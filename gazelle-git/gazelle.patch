diff --git a/Makefile b/Makefile
index ac313fe..6aa0405 100644
--- a/Makefile
+++ b/Makefile
@@ -3,6 +3,7 @@ PREFIX ?= /usr
 BINDIR := $(DESTDIR)$(PREFIX)/bin
 LIBDIR := $(DESTDIR)$(PREFIX)/lib
 INCDIR := $(DESTDIR)$(PREFIX)/include
+DOCDIR := $(DESTDIR)$(PREFIX)/share/doc

 IMGDIR := /usr/share/asciidoc/images

@@ -15,6 +16,11 @@ else
   CFLAGS += $(strip $(shell pkg-config --silence-errors --cflags lua || pkg-config --cflags lua5.1))
   LDFLAGS := $(strip $(shell pkg-config --silence-errors --libs lua || pkg-config --libs lua5.1))
 endif
+ifeq ($(HOSTTYPE), x86_64)
+  LUACLUABITS := 64
+else
+  LUACLUABITS := 32
+endif
 ADFLAGS := -a toc -a toclevels=3 -a icons -a iconsdir=.

 export LUA_PATH := $(CURDIR)/compiler/?.lua;$(CURDIR)/sketches/?.lua;$(CURDIR)/tests/?.lua
@@ -34,6 +40,7 @@ LUALIB := lang_ext/lua/bc_read_stream.so lang_ext/lua/gazelle.so
 LIB := $(LUALIB) runtime/libgazelle.a
 INC := $(wildcard runtime/include/gazelle/*.h)
 IMG := $(foreach img,$(wildcard $(IMGDIR)/*.png),docs/images/$(notdir $(img)))
+DOC := $(wildcard docs/*.html docs/*.gif docs/*.png)

 .PHONY: all clean doc install test

@@ -66,6 +73,7 @@ utilities/gzlparse: utilities/gzlparse.o $(RTOBJ)

 gzlc: utilities/luac.lua utilities/srlua utilities/srlua-glue \
       compiler/gzlc | $(LUASRC) sketches/pp.lua sketches/dump_to_html.lua
+	sed -i 's/^local bits=[36][24]$$/local bits=$(LUACLUABITS)/' utilities/luac.lua
 	lua utilities/luac.lua compiler/gzlc -L $|
 	./utilities/srlua-glue ./utilities/srlua luac.out $@
 	chmod a+x gzlc
@@ -84,14 +92,16 @@ doc: $(IMG) docs/images docs/manual.html
 test:
 	lua tests/run_tests.lua

-install: gzlc utilities/gzlparse runtime/libgazelle.a $(INC)
-	install -d -o root -g root $(BINDIR)
-	install -m 0755 -o root -g root gzlc $(BINDIR)
-	install -m 0755 -o root -g root utilities/gzlparse $(BINDIR)
-	install -d -o root -g root $(LIBDIR)
-	install -m 0644 -o root -g root runtime/libgazelle.a $(LIBDIR)
+install: gzlc utilities/gzlparse runtime/libgazelle.a $(INC) $(DOC)
+	install -d $(BINDIR)
+	install -m 0755 gzlc $(BINDIR)
+	install -m 0755 utilities/gzlparse $(BINDIR)
+	install -d $(LIBDIR)
+	install -m 0644 runtime/libgazelle.a $(LIBDIR)
 	install -d $(INCDIR)/gazelle
-	install -m 0644 -o root -g root $(INC) $(INCDIR)/gazelle
+	install -m 0644 $(INC) $(INCDIR)/gazelle
+	install -d $(DOCDIR)/gazelle
+	install -m 0644 $(DOC) $(DOCDIR)/gazelle

 clean:
 	$(RM) $(OBJ)
diff --git a/docs/gzl-rtn-graph b/docs/gzl-rtn-graph
index 4e6c756..40a7166
--- a/docs/gzl-rtn-graph
+++ b/docs/gzl-rtn-graph
@@ -19,10 +19,9 @@ function escape(str)
   return str:gsub("[\"\\]", "\\%1")
 end

-grammar = parse_grammar(CharStream:new(io.stdin:read("*a")))
-if grammar.rtns:count() ~= 1 then
-  error("This filter can only deal with grammars that have a single nonterminal")
-end
+grammar = Grammar:new()
+grammar:parse_source_string(io.stdin:read("*a"))
+grammar:process()
 for _nonterm, _rtn in grammar.rtns:each() do
   nonterm = _nonterm
   rtn = _rtn
@@ -45,9 +44,6 @@ for state in each(rtn:states()) do
     if fa.is_nonterm(edge_val) then
       outfile:write(string.format('  "%s" -> "%s" [label="<%s>"]\n', tostring(state), tostring(target_state), escape(edge_val.name)))
     else
-      if grammar.attributes.regex_text[edge_val] then
-        edge_val = "/" .. grammar.attributes.regex_text[edge_val] .. "/"
-      end
       outfile:write(string.format('  "%s" -> "%s" [label="%s"]\n', tostring(state), tostring(target_state), escape(edge_val)))
     end
   end
diff --git a/docs/manual.txt b/docs/manual.txt
index 170f44f..eba0d99 100644
--- a/docs/manual.txt
+++ b/docs/manual.txt
@@ -293,6 +293,8 @@ graph is just a single path.

 ["simplerule1.png", "graph 1: assign -> ident \"=\" expr;"]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ident -> "lit_ident";
+expr -> "lit_expr";
 assign -> ident "=" expr;
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@@ -332,6 +334,11 @@ rule are what you intended.

 ["altrule2.png", "graph for: name -> (fname (mname | minitial) | nickname) surname"]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+fname -> "lit_fname";
+mname -> "lit_mname";
+minitial -> "lit_minitial";
+nickname -> "lit_nickname";
+surname -> "lit_surname";
 name -> (fname (mname | minitial) | nickname) surname;
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@@ -382,6 +389,8 @@ object   -> "{" (string ":" value) *(",") "}";

 ["reprule1.png", "Graph for the above JSON object expression."]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+string -> "lit_string";
+value -> "lit_value";
 object   -> "{" (string ":" value) *(",") "}";
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@@ -1045,6 +1054,8 @@ same JSON rule as the first example:

 ["json.png", "Gazelle's graph of the JSON rule above"]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+string -> "lit_string";
+value -> "lit_value";
 object -> "{" (string ":" value) *(,) "}";
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@@ -1099,6 +1110,8 @@ the input imply what transitions.  For example, consider the rule:

 ["hardrule1.png", "graph 3: word -> numbers | letters;"]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+numbers -> "lit_numbers";
+letters -> "lit_letters";
 word -> numbers | letters;
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

@@ -1113,6 +1126,7 @@ in a final state that has transitions out of it?  Consider this rule:

 ["hardrule2.png", "graph 3: sentence -> word*;"]
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+word -> "lit_word";
 sentence -> word*;
 gzl-rtn-graph~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

diff --git a/sketches/dump_to_html.lua b/sketches/dump_to_html.lua
index 5fb8f7d..e70b102 100644
--- a/sketches/dump_to_html.lua
+++ b/sketches/dump_to_html.lua
@@ -160,6 +160,7 @@ function dump_to_html(src_file, grammar, dir)
     intfa_file:close()
     os.execute(string.format("dot -Tpng -o %s %s", png_file, dot_file))
     local w = 800
+    local h = 600
     if have_imagemagick then
       local img_info = io.popen(string.format("identify %s", png_file)):read("*a")
       w, h = string.match(img_info, "[^ ]+ [^ ]+ (%d+)x(%d+)")
diff --git a/utilities/luac.lua b/utilities/luac.lua
index a3baa38..5b225c5 100644
--- a/utilities/luac.lua
+++ b/utilities/luac.lua
@@ -15,6 +15,7 @@

 local MARK="////////"
 local NAME="luac"
+local bits=32

 local OUTPUT=NAME..".out"
 NAME="=("..NAME..")"
@@ -48,7 +49,7 @@ end

 b=string.dump(assert(loadstring(b,NAME)))
 local x,y=string.find(b,MARK)
-b=string.sub(b,1,x-6).."\0"..string.sub(b,y+2,y+5)
+b=string.sub(b,1,x-2-bits/8).."\0"..string.sub(b,y+2,y+5)

 f=assert(io.open(OUTPUT,"wb"))
 assert(f:write(b))
@@ -58,5 +59,5 @@ end
 for i=1,m do
 	assert(f:write(arg[i]))
 end
-assert(f:write(string.rep("\0",12)))
+assert(f:write(string.rep("\0", 3*bits/8)))
 assert(f:close())
diff --git a/utilities/srlua.c b/utilities/srlua.c
index b67e625..1e00ec4 100644
--- a/utilities/srlua.c
+++ b/utilities/srlua.c
@@ -2,7 +2,7 @@
 * srlua.c
 * Lua interpreter for self-running programs
 * Luiz Henrique de Figueiredo <lhf@tecgraf.puc-rio.br>
-* 28 Apr 2006 23:01:50
+* 20 Mar 2009 21:05:59
 * This code is hereby placed in the public domain.
 */
 
@@ -14,12 +14,20 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
 
 #include "srlua-glue.h"
 #include "lua.h"
 #include "lualib.h"
 #include "lauxlib.h"
 
+#ifndef PATH_MAX
+#define PATH_MAX 512
+#endif
+
 typedef struct
 {
  FILE *f;
@@ -27,6 +35,77 @@ typedef struct
  char buff[512];
 } State;
 
+/* int checkifexecutable(const char *filename)
+ *
+ * Return non-zero if the name is an executable file, and
+ * zero if it is not executable, or if it does not exist.
+ */
+
+int checkifexecutable(const char *filename)
+{
+     int result;
+     struct stat statinfo;
+
+     result = stat(filename, &statinfo);
+     if (result < 0) return 0;
+     if (!S_ISREG(statinfo.st_mode)) return 0;
+
+     if (statinfo.st_uid == geteuid()) return statinfo.st_mode & S_IXUSR;
+     if (statinfo.st_gid == getegid()) return statinfo.st_mode & S_IXGRP;
+     return statinfo.st_mode & S_IXOTH;
+}
+
+
+/* int findpathof(char *pth, const char *exe)
+ *
+ * Find executable by searching the PATH environment variable.
+ *
+ * const char *exe - executable name to search for.
+ *       char *pth - the path found is stored here, space
+ *                   needs to be available.
+ *
+ * If a path is found, returns non-zero, and the path is stored
+ * in pth.  If exe is not found returns 0, with pth undefined.
+ */
+
+int findpathof(char *pth, const char *exe)
+{
+     char *searchpath;
+     char *beg, *end;
+     int stop, found;
+     int len;
+
+     if (strchr(exe, '/') != NULL) {
+	  if (realpath(exe, pth) == NULL) return 0;
+	  return  checkifexecutable(pth);
+     }
+
+     searchpath = getenv("PATH");
+     if (searchpath == NULL) return 0;
+     if (strlen(searchpath) <= 0) return 0;
+
+     beg = searchpath;
+     stop = 0; found = 0;
+     do {
+	  end = strchr(beg, ':');
+	  if (end == NULL) {
+	       stop = 1;
+	       strncpy(pth, beg, PATH_MAX);
+	       len = strlen(pth);
+	  } else {
+	       strncpy(pth, beg, end - beg);
+	       pth[end - beg] = '\0';
+	       len = end - beg;
+	  }
+	  if (pth[len - 1] != '/') strncat(pth, "/", 1);
+	  strncat(pth, exe, PATH_MAX - len);
+	  found = checkifexecutable(pth);
+	  if (!stop) beg = end + 1;
+     } while (!stop && !found);
+
+     return found;
+}
+
 static const char *myget(lua_State *L, void *data, size_t *size)
 {
  State* s=data;
@@ -53,29 +132,32 @@ static void load(lua_State *L, const char *name)
  if (memcmp(t.sig,GLUESIG,GLUELEN)!=0) luaL_error(L,"no Lua program found in %s",name);
  if (fseek(f,t.size1,SEEK_SET)!=0) cannot("seek");
  S.f=f; S.size=t.size2;
- if (lua_load(L,myget,&S,name)!=0) lua_error(L);
+ if (lua_load(L,myget,&S,"=")!=0) lua_error(L);
  fclose(f);
 }
 
 static int pmain(lua_State *L)
 {
  char **argv=lua_touserdata(L,1);
+ char path[PATH_MAX+1];
  int i;
+ lua_gc(L,LUA_GCSTOP,0);
  luaL_openlibs(L);
- load(L,argv[0]);
- lua_newtable(L);
+ lua_gc(L,LUA_GCRESTART,0);
+ if(!findpathof(path, argv[0])){
+  fprintf(stderr, "%s not found in path", argv[0]);
+  return 1;
+ }
+ load(L,path);
+ for (i=1; argv[i]; i++) ; /* count */
+ lua_createtable(L,i-1,1);
  for (i=0; argv[i]; i++)
  {
   lua_pushstring(L,argv[i]);
   lua_rawseti(L,-2,i);
  }
- lua_pushliteral(L,"n");
- lua_pushnumber(L,i-1);
- lua_rawset(L,-3);
  lua_setglobal(L,"arg");
- lua_pushstring(L,argv[0]);
- lua_setglobal(L,"_PROGNAME");
- luaL_checkstack(L, i, "too many arguments to script");
+ luaL_checkstack(L,i-1,"too many arguments to script");
  for (i=1; argv[i]; i++)
  {
   lua_pushstring(L,argv[i]);
@@ -84,31 +166,27 @@ static int pmain(lua_State *L)
  return 0;
 }
 
+static void fatal(const char* progname, const char* message)
+{
 #ifdef _WIN32
-#define report(s) MessageBox(NULL,s,argv[0], MB_ICONERROR | MB_OK)
+ MessageBox(NULL,message,progname,MB_ICONERROR | MB_OK);
 #else
-#define report(s) fprintf(stderr,"%s: %s\n",argv[0],s)
+ fprintf(stderr,"%s: %s\n",progname,message);
 #endif
+ exit(EXIT_FAILURE);
+}
 
 int main(int argc, char *argv[])
 {
  lua_State *L;
 #ifdef _WIN32
  char name[MAX_PATH];
- if (GetModuleFileName(NULL,name,sizeof(name))==0)
- {
-  report("cannot locate this executable");
-  return EXIT_FAILURE;
- }
- argv[0]=name;
+ argv[0]= GetModuleFileName(NULL,name,sizeof(name)) ? name : NULL;
 #endif
+ if (argv[0]==NULL) fatal("srlua","cannot locate this executable");
  L=lua_open();
- if (L==NULL)
- {
-  report("not enough memory for state");
-  return EXIT_FAILURE;
- }
- if (lua_cpcall(L,pmain,argv)) report(lua_tostring(L,-1));
+ if (L==NULL) fatal(argv[0],"not enough memory for state");
+ if (lua_cpcall(L,pmain,argv)) fatal(argv[0],lua_tostring(L,-1));
  lua_close(L);
  return EXIT_SUCCESS;
 }
