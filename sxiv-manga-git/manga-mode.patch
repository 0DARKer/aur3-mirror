diff --git a/commands.c b/commands.c
index 0ab1944..2c2070f 100644
--- a/commands.c
+++ b/commands.c
@@ -267,6 +267,35 @@ bool i_scroll_to_edge(arg_t a)
 		return false;
 }
 
+bool i_scroll_to_edge_seq(arg_t a)
+{
+	if (mode == MODE_IMAGE) {
+		switch (img.edgedir) {
+			case 1:
+				img.edgedir++;
+				img_pan_edge(&img, DIR_DOWN);
+				break;
+			case 2:
+				img.edgedir++;
+				img_pan_edge(&img, DIR_UP);
+				img_pan_edge(&img, DIR_LEFT);
+				break;
+			case 3:
+				img.edgedir++;
+				img_pan_edge(&img, DIR_DOWN);
+				break;
+			case 4:
+				img.edgedir = 1;
+				img_pan_edge(&img, DIR_UP);
+				img_pan_edge(&img, DIR_RIGHT);
+				break;
+		}
+		return true;
+	} else {
+		return false;
+	}
+}
+
 /* Xlib helper function for i_drag() */
 Bool is_motionnotify(Display *d, XEvent *e, XPointer a)
 {
diff --git a/commands.h b/commands.h
index 7a6752f..efed65d 100644
--- a/commands.h
+++ b/commands.h
@@ -57,6 +57,7 @@ bool i_toggle_animation(arg_t);
 bool it_scroll_move(arg_t);
 bool it_scroll_screen(arg_t);
 bool i_scroll_to_edge(arg_t);
+bool i_scroll_to_edge_seq(arg_t);
 bool i_drag(arg_t);
 bool i_zoom(arg_t);
 bool i_set_zoom(arg_t);
diff --git a/config.def.h b/config.def.h
index cd89b5f..2eddadf 100644
--- a/config.def.h
+++ b/config.def.h
@@ -103,6 +103,7 @@ static const keymap_t keys[] = {
 	{ false,  XK_J,             i_scroll_to_edge,     (arg_t) DIR_DOWN },
 	{ false,  XK_K,             i_scroll_to_edge,     (arg_t) DIR_UP },
 	{ false,  XK_L,             i_scroll_to_edge,     (arg_t) DIR_RIGHT },
+	{ false,  XK_m,             i_scroll_to_edge_seq, (arg_t) None },
 
 	{ false,  XK_plus,          i_zoom,               (arg_t) +1 },
 	{ false,  XK_KP_Add,        i_zoom,               (arg_t) +1 },
diff --git a/image.c b/image.c
index 7e3329a..b1e5c65 100644
--- a/image.c
+++ b/image.c
@@ -417,10 +417,11 @@ void img_render(img_t *img)
 	if (!img->re) {
 		/* rendered for the first time */
 		img->re = true;
+		img->edgedir = 1;
 		if (img->zoom * img->w <= win->w)
 			img->x = (win->w - img->w * img->zoom) / 2;
 		else
-			img->x = 0;
+			img->x = options->manga_mode ? (win->w - img->w * img->zoom) : 0;
 		if (img->zoom * img->h <= win->h)
 			img->y = (win->h - img->h * img->zoom) / 2;
 		else
diff --git a/image.h b/image.h
index dbb249e..a28c430 100644
--- a/image.h
+++ b/image.h
@@ -54,6 +54,7 @@ typedef struct {
 	bool dirty;
 	bool aa;
 	bool alpha;
+	int edgedir;
 
 	multi_img_t multi;
 } img_t;
diff --git a/options.c b/options.c
index 2d35992..b251b53 100644
--- a/options.c
+++ b/options.c
@@ -33,7 +33,7 @@ const options_t *options = (const options_t*) &_options;
 
 void print_usage(void)
 {
-	printf("usage: sxiv [-bcdFfhiopqrstvZ] [-g GEOMETRY] [-n NUM] "
+	printf("usage: sxiv [-bcdFfhimopqrstvZ] [-g GEOMETRY] [-n NUM] "
 	       "[-N name] [-z ZOOM] FILES...\n");
 }
 
@@ -63,9 +63,10 @@ void parse_options(int argc, char **argv)
 
 	_options.quiet = false;
 	_options.thumb_mode = false;
+	_options.manga_mode = false;
 	_options.clean_cache = false;
 
-	while ((opt = getopt(argc, argv, "bcdFfg:hin:N:opqrstvZz:")) != -1) {
+	while ((opt = getopt(argc, argv, "bcdFfg:hin:N:mopqrstvZz:")) != -1) {
 		switch (opt) {
 			case '?':
 				print_usage();
@@ -94,6 +95,11 @@ void parse_options(int argc, char **argv)
 			case 'i':
 				_options.from_stdin = true;
 				break;
+			case 'm':
+				_options.manga_mode = true;
+				_options.scalemode = SCALE_ZOOM;
+				_options.zoom = 1.0;
+				break;
 			case 'n':
 				if (sscanf(optarg, "%d", &t) <= 0 || t < 1) {
 					fprintf(stderr, "sxiv: invalid argument for option -n: %s\n",
diff --git a/options.h b/options.h
index d60bc9a..deefd14 100644
--- a/options.h
+++ b/options.h
@@ -46,6 +46,7 @@ typedef struct {
 	/* misc flags: */
 	bool quiet;
 	bool thumb_mode;
+	bool manga_mode;
 	bool clean_cache;
 } options_t;
 
diff --git a/sxiv.1 b/sxiv.1
index 85872e3..96dd27d 100644
--- a/sxiv.1
+++ b/sxiv.1
@@ -49,6 +49,10 @@ Set window position and size. See section GEOMETRY SPECIFICATIONS of X(7) for
 more information on
 .IR GEOMETRY .
 .TP
+.BI "\-m "
+Start in manga mode, scale all images to 100% and read images from right to
+left.
+.TP
 .BI "\-n " NUM
 Start at picture number NUM.
 .TP
@@ -243,6 +247,9 @@ Pan to top image edge.
 .B L
 Pan to right image edge.
 .TP
+.B m
+Pan in manga way (topright, bottomright, topleft, bottomleft).
+.TP
 .BR Ctrl-h ", " Ctrl-Left
 Pan image one window width left.
 .TP
