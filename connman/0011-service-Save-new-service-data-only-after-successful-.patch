From 50fb779bc959e9ec853297c532a2211190534a5d Mon Sep 17 00:00:00 2001
From: Jukka Rissanen <jukka.rissanen@linux.intel.com>
Date: Fri, 20 Apr 2012 14:38:56 +0300
Subject: [PATCH 11/11] service: Save new service data only after successful
 connect

The data for new service was saved into disk (with Favorite=false)
even if the first connection failed. This is now changed and
service data is only saved if user has been able to connect to a
service at least once.
---
 src/service.c |   33 ++++++++++++++++++++++++++++++---
 1 file changed, 30 insertions(+), 3 deletions(-)

diff --git a/src/service.c b/src/service.c
index d14431a..c9ec6b3 100644
--- a/src/service.c
+++ b/src/service.c
@@ -116,6 +116,7 @@ struct connman_service {
 	connman_bool_t wps;
 	int online_check_count;
 	connman_bool_t do_split_routing;
+	connman_bool_t new_service;
 };
 
 struct find_data {
@@ -322,8 +323,11 @@ static int service_load(struct connman_service *service)
 	DBG("service %p", service);
 
 	keyfile = connman_storage_load_service(service->identifier);
-	if (keyfile == NULL)
+	if (keyfile == NULL) {
+		service->new_service = TRUE;
 		return -EIO;
+	} else
+		service->new_service = FALSE;
 
 	switch (service->type) {
 	case CONNMAN_SERVICE_TYPE_UNKNOWN:
@@ -496,7 +500,10 @@ static int service_save(struct connman_service *service)
 	const char *cst_str = NULL;
 	int err = 0;
 
-	DBG("service %p", service);
+	DBG("service %p new %d", service, service->new_service);
+
+	if (service->new_service == TRUE)
+		return -ESRCH;
 
 	keyfile = __connman_storage_open_service(service->identifier);
 	if (keyfile == NULL)
@@ -4487,7 +4494,12 @@ static int service_indicate_state(struct connman_service *service)
 	}
 
 	if (new_state == CONNMAN_SERVICE_STATE_CONFIGURATION) {
-		if (__connman_stats_service_register(service) == 0) {
+		if (service->new_service == FALSE &&
+				__connman_stats_service_register(service) == 0) {
+			/*
+			 * For new services the statistics are updated after
+			 * we have successfully connected.
+			 */
 			__connman_stats_get(service, FALSE,
 						&service->stats.data);
 			__connman_stats_get(service, TRUE,
@@ -4508,6 +4520,21 @@ static int service_indicate_state(struct connman_service *service)
 	if (new_state == CONNMAN_SERVICE_STATE_READY) {
 		enum connman_ipconfig_method method;
 
+		if (service->new_service == TRUE &&
+				__connman_stats_service_register(service) == 0) {
+			/*
+			 * This is normally done after configuring state
+			 * but for new service do this after we have connected
+			 * successfully.
+			 */
+			__connman_stats_get(service, FALSE,
+						&service->stats.data);
+			__connman_stats_get(service, TRUE,
+						&service->stats_roaming.data);
+		}
+
+		service->new_service = FALSE;
+
 		service_update_preferred_order(def_service, service, new_state);
 
 		set_reconnect_state(service, TRUE);
-- 
1.7.10

