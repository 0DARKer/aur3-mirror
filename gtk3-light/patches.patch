Description: Don't let offscreen widget do grabbing
Author: Cody Russell <bratsche@gnome.org>
Bug: https://bugzilla.gnome.org/show_bug.cgi?id=607668
Bug-Ubuntu: https://bugs.launchpad.net/bugs/512427

Index: gtk+-3.5.18/gtk/gtkmain.c
===================================================================
--- gtk+-3.5.18.orig/gtk/gtkmain.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.5.18/gtk/gtkmain.c	2012-09-19 12:16:53.696728253 +1200
@@ -2046,9 +2046,14 @@
 {
   GtkWindowGroup *group;
   GtkWidget *old_grab_widget;
+  GtkWidget *toplevel;
 
   g_return_if_fail (widget != NULL);
 
+  toplevel = gtk_widget_get_toplevel (widget);
+  if (toplevel && gdk_window_get_window_type (gtk_widget_get_window (toplevel)) == GDK_WINDOW_OFFSCREEN)
+    return;
+
   if (!gtk_widget_has_grab (widget) && gtk_widget_is_sensitive (widget))
     {
       _gtk_widget_set_has_grab (widget, TRUE);
Description: Do not allow devices in an offscreen hierarchy to take grabs.
Author: Robert Carr <racarr@canonical.com>
Bug: https://bugzilla.gnome.org/show_bug.cgi?id=658563
Bug-Ubuntu: https://launchpad.net/bugs/804009

Index: gtk+-3.5.18/gtk/gtkmain.c
===================================================================
--- gtk+-3.5.18.orig/gtk/gtkmain.c	2012-09-19 12:16:53.696728253 +1200
+++ gtk+-3.5.18/gtk/gtkmain.c	2012-09-19 12:16:57.224728130 +1200
@@ -2139,9 +2139,14 @@
 {
   GtkWindowGroup *group;
   GtkWidget *old_grab_widget;
+  GdkWindow *toplevel;
 
   g_return_if_fail (GTK_IS_WIDGET (widget));
   g_return_if_fail (GDK_IS_DEVICE (device));
+  
+  toplevel = gdk_window_get_toplevel (gtk_widget_get_window (widget));
+  if (toplevel && gdk_window_get_window_type (toplevel) == GDK_WINDOW_OFFSCREEN)
+    return;
 
   group = gtk_main_get_window_group (widget);
   old_grab_widget = gtk_window_group_get_current_device_grab (group, device);
From 7785c99603e754d6c20a7923450d7a19eed0cd07 Mon Sep 17 00:00:00 2001
From: Martin Pitt <martin.pitt@ubuntu.com>
Date: Thu, 8 Sep 2011 09:14:02 +0200
Subject: [PATCH] Consistently treat gdkenumtypes.[hc] as source files

Always generate gdk/gdkenumtypes.c in the source tree, and fix path in the
introspection sources. With this, gdkenumtypes.c is correctly included with
separate build trees, too. This fixes missing GTypes in the .gir when using a
separate build tree.

Also remove the gdk/stamp-gdkenumtypes.h target. It was forcing the
regeneration of gdk/gdkenumtypes.h even if it was already present and current
in the source tree.

Bug: https://bugzilla.gnome.org/show_bug.cgi?id=647729
Bug-Ubuntu: https://launchpad.net/bugs/769256
---
 gdk/Makefile.am |   17 +++++++----------
 1 files changed, 7 insertions(+), 10 deletions(-)

Index: gtk+-3.5.4/gdk/Makefile.am
===================================================================
--- gtk+-3.5.4.orig/gdk/Makefile.am	2012-06-05 16:59:15.892579046 +1200
+++ gtk+-3.5.4/gdk/Makefile.am	2012-06-05 16:59:22.904578803 +1200
@@ -189,8 +189,8 @@
 introspection_files = 		\
 	$(filter-out gdkkeysyms-compat.h, $(gdk_public_h_sources))	\
 	$(gdk_c_sources)	\
-        gdkenumtypes.c		\
-        gdkenumtypes.h
+        $(srcdir)/gdkenumtypes.c	\
+        $(srcdir)/gdkenumtypes.h
 
 Gdk-3.0.gir: libgdk-3.la Makefile
 Gdk_3_0_gir_SCANNERFLAGS = 	\
@@ -305,7 +305,7 @@
 
 lib_LTLIBRARIES = libgdk-3.la
 
-MAINTAINERCLEANFILES = $(gdk_built_sources) stamp-gdkenumtypes.h
+MAINTAINERCLEANFILES = $(gdk_built_sources)
 EXTRA_DIST += \
 	$(gdk_built_sources)	\
 	fallback-c89.c
@@ -319,18 +319,15 @@
 	$(gdk_built_sources)			\
 	gdkconfig.h
 
-gdkenumtypes.h: stamp-gdkenumtypes.h
-	@true
-stamp-gdkenumtypes.h: @REBUILD@ $(gdk_public_h_sources) gdkenumtypes.h.template
+gdkenumtypes.h: @REBUILD@ $(gdk_public_h_sources) $(srcdir)/gdkenumtypes.h.template
 	$(AM_V_GEN) ( cd $(srcdir) && $(GLIB_MKENUMS) --template gdkenumtypes.h.template \
 		$(gdk_public_h_sources) ) >> xgen-geth \
-	&& (cmp -s xgen-geth gdkenumtypes.h || cp xgen-geth gdkenumtypes.h ) \
-	&& rm -f xgen-geth \
-	&& echo timestamp > $(@F)
+	&& (cmp -s xgen-geth gdkenumtypes.h || cp xgen-geth $(srcdir)/gdkenumtypes.h ) \
+	&& rm -f xgen-geth 
 gdkenumtypes.c: @REBUILD@ $(gdk_public_h_sources) gdkenumtypes.c.template
 	$(AM_V_GEN) ( cd $(srcdir) && $(GLIB_MKENUMS) --template gdkenumtypes.c.template \
 		$(gdk_public_h_sources) ) > xgen-getc \
-	&& cp xgen-getc gdkenumtypes.c  \
+	&& cp xgen-getc $(srcdir)/gdkenumtypes.c  \
 	&& rm -f xgen-getc
 
 #
Bug-Ubuntu: https://bugs.launchpad.net/ubuntu/+source/m17n-db/+bug/191451

Index: gtk+3.0-3.3.20/modules/input/imviqr.c
===================================================================
--- gtk+3.0-3.3.20.orig/modules/input/imviqr.c	2012-03-18 21:44:22.000000000 +0100
+++ gtk+3.0-3.3.20/modules/input/imviqr.c	2012-03-20 18:48:18.101061455 +0100
@@ -242,7 +242,7 @@
   N_("Vietnamese (VIQR)"), /* Human readable name */
   GETTEXT_PACKAGE,	   /* Translation domain */
    GTK_LOCALEDIR,	   /* Dir for bindtextdomain (not strictly needed for "gtk+") */
-  "vi"			   /* Languages for which this module is the default */
+  ""			   /* Languages for which this module is the default */
 };
 
 static const GtkIMContextInfo *info_list[] = {
Origin: vendor, Debian

Index: gtk+-3.2.2/gtk/gtkcalendar.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkcalendar.c	2011-11-07 19:47:34.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkcalendar.c	2011-11-13 02:59:34.922905814 +0100
@@ -3161,6 +3161,10 @@
 {
   GtkCalendar *calendar = GTK_CALENDAR (widget);
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   if (event->direction == GDK_SCROLL_UP)
     {
       if (!gtk_widget_has_focus (widget))
Index: gtk+-3.2.2/gtk/gtkcombobox.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkcombobox.c	2011-11-11 23:39:31.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkcombobox.c	2011-11-13 02:59:34.926905815 +0100
@@ -3002,6 +3002,10 @@
   GtkTreeIter iter;
   GtkTreeIter new_iter;
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   if (!gtk_combo_box_get_active_iter (combo_box, &iter))
     return TRUE;
 
Index: gtk+-3.2.2/gtk/gtkmenu.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkmenu.c	2011-11-11 23:39:31.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkmenu.c	2011-11-13 02:59:34.930905815 +0100
@@ -3954,6 +3954,10 @@
 {
   GtkMenu *menu = GTK_MENU (widget);
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   switch (event->direction)
     {
     case GDK_SCROLL_RIGHT:
Index: gtk+-3.2.2/gtk/gtknotebook.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtknotebook.c	2011-11-12 03:52:24.000000000 +0100
+++ gtk+-3.2.2/gtk/gtknotebook.c	2011-11-13 02:59:34.934905815 +0100
@@ -345,6 +345,8 @@
                                               GtkAllocation    *allocation);
 static gint gtk_notebook_draw                (GtkWidget        *widget,
                                               cairo_t          *cr);
+static gboolean gtk_notebook_scroll          (GtkWidget        *widget,
+                                              GdkEventScroll   *event);
 static gint gtk_notebook_button_press        (GtkWidget        *widget,
                                               GdkEventButton   *event);
 static gint gtk_notebook_button_release      (GtkWidget        *widget,
@@ -648,6 +650,7 @@
   widget_class->get_preferred_height_for_width = gtk_notebook_get_preferred_height_for_width;
   widget_class->size_allocate = gtk_notebook_size_allocate;
   widget_class->draw = gtk_notebook_draw;
+  widget_class->scroll_event = gtk_notebook_scroll;
   widget_class->button_press_event = gtk_notebook_button_press;
   widget_class->button_release_event = gtk_notebook_button_release;
   widget_class->popup_menu = gtk_notebook_popup_menu;
@@ -1887,7 +1890,8 @@
   attributes.event_mask = gtk_widget_get_events (widget);
   attributes.event_mask |= (GDK_BUTTON_PRESS_MASK |
                             GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK |
-                            GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK);
+                            GDK_POINTER_MOTION_MASK | GDK_LEAVE_NOTIFY_MASK |
+                            GDK_SCROLL_MASK);
   attributes_mask = GDK_WA_X | GDK_WA_Y;
 
   priv->event_window = gdk_window_new (gtk_widget_get_parent_window (widget),
@@ -2810,6 +2814,38 @@
     return FALSE;
 }
 
+static gboolean
+gtk_notebook_scroll (GtkWidget      *widget,
+                     GdkEventScroll *event)
+{
+  GtkNotebook *notebook = GTK_NOTEBOOK (widget);
+  GtkNotebookPrivate *priv = notebook->priv;
+  gint i;
+
+  if (!priv->cur_page)
+    return FALSE;
+
+  /* Only actually scroll when Mod1 is pressed.
+     This allows us to scroll from the page contents
+     or the action area too */
+  if (!(event->state & GDK_MOD1_MASK))
+    return FALSE;
+
+  switch (event->direction)
+    {
+    case GDK_SCROLL_RIGHT:
+    case GDK_SCROLL_DOWN:
+      gtk_notebook_next_page (notebook);
+      break;
+    case GDK_SCROLL_LEFT:
+    case GDK_SCROLL_UP:
+      gtk_notebook_prev_page (notebook);
+      break;
+    }
+
+  return TRUE;
+}
+
 static GList*
 get_tab_at_pos (GtkNotebook *notebook, gint x, gint y)
 {
Index: gtk+-3.2.2/gtk/gtkpathbar.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkpathbar.c	2011-11-07 19:47:35.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkpathbar.c	2011-11-13 02:59:34.938905813 +0100
@@ -757,6 +757,10 @@
 gtk_path_bar_scroll (GtkWidget      *widget,
 		     GdkEventScroll *event)
 {
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   switch (event->direction)
     {
     case GDK_SCROLL_RIGHT:
Index: gtk+-3.2.2/gtk/gtkrange.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkrange.c	2011-11-11 23:39:31.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkrange.c	2011-11-13 02:59:34.938905813 +0100
@@ -2748,6 +2748,10 @@
   GtkRange *range = GTK_RANGE (widget);
   GtkRangePrivate *priv = range->priv;
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   if (gtk_widget_get_realized (widget))
     {
       gdouble delta;
Index: gtk+-3.2.2/gtk/gtkscalebutton.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkscalebutton.c	2011-11-11 23:39:31.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkscalebutton.c	2011-11-13 02:59:34.942905810 +0100
@@ -848,6 +848,10 @@
   if (event->type != GDK_SCROLL)
     return FALSE;
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   d = gtk_scale_button_get_value (button);
   if (event->direction == GDK_SCROLL_UP)
     {
Index: gtk+-3.2.2/gtk/gtkspinbutton.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtkspinbutton.c	2011-11-11 23:39:31.000000000 +0100
+++ gtk+-3.2.2/gtk/gtkspinbutton.c	2011-11-13 02:59:34.946905809 +0100
@@ -1181,6 +1181,10 @@
   GtkSpinButton *spin = GTK_SPIN_BUTTON (widget);
   GtkSpinButtonPrivate *priv = spin->priv;
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   if (event->direction == GDK_SCROLL_UP)
     {
       if (!gtk_widget_has_focus (widget))
Index: gtk+-3.2.2/gtk/gtktreeview.c
===================================================================
--- gtk+-3.2.2.orig/gtk/gtktreeview.c	2011-11-13 02:59:31.902905921 +0100
+++ gtk+-3.2.2/gtk/gtktreeview.c	2011-11-13 02:59:34.950905810 +0100
@@ -15106,6 +15106,10 @@
 {
   gboolean retval = FALSE;
 
+  /* Ignore Alt-scroll to allow it to be taken by GtkNotebook */
+  if (event->state & GDK_MOD1_MASK)
+    return FALSE;
+
   if (event->direction == GDK_SCROLL_UP)
     {
       gtk_tree_view_search_move (widget, tree_view, TRUE);
## Description: add some description
## Origin/Author: add some origin or author
## Bug: bug URL
Description: Add GtkMenuProxy support for remoting menus.

Index: gtk+-3.6.0/gtk/gtk.h
===================================================================
--- gtk+-3.6.0.orig/gtk/gtk.h	2012-09-19 03:34:41.000000000 +1200
+++ gtk+-3.6.0/gtk/gtk.h	2012-09-25 11:55:59.152154117 +1200
@@ -74,6 +74,8 @@
 #include <gtk/gtkcellview.h>
 #include <gtk/gtkcheckbutton.h>
 #include <gtk/gtkcheckmenuitem.h>
+#include <gtk/ubuntumenuproxy.h>
+#include <gtk/ubuntumenuproxymodule.h>
 #include <gtk/gtkclipboard.h>
 #include <gtk/gtkcolorbutton.h>
 #include <gtk/gtkcolorchooser.h>
Index: gtk+-3.6.0/gtk/gtkmenubar.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkmenubar.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkmenubar.c	2012-09-25 11:55:59.172154117 +1200
@@ -65,9 +65,9 @@
 {
   GtkPackDirection pack_direction;
   GtkPackDirection child_pack_direction;
+  gboolean shell_shows;
 };
 
-
 static void gtk_menu_bar_set_property      (GObject             *object,
 					    guint                prop_id,
 					    const GValue        *value,
@@ -92,10 +92,14 @@
                                                          gint         *natural);
 static void gtk_menu_bar_size_allocate     (GtkWidget       *widget,
 					    GtkAllocation   *allocation);
+static void gtk_menu_bar_realize           (GtkWidget *widget);
+static void gtk_menu_bar_unrealize         (GtkWidget *widget);
 static gint gtk_menu_bar_draw              (GtkWidget       *widget,
                                             cairo_t         *cr);
 static void gtk_menu_bar_hierarchy_changed (GtkWidget       *widget,
 					    GtkWidget       *old_toplevel);
+static gboolean gtk_menu_bar_can_activate_accel (GtkWidget *widget,
+                                                 guint      signal_id);
 static gint gtk_menu_bar_get_popup_delay   (GtkMenuShell    *menu_shell);
 static void gtk_menu_bar_move_current      (GtkMenuShell     *menu_shell,
                                             GtkMenuDirectionType direction);
@@ -125,10 +129,11 @@
   widget_class->get_preferred_width_for_height = gtk_menu_bar_get_preferred_width_for_height;
   widget_class->get_preferred_height_for_width = gtk_menu_bar_get_preferred_height_for_width;
   widget_class->size_allocate = gtk_menu_bar_size_allocate;
+  widget_class->realize = gtk_menu_bar_realize;
+  widget_class->unrealize = gtk_menu_bar_unrealize;
   widget_class->draw = gtk_menu_bar_draw;
   widget_class->hierarchy_changed = gtk_menu_bar_hierarchy_changed;
-  
-  gtk_widget_class_set_accessible_role (widget_class, ATK_ROLE_MENU_BAR);
+  widget_class->can_activate_accel = gtk_menu_bar_can_activate_accel;
 
   menu_shell_class->submenu_placement = GTK_TOP_BOTTOM;
   menu_shell_class->get_popup_delay = gtk_menu_bar_get_popup_delay;
@@ -240,6 +245,8 @@
                                                 GTK_TYPE_MENU_BAR,
                                                 GtkMenuBarPrivate);
 
+  menu_bar->priv->shell_shows = (ubuntu_menu_proxy_get () != NULL);
+
   context = gtk_widget_get_style_context (GTK_WIDGET (menu_bar));
   gtk_style_context_add_class (context, GTK_STYLE_CLASS_MENUBAR);
 }
@@ -344,6 +351,9 @@
   menu_shell = GTK_MENU_SHELL (widget);
   priv = menu_bar->priv;
 
+  if (priv->shell_shows)
+    return;
+
   children = menu_shell->priv->children;
 
   if (priv->child_pack_direction == GTK_PACK_DIRECTION_LTR ||
@@ -475,6 +485,27 @@
   menu_shell = GTK_MENU_SHELL (widget);
   priv = menu_bar->priv;
 
+  if (priv->shell_shows)
+    {
+      GtkAllocation zero = { 0, 0, 0, 0 };
+      GdkWindow *window;
+
+      /* We manually assign an empty allocation to the menubar to
+       * prevent the container from attempting to draw it at all.
+       */
+      gtk_widget_set_allocation (widget, &zero);
+
+      /* Then we move the GdkWindow belonging to the menubar outside of
+       * the clipping rectangle of the parent window so that we can't
+       * see it.
+       */
+      window = gtk_widget_get_window (widget);
+      if (window != NULL)
+        gdk_window_move_resize (window, -1, -1, 1, 1);
+
+      return;
+    }
+
   gtk_widget_set_allocation (widget, allocation);
 
   if (gtk_widget_get_realized (widget))
@@ -629,6 +660,52 @@
     }
 }
 
+static void
+gtk_menu_bar_shell_shows_menubar_cb (GtkSettings *settings,
+                                     GParamSpec  *pspec,
+                                     gpointer     user_data)
+{
+  GtkMenuBar *menu_bar;
+
+  menu_bar = GTK_MENU_BAR (user_data);
+
+  g_object_get (settings, "gtk-shell-shows-menubar", &menu_bar->priv->shell_shows, NULL);
+
+  gtk_widget_queue_resize (GTK_WIDGET (menu_bar));
+}
+
+static void
+gtk_menu_bar_realize (GtkWidget *widget)
+{
+  GtkSettings *settings;
+
+  GTK_WIDGET_CLASS (gtk_menu_bar_parent_class)->realize (widget);
+
+  if (ubuntu_menu_proxy_get ())
+    {
+      settings = gtk_widget_get_settings (widget);
+
+      g_signal_connect (settings, "notify::gtk-shell-shows-menubar",
+                        G_CALLBACK (gtk_menu_bar_shell_shows_menubar_cb), widget);
+      gtk_menu_bar_shell_shows_menubar_cb (settings, NULL, widget);
+    }
+}
+
+static void
+gtk_menu_bar_unrealize (GtkWidget *widget)
+{
+  GtkSettings *settings;
+
+  if (ubuntu_menu_proxy_get ())
+    {
+      settings = gtk_widget_get_settings (widget);
+
+      g_signal_handlers_disconnect_by_func (settings, gtk_menu_bar_shell_shows_menubar_cb, widget);
+    }
+
+  GTK_WIDGET_CLASS (gtk_menu_bar_parent_class)->unrealize (widget);
+}
+
 static gint
 gtk_menu_bar_draw (GtkWidget *widget,
 		   cairo_t   *cr)
@@ -737,8 +814,16 @@
 	    {
 	      GtkMenuShell *menu_shell = GTK_MENU_SHELL (menubars->data);
 
-              _gtk_menu_shell_set_keyboard_mode (menu_shell, TRUE);
-	      gtk_menu_shell_select_first (menu_shell, FALSE);
+              if (ubuntu_gtk_menu_shell_activate_first (GTK_MENU_SHELL (menu_shell), FALSE))
+                {
+                  //g_print ("send activate to remote!\n");
+                }
+              else
+                {
+                  _gtk_menu_shell_set_keyboard_mode (menu_shell, TRUE);
+                  gtk_menu_shell_select_first (menu_shell, FALSE);
+                  gtk_menu_shell_select_first (menu_shell, FALSE);
+                }
 	      
 	      g_list_free (menubars);
 	      
@@ -805,6 +890,16 @@
     add_to_window (GTK_WINDOW (toplevel), menubar);
 }
 
+static gboolean
+gtk_menu_bar_can_activate_accel (GtkWidget *widget,
+                                 guint      signal_id)
+{
+  g_return_val_if_fail (GTK_IS_MENU_BAR (widget),
+                        gtk_widget_can_activate_accel (widget, signal_id));
+
+  return gtk_widget_is_sensitive (widget);
+}
+
 /**
  * _gtk_menu_bar_cycle_focus:
  * @menubar: a #GtkMenuBar
Index: gtk+-3.6.0/gtk/gtkmenuitem.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkmenuitem.c	2012-09-22 10:23:01.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkmenuitem.c	2012-09-25 11:55:59.176154117 +1200
@@ -36,6 +36,7 @@
 #include "gtkmenuprivate.h"
 #include "gtkseparatormenuitem.h"
 #include "gtkprivate.h"
+#include "ubuntumenuproxy.h"
 #include "gtkbuildable.h"
 #include "gtkactivatable.h"
 #include "gtkwidgetprivate.h"
@@ -1810,7 +1811,18 @@
       gtk_menu_shell_select_item (GTK_MENU_SHELL (parent), widget);
     }
   else
-    g_signal_emit (widget, menu_item_signals[ACTIVATE_ITEM], 0);
+    {
+      GtkWidget *parent = gtk_widget_get_parent (widget);
+      if (GTK_IS_MENU_BAR (parent) &&
+          ubuntu_gtk_menu_shell_activate_mnemonic (GTK_MENU_SHELL (parent), widget))
+        {
+          //g_print ("send activate to remote!\n");
+        }
+      else
+        {
+          g_signal_emit (widget, menu_item_signals[ACTIVATE_ITEM], 0);
+        }
+    }
 
   return TRUE;
 }
Index: gtk+-3.6.0/gtk/gtkmenushell.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkmenushell.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkmenushell.c	2012-09-25 11:55:59.176154117 +1200
@@ -46,6 +46,7 @@
 #include "gtkmenuitemprivate.h"
 #include "gtkmenushellprivate.h"
 #include "gtkmenuprivate.h"
+#include "ubuntumenuproxy.h"
 #include "gtkmnemonichash.h"
 #include "gtkwindow.h"
 #include "gtkprivate.h"
@@ -472,6 +473,7 @@
                                       GtkMenuShellPrivate);
   menu_shell->priv = priv;
   priv->take_focus = TRUE;
+  priv->proxy = ubuntu_menu_proxy_get ();
 }
 
 static void
@@ -580,10 +582,20 @@
                        GtkWidget    *child,
                        gint          position)
 {
+  GtkMenuShellPrivate *priv;
+
   g_return_if_fail (GTK_IS_MENU_SHELL (menu_shell));
   g_return_if_fail (GTK_IS_MENU_ITEM (child));
 
   g_signal_emit (menu_shell, menu_shell_signals[INSERT], 0, child, position);
+
+  /* insert to proxy */
+  priv = menu_shell->priv;
+  if (priv->proxy != NULL)
+    ubuntu_menu_proxy_insert (priv->proxy,
+                              GTK_WIDGET (menu_shell),
+                              child,
+                              position);
 }
 
 static void
@@ -1987,6 +1999,54 @@
     }
 }
 
+gboolean
+ubuntu_gtk_menu_shell_activate_first (GtkMenuShell *menu_shell,
+				      gboolean      search_sensitive)
+{
+  GtkMenuShellPrivate *priv = menu_shell->priv;
+  GtkWidget *to_select = NULL;
+  GList *tmp_list;
+
+  tmp_list = priv->children;
+  while (tmp_list)
+    {
+      GtkWidget *child = tmp_list->data;
+
+      if ((!search_sensitive && gtk_widget_get_visible (child)) ||
+           _gtk_menu_item_is_selectable (child))
+        {
+          to_select = child;
+          if (!GTK_IS_TEAROFF_MENU_ITEM (child))
+            break;
+        }
+
+      tmp_list = tmp_list->next;
+    }
+
+  return to_select &&
+         ubuntu_gtk_menu_shell_activate_mnemonic(menu_shell, to_select);
+}
+
+gboolean
+ubuntu_gtk_menu_shell_activate_mnemonic (GtkMenuShell *shell, GtkWidget *item)
+{
+  GtkMenuShellPrivate *priv;
+
+  g_return_val_if_fail (GTK_IS_MENU_SHELL (shell), FALSE);
+
+  priv = shell->priv;
+
+  if (priv->proxy && !ubuntu_menu_proxy_show_local (priv->proxy))
+    {
+      ubuntu_menu_proxy_activate_menu (priv->proxy,
+                                       item);
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
 /**
  * gtk_menu_shell_get_selected_item:
  * @menu_shell: a #GtkMenuShell
Index: gtk+-3.6.0/gtk/gtkmenushellprivate.h
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkmenushellprivate.h	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkmenushellprivate.h	2012-09-25 11:55:59.176154117 +1200
@@ -22,6 +22,7 @@
 #include <gtk/gtkmenushell.h>
 #include <gtk/gtkmnemonichash.h>
 #include <gtk/gtkkeyhash.h>
+#include "ubuntumenuproxy.h"
 
 
 G_BEGIN_DECLS
@@ -52,6 +53,8 @@
   GtkKeyHash *key_hash;
 
   GdkDevice *grab_pointer;
+
+  UbuntuMenuProxy *proxy;
 };
 
 void        _gtk_menu_shell_select_last      (GtkMenuShell *menu_shell,
Index: gtk+-3.6.0/gtk/gtk.symbols
===================================================================
--- gtk+-3.6.0.orig/gtk/gtk.symbols	2012-09-24 16:06:18.000000000 +1200
+++ gtk+-3.6.0/gtk/gtk.symbols	2012-09-25 11:55:59.176154117 +1200
@@ -3972,3 +3972,12 @@
 gtk_window_unmaximize
 gtk_window_unstick
 gtk_wrap_mode_get_type
+ubuntu_gtk_menu_shell_activate_mnemonic
+ubuntu_gtk_menu_shell_activate_first
+ubuntu_menu_proxy_activate_menu
+ubuntu_menu_proxy_get_type
+ubuntu_menu_proxy_get
+ubuntu_menu_proxy_insert
+ubuntu_menu_proxy_module_get_type
+ubuntu_menu_proxy_module_get
+ubuntu_menu_proxy_show_local
Index: gtk+-3.6.0/gtk/gtkwindow.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkwindow.c	2012-09-19 03:34:43.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkwindow.c	2012-09-25 11:55:59.176154117 +1200
@@ -122,6 +122,8 @@
 
   GdkWindow *grip_window;
 
+  gboolean no_proxy;
+
   gchar   *startup_id;
   gchar   *title;
   gchar   *wmclass_class;
@@ -232,6 +234,7 @@
   PROP_HAS_RESIZE_GRIP,
   PROP_RESIZE_GRIP_VISIBLE,
   PROP_APPLICATION,
+  PROP_NO_PROXY,
   /* Readonly properties */
   PROP_IS_ACTIVE,
   PROP_HAS_TOPLEVEL_FOCUS,
@@ -638,6 +641,14 @@
 							NULL,
 							GTK_PARAM_READWRITE));
 
+  g_object_class_install_property (gobject_class,
+                                   PROP_NO_PROXY,
+                                   g_param_spec_boolean ("ubuntu-no-proxy",
+                                                         P_("Disable menu proxies for this window"),
+                                                         P_("Disable menu proxies for this window"),
+                                                         FALSE,
+                                                         GTK_PARAM_READWRITE));
+
   /**
    * GtkWindow:startup-id:
    *
@@ -1325,6 +1336,9 @@
     case PROP_FOCUS_VISIBLE:
       gtk_window_set_focus_visible (window, g_value_get_boolean (value));
       break;
+    case PROP_NO_PROXY:
+      priv->no_proxy = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1452,6 +1466,9 @@
     case PROP_FOCUS_VISIBLE:
       g_value_set_boolean (value, priv->focus_visible);
       break;
+    case PROP_NO_PROXY:
+      g_value_set_boolean (value, priv->no_proxy);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
Index: gtk+-3.6.0/gtk/Makefile.am
===================================================================
--- gtk+-3.6.0.orig/gtk/Makefile.am	2012-09-20 12:52:10.000000000 +1200
+++ gtk+-3.6.0/gtk/Makefile.am	2012-09-25 11:55:59.176154117 +1200
@@ -274,6 +274,8 @@
 	gtkmenubar.h		\
 	gtkmenubutton.h		\
 	gtkmenuitem.h		\
+	ubuntumenuproxy.h	\
+	ubuntumenuproxymodule.h	\
 	gtkmenushell.h		\
 	gtkmenutoolbutton.h	\
 	gtkmessagedialog.h	\
@@ -745,6 +747,8 @@
 	gtkmenubar.c		\
 	gtkmenubutton.c		\
 	gtkmenuitem.c		\
+	ubuntumenuproxy.c	\
+	ubuntumenuproxymodule.c	\
 	gtkmenushell.c		\
 	gtkmenutoolbutton.c	\
 	gtkmessagedialog.c	\
Index: gtk+-3.6.0/gtk/ubuntumenuproxy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gtk+-3.6.0/gtk/ubuntumenuproxy.c	2012-09-25 11:55:59.176154117 +1200
@@ -0,0 +1,246 @@
+/*
+ * Copyright (C) 2010 Canonical, Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Cody Russell <bratsche@gnome.org>
+ */
+
+#include "config.h"
+#include "gtkintl.h"
+#include "gtkmarshalers.h"
+#include "ubuntumenuproxy.h"
+#include "ubuntumenuproxymodule.h"
+#include "gtkmodules.h"
+#include "gtkprivate.h"
+
+enum {
+  PROP_0,
+  PROP_SHOW_LOCAL
+};
+
+enum {
+  INSERTED,
+  LOCAL_NOTIFY,
+  ACTIVATE_MENU,
+  LAST_SIGNAL
+};
+
+#define UBUNTU_MENU_PROXY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), UBUNTU_TYPE_MENU_PROXY, UbuntuMenuProxyPrivate))
+
+typedef struct _UbuntuMenuProxyPrivate UbuntuMenuProxyPrivate;
+
+struct _UbuntuMenuProxyPrivate
+{
+  gboolean show_local;
+};
+
+static guint               menu_proxy_signals[LAST_SIGNAL] = { 0 };
+static GObjectClass       *parent_class = NULL;
+static UbuntuMenuProxy    *proxy_singleton = NULL;
+
+static void     ubuntu_menu_proxy_real_insert     (UbuntuMenuProxy *proxy,
+                                                   GtkWidget    *parent,
+                                                   GtkWidget    *child,
+                                                   guint         position);
+static gboolean ubuntu_menu_proxy_real_show_local (UbuntuMenuProxy *proxy);
+
+
+
+/* --------------------------------------------------------- */
+
+G_DEFINE_TYPE (UbuntuMenuProxy, ubuntu_menu_proxy, G_TYPE_OBJECT)
+
+static GObject *
+ubuntu_menu_proxy_constructor (GType                  type,
+                               guint                  n_params,
+                               GObjectConstructParam *params)
+{
+  GObject *object;
+
+  if (proxy_singleton != NULL)
+    {
+      object = g_object_ref (proxy_singleton);
+    }
+  else
+    {
+      object = G_OBJECT_CLASS (ubuntu_menu_proxy_parent_class)->constructor (type,
+                                                                             n_params,
+                                                                             params);
+
+      proxy_singleton = UBUNTU_MENU_PROXY (object);
+      g_object_add_weak_pointer (object, (gpointer) &proxy_singleton);
+    }
+
+  return object;
+}
+
+static void
+ubuntu_menu_proxy_init (UbuntuMenuProxy *proxy)
+{
+}
+
+static void
+ubuntu_menu_proxy_get_property (GObject    *object,
+                                guint       prop_id,
+                                GValue     *value,
+                                GParamSpec *pspec)
+{
+  UbuntuMenuProxyPrivate *priv = UBUNTU_MENU_PROXY_GET_PRIVATE (object);
+
+  switch (prop_id)
+    {
+    case PROP_SHOW_LOCAL:
+      g_value_set_boolean (value, priv->show_local);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+ubuntu_menu_proxy_set_property (GObject      *object,
+                                guint         prop_id,
+                                const GValue *value,
+                                GParamSpec   *pspec)
+{
+  UbuntuMenuProxyPrivate *priv = UBUNTU_MENU_PROXY_GET_PRIVATE (object);
+
+  switch (prop_id)
+    {
+    case PROP_SHOW_LOCAL:
+      priv->show_local = g_value_get_boolean (value);
+      g_signal_emit (object, menu_proxy_signals[LOCAL_NOTIFY], 0, priv->show_local);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+ubuntu_menu_proxy_class_init (UbuntuMenuProxyClass *class)
+{
+  GObjectClass *object_class = G_OBJECT_CLASS (class);
+
+  parent_class = g_type_class_peek_parent (class);
+
+  object_class->get_property = ubuntu_menu_proxy_get_property;
+  object_class->set_property = ubuntu_menu_proxy_set_property;
+
+  g_object_class_install_property (object_class,
+                                   PROP_SHOW_LOCAL,
+                                   g_param_spec_boolean ("show-local",
+                                                         P_("Show the local menu"),
+                                                         P_("Whether the menu is displayed locally"),
+                                                         FALSE,
+                                                         GTK_PARAM_READWRITE));
+
+  menu_proxy_signals[INSERTED] =
+    g_signal_new (I_("inserted"),
+                  G_TYPE_FROM_CLASS (class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (UbuntuMenuProxyClass, inserted),
+                  NULL, NULL,
+                  _gtk_marshal_VOID__OBJECT_UINT,
+                  G_TYPE_NONE, 2,
+                  GTK_TYPE_WIDGET, G_TYPE_UINT);
+
+  menu_proxy_signals[LOCAL_NOTIFY] =
+    g_signal_new (I_("local-notify"),
+                  G_TYPE_FROM_CLASS (class),
+                  G_SIGNAL_RUN_LAST,
+                  NULL,
+                  NULL, NULL,
+                  _gtk_marshal_VOID__BOOLEAN,
+                  G_TYPE_NONE, 1,
+                  G_TYPE_BOOLEAN);
+
+  menu_proxy_signals[ACTIVATE_MENU] =
+    g_signal_new (I_("activate-menu"),
+                  G_TYPE_FROM_CLASS (class),
+                  G_SIGNAL_RUN_LAST,
+                  NULL,
+                  NULL, NULL,
+                  _gtk_marshal_VOID__OBJECT,
+                  G_TYPE_NONE, 1,
+                  G_TYPE_OBJECT);
+
+  class->insert = ubuntu_menu_proxy_real_insert;
+  class->show_local = ubuntu_menu_proxy_real_show_local;
+
+  object_class->constructor = ubuntu_menu_proxy_constructor;
+
+  g_type_class_add_private (object_class, sizeof (UbuntuMenuProxyPrivate));
+}
+
+UbuntuMenuProxy *
+ubuntu_menu_proxy_get (void)
+{
+  if (!proxy_singleton)
+    {
+      ubuntu_menu_proxy_module_get ();
+    }
+
+  return proxy_singleton;
+}
+
+static void
+ubuntu_menu_proxy_real_insert (UbuntuMenuProxy *proxy,
+                               GtkWidget    *parent,
+                               GtkWidget    *child,
+                               guint         position)
+{
+}
+
+static gboolean
+ubuntu_menu_proxy_real_show_local (UbuntuMenuProxy *proxy)
+{
+  UbuntuMenuProxyPrivate *priv = UBUNTU_MENU_PROXY_GET_PRIVATE (proxy);
+  return priv->show_local;
+}
+
+void
+ubuntu_menu_proxy_insert (UbuntuMenuProxy *proxy,
+                          GtkWidget    *parent,
+                          GtkWidget    *child,
+                          guint         position)
+{
+  g_return_if_fail (UBUNTU_IS_MENU_PROXY (proxy));
+
+  UBUNTU_MENU_PROXY_GET_CLASS (proxy)->insert (proxy,
+                                               parent,
+                                               child,
+                                               position);
+}
+
+gboolean
+ubuntu_menu_proxy_show_local (UbuntuMenuProxy *proxy)
+{
+  g_return_val_if_fail (UBUNTU_IS_MENU_PROXY (proxy), TRUE);
+
+  return UBUNTU_MENU_PROXY_GET_CLASS (proxy)->show_local (proxy);
+}
+
+void
+ubuntu_menu_proxy_activate_menu (UbuntuMenuProxy *proxy,
+                                 GtkWidget       *widget)
+{
+  g_signal_emit (proxy, menu_proxy_signals[ACTIVATE_MENU], 0, widget);
+}
Index: gtk+-3.6.0/gtk/ubuntumenuproxy.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gtk+-3.6.0/gtk/ubuntumenuproxy.h	2012-09-25 11:55:59.176154117 +1200
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2010 Canonical, Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Cody Russell <bratsche@gnome.org>
+ */
+
+#if defined(GTK_DISABLE_SINGLE_INCLUDES) && !defined (__GTK_H_INSIDE__) && !defined (GTK_COMPILATION)
+#error "Only <gtk/gtk.h> can be included directly."
+#endif
+
+#ifndef __UBUNTU_MENU_PROXY_H__
+#define __UBUNTU_MENU_PROXY_H__
+
+#include <gtk/gtkwidget.h>
+
+G_BEGIN_DECLS
+
+#define UBUNTU_TYPE_MENU_PROXY           (ubuntu_menu_proxy_get_type ())
+#define UBUNTU_MENU_PROXY(o)             (G_TYPE_CHECK_INSTANCE_CAST ((o), UBUNTU_TYPE_MENU_PROXY, UbuntuMenuProxy))
+#define UBUNTU_MENU_PROXY_CLASS(k)       (G_TYPE_CHECK_CLASS_CAST ((k), UBUNTU_TYPE_MENU_PROXY, UbuntuMenuProxyClass))
+#define UBUNTU_IS_MENU_PROXY(o)          (G_TYPE_CHECK_INSTANCE_TYPE ((o), UBUNTU_TYPE_MENU_PROXY))
+#define UBUNTU_IS_MENU_PROXY_CLASS(k)    (G_TYPE_CHECK_CLASS_TYPE ((k), UBUNTU_TYPE_MENU_PROXY))
+#define UBUNTU_MENU_PROXY_GET_CLASS(o)   (G_TYPE_INSTANCE_GET_CLASS ((o), UBUNTU_TYPE_MENU_PROXY, UbuntuMenuProxyClass))
+
+
+typedef struct _UbuntuMenuProxy      UbuntuMenuProxy;
+typedef struct _UbuntuMenuProxyClass UbuntuMenuProxyClass;
+
+struct _UbuntuMenuProxy
+{
+  GObject parent_object;
+};
+
+struct _UbuntuMenuProxyClass
+{
+  GObjectClass parent_class;
+
+  /* vtable */
+  void     (* insert)     (UbuntuMenuProxy *proxy, GtkWidget *parent, GtkWidget *child, guint position);
+  gboolean (* show_local) (UbuntuMenuProxy *proxy);
+
+  /* signals */
+  void (* inserted)  (UbuntuMenuProxy *proxy, GtkWidget *child);
+};
+
+GType              ubuntu_menu_proxy_get_type      (void);
+UbuntuMenuProxy*   ubuntu_menu_proxy_get           (void);
+void               ubuntu_menu_proxy_insert        (UbuntuMenuProxy *proxy,
+                                                    GtkWidget       *parent,
+                                                    GtkWidget       *child,
+                                                    guint            position);
+gboolean           ubuntu_menu_proxy_show_local    (UbuntuMenuProxy *proxy);
+void               ubuntu_menu_proxy_activate_menu (UbuntuMenuProxy *proxy,
+                                                    GtkWidget       *widget);
+
+G_END_DECLS
+
+#endif /* __UBUNTU_MENU_PROXY_H__ */
Index: gtk+-3.6.0/gtk/ubuntumenuproxymodule.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gtk+-3.6.0/gtk/ubuntumenuproxymodule.c	2012-09-25 11:55:59.176154117 +1200
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2010 Canonical, Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Cody Russell <bratsche@gnome.org>
+ */
+
+#include "config.h"
+#include "gtkintl.h"
+#include "ubuntumenuproxy.h"
+#include "ubuntumenuproxymodule.h"
+#include "gtkmodules.h"
+#include "gtkmodulesprivate.h"
+#include "gtkprivate.h"
+
+enum {
+  PROP_0,
+  PROP_MODULENAME
+};
+
+static GObject  *ubuntu_menu_proxy_module_constructor   (GType                  type,
+                                                         guint                  n_params,
+                                                         GObjectConstructParam *params);
+static void      ubuntu_menu_proxy_module_finalize      (GObject               *object);
+static gboolean  ubuntu_menu_proxy_module_real_load     (GTypeModule           *gmodule);
+static void      ubuntu_menu_proxy_module_real_unload   (GTypeModule           *gmodule);
+
+
+G_DEFINE_TYPE (UbuntuMenuProxyModule, ubuntu_menu_proxy_module, G_TYPE_TYPE_MODULE);
+
+static UbuntuMenuProxyModule *proxy_module_singleton = NULL;
+
+static void
+ubuntu_menu_proxy_module_class_init (UbuntuMenuProxyModuleClass *class)
+{
+  GObjectClass     *object_class      = G_OBJECT_CLASS (class);
+  GTypeModuleClass *type_module_class = G_TYPE_MODULE_CLASS (class);
+
+  object_class->finalize     = ubuntu_menu_proxy_module_finalize;
+
+  type_module_class->load    = ubuntu_menu_proxy_module_real_load;
+  type_module_class->unload  = ubuntu_menu_proxy_module_real_unload;
+}
+
+static void
+ubuntu_menu_proxy_module_init (UbuntuMenuProxyModule *module)
+{
+  module->name     = g_strdup (g_getenv ("UBUNTU_MENUPROXY"));
+  module->library  = NULL;
+  module->load     = NULL;
+  module->unload   = NULL;
+}
+
+static void
+ubuntu_menu_proxy_module_finalize (GObject *object)
+{
+  UbuntuMenuProxyModule *module = UBUNTU_MENU_PROXY_MODULE (object);
+
+  if (module->name != NULL)
+    {
+      g_free (module->name);
+    }
+
+  G_OBJECT_CLASS (ubuntu_menu_proxy_module_parent_class)->finalize (object);
+}
+
+static gboolean
+ubuntu_menu_proxy_module_real_load (GTypeModule *gmodule)
+{
+  UbuntuMenuProxyModule *module = UBUNTU_MENU_PROXY_MODULE (gmodule);
+  gchar *path;
+
+  if (proxy_module_singleton != NULL)
+    return TRUE;
+
+  if (!module->name)
+    {
+      g_warning ("Module path not set");
+      return FALSE;
+    }
+
+  path = _gtk_find_module (module->name, "menuproxies");
+
+  module->library = g_module_open (path, 0);
+
+  if (!module->library)
+    {
+      g_printerr ("%s\n", g_module_error ());
+      return FALSE;
+    }
+
+  /* Make sure that the loaded library contains the required methods */
+  if (!g_module_symbol (module->library,
+                        "menu_proxy_module_load",
+                        (gpointer *) &module->load) ||
+      !g_module_symbol (module->library,
+                        "menu_proxy_module_unload",
+                        (gpointer *) &module->unload))
+    {
+      g_printerr ("%s\n", g_module_error ());
+      g_module_close (module->library);
+
+      return FALSE;
+    }
+
+  /* Initialize the loaded module */
+  module->load (module);
+
+  return TRUE;
+}
+
+static void
+ubuntu_menu_proxy_module_real_unload (GTypeModule *gmodule)
+{
+  UbuntuMenuProxyModule *module = UBUNTU_MENU_PROXY_MODULE (gmodule);
+
+  module->unload (module);
+
+  g_module_close (module->library);
+  module->library = NULL;
+
+  module->load   = NULL;
+  module->unload = NULL;
+}
+
+static gboolean
+is_valid_module_name (const gchar *name)
+{
+#if !defined(G_OS_WIN32) && !defined(G_WITH_CYGWIN)
+  return g_str_has_prefix (name, "lib") && g_str_has_suffix (name, ".so");
+#else
+  return g_str_has_suffix (name, ".dll");
+#endif
+}
+
+static void
+setup_instance (UbuntuMenuProxyModule *module)
+{
+  GType *proxy_types;
+  guint  n_proxies;
+
+  proxy_types = g_type_children (UBUNTU_TYPE_MENU_PROXY,
+                                 &n_proxies);
+
+  if (n_proxies > 1)
+    {
+      g_warning ("There are %d child types of UbuntuMenuProxy, should be 0 or 1.\n",
+                 n_proxies);
+    }
+  else if (n_proxies == 1)
+    {
+      g_object_new (proxy_types[0], NULL);
+    }
+}
+
+UbuntuMenuProxyModule *
+ubuntu_menu_proxy_module_get (void)
+{
+  if (!proxy_module_singleton)
+    {
+      UbuntuMenuProxyModule *module = NULL;
+      const gchar *module_name;
+
+      module_name = g_getenv ("UBUNTU_MENUPROXY");
+
+      if (module_name != NULL)
+        {
+          if (is_valid_module_name (module_name))
+            {
+              gchar *path = _gtk_find_module (module_name, "menuproxies");
+
+              module = g_object_new (UBUNTU_TYPE_MENU_PROXY_MODULE,
+                                     NULL);
+
+              if (!g_type_module_use (G_TYPE_MODULE (module)))
+                {
+                  g_warning ("Failed to load type module: %s\n", path);
+
+                  g_object_unref (module);
+                  g_free (path);
+
+                  return NULL;
+                }
+
+              setup_instance (module);
+
+              g_free (path);
+              g_type_module_unuse (G_TYPE_MODULE (module));
+            }
+
+          proxy_module_singleton = module;
+        }
+    }
+
+  return proxy_module_singleton;
+}
Index: gtk+-3.6.0/gtk/ubuntumenuproxymodule.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ gtk+-3.6.0/gtk/ubuntumenuproxymodule.h	2012-09-25 11:55:59.176154117 +1200
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2010 Canonical, Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * Authors: Cody Russell <bratsche@gnome.org>
+ */
+
+#if defined(GTK_DISABLE_SINGLE_INCLUDES) && !defined (__GTK_H_INSIDE__) && !defined (GTK_COMPILATION)
+#error "Only <gtk/gtk.h> can be included directly."
+#endif
+
+#ifndef __UBUNTU_MENU_PROXY_MODULE_H__
+#define __UBUNTU_MENU_PROXY_MODULE_H__
+
+#include <glib-object.h>
+#include <gmodule.h>
+
+G_BEGIN_DECLS
+
+#define UBUNTU_TYPE_MENU_PROXY_MODULE         (ubuntu_menu_proxy_module_get_type ())
+#define UBUNTU_MENU_PROXY_MODULE(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), UBUNTU_TYPE_MENU_PROXY_MODULE, UbuntuMenuProxyModule))
+#define UBUNTU_MENU_PROXY_MODULE_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST ((k), UBUNTU_TYPE_MENU_PROXY_MODULE, UbuntuMenuProxyModuleClass))
+#define UBUNTU_IS_MENU_MODULE_PROXY(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), UBUNTU_TYPE_MENU_PROXY_MODULE))
+#define UBUNTU_IS_MENU_PROXY_MODULE_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), UBUNTU_TYPE_MENU_PROXY_MODULE))
+#define UBUNTU_MENU_PROXY_MODULE_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), UBUNTU_TYPE_MENU_PROXY_MODULE, UbuntuMenuProxyModuleClass))
+
+typedef struct _UbuntuMenuProxyModule        UbuntuMenuProxyModule;
+typedef struct _UbuntuMenuProxyModuleClass   UbuntuMenuProxyModuleClass;
+typedef struct _UbuntuMenuProxyModulePrivate UbuntuMenuProxyModulePrivate;
+
+struct _UbuntuMenuProxyModule
+{
+  GTypeModule parent_instance;
+
+  UbuntuMenuProxyModulePrivate *priv;
+
+  GModule *library;
+  gchar   *name;
+
+  void        (* load)     (UbuntuMenuProxyModule *module);
+  void        (* unload)   (UbuntuMenuProxyModule *module);
+};
+
+struct _UbuntuMenuProxyModuleClass
+{
+  GTypeModuleClass parent_class;
+};
+
+GType                  ubuntu_menu_proxy_module_get_type (void);
+
+UbuntuMenuProxyModule *ubuntu_menu_proxy_module_get      (void);
+
+G_END_DECLS
+
+#endif /* __UBUNTU_MENU_PROXY_MODULE_H__ */
Index: gtk+-3.6.0/gtk/gtkmnemonichash.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkmnemonichash.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkmnemonichash.c	2012-09-25 11:55:59.176154117 +1200
@@ -18,6 +18,10 @@
  */
 
 #include "gtkmnemonichash.h"
+#include "ubuntumenuproxy.h"
+#include "gtkmenuitem.h"
+#include "gtkmenubar.h"
+#include "gtkaccellabel.h"
 
 struct _GtkMnemnonicHash
 {
@@ -112,7 +116,8 @@
   GSList *list, *targets;
   GtkWidget *widget, *chosen_widget;
   GdkWindow *window;
-  gboolean overloaded;
+  gboolean overloaded, hasMenuBarParent;
+  UbuntuMenuProxy * menu_proxy = ubuntu_menu_proxy_get();
 
   targets = g_hash_table_lookup (mnemonic_hash->hash,
 				 GUINT_TO_POINTER (keyval));
@@ -125,10 +130,16 @@
     {
       widget = GTK_WIDGET (list->data);
       window = gtk_widget_get_window (widget);
+      if (widget)
+	hasMenuBarParent = gtk_widget_get_ancestor(widget, GTK_TYPE_MENU_BAR) != NULL;
+      else
+	hasMenuBarParent = FALSE;
 
-      if (gtk_widget_is_sensitive (widget) &&
+      if ((menu_proxy && hasMenuBarParent && !ubuntu_menu_proxy_show_local(menu_proxy) && GTK_IS_ACCEL_LABEL(widget))
+      || (gtk_widget_is_sensitive (widget) &&
 	  gtk_widget_get_mapped (widget) &&
           window && gdk_window_is_viewable (window))
+      )
 	{
 	  if (chosen_widget)
 	    {
Description: Enable tracker full text search
 Tracker in Debian is compiled with FTS support, so we make use of that in
 GTK3's file selector dialog.
 This way files can be found by their content and not only their file name.

Index: gtk+3.0-3.3.20/gtk/gtksearchenginetracker.c
===================================================================
--- gtk+3.0-3.3.20.orig/gtk/gtksearchenginetracker.c	2012-03-18 21:44:22.000000000 +0100
+++ gtk+3.0-3.3.20/gtk/gtksearchenginetracker.c	2012-03-20 18:48:18.113061457 +0100
@@ -50,7 +50,7 @@
  * use filename matching instead. This doesn't use the content of the
  * file however.
  */
-#undef FTS_MATCHING
+#define FTS_MATCHING
 
 /*
  * GtkSearchEngineTracker object
Index: gtk+-3.6.0/gtk/gtk.symbols
===================================================================
--- gtk+-3.6.0.orig/gtk/gtk.symbols	2012-09-25 11:55:59.176154117 +1200
+++ gtk+-3.6.0/gtk/gtk.symbols	2012-09-25 11:56:02.512154085 +1200
@@ -3974,6 +3974,7 @@
 gtk_wrap_mode_get_type
 ubuntu_gtk_menu_shell_activate_mnemonic
 ubuntu_gtk_menu_shell_activate_first
+ubuntu_gtk_widget_set_has_grab
 ubuntu_menu_proxy_activate_menu
 ubuntu_menu_proxy_get_type
 ubuntu_menu_proxy_get
Index: gtk+-3.6.0/gtk/gtkwidget.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkwidget.c	2012-09-19 03:34:43.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkwidget.c	2012-09-25 11:56:02.516154085 +1200
@@ -14140,3 +14140,11 @@
   else
     g_action_muxer_remove (muxer, name);
 }
+
+void
+ubuntu_gtk_widget_set_has_grab (GtkWidget *widget,
+                                gboolean   has_grab)
+{
+  _gtk_widget_set_has_grab (widget, has_grab);
+}
+ 
Index: gtk+-3.6.0/gtk/gtkwidget.h
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkwidget.h	2012-09-19 03:34:43.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkwidget.h	2012-09-25 11:56:02.516154085 +1200
@@ -891,6 +891,9 @@
                                                                          const gchar  *name,
                                                                          GActionGroup *group);
 
+void   ubuntu_gtk_widget_set_has_grab  (GtkWidget *widget,
+                                        gboolean   has_grab);
+
 G_END_DECLS
 
 #endif /* __GTK_WIDGET_H__ */
From 4c220ef6650afeba334570ad00db0a95c9ba38e6 Mon Sep 17 00:00:00 2001
From: Michael Biebl <biebl@debian.org>
Date: Tue, 17 Apr 2012 13:29:09 +0200
Subject: [PATCH] Fix installation of HTML images for absolute paths

when using out-of-tree builds.

Bug: https://bugzilla.gnome.org/show_bug.cgi?id=674163
Bug-Debian: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=656803
---
 gtk-doc.make |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

Index: gtk+-3.4.1/gtk-doc.make
===================================================================
--- gtk+-3.4.1.orig/gtk-doc.make	2012-04-10 00:52:46.000000000 +0200
+++ gtk+-3.4.1/gtk-doc.make	2012-04-17 19:22:04.294590580 +0200
@@ -155,8 +155,8 @@
 	  if test -f $(abs_srcdir)/$$file ; then \
 	    cp $(abs_srcdir)/$$file $(abs_builddir)/html; \
 	  fi; \
-	  if test -f $(abs_builddir)/$$file ; then \
-	    cp $(abs_builddir)/$$file $(abs_builddir)/html; \
+	  if test -f $$file ; then \
+	    cp $$file $(abs_builddir)/html; \
 	  fi; \
 	done;
 	@echo '  DOC   Fixing cross-references'
Description: "ubuntu-almost-fixed-height" private property to speed-up software-center
Bug: https://bugzilla.gnome.org/607447
Bug-Ubuntu: https://launchpad.net/bugs/514879

=== modified file 'gtk/gtktreeview.c'
Index: gtk+-3.5.2/gtk/gtktreeview.c
===================================================================
--- gtk+-3.5.2.orig/gtk/gtktreeview.c	2012-05-16 10:09:12.974667115 +1200
+++ gtk+-3.5.2/gtk/gtktreeview.c	2012-05-16 10:09:19.250666909 +1200
@@ -462,6 +462,7 @@
 
   guint fixed_height_mode : 1;
   guint fixed_height_check : 1;
+  guint ubuntu_almost_fixed_height_mode : 1;
 
   guint reorderable : 1;
   guint header_has_focus : 1;
@@ -552,6 +553,7 @@
   PROP_ENABLE_SEARCH,
   PROP_SEARCH_COLUMN,
   PROP_FIXED_HEIGHT_MODE,
+  PROP_UBUNTU_ALMOST_FIXED_HEIGHT_MODE,
   PROP_HOVER_SELECTION,
   PROP_HOVER_EXPAND,
   PROP_SHOW_EXPANDERS,
@@ -1075,6 +1077,15 @@
                                                            P_("Speeds up GtkTreeView by assuming that all rows have the same height"),
                                                            FALSE,
                                                            GTK_PARAM_READWRITE));
+
+    /* Private ubuntu extension to fix bugzilla bug #607447 */
+    g_object_class_install_property (o_class,
+                                     PROP_UBUNTU_ALMOST_FIXED_HEIGHT_MODE,
+                                     g_param_spec_boolean ("ubuntu-almost-fixed-height-mode",
+                                                           "Private Ubuntu extension",
+							   "Private Ubuntu extension",
+                                                           FALSE,
+                                                           GTK_PARAM_READWRITE));
     
     /**
      * GtkTreeView:hover-selection:
@@ -1736,6 +1747,7 @@
   tree_view->priv->fixed_height = -1;
   tree_view->priv->fixed_height_mode = FALSE;
   tree_view->priv->fixed_height_check = 0;
+  tree_view->priv->ubuntu_almost_fixed_height_mode = FALSE;
   tree_view->priv->selection = _gtk_tree_selection_new_with_tree_view (tree_view);
   tree_view->priv->enable_search = TRUE;
   tree_view->priv->search_column = -1;
@@ -1828,6 +1840,9 @@
     case PROP_FIXED_HEIGHT_MODE:
       gtk_tree_view_set_fixed_height_mode (tree_view, g_value_get_boolean (value));
       break;
+    case PROP_UBUNTU_ALMOST_FIXED_HEIGHT_MODE:
+      tree_view->priv->ubuntu_almost_fixed_height_mode = g_value_get_boolean (value);
+      break;
     case PROP_HOVER_SELECTION:
       tree_view->priv->hover_selection = g_value_get_boolean (value);
       break;
@@ -8744,7 +8759,15 @@
 
   _gtk_tree_view_accessible_changed (tree_view, tree, node);
 
-  if (tree_view->priv->fixed_height_mode
+  if (tree_view->priv->ubuntu_almost_fixed_height_mode
+      && tree_view->priv->fixed_height >= 0)
+    {
+      _gtk_rbtree_node_mark_invalid (tree, node);
+      validate_visible_area (tree_view);
+      if (gtk_widget_get_realized (GTK_WIDGET (tree_view)))
+	gtk_tree_view_node_queue_redraw (tree_view, tree, node);
+    }
+  else if (tree_view->priv->fixed_height_mode
       && tree_view->priv->fixed_height >= 0)
     {
       _gtk_rbtree_node_set_height (tree, node, tree_view->priv->fixed_height);
From 567bbeb4c639aa55bfe4cb70919623f1931b9357 Mon Sep 17 00:00:00 2001
From: Didier Roche <didrocks@ubuntu.com>
Date: Fri, 8 Oct 2010 18:54:44 +0200
Subject: [PATCH] Add gtk_range_get_event_window to get the event_window for a GtkRange

This is useful when you try to build your own widget based on GtkRange and then,
should access to the GdkWindow.
---
 docs/reference/gtk/gtk3-sections.txt |    1 +
 gtk/gtk.symbols                      |    1 +
 gtk/gtkrange.c                       |   19 +++++++++++++++++++
 gtk/gtkrange.h                       |    1 +
 4 files changed, 22 insertions(+), 0 deletions(-)

Bug-Debian: https://bugzilla.gnome.org/show_bug.cgi?id=631695

Index: gtk+-3.6.0/docs/reference/gtk/gtk3-sections.txt
===================================================================
--- gtk+-3.6.0.orig/docs/reference/gtk/gtk3-sections.txt	2012-09-25 10:55:42.000000000 +1200
+++ gtk+-3.6.0/docs/reference/gtk/gtk3-sections.txt	2012-09-25 11:56:06.296154049 +1200
@@ -2634,6 +2634,7 @@
 gtk_range_get_slider_size_fixed
 gtk_range_set_min_slider_size
 gtk_range_set_slider_size_fixed
+gtk_range_get_event_window
 
 <SUBSECTION Standard>
 GTK_RANGE
Index: gtk+-3.6.0/gtk/gtk.symbols
===================================================================
--- gtk+-3.6.0.orig/gtk/gtk.symbols	2012-09-25 11:56:02.512154085 +1200
+++ gtk+-3.6.0/gtk/gtk.symbols	2012-09-25 11:56:06.296154049 +1200
@@ -2166,6 +2166,7 @@
 gtk_radio_tool_button_new_with_stock_from_widget
 gtk_radio_tool_button_set_group
 gtk_range_get_adjustment
+gtk_range_get_event_window
 gtk_range_get_fill_level
 gtk_range_get_flippable
 gtk_range_get_inverted
Index: gtk+-3.6.0/gtk/gtkrange.c
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkrange.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkrange.c	2012-09-25 11:56:06.296154049 +1200
@@ -4174,6 +4174,26 @@
   return range->priv->has_origin;
 }
 
+/**
+ * gtk_range_get_event_window:
+ * @range: a #GtkRange
+ *
+ * Returns the range's event window if it is realized, %NULL otherwise.
+ * This function should be rarely needed.
+ *
+ * Return value: (transfer none): @range's event window.
+ *
+ * Since: 2.24
+ */
+GdkWindow*
+gtk_range_get_event_window (GtkRange *range)
+{
+  g_return_val_if_fail (GTK_IS_RANGE (range), NULL);
+  GtkRangePrivate *priv = range->priv;
+
+  return priv->event_window;
+}
+
 void
 _gtk_range_set_stop_values (GtkRange *range,
                             gdouble  *values,
Index: gtk+-3.6.0/gtk/gtkrange.h
===================================================================
--- gtk+-3.6.0.orig/gtk/gtkrange.h	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.6.0/gtk/gtkrange.h	2012-09-25 11:56:06.296154049 +1200
@@ -143,6 +143,7 @@
 void               gtk_range_set_round_digits              (GtkRange      *range,
                                                             gint           round_digits);
 gint                gtk_range_get_round_digits              (GtkRange      *range);
+GdkWindow*         gtk_range_get_event_window              (GtkRange      *range);
 
 /* internal API */
 gdouble            _gtk_range_get_wheel_delta              (GtkRange       *range,
Index: gtk+3.0-3.3.20/gtk/gtkeventbox.c
===================================================================
--- gtk+3.0-3.3.20.orig/gtk/gtkeventbox.c	2012-03-18 21:44:21.000000000 +0100
+++ gtk+3.0-3.3.20/gtk/gtkeventbox.c	2012-03-20 18:48:18.365061469 +0100
@@ -414,7 +414,8 @@
                         | GDK_BUTTON_RELEASE_MASK
                         | GDK_EXPOSURE_MASK
                         | GDK_ENTER_NOTIFY_MASK
-                        | GDK_LEAVE_NOTIFY_MASK;
+                        | GDK_LEAVE_NOTIFY_MASK
+                        | GDK_SCROLL_MASK;
 
   priv = GTK_EVENT_BOX (widget)->priv;
 
From ebd0d372a35d7f1b0c9a7bb5415ae56e4739e0e8 Mon Sep 17 00:00:00 2001
From: Ryan Lortie <desrt@desrt.ca>
Date: Mon, 2 Apr 2012 09:55:42 -0400
Subject: [PATCH] accel cell renderer: support modifier 'tapping'

Introduce a new GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP that accepts
tapping modifier keys (eg: simply pressing and releasing the Windows
key) as accelerators.

https://bugzilla.gnome.org/show_bug.cgi?id=673360
---
 gtk/gtkcellrendereraccel.c |   37 +++++++++++++++++++++++++++++++++++++
 gtk/gtkcellrendereraccel.h |    3 ++-
 2 files changed, 39 insertions(+), 1 deletions(-)

Index: b/gtk/gtkcellrendereraccel.c
===================================================================
--- a/gtk/gtkcellrendereraccel.c
+++ b/gtk/gtkcellrendereraccel.c
@@ -98,6 +98,13 @@
 
   GdkModifierType accel_mods;
 
+  /* Used to track the last modifier that was pressed down.
+   * We can then treat a directly-following release of the same key as a
+   * 'tap'.
+   */
+  GdkModifierType last_saw_state;
+  guint last_saw_keyval;
+
   guint accel_key;
   guint keycode;
 };
@@ -195,6 +202,10 @@
    * accepted by GTK+ are allowed, and the accelerators are rendered
    * in the same way as they are in menus.
    *
+   * If the mode is set to %GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP
+   * then bare modifiers can be set as accelerators by tapping (ie:
+   * pressing and immediately releasing) them.
+   *
    * Since: 2.10
    */
   g_object_class_install_property (object_class,
@@ -444,6 +455,29 @@
 
   display = gtk_widget_get_display (widget);
 
+  if (event->type == GDK_KEY_RELEASE)
+    {
+      /* User released a modifier key right after pressing it and we're
+       * in 'modifier tap' mode: this is our new accel.
+       */
+      if (priv->accel_mode == GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP &&
+          event->is_modifier && event->keyval == priv->last_saw_keyval)
+        {
+          /* We use the mask from the down press -- the release event
+           * has the modifier mask from the modifier key itself.
+           */
+          accel_mods = priv->last_saw_state;
+          accel_key = event->keyval;
+          goto out;
+        }
+
+      /* Ignore other releases */
+      return TRUE;
+    }
+
+  priv->last_saw_keyval = event->keyval;
+  priv->last_saw_state = event->state;
+
   if (event->is_modifier)
     return TRUE;
 
@@ -722,6 +756,9 @@
   g_signal_connect (G_OBJECT (widget), "key-press-event",
                     G_CALLBACK (grab_key_callback),
                     accel);
+  g_signal_connect (G_OBJECT (widget), "key-release-event",
+                    G_CALLBACK (grab_key_callback),
+                    accel);
 
   eventbox = g_object_new (_gtk_cell_editable_event_box_get_type (), NULL);
   priv->edit_widget = eventbox;
Index: b/gtk/gtkcellrendereraccel.h
===================================================================
--- a/gtk/gtkcellrendereraccel.h
+++ b/gtk/gtkcellrendereraccel.h
@@ -41,7 +41,8 @@
 typedef enum
 {
   GTK_CELL_RENDERER_ACCEL_MODE_GTK,
-  GTK_CELL_RENDERER_ACCEL_MODE_OTHER
+  GTK_CELL_RENDERER_ACCEL_MODE_OTHER,
+  GTK_CELL_RENDERER_ACCEL_MODE_MODIFIER_TAP
 } GtkCellRendererAccelMode;
 
 
Bug-Upstream: https://bugzilla.gnome.org/show_bug.cgi?id=684533

--- a/modules/printbackends/cups/gtkprintbackendcups.c
+++ b/modules/printbackends/cups/gtkprintbackendcups.c
@@ -1896,6 +1896,19 @@
 		   &port,
 		   resource, sizeof (resource));
 
+  if (strncmp (method, "dnssd", 5) == 0)
+    {
+      _httpResolveURI(cups_printer->printer_uri,
+		      uri, sizeof(uri), 0, NULL, NULL);
+      httpSeparateURI (HTTP_URI_CODING_ALL,
+		       uri,
+		       method, sizeof (method),
+		       username, sizeof (username),
+		       hostname, sizeof (hostname),
+		       &port,
+		       resource, sizeof (resource));
+    }
+
   if (strncmp (resource, "/printers/", 10) == 0)
     {
       cups_printer->ppd_name = g_strdup (resource + 10);
diff -Nur gtk+3.0-3.6.0.old/gtk/a11y/gail.c gtk+3.0-3.6.0/gtk/a11y/gail.c
--- gtk+3.0-3.6.0.old/gtk/a11y/gail.c	2012-10-09 11:28:38.129582008 +0200
+++ gtk+3.0-3.6.0/gtk/a11y/gail.c	2012-10-09 11:30:27.485587299 +0200
@@ -76,7 +76,6 @@
 static guint focus_notify_handler = 0;    
 static guint focus_tracker_id = 0;
 static GQuark quark_focus_object = 0;
-static int initialized = FALSE;
 
 static AtkObject*
 gail_get_accessible_for_widget (GtkWidget *widget,
@@ -796,24 +795,9 @@
 }
 
 void
-_gtk_accessibility_shutdown (void)
-{
-  if (!initialized)
-    return;
-
-  initialized = FALSE;
-
-  g_clear_object (&atk_misc_instance);
-
-#ifdef GDK_WINDOWING_X11
-  atk_bridge_adaptor_cleanup ();
-#endif
-  _gail_util_uninstall ();
-}
-
-void
 _gtk_accessibility_init (void)
 {
+  static int initialized = FALSE;
 
   if (initialized)
     return;
diff -Nur gtk+3.0-3.6.0.old/gtk/a11y/gailutil.c gtk+3.0-3.6.0/gtk/a11y/gailutil.c
--- gtk+3.0-3.6.0.old/gtk/a11y/gailutil.c	2012-10-09 11:28:38.117582007 +0200
+++ gtk+3.0-3.6.0/gtk/a11y/gailutil.c	2012-10-09 11:30:27.485587299 +0200
@@ -206,17 +206,6 @@
                     (GCallback) window_removed, NULL);
 }
 
-static void
-undo_window_event_initialization (void)
-{
-  AtkObject *root;
-
-  root = atk_get_root ();
-
-  g_signal_handlers_disconnect_by_func (root, (GCallback) window_added, NULL);
-  g_signal_handlers_disconnect_by_func (root, (GCallback) window_removed, NULL);
-}
-
 static AtkKeyEventStruct *
 atk_key_event_from_gdk_event_key (GdkEventKey *key)
 {
@@ -353,12 +342,6 @@
 }
 
 void
-_gail_util_uninstall (void)
-{
-  undo_window_event_initialization ();
-}
-
-void
 _gail_util_install (void)
 {
   AtkUtilClass *atk_class = ATK_UTIL_CLASS (g_type_class_ref (ATK_TYPE_UTIL));
diff -Nur gtk+3.0-3.6.0.old/gtk/a11y/gailutil.h gtk+3.0-3.6.0/gtk/a11y/gailutil.h
--- gtk+3.0-3.6.0.old/gtk/a11y/gailutil.h	2012-10-09 11:28:38.121582007 +0200
+++ gtk+3.0-3.6.0/gtk/a11y/gailutil.h	2012-10-09 11:30:27.485587299 +0200
@@ -23,7 +23,6 @@
 G_BEGIN_DECLS
 
 void _gail_util_install   (void);
-void _gail_util_uninstall (void);
 
 gboolean  _gail_util_key_snooper (GtkWidget   *the_widget,
                                   GdkEventKey *event);
diff -Nur gtk+3.0-3.6.0.old/gtk/gtkapplication.c gtk+3.0-3.6.0/gtk/gtkapplication.c
--- gtk+3.0-3.6.0.old/gtk/gtkapplication.c	2012-10-09 11:28:38.261582015 +0200
+++ gtk+3.0-3.6.0/gtk/gtkapplication.c	2012-10-09 11:30:27.493587302 +0200
@@ -47,8 +47,6 @@
 #include <gdk/x11/gdkx.h>
 #endif
 
-extern void _gtk_accessibility_shutdown (void);
-
 /**
  * SECTION:gtkapplication
  * @title: GtkApplication
@@ -425,16 +423,12 @@
   gtk_application_shutdown_quartz (GTK_APPLICATION (application));
 #endif
 
-  /* Keep this section in sync with gtk_main() */
-
   /* Try storing all clipboard data we have */
   _gtk_clipboard_store_all ();
 
   /* Synchronize the recent manager singleton */
   _gtk_recent_manager_sync ();
 
-  _gtk_accessibility_shutdown ();
-
   G_APPLICATION_CLASS (gtk_application_parent_class)
     ->shutdown (application);
 }
diff -Nur gtk+3.0-3.6.0.old/gtk/gtkmain.c gtk+3.0-3.6.0/gtk/gtkmain.c
--- gtk+3.0-3.6.0.old/gtk/gtkmain.c	2012-10-09 11:28:38.217582012 +0200
+++ gtk+3.0-3.6.0/gtk/gtkmain.c	2012-10-09 11:30:27.497587303 +0200
@@ -1173,15 +1172,11 @@
 
   if (gtk_main_loop_level == 0)
     {
-      /* Keep this section in sync with gtk_application_shutdown() */
-
       /* Try storing all clipboard data we have */
       _gtk_clipboard_store_all ();
 
       /* Synchronize the recent manager singleton */
       _gtk_recent_manager_sync ();
-
-      _gtk_accessibility_shutdown ();
     }
 }
 
# Description: gtk_menu_new_from_model doesn't support custom menu items
# Ubuntu: https://bugs.launchpad.net/ubuntu/+source/gtk+3.0/+bug/1039476
#
Index: gtk+-3.5.18/gtk/gtkmodelmenu.c
===================================================================
--- gtk+-3.5.18.orig/gtk/gtkmodelmenu.c	2012-09-19 03:34:42.000000000 +1200
+++ gtk+-3.5.18/gtk/gtkmodelmenu.c	2012-09-19 12:18:50.524724208 +1200
@@ -28,6 +28,7 @@
 #include "gtkseparatormenuitem.h"
 #include "gtkmodelmenuitem.h"
 #include "gtkapplicationprivate.h"
+#include "gtkwidgetprivate.h"
 
 #define MODEL_MENU_WIDGET_DATA "gtk-model-menu-widget-data"
 
@@ -72,6 +73,80 @@
   g_slice_free (GtkModelMenuBinding, binding);
 }
 
+static GtkMenuItem *
+gtk_model_menu_create_custom_item (GMenuModel  *menu,
+                                   gint         item_index,
+                                   const gchar *action_namespace)
+{
+  GtkMenuItem *item = NULL;
+  gchar *typename = NULL;
+  GType type;
+  GObjectClass *class = NULL;
+  GParamSpec *pspec;
+  GMenuItem *menuitem = NULL;
+
+  if (!g_menu_model_get_item_attribute (menu, item_index, "x-canonical-type", "s", &typename))
+      return NULL;
+
+  type = g_type_from_name (typename);
+  if (type == 0)
+    {
+      g_warning ("gtk_menu_new_from_model: cannot find type '%s'", typename);
+      goto out;
+    }
+  if (!g_type_is_a (type, GTK_TYPE_MENU_ITEM))
+    {
+      g_warning ("gtk_menu_new_from_model: '%s' is not derived from GtkMenuItem", typename);
+      goto out;
+    }
+
+  class = g_type_class_ref (type);
+
+  pspec = g_object_class_find_property (class, "menu-item");
+  if (pspec == NULL || G_PARAM_SPEC_VALUE_TYPE (pspec) != G_TYPE_MENU_ITEM)
+    {
+      g_warning ("gtk_menu_new_from_model: '%s' does not have a 'menu-item' property", typename);
+      goto out;
+    }
+
+  pspec = g_object_class_find_property (class, "action-group");
+  if (pspec == NULL || G_PARAM_SPEC_VALUE_TYPE (pspec) != G_TYPE_ACTION_GROUP)
+    {
+      g_warning ("gtk_menu_new_from_model: '%s' does not have an 'action-group' property", typename);
+      goto out;
+    }
+
+  menuitem = g_menu_item_new_from_model (menu, item_index);
+  if (action_namespace)
+    {
+      gchar *action;
+      gchar *fullname;
+
+      g_menu_item_get_attribute (menuitem, G_MENU_ATTRIBUTE_ACTION, "s", &action);
+      fullname = g_strconcat (action_namespace, ".", action, NULL);
+      g_menu_item_set_attribute (menuitem, G_MENU_ATTRIBUTE_ACTION, "s", fullname);
+
+      g_free (action);
+      g_free (fullname);
+    }
+
+  item = g_object_new (type,
+                       "menu-item", menuitem,
+                       NULL);
+
+  g_object_set (item,
+                "action-group", _gtk_widget_get_action_muxer (GTK_WIDGET (item)),
+                NULL);
+
+out:
+  if (menuitem)
+    g_object_unref (menuitem);
+  if (class)
+    g_type_class_unref (class);
+  g_free (typename);
+  return item;
+}
+
 static void
 gtk_model_menu_binding_append_item (GtkModelMenuBinding  *binding,
                                     GMenuModel           *model,
@@ -106,7 +181,10 @@
     {
       GtkMenuItem *item;
 
-      item = gtk_model_menu_item_new (model, item_index, action_namespace);
+      item = gtk_model_menu_create_custom_item (model, item_index, action_namespace);
+      if (item == NULL)
+        item = gtk_model_menu_item_new (model, item_index, action_namespace);
+
       gtk_menu_shell_append (binding->shell, GTK_WIDGET (item));
       gtk_widget_show (GTK_WIDGET (item));
       binding->n_items++;
diff -u -r gtk+-3.4.2/gdk/x11/gdkdevicemanager-xi2.c gtk+-3.4.2-wacom/gdk/x11/gdkdevicemanager-xi2.c
--- gtk+-3.4.2/gdk/x11/gdkdevicemanager-xi2.c	2012-05-02 14:45:04.000000000 +0200
+++ gtk+-3.4.2-wacom/gdk/x11/gdkdevicemanager-xi2.c	2012-05-03 18:34:18.034807644 +0200
@@ -331,6 +331,8 @@
         input_source = GDK_SOURCE_ERASER;
       else if (strstr (tmp_name, "cursor"))
         input_source = GDK_SOURCE_CURSOR;
+      else if (strstr (tmp_name, "finger"))
+        input_source = GDK_SOURCE_TOUCHSCREEN;
       else if (strstr (tmp_name, "wacom") ||
                strstr (tmp_name, "pen"))
         input_source = GDK_SOURCE_PEN;
diff -rpu gtk+-3.4.4.orig/gdk/x11/gdkeventsource.c gtk+-3.4.4/gdk/x11/gdkeventsource.c
--- gtk+-3.4.4.orig/gdk/x11/gdkeventsource.c	2012-05-16 15:20:42.000000000 +0200
+++ gtk+-3.4.4/gdk/x11/gdkeventsource.c	2012-08-20 17:49:51.634753134 +0200
@@ -142,9 +142,6 @@ handle_focus_change (GdkEventCrossing *e
 
   toplevel->has_pointer = focus_in;
 
-  if (!event->focus || toplevel->has_focus_window)
-    return;
-
   had_focus = HAS_FOCUS (toplevel);
   toplevel->has_pointer_focus = focus_in;
