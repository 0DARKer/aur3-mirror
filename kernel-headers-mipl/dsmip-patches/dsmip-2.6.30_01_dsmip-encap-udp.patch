Index: linux-2.6.30/include/linux/in.h
===================================================================
--- linux-2.6.30.orig/include/linux/in.h
+++ linux-2.6.30/include/linux/in.h
@@ -47,6 +47,8 @@ enum {
   IPPROTO_SCTP   = 132,		/* Stream Control Transport Protocol	*/
   IPPROTO_UDPLITE = 136,	/* UDP-Lite (RFC 3828)			*/
 
+  IPPROTO_UDP_ENCAPSULATION = 166,/* IPv6 in UDP pseudo protocol for DSMIP */
+
   IPPROTO_RAW	 = 255,		/* Raw IP packets			*/
   IPPROTO_MAX
 };
Index: linux-2.6.30/include/linux/udp.h
===================================================================
--- linux-2.6.30.orig/include/linux/udp.h
+++ linux-2.6.30/include/linux/udp.h
@@ -34,6 +34,7 @@ struct udphdr {
 #define UDP_ENCAP_ESPINUDP_NON_IKE	1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
 #define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
 #define UDP_ENCAP_L2TPINUDP	3 /* rfc2661 */
+#define UDP_ENCAP_IP_VANILLA	4 /* draft-ietf-mext-nemo-v4traversal-01 */
 
 #ifdef __KERNEL__
 #include <net/inet_sock.h>
Index: linux-2.6.30/net/ipv4/Kconfig
===================================================================
--- linux-2.6.30.orig/net/ipv4/Kconfig
+++ linux-2.6.30/net/ipv4/Kconfig
@@ -370,6 +370,16 @@ config INET_IPCOMP
 
 	  If unsure, say Y.
 
+config INET_XFRM_UDP_ENCAP
+	tristate "IP: UDP Encapsulation transformation"
+	select XFRM
+	select INET_XFRM_TUNNEL
+	---help---
+	  Suport for UDP encapsulation over IPv4,
+    	  typically needed for DSMIPv6
+
+	  If unsure, say Y.
+
 config INET_XFRM_TUNNEL
 	tristate
 	select INET_TUNNEL
Index: linux-2.6.30/net/ipv4/Makefile
===================================================================
--- linux-2.6.30.orig/net/ipv4/Makefile
+++ linux-2.6.30/net/ipv4/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_SYN_COOKIES) += syncookies.
 obj-$(CONFIG_INET_AH) += ah4.o
 obj-$(CONFIG_INET_ESP) += esp4.o
 obj-$(CONFIG_INET_IPCOMP) += ipcomp.o
+obj-$(CONFIG_INET_XFRM_UDP_ENCAP) += xfrm4_udp_encap.o
 obj-$(CONFIG_INET_XFRM_TUNNEL) += xfrm4_tunnel.o
 obj-$(CONFIG_INET_XFRM_MODE_BEET) += xfrm4_mode_beet.o
 obj-$(CONFIG_INET_LRO) += inet_lro.o
Index: linux-2.6.30/net/ipv4/udp.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/udp.c
+++ linux-2.6.30/net/ipv4/udp.c
@@ -1377,6 +1377,7 @@ int udp_lib_setsockopt(struct sock *sk, 
 		case 0:
 		case UDP_ENCAP_ESPINUDP:
 		case UDP_ENCAP_ESPINUDP_NON_IKE:
+		case UDP_ENCAP_IP_VANILLA:
 			up->encap_rcv = xfrm4_udp_encap_rcv;
 			/* FALLTHROUGH */
 		case UDP_ENCAP_L2TPINUDP:
Index: linux-2.6.30/net/ipv4/xfrm4_input.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/xfrm4_input.c
+++ linux-2.6.30/net/ipv4/xfrm4_input.c
@@ -124,6 +124,10 @@ int xfrm4_udp_encap_rcv(struct sock *sk,
 			/* Must be an IKE packet.. pass it through */
 			return 1;
 		break;
+	case UDP_ENCAP_IP_VANILLA:
+		/* Note: The keep-alive packets are real BU packets in DSMIPv6 */
+		/* Let's parse the packet in a different handler */
+		return -IPPROTO_UDP_ENCAPSULATION;
 	}
 
 	/* At this point we are sure that this is an ESPinUDP packet,
Index: linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
===================================================================
--- /dev/null
+++ linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
@@ -0,0 +1,262 @@
+#include <linux/err.h>
+#include <linux/module.h>
+#include <net/ip.h>
+#include <net/xfrm.h>
+#include <asm/scatterlist.h>
+#include <linux/kernel.h>
+#include <linux/pfkeyv2.h>
+#include <linux/random.h>
+#include <net/icmp.h>
+#include <net/protocol.h>
+#include <net/udp.h>
+#include <net/inet_ecn.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+
+static int udp_encap_output(struct xfrm_state *x, struct sk_buff *skb)
+{
+	struct udphdr *uh;
+	struct iphdr *top_iph;
+
+	printk(KERN_INFO "xfrm_type: udp_encap_output entered\n");
+
+	skb_push(skb, -skb_network_offset(skb));
+
+	top_iph = (struct iphdr *) skb->network_header;
+	top_iph->tot_len = htons(skb->len);
+	/* this is non-NULL only with UDP Encapsulation */
+	if (x->encap) {
+		struct xfrm_encap_tmpl *encap = x->encap;
+
+		uh = (struct udphdr *) (top_iph + 1);
+		uh->source = encap->encap_sport;
+		uh->dest = encap->encap_dport;
+		uh->len = htons(skb->len - top_iph->ihl*4);
+		uh->check = 0;
+
+		top_iph->protocol = IPPROTO_UDP;
+	}
+
+	ip_send_check(top_iph);
+
+	return 0;
+}
+
+static int udp_encap_input(struct xfrm_state *x, struct sk_buff *skb)
+{
+	printk(KERN_INFO "udp_encap_input should not have been called\n");
+	return 0;
+}
+
+static u32 udp_encap_get_mtu(struct xfrm_state *x, int mtu)
+{ /* XXX : check if sizeof(udphdr) is accounted for */
+	return mtu + x->props.header_len;
+}
+
+static void udp_encap_proto_err(struct sk_buff *skb, u32 info)
+{
+	printk("udp_encap error : got an error by udp_encap_err...\n");
+}
+
+/* This function will reset some flags on the skb and resubmit as IP packet
+ * It is inspired from ipip_rcv
+ * Return 0 on success, -1 if packet must be dropped.
+ */
+static int resubmit_as_ip(struct sk_buff *skb, struct iphdr *top_iph)
+{
+	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
+		return -1;	/* No space for IP header. */
+
+	secpath_reset(skb);
+
+	skb->protocol = htons(ETH_P_IP);
+	skb->pkt_type = PACKET_HOST;
+
+	dst_release(skb->dst);
+	skb->dst = NULL;
+	nf_reset(skb);
+
+	if (INET_ECN_is_ce(top_iph->tos))
+		IP_ECN_set_ce(ip_hdr(skb));
+
+	netif_rx(skb);
+
+	return 0;
+}
+/* This function will reset some flags on the skb and resubmit as IPv6 packet
+ * It is inspired from ipip6_rcv
+ * Return 0 on success, -1 if packet must be dropped.
+ */
+static int resubmit_as_ipv6(struct sk_buff *skb, struct iphdr *top_iph)
+{
+	if (!pskb_may_pull(skb, sizeof(struct ipv6hdr)))
+		return -1;	/* No space for IPv6 header. */
+
+	secpath_reset(skb);
+
+	IPCB(skb)->flags = 0;
+	skb->protocol = htons(ETH_P_IPV6);
+	skb->pkt_type = PACKET_HOST;
+
+	dst_release(skb->dst);
+	skb->dst = NULL;
+	nf_reset(skb);
+
+	if (INET_ECN_is_ce(top_iph->tos))
+		IP6_ECN_set_ce(ipv6_hdr(skb));
+
+	netif_rx(skb);
+
+	return 0;
+}
+
+/* This function tries to find what kind of packet is in the UDP payload.
+ * It returns the IPPROTO_* value of the protocol, or -1 on error.
+ */
+static int find_inside_proto(struct sk_buff *skb)
+{
+	if (!pskb_may_pull(skb, sizeof(__u8)))
+		return -1; /* No space for anything. */
+
+	switch (ip_hdr(skb)->version) {
+		case 4: /* IP in the UDP vanilla encapsulation */
+			return IPPROTO_IP;
+
+		case 6: /* IPv6 in the UDP packet */
+			return IPPROTO_IPV6;
+
+		default:
+			printk(KERN_DEBUG "Unexpected UDP content (start with %x), dropped\n", *(int *)ip_hdr(skb));
+	}
+	/* Protocol not found */
+	return -1;
+}
+
+static int udp_encap_proto_input(struct sk_buff *skb)
+{
+	struct iphdr *top_iph = ip_hdr(skb);
+	__be32 saddr = top_iph->saddr;
+	__be32 daddr = top_iph->daddr;
+	struct udphdr *uh = udp_hdr(skb);
+	int proto=0;
+
+	/* This function was called by ip_local_deliver_finish after
+	    udp_rcv has resubmitted the skb */
+	printk(KERN_DEBUG "%s:%d - %s ( enter )\n", __FILE__, __LINE__, __FUNCTION__);
+
+	/* Check it's a real UDP packet that was resubmitted */
+	if (top_iph->protocol != IPPROTO_UDP) {
+		printk(KERN_DEBUG "Bad packet, dropped (proto %d)\n", top_iph->protocol);
+		goto drop;
+	}
+
+	/* We know here the packet has gone through UDP checks and is valid. */
+
+	/* Let's eat the UDP header */
+	skb_pull(skb, sizeof(struct udphdr));
+
+	/* And update the internal skb pointers */
+	skb->mac_header = skb->network_header;
+	skb_reset_network_header(skb);
+
+	/* We must save saddr and ntohs(uh->source) as ancialliary data here */
+	printk("Seb: TODO: save %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n", NIPQUAD(saddr), ntohs(uh->source), NIPQUAD(daddr), ntohs(uh->dest));
+
+	/* Now the inside is either IP or IPv6. We will do as in ipip_rcv or ipip6_rcv accordingly */
+	proto = find_inside_proto(skb);
+	switch (proto) {
+		case IPPROTO_IP: /* IP in the UDP vanilla encapsulation */
+			goto ipv4;
+
+		case IPPROTO_IPV6: /* IPv6 in the UDP packet */
+			goto ipv6;
+
+		default:
+			printk(KERN_DEBUG "Unsupported protocol (%d), dropped\n", proto);
+	}
+	goto drop;
+ipv4:
+	if (resubmit_as_ip(skb, top_iph) < 0)
+		goto drop;
+	goto end;
+
+ipv6:
+	if (resubmit_as_ipv6(skb, top_iph) < 0)
+		goto drop;
+	goto end;
+
+drop:
+	kfree_skb(skb);
+end:
+	return 0;
+}
+
+static void udp_encap_destroy(struct xfrm_state *x)
+{
+        return;
+}
+
+static int udp_encap_init_state(struct xfrm_state *x)
+{
+	if (x->props.mode != XFRM_MODE_TUNNEL)
+	        return -EINVAL;
+
+	if (!x->encap) /* Is this possible? */
+		return -EINVAL;
+
+	switch (x->encap->encap_type) {
+		case UDP_ENCAP_IP_VANILLA:
+			x->props.header_len = sizeof(struct iphdr) + sizeof(struct udphdr);
+			break;
+		default:
+		        return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static struct xfrm_type udp_encap_type =
+{
+	.description	= "UDP4",
+	.owner		= THIS_MODULE,
+	.proto	     	= IPPROTO_UDP_ENCAPSULATION,
+	.init_state	= udp_encap_init_state,
+	.destructor	= udp_encap_destroy,
+	.get_mtu	= udp_encap_get_mtu,
+	.input		= udp_encap_input, /* can we remove this? */
+	.output		= udp_encap_output
+};
+
+static struct net_protocol udp_encap_protocol = {
+	.handler	=	udp_encap_proto_input,
+	.err_handler	=	udp_encap_proto_err,
+	.no_policy	=	1,
+};
+
+static int __init udp_encap_init(void)
+{
+  printk(KERN_INFO "registering udp_encap type and protocol handler\n");
+	if (xfrm_register_type(&udp_encap_type, AF_INET) < 0) {
+		printk(KERN_INFO "ip udp_encap init: can't add xfrm type\n");
+		return -EAGAIN;
+	}
+ 	if (inet_add_protocol(&udp_encap_protocol, IPPROTO_UDP_ENCAPSULATION) < 0) {
+ 		printk(KERN_INFO "ip udp_encap init: can't add protocol\n");
+ 		xfrm_unregister_type(&udp_encap_type, AF_INET);
+ 		return -EAGAIN;
+ 	}
+	return 0;
+}
+
+static void __exit udp_encap_fini(void)
+{
+ 	if (inet_del_protocol(&udp_encap_protocol, IPPROTO_UDP_ENCAPSULATION) < 0)
+ 		printk(KERN_INFO "ip udp_encap close: can't remove protocol\n");
+	if (xfrm_unregister_type(&udp_encap_type, AF_INET) < 0)
+		printk(KERN_INFO "ip udp_encap close: can't remove xfrm type\n");
+}
+
+module_init(udp_encap_init);
+module_exit(udp_encap_fini);
+MODULE_LICENSE("GPL");
Index: linux-2.6.30/net/xfrm/xfrm_user.c
===================================================================
--- linux-2.6.30.orig/net/xfrm/xfrm_user.c
+++ linux-2.6.30/net/xfrm/xfrm_user.c
@@ -156,6 +156,16 @@ static int verify_newsa_info(struct xfrm
 			goto out;
 		break;
 
+	case IPPROTO_UDP_ENCAPSULATION:
+		if (attrs[XFRMA_ALG_COMP]	||
+		    attrs[XFRMA_ALG_AUTH]	||
+		    attrs[XFRMA_ALG_CRYPT]	||
+		    !attrs[XFRMA_ENCAP]		||
+		    attrs[XFRMA_SEC_CTX]	||
+		    attrs[XFRMA_COADDR])
+			goto out;
+		break;
+
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 	case IPPROTO_DSTOPTS:
 	case IPPROTO_ROUTING:
