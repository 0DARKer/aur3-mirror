Add support for the TLV-UDP encapsulation format.
Based on draft-ietf-mext-nemo-v4traversal-01

Author: Sebastien Decugis

Index: linux-2.6.30/include/linux/udp.h
===================================================================
--- linux-2.6.30.orig/include/linux/udp.h
+++ linux-2.6.30/include/linux/udp.h
@@ -35,6 +35,7 @@ struct udphdr {
 #define UDP_ENCAP_ESPINUDP	2 /* draft-ietf-ipsec-udp-encaps-06 */
 #define UDP_ENCAP_L2TPINUDP	3 /* rfc2661 */
 #define UDP_ENCAP_IP_VANILLA	4 /* draft-ietf-mext-nemo-v4traversal-01 */
+#define UDP_ENCAP_TLV		5 /* draft-ietf-mext-nemo-v4traversal-01 */
 
 #ifdef __KERNEL__
 #include <net/inet_sock.h>
Index: linux-2.6.30/net/ipv4/udp.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/udp.c
+++ linux-2.6.30/net/ipv4/udp.c
@@ -1378,6 +1378,7 @@ int udp_lib_setsockopt(struct sock *sk, 
 		case UDP_ENCAP_ESPINUDP:
 		case UDP_ENCAP_ESPINUDP_NON_IKE:
 		case UDP_ENCAP_IP_VANILLA:
+		case UDP_ENCAP_TLV:
 			up->encap_rcv = xfrm4_udp_encap_rcv;
 			/* FALLTHROUGH */
 		case UDP_ENCAP_L2TPINUDP:
Index: linux-2.6.30/net/ipv4/xfrm4_input.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/xfrm4_input.c
+++ linux-2.6.30/net/ipv4/xfrm4_input.c
@@ -125,7 +125,12 @@ int xfrm4_udp_encap_rcv(struct sock *sk,
 			return 1;
 		break;
 	case UDP_ENCAP_IP_VANILLA:
+	case UDP_ENCAP_TLV:
 		/* Note: The keep-alive packets are real BU packets in DSMIPv6 */
+
+		/* Save the encapsulation type in skb control buffer */
+		*(int *)skb->cb = encap_type;
+
 		/* Let's parse the packet in a different handler */
 		return -IPPROTO_UDP_ENCAPSULATION;
 	}
Index: linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/xfrm4_udp_encap.c
+++ linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
@@ -13,6 +13,46 @@
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv4.h>
 
+/* TLV as defined in draft-ietf-mext-nemo-v4traversal-01 */
+struct tlvhdr {
+	__u8		type;
+	__u8		length;	/* Note that this is probably too small and will be changed */
+	__u16		reserved;
+};
+
+enum tlv_type_t {
+	UDP_ENCAP_TLV_IPV4	= 1,
+	UDP_ENCAP_TLV_IPV6	= 2,
+	UDP_ENCAP_TLV_IPSEC	= 3,
+	UDP_ENCAP_TLV_GRE	= 4
+};
+
+/* Compute the type value for TLV from the packet inside.
+  - Only IPv4 and IPv6 are supported yet.
+  Returns 0 on success, <0 on error.
+*/
+static int get_tlv_type_from_packet(__u8 * type, __u8 * packet)
+{
+	struct iphdr * ip = (struct iphdr *)packet;
+	/* There is maybe a better way to find the protocol, in the skb struct for example... */
+	switch (ip->version) {
+		case 4:
+			*type = UDP_ENCAP_TLV_IPV4;
+			break;
+
+		case 6:
+			*type = UDP_ENCAP_TLV_IPV6;
+			break;
+
+		default:
+			printk(KERN_INFO "Unrecognized packet in %s: %x\n", __FUNCTION__, *packet);
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+
 static int udp_encap_output(struct xfrm_state *x, struct sk_buff *skb)
 {
 	struct udphdr *uh;
@@ -35,6 +75,17 @@ static int udp_encap_output(struct xfrm_
 		uh->check = 0;
 
 		top_iph->protocol = IPPROTO_UDP;
+
+		if (encap->encap_type == UDP_ENCAP_TLV) {
+			/* We must also add the TLV header here */
+			struct tlvhdr * tlvh = (struct tlvhdr *)(uh + 1);
+
+			if (get_tlv_type_from_packet(&tlvh->type,(__u8 *)(tlvh+1)))
+				return -EINVAL;
+
+			tlvh->length = skb->len - x->props.header_len;
+			tlvh->reserved = 0;
+		}
 	}
 
 	ip_send_check(top_iph);
@@ -115,18 +166,55 @@ static int resubmit_as_ipv6(struct sk_bu
  */
 static int find_inside_proto(struct sk_buff *skb)
 {
-	if (!pskb_may_pull(skb, sizeof(__u8)))
-		return -1; /* No space for anything. */
+	struct tlvhdr * tlvh;
+
+	switch (*(int *)skb->cb) {
+		case UDP_ENCAP_IP_VANILLA:
+			if (!pskb_may_pull(skb, sizeof(__u8)))
+				return -1; /* No space for anything. */
+
+			switch (ip_hdr(skb)->version) {
+				case 4: /* IP in the UDP vanilla encapsulation */
+					return IPPROTO_IP;
+
+				case 6: /* IPv6 in the UDP packet */
+					return IPPROTO_IPV6;
+
+				default:
+					printk(KERN_DEBUG "Unexpected UDP content (start with %x), dropped\n", *(int *)ip_hdr(skb));
+			}
+			break;
+
+		case UDP_ENCAP_TLV:
+			if (!pskb_may_pull(skb, sizeof(struct tlvhdr)))
+				return -1; /* No space for TLV header. */
 
-	switch (ip_hdr(skb)->version) {
-		case 4: /* IP in the UDP vanilla encapsulation */
-			return IPPROTO_IP;
+			tlvh = (struct tlvhdr *)skb_network_header(skb);
 
-		case 6: /* IPv6 in the UDP packet */
-			return IPPROTO_IPV6;
+			/* Eat the TLV header */
+			skb_pull(skb, sizeof(struct tlvhdr));
+			skb_reset_network_header(skb);
+
+			switch (tlvh->type) {
+				case UDP_ENCAP_TLV_IPV4:
+					return IPPROTO_IP;
+
+				case UDP_ENCAP_TLV_IPV6:
+					return IPPROTO_IPV6;
+
+				case UDP_ENCAP_TLV_IPSEC:
+					return IPPROTO_ESP;
+
+				case UDP_ENCAP_TLV_GRE:
+					return IPPROTO_GRE;
+
+				default:
+					printk(KERN_DEBUG "Unexpected type in TLV (%d), dropped\n", tlvh->type);
+			}
+			break;
 
 		default:
-			printk(KERN_DEBUG "Unexpected UDP content (start with %x), dropped\n", *(int *)ip_hdr(skb));
+			printk(KERN_DEBUG "Unexpected encap_type (%x)\n", *(int *)skb->cb);
 	}
 	/* Protocol not found */
 	return -1;
@@ -152,7 +240,7 @@ static int udp_encap_proto_input(struct 
 
 	/* We know here the packet has gone through UDP checks and is valid. */
 
-	/* Let's eat the UDP header */
+	/* Let's eat the UDP header -- TLV will be eaten later */
 	skb_pull(skb, sizeof(struct udphdr));
 
 	/* And update the internal skb pointers */
@@ -208,6 +296,8 @@ static int udp_encap_init_state(struct x
 		case UDP_ENCAP_IP_VANILLA:
 			x->props.header_len = sizeof(struct iphdr) + sizeof(struct udphdr);
 			break;
+		case UDP_ENCAP_TLV:
+			x->props.header_len = sizeof(struct iphdr) + sizeof(struct udphdr) + sizeof(struct tlvhdr);
 		default:
 		        return -EINVAL;
 	}
