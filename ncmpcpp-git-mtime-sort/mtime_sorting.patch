diff --git a/doc/config b/doc/config
index 01b2c01..e931f86 100644
--- a/doc/config
+++ b/doc/config
@@ -423,6 +423,8 @@
 #
 #media_library_disable_two_column_mode = "no"
 #
+#media_library_sort_by_mtime = "no"
+#
 #enable_window_title = "yes"
 #
 ##
diff --git a/doc/keys b/doc/keys
index 3248e4c..2cf7985 100644
--- a/doc/keys
+++ b/doc/keys
@@ -184,3 +184,4 @@
 #
 #key_quit = 'q' 'Q'
 #
+#key_toggle_media_library_sort_by_mtime = 'm'
diff --git a/src/help.cpp b/src/help.cpp
index 025b17c..70c1a39 100644
--- a/src/help.cpp
+++ b/src/help.cpp
@@ -295,7 +295,8 @@ void Help::GetKeybindings()
 	*w << DisplayKeys(Key.EditTags)			<< "Edit main tag/album/song's tags\n";
 #	endif // HAVE_TAGLIB_H
 	*w << DisplayKeys(Key.SwitchTagTypeList)	<< "Tag type list switcher (left column)\n";
-	
+    *w << DisplayKeys(Key.ToggleMediaLibrarySortByMTime)	<< "Toggle sort alphabetically or by mtime \n";
+
 	
 	*w << "\n\n   " << fmtBold << "Keys - Playlist Editor\n -----------------------------------------\n" << fmtBoldEnd;
 	*w << DisplayKeys(Key.PrevColumn)		<< "Previous column\n";
diff --git a/src/media_library.cpp b/src/media_library.cpp
index 6e38d9a..17b0f66 100644
--- a/src/media_library.cpp
+++ b/src/media_library.cpp
@@ -19,6 +19,9 @@
  ***************************************************************************/
 
 #include <algorithm>
+#include <utility>
+#include <map>
+#include <set>
 
 #include "charset.h"
 #include "display.h"
@@ -43,6 +46,12 @@ size_t MediaLibrary::itsMiddleColStartX;
 size_t MediaLibrary::itsRightColWidth;
 size_t MediaLibrary::itsRightColStartX;
 
+bool MediaLibrary::mtimeMapsOutdated;
+std::set<MediaLibrary::album_mtime_flags> MediaLibrary::initedAlbumMTimeMaps;
+MediaLibrary::album_mtime_map MediaLibrary::albumMTimeMap;
+std::set<mpd_tag_type> MediaLibrary::initedArtistMTimeMaps;
+MediaLibrary::artist_mtime_map MediaLibrary::artistMTimeMap;
+
 // this string marks the position in middle column that works as "All tracks" option. it's
 // assigned to Year in SearchConstraint class since date normally cannot contain other chars
 // than ciphers and -'s (0x7f is interpreted as backspace keycode, so it's quite safe to assume
@@ -89,6 +98,9 @@ void MediaLibrary::Init()
 	Songs->SetGetStringFunction(SongToString);
 	
 	w = Artists;
+
+    mtimeMapsOutdated = true;
+
 	isInitialized = 1;
 }
 
@@ -162,7 +174,7 @@ void MediaLibrary::SwitchTo()
 				{
 					std::string item_type = IntoStr(Config.media_lib_primary_tag);
 					ToLower(item_type);
-					Albums->SetTitle("Albums (sorted by " + item_type + ")");
+					Albums->SetTitle("Albums (with " + item_type + ")");
 				}
 				else
 					Albums->SetTitle("");
@@ -202,7 +214,6 @@ void MediaLibrary::Update()
 		Albums->Clear();
 		Songs->Clear();
 		Mpd.GetList(list, Config.media_lib_primary_tag);
-		sort(list.begin(), list.end(), CaseInsensitiveSorting());
 		for (MPD::TagList::iterator it = list.begin(); it != list.end(); ++it)
 		{
 			if (it->empty() && !Config.media_library_display_empty_tag)
@@ -210,6 +221,10 @@ void MediaLibrary::Update()
 			utf_to_locale(*it);
 			Artists->AddOption(*it);
 		}
+        if (Config.media_library_sort_by_mtime) 
+            Artists->Sort<MTimeArtistSorting>();
+        else
+            Artists->Sort<CaseInsensitiveSorting>();
 		Artists->Window::Clear();
 		Artists->Refresh();
 	}
@@ -240,18 +255,23 @@ void MediaLibrary::Update()
 				for (MPD::TagList::iterator j = l.begin(); j != l.end(); ++j)
 				{
 					utf_to_locale(*j);
-					Albums->AddOption(SearchConstraints(*it, *j));
+					Albums->AddOption(SearchConstraints(Artists->Current(), 
+                                                        *it, 
+                                                        *j));
 				}
 			}
 			else
 			{
 				utf_to_locale(*it);
-				Albums->AddOption(SearchConstraints(*it, ""));
+				Albums->AddOption(SearchConstraints(Artists->Current(), *it, ""));
 			}
 		}
 		utf_to_locale(Artists->Current());
-		if (!Albums->Empty())
-			Albums->Sort<SearchConstraintsSorting>();
+		if (!Albums->Empty()) 
+            if (Config.media_library_sort_by_mtime)
+                Albums->Sort<MTimeAlbumSorting>();
+            else
+                Albums->Sort<SearchConstraintsSorting>();
 		if (Albums->Size() > 1)
 		{
 			Albums->AddSeparator();
@@ -310,7 +330,10 @@ void MediaLibrary::Update()
 		}
 		Mpd.BlockIdle(0);
 		if (!Albums->Empty())
-			Albums->Sort<SearchConstraintsSorting>();
+            if (Config.media_library_sort_by_mtime)
+			    Albums->Sort<MTimeAlbumSorting>();
+            else
+                Albums->Sort<SearchConstraintsSorting>();
 		Albums->Refresh();
 	}
 	
@@ -785,6 +808,203 @@ bool MediaLibrary::SearchConstraintsSorting::operator()(const SearchConstraints
 	return (result == 0 ? cmp(a.Album, b.Album) : result) < 0;
 }
 
+
+void MediaLibrary::ensureMTimeMapsUpToDate() {
+    if (mtimeMapsOutdated) {
+        albumMTimeMap.clear();
+        initedAlbumMTimeMaps.clear();
+        artistMTimeMap.clear();
+        initedArtistMTimeMaps.clear();
+        mtimeMapsOutdated = false;
+    }
+}
+
+
+
+bool MediaLibrary::AlbumMapSorting::operator()(const album_mtime_key &a, 
+                                               const album_mtime_key &b) const 
+{
+    if (a.first == b.first) {
+        return scs(a.second, b.second);
+    } else {
+        return a.first < b.first;
+    }
+}
+
+
+bool MediaLibrary::MTimeAlbumSorting::operator()(const SearchConstraints &a, 
+                                                 const SearchConstraints &b)
+{
+    mpd_tag_type tt = Config.media_lib_primary_tag;
+    bool dd = Config.media_library_display_date;
+    time_t ta = MediaLibrary::getAddAlbumMTime(tt, dd, a);
+    time_t tb = MediaLibrary::getAddAlbumMTime(tt, dd, b);
+    return ta > tb;
+}
+
+time_t MediaLibrary::getAddAlbumMTime(const mpd_tag_type primary_tag,
+                                      const bool display_date,
+                                      const SearchConstraints &a) {
+    forceInitedAlbumMTimeMap(primary_tag, display_date);
+
+    album_mtime_flags f = std::make_pair(primary_tag, display_date);
+    album_mtime_key key = std::make_pair(f, a);
+    album_mtime_map::iterator it;
+    it = albumMTimeMap.find(key);
+    time_t time = 0;
+    if (it == albumMTimeMap.end()) {
+        time = getAlbumMTime(primary_tag, display_date, a);
+        albumMTimeMap.insert(std::make_pair(key, time));
+    } else {
+        time = it->second;
+    }
+    return time;
+}
+
+time_t MediaLibrary::getAlbumMTime(const mpd_tag_type primary_tag, 
+                                   const bool display_date,
+                                   const SearchConstraints &a) {
+    // make this the newest song with same album tag
+    MPD::SongList list;
+		
+    Mpd.StartSearch(1);
+    Mpd.AddSearch(MPD_TAG_ALBUM, locale_to_utf_cpy(a.Album));
+    Mpd.AddSearch(MPD_TAG_DATE, locale_to_utf_cpy(a.Year));
+
+    if (a.PrimaryTag.length() > 0) {
+	    Mpd.AddSearch(primary_tag,
+                      locale_to_utf_cpy(a.PrimaryTag));
+    }
+    if (display_date) {
+	    Mpd.AddSearch(MPD_TAG_DATE, locale_to_utf_cpy(a.Year));
+    }
+    Mpd.CommitSearch(list);
+		
+    time_t time = 0;
+    for (MPD::SongList::const_iterator it = list.begin(); 
+         it != list.end(); 
+         ++it) {
+        time = std::max(time, (*it)->GetMTime());
+	}
+    return time;
+}
+
+void MediaLibrary::forceInitedAlbumMTimeMap(const mpd_tag_type primary_tag,
+                                            const bool display_date) {
+    ensureMTimeMapsUpToDate();
+
+    album_mtime_flags f = std::make_pair(primary_tag, display_date);
+    if (initedAlbumMTimeMaps.count(f) == 0) {
+        MPD::SongList list;
+        Mpd.GetDirectoryRecursive("/", list);
+        for (MPD::SongList::const_iterator it = list.begin(); 
+             it != list.end(); 
+            ++it) {
+            std::string date = display_date ? (*it)->GetDate() : "";
+            updateAlbumMTimeMap(primary_tag,
+                                display_date,
+                                SearchConstraints((*it)->GetTag(primary_tag),
+                                                  (*it)->GetAlbum(),
+                                                  date),
+                                (*it)->GetMTime());
+	    }
+
+        initedAlbumMTimeMaps.insert(f);
+    }
+}
+
+void MediaLibrary::updateAlbumMTimeMap(const mpd_tag_type primary_tag,
+                                       const bool display_date,
+                                       const SearchConstraints &a, 
+                                       const time_t time) {
+    album_mtime_map::iterator it;
+    album_mtime_flags f = std::make_pair(primary_tag, display_date);
+    album_mtime_key key = std::make_pair(f, a);
+    it = albumMTimeMap.find(key);
+    if (it == albumMTimeMap.end()) {
+        albumMTimeMap.insert(std::make_pair(key, time));
+    } else {
+        it->second = std::max(it->second, time);
+    }
+}
+
+
+bool MediaLibrary::MTimeArtistSorting::operator()(const std::string &a, 
+                                                  const std::string &b)
+{
+    mpd_tag_type tt = Config.media_lib_primary_tag;
+    time_t ta = MediaLibrary::getAddArtistMTime(tt, a);
+    time_t tb = MediaLibrary::getAddArtistMTime(tt, b);
+    return ta > tb;
+}
+
+time_t MediaLibrary::getAddArtistMTime(const mpd_tag_type primary_tag,
+                                       const std::string &a) {
+    forceInitedArtistMTimeMap(primary_tag);
+
+    artist_mtime_map::iterator it;
+    artist_mtime_key key = std::make_pair(primary_tag, a);
+    it = artistMTimeMap.find(key);
+    time_t time = 0;
+    if (it == artistMTimeMap.end()) {
+        time = getArtistMTime(primary_tag, a);
+        artistMTimeMap.insert(std::make_pair(key, time));
+    } else {
+        time = it->second;
+    }
+    return time;
+}
+
+void MediaLibrary::forceInitedArtistMTimeMap(const mpd_tag_type primary_tag) {
+    ensureMTimeMapsUpToDate();
+
+    if (initedArtistMTimeMaps.count(primary_tag) == 0) {
+        MPD::SongList list;
+        Mpd.GetDirectoryRecursive("/", list);
+        for (MPD::SongList::const_iterator it = list.begin(); 
+             it != list.end(); 
+            ++it) {
+            updateArtistMTimeMap(primary_tag,
+                                 (*it)->GetTag(primary_tag),
+                                 (*it)->GetMTime());
+        }
+
+        initedArtistMTimeMaps.insert(primary_tag);
+    }
+}
+
+void MediaLibrary::updateArtistMTimeMap(const mpd_tag_type primary_tag,
+                                        const std::string &a, 
+                                        const time_t time) {
+    artist_mtime_map::iterator it;
+    artist_mtime_key key = std::make_pair(primary_tag, a);
+    it = artistMTimeMap.find(key);
+    if (it == artistMTimeMap.end()) {
+        artistMTimeMap.insert(std::make_pair(key, time));
+    } else {
+        it->second = std::max(it->second, time);
+    }
+}
+
+
+time_t MediaLibrary::getArtistMTime(const mpd_tag_type primary_tag,
+                                    const std::string &a) {
+    MPD::SongList list;
+		
+    Mpd.StartSearch(1);
+	Mpd.AddSearch(primary_tag, locale_to_utf_cpy(a));
+    Mpd.CommitSearch(list);
+		
+    time_t time = 0;
+    for (MPD::SongList::const_iterator it = list.begin(); 
+         it != list.end(); 
+         ++it) {
+        time = std::max(time, (*it)->GetMTime());
+	}
+    return time;
+}
+
+
 bool MediaLibrary::SortSongsByTrack(MPD::Song *a, MPD::Song *b)
 {
 	if (a->GetDisc() == b->GetDisc())
diff --git a/src/media_library.h b/src/media_library.h
index 1b07f92..74d3ffb 100644
--- a/src/media_library.h
+++ b/src/media_library.h
@@ -21,6 +21,9 @@
 #ifndef _H_MEDIA_LIBRARY
 #define _H_MEDIA_LIBRARY
 
+#include <map>
+#include <set>
+
 #include "ncmpcpp.h"
 #include "screen.h"
 
@@ -40,6 +43,71 @@ class MediaLibrary : public Screen<Window>
 	{
 		bool operator()(const SearchConstraints &a, const SearchConstraints &b) const;
 	};
+
+
+    // typedefs map keys
+    typedef std::pair<mpd_tag_type, bool> album_mtime_flags;
+    typedef std::pair<album_mtime_flags,
+                      SearchConstraints> album_mtime_key;
+    typedef std::pair<mpd_tag_type, std::string> artist_mtime_key;
+
+    // sorting for maps
+	struct AlbumMapSorting
+	{
+        SearchConstraintsSorting scs;
+
+		bool operator()(const album_mtime_key &a, const album_mtime_key &b) const;
+	};
+
+    // typedefs for maps
+    typedef std::map<album_mtime_key, 
+                    time_t, 
+                    AlbumMapSorting> album_mtime_map;
+    typedef std::map<artist_mtime_key,
+                     time_t> artist_mtime_map; 
+
+    // timestamp to make sure maps up to date
+    static bool mtimeMapsOutdated;
+    // erases maps if out of date
+    static void ensureMTimeMapsUpToDate();
+
+    // contains set of primary tags for which map has been initialised
+    static std::set<album_mtime_flags> initedAlbumMTimeMaps;
+    static album_mtime_map albumMTimeMap;
+
+    static void forceInitedAlbumMTimeMap(const mpd_tag_type primary_tag,
+                                         const bool display_date);
+    static void updateAlbumMTimeMap(const mpd_tag_type primary_tag,
+                                    const bool display_date,
+                                    const SearchConstraints &a, 
+                                    const time_t time);
+    static time_t getAddAlbumMTime(const mpd_tag_type primary_tag,
+                                   const bool display_date,
+                                   const SearchConstraints &a);
+    static time_t getAlbumMTime(const mpd_tag_type primary_tag,
+                                const bool display_date,
+                                const SearchConstraints &a);
+    struct MTimeAlbumSorting 
+    {
+        bool operator()(const SearchConstraints &a, const SearchConstraints &b);
+    };
+
+    static std::set<mpd_tag_type> initedArtistMTimeMaps;
+    static artist_mtime_map artistMTimeMap;
+
+    static void forceInitedArtistMTimeMap(const mpd_tag_type primary_tag);
+    static time_t getAddArtistMTime(const mpd_tag_type primary_tag,
+                                    const std::string &a);
+    static time_t getArtistMTime(const mpd_tag_type primary_tag,
+                                 const std::string &a);
+    static void updateArtistMTimeMap(const mpd_tag_type primary_tag,
+                                     const std::string &a, 
+                                     const time_t time);
+    struct MTimeArtistSorting 
+    {
+        bool operator()(const std::string &a, const std::string &b);
+    };
+
 	
 	public:
 		virtual void SwitchTo();
@@ -77,6 +145,8 @@ class MediaLibrary : public Screen<Window>
 		Menu<std::string> *Artists;
 		Menu<SearchConstraints> *Albums;
 		Menu<MPD::Song> *Songs;
+
+        void DatabaseUpdated() { mtimeMapsOutdated = true; }
 		
 	protected:
 		virtual void Init();
diff --git a/src/ncmpcpp.cpp b/src/ncmpcpp.cpp
index 1e003ae..2f1cbf2 100644
--- a/src/ncmpcpp.cpp
+++ b/src/ncmpcpp.cpp
@@ -460,8 +460,20 @@ int main(int argc, char **argv)
 		title_allowed = 1;
 		
 		// key mapping beginning
-		
-		if (Keypressed(input, Key.Up))
+		if (Keypressed(input, Key.ToggleMediaLibrarySortByMTime) &&
+            myScreen == myLibrary) 
+        {
+            Config.media_library_sort_by_mtime = !Config.media_library_sort_by_mtime;
+            if (Config.media_library_sort_by_mtime) 
+                ShowMessage("Sorting by mtime...");
+            else
+                ShowMessage("Sorting alphabetically...");
+            myLibrary->Artists->Clear();
+            myLibrary->Albums->Clear();
+            myLibrary->Songs->Clear();
+            myLibrary->Update();
+        }
+		else if (Keypressed(input, Key.Up))
 		{
 			myScreen->Scroll(wUp, Key.Up);
 		}
diff --git a/src/settings.cpp b/src/settings.cpp
index 0ce6c4e..83279b6 100644
--- a/src/settings.cpp
+++ b/src/settings.cpp
@@ -267,6 +267,7 @@ void NcmpcppKeys::SetDefaults()
 	GoToParentDir[0] = KEY_BACKSPACE;
 	SwitchTagTypeList[0] = '`';
 	Quit[0] = 'q';
+    ToggleMediaLibrarySortByMTime[0] = 'm';
 
 	Up[1] = 'k';
 	Down[1] = 'j';
@@ -357,6 +358,7 @@ void NcmpcppKeys::SetDefaults()
 	GoToParentDir[1] = 127;
 	SwitchTagTypeList[1] = NullKey;
 	Quit[1] = 'Q';
+    ToggleMediaLibrarySortByMTime[1] = NullKey;
 }
 
 void NcmpcppConfig::SetDefaults()
@@ -443,6 +445,7 @@ void NcmpcppConfig::SetDefaults()
 	visualizer_use_wave = true;
 	visualizer_in_stereo = false;
 	browser_sort_by_mtime = false;
+	media_library_sort_by_mtime = false;
 	tag_editor_extended_numeration = false;
 	media_library_display_date = true;
 	media_library_display_empty_tag = true;
@@ -663,6 +666,8 @@ void NcmpcppKeys::Read()
 				GetKeys(key, SwitchTagTypeList);
 			else if (name == "key_quit")
 				GetKeys(key, Quit);
+			else if (name == "toggle_media_library_sort_by_mtime")
+				GetKeys(key, ToggleMediaLibrarySortByMTime);
 		}
 	}
 	f.close();
@@ -1327,6 +1332,10 @@ void NcmpcppConfig::Read()
 				if (!v.empty())
 					media_lib_primary_tag = IntoTagItem(v[0]);
 			}
+			else if (name == "media_library_sort_by_mtime")
+			{
+				media_library_sort_by_mtime = v == "yes";
+			}
 		}
 	}
 	f.close();
diff --git a/src/settings.h b/src/settings.h
index eaa3d66..c49ee6d 100644
--- a/src/settings.h
+++ b/src/settings.h
@@ -138,6 +138,7 @@ struct NcmpcppKeys
 	int GoToParentDir[2];
 	int SwitchTagTypeList[2];
 	int Quit[2];
+    int ToggleMediaLibrarySortByMTime[2];
 };
 
 struct NcmpcppConfig
@@ -252,6 +253,7 @@ struct NcmpcppConfig
 	bool visualizer_use_wave;
 	bool visualizer_in_stereo;
 	bool browser_sort_by_mtime;
+    bool media_library_sort_by_mtime;
 	bool tag_editor_extended_numeration;
 	bool media_library_display_date;
 	bool media_library_display_empty_tag;
diff --git a/src/song.h b/src/song.h
index 87b5042..2506d4e 100644
--- a/src/song.h
+++ b/src/song.h
@@ -104,13 +104,15 @@ namespace MPD
 			
 			static std::string ShowTime(int);
 			static bool isFormatOk(const std::string &type, const std::string &format);
+
+
+			std::string GetTag(mpd_tag_type, unsigned = 0) const;
 			
 		private:
 			void SetHashAndSlash();
 			std::string ParseFormat(std::string::const_iterator &it, const char *escape_chars) const;
 			
 			void SetTag(mpd_tag_type, unsigned, const std::string &);
-			std::string GetTag(mpd_tag_type, unsigned) const;
 			
 			/// Used internally for handling filename, since we don't have
 			/// write access to file string in mpd_song, manage our own if
diff --git a/src/status.cpp b/src/status.cpp
index f26e025..ab879a4 100644
--- a/src/status.cpp
+++ b/src/status.cpp
@@ -560,6 +560,8 @@ void NcmpcppStatusChanged(MPD::Connection *, MPD::StatusChanges changed, void *)
 		if (!Mpd.SupportsIdle() || Mpd.Version() > 15)
 			mpd_db_updating = Mpd.GetDBIsUpdating() ? 'U' : 0;
 		ShowMessage(Mpd.GetDBIsUpdating() ? "Database update started!" : "Database update finished!");
+        // after db update finished, mtime maps in myLibrary are out of date
+        myLibrary->DatabaseUpdated();
 		if (changed.Database && myScreen == mySelectedItemsAdder)
 		{
 			myScreen->SwitchTo(); // switch to previous screen
