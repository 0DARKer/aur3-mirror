diff -ru hal-0.5.14/hald/linux/osspec.c hal-netlink-events/hald/linux/osspec.c
--- hal-0.5.14/hald/linux/osspec.c	2009-08-24 05:42:30.000000000 -0700
+++ hal-netlink-events/hald/linux/osspec.c	2012-06-16 13:02:33.833352693 -0700
@@ -44,6 +44,7 @@
 #include <sys/un.h>
 #include <sys/utsname.h>
 #include <unistd.h>
+#include <linux/netlink.h>
 
 #include <dbus/dbus.h>
 #include <dbus/dbus-glib.h>
@@ -117,6 +118,11 @@
 		goto out;
 	}
 
+	if (strcmp(buf, "libudev")==0) {
+		/* NETLINK events send this line intermittently. */
+		goto out;
+	}
+
 	if (!strstr(buf, "@/")) {
 		HAL_INFO (("invalid message format"));
 		goto out;
@@ -406,40 +412,41 @@
 void
 osspec_init (void)
 {
-	int udev_socket;
-	struct sockaddr_un saddr;
-	socklen_t addrlen;
+	int netlink_socket;
+	struct sockaddr_nl netlink_addr;
 	const int on = 1;
-	GIOChannel *udev_channel;
+	GIOChannel *netlink_channel;
 	GIOChannel *mounts_channel;
-
+ 
 	/*
 	 * setup socket for listening from messages from udev
 	 */
 
 	hal_device_store_index_property (hald_get_gdl (), "linux.sysfs_path");
 
-	memset(&saddr, 0x00, sizeof(saddr));
-	saddr.sun_family = AF_LOCAL;
-	/* use abstract namespace for socket path */
-	strcpy(&saddr.sun_path[1], "/org/freedesktop/hal/udev_event");
-	addrlen = offsetof(struct sockaddr_un, sun_path) + strlen(saddr.sun_path+1) + 1;
-
-	udev_socket = socket(AF_LOCAL, SOCK_DGRAM, 0);
-	if (udev_socket == -1) {
-		DIE (("Couldn't open socket"));
+	memset (&netlink_addr, 0, sizeof (netlink_addr));
+	netlink_addr.nl_family = AF_NETLINK;
+	netlink_addr.nl_pid = getpid ();
+	netlink_addr.nl_groups = 0xffffffff;//RTMGRP_LINK;
+
+
+	/* hook up to netlink socket to receive events from the *Kernel Events Layer* */
+	netlink_socket = socket (PF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
+
+	if (netlink_socket < 0) {
+		DIE (("Unable to create netlink socket"));
 	}
 
-	if (bind(udev_socket, (struct sockaddr *) &saddr, addrlen) < 0) {
-		fprintf (stderr, "Error binding udev_event socket: %s\n", strerror(errno));
-		exit (1);
+	if (bind (netlink_socket, (struct sockaddr *) &netlink_addr, sizeof (netlink_addr)) < 0) {
+		DIE (("Unable to bind to netlink socket"));
 	}
 	/* enable receiving of the sender credentials */
-	setsockopt(udev_socket, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
+	setsockopt(netlink_socket, SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
+
+	netlink_channel = g_io_channel_unix_new (netlink_socket);
+	g_io_add_watch (netlink_channel, G_IO_IN, hald_udev_data, NULL);
+	g_io_channel_unref (netlink_channel);
 
-	udev_channel = g_io_channel_unix_new (udev_socket);
-	g_io_add_watch (udev_channel, G_IO_IN, hald_udev_data, NULL);
-	g_io_channel_unref (udev_channel);
 
 	/* watch /proc/mounts for mount tree changes
 	 * kernel 2.6.15 vfs throws a POLLERR event for every change
