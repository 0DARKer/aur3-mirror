#! /bin/bash
. /usr/lib/network/network

wait_for_link() {
    # Returns 0 when a link is detected, 1 otherwise
    for i in {1..10}; do
        sleep .2
        if ip link show $1|grep -q "state UP"; then
            return 0
        fi
    done
    return 1
}

bonding_up() {
    load_profile $1

    let slaves_up=0

    # Add the master interface
    ip link set $INTERFACE up || return 1

    # Add slaves
    for S in $SLAVES; do
        ifenslave -d $INTERFACE $S &>/dev/null
        ip link set $S up || return 1
        ifenslave $INTERFACE $S || return 1
        if [[ $slaves_up -eq 0 ]]; then
            let timeout=0
            until ! ip link show $S|grep -q "state UP"; do
                sleep 0.5
                let timeout++
                if  [[ $timeout -eq 5 ]]; then
                    report_fail "Slave $S is down"
                    break
                fi                
            done
            if ! ip link show $S|grep -q "state UP"; then
                let slaves_up++
            fi
        fi
    done

    # If no slave is up, abort
    if [[ $slaves_up -eq 0 ]]; then
        report_fail "No slave up"
        return 1
    fi

    # Wait for the bonding interface to be up
    while ! ip link show $INTERFACE|grep -q "state UP"; do
        sleep .2
    done

    # Now do as if it were a simple ethernet interface
    /usr/lib/network/connections/ethernet-iproute up $1
}

bonding_down() {
    load_profile $1

    # Remove slaves
    for S in $SLAVES; do
        ifenslave -d $INTERFACE $S
        ip link set $S down || return 1
    done

    /usr/lib/network/connections/ethernet-iproute down $1
}

bonding_$1 $2
exit $?
