--- prettytable.py	(original)
+++ prettytable.py	(refactored)
@@ -31,7 +31,7 @@
 
 import cgi
 import copy
-import cPickle
+import pickle
 import sys
 
 FRAME = 0
@@ -108,8 +108,8 @@
             self.widths = [len(field) for field in fields]
             for row in self.rows:
                 for i in range(0,len(row)):
-                    if len(unicode(row[i])) > self.widths[i]:
-                        self.widths[i] = len(unicode(row[i]))
+                    if len(str(row[i])) > self.widths[i]:
+                        self.widths[i] = len(str(row[i]))
         else:
             self.widths = [len(field) for field in fields]
         self.fields = fields
@@ -145,7 +145,7 @@
         try:
             assert int(padding_width) >= 0
         except AssertionError:
-            raise Exception("Invalid value for padding_width: %s!" % unicode(padding_width))
+            raise Exception("Invalid value for padding_width: %s!" % str(padding_width))
 
         self.padding_width = padding_width
         self.cache = {}
@@ -162,7 +162,7 @@
         try:
             assert left_padding == None or int(left_padding) >= 0
         except AssertionError:
-            raise Exception("Invalid value for left_padding: %s!" % unicode(left_padding))
+            raise Exception("Invalid value for left_padding: %s!" % str(left_padding))
 
         self.left_padding = left_padding
         self.cache = {}
@@ -179,7 +179,7 @@
         try:
             assert right_padding == None or int(right_padding) >= 0
         except AssertionError:
-            raise Exception("Invalid value for right_padding: %s!" % unicode(right_padding))
+            raise Exception("Invalid value for right_padding: %s!" % str(right_padding))
 
         self.right_padding = right_padding
         self.cache = {}
@@ -219,8 +219,8 @@
             raise Exception("Row has incorrect number of values, (actual) %d!=%d (expected)" %(len(row),len(self.fields)))
         self.rows.append(row)
         for i in range(0,len(row)):
-            if len(unicode(row[i])) > self.widths[i]:
-                self.widths[i] = len(unicode(row[i]))
+            if len(str(row[i])) > self.widths[i]:
+                self.widths[i] = len(str(row[i]))
         self.html_cache = {}
 
     def add_column(self, fieldname, column, align="c"):
@@ -244,8 +244,8 @@
                 if len(self.rows) < i+1:
                     self.rows.append([])
                 self.rows[i].append(column[i])
-                if len(unicode(column[i])) > self.widths[-1]:
-                    self.widths[-1] = len(unicode(column[i]))
+                if len(str(column[i])) > self.widths[-1]:
+                    self.widths[-1] = len(str(column[i]))
         else:
             raise Exception("Column length %d does not match number of rows %d!" % (len(column), len(self.rows)))
 
@@ -295,7 +295,7 @@
         border - should be True or False to print or not print borders
         hrules - controls printing of horizontal rules after each row.  Allowed values: FRAME, ALL, NONE"""
 
-        print self.get_string(start, end, fields, header, border, hrules, sortby, reversesort)
+        print(self.get_string(start, end, fields, header, border, hrules, sortby, reversesort))
 
     def get_string(self, start=0, end=None, fields=None, header=True, border=True, hrules=FRAME, sortby=None, reversesort=False):
 
@@ -312,7 +312,7 @@
         hrules - controls printing of horizontal rules after each row.  Allowed values: FRAME, ALL, NONE"""
 
         if self.caching:
-            key = cPickle.dumps((start, end, fields, header, border, hrules, sortby, reversesort))
+            key = pickle.dumps((start, end, fields, header, border, hrules, sortby, reversesort))
             if key in self.cache:
                 return self.cache[key]
 
@@ -326,8 +326,8 @@
             self.widths = [0]*len(self.fields)
             for row in self.rows:
                 for i in range(0,len(row)):
-                    if len(unicode(row[i])) > self.widths[i]:
-                        self.widths[i] = len(unicode(row[i]))
+                    if len(str(row[i])) > self.widths[i]:
+                        self.widths[i] = len(str(row[i]))
         if header:
             bits.append(self._stringify_header(fields, border, hrules))
         elif border and hrules != NONE:
@@ -350,8 +350,8 @@
             self.widths = old_widths
             for row in self.rows:
                 for i in range(0,len(row)):
-                    if len(unicode(row[i])) > self.widths[i]:
-                        self.widths[i] = len(unicode(row[i]))
+                    if len(str(row[i])) > self.widths[i]:
+                        self.widths[i] = len(str(row[i]))
 
         return string
 
@@ -399,11 +399,11 @@
             if fields and field not in fields:
                 continue
             if align == "l":
-                bits.append(" " * lpad + unicode(value).ljust(width) + " " * rpad)
+                bits.append(" " * lpad + str(value).ljust(width) + " " * rpad)
             elif align == "r":
-                bits.append(" " * lpad + unicode(value).rjust(width) + " " * rpad)
+                bits.append(" " * lpad + str(value).rjust(width) + " " * rpad)
             else:
-                bits.append(" " * lpad + unicode(value).center(width) + " " * rpad)
+                bits.append(" " * lpad + str(value).center(width) + " " * rpad)
             if border:
                 bits.append(self.vertical_char)
         if border and hrule == ALL:
@@ -431,7 +431,7 @@
         hrules - include horizontal rule after each row
         attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag"""
 
-        print self.get_html_string(start, end, fields, sortby, reversesort, format, header, border, hrules, attributes)
+        print(self.get_html_string(start, end, fields, sortby, reversesort, format, header, border, hrules, attributes))
 
     def get_html_string(self, start=0, end=None, fields=None, sortby=None, reversesort=False, format=True, header=True, border=True, hrules=FRAME, attributes=None):
 
@@ -451,7 +451,7 @@
         attributes - dictionary of name/value pairs to include as HTML attributes in the <table> tag"""
 
         if self.caching:
-            key = cPickle.dumps((start, end, fields, format, header, border, hrules, sortby, reversesort, attributes))
+            key = pickle.dumps((start, end, fields, format, header, border, hrules, sortby, reversesort, attributes))
             if key in self.html_cache:
                 return self.html_cache[key]
 
@@ -483,7 +483,7 @@
         for field in self.fields:
             if fields and field not in fields:
                 continue
-            bits.append("        <th>%s</th>" % cgi.escape(unicode(field)))
+            bits.append("        <th>%s</th>" % cgi.escape(str(field)))
         bits.append("    </tr>")
         # Data
         if sortby:
@@ -495,7 +495,7 @@
             for field, datum in zip(self.fields, row):
                 if fields and field not in fields:
                     continue
-                bits.append("        <td>%s</td>" % cgi.escape(unicode(datum)))
+                bits.append("        <td>%s</td>" % cgi.escape(str(datum)))
         bits.append("    </tr>")
         bits.append("</table>")
         string = "\n".join(bits)
@@ -523,7 +523,7 @@
             for field in self.fields:
                 if fields and field not in fields:
                     continue
-                bits.append("        <th style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</th>" % (lpad, rpad, cgi.escape(unicode(field))))
+                bits.append("        <th style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</th>" % (lpad, rpad, cgi.escape(str(field))))
             bits.append("    </tr>")
         # Data
         if sortby:
@@ -536,11 +536,11 @@
                 if fields and field not in fields:
                     continue
                 if align == "l":
-                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: left\">%s</td>" % (lpad, rpad, cgi.escape(unicode(datum))))
+                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: left\">%s</td>" % (lpad, rpad, cgi.escape(str(datum))))
                 elif align == "r":
-                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: right\">%s</td>" % (lpad, rpad, cgi.escape(unicode(datum))))
+                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: right\">%s</td>" % (lpad, rpad, cgi.escape(str(datum))))
                 else:
-                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</td>" % (lpad, rpad, cgi.escape(unicode(datum))))
+                    bits.append("        <td style=\"padding-left: %dem; padding-right: %dem; text-align: center\">%s</td>" % (lpad, rpad, cgi.escape(str(datum))))
         bits.append("    </tr>")
         bits.append("</table>")
         string = "\n".join(bits)
@@ -558,34 +558,34 @@
     x.add_row(["Sydney", 2058, 4336374, 1214.8])
     x.add_row(["Melbourne", 1566, 3806092, 646.9])
     x.add_row(["Perth", 5386, 1554769, 869.4])
-    print x
+    print(x)
 
     if len(sys.argv) > 1 and sys.argv[1] == "test":
 
     # This "test suite" is hideous and provides poor, arbitrary coverage.
     # I'll replace it with some proper unit tests Sometime Soon (TM).
     # Promise.
-        print "Testing field subset selection:"
+        print("Testing field subset selection:")
         x.printt(fields=["City name","Population"])
-        print "Testing row subset selection:"
+        print("Testing row subset selection:")
         x.printt(start=2, end=5)
-        print "Testing hrules settings:"
-        print "FRAME:"
+        print("Testing hrules settings:")
+        print("FRAME:")
         x.printt(hrules=FRAME)
-        print "ALL:"
+        print("ALL:")
         x.printt(hrules=ALL)
-        print "NONE:"
+        print("NONE:")
         x.printt(hrules=NONE)
-        print "Testing lack of headers:"
+        print("Testing lack of headers:")
         x.printt(header=False)
         x.printt(header=False, border=False)
-        print "Testing lack of borders:"
+        print("Testing lack of borders:")
         x.printt(border=False)
-        print "Testing sorting:"
+        print("Testing sorting:")
         x.printt(sortby="City name")
         x.printt(sortby="Annual Rainfall")
         x.printt(sortby="Annual Rainfall", reversesort=True)
-        print "Testing padding parameter:"
+        print("Testing padding parameter:")
         x.set_padding_width(0)
         x.printt()
         x.set_padding_width(5)
@@ -598,22 +598,22 @@
         x.set_left_padding(None)
         x.set_right_padding(None)
         x.set_padding_width(2)
-        print "Testing changing characters"
+        print("Testing changing characters")
         x.set_border_chars("*","*","*")
         x.printt()
         x.set_border_chars("!","~","o")
         x.printt()
         x.set_border_chars("|","-","+")
-        print "Testing everything at once:"
+        print("Testing everything at once:")
         x.printt(start=2, end=5, fields=["City name","Population"], border=False, hrules=True)
-        print "Rebuilding by columns:"
+        print("Rebuilding by columns:")
         x = PrettyTable()
         x.add_column("City name", ["Adelaide", "Brisbane", "Darwin", "Hobart", "Sydney", "Melbourne", "Perth"])
         x.add_column("Area", [1295, 5905, 112, 1357, 2058, 1566, 5385])
         x.add_column("Population", [1158259, 1857594, 120900, 205556, 4336374, 3806092, 1554769])
         x.add_column("Annual Rainfall", [600.5, 1146.4, 1714.7, 619.5, 1214.8, 646.9, 869.4])
         x.printt()
-        print "Testing HTML:"
+        print("Testing HTML:")
         x.print_html()
         x.print_html(border=False)
         x.print_html(border=True)
