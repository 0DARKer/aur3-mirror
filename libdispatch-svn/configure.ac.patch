diff -urN libdispatch-svn.orig/configure.ac libdispatch-svn/configure.ac
--- libdispatch-svn.orig/configure.ac	2010-01-06 16:09:12.000000000 +0100
+++ libdispatch-svn/configure.ac	2010-01-06 16:08:24.000000000 +0100
@@ -193,7 +193,7 @@
 AC_CHECK_DECLS([SIGEMT], [], [], [[#include <signal.h>]])
 AC_CHECK_DECLS([VQ_UPDATE, VQ_VERYLOWDISK], [], [], [[#include <sys/mount.h>]])
 AC_CHECK_DECLS([program_invocation_short_name], [], [], [[#include <errno.h>]])
-AC_CHECK_FUNCS([pthread_key_init_np pthread_main_np mach_absolute_time malloc_create_zone sysconf getprogname])
+AC_CHECK_FUNCS([pthread_key_init_np pthread_main_np mach_absolute_time malloc_create_zone sysconf getprogname arc4random fgetln])
 
 AC_CHECK_DECLS([POSIX_SPAWN_START_SUSPENDED],
   [have_posix_spawn_start_suspended=true],
diff -urN libdispatch-svn.orig/testing/queue_finalizer.c libdispatch-svn/testing/queue_finalizer.c
--- libdispatch-svn.orig/testing/queue_finalizer.c	2009-12-11 22:56:30.000000000 +0100
+++ libdispatch-svn/testing/queue_finalizer.c	2009-12-11 22:58:40.000000000 +0100
@@ -32,6 +32,35 @@
 
 void *ctxt_magic;
 
+/*
+ * Based on ISC BIND lib/isc/random.c
+ */
+#ifndef HAVE_ARC4RANDOM
+static uint32_t
+arc4random(void)
+{
+  unsigned int pid;
+  static int arc4random_init;
+
+  /*
+   * The low bits of pid generally change faster.
+   * Xor them with the high bits of time which change slowly.
+   */
+  if (!arc4random_init) {
+    pid = getpid();
+    pid = ((pid << 16) & 0xffff0000) | ((pid >> 16) & 0xffff);
+    srand(time(NULL) ^ pid);
+    arc4random_init = 1;
+  }
+
+  /*
+   * rand()'s lower bits are not random.
+   * rand()'s upper bit is zero.
+   */
+  return ((rand() >> 4) & 0xffff) | ((rand() << 12) & 0xffff0000);
+}
+#endif /* ! HAVE_ARC4RANDOM */
+
 static void
 finalizer(void *ctxt)
 {
diff -urN libdispatch-svn.orig/testing/summarize.c libdispatch-svn/testing/summarize.c
--- libdispatch-svn.orig/testing/summarize.c	2009-12-11 22:56:30.000000000 +0100
+++ libdispatch-svn/testing/summarize.c	2009-12-11 23:05:22.000000000 +0100
@@ -24,6 +24,96 @@
 #include <stdlib.h>
 #include <string.h>
 
+#ifndef HAVE_FGETLN
+/*
+ * fgetln() for linux.   Hacked up for sed, et al.
+ *
+ * BSD tweaks around with the inside of a FILE*; we can't do that
+ * in the land of GNU libc, so we keep a private array of FILE*
+ * keys and pointer/size pairs to hold the lines.
+ */
+#include <stdio.h>
+#include <sys/types.h>
+#include <malloc.h>
+#include <errno.h>
+
+#define MAXFILES	20
+
+typedef struct {
+    FILE *key;		/* file descriptor this bfr is associated with */
+    char *bfr;		/* buffer for latest fgetln()ed line */
+    int buflen;		/* length of the buffer */
+} LINEREC;
+
+static LINEREC tbl[MAXFILES] = { {0, 0, 0} };
+
+char*
+fgetln(FILE *fd, size_t *len)
+{
+    int idx;
+    int c, lnsize;
+    /*int newest;*/
+
+    /* we want to do fgetln, eh?  Check to see if all the variables
+     * are okay first (don't want to waste space if the file is bad
+     * or the len argument is bogus (==zero)
+     */
+    if (fd == 0 || len == 0) {
+	errno = EINVAL;
+	return 0;
+    }
+
+    /* find an available slot in the table
+     */
+    for (idx = 0; idx < MAXFILES; idx++)
+	if (tbl[idx].key == fd)
+	    break;
+
+    if (idx == MAXFILES) {
+	for (idx=0; idx < MAXFILES; idx++)
+	    if (tbl[idx].key == 0) {
+		/* usable file slot */
+		break;
+	    }
+
+	if (idx == MAXFILES) {
+	    errno = ENFILE;
+	    return 0;
+	}
+    }
+
+    /* Initialize the buffer, if needed
+     */
+    if (tbl[idx].bfr == 0) {
+	tbl[idx].bfr = malloc(200);
+	if (tbl[idx].bfr == 0)
+	    return 0;
+	tbl[idx].buflen = 200;
+    }
+    tbl[idx].key = fd;
+
+    /* we've got a buffer, so lets start writing a line into
+     * it.
+     */
+    for (lnsize = 0; (c = getc(fd)) != EOF; ) {
+	tbl[idx].bfr[lnsize++] = c;
+	if (lnsize == tbl[idx].buflen) {
+	    tbl[idx].bfr = realloc(tbl[idx].bfr, tbl[idx].buflen * 2);
+	    if (tbl[idx].bfr == 0)
+		return 0;
+	    tbl[idx].buflen *= 2;
+	}
+	if (c == '\n')
+	    break;
+    }
+
+    /* save out the size, then return to sender
+     */
+    *len = lnsize;
+    return lnsize ? tbl[idx].bfr : 0;
+} /* fgetln */
+#endif /* ! HAVE_FGETLN */
+
 int
 has_prefix(const char* str, const char* prefix) {
 	return (strncmp(str, prefix, strlen(prefix)) == 0);
