diff -Nru kde-workspace-4.8.0/kwin/client.cpp kde-workspace-4.8.0-appmenu/kwin/client.cpp
--- kde-workspace-4.8.0/kwin/client.cpp	2012-01-18 21:08:42.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/client.cpp	2012-02-20 15:56:26.510513978 +0100
@@ -1812,6 +1812,18 @@
 }
 
 /**
+ * Invokes application menu on window. Only works if the window
+ * actually provides a menu
+ */
+void Client::showApplicationMenu()
+{
+    if (decoration)
+    {
+        decoration->showApplicationMenu(false);
+    }
+}
+
+/**
  * Fetches the window's caption (WM_NAME property). It will be
  * stored in the client's caption().
  */
diff -Nru kde-workspace-4.8.0/kwin/client.h kde-workspace-4.8.0-appmenu/kwin/client.h
--- kde-workspace-4.8.0/kwin/client.h	2012-01-18 21:08:42.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/client.h	2012-02-20 15:56:26.513847312 +0100
@@ -344,6 +344,7 @@
     void maximize(MaximizeMode);
     void toggleShade();
     void showContextHelp();
+    void showApplicationMenu();
     void cancelShadeHoverTimer();
     void cancelAutoRaise();
     void checkActiveModal();
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/config/oxygenconfig.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/oxygenconfig.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/config/oxygenconfig.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/oxygenconfig.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -120,6 +120,7 @@
         else if( ui->ui.separatorMode->currentIndex() != configuration.separatorMode() ) modified = true;
         else if( ui->ui.titleOutline->isChecked() !=  configuration.drawTitleOutline() ) modified = true;
         else if( ui->ui.narrowButtonSpacing->isChecked() !=  configuration.useNarrowButtonSpacing() ) modified = true;
+        else if( ui->ui.applicationMenuButtonType->currentIndex() != configuration.applicationMenuButtonType() ) modified = true;
 
         // shadow configurations
         else if( ui->shadowConfigurations[0]->isChecked() !=  configuration.useOxygenShadows() ) modified = true;
@@ -157,6 +158,7 @@
         configuration.setUseDropShadows( ui->shadowConfigurations[1]->isChecked() );
         configuration.setUseOxygenShadows( ui->shadowConfigurations[0]->isChecked() );
         configuration.setUseNarrowButtonSpacing( ui->ui.narrowButtonSpacing->isChecked() );
+        configuration.setApplicationMenuButtonType( ui->ui.applicationMenuButtonType->currentIndex() );
 
         if( ui->expertMode() )
         {
@@ -246,7 +248,8 @@
         ui->shadowConfigurations[1]->setChecked( configuration.useDropShadows() );
         ui->ui.animationsEnabled->setChecked( configuration.animationsEnabled() );
         ui->ui.narrowButtonSpacing->setChecked( configuration.useNarrowButtonSpacing() );
-
+        ui->ui.applicationMenuButtonType->setCurrentIndex( configuration.applicationMenuButtonType() );
+        
         ui->animationConfigWidget()->setConfiguration( configuration );
         ui->animationConfigWidget()->load();
 
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/config/oxygenconfigurationui.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/oxygenconfigurationui.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/config/oxygenconfigurationui.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/oxygenconfigurationui.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -107,6 +107,7 @@
         connect( ui.sizeGripMode, SIGNAL(currentIndexChanged(int)), SIGNAL(changed()) );
 
         connect( ui.narrowButtonSpacing, SIGNAL(clicked()), SIGNAL(changed()) );
+        connect( ui.applicationMenuButtonType, SIGNAL(currentIndexChanged(int)), SIGNAL(changed()) );
         connect( ui.separatorMode, SIGNAL(currentIndexChanged(int)), SIGNAL(changed()) );
         connect( ui.titleOutline, SIGNAL(clicked()), SIGNAL(changed()) );
         connect( ui.exceptions, SIGNAL(changed()), SIGNAL(changed()) );
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/config/ui/oxygenconfigurationui.ui kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/ui/oxygenconfigurationui.ui
--- kde-workspace-4.8.0/kwin/clients/oxygen/config/ui/oxygenconfigurationui.ui	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/config/ui/oxygenconfigurationui.ui	2012-02-20 15:56:26.513847312 +0100
@@ -228,6 +228,33 @@
          </property>
         </widget>
        </item>
+       <item row="3" column="0">
+        <widget class="QLabel" name="label_6">
+         <property name="text">
+          <string>Menu button style:</string>
+         </property>
+         <property name="alignment">
+          <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+         </property>
+        </widget>
+       </item>
+       <item row="3" column="1">
+        <widget class="QComboBox" name="applicationMenuButtonType">
+         <property name="currentIndex">
+          <number>0</number>
+         </property>
+         <item>
+          <property name="text">
+           <string>Menu</string>
+          </property>
+         </item>
+         <item>
+          <property name="text">
+           <string>Application name</string>
+          </property>
+         </item>
+        </widget>
+       </item>
       </layout>
      </widget>
      <widget class="QWidget" name="tab_3">
@@ -339,3 +366,4 @@
  <resources/>
  <connections/>
 </ui>
+
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenbutton.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenbutton.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenbutton.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenbutton.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -28,6 +28,7 @@
 #include "oxygenbutton.h"
 #include "oxygenbutton.moc"
 #include "oxygenclient.h"
+#include "oxygenhelper.h"
 
 #include <cmath>
 
@@ -36,6 +37,7 @@
 
 #include <KColorUtils>
 #include <KColorScheme>
+#include <klocale.h>
 #include <kcommondecoration.h>
 
 namespace Oxygen
@@ -112,7 +114,6 @@
     //___________________________________________________
     void Button::paint( QPainter& painter )
     {
-
         QPalette palette( this->palette() );
         palette.setCurrentColorGroup( isActive() ? QPalette::Active : QPalette::Inactive);
 
@@ -122,8 +123,12 @@
         { painter.translate( 0, -1 ); }
 
         // translate buttons down if window maximized
-        if( _client.isMaximized() ) painter.translate( 0, 1 );
-
+        if( _client.isMaximized() )
+        {
+            if( _type == ButtonApplicationMenu ) painter.translate( 0, -1 );
+            else painter.translate( 0, 1 );
+        }
+        
         // base button color
         QColor base;
         if( _type == ButtonItemClose && _forceInactive ) base = _client.backgroundPalette( this, palette ).window().color();
@@ -155,25 +160,76 @@
 
         if( hasDecoration() )
         {
-            // scale
-            qreal scale( (21.0*_client.configuration().buttonSize())/22.0 );
+            if( _type == ButtonApplicationMenu && _client.hasApplicationMenu() ) {
 
-            // pressed state
-            const bool pressed(
-                (_status&Pressed) ||
-                ( _type == ButtonSticky && _client.isOnAllDesktops()  ) ||
-                ( _type == ButtonAbove && _client.keepAbove() ) ||
-                ( _type == ButtonBelow && _client.keepBelow() ) );
+                TileSet *tile;
+                QString menuTitle;
+                const unsigned int iconHeight = _client.configuration().iconScale();
+                const unsigned int iconWidth = _client.hasWindowMenu() ? 0 : iconHeight;
+                const QPen pen(buttonDetailColor( _client.backgroundPalette( this, palette ) ) );
+                const QPalette palette;
+                const QColor buttonColor(palette.color(QPalette::Button));
+                const QFont font = _client.options()->font(isActive());
+                const QFontMetrics metrics(font);
 
-            // draw button shape
-            painter.drawPixmap(0, 0, _helper.windecoButton( base, glow, pressed, scale ) );
+                painter.setFont(font);
+                painter.setPen(pen);
 
+                switch( _client.configuration().applicationMenuButtonType() )
+                {
+                    default:
+                    case 0:
+                    menuTitle = i18n("Menu");
+                    break;
+
+                    case 1:
+                    menuTitle = _client.className();
+                    break;
+                }
+
+                const QRect tileRect(0, -TILESIZE+1, iconWidth+metrics.width(menuTitle)+TILESIZE*2, iconHeight+TILESIZE+6);
+                // Dont fill TileSet::Top
+                const QRect fillRect(0, 1, iconWidth+metrics.width(menuTitle)+TILESIZE*2, iconHeight+TILESIZE+6);
+
+                if( _status&Oxygen::Pressed )
+                    tile = _helper.slabSunken(buttonColor, TILESIZE);
+                else if( _status&Oxygen::Hovered )
+                    tile = _helper.slab(buttonColor, glow, 1, TILESIZE);
+                else
+                    tile = _helper.slab(buttonColor, 1, TILESIZE);
+
+                painter.setClipRect(fillRect);
+                _helper.fillButtonSlab( painter, tileRect, buttonColor, _status&Oxygen::Pressed);
+                painter.setClipping( false );
+                tile->render(tileRect, &painter, (TileSet::Tiles)(TileSet::Left|TileSet::Bottom|TileSet::Right));
+                
+                if( iconWidth ) {
+                    const QPixmap& pixmap( _client.icon().pixmap( iconWidth ) );
+                    painter.drawPixmap(TILESIZE, 2, pixmap);
+                }
+                
+                painter.drawText(QRect(TILESIZE+iconWidth+2, 2, metrics.width(menuTitle), iconHeight), Qt::AlignCenter, menuTitle);
+                
+            } else if ( _type != ButtonApplicationMenu ) {
+
+                // scale
+                qreal scale( (21.0*_client.configuration().buttonSize())/22.0 );
+
+                // pressed state
+                const bool pressed(
+                    (_status&Pressed) ||
+                    ( _type == ButtonSticky && _client.isOnAllDesktops()  ) ||
+                    ( _type == ButtonAbove && _client.keepAbove() ) ||
+                    ( _type == ButtonBelow && _client.keepBelow() ) );
+
+                // draw button shape
+                painter.drawPixmap(0, 0, _helper.windecoButton( base, glow, pressed, scale ) );
+            }
         }
 
         // Icon
         // for menu button the application icon is used
-        if( isMenuButton() )
-        {
+        if( isMenuButton() ) {
 
             const QPixmap& pixmap( _client.icon().pixmap( _client.configuration().iconScale() ) );
             const double offset = 0.5*(width()-pixmap.width() );
@@ -409,5 +465,4 @@
         painter->restore();
         return;
     }
-
 }
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenbutton.h kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenbutton.h
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenbutton.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenbutton.h	2012-02-20 15:56:26.513847312 +0100
@@ -43,6 +43,12 @@
         Pressed = 1<<1
     };
 
+    enum {
+
+        //! this is menu button tile size
+        TILESIZE = 9,
+    };
+    
     Q_DECLARE_FLAGS(ButtonState, ButtonStatus)
 
         class Button : public KCommonDecorationButton
@@ -172,7 +178,7 @@
         { return !isMenuButton() && _type != ButtonItemClose; }
 
         //@}
-
+        
         private:
 
         //! parent client
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenclient.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenclient.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenclient.cpp	2012-01-18 21:08:42.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenclient.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -37,6 +37,8 @@
 #include <KLocale>
 #include <KColorUtils>
 #include <KDebug>
+#include <KWindowInfo>
+#include <KWindowSystem>
 
 #include <QtGui/QApplication>
 #include <QtGui/QLabel>
@@ -65,7 +67,10 @@
         _itemData( this ),
         _sourceItem( -1 ),
         _shadowAtom( 0 )
-    {}
+    {
+        KWindowInfo info( windowId(), 0, NET::WM2WindowClass );
+        _className = QString( info.windowClassClass() );
+    }
 
     //___________________________________________
     Client::~Client()
@@ -205,7 +210,10 @@
         switch (type) {
 
             case MenuButton:
-            return new Button(*this, i18n("Menu"), ButtonMenu);
+            return new Button(*this, i18n("Window Menu"), ButtonMenu);
+
+            case ApplicationMenuButton:
+            return new Button(*this, i18n("Application Menu"), ButtonApplicationMenu);
 
             case HelpButton:
             return new Button(*this, i18n("Help"), ButtonHelp);
@@ -375,6 +383,27 @@
             }
 
             case LM_ButtonWidth:
+            {
+                if ( btn && btn->type() == ApplicationMenuButton ) {
+
+                    const unsigned int iconScale = hasWindowMenu() ? 0 : configuration().iconScale();
+                    const QFont font = options()->font(isActive());
+                    const QFontMetrics metrics(font);
+
+                    switch( configuration().applicationMenuButtonType() )
+                    {
+                            default:
+                            case 0:
+                            return iconScale+metrics.width(i18n("Menu"))+TILESIZE*2;
+
+                            case 1:
+                            return iconScale+metrics.width(_className)+TILESIZE*2;
+                    }
+                } else {
+                    return buttonSize;
+                }
+            }
+
             case LM_ButtonHeight:
             case LM_TitleHeight:
             {
@@ -1327,6 +1356,30 @@
     { return "HIAX"; }
 
     //________________________________________________________________
+    QString Client::caption( void ) const
+    {
+        switch( configuration().applicationMenuButtonType() )
+        {
+            default:
+            case 0:
+                return KCommonDecoration::caption();
+
+            case 1:
+                if( hasApplicationMenu() )
+                {
+                    QString toFilter = KCommonDecoration::caption();
+                    QRegExp rx("[:\\x2013-]*[\\w \']*" + _className +"[\\w \']*[\\x2013:-]*");
+
+                    rx.setCaseSensitivity(Qt::CaseInsensitive);
+
+                    return toFilter.remove( rx );
+                }
+                else
+                    return KCommonDecoration::caption();
+        }
+    }
+    
+    //________________________________________________________________
     void Client::updateWindowShape()
     {
 
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenclient.h kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenclient.h
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenclient.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenclient.h	2012-02-20 15:56:26.513847312 +0100
@@ -119,6 +119,9 @@
                 clientGroupItems().count() == 1;
         }
 
+        //! filter caption
+        QString caption( void ) const;
+        
         //@}
 
         //! window shape
@@ -226,6 +229,10 @@
 
         //! paint background to painter
         void paintBackground( QPainter& ) const;
+        
+        //! client window class name
+        QString className( void ) const
+        { return _className; }
 
         public slots:
 
@@ -471,6 +478,9 @@
         */
         QBasicTimer _dragStartTimer;
 
+        //! Client window class name
+        QString _className; 
+        
         //! shadow atom
         Atom _shadowAtom;
 
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenconfiguration.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenconfiguration.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenconfiguration.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenconfiguration.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -48,6 +48,7 @@
         _useDropShadows( true ),
         _useOxygenShadows( true ),
         _useNarrowButtonSpacing( false ),
+        _applicationMenuButtonType( 0 ),
         _animationsEnabled( true ),
         _buttonAnimationsEnabled( true ),
         _titleAnimationsEnabled( true ),
@@ -132,6 +133,11 @@
             OxygenConfig::NARROW_BUTTON_SPACING,
             defaultConfiguration.useNarrowButtonSpacing() ) );
 
+        // application menu button type
+        setApplicationMenuButtonType( group.readEntry(
+            OxygenConfig::APPLICATION_MENU_BUTTON_TYPE,
+            defaultConfiguration.applicationMenuButtonType() ) );
+
         // animations
         setAnimationsEnabled( group.readEntry(
             OxygenConfig::ANIMATIONS_ENABLED,
@@ -208,6 +214,7 @@
         if( useDropShadows() != defaultConfiguration.useDropShadows() ) group.writeEntry( OxygenConfig::USE_DROP_SHADOWS, useDropShadows() );
         if( useOxygenShadows() != defaultConfiguration.useOxygenShadows() ) group.writeEntry( OxygenConfig::USE_OXYGEN_SHADOWS, useOxygenShadows() );
         if( useNarrowButtonSpacing() != defaultConfiguration.useNarrowButtonSpacing() ) group.writeEntry( OxygenConfig::NARROW_BUTTON_SPACING, useNarrowButtonSpacing() );
+        if( applicationMenuButtonType() != defaultConfiguration.applicationMenuButtonType() ) group.writeEntry(OxygenConfig::APPLICATION_MENU_BUTTON_TYPE, applicationMenuButtonType() );
 
         // animations
         if( animationsEnabled() != defaultConfiguration.animationsEnabled() ) group.writeEntry( OxygenConfig::ANIMATIONS_ENABLED, animationsEnabled() );
@@ -401,6 +408,7 @@
             useDropShadows() == other.useDropShadows() &&
             useOxygenShadows() == other.useOxygenShadows() &&
             useNarrowButtonSpacing() == other.useNarrowButtonSpacing() &&
+            applicationMenuButtonType() == other.applicationMenuButtonType() &&
             animationsEnabled() == other.animationsEnabled() &&
             buttonAnimationsEnabled() == other.buttonAnimationsEnabled() &&
             titleAnimationsEnabled() == other.titleAnimationsEnabled() &&
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenconfiguration.h kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenconfiguration.h
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenconfiguration.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenconfiguration.h	2012-02-20 15:56:26.513847312 +0100
@@ -44,6 +44,7 @@
     static const QString HIDE_TITLEBAR = "HideTitleBar";
     static const QString ANIMATIONS_ENABLED = "AnimationsEnabled";
     static const QString NARROW_BUTTON_SPACING = "UseNarrowButtonSpacing";
+    static const QString APPLICATION_MENU_BUTTON_TYPE = "applicationMenuButtonType";
 
     //!@name animation flags
     //@{
@@ -193,6 +194,12 @@
 
         virtual void  setUseNarrowButtonSpacing( bool value )
         { _useNarrowButtonSpacing = value; }
+        
+        virtual int applicationMenuButtonType( void ) const
+        { return _applicationMenuButtonType; }
+        
+        virtual void setApplicationMenuButtonType( int value )
+        { _applicationMenuButtonType = value; }
 
         //@}
 
@@ -414,7 +421,10 @@
 
         //! narrow button spacing
         bool _useNarrowButtonSpacing;
-
+        
+        //! application menu button type
+        int _applicationMenuButtonType;
+        
         //!@name animation flags
         //@{
         bool _animationsEnabled;
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenfactory.cpp kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenfactory.cpp
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenfactory.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenfactory.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -148,6 +148,7 @@
 
             // buttons
             case AbilityButtonMenu:
+            case AbilityButtonApplicationMenu:
             case AbilityButtonHelp:
             case AbilityButtonMinimize:
             case AbilityButtonMaximize:
diff -Nru kde-workspace-4.8.0/kwin/clients/oxygen/oxygenfactory.h kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenfactory.h
--- kde-workspace-4.8.0/kwin/clients/oxygen/oxygenfactory.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/clients/oxygen/oxygenfactory.h	2012-02-20 15:56:26.513847312 +0100
@@ -47,7 +47,8 @@
         ButtonMax,
         ButtonMin,
         ButtonClose,
-        ButtonMenu,
+        ButtonMenu,        
+        ButtonApplicationMenu,
         ButtonSticky,
         ButtonAbove,
         ButtonBelow,
@@ -58,7 +59,7 @@
         ButtonItemClose=100,
 
         // shows the window menu for one tab
-        ButtonItemMenu
+        ButtonItemMenu,
 
     };
 
diff -Nru kde-workspace-4.8.0/kwin/kcmkwin/kwindecoration/buttons.cpp kde-workspace-4.8.0-appmenu/kwin/kcmkwin/kwindecoration/buttons.cpp
--- kde-workspace-4.8.0/kwin/kcmkwin/kwindecoration/buttons.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/kcmkwin/kwindecoration/buttons.cpp	2012-02-20 15:56:26.513847312 +0100
@@ -680,7 +680,7 @@
 
     // insert all possible buttons into the source (backwards to keep the preferred order...)
     bool dummy;
-    m_supportedButtons = "MSHIAX_FBLR"; // support all buttons
+    m_supportedButtons = "MNSHIAX_FBLR"; // support all buttons
     new ButtonSourceItem(m_buttonSource, getButton('R', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('L', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('B', dummy));
@@ -691,6 +691,7 @@
     new ButtonSourceItem(m_buttonSource, getButton('H', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('S', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('M', dummy));
+    new ButtonSourceItem(m_buttonSource, getButton('N', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('_', dummy));
 }
 
@@ -741,7 +742,11 @@
     } else if (type == 'M') {
         QBitmap bmp = QBitmap::fromData(QSize(menu_width, menu_height), menu_bits);
         bmp.createMaskFromColor(Qt::white);
-        return Button(i18n("Menu"), bmp, 'M', false, m_supportedButtons.contains('M'));
+        return Button(i18n("Window Menu"), bmp, 'M', false, m_supportedButtons.contains('M'));
+    } else if (type == 'N') {
+        QBitmap bmp = QBitmap::fromData(QSize(menu_width, menu_height), menu_bits);
+        bmp.createMaskFromColor(Qt::white);
+        return Button(i18n("Application Menu"), bmp, 'N', false, m_supportedButtons.contains('N'));
     } else if (type == '_') {
         QBitmap bmp = QBitmap::fromData(QSize(spacer_width, spacer_height), spacer_bits);
         bmp.createMaskFromColor(Qt::white);
diff -Nru kde-workspace-4.8.0/kwin/kwinbindings.cpp kde-workspace-4.8.0-appmenu/kwin/kwinbindings.cpp
--- kde-workspace-4.8.0/kwin/kwinbindings.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/kwinbindings.cpp	2012-02-20 15:56:26.537180644 +0100
@@ -141,6 +141,8 @@
     0, slotIncreaseWindowOpacity());
 DEF2("Decrease Opacity", I18N_NOOP("Decrease Opacity of Active Window by 5 %"),
     0, slotLowerWindowOpacity());
+DEF2("Show application menu", I18N_NOOP("Show application menu at mouse position"),
+    0, slotShowApplicationMenu());
 
 a = actionCollection->addAction("Group:Window Desktop");
 a->setText(i18n("Window & Desktop"));
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/CMakeLists.txt kde-workspace-4.8.0-appmenu/kwin/libkdecorations/CMakeLists.txt
--- kde-workspace-4.8.0/kwin/libkdecorations/CMakeLists.txt	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/CMakeLists.txt	2012-02-20 15:56:26.537180644 +0100
@@ -4,12 +4,16 @@
    kdecoration_p.cpp
    kdecoration_plugins_p.cpp
    kdecorationfactory.cpp
+   kdecorationmenubar.cpp
    kcommondecoration.cpp
-   kcommondecoration_p.cpp )
+   kcommondecoration_p.cpp 
+)
+
+include_directories(${DBUSMENUQT_INCLUDE_DIR})
 
 kde4_add_library(kdecorations SHARED ${kdecorations_LIB_SRCS})
 
-target_link_libraries(kdecorations ${KDE4_KDEUI_LIBS} kephal)
+target_link_libraries(kdecorations ${KDE4_KDEUI_LIBS} ${DBUSMENUQT_LIBRARIES} ${KDE4_PLASMA_LIBS} kephal appmenu-kde)
 target_link_libraries(kdecorations LINK_INTERFACE_LIBRARIES ${KDE4_KDEUI_LIBS})
 
 set_target_properties(kdecorations PROPERTIES
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kcommondecoration.cpp kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kcommondecoration.cpp
--- kde-workspace-4.8.0/kwin/libkdecorations/kcommondecoration.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kcommondecoration.cpp	2012-02-20 15:56:26.537180644 +0100
@@ -224,7 +224,10 @@
             bool elementLayouted = false;
             if (*it) {
                 if (!(*it)->isHidden()) {
-                    moveWidget(x, y, *it);
+                    if ((*it)->type() == ApplicationMenuButton) //button on top border frame
+                        moveWidget(x, r_y, *it);
+                    else
+                        moveWidget(x, y, *it);
                     x += layoutMetric(LM_ButtonWidth, true, qobject_cast<KCommonDecorationButton*>(*it));
                     elementLayouted = true;
                 }
@@ -246,7 +249,10 @@
             bool elementLayouted = false;
             if (*it) {
                 if (!(*it)->isHidden()) {
-                    moveWidget(x, y, *it);
+                    if ((*it)->type() == ApplicationMenuButton) //button on top border frame
+                        moveWidget(x, r_y, *it);
+                    else
+                        moveWidget(x, y, *it);
                     x += layoutMetric(LM_ButtonWidth, true, qobject_cast<KCommonDecorationButton*>(*it));;
                     elementLayouted = true;
                 }
@@ -263,7 +269,18 @@
 void KCommonDecoration::updateButtons() const
 {
     for (int n = 0; n < NumButtons; n++)
-        if (m_button[n]) m_button[n]->update();
+    {
+        if (m_button[n])
+        {
+            // Application menu button may be hidden (menu not ready when decoration was created
+            if ( m_button[n]->type() == ApplicationMenuButton && m_button[n]->isHidden() && hasApplicationMenu() )
+            {
+                m_button[n]->show();
+                updateLayout();
+            }
+            m_button[n]->update();
+        }
+    }
 }
 
 void KCommonDecoration::resetButtons() const
@@ -296,12 +313,16 @@
         connect(m_previewWidget, SIGNAL(destroyed(QObject*)), this, SLOT(objDestroyed(QObject*)));
     }
 
-    addButtons(m_buttonsLeft,
-               options()->customButtonPositions() ? options()->titleButtonsLeft() : defaultButtonsLeft(),
-               true);
-    addButtons(m_buttonsRight,
-               options()->customButtonPositions() ? options()->titleButtonsRight() : defaultButtonsRight(),
-               false);
+    QString leftSettings = options()->customButtonPositions() ? options()->titleButtonsLeft() : defaultButtonsLeft();
+    QString rightSettings = options()->customButtonPositions() ? options()->titleButtonsRight() : defaultButtonsRight();
+
+    if (!isPreview()) {
+        bool containsN = leftSettings.contains("N") || rightSettings.contains("N");
+        wrapper->manageApplicationMenu(containsN);
+    }
+
+    addButtons(m_buttonsLeft, leftSettings, true);
+    addButtons(m_buttonsRight, rightSettings, false);
 
     updateLayout();
 
@@ -378,7 +399,7 @@
                 if (!m_button[MenuButton]) {
                     btn = createButton(MenuButton);
                     if (!btn) break;
-                    btn->setTipText(i18n("Menu"));
+                    btn->setTipText(i18n("Window Menu"));
                     btn->setRealizeButtons(Qt::LeftButton | Qt::RightButton);
                     connect(btn, SIGNAL(pressed()), SLOT(menuButtonPressed()));
                     connect(btn, SIGNAL(released()), this, SLOT(menuButtonReleased()));
@@ -389,6 +410,19 @@
                     m_button[MenuButton] = btn;
                 }
                 break;
+             case 'N': // Application Menu button
+                if (!m_button[ApplicationMenuButton]) {
+                    btn = createButton(ApplicationMenuButton);
+                    if (!btn) break;
+                    btn->setTipText(i18n("Application Menu"));
+                    btn->setRealizeButtons(Qt::LeftButton);
+                    connect(btn, SIGNAL(pressed()), SLOT(applicationMenuButtonPressed()));
+
+                    // fix double deletion, see objDestroyed()
+                    connect(btn, SIGNAL(destroyed(QObject*)), this, SLOT(objDestroyed(QObject*)));
+                    m_button[ApplicationMenuButton] = btn;
+                }
+                break;
             case 'S': // OnAllDesktops button
                 if (!m_button[OnAllDesktopsButton]) {
                     btn = createButton(OnAllDesktopsButton);
@@ -517,7 +551,9 @@
             if (btn) {
                 btn->setLeft(isLeft);
                 btn->setSize(QSize(layoutMetric(LM_ButtonWidth, true, btn), layoutMetric(LM_ButtonHeight, true, btn)));
-                btn->show();
+                // Only show button if menu available, will be shown later if menu available on window registration
+                if ( !(btn->type() == ApplicationMenuButton && !hasApplicationMenu()) )
+                    btn->show();
                 btnContainer.append(btn);
             }
 
@@ -721,6 +757,16 @@
         closeWindow();
 }
 
+void KCommonDecoration::applicationMenuButtonPressed()
+{
+    showApplicationMenu();
+
+    KDecorationFactory* f = factory();
+    if (!f->exists(decoration()))   // 'this' was deleted
+        return;
+    m_button[ApplicationMenuButton]->setDown(false);
+}
+
 void KCommonDecoration::resizeEvent(QResizeEvent */*e*/)
 {
     if (decorationBehaviour(DB_ButtonHide))
@@ -1007,7 +1053,7 @@
     m_lastMouse = e->button();
     // pass on event after changing button to LeftButton
     QMouseEvent me(e->type(), e->pos(), (e->button()&m_realizeButtons) ? Qt::LeftButton : Qt::NoButton, e->buttons(), e->modifiers());
-
+    
     QAbstractButton::mousePressEvent(&me);
 }
 
@@ -1115,6 +1161,22 @@
 {
     return wrapper->showWindowMenu(pos);
 }
+void KCommonDecoration::manageApplicationMenu(bool manage)
+{
+    return wrapper->manageApplicationMenu(manage);
+}
+void KCommonDecoration::showApplicationMenu()
+{
+    return wrapper->showApplicationMenu();
+}
+bool KCommonDecoration::hasApplicationMenu() const
+{
+    return wrapper->hasApplicationMenu();
+}
+bool KCommonDecoration::hasWindowMenu() const
+{
+    return m_button[MenuButton];
+}
 void KCommonDecoration::showWindowMenu(QPoint pos)
 {
     return wrapper->showWindowMenu(pos);
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kcommondecoration.h kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kcommondecoration.h
--- kde-workspace-4.8.0/kwin/libkdecorations/kcommondecoration.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kcommondecoration.h	2012-02-20 15:56:26.537180644 +0100
@@ -40,6 +40,7 @@
     MinButton,
     CloseButton,
     MenuButton,
+    ApplicationMenuButton,
     OnAllDesktopsButton,
     AboveButton,
     BelowButton,
@@ -274,6 +275,7 @@
     void slotKeepBelow();
     void menuButtonPressed();
     void menuButtonReleased();
+    void applicationMenuButtonPressed();
 public:
     virtual Position mousePosition(const QPoint &point) const;
 
@@ -310,6 +312,10 @@
     void showWindowMenu(const QRect &pos);
     void showWindowMenu(QPoint pos);
     void performWindowOperation(WindowOperation op);
+    void manageApplicationMenu(bool manage);
+    void showApplicationMenu();
+    bool hasApplicationMenu() const;
+    bool hasWindowMenu() const;
     void setMask(const QRegion& reg, int mode = 0);
     void clearMask(); // convenience
     bool isPreview() const;
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kdecoration.cpp kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecoration.cpp
--- kde-workspace-4.8.0/kwin/libkdecorations/kdecoration.cpp	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecoration.cpp	2012-02-20 15:56:26.537180644 +0100
@@ -24,10 +24,12 @@
 
 #include "kdecoration.h"
 #include "kdecoration_p.h"
+#include "kdecorationmenubar.h"
 
 #include <kdebug.h>
 #include <QApplication>
 #include <kglobal.h>
+#include <appmenu-kde/registrarclient.h>
 #include <assert.h>
 #if defined Q_WS_X11 && ! defined K_WS_QTONLY
 #include <X11/Xlib.h>
@@ -56,6 +58,8 @@
 
 
 KDecorationOptions* KDecoration::options_;
+RegistrarClient* KDecoration::registrarClient_ = 0;
+KDecorationMenuBar* KDecoration::menuBar_ = 0;
 
 KDecoration::KDecoration(KDecorationBridge* bridge, KDecorationFactory* factory)
     :   bridge_(bridge),
@@ -63,11 +67,20 @@
         factory_(factory)
 {
     factory->addDecoration(this);
+    if (registrarClient_)
+        connect(registrarClient_, SIGNAL(windowRegistered(WId)), SLOT(slotWindowRegistered(WId)));
 }
 
 KDecoration::~KDecoration()
 {
     factory()->removeDecoration(this);
+    if (menuBar_)
+    {
+        menuBar_->hide();
+        delete menuBar_;
+        menuBar_ = 0;
+    }
+
     delete w_;
 }
 
@@ -206,6 +219,73 @@
     bridge_->showWindowMenu(pos);
 }
 
+bool KDecoration::hasApplicationMenu() const
+{
+    return registrarClient_ && registrarClient_->menuForWinId(windowId());
+}
+
+void KDecoration::manageApplicationMenu(bool manage)
+{
+    if (!manage && registrarClient_) 
+    {
+        delete registrarClient_;
+        registrarClient_ = 0;
+    }
+    else if (manage && !registrarClient_) {
+        registrarClient_ = new RegistrarClient();
+        connect(registrarClient_, SIGNAL(windowRegistered(WId)),
+                SLOT(slotWindowRegistered(WId)));
+        connect(registrarClient_, SIGNAL(actionActivationRequested(WId, QAction *)),
+                SLOT(slotActionActivationRequested(WId, QAction *)));
+
+    }
+}
+
+void KDecoration::slotWindowRegistered(WId id)
+{
+    // Fix application with no menu available when decoration being created
+    activeChange();
+}
+
+void KDecoration::slotActionActivationRequested(WId id, QAction* action)
+{
+    if (menuBar_ && menuBar_->isVisible())
+        menuBar_->activateAction(action);
+}
+
+void KDecoration::showApplicationMenu(bool lookForCursor)
+{
+    QMenu* menu = registrarClient_->menuForWinId(windowId());
+    menu = registrarClient_->menuForWinId(windowId());
+
+    if (menu) 
+    {
+        if (menuBar_)
+        {
+            menuBar_->hide();
+            delete menuBar_;
+            menuBar_ = 0;
+        }
+
+        bool rightButton = false;
+        int x;
+        if (lookForCursor)
+        {
+            x = QCursor::pos().x();
+            rightButton = x > geometry().topLeft().x() + geometry().width()/2;
+        }
+        else {
+
+            x = -1;
+        }
+
+        menuBar_ = new KDecorationMenuBar(menu, rightButton);
+
+        menuBar_->setPosition(x, geometry().topLeft().y(), geometry().topLeft().x(), geometry().topRight().x());
+        menuBar_->show();
+    }
+}
+
 void KDecoration::showWindowMenu(QPoint pos)
 {
     bridge_->showWindowMenu(pos);
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kdecoration.h kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecoration.h
--- kde-workspace-4.8.0/kwin/libkdecorations/kdecoration.h	2012-01-18 21:08:41.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecoration.h	2012-02-20 15:56:26.537180644 +0100
@@ -35,6 +35,8 @@
 #define KWIN_EXPORT KDE_EXPORT
 
 class KConfig;
+class RegistrarClient;
+class QMenu;
 
 /** @defgroup kdecoration KWin decorations library */
 
@@ -45,6 +47,7 @@
 class KDecorationBridge;
 class KDecorationPrivate;
 class KDecorationFactory;
+class KDecorationMenuBar;
 
 /**
  * This class provides a namespace for all decoration related classes.
@@ -164,7 +167,7 @@
         AbilityAnnounceButtons = 0, ///< decoration supports AbilityButton* values (always use)
         AbilityAnnounceColors = 1, ///< decoration supports AbilityColor* values (always use)
         // buttons
-        AbilityButtonMenu = 1000,   ///< decoration supports the menu button
+        AbilityButtonMenu = 1000,   ///< decoration supports the window menu button
         AbilityButtonOnAllDesktops = 1001, ///< decoration supports the on all desktops button
         AbilityButtonSpacer = 1002, ///< decoration supports inserting spacers between buttons
         AbilityButtonHelp = 1003,   ///< decoration supports what's this help button
@@ -175,6 +178,7 @@
         AbilityButtonBelowOthers = 1008, ///< decoration supports a below button
         AbilityButtonShade = 1009, ///< decoration supports a shade button
         AbilityButtonResize = 1010, ///< decoration supports a resize button
+        AbilityButtonApplicationMenu = 1011,   ///< decoration supports the application menu button
         // colors
         AbilityColorTitleBack = 2000, ///< decoration supports titlebar background color
         ABILITYCOLOR_FIRST = AbilityColorTitleBack, ///< @internal
@@ -310,7 +314,8 @@
      * If customButtonPositions() returns true, titleButtonsLeft
      * returns which buttons should be on the left side of the titlebar from left
      * to right. Characters in the returned string have this meaning :
-     * @li 'M' menu button
+     * @li 'N' application menu button
+     * @li 'M' window menu button
      * @li 'S' on_all_desktops button
      * @li 'H' quickhelp button
      * @li 'I' minimize ( iconify ) button
@@ -579,6 +584,19 @@
      * Overloaded version of the above.
      */
     void showWindowMenu(QPoint pos);
+    /** 
+     * show application menu in window at cursor pos if lookForCursor
+     * otherwise center on titlebar
+     */
+    void showApplicationMenu(bool lookForCursor = true);
+    /**
+     * registar to dbusmenu if manage true
+     */
+    void manageApplicationMenu(bool manage);
+    /**
+     * true if an application menu is available
+     */
+    bool hasApplicationMenu() const;
     /**
      * This function performs the given window operation. This function may destroy
      * the current decoration object, just like showWindowMenu().
@@ -907,7 +925,12 @@
     friend class KDecorationUnstable; // for bridge_
     static KDecorationOptions* options_;
     KDecorationPrivate* d;
+    static RegistrarClient* registrarClient_;
+    static KDecorationMenuBar* menuBar_;
 
+private Q_SLOTS:
+    void slotWindowRegistered(WId id);
+    void slotActionActivationRequested(WId id, QAction* action);
 };
 
 /**
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kdecorationmenubar.cpp kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecorationmenubar.cpp
--- kde-workspace-4.8.0/kwin/libkdecorations/kdecorationmenubar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecorationmenubar.cpp	2012-02-20 15:56:26.537180644 +0100
@@ -0,0 +1,380 @@
+/*******************************************************************
+* menuwidget.cpp
+* Copyright  2012    Cédric Bellegarde <gnumdk@gmail.com>
+* Copyright  2009    Aurélien Gâteau <agateau@kde.org>
+* Inspirated by plasma-widget-menubar
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+******************************************************************/
+
+#include "kdecorationmenubar.h"
+
+// Qt
+#include <QGraphicsLinearLayout>
+#include <QPainter>
+#include <QMenu>
+#include <QToolButton>
+#include <QDesktopWidget>
+
+// KDE
+#include <KWindowSystem>
+#include <Plasma/FrameSvg>
+#include <Plasma/Label>
+#include <Plasma/Meter>
+#include <Plasma/Theme>
+#include <Plasma/WindowEffects>
+#include <KApplication>
+
+KDecorationMenuBarWidget::KDecorationMenuBarWidget(KDecorationMenuBar *parent, QMenu *menu, bool isRightButton) :
+    QGraphicsWidget(),
+    mouseTimer_(new QTimer(this)),
+    layout_(new QGraphicsLinearLayout(this)),
+    parent_(parent),
+    currentButton_(0),
+    menu_(menu),
+    isRightButton_(isRightButton)
+{
+    mouseTimer_->setInterval(100);
+    connect(mouseTimer_, SIGNAL(timeout()), SLOT(checkActiveItem()));
+    layout_->setContentsMargins(0, 0, 0, 0);
+}
+
+KDecorationMenuBarWidget::~KDecorationMenuBarWidget()
+{
+    delete mouseTimer_;
+    while (!buttons_.isEmpty())
+    {
+        delete buttons_.front();
+        buttons_.pop_front();
+    }
+}
+
+void KDecorationMenuBarWidget::updateLayout()
+{
+    if( menu_ == 0 ) return;
+
+
+    foreach( QAction* action, menu_->actions() )
+    {
+        action->setShortcut(QKeySequence());
+        KDecorationMenuButton* button;
+        QMenu *menu = action->menu();
+        if( action->isSeparator() || !menu )
+            continue;
+
+        button = new KDecorationMenuButton( this );
+        button->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
+
+        button->setText( action->text() );
+        button->setMenu( menu );
+        connect(button, SIGNAL(clicked()), SLOT(buttonClicked()));
+        layout_->addItem(button);
+        buttons_ << button;
+    }
+}
+
+bool KDecorationMenuBarWidget::eventFilter(QObject* object, QEvent* event)
+{
+    QMenu *menu = static_cast<QMenu*>(object);
+
+    if (event->type() == QEvent::KeyPress) 
+    {
+        menu->removeEventFilter(this);
+        QApplication::sendEvent(menu, event);
+        menu->installEventFilter(this);
+        if (!event->isAccepted())
+        {
+            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
+            switch (keyEvent->key()) 
+            {
+            case Qt::Key_Left:
+                showLeftRightMenu(false);
+                break;
+            case Qt::Key_Right:
+                showLeftRightMenu(true);
+                break;
+            case Qt::Key_Escape:
+                menu->hide();
+                break;
+            default:
+                break;
+            }
+        }
+        return true;
+    }
+    return false;
+}
+
+void KDecorationMenuBarWidget::checkActiveItem()
+{
+    QPoint pos =  parent_->mapFromGlobal(QCursor::pos());
+    QGraphicsItem* item = parent_->itemAt(pos);
+
+    if (!item) 
+    {
+        return;
+    }
+
+    KDecorationMenuButton* buttonBelow = qobject_cast<KDecorationMenuButton*>(item->toGraphicsObject());
+    if (!buttonBelow) 
+    {
+        return;
+    }
+
+    if (buttonBelow != currentButton_) 
+    {
+        QMenu *menu = 0;
+        if (currentButton_ )
+        {
+            currentButton_->nativeWidget()->setDown(false);
+            menu = currentButton_->menu();
+            if (menu)
+            {
+                disconnect(menu, SIGNAL(aboutToHide()), this, SLOT(menuAboutToHide()));
+                menu->hide();
+            }
+        }
+        currentButton_ = buttonBelow;
+        currentButton_->nativeWidget()->setDown(true);
+        showMenu();
+    }
+}
+
+void KDecorationMenuBarWidget::menuAboutToHide()
+{
+    currentButton_->setDown( false );
+    parent_->hide();
+}
+
+void KDecorationMenuBarWidget::buttonClicked()
+{
+    currentButton_ = qobject_cast<KDecorationMenuButton*>(sender());
+
+    currentButton_->nativeWidget()->setDown(true);
+    showMenu();
+}
+
+bool KDecorationMenuBarWidget::menuVisible()
+{
+    QMenu *menu;
+    foreach(KDecorationMenuButton *button, buttons_)
+    {
+        menu = button->menu();
+        if (menu && menu->isVisible())
+            return true;
+    }
+    return false;
+}
+
+void KDecorationMenuBarWidget::showFirstAction()
+{
+    isRightButton_ ? currentButton_ = buttons_.last() : currentButton_ = buttons_.first();
+    currentButton_->nativeWidget()->animateClick();
+}
+
+int KDecorationMenuBarWidget::firstItemWidth()
+{
+    KDecorationMenuButton* button;
+    isRightButton_ ? button = buttons_.last() : button = buttons_.first();
+    if (button)
+        return button->size().width();
+    else
+        return 0;
+}
+
+void KDecorationMenuBarWidget::activateAction(QAction *action) 
+{
+    int index = 0;
+    foreach(KDecorationMenuButton* button, buttons_) {
+        if (button->menu() == action->menu()) {
+            button->nativeWidget()->animateClick();
+            break;
+        }
+        ++index;
+    }
+}
+
+void KDecorationMenuBarWidget::showMenu()
+{
+    QMenu *menu = currentButton_->menu();
+    if (menu)
+    {
+        QPoint globalPos = parent_->mapToGlobal(QPoint(0,0));
+        QPointF parentPos =  currentButton_->mapFromParent(QPoint(0,0));
+        QRect screen = KApplication::desktop()->screenGeometry();
+        int x = globalPos.x() - parentPos.x();
+        int y = globalPos.y() + currentButton_->size().height() - parentPos.y();
+
+        menu->popup(QPoint(x, y));
+
+        // Fix offscreen menu
+        if (menu->size().height() + y > screen.height() + screen.y())
+        {
+            y = globalPos.y() - parentPos.y() - menu->size().height();
+            if (menu->size().width() + x > screen.width() + screen.x())
+                x = screen.width() + screen.x() - menu->size().width();
+            else if (menu->size().width() + x < screen.x())
+                x = screen.x();
+            menu->move(x, y);
+        }
+
+        connect(menu, SIGNAL(aboutToHide()), this, SLOT(menuAboutToHide()));
+
+        installEventFilterForAll(menu, this);
+    }
+}
+
+void KDecorationMenuBarWidget::showLeftRightMenu(bool next)
+{
+    int index = buttons_.indexOf(currentButton_);
+    if (index == -1) {
+        kWarning() << "Couldn't find button!";
+        return;
+    }
+    if (next) {
+        index = (index + 1) % buttons_.count();
+    } else {
+        index = (index == 0 ? buttons_.count() : index) - 1;
+    }
+    QMenu *menu = currentButton_->menu();
+    disconnect(menu, SIGNAL(aboutToHide()), this, SLOT(menuAboutToHide()));
+    menu->hide();
+    currentButton_->setDown(false);
+    currentButton_ = buttons_.at(index);
+    currentButton_->nativeWidget()->setDown(true);
+    showMenu();
+}
+
+void KDecorationMenuBarWidget::installEventFilterForAll(QMenu *menu, QObject *object)
+{
+    menu->installEventFilter(this);
+
+    foreach (QAction *action, menu->actions())
+    {
+        if (action->menu())
+            installEventFilterForAll(action->menu(), object);
+    }
+}
+
+KDecorationMenuBar::KDecorationMenuBar(QMenu *menu, bool rightButton)
+    : QGraphicsView(),
+    background_(new Plasma::FrameSvg(this)),
+    scene_(new QGraphicsScene(this)),
+    container_(new KDecorationMenuBarWidget(this, menu, rightButton))
+{
+    //Setup the window properties
+    setWindowFlags(Qt::X11BypassWindowManagerHint);
+    setFrameStyle(QFrame::NoFrame);
+    viewport()->setAutoFillBackground(false);
+    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setAttribute(Qt::WA_TranslucentBackground);
+
+    //Setup the widgets
+    background_->setImagePath("widgets/tooltip");
+
+    container_->updateLayout();
+
+    scene_->addItem(container_);
+
+    setScene(scene_);
+}
+
+KDecorationMenuBar::~KDecorationMenuBar()
+{
+    delete container_;
+}
+
+//FIXME: What is 8?
+void KDecorationMenuBar::setPosition(int x, int y, int leftConstraint, int rightConstraint)
+{
+    QSizeF sh = sizeHint();
+    int buttonOffset = container_->firstItemWidth()/2;
+
+    if (x == -1) //Center on titlebar
+    {
+        x = rightConstraint - (rightConstraint - leftConstraint)/2 - sh.width()/2 + 8;
+    }
+    else
+    {
+        if (container_->isRightButton())
+            x += 8 + buttonOffset - sh.width() ;
+        else
+            x -= 8 + buttonOffset;
+    }
+
+    y -= 8;
+
+    // Button on the right, put menubar on the right
+    if (container_->isRightButton() && x + sh.width() > rightConstraint) 
+    {
+        x = rightConstraint - sh.width() + 9;
+
+    }else if (x < leftConstraint) {
+
+        x = leftConstraint - 8 ;
+    }
+
+    setGeometry(x, y , sh.width(), sh.height());
+
+}
+
+QSize KDecorationMenuBar::sizeHint() const
+{
+    qreal left, top, right, bottom;
+    QSizeF size = container_->preferredSize();
+    background_->getMargins(left, top, right, bottom);
+    return QSize(size.width() + left + right, size.height() + top + bottom);
+}
+
+void KDecorationMenuBar::show()
+{
+    QGraphicsView::show();
+    container_->showFirstAction();
+    container_->startMouseTimer();
+}
+
+void KDecorationMenuBar::hide()
+{
+    container_->stopMouseTimer();
+    QGraphicsView::hide();
+}
+
+void KDecorationMenuBar::drawBackground(QPainter *painter, const QRectF &/*rectF*/)
+{
+    painter->save();
+    painter->setCompositionMode(QPainter::CompositionMode_Source);
+    background_->paintFrame(painter);
+    painter->restore();
+}
+
+void KDecorationMenuBar::resizeEvent(QResizeEvent*)
+{
+    background_->resizeFrame(size());
+    container_->setGeometry(0, 0, width(), height());
+    qreal left, top, right, bottom;
+    background_->getMargins(left, top, right, bottom);
+    container_->layout()->setContentsMargins(left, top, right, bottom);
+
+    scene_->setSceneRect(0, 0, width(), height());
+    if (!KWindowSystem::compositingActive()) {
+        setMask(background_->mask());
+    }
+}
+
+void KDecorationMenuBar::showEvent(QShowEvent *)
+{
+    Plasma::WindowEffects::overrideShadow(winId(), true);
+    Plasma::WindowEffects::enableBlurBehind(winId(), true, background_->mask());
+}
diff -Nru kde-workspace-4.8.0/kwin/libkdecorations/kdecorationmenubar.h kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecorationmenubar.h
--- kde-workspace-4.8.0/kwin/libkdecorations/kdecorationmenubar.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/libkdecorations/kdecorationmenubar.h	2012-02-20 15:56:26.537180644 +0100
@@ -0,0 +1,133 @@
+/*******************************************************************
+* menuwidget.h
+* Copyright  2012    Cédric Bellegarde <gnumdk@gmail.com>
+* Copyright  2009    Aurélien Gâteau <agateau@kde.org>
+* Inspirated by plasma-widget-menubar
+* This program is free software; you can redistribute it and/or
+* modify it under the terms of the GNU General Public License as
+* published by the Free Software Foundation; either version 2 of
+* the License, or (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*
+******************************************************************/
+
+#ifndef MENUBAR__H
+#define MENUBAR__H
+
+#include <QGraphicsView>
+#include <QTimer>
+#include <QGraphicsWidget>
+#include <Plasma/ToolButton>
+
+class QGraphicsLinearLayout;
+class KDecorationMenuBar;
+
+namespace Plasma
+{
+class FrameSvg;
+class Label;
+class Meter;
+}
+
+class KDecorationMenuButton : public Plasma::ToolButton
+{
+Q_OBJECT
+public:
+    KDecorationMenuButton(QGraphicsWidget *parent): 
+    Plasma::ToolButton(parent),
+    menu_(0)
+    {}
+
+    void setMenu(QMenu *menu) { menu_ = menu; }
+    QMenu *menu() { return menu_; }
+protected:
+    // disable plasma animations
+    void hoverEnterEvent(QGraphicsSceneHoverEvent *){}
+    void hoverLeaveEvent(QGraphicsSceneHoverEvent *){}
+private:
+    QMenu *menu_;
+};
+
+class KDecorationMenuBarWidget : public QGraphicsWidget
+{
+Q_OBJECT
+public:
+    KDecorationMenuBarWidget(KDecorationMenuBar *parent = 0, QMenu *menu = 0, bool isRightButton = false);
+    ~KDecorationMenuBarWidget();
+
+    void updateLayout();
+    bool menuVisible();
+
+    void startMouseTimer() { mouseTimer_->start(); }
+    void stopMouseTimer() { if (mouseTimer_->isActive()) mouseTimer_->stop(); }
+
+    //! Show first action
+    void showFirstAction();
+
+    //! Return first item width
+    int firstItemWidth();
+
+    //! Activate action in menu
+    void activateAction(QAction *action);
+
+    //! True if menu button is right packed
+    bool isRightButton() { return isRightButton_; }
+
+protected:
+    virtual bool eventFilter(QObject*, QEvent*);
+private Q_SLOTS:
+    void checkActiveItem();
+    void menuAboutToHide();
+    void buttonClicked();
+
+private:
+    //! Show current button menu
+    void showMenu();
+    //! Show next menu if next, otherwise previous
+    void showLeftRightMenu(bool next);
+    //! Install event filter for menu and it submenus
+    void installEventFilterForAll(QMenu *menu, QObject *object);
+
+    QTimer *mouseTimer_;
+    QGraphicsLinearLayout *layout_;
+    QList<KDecorationMenuButton*> buttons_;
+    KDecorationMenuBar *parent_;
+    KDecorationMenuButton *currentButton_;
+    QMenu *menu_;
+    bool isRightButton_;
+};
+
+class KDecorationMenuBar : public QGraphicsView
+{
+Q_OBJECT
+public:
+    KDecorationMenuBar(QMenu *menu = 0, bool rightButton = false);
+    ~KDecorationMenuBar();
+
+    //! Set position at x,y constrained by leftConstraint and rightConstraint
+    //! If x == -1, center on titlebar
+    void setPosition(int x, int y, int leftConstraint, int rightConstraint);
+    //! Activate action in widget
+    void activateAction(QAction *action) { container_->activateAction(action); }
+    QSize sizeHint() const;
+    void show();
+    void hide();
+
+protected:
+    void drawBackground(QPainter *painter, const QRectF &rectF);
+    void resizeEvent(QResizeEvent *);
+    void showEvent(QShowEvent *event);
+private:
+    Plasma::FrameSvg *background_;
+    QGraphicsScene *scene_;
+    KDecorationMenuBarWidget *container_;
+};
+
+#endif
diff -Nru kde-workspace-4.8.0/kwin/useractions.cpp kde-workspace-4.8.0-appmenu/kwin/useractions.cpp
--- kde-workspace-4.8.0/kwin/useractions.cpp	2012-01-18 21:08:42.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/useractions.cpp	2012-02-20 15:56:26.537180644 +0100
@@ -243,6 +243,13 @@
     active_client->setOpacity(qMax(active_client->opacity() - 0.05, 0.05));
 }
 
+void Workspace::slotShowApplicationMenu()
+{
+    if (!active_client) {
+        return;
+    }
+    active_client->showApplicationMenu();
+}
 /*!
   The client popup menu will become visible soon.
 
diff -Nru kde-workspace-4.8.0/kwin/workspace.h kde-workspace-4.8.0-appmenu/kwin/workspace.h
--- kde-workspace-4.8.0/kwin/workspace.h	2012-01-18 21:08:42.000000000 +0100
+++ kde-workspace-4.8.0-appmenu/kwin/workspace.h	2012-02-20 15:56:26.537180644 +0100
@@ -593,6 +593,8 @@
     void slotIncreaseWindowOpacity();
     void slotLowerWindowOpacity();
 
+    void slotShowApplicationMenu();
+    
     void slotWindowOperations();
     void slotWindowClose();
     void slotWindowMove();
