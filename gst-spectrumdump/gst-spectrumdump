#!/usr/bin/env python2
# -*- coding: utf-8 -*-
### GStreamer Spectrum Dump ####
# Version 0.2 by Scott Garrett #
# Wintervenom [(at)] gmail.com #
################################
# Dependencies:
#
# pygobject
# gst-python (gstreamer0.10-python)
# gstreamer0.10-good
#
# Optional Dependencies:
# gconf (python2-gconf)
#
#################################
# License:
#
# This program is free software. It comes without any warranty, to
# the extent permitted by applicable law. You can redistribute it
# and/or modify it under the terms of the Do What The Fuck You Want
# To Public License, Version 2, as published by Sam Hocevar. See
# http://sam.zoy.org/wtfpl/COPYING for more details.

import curses
try:
    import gconf
except ImportError:
    pass
import sys
import getopt
import gobject
import math
import pprint
import pygst
pygst.require('0.10')
import gst
import os


VERSION = 0.1
sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)


def stdout(message):
    """
    Writes a message to STDOUT.
    """
    sys.stdout.write("{0}\n".format(message))
    sys.stdout.flush()


def stderr(message):
    """
    Writes a message to STDERR.
    """
    sys.stderr.write("{0}\n".format(message))
    sys.stderr.flush()


def fatal(error):
    """
    Output an error message to STDERR and exit with status 1.
    """
    stderr("Error: {0}".format(error))
    sys.exit(1)


def usage():
    text = """
    GStreamer Spectrum Analyzer Dump 0.1
    Version {0} by Scott Garrett
    Wintervenom [(at)] gmail.com

    Usage: gst-spectrumdump [opts]
        -h --help       Obvious.  ;)
        -s --source=    GST source of audio stream (default: gconf setting or
                        'alsasrc').
        -p --precision= Number of decimal places to round magnitudes.
                        A precision of zero will round to integers (0-16).
        -b --bands=     Number of frequency bands to output (1-128).
        -a --amplify=   Amplify output by this amount (-10-10)
        -l --lamplify=  Amplify magnitudes logarithmically to compensate for
                        softer higher frequencies.
        -v --vu         Return VU meter dump instead of spectrum dump.
                        The band option will be the maxiumum number of
                        channels to output.
        -d --draw       Draw spectrum.
    """
    text = text.format(os.path.basename(sys.argv[0]), VERSION)
    stderr(textwrap.dedent(text))
    sys.exit(2)





class GstSpectrumDump(object):
    """
    Dumps the spectrum magnitudes of incoming audio as volume units per band.

    Optional arguments:
    <source>: Source of the audio (default: alsasrc or gconf setting).
    <precision>: How many decimal places to round the magnitudes to (default: 16).
    <bands>: How many frequency bands to output (default: 128).
    <amplify>: Amplify output by this much (default: 1).
    <threshold>: Minimal magnitude of a band.
    <vumeter>: Return VU meter output instead of spectrum (bands=channels).
    <logamplify>: Amplify magnitude values logarithmically to compensate for
                  softer higher frequencies.  (default: False)
    <quiet>: Don't output to STDERR (default: False).
    <callback>: Return the magnitude list to this function (default: None).
    """
    def __init__(self, **opts):
        self.source = opts.get('source')
        self.precision = opts.get('precision')
        self.bands = opts.get('bands', 128)
        self.amplify = opts.get('amplify', 1)
        self.logamplify = opts.get('logamplify', False)
        self.threshold = opts.get('threshold', 70)
        self.vumeter = opts.get('vumeter', False)
        self.quiet = opts.get('quiet', False)
        self.callback = opts.get('callback')
        self.pipeline = None
        if not self.source:
            defaultsrc = 'alsasrc'
            try:
                conf = gconf.client_get_default()
                source = conf.get('/system/gstreamer/%d.%d/default/audiosrc' %
                                  gst.gst_version[:-1])
                if source:
                    self.source = source.get_string()
                else:
                    self.source = defaultsrc
            except NameError:
                stderr('Python2 GConf module not installed; using default source.')
                self.source = defaultsrc
        stderr('Source: {0}.'.format(self.source))


    def draw(self, magnitudes):
        self.stdscr.erase()
        for i, m in enumerate(magnitudes):
            self.stdscr.addstr(i, 0, ' ' * int(round(m, 0)), curses.A_REVERSE)
        self.stdscr.refresh()


    def round(self, n, precision=None):
        if precision:
            return round(n, precision)
        elif precision == 0:
            return int(n)
        return n


    def dbtoiec(self, db, amp=1):
        """
        Decibel to IEC scale converter.
        Borrowed from gst-python's VU meter with modification to round and
        amplify result.
        """
        pct = 0.0
        if db < -70.0:
            pct = 0.0
        elif db < -60.0:
            pct = (db + 70.0) * 0.25
        elif db < -50.0:
            pct = (db + 60.0) * 0.5 + 2.5
        elif db < -40.0:
            pct = (db + 50.0) * 0.75 + 7.5
        elif db < -30.0:
            pct = (db + 40.0) * 1.5 + 15.0
        elif db < -20.0:
            pct = (db + 30.0) * 2.0 + 30.0
        elif db < 0.0:
            pct = (db + 20.0) * 2.5 + 50.0
        else:
            pct = 100.0
        return min(100, self.amplify * (amp * pct))


    def interpolate(self, a, b, points):
        points = round(points, 0) + 1.0
        return [a + ((b - a) / points) * x for x in range(0, int(points))]


    def scale(self, floats, precision=None, maxlen=None):
        if len(floats) < 2:
            return floats
        scaled = []
        for i in range(1, len(floats)):
            length = 1 + math.log10(i - 0)
            scaled += self.interpolate(floats[i-1], floats[i], length)[:-1]
        scaled.append(floats[-1])
        if maxlen and len(scaled) > maxlen:
            downscaled = []
            incr = len(scaled) / float(maxlen)
            index = 0
            for v in range(0, maxlen):
                downscaled.append(scaled[int(round(index, 0))])
                index += incr
            return downscaled
        else:
            return scaled


    def on_message(self, bus, message):
        s = message.structure
        name = s.get_name()
        if name == 'spectrum':
            magnitudes = s['magnitude'][:int(round(self.bands * (7/8.0), 0))]
            if self.logamplify:
                magnitudes = [self.dbtoiec(db, 1+math.log10(1+i)) for i, db in
                              enumerate(magnitudes)]
            else:
                magnitudes = [self.dbtoiec(db, 1) for i, db in
                              enumerate(magnitudes)]
            magnitudes = self.scale(magnitudes, self.precision, self.bands)
            magnitudes = [self.round(m, self.precision) for m in magnitudes]
        elif name == 'level':
            magnitudes = []
            for channel in range(0, min(self.bands, len(s['peak']))):
                peak = max(-90, min(0, s['peak'][channel]))
                decay = max(-90, min(0, s['decay'][channel]))
                peak = max(100, self.amplify * peak)
                decay = max(100, self.amplify * decay)
                magnitudes.append(self.dbtoiec(peak, self.precision))
                magnitudes.append(self.dbtoiec(decay, self.precision))
        else:
            return True
        if not self.quiet:
            try:
                print(' '.join((str(m) for m in magnitudes)))
            except IOError:
                self.loop.quit()
        if self.callback:
            self.callback(magnitudes)
        return True


    def start_pipeline(self):
        pipeline = [self.source]
        if self.vumeter:
            pipeline.append('level message=true')
        else:
            spectrum='spectrum message=true bands={0} threshold=-{1}'
            pipeline.append(spectrum.format(self.bands, self.threshold))
        pipeline.append('fakesink')
        self.pipeline = gst.parse_launch(' ! '.join(pipeline))
        self.bus = self.pipeline.get_bus()
        self.bus.enable_sync_message_emission()
        self.bus.add_signal_watch()
        self.conn = self.bus.connect("message::element", self.on_message)
        self.pipeline.set_state(gst.STATE_PLAYING)


    def stop_pipeline(self):
        if self.pipeline:
            self.bus.disconnect(self.conn)
            self.bus.remove_signal_watch()
            self.pipeline.set_state(gst.STATE_NULL)


    def run(self, stdscr=None):
        self.stdscr = stdscr
        if stdscr:
            try:
                curses.curs_set(0)
            except:
                pass
            height = stdscr.getmaxyx()[0]
            if self.bands > height:
                self.bands = height
        try:
            self.start_pipeline()
            self.loop = gobject.MainLoop(is_running=True)
            while self.loop.is_running():
                try:
                    self.loop.run()
                except KeyboardInterrupt:
                    break
            self.stop_pipeline()
            sys.exit(0)
        except gobject.GError as error:
            stderr("Error creating pipeline: {0}".format(error))
            stderr("Do you have gstreamer0.10-good installed?")
            sys.exit(1)


    def rundraw(self):
        self.quiet = True
        self.callback = self.draw
        curses.wrapper(self.run)


def main():
    opt_precision = None
    opt_bands = 128
    opt_amplify = 1
    opt_lamplify = False
    opt_vumeter = False
    opt_source = None
    opt_draw = False
    try:
        longopts = ['source=', 'precision=', 'bands=', 'amplify=', 'lamplify',
                    'vu', 'draw', 'help']
        opts, args = getopt.getopt(sys.argv[1:], 's:p:b:a:lvdh', longopts)
    except getopt.GetoptError as error:
        fatal(error)
    for o, a in opts:
        if o in ('-s', '--source'):
            if a.isalnum():
                opt_source = a
            else:
                fatal('Invalid audio source.')
        elif o in ('-p', '--precision'):
            if a.isdigit():
                opt_precision = int(a)
            else:
                fatal('Precision should be an integer greater than zero.')
        elif o in ('-a', '--amplify'):
            try:
                opt_amplify = max(-10, min(10, float(a)))
            except ValueError:
                fatal('Amplify should be a float between -10 and 10.')
        elif o in ('-b', '--bands'):
            if a.isdigit():
                opt_bands = max(1, min(128, int(a)))
            else:
                fatal('Bands should be an integer between 1 and 128.')
        elif o in ('-l', '--lamplify'):
            opt_lamplify = True
        elif o in ('-v', '--vu'):
            opt_vumeter = True
        elif o in ('-d', '--draw'):
            opt_draw = True
        elif o in ('-h', '--help'):
            usage()
    spectrum = GstSpectrumDump(source=opt_source, precision=opt_precision,
                               bands=opt_bands, amplify=opt_amplify,
                               logamplify=opt_lamplify, vmumeter=opt_vumeter)
    if opt_draw:
        spectrum.rundraw()
    else:
        spectrum.run()


if __name__ == "__main__":
    main()
