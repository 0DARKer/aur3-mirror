diff -urN SuperLU_MT_2.0.orig/make.inc SuperLU_MT_2.0/make.inc
--- SuperLU_MT_2.0.orig/make.inc	2010-10-24 15:32:48.004562348 +0200
+++ SuperLU_MT_2.0/make.inc	2010-10-24 15:41:18.877895682 +0200
@@ -16,7 +16,7 @@
 #
 #  The machine (platform) identifier to append to the library names
 #
-PLAT = _sp
+PLAT = 
 
 #
 #  The name of the libraries to be created/linked to
@@ -29,8 +29,8 @@
 #           BLASLIB = -lblas -lxlf -lxlf90
 # which may be slower than ESSL
 #
-BLASDEF	  = -DUSE_VENDOR_BLAS
-BLASLIB   = -lessl
+BLASDEF	  = 
+BLASLIB   = -lblas
 #BLASLIB   = ../lib/libblas$(PLAT).a
 MATHLIB	  = -lm 
 MPLIB	  = -lpthread
@@ -46,16 +46,16 @@
 PREDEFS      	= -D_PTHREAD
 #
 
-CC           = xlc_r
-CFLAGS       = -qarch=pwr5 -qalias=allptrs $(PREDEFS) -DPRNTlevel=0 -O3
-FORTRAN	     = xlf
-FFLAGS       = -O3 -qarch=pwr5
-LOADER       = xlc_r
-LOADOPTS     = -bmaxdata:0x80000000
+CC           = cc
+CFLAGS       = 
+FORTRAN	 = gfortran
+FFLAGS       = 
+LOADER       = cc
+LOADOPTS     = 
 #
 #  C preprocessor defs for compilation for the Fortran interface
 #  (-DNoChange, -DAdd_, -DAdd__, or -DUpCase)
 #
-CDEFS        = -DNoChange
+CDEFS        = -DAdd_
 
 
diff -urN SuperLU_MT_2.0.orig/SRC/cmatgen.c SuperLU_MT_2.0/SRC/cmatgen.c
--- SuperLU_MT_2.0.orig/SRC/cmatgen.c	2010-10-24 15:32:48.001229014 +0200
+++ SuperLU_MT_2.0/SRC/cmatgen.c	2010-10-24 16:48:08.347895679 +0200
@@ -93,76 +93,4 @@
     xa[n] = lasta;
 }
 
-double dlaran_(int *iseed)
-{
-/*  -- LAPACK auxiliary routine (version 2.0) --   
-       Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,   
-       Courant Institute, Argonne National Lab, and Rice University   
-       February 29, 1992   
-
-    Purpose   
-    =======   
-
-    DLARAN returns a random real number from a uniform (0,1)   
-    distribution.   
-
-    Arguments   
-    =========   
-
-    ISEED   (input/output) INT array, dimension (4)   
-            On entry, the seed of the random number generator; the array 
-  
-            elements must be between 0 and 4095, and ISEED(4) must be   
-            odd.   
-            On exit, the seed is updated.   
-
-    Further Details   
-    ===============   
-
-    This routine uses a multiplicative congruential method with modulus   
-    2**48 and multiplier 33952834046453 (see G.S.Fishman,   
-    'Multiplicative congruential random number generators with modulus   
-    2**b: an exhaustive analysis for b = 32 and a partial analysis for   
-    b = 48', Math. Comp. 189, pp 331-344, 1990).   
-
-    48-bit integers are stored in 4 integer array elements with 12 bits   
-    per element. Hence the routine is portable across machines with   
-    integers of 32 bits or more.   
-
-    ===================================================================== 
-*/
-    
-    /* Local variables */
-    int it1, it2, it3, it4;
-
-    --iseed;
-
-    /* multiply the seed by the multiplier modulo 2**48 */
-    it4 = iseed[4] * 2549;
-    it3 = it4 / 4096;
-    it4 -= it3 << 12;
-    it3 = it3 + iseed[3] * 2549 + iseed[4] * 2508;
-    it2 = it3 / 4096;
-    it3 -= it2 << 12;
-    it2 = it2 + iseed[2] * 2549 + iseed[3] * 2508 + iseed[4] * 322;
-    it1 = it2 / 4096;
-    it2 -= it1 << 12;
-    it1 = it1 + iseed[1] * 2549 + iseed[2] * 2508 + iseed[3] * 322 + iseed[4] 
-	    * 494;
-    it1 %= 4096;
-
-   /* return updated seed */
-
-    iseed[1] = it1;
-    iseed[2] = it2;
-    iseed[3] = it3;
-    iseed[4] = it4;
-
-   /* convert 48-bit integer to a real number in the interval (0,1) */
-
-    return ((double) it1 +
-	    ((double) it2 + ((double) it3 + (double) it4 * 2.44140625e-4) *
-	     2.44140625e-4) * 2.44140625e-4) * 2.44140625e-4;
-
-} /* dlaran_ */
 
diff -urN SuperLU_MT_2.0.orig/SRC/cmyblas2.c SuperLU_MT_2.0/SRC/cmyblas2.c
--- SuperLU_MT_2.0.orig/SRC/cmyblas2.c	2010-10-24 15:32:48.001229014 +0200
+++ SuperLU_MT_2.0/SRC/cmyblas2.c	2010-10-24 16:43:36.411229012 +0200
@@ -181,3 +181,127 @@
 	
 }
 
+/*
+ * Performs dense matrix-vector multiply with 2 vectors:
+ *        y0 = y0 + A * x0
+ *        y1 = y1 + A * x1
+ */
+void cmatvec2 (
+               int lda,     /* leading dimension of A */
+               int m,
+               int n,
+               complex *A,   /* in - size m-by-n */
+               complex *x0,  /* in - size n-by-1 */
+               complex *x1,  /* in - size n-by-1 */
+               complex *y0,  /* out - size n-by-1 */
+               complex *y1   /* out - size n-by-1 */
+               )
+
+{
+    complex v00, v10, v20, v30, v40, v50, v60, v70,
+                    v01, v11, v21, v31, v41, v51, v61, v71;
+    complex t0, t1, t2, t3, t4, t5, t6, t7;
+    complex f0, f1;
+    complex *Mki0, *Mki1, *Mki2, *Mki3, *Mki4, *Mki5, *Mki6, *Mki7;
+    register int firstcol = 0;
+    complex *M0, temp;
+    int k;
+
+    M0 = &A[0];
+
+    while ( firstcol < n - 7 ) {        /* Do 8 columns */
+
+        Mki0 = M0;
+        Mki1 = Mki0 + lda;
+        Mki2 = Mki1 + lda;
+        Mki3 = Mki2 + lda;
+        Mki4 = Mki3 + lda;
+        Mki5 = Mki4 + lda;
+        Mki6 = Mki5 + lda;
+        Mki7 = Mki6 + lda;
+
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+        v10 = x0[firstcol];   v11 = x1[firstcol++];
+        v20 = x0[firstcol];   v21 = x1[firstcol++];
+        v30 = x0[firstcol];   v31 = x1[firstcol++];
+        v40 = x0[firstcol];   v41 = x1[firstcol++];
+        v50 = x0[firstcol];   v51 = x1[firstcol++];
+        v60 = x0[firstcol];   v61 = x1[firstcol++];
+        v70 = x0[firstcol];   v71 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];  cc_mult(&temp, &v00, &t0);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v01,&t0);c_add(&f1,&f1,&temp);
+            t1 = Mki1[k];  cc_mult(&temp,&v10,&t1);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v11,&t1);c_add(&f1,&f1,&temp);
+            t2 = Mki2[k];  cc_mult(&temp,&v20,&t2);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v21,&t2);c_add(&f1,&f1,&temp);
+            t3 = Mki3[k];  cc_mult(&temp,&v30,&t3);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v31,&t3);c_add(&f1,&f1,&temp);
+            t4 = Mki4[k];  cc_mult(&temp,&v40,&t4);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v41,&t4);c_add(&f1,&f1,&temp);
+            t5 = Mki5[k];  cc_mult(&temp,&v50,&t5);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v51,&t5);c_add(&f1,&f1,&temp);
+            t6 = Mki6[k];  cc_mult(&temp,&v60,&t6);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v61,&t6);c_add(&f1,&f1,&temp);
+            t7 = Mki7[k];  cc_mult(&temp,&v70,&t7);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v71,&t7);c_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += 8 * lda;
+    }
+
+    while ( firstcol < n - 3 ) {        /* Do 4 columns */
+        Mki0 = M0;
+        Mki1 = Mki0 + lda;
+        Mki2 = Mki1 + lda;
+        Mki3 = Mki2 + lda;
+
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+        v10 = x0[firstcol];   v11 = x1[firstcol++];
+        v20 = x0[firstcol];   v21 = x1[firstcol++];
+        v30 = x0[firstcol];   v31 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];  cc_mult(&temp,&v00,&t0);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v01,&t0);c_add(&f1,&f1,&temp);
+            t1 = Mki1[k];  cc_mult(&temp,&v10,&t1);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v11,&t1);c_add(&f1,&f1,&temp);
+            t2 = Mki2[k];  cc_mult(&temp,&v20,&t2);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v21,&t2);c_add(&f1,&f1,&temp);
+            t3 = Mki3[k];  cc_mult(&temp,&v30,&t3);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v31,&t3);c_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += 4 * lda;
+
+    }
+
+    while ( firstcol < n ) {            /* Do 1 column */
+        Mki0 = M0;
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];
+            cc_mult(&temp,&v00,&t0);c_add(&f0,&f0,&temp);
+            cc_mult(&temp,&v01,&t0);c_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += lda;
+    }
+
+}
+
+
diff -urN SuperLU_MT_2.0.orig/SRC/smatgen.c SuperLU_MT_2.0/SRC/smatgen.c
--- SuperLU_MT_2.0.orig/SRC/smatgen.c	2010-10-24 15:32:47.997895679 +0200
+++ SuperLU_MT_2.0/SRC/smatgen.c	2010-10-24 16:48:08.347895679 +0200
@@ -93,76 +93,3 @@
     xa[n] = lasta;
 }
 
-double dlaran_(int *iseed)
-{
-/*  -- LAPACK auxiliary routine (version 2.0) --   
-       Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,   
-       Courant Institute, Argonne National Lab, and Rice University   
-       February 29, 1992   
-
-    Purpose   
-    =======   
-
-    DLARAN returns a random real number from a uniform (0,1)   
-    distribution.   
-
-    Arguments   
-    =========   
-
-    ISEED   (input/output) INT array, dimension (4)   
-            On entry, the seed of the random number generator; the array 
-  
-            elements must be between 0 and 4095, and ISEED(4) must be   
-            odd.   
-            On exit, the seed is updated.   
-
-    Further Details   
-    ===============   
-
-    This routine uses a multiplicative congruential method with modulus   
-    2**48 and multiplier 33952834046453 (see G.S.Fishman,   
-    'Multiplicative congruential random number generators with modulus   
-    2**b: an exhaustive analysis for b = 32 and a partial analysis for   
-    b = 48', Math. Comp. 189, pp 331-344, 1990).   
-
-    48-bit integers are stored in 4 integer array elements with 12 bits   
-    per element. Hence the routine is portable across machines with   
-    integers of 32 bits or more.   
-
-    ===================================================================== 
-*/
-    
-    /* Local variables */
-    int it1, it2, it3, it4;
-
-    --iseed;
-
-    /* multiply the seed by the multiplier modulo 2**48 */
-    it4 = iseed[4] * 2549;
-    it3 = it4 / 4096;
-    it4 -= it3 << 12;
-    it3 = it3 + iseed[3] * 2549 + iseed[4] * 2508;
-    it2 = it3 / 4096;
-    it3 -= it2 << 12;
-    it2 = it2 + iseed[2] * 2549 + iseed[3] * 2508 + iseed[4] * 322;
-    it1 = it2 / 4096;
-    it2 -= it1 << 12;
-    it1 = it1 + iseed[1] * 2549 + iseed[2] * 2508 + iseed[3] * 322 + iseed[4] 
-	    * 494;
-    it1 %= 4096;
-
-   /* return updated seed */
-
-    iseed[1] = it1;
-    iseed[2] = it2;
-    iseed[3] = it3;
-    iseed[4] = it4;
-
-   /* convert 48-bit integer to a real number in the interval (0,1) */
-
-    return ((double) it1 +
-	    ((double) it2 + ((double) it3 + (double) it4 * 2.44140625e-4) *
-	     2.44140625e-4) * 2.44140625e-4) * 2.44140625e-4;
-
-} /* dlaran_ */
-
diff -urN SuperLU_MT_2.0.orig/SRC/xerbla.c SuperLU_MT_2.0/SRC/xerbla.c
--- SuperLU_MT_2.0.orig/SRC/xerbla.c	2010-10-24 15:32:48.001229014 +0200
+++ SuperLU_MT_2.0/SRC/xerbla.c	2010-10-24 16:48:08.351229012 +0200
@@ -1,3 +1,4 @@
+#include <stdio.h>
 /* Subroutine */ int xerbla_(char *srname, int *info)
 {
 /*  -- LAPACK auxiliary routine (version 2.0) --   
diff -urN SuperLU_MT_2.0.orig/SRC/zmatgen.c SuperLU_MT_2.0/SRC/zmatgen.c
--- SuperLU_MT_2.0.orig/SRC/zmatgen.c	2010-10-24 15:32:47.997895679 +0200
+++ SuperLU_MT_2.0/SRC/zmatgen.c	2010-10-24 16:48:08.351229012 +0200
@@ -93,76 +93,3 @@
     xa[n] = lasta;
 }
 
-double dlaran_(int *iseed)
-{
-/*  -- LAPACK auxiliary routine (version 2.0) --   
-       Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,   
-       Courant Institute, Argonne National Lab, and Rice University   
-       February 29, 1992   
-
-    Purpose   
-    =======   
-
-    DLARAN returns a random real number from a uniform (0,1)   
-    distribution.   
-
-    Arguments   
-    =========   
-
-    ISEED   (input/output) INT array, dimension (4)   
-            On entry, the seed of the random number generator; the array 
-  
-            elements must be between 0 and 4095, and ISEED(4) must be   
-            odd.   
-            On exit, the seed is updated.   
-
-    Further Details   
-    ===============   
-
-    This routine uses a multiplicative congruential method with modulus   
-    2**48 and multiplier 33952834046453 (see G.S.Fishman,   
-    'Multiplicative congruential random number generators with modulus   
-    2**b: an exhaustive analysis for b = 32 and a partial analysis for   
-    b = 48', Math. Comp. 189, pp 331-344, 1990).   
-
-    48-bit integers are stored in 4 integer array elements with 12 bits   
-    per element. Hence the routine is portable across machines with   
-    integers of 32 bits or more.   
-
-    ===================================================================== 
-*/
-    
-    /* Local variables */
-    int it1, it2, it3, it4;
-
-    --iseed;
-
-    /* multiply the seed by the multiplier modulo 2**48 */
-    it4 = iseed[4] * 2549;
-    it3 = it4 / 4096;
-    it4 -= it3 << 12;
-    it3 = it3 + iseed[3] * 2549 + iseed[4] * 2508;
-    it2 = it3 / 4096;
-    it3 -= it2 << 12;
-    it2 = it2 + iseed[2] * 2549 + iseed[3] * 2508 + iseed[4] * 322;
-    it1 = it2 / 4096;
-    it2 -= it1 << 12;
-    it1 = it1 + iseed[1] * 2549 + iseed[2] * 2508 + iseed[3] * 322 + iseed[4] 
-	    * 494;
-    it1 %= 4096;
-
-   /* return updated seed */
-
-    iseed[1] = it1;
-    iseed[2] = it2;
-    iseed[3] = it3;
-    iseed[4] = it4;
-
-   /* convert 48-bit integer to a real number in the interval (0,1) */
-
-    return ((double) it1 +
-	    ((double) it2 + ((double) it3 + (double) it4 * 2.44140625e-4) *
-	     2.44140625e-4) * 2.44140625e-4) * 2.44140625e-4;
-
-} /* dlaran_ */
-
diff -urN SuperLU_MT_2.0.orig/SRC/zmyblas2.c SuperLU_MT_2.0/SRC/zmyblas2.c
--- SuperLU_MT_2.0.orig/SRC/zmyblas2.c	2010-10-24 15:32:48.001229014 +0200
+++ SuperLU_MT_2.0/SRC/zmyblas2.c	2010-10-24 16:45:39.021229012 +0200
@@ -181,3 +181,127 @@
 	
 }
 
+/*
+ * Performs dense matrix-vector multiply with 2 vectors:
+ *        y0 = y0 + A * x0
+ *        y1 = y1 + A * x1
+ */
+void zmatvec2 (
+               int lda,     /* leading dimension of A */
+               int m,
+               int n,
+               doublecomplex *A,   /* in - size m-by-n */
+               doublecomplex *x0,  /* in - size n-by-1 */
+               doublecomplex *x1,  /* in - size n-by-1 */
+               doublecomplex *y0,  /* out - size n-by-1 */
+               doublecomplex *y1   /* out - size n-by-1 */
+               )
+
+{
+    doublecomplex v00, v10, v20, v30, v40, v50, v60, v70,
+                    v01, v11, v21, v31, v41, v51, v61, v71;
+    doublecomplex t0, t1, t2, t3, t4, t5, t6, t7;
+    doublecomplex f0, f1;
+    doublecomplex *Mki0, *Mki1, *Mki2, *Mki3, *Mki4, *Mki5, *Mki6, *Mki7;
+    register int firstcol = 0;
+    doublecomplex *M0, temp;
+    int k;
+
+    M0 = &A[0];
+
+    while ( firstcol < n - 7 ) {        /* Do 8 columns */
+
+        Mki0 = M0;
+        Mki1 = Mki0 + lda;
+        Mki2 = Mki1 + lda;
+        Mki3 = Mki2 + lda;
+        Mki4 = Mki3 + lda;
+        Mki5 = Mki4 + lda;
+        Mki6 = Mki5 + lda;
+        Mki7 = Mki6 + lda;
+
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+        v10 = x0[firstcol];   v11 = x1[firstcol++];
+        v20 = x0[firstcol];   v21 = x1[firstcol++];
+        v30 = x0[firstcol];   v31 = x1[firstcol++];
+        v40 = x0[firstcol];   v41 = x1[firstcol++];
+        v50 = x0[firstcol];   v51 = x1[firstcol++];
+        v60 = x0[firstcol];   v61 = x1[firstcol++];
+        v70 = x0[firstcol];   v71 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];  zz_mult(&temp,&v00,&t0);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v01,&t0);z_add(&f1,&f1,&temp);
+            t1 = Mki1[k];  zz_mult(&temp,&v10,&t1);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v11,&t1);z_add(&f1,&f1,&temp);
+            t2 = Mki2[k];  zz_mult(&temp,&v20,&t2);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v21,&t2);z_add(&f1,&f1,&temp);
+            t3 = Mki3[k];  zz_mult(&temp,&v30,&t3);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v31,&t3);z_add(&f1,&f1,&temp);
+            t4 = Mki4[k];  zz_mult(&temp,&v40,&t4);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v41,&t4);z_add(&f1,&f1,&temp);
+            t5 = Mki5[k];  zz_mult(&temp,&v50,&t5);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v51,&t5);z_add(&f1,&f1,&temp);
+            t6 = Mki6[k];  zz_mult(&temp,&v60,&t6);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v61,&t6);z_add(&f1,&f1,&temp);
+            t7 = Mki7[k];  zz_mult(&temp,&v70,&t7);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v71,&t7);z_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += 8 * lda;
+    }
+
+    while ( firstcol < n - 3 ) {        /* Do 4 columns */
+        Mki0 = M0;
+        Mki1 = Mki0 + lda;
+        Mki2 = Mki1 + lda;
+        Mki3 = Mki2 + lda;
+
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+        v10 = x0[firstcol];   v11 = x1[firstcol++];
+        v20 = x0[firstcol];   v21 = x1[firstcol++];
+        v30 = x0[firstcol];   v31 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];  zz_mult(&temp,&v00,&t0);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v01,&t0);z_add(&f1,&f1,&temp);
+            t1 = Mki1[k];  zz_mult(&temp,&v10,&t1);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v11,&t1);z_add(&f1,&f1,&temp);
+            t2 = Mki2[k];  zz_mult(&temp,&v20,&t2);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v21,&t2);z_add(&f1,&f1,&temp);
+            t3 = Mki3[k];  zz_mult(&temp,&v30,&t3);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v31,&t3);z_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += 4 * lda;
+
+    }
+
+    while ( firstcol < n ) {            /* Do 1 column */
+        Mki0 = M0;
+        v00 = x0[firstcol];   v01 = x1[firstcol++];
+
+        for (k = 0; k < m; k++) {
+            f0 = y0[k];
+            f1 = y1[k];
+            t0 = Mki0[k];
+            zz_mult(&temp,&v00,&t0);z_add(&f0,&f0,&temp);
+            zz_mult(&temp,&v01,&t0);z_add(&f1,&f1,&temp);
+            y0[k] = f0;
+            y1[k] = f1;
+        }
+
+        M0 += lda;
+    }
+
+}
+
+
diff -urN SuperLU_MT_2.0.orig/TESTING/MATGEN/clatb4.c SuperLU_MT_2.0/TESTING/MATGEN/clatb4.c
--- SuperLU_MT_2.0.orig/TESTING/MATGEN/clatb4.c	2010-10-24 15:32:47.994562344 +0200
+++ SuperLU_MT_2.0/TESTING/MATGEN/clatb4.c	2010-10-24 15:33:14.847895677 +0200
@@ -3,6 +3,7 @@
 	-lf2c -lm   (in that order)
 */
 
+#include <string.h>
 #include "f2c.h"
 
 /* Table of constant values */
diff -urN SuperLU_MT_2.0.orig/TESTING/MATGEN/dlatb4.c SuperLU_MT_2.0/TESTING/MATGEN/dlatb4.c
--- SuperLU_MT_2.0.orig/TESTING/MATGEN/dlatb4.c	2010-10-24 15:32:47.994562344 +0200
+++ SuperLU_MT_2.0/TESTING/MATGEN/dlatb4.c	2010-10-24 15:33:14.851229012 +0200
@@ -3,6 +3,7 @@
 	-lf2c -lm   (in that order)
 */
 
+#include <string.h>
 #include "f2c.h"
 
 /* Table of constant values */
diff -urN SuperLU_MT_2.0.orig/TESTING/MATGEN/slatb4.c SuperLU_MT_2.0/TESTING/MATGEN/slatb4.c
--- SuperLU_MT_2.0.orig/TESTING/MATGEN/slatb4.c	2010-10-24 15:32:47.994562344 +0200
+++ SuperLU_MT_2.0/TESTING/MATGEN/slatb4.c	2010-10-24 15:33:14.851229012 +0200
@@ -3,6 +3,7 @@
 	-lf2c -lm   (in that order)
 */
 
+#include <string.h>
 #include "f2c.h"
 
 /* Table of constant values */
diff -urN SuperLU_MT_2.0.orig/TESTING/MATGEN/zlatb4.c SuperLU_MT_2.0/TESTING/MATGEN/zlatb4.c
--- SuperLU_MT_2.0.orig/TESTING/MATGEN/zlatb4.c	2010-10-24 15:32:47.994562344 +0200
+++ SuperLU_MT_2.0/TESTING/MATGEN/zlatb4.c	2010-10-24 15:33:14.854562347 +0200
@@ -3,6 +3,7 @@
 	-lf2c -lm   (in that order)
 */
 
+#include <string.h>
 #include "f2c.h"
 
 /* Table of constant values */
