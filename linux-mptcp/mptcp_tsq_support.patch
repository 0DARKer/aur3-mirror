From 417ae7c3cc9b3b8d4fdb5556d37fe51888661286 Mon Sep 17 00:00:00 2001
From: Christoph Paasch <christoph.paasch@uclouvain.be>
Date: Fri, 9 Aug 2013 11:15:56 +0200
Subject: [PATCH] Support TSQ

Signed-off-by: Christoph Paasch <christoph.paasch@uclouvain.be>
---
 net/ipv4/tcp_output.c    | 16 +++++++++++-----
 net/mptcp/mptcp_ctrl.c   |  1 +
 net/mptcp/mptcp_output.c |  9 +++++++++
 3 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c
index 79a6740..f2bfa43 100644
--- a/net/ipv4/tcp_output.c
+++ b/net/ipv4/tcp_output.c
@@ -722,7 +722,7 @@ static void tcp_tasklet_func(unsigned long data)
 	unsigned long flags;
 	struct list_head *q, *n;
 	struct tcp_sock *tp;
-	struct sock *sk;
+	struct sock *sk, *meta_sk;
 
 	local_irq_save(flags);
 	list_splice_init(&tsq->head, &list);
@@ -733,15 +733,18 @@ static void tcp_tasklet_func(unsigned long data)
 		list_del(&tp->tsq_node);
 
 		sk = (struct sock *)tp;
-		bh_lock_sock(sk);
+		meta_sk = tp->mpc ? mptcp_meta_sk(sk) : sk;
+		bh_lock_sock(meta_sk);
 
-		if (!sock_owned_by_user(sk)) {
-			tcp_tsq_handler(sk);
+		if (!sock_owned_by_user(meta_sk)) {
+			tcp_tsq_handler(meta_sk);
 		} else {
 			/* defer the work to tcp_release_cb() */
 			set_bit(TCP_TSQ_DEFERRED, &tp->tsq_flags);
+			if (tp->mpc)
+				set_bit(TCP_TSQ_DEFERRED, &tcp_sk(meta_sk)->tsq_flags);
 		}
-		bh_unlock_sock(sk);
+		bh_unlock_sock(meta_sk);
 
 		clear_bit(TSQ_QUEUED, &tp->tsq_flags);
 		sk_free(sk);
@@ -767,6 +770,9 @@ static void mptcp_release_cb(struct sock *meta_sk)
 		nflags = flags & ~TCP_DEFERRED_ALL;
 	} while (cmpxchg(&meta_tp->tsq_flags, flags, nflags) != flags);
 
+	if (flags & (1UL << TCP_TSQ_DEFERRED))
+		tcp_tsq_handler(meta_sk);
+
 	if (flags & (1UL << TCP_WRITE_TIMER_DEFERRED))
 		__sock_put(meta_sk);
 	if (flags & (1UL << TCP_DELACK_TIMER_DEFERRED))
diff --git a/net/mptcp/mptcp_ctrl.c b/net/mptcp/mptcp_ctrl.c
index 19ab5bd..1806e84 100644
--- a/net/mptcp/mptcp_ctrl.c
+++ b/net/mptcp/mptcp_ctrl.c
@@ -776,6 +776,7 @@ int mptcp_alloc_mpcb(struct sock *meta_sk, __u64 remote_key, u32 window)
 	skb_queue_head_init(&mpcb->reinject_queue);
 	skb_queue_head_init(&master_tp->out_of_order_queue);
 	tcp_prequeue_init(master_tp);
+	INIT_LIST_HEAD(&master_tp->tsq_node);
 
 	master_tp->tsq_flags = 0;
 
diff --git a/net/mptcp/mptcp_output.c b/net/mptcp/mptcp_output.c
index 2fa879f..506e4f3 100644
--- a/net/mptcp/mptcp_output.c
+++ b/net/mptcp/mptcp_output.c
@@ -1162,6 +1162,15 @@ retry:
 			}
 		}
 
+		/* TSQ : sk_wmem_alloc accounts skb truesize,
+		 * including skb overhead. But thats OK.
+		 */
+		if (atomic_read(&subsk->sk_wmem_alloc) >= sysctl_tcp_limit_output_bytes) {
+			set_bit(TSQ_THROTTLED, &subtp->tsq_flags);
+			mpcb->noneligible |= mptcp_pi_to_flag(subtp->mptcp->path_index);
+			continue;
+		}
+
 		limit = mss_now;
 		if (tso_segs > 1 && !tcp_urg_mode(meta_tp))
 			limit = tcp_mss_split_point(subsk, skb, mss_now,
-- 
1.8.1.2

