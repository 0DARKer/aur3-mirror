commit bfa6b92c73c5f6231babb303ef6bb58e80367386
Author: Simon Farnsworth <simon.farnsworth@onelan.co.uk>
Date:   Mon Jan 17 17:38:23 2011 +0000

    Fix textured video when destination is larger than screen
    
    In our application, the screen is never rotated from the point of view
    of the driver; instead, the compositor applies a suitable rotation as
    it composites the display. This works fine on 945, but on 965, videos
    are limited in height to the actual height of the screen.
    
    Change various bits of code so that we use the width and height of the
    destination pixmap instead of the width and height of the virtual
    screen. This works correctly both for XVideo to offscreen storage
    (CompositeRedirect) and for XVideo to the screen (no compositor).
    (cherry picked from commit 3a2a4b0784f0fc96a5457b18931471f15ad745fc)

commit 6b1edd373d895bd9cfd348ecd68aabef0a8ce4ae
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Wed Jan 19 15:25:06 2011 +0000

    Correct offset of planes within clipped window
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=24767
    Reported-and-tested-by: Sitsofe Wheeler <sitsofe@yahoo.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 4c4ad555564a80311df1a4b762eb1e119c6d95fb)

commit 5c1f4eb5aa65a6a37bccd9c3df653c497aea1e98
Author: Xiang, Haihao <haihao.xiang@intel.com>
Date:   Fri Jan 21 08:45:52 2011 +0800

    Fix an error in 4c4ad555564a80311df1a4b762eb1e119c6d95fb.
    
    See the original patch at https://bugs.freedesktop.org/show_bug.cgi?id=24767
    
    Signed-off-by: Xiang, Haihao <haihao.xiang@intel.com>
    (cherry picked from commit 5baa63c634990810a66c3150b4f2b76fcee2df38)

commit 7e08d60023d5414c2f8175d77fb8a7e5ae0306ee
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Mon Jan 31 20:27:26 2011 +0000

    Rename 'intel' backlight to match upstream name in 2.6.38
    
    (Just waiting for libbacklight to bring sanity...)
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit ce1e0969058f8c70b624bc85bb8d6698a35794d3)

commit 7b4c691f3da8b38e14a1ea26ff6d3ab55d446aaf
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 3 09:41:48 2011 +0000

    uxa: Undo damage translation before appending
    
    The region is used to paint onto the backing pixmap (and thus
    translated) prior to being passed to the damage layer (wrt to the
    drawable). So the local translation needs to be undone first.
    
    Identified by Christopher James Halse Rogers.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=33650
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit da990536eca09c6de74627541cd56ecfad925eda)

commit 7016048e2858475e6f1d3b4895f045e85f197c1a
Author: Bryce Harrington <bryce@canonical.com>
Date:   Fri Feb 4 00:15:13 2011 -0800

    Check return value of uxa_acquire_solid() since it can return NULL
    
    uxa_acquire_solid returns NULL under OOM.  Thus the value of solid
    must be checked before dereferencing it in the uxa_get_offscreen()
    call.
    
    Signed-off-by: Bryce Harrington <bryce@canonical.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 6e721e098b9181e8e77e314f966729d28e705582)

commit 811b2c7b40dd135601504d3b6aaf52fbd20e17ff
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Sat Feb 12 10:42:34 2011 +0000

    i965: Remove broken maximum base addresses from video
    
    WRONG.
    
    The hardware was never limited to 0x1000000 and the kernel can quite
    rightly place objects above that limit. Specifying such had no relation
    to reality, so why did we do it? TWICE!
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=34017
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 23f9b14df7c102c1036134835dd5d1a508059858)

commit 1ccafee518f71ceb60dd4990e77d6df2cd2c787a
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Thu Feb 17 16:48:24 2011 +0000

    uxa: Fallback if the temporary is too large
    
    If the render operation requires a temporary source Picture and the
    operation is large, larger than the maximum permitted bo, then we will
    fail to allocate the bo. In this case, we need to fallback and perform
    the operation on the CPU rather than dereference a NULL bo.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=34399
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 4c66b28870b050493ad96f7b0fe2d70d7ee539c7)

commit f2b19c1305913c9f5dda74d1421031642489777d
Author: Bryce Harrington <bryce@canonical.com>
Date:   Tue Feb 15 22:30:18 2011 -0800

    Quell excessively verbose vblank counter failed error messages
    
    Certain error situations can result in the following printed to
    Xorg.0.log at a high enough rate to make log file size a problem.
    
    (WW) intel(0): I830DRI2GetMSC:1062 get vblank counter failed: Invalid argument
    (WW) intel(0): I830DRI2ScheduleWaitMSC:1118 get vblank counter failed: Invalid argument
    
    Following in the tradition of commit 0ad6d6e1, limit the warnings to be
    output 5 times, then quell the remainder.
    
    Bugzilla: https://bugs.freedesktop.org/show_bug.cgi?id=34322
    Ref.: https://bugs.launchpad.net/ubuntu/+source/xserver-xorg-video-intel/+bug/710594
    
    Signed-off-by: Bryce Harrington <bryce@canonical.com>
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
    (cherry picked from commit 9599fde65a0d8b7e7c85199346f7b620bdd8388d)

diff --git a/src/i965_video.c b/src/i965_video.c
index 235dfb9..e16a575 100644
--- a/src/i965_video.c
+++ b/src/i965_video.c
@@ -414,8 +414,8 @@ static void i965_create_dst_surface_state(ScrnInfoPtr scrn,
 	    intel_emit_reloc(surf_bo, offset + offsetof(struct brw_surface_state, ss1),
 			     pixmap_bo, 0, I915_GEM_DOMAIN_SAMPLER, 0);
 
-	dest_surf_state->ss2.height = scrn->virtualY - 1;
-	dest_surf_state->ss2.width = scrn->virtualX - 1;
+	dest_surf_state->ss2.height = pixmap->drawable.height - 1;
+	dest_surf_state->ss2.width = pixmap->drawable.width - 1;
 	dest_surf_state->ss2.mip_count = 0;
 	dest_surf_state->ss2.render_target_rotation = 0;
 	dest_surf_state->ss3.pitch = intel_pixmap_pitch(pixmap) - 1;
@@ -770,7 +770,7 @@ static drm_intel_bo *i965_create_cc_state(ScrnInfoPtr scrn)
 }
 
 static void
-i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_table_bo, int n_src_surf)
+i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_table_bo, int n_src_surf, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	int urb_vs_start, urb_vs_size;
@@ -821,20 +821,20 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_tab
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Instruction base address */
 		/* general state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* media object state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* Instruction max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 	} else {
 		OUT_BATCH(BRW_STATE_BASE_ADDRESS | 4);
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* Generate state base address */
 		OUT_RELOC(surface_state_binding_table_bo, I915_GEM_DOMAIN_INSTRUCTION, 0, BASE_ADDRESS_MODIFY); /* Surface state base address */
 		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);	/* media base addr, don't care */
 		/* general state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 		/* media object state max addr, disabled */
-		OUT_BATCH(0x10000000 | BASE_ADDRESS_MODIFY);
+		OUT_BATCH(0 | BASE_ADDRESS_MODIFY);
 	}
 
 	/* Set system instruction pointer */
@@ -877,7 +877,7 @@ i965_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo * surface_state_binding_tab
 	 */
 	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);	/* XXX 3 for BLC or CTG */
 	OUT_BATCH(0x00000000);	/* ymin, xmin */
-	OUT_BATCH((scrn->virtualX - 1) | (scrn->virtualY - 1) << 16);	/* ymax, xmax */
+	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
 	OUT_BATCH(0x00000000);	/* yorigin, xorigin */
 
 	/* skip the depth buffer */
@@ -1212,7 +1212,7 @@ I965DisplayVideoTextured(ScrnInfoPtr scrn,
 
 		intel_batch_start_atomic(scrn, 100);
 
-		i965_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf);
+		i965_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap);
 
 		/* Set up the pointer to our vertex buffer */
 		OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | 3);
@@ -1517,13 +1517,13 @@ gen6_upload_depth_buffer_state(ScrnInfoPtr scrn)
 }
 
 static void
-gen6_upload_drawing_rectangle(ScrnInfoPtr scrn)
+gen6_upload_drawing_rectangle(ScrnInfoPtr scrn, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 
 	OUT_BATCH(BRW_3DSTATE_DRAWING_RECTANGLE | 2);
 	OUT_BATCH(0x00000000);	/* ymin, xmin */
-	OUT_BATCH((scrn->virtualX - 1) | (scrn->virtualY - 1) << 16);	/* ymax, xmax */
+	OUT_BATCH((pixmap->drawable.width - 1) | (pixmap->drawable.height - 1) << 16);	/* ymax, xmax */
 	OUT_BATCH(0x00000000);	/* yorigin, xorigin */
 }
 
@@ -1673,7 +1673,7 @@ gen6_upload_vertex_element_state(ScrnInfoPtr scrn)
 }
 
 static void
-gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_table_bo, int n_src_surf)
+gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_table_bo, int n_src_surf, PixmapPtr pixmap)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 
@@ -1694,7 +1694,7 @@ gen6_emit_video_setup(ScrnInfoPtr scrn, drm_intel_bo *surface_state_binding_tabl
 	gen6_upload_wm_state(scrn, n_src_surf == 1 ? TRUE : FALSE);
 	gen6_upload_binding_table(scrn, (n_src_surf + 1) * ALIGN(sizeof(struct brw_surface_state), 32));;
 	gen6_upload_depth_buffer_state(scrn);
-	gen6_upload_drawing_rectangle(scrn);
+	gen6_upload_drawing_rectangle(scrn, pixmap);
 	gen6_upload_vertex_element_state(scrn);
 }
 
@@ -1853,7 +1853,7 @@ void Gen6DisplayVideoTextured(ScrnInfoPtr scrn,
 			intel_batch_submit(scrn, FALSE);
 
 		intel_batch_start_atomic(scrn, 200);
-		gen6_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf);
+		gen6_emit_video_setup(scrn, surface_state_binding_table_bo, n_src_surf, pixmap);
 
 		/* Set up the pointer to our vertex buffer */
 		OUT_BATCH(BRW_3DSTATE_VERTEX_BUFFERS | (5 - 2));
diff --git a/src/intel_display.c b/src/intel_display.c
index 1198013..a8564b2 100644
--- a/src/intel_display.c
+++ b/src/intel_display.c
@@ -118,7 +118,6 @@ intel_output_dpms_backlight(xf86OutputPtr output, int oldmode, int mode);
  * List of available kernel interfaces in priority order
  */
 static const char *backlight_interfaces[] = {
-	"intel", /* prefer our own native backlight driver */
 	"asus-laptop",
 	"eeepc",
 	"thinkpad_screen",
@@ -128,6 +127,7 @@ static const char *backlight_interfaces[] = {
 	"samsung",
 	"acpi_video1", /* finally fallback to the generic acpi drivers */
 	"acpi_video0",
+	"intel_backlight",
 	NULL,
 };
 /*
diff --git a/src/intel_dri.c b/src/intel_dri.c
index 7b60e14..65c8f39 100644
--- a/src/intel_dri.c
+++ b/src/intel_dri.c
@@ -1057,10 +1057,14 @@ I830DRI2GetMSC(DrawablePtr draw, CARD64 *ust, CARD64 *msc)
 
 	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
 	if (ret) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s:%d get vblank counter failed: %s\n",
-			   __FUNCTION__, __LINE__,
-			   strerror(errno));
+		static int limit = 5;
+		if (limit) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+				   "%s:%d get vblank counter failed: %s\n",
+				   __FUNCTION__, __LINE__,
+				   strerror(errno));
+			limit--;
+		}
 		return FALSE;
 	}
 
@@ -1113,10 +1117,14 @@ I830DRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr draw, CARD64 target_msc,
 	vbl.request.sequence = 0;
 	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
 	if (ret) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s:%d get vblank counter failed: %s\n",
-			   __FUNCTION__, __LINE__,
-			   strerror(errno));
+		static int limit = 5;
+		if (limit) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+				   "%s:%d get vblank counter failed: %s\n",
+				   __FUNCTION__, __LINE__,
+				   strerror(errno));
+			limit--;
+		}
 		goto out_complete;
 	}
 
@@ -1143,10 +1151,14 @@ I830DRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr draw, CARD64 target_msc,
 		vbl.request.signal = (unsigned long)wait_info;
 		ret = drmWaitVBlank(intel->drmSubFD, &vbl);
 		if (ret) {
-			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-				   "%s:%d get vblank counter failed: %s\n",
-				   __FUNCTION__, __LINE__,
-				   strerror(errno));
+			static int limit = 5;
+			if (limit) {
+				xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+					   "%s:%d get vblank counter failed: %s\n",
+					   __FUNCTION__, __LINE__,
+					   strerror(errno));
+				limit--;
+			}
 			goto out_complete;
 		}
 
@@ -1178,10 +1190,14 @@ I830DRI2ScheduleWaitMSC(ClientPtr client, DrawablePtr draw, CARD64 target_msc,
 	vbl.request.signal = (unsigned long)wait_info;
 	ret = drmWaitVBlank(intel->drmSubFD, &vbl);
 	if (ret) {
-		xf86DrvMsg(scrn->scrnIndex, X_WARNING,
-			   "%s:%d get vblank counter failed: %s\n",
-			   __FUNCTION__, __LINE__,
-			   strerror(errno));
+		static int limit = 5;
+		if (limit) {
+			xf86DrvMsg(scrn->scrnIndex, X_WARNING,
+				   "%s:%d get vblank counter failed: %s\n",
+				   __FUNCTION__, __LINE__,
+				   strerror(errno));
+			limit--;
+		}
 		goto out_complete;
 	}
 
diff --git a/src/intel_video.c b/src/intel_video.c
index 2786201..5294f73 100644
--- a/src/intel_video.c
+++ b/src/intel_video.c
@@ -996,7 +996,7 @@ I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
 	/* Copy V data for YV12, or U data for I420 */
 	src2 = buf +		/* start of YUV data */
 	    (srcH * srcPitch) +	/* move over Luma plane */
-	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
+	    ((top >> 1) * srcPitch2) +	/* move down from by top lines */
 	    (left >> 1);	/* move left by left pixels */
 
 #if 0
@@ -1015,7 +1015,7 @@ I830CopyPlanarData(intel_adaptor_private *adaptor_priv,
 	src3 = buf +		/* start of YUV data */
 	    (srcH * srcPitch) +	/* move over Luma plane */
 	    ((srcH >> 1) * srcPitch2) +	/* move over Chroma plane */
-	    ((top * srcPitch) >> 2) +	/* move down from by top lines */
+	    ((top >> 1) * srcPitch2) +	/* move down from by top lines */
 	    (left >> 1);	/* move left by left pixels */
 #if 0
 	ErrorF("src3 is %p, offset is %ld\n", src3,
diff --git a/uxa/uxa-accel.c b/uxa/uxa-accel.c
index a5066c8..0650ac2 100644
--- a/uxa/uxa-accel.c
+++ b/uxa/uxa-accel.c
@@ -120,6 +120,10 @@ uxa_fill_spans(DrawablePtr pDrawable, GCPtr pGC, int n,
 
 		solid = uxa_acquire_solid(screen, src->pSourcePict);
 		FreePicture(src, 0);
+		if (!solid) {
+			FreePicture(dst, 0);
+			goto solid;
+		}
 
 		src = solid;
 		src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
@@ -1110,6 +1114,10 @@ try_solid:
 
 			solid = uxa_acquire_solid(screen, src->pSourcePict);
 			FreePicture(src, 0);
+			if (!solid) {
+				FreePicture(dst, 0);
+				goto err;
+			}
 
 			src = solid;
 			src_pixmap = uxa_get_offscreen_pixmap(src->pDrawable,
diff --git a/uxa/uxa-render.c b/uxa/uxa-render.c
index cf8b8ea..b26be80 100644
--- a/uxa/uxa-render.c
+++ b/uxa/uxa-render.c
@@ -460,12 +460,12 @@ uxa_try_driver_solid_fill(PicturePtr pSrc,
 }
 
 static PicturePtr
-uxa_picture_for_pixman_format(ScreenPtr pScreen,
+uxa_picture_for_pixman_format(ScreenPtr screen,
 			      pixman_format_code_t format,
 			      int width, int height)
 {
-	PicturePtr pPicture;
-	PixmapPtr pPixmap;
+	PicturePtr picture;
+	PixmapPtr pixmap;
 	int error;
 
 	if (format == PIXMAN_a1)
@@ -475,24 +475,29 @@ uxa_picture_for_pixman_format(ScreenPtr pScreen,
 	if (PIXMAN_FORMAT_A(format) == 0)
 	    format = PIXMAN_a8r8g8b8;
 
-	pPixmap = (*pScreen->CreatePixmap)(pScreen, width, height,
-					   PIXMAN_FORMAT_DEPTH(format),
-					   UXA_CREATE_PIXMAP_FOR_MAP);
-	if (!pPixmap)
+	pixmap = screen->CreatePixmap(screen, width, height,
+					PIXMAN_FORMAT_DEPTH(format),
+					UXA_CREATE_PIXMAP_FOR_MAP);
+	if (!pixmap)
 		return 0;
 
-	pPicture = CreatePicture(0, &pPixmap->drawable,
-				 PictureMatchFormat(pScreen,
-						    PIXMAN_FORMAT_DEPTH(format),
-						    format),
-				 0, 0, serverClient, &error);
-	(*pScreen->DestroyPixmap) (pPixmap);
-	if (!pPicture)
+	if (!uxa_pixmap_is_offscreen(pixmap)) {
+		screen->DestroyPixmap(pixmap);
 		return 0;
+	}
 
-	ValidatePicture(pPicture);
+	picture = CreatePicture(0, &pixmap->drawable,
+				PictureMatchFormat(screen,
+						   PIXMAN_FORMAT_DEPTH(format),
+						   format),
+				0, 0, serverClient, &error);
+	screen->DestroyPixmap(pixmap);
+	if (!picture)
+		return 0;
 
-	return pPicture;
+	ValidatePicture(picture);
+
+	return picture;
 }
 
 static PicturePtr
@@ -1061,6 +1066,8 @@ try_solid:
 			int src_off_x, src_off_y;
 
 			solid = uxa_acquire_solid(screen, src->pSourcePict);
+			if (!solid)
+				goto err_src;
 			FreePicture(src, 0);
 
 			src = solid;
@@ -1090,6 +1097,7 @@ try_solid:
 	/* XXX xserver-1.8: CompositeRects is not tracked by Damage, so we must
 	 * manually append the damaged regions ourselves.
 	 */
+	pixman_region_translate(&region, -dst_x, -dst_y);
 	DamageRegionAppend(dst->pDrawable, &region);
 
 	pixman_region_fini(&region);
