diff -c -r -N xplico-1.0.1-original/dissectors/ip/ip.c xplico-1.0.1/dissectors/ip/ip.c
*** xplico-1.0.1-original/dissectors/ip/ip.c	2012-09-16 07:36:53.000000000 -0400
--- xplico-1.0.1/dissectors/ip/ip.c	2012-10-16 15:41:27.000000000 -0400
***************
*** 303,308 ****
--- 303,311 ----
      dep.type = FT_UINT16;
      dep.val.uint16 = DLT_RAW;
      ProtDep(&dep);
+ #ifndef DLT_IPV4
+ # define DLT_IPV4 228
+ #endif
      dep.val.uint16 = DLT_IPV4;
      ProtDep(&dep);
      
diff -c -r -N xplico-1.0.1-original/dissectors/ip/ip.c.orig xplico-1.0.1/dissectors/ip/ip.c.orig
*** xplico-1.0.1-original/dissectors/ip/ip.c.orig	1969-12-31 19:00:00.000000000 -0500
--- xplico-1.0.1/dissectors/ip/ip.c.orig	2012-09-16 07:36:53.000000000 -0400
***************
*** 0 ****
--- 1,353 ----
+ /* ip.c
+  * IP dissector
+  *
+  * $Id:  $
+  *
+  * Xplico - Internet Traffic Decoder
+  * By Gianluca Costa <g.costa@xplico.org>
+  * Copyright 2007-2011 Gianluca Costa & Andrea de Franceschi. Web: www.xplico.org
+  *
+  *
+  * This program is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU General Public License
+  * as published by the Free Software Foundation; either version 2
+  * of the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+  */
+ 
+ #include <pcap.h>
+ #include <netinet/ip.h>
+ #include <arpa/inet.h>
+ #include <string.h>
+ 
+ #include "proto.h"
+ #include "dmemory.h"
+ #include "etypes.h"
+ #include "ppptypes.h"
+ #include "in_cksum.h"
+ #include "log.h"
+ #include "embedded.h"
+ #include "configs.h"
+ 
+ #define GTP_MSG_TPDU                0xFF
+ 
+ /* info id */
+ static int iphdr_len;
+ static int prot_id;
+ static int ipv6_id;
+ static int proto_id;
+ static int src_id;
+ static int dst_id;
+ static int offset_id;
+ #if SNIFFER_EVASION
+ static int ttl_id;
+ static int id_id;
+ #endif
+ 
+ #ifdef XPL_X86
+ /*
+  *	This is a version of ip_compute_csum() optimized for IP headers,
+  *	which always checksum on 4 octet boundaries.
+  *
+  *	By Jorge Cwik <jorge@laser.satlink.net>, adapted for linux by
+  *	Arnt Gulbrandsen.
+  */
+ static inline unsigned short ip_fast_csum(unsigned char * iph,
+ 					  unsigned int ihl)
+ {
+ 	unsigned int sum;
+ 
+ 	__asm__ __volatile__(
+ 	    "movl (%1), %0	;\n"
+ 	    "subl $4, %2	;\n"
+ 	    "jbe 2f		;\n"
+ 	    "addl 4(%1), %0	;\n"
+ 	    "adcl 8(%1), %0	;\n"
+ 	    "adcl 12(%1), %0	;\n"
+ "1:	    adcl 16(%1), %0	;\n"
+ 	    "lea 4(%1), %1	;\n"
+ 	    "decl %2		;\n"
+ 	    "jne 1b		;\n"
+ 	    "adcl $0, %0	;\n"
+ 	    "movl %0, %2	;\n"
+ 	    "shrl $16, %0	;\n"
+ 	    "addw %w2, %w0	;\n"
+ 	    "adcl $0, %0	;\n"
+ 	    "notl %0		;\n"
+ "2:				;\n"
+ 	/* Since the input registers which are loaded with iph and ihl
+ 	   are modified, we must also specify them as outputs, or gcc
+ 	   will assume they contain their original values. */
+ 	: "=r" (sum), "=r" (iph), "=r" (ihl)
+ 	: "1" (iph), "2" (ihl)
+ 	: "memory");
+ 	return(sum);
+ }
+ #else
+ 
+ static inline unsigned short ip_fast_csum(unsigned char *iph, unsigned int ihl)
+ {
+     vec_t cksum_vec[1];
+     
+     cksum_vec[0].ptr = iph;
+     cksum_vec[0].len = ihl << 2;
+     return in_cksum(&cksum_vec[0], 1);
+ }
+ 
+ #endif /* XPL_X86 */
+ 
+ 
+ static packet* IpDissector(packet *pkt)
+ {
+     pstack_f *frame;
+     ftval val;
+     struct iphdr *ip;
+     unsigned short checksum_v;
+     size_t iphdr_len;
+     size_t ip_len;
+ 
+     if (sizeof(struct iphdr) > pkt->len) {
+         LogPrintf(LV_WARNING, "IP hedear packet dimension overflow the real dimension of packet");
+         ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+ 
+     ip = (struct iphdr *)pkt->data;
+     /* IPv- or IPv4 */
+     if (ip->version != 4) {
+         if (ip->version == 6 && ipv6_id != -1)
+             return ProtDissecPkt(ipv6_id, pkt);
+ 
+         LogPrintf(LV_WARNING, "IP verision %i without dissector", ip->version);
+         ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+     /* IPv4 */
+     iphdr_len = ip->ihl << 2;
+     ip_len = ntohs(ip->tot_len);
+ 
+     /* check consistence and checksum */
+     if (ip_len > pkt->len) {
+         //LogPrintf(LV_WARNING, "IP packet dimension overflow the real dimension of packet (%i>%i)", ip_len, pkt->len);
+         LogPrintf(LV_WARNING, "IP packet dimension overflow the real dimension of packet");
+         ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+ 
+ #if (XPL_DIS_IP_CHECKSUM == 0)
+     if (ip_len <= iphdr_len) {
+         LogPrintf(LV_WARNING, "Bogus IP length (%i, less than header length 20)", ip_len);
+         ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+     checksum_v = ip_fast_csum((unsigned char *)ip, ip->ihl);
+     if (checksum_v != 0) {
+         LogPrintf(LV_WARNING, "IP packet chechsum error (0x%x != 0x%x)", checksum_v, ip->check);
+         //ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+ #else 
+     if (ip_len <= iphdr_len) {
+         ip_len = pkt->len;
+     }
+ #endif
+     
+     /* fragment ip */
+     if (ip->frag_off != 0 && ip->frag_off != 0x40) {
+ #warning only commercial version has ipv4 defragmentation!
+         LogPrintf(LV_WARNING, "IP packet fragment contact g.costa@xplico.org");
+         ProtStackFrmDisp(pkt->stk, TRUE);
+         PktFree(pkt);
+         return NULL;
+     }
+ 
+     /* new frame */
+     frame = ProtCreateFrame(prot_id);
+     ProtSetNxtFrame(frame, pkt->stk);
+     pkt->stk = frame;
+ 
+     /* set attribute */
+     val.uint8 = ip->protocol;
+     ProtInsAttr(frame, proto_id, &val);
+ #ifdef XPL_X86
+     val.uint32 = ip->saddr;
+ #else
+     val.uint32 = Emb32(&ip->saddr);
+ #endif
+     ProtInsAttr(frame, src_id, &val);
+ #ifdef XPL_X86
+     val.uint32 = ip->daddr;
+ #else
+     val.uint32 = Emb32(&ip->daddr);
+ #endif
+     ProtInsAttr(frame, dst_id, &val);
+     if (pkt->raw != NULL)
+         val.uint32 = (pkt->data - pkt->raw);
+     else
+         val.uint32 = 0;
+     ProtInsAttr(frame, offset_id, &val);
+ #if SNIFFER_EVASION
+     val.uint8 = ip->ttl;
+     ProtInsAttr(frame, ttl_id, &val);
+     val.uint16 = ntohs(ip->id);
+     ProtInsAttr(frame, id_id, &val);
+ #endif
+ 
+     /* pdu */
+     pkt->data += iphdr_len;
+     pkt->len = ip_len - iphdr_len;
+ 
+     return pkt;
+ }
+ 
+ 
+ int DissecRegist(const char *file_cfg)
+ {
+     proto_info info;
+     proto_dep dep;
+ 
+     memset(&info, 0, sizeof(proto_info));
+     memset(&dep, 0, sizeof(proto_dep));
+ 
+     /* protocol name */
+     ProtName("Internet Protocol", "ip");
+     
+     /* protocol */
+     info.name = "Protocol";
+     info.abbrev = "ip.proto";
+     info.type = FT_UINT8;
+     proto_id = ProtInfo(&info);
+ 
+     /* source */
+     info.name = "Source";
+     info.abbrev = "ip.src";
+     info.type = FT_IPv4;
+     src_id = ProtInfo(&info);
+ 
+     /* destination */
+     info.name = "Destination";
+     info.abbrev = "ip.dst";
+     info.type = FT_IPv4;
+     dst_id = ProtInfo(&info);
+ 
+     /* packet offset */
+     info.name = "Packet Offset";
+     info.abbrev = "ip.offset";
+     info.type = FT_UINT32;
+     offset_id = ProtInfo(&info);
+ 
+ #if SNIFFER_EVASION
+     /* time to live */
+     info.name = "Time To Live";
+     info.abbrev = "ip.ttl";
+     info.type = FT_UINT8;
+     ttl_id = ProtInfo(&info);
+ 
+     /* identification */
+     info.name = "Identification";
+     info.abbrev = "ip.id";
+     info.type = FT_UINT16;
+     id_id = ProtInfo(&info);
+ #endif
+ 
+     /* ethernet dependence */
+     dep.name = "eth";
+     dep.attr = "eth.type";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* llc dependence */
+     dep.name = "llc";
+     dep.attr = "llc.type";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* sll dependence */
+     dep.name = "sll";
+     dep.attr = "sll.protocol";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* ppp dependence */
+     dep.name = "ppp";
+     dep.attr = "ppp.protocol";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = PPP_IP;
+     ProtDep(&dep);
+ 
+     dep.name = "ppp";
+     dep.attr = "ppp.protocol";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* pcapf dependence */
+     dep.name = "pcapf";
+     dep.attr = "pcapf.layer1";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = DLT_RAW;
+     ProtDep(&dep);
+     dep.val.uint16 = DLT_IPV4;
+     ProtDep(&dep);
+     
+     /* pol dependence */
+     dep.name = "pol";
+     dep.attr = "pol.layer1";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = DLT_RAW;
+     ProtDep(&dep);
+     dep.val.uint16 = DLT_IPV4;
+     ProtDep(&dep);
+ 
+     /* vlan dependence */
+     dep.name = "vlan";
+     dep.attr = "vlan.type";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* chdlc dependence */
+     dep.name = "chdlc";
+     dep.attr = "chdlc.protocol";
+     dep.type = FT_UINT16;
+     dep.val.uint16 = ETHERTYPE_IP;
+     ProtDep(&dep);
+ 
+     /* GTP dependence */
+     dep.name = "gtp";
+     dep.attr = "gtp.msg";
+     dep.type = FT_UINT8;
+     dep.val.uint8 = GTP_MSG_TPDU;
+     ProtDep(&dep);
+     
+     /* dissectors registration */
+     ProtDissectors(IpDissector, NULL, NULL, NULL);
+ 
+     return 0;
+ }
+ 
+ 
+ int DissectInit(void)
+ {
+     prot_id = ProtId("ip");
+     iphdr_len = sizeof(struct iphdr);
+     ipv6_id = ProtId("ipv6");
+     
+     return 0;
+ }
diff -c -r -N xplico-1.0.1-original/dissectors/ipv6/ipv6.c xplico-1.0.1/dissectors/ipv6/ipv6.c
*** xplico-1.0.1-original/dissectors/ipv6/ipv6.c	2011-11-13 05:40:28.000000000 -0500
--- xplico-1.0.1/dissectors/ipv6/ipv6.c	2012-10-16 15:41:27.000000000 -0400
***************
*** 208,213 ****
--- 208,216 ----
      dep.name = "pcapf";
      dep.attr = "pcapf.layer1";
      dep.type = FT_UINT16;
+ #ifndef DLT_IPV6
+ # define DLT_IPV6 229
+ #endif
      dep.val.uint16 = DLT_IPV6;
      ProtDep(&dep);
      
diff -c -r -N xplico-1.0.1-original/dissectors/tcp_grbg/Makefile xplico-1.0.1/dissectors/tcp_grbg/Makefile
*** xplico-1.0.1-original/dissectors/tcp_grbg/Makefile	2012-04-14 10:58:37.000000000 -0400
--- xplico-1.0.1/dissectors/tcp_grbg/Makefile	2012-10-16 15:55:40.000000000 -0400
***************
*** 36,45 ****
  SRC = dis_log.c tcp_garbage.c
  
  # C flags specific to the dissector
! CFLAGS += -I$(ROOT_DIR)/../nDPI/src/include -I$(ROOT_DIR)/../nDPI/src/lib
  
  # library specific to the dissector
! LDFLAGS = $(ROOT_DIR)/../nDPI/src/lib/.libs/libndpi.a
  
  # To make it visible
  export CC CCPP ROOT_DIR CFLAGS LDFLAGS INCLUDE_DIR
--- 36,45 ----
  SRC = dis_log.c tcp_garbage.c
  
  # C flags specific to the dissector
! CFLAGS += -I/usr/include/libndpi
  
  # library specific to the dissector
! LDFLAGS = -lndpi
  
  # To make it visible
  export CC CCPP ROOT_DIR CFLAGS LDFLAGS INCLUDE_DIR
diff -c -r -N xplico-1.0.1-original/dissectors/udp_grbg/Makefile xplico-1.0.1/dissectors/udp_grbg/Makefile
*** xplico-1.0.1-original/dissectors/udp_grbg/Makefile	2012-04-14 11:05:37.000000000 -0400
--- xplico-1.0.1/dissectors/udp_grbg/Makefile	2012-10-16 16:06:39.000000000 -0400
***************
*** 36,45 ****
  SRC = dis_log.c udp_garbage.c
  
  # C flags specific to the dissector
! CFLAGS += -I$(ROOT_DIR)/../nDPI/src/include -I$(ROOT_DIR)/../nDPI/src/lib
  
  # library specific to the dissector
! LDFLAGS = $(ROOT_DIR)/../nDPI/src/lib/.libs/libndpi.a
  
  # To make it visible
  export CC CCPP ROOT_DIR CFLAGS LDFLAGS INCLUDE_DIR
--- 36,45 ----
  SRC = dis_log.c udp_garbage.c
  
  # C flags specific to the dissector
! CFLAGS += -I/usr/include/libndpi
  
  # library specific to the dissector
! LDFLAGS = -lndpi
  
  # To make it visible
  export CC CCPP ROOT_DIR CFLAGS LDFLAGS INCLUDE_DIR
diff -c -r -N xplico-1.0.1-original/httpd/xplico.conf xplico-1.0.1/httpd/xplico.conf
*** xplico-1.0.1-original/httpd/xplico.conf	1969-12-31 19:00:00.000000000 -0500
--- xplico-1.0.1/httpd/xplico.conf	2012-10-16 15:41:27.000000000 -0400
***************
*** 0 ****
--- 1,38 ----
+ NameVirtualHost *:9876
+ Listen 9876
+ 
+ <VirtualHost *:9876>
+ 	DocumentRoot /opt/xplico/xi
+ 	<Directory "/opt/xplico/xi">
+ 		Options All
+ 		AllowOverride All
+ 		Order allow,deny
+ 		allow from all
+ 	</Directory>
+ 
+ 	ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/
+ 	<Directory "/usr/lib/cgi-bin">
+ 		AllowOverride All
+ 		Options +ExecCGI -MultiViews +SymLinksIfOwnerMatch
+ 		Order allow,deny
+ 		Allow from all
+ 	</Directory>
+ 
+ 	ErrorLog /var/log/httpd/xplico_error.log
+ 
+ 	# Possible values include: debug, info, notice, warn, error, crit,
+ 	# alert, emerg.
+ 	LogLevel debug
+ 
+ 	CustomLog /var/log/httpd/xplico_access.log combined
+ 
+ #    Alias /doc/ "/usr/share/doc/"
+ #    <Directory "/usr/share/doc/">
+ #        Options Indexes MultiViews FollowSymLinks
+ #        AllowOverride All
+ #        Order deny,allow
+ #        Deny from all
+ #        Allow from 127.0.0.0/255.0.0.0 ::1/128
+ #    </Directory>
+ 
+ </VirtualHost>
diff -c -r -N xplico-1.0.1-original/init.d/xplico xplico-1.0.1/init.d/xplico
*** xplico-1.0.1-original/init.d/xplico	1969-12-31 19:00:00.000000000 -0500
--- xplico-1.0.1/init.d/xplico	2012-10-16 15:41:27.000000000 -0400
***************
*** 0 ****
--- 1,227 ----
+ #!/bin/sh
+ #
+ # /etc/init.d/xplico.offline  --  start/stop the Xplico-offline-mode daemon.Xplico will decode the capture you upload to its web interface (default http://localhost:9876)
+ # 
+ # chkconfig: - 86 14
+ ### BEGIN INIT INFO
+ # Provides:          Xplico
+ # Required-Start:    $syslog $network httpd
+ # Required-Stop:     $syslog
+ # Should-Start:      $local_fs
+ # Should-Stop:       $local_fs
+ # Short-Description: Starts and stops the xplico.offline  daemon
+ ### END INIT INFO
+ 
+ PATH=/bin:/usr/bin:/sbin:/usr/sbin
+ 
+ [ -f /etc/rc.d/init.d/functions ] || exit 0
+ . /etc/rc.d/init.d/functions
+ 
+ # CHMOD && CHOWN (FIX)
+ chmod 777 /opt/xplico
+ chmod 777 /opt/xplico/xplico.db
+ chown -R apache:apache /opt/xplico/xi
+ 
+ NAME="Xplico"
+ DAEMON=/opt/xplico/bin/dema
+ #APPLICATION=/opt/xplico/bin/dema
+ PIDFILE=/var/run/dema.pid
+ HTTPDPIDFILE=/var/run/httpd/httpd.pid
+ DESC=""
+ RUN_DAEMON=yes
+ PRIORITY=1 #(0..20)
+   #0: don't change priority
+   #1: better priority
+   #...
+   #20: highest priority, not recommended.
+ 
+ 
+ #INTERFACE=eth1
+ #CONFIG_FILE="/opt/xplico/cfg/xplico.cfg"
+ #MODE=pcap
+ #PATH_DECODED_FILES="/opt/xplico/bin/"
+ 
+ #DAEMON_ARGS="-c $CONFIG_FILE -m $MODE -i $INTERFACE"
+ #DAEMON_ARGS=""
+ 
+ BINFMT=/proc/sys/fs/binfmt_misc
+ BINFMT_REGISTER=$BINFMT/register
+ PYTHON31=/usr/bin/python3.1
+ BINFMT_PYTHON31=$BINFMT/xplico_python31
+ PYTHON32=/usr/bin/python3.2
+ BINFMT_PYTHON32=$BINFMT/xplico_python32
+ 
+ unset LANG
+ trap "" 1 15
+ 
+ test -x $DAEMON || exit 0
+ run_xoffline="1"
+ 
+ 
+ 
+ if [ "x$RUN_DAEMON" = "xno" ]; then
+     run_xoffline=0
+ fi
+ 
+ 
+ is_running() 
+ {
+ 	if [ -f "$PIDFILE" ]; then
+ 		status -p $PIDFILE  > /dev/null
+ 		running=$?
+ 	else
+ 		running=1
+ 	fi
+ 	return $running
+ }
+ 
+ 
+ is_httpd_running() 
+ {
+ 
+ 	let I=10
+ 	while [ $I -gt 0 ]
+ 	do
+ 		PIDS=`pidof httpd` || true  # Array of httpd forks.
+ 		[ -e $HTTPDPIDFILE ] && PIDS2=`cat $HTTPDPIDFILE` #Last httpd pid known.
+ 		# if there is a pid we need to verify that belongs to httpd 
+ 		for i in $PIDS; do
+ 		  if [ "$i" = "$PIDS2" ]; then
+ 		    # in this case the pid stored in the pidfile matches one of the pidof apache
+ 		    #echo $i
+ 		    return 0
+ 		  fi
+ 		done
+ 		sleep 5
+ 		let I--
+ 	done
+ 	echo "  Error, httpd not running"
+ 	return 1
+ }
+ 
+ # Function that starts the daemon/service
+ do_start()
+ {
+ 	# Return
+ 	#   0 if daemon has been started
+ 	#   1 if daemon was already running
+ 	#   2 if daemon could not be started
+ 
+ 	
+ 
+ 	#Check httpd is up&running
+ 	is_httpd_running || return 2
+ 
+ 	is_running
+ 
+ 	case "$?" in
+ 		0) echo "Xplico was (and is) already running" ;; 
+ 		1) if [ -e "$PYTHON31" ]; then
+ 			  if [ ! -f "$BINFMT_PYTHON31" ]; then
+ 				echo ':'`basename $BINFMT_PYTHON31`':M:0:\x4f\x0c\x0d\x0a::'$PYTHON31':' > $BINFMT_REGISTER
+ 			  else
+ 				echo "Xplico: $PYTHON31 already registered with binfmt"
+ 			  fi
+ 			  FoundPython=1
+ 		  fi
+ 		  if [ -e "$PYTHON32" ]; then
+ 			  if [ ! -f "$BINFMT_PYTHON32" ]; then
+ 				echo ':'`basename $BINFMT_PYTHON32`':M:0:\x6c\x0c\x0d\x0a::'$PYTHON32':' > $BINFMT_REGISTER
+ 			  else
+ 				echo "Xplico: $PYTHON32 already registered with binfmt"
+ 			  fi
+ 			  FoundPython=1
+ 		  fi
+ 		  if [ -z "$FoundPython" ]; then
+ 			echo "Xplico cannot be started on this system because neither python3.1 nor python3.2 can be found"
+ 			exit 1
+ 		  else
+ 			# ulimit
+ 			ulimit -n 200000
+ 			ulimit -m unlimited
+ 			#ulimit -u unlimited #this is a value for bash, not sh.
+ 			ulimit -v unlimited
+ 			# kill  : Not necessary here, will use the function  "is_running"
+ 			#killall dema
+ 			# start dema
+ 			(cd /opt/xplico/bin; ./dema -d /opt/xplico -b sqlite > /dev/null) &
+ 			#Optional: let's give more priotity and CPU to xplico, so decoding will be faster.
+ 			  
+ 			if [ "$PRIORITY" -ge "0" ] && [ "$PRIORITY" -le "20" ]; then
+ 			  if [ "$PRIORITY" -ge "1" ]; then 
+ 			    echo Modifying priority to -$PRIORITY
+ 			    sleep 1  #giving time to DEMA to start and write its pid in the PIDFILE
+ 			    renice -$PRIORITY `cat $PIDFILE`  >> /dev/null
+ 			    #else: "PRIORITY is 0, nothing will be done.
+ 			  fi
+ 		        else
+ 			    echo "WARNING: Xplico priority not altered: wrong priority value (check $PRIORITY, range 0..20, default:0)"
+ 		        fi
+ 		  fi
+ 		  ;;
+ 
+ 		*) echo "Error #123" ;; # Failed to start
+ 	esac
+ }
+ 
+ 
+ # Function that stops the daemon/service
+ do_stop()
+ {
+ 	# Return
+ 	#   0 if daemon has been stopped
+ 	#   1 if daemon was already stopped
+ 	#   2 if daemon could not be stopped
+ 	#   other if a failure occurred
+ 	
+ 	killproc -p $PIDFILE 
+ 	RETVAL="$?"
+ 	if [ -f "$BINFMT_PYTHON32" ]; then
+ 		echo -1 > "$BINFMT_PYTHON32"
+ 	fi
+ 	if [ -f "$BINFMT_PYTHON31" ]; then
+ 		echo -1 > "$BINFMT_PYTHON31"
+ 	fi
+ 	return "$RETVAL"
+ }
+ 
+ 
+ if [ "$EUID" -ne 0 ]; then
+   echo "ERROR: Execute this as root"
+   exit 1    
+ fi
+ 
+ 
+ 
+ case "$1" in
+     start)
+         if [ "$run_xoffline" = "1" ]; then
+ 		[ "$VERBOSE" != no ] && echo "Starting $DESC" "$NAME"
+ 		do_start
+         fi
+ 	echo
+         ;;
+     stop)
+        # if [ -f /var/run/xplico.pid ] && kill -0 `cat /var/run/xplico.pid` 2>/dev/null; then
+ 		[ "$VERBOSE" != no ] && echo "Stopping $DESC" "$NAME"
+ 		do_stop
+         # fi
+         ;;
+     restart|force-reload)
+         if [ "$run_xoffline" = "1" ]; then
+ 		echo "Restarting $DESC" "$NAME"
+ 		do_stop
+ 		do_start
+         fi
+         ;;
+     status)
+ 		echo -n xplico; status -p $PIDFILE -l xplico
+ 		RETVAL=$?
+ 	;;				
+     *)
+         echo "Usage: /etc/init.d/xplico.rt {start|stop|restart|force-reload|status}"
+         exit 1
+         ;;
+ esac
+ 
+ exit 0
diff -c -r -N xplico-1.0.1-original/system/xi2/app/controllers/components/xplico.php xplico-1.0.1/system/xi2/app/controllers/components/xplico.php
*** xplico-1.0.1-original/system/xi2/app/controllers/components/xplico.php	2011-11-13 06:14:48.000000000 -0500
--- xplico-1.0.1/system/xi2/app/controllers/components/xplico.php	2012-10-16 15:41:39.000000000 -0400
***************
*** 135,140 ****
--- 135,141 ----
              if ($foca) {
                  $dema_pid = fgets($foca, 200);
                  fclose($foca);
+                 $dema_pid = preg_replace('/\n/', '', $dema_pid);
                  $foca = popen('ps -p '.$dema_pid.' | grep dema', 'r');
                  if ($foca) {
                      while (!feof($foca)) {
