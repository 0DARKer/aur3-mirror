Only in b/: teensy_loader_cli
diff -ur a/teensy_loader_cli.c b/teensy_loader_cli.c
--- a/teensy_loader_cli.c	2013-10-10 23:24:16.000000000 +0200
+++ b/teensy_loader_cli.c	2013-12-25 01:37:06.195744532 +0100
@@ -35,9 +35,10 @@
 
 void usage(void)
 {
-	fprintf(stderr, "Usage: teensy_loader_cli -mmcu=<MCU> [-w] [-h] [-n] [-v] <file.hex>\n");
+	fprintf(stderr, "Usage: teensy_loader_cli -mmcu=<MCU> [-w] [-r] [-s] [-n] [-v] <file.hex>\n");
 	fprintf(stderr, "\t-w : Wait for device to appear\n");
 	fprintf(stderr, "\t-r : Use hard reboot if device not online\n");
+	fprintf(stderr, "\t-s : Try soft reboot if device not online\n");
 	fprintf(stderr, "\t-n : No reboot after programming\n");
 	fprintf(stderr, "\t-v : Verbose output\n");
 #if defined(USE_LIBUSB)
@@ -55,6 +56,7 @@
 int teensy_write(void *buf, int len, double timeout);
 void teensy_close(void);
 int hard_reboot(void);
+int soft_reboot(void);
 
 // Intel Hex File Functions
 int read_intel_hex(const char *filename);
@@ -71,6 +73,7 @@
 // options (from user via command line args)
 int wait_for_device_to_appear = 0;
 int hard_reboot_device = 0;
+int soft_reboot_device = 0;
 int reboot_after_programming = 1;
 int verbose = 0;
 int code_size = 0, block_size = 0;
@@ -117,6 +120,12 @@
 			hard_reboot_device = 0; // only hard reboot once
 			wait_for_device_to_appear = 1;
 		}
+		if (soft_reboot_device) {
+			if (!soft_reboot()) die("Unable to trigger soft reboot\n");
+			printf_verbose("Soft Reboot performed\n");
+			soft_reboot_device = 0; // only soft reboot once
+			wait_for_device_to_appear = 1;
+		}
 		if (!wait_for_device_to_appear) die("Unable to open device\n");
 		if (!waited) {
 			printf_verbose("Waiting for Teensy device...\n");
@@ -300,6 +309,22 @@
 	return 1;
 }
 
+// Limitation: works only in Serial mode and on Teensy 3.x
+int soft_reboot(void)
+{
+	static char data[7] = {0x86, 0, 0, 0, 0, 0, 0x08};
+	usb_dev_handle *serial;
+	int r;
+
+	serial = open_usb_device(0x16C0, 0x0483);
+	if (!serial) return 0;
+	r = usb_control_msg(serial, 0x21, 32, 0, 0, data, sizeof(data), 100);
+	usb_release_interface(serial, 0);
+	usb_close(serial);
+	if (r < 0) return 0;
+	return 1;
+}
+
 #endif
 
 
@@ -971,6 +996,8 @@
 				wait_for_device_to_appear = 1;
 			} else if (strcmp(arg, "-r") == 0) {
 				hard_reboot_device = 1;
+			} else if (strcmp(arg, "-s") == 0) {
+				soft_reboot_device = 1;
 			} else if (strcmp(arg, "-n") == 0) {
 				reboot_after_programming = 0;
 			} else if (strcmp(arg, "-v") == 0) {
