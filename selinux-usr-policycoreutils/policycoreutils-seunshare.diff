Index: policycoreutils/sandbox/seunshare.c
===================================================================
--- policycoreutils/sandbox/seunshare.c (revision 0a5dc30456509f10fdc062f9caecc5d3d57b4306)
+++ policycoreutils/sandbox/seunshare.c (revision 221e6d46651a921c843cbe5ac9b81f324a81e593)
@@ -618,10 +618,17 @@
 
 	/* remove runtime temporary directory */
-	setfsuid(0);
+	if ((uid_t)setfsuid(0) != pwd->pw_uid) {
+		fprintf(stderr, _("Unable to switch to root to clear tmp dir\n"));
+		rc++;
+	}
+
 	if (rmdir(tmpdir) == -1)
 		fprintf(stderr, _("Failed to remove directory %s: %s\n"), tmpdir, strerror(errno));
-	setfsuid(pwd->pw_uid);
-
-	return 0;
+	if ((uid_t)setfsuid(pwd->pw_uid) != 0) {
+		fprintf(stderr, _("unable to switch back to user after clearing tmp dir\n"));
+		rc++;
+	}
+
+	return rc;
 }
 
@@ -643,5 +650,7 @@
 	/* get selinux context */
 	if (execcon) {
-		setfsuid(pwd->pw_uid);
+		if ((uid_t)setfsuid(pwd->pw_uid) != 0)
+			goto err;
+
 		if ((fd_s = open(src, O_RDONLY)) < 0) {
 			fprintf(stderr, _("Failed to open directory %s: %s\n"), src, strerror(errno));
@@ -662,5 +671,6 @@
 
 		/* ok to not reach this if there is an error */
-		setfsuid(0);
+		if ((uid_t)setfsuid(0) != pwd->pw_uid)
+			goto err;
 	}
 
@@ -717,5 +727,6 @@
 	}
 
-	setfsuid(pwd->pw_uid);
+	if ((uid_t)setfsuid(pwd->pw_uid) != 0)
+		goto err;
 
 	if (rsynccmd(src, tmpdir, &cmdbuf) < 0) {
@@ -724,5 +735,6 @@
 
 	/* ok to not reach this if there is an error */
-	setfsuid(0);
+	if ((uid_t)setfsuid(0) != pwd->pw_uid)
+		goto err;
 
 	if (cmdbuf && spawn_command(cmdbuf, pwd->pw_uid) != 0) {
@@ -920,5 +932,6 @@
 	 * on an NFS mount.  It's also desired to avoid leaking info about
 	 * existence of the files not accessible to the user. */
-	setfsuid(uid);
+	if ((uid_t)setfsuid(uid) != 0)
+		return -1;
 
 	/* verify homedir and tmpdir */
@@ -929,5 +942,5 @@
 		verify_directory(tmpdir_s, NULL, &st_tmpdir_s) < 0 ||
 		check_owner_uid(uid, tmpdir_s, &st_tmpdir_s))) return -1;
-	setfsuid(0);
+	if ((uid_t)setfsuid(0) != uid) return -1;
 
 	/* create runtime tmpdir */
@@ -963,5 +976,5 @@
 
 		/* assume fsuid==ruid after this point */
-		setfsuid(uid);
+		if ((uid_t)setfsuid(uid) != 0) goto childerr;
 
 		/* mount homedir and tmpdir, in this order */
@@ -980,5 +993,5 @@
 			}
 		}
-		
+
 		/* construct a new environment */
 		if ((LANG = getenv("LANG")) != NULL) {
@@ -988,5 +1001,5 @@
 			}
 		}
-		
+
 		if ((rc = clearenv()) != 0) {
 			perror(_("Failed to clear environment"));
@@ -995,5 +1008,5 @@
 		if (display)
 			rc |= setenv("DISPLAY", display, 1);
-		if (LANG) 
+		if (LANG)
 			rc |= setenv("LANG", LANG, 1);
 		rc |= setenv("HOME", pwd->pw_dir, 1);
@@ -1009,5 +1022,5 @@
 		/* selinux context */
 		if (execcon && setexeccon(execcon) != 0) {
-			fprintf(stderr, _("Could not set exec context to %s.\n"), execcon);
+			fprintf(stderr, _("Could not set exec context to %s. %s\n"), execcon, strerror(errno));
 			goto childerr;
 		}
