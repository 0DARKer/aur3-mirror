diff -Naur xen/.git/ORIG_HEAD xen-b/.git/ORIG_HEAD
--- xen/.git/ORIG_HEAD	2013-03-16 23:14:03.186511944 -0600
+++ xen-b/.git/ORIG_HEAD	2013-03-16 11:20:56.826511944 -0600
@@ -1 +1 @@
-f91c9f4254c926c92815da881fdff2a14ce72acf
+37d930430c2f2ef4dedf27deb404d2fe2602c039
diff -Naur xen/Config.mk xen-b/Config.mk
--- xen/Config.mk	2013-03-16 22:40:58.693178611 -0600
+++ xen-b/Config.mk	2013-03-16 22:46:20.403178611 -0600
@@ -7,7 +7,6 @@
 # fallback for older make
 realpath = $(wildcard $(foreach file,$(1),$(shell cd -P $(dir $(file)) && echo "$$PWD/$(notdir $(file))")))
 
--include $(XEN_ROOT)/.config
 
 # A debug build of Xen and tools?
 debug ?= y
@@ -29,7 +28,7 @@
 
 # Tools to run on system hosting the build
 HOSTCC      = gcc
-HOSTCFLAGS  = -Wall -Werror -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCFLAGS  = -Wstrict-prototypes -O2 -fomit-frame-pointer
 HOSTCFLAGS += -fno-strict-aliasing
 
 DISTDIR     ?= $(XEN_ROOT)/dist
@@ -68,7 +67,7 @@
 
 # See distro_mapping.txt for other options
 $(eval $(call setvar_dir,CONFIG_LEAF_DIR,,/etc/sysconfig,sysconfig,default))
-$(eval $(call setvar_dir,SUBSYS_DIR,/var/run,/subsys,/subsys,))
+$(eval $(call setvar_dir,SUBSYS_DIR,/run,/subsys,/subsys,))
 $(eval $(call setvar_dir,INITD_DIR,/etc,/rc.d/init.d,/rc.d/init.d,/init.d))
 
 ifneq ($(EXTRA_PREFIX),)
@@ -165,7 +164,7 @@
 
 CFLAGS += -std=gnu99
 
-CFLAGS += -Wall -Wstrict-prototypes
+CFLAGS += -Wstrict-prototypes
 
 # Clang complains about macros that expand to 'if ( ( foo == bar ) ) ...'
 # and is over-zealous with the printf format lint
@@ -197,7 +196,7 @@
 # near the place in the Xen Makefiles where the file is used.
 
 ifeq ($(GIT_HTTP),y)
-QEMU_REMOTE=http://xenbits.xen.org/git-http/qemu-xen-unstable.git
+QEMU_REMOTE=http://xenbits.xen.org/git-http/qemu-upstream-unstable.git
 else
 QEMU_REMOTE=git://xenbits.xen.org/qemu-xen-unstable.git
 endif
@@ -208,16 +207,16 @@
 SEABIOS_UPSTREAM_URL ?= http://xenbits.xen.org/git-http/seabios.git
 else
 OVMF_UPSTREAM_URL ?= git://xenbits.xen.org/ovmf.git
-QEMU_UPSTREAM_URL ?= git://xenbits.xen.org/qemu-upstream-unstable.git
-SEABIOS_UPSTREAM_URL ?= git://xenbits.xen.org/seabios.git
+QEMU_UPSTREAM_URL ?= git://git.qemu.org/qemu.git
+SEABIOS_UPSTREAM_URL ?= git://git.seabios.org/seabios.git
 endif
 OVMF_UPSTREAM_REVISION ?= b0855f925c6e2e0b21fbb03fab4b5fb5b6876871
 QEMU_UPSTREAM_REVISION ?= master
-SEABIOS_UPSTREAM_TAG ?= rel-1.7.1
+SEABIOS_UPSTREAM_TAG ?= master
 # Wed Aug 29 21:27:37 2012 -0400
 # Make iasl option check work with older versions of iasl.
 
-ETHERBOOT_NICS ?= rtl8139 8086100e
+ETHERBOOT_NICS ?= rtl8139 e1000_82540
 
 # Specify which qemu-dm to use. This may be `ioemu' to use the old
 # Mercurial in-tree version, or a local directory, or a git URL.
diff -Naur xen/Makefile xen-b/Makefile
--- xen/Makefile	2013-03-12 14:53:23.156511944 -0600
+++ xen-b/Makefile	2013-03-16 22:46:20.403178611 -0600
@@ -236,7 +236,7 @@
 	rm -f  $(D)$(CONFIG_DIR)/udev/rules.d/xend.rules
 	rm -f  $(D)$(SYSCONFIG_DIR)/xendomains
 	rm -f  $(D)$(SYSCONFIG_DIR)/xencommons
-	rm -rf $(D)/var/run/xen* $(D)/var/lib/xen*
+	rm -rf $(D)/run/xen* $(D)/var/lib/xen*
 	make -C tools uninstall
 	rm -rf $(D)/boot/tboot*
 
diff -Naur xen/Makefile.orig xen-b/Makefile.orig
--- xen/Makefile.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/Makefile.orig	2013-03-12 14:53:23.156511944 -0600
@@ -0,0 +1,288 @@
+#
+# Grand Unified Makefile for Xen.
+#
+
+# Default target must appear before any include lines
+.PHONY: all
+all: dist
+
+-include config/Toplevel.mk
+SUBSYSTEMS?=xen kernels tools stubdom docs
+TARGS_DIST=$(patsubst %, dist-%, $(SUBSYSTEMS))
+TARGS_INSTALL=$(patsubst %, install-%, $(SUBSYSTEMS))
+
+export XEN_ROOT=$(CURDIR)
+include Config.mk
+
+SUBARCH := $(subst x86_32,i386,$(XEN_TARGET_ARCH))
+export XEN_TARGET_ARCH SUBARCH XEN_SYSTYPE
+include buildconfigs/Rules.mk
+
+# build and install everything into the standard system directories
+.PHONY: install
+install: $(TARGS_INSTALL)
+
+.PHONY: build
+build: kernels
+	$(MAKE) -C xen build
+	$(MAKE) -C tools build
+	$(MAKE) -C stubdom build
+ifeq (x86_64,$(XEN_TARGET_ARCH))
+	XEN_TARGET_ARCH=x86_32 $(MAKE) -C stubdom pv-grub
+endif
+	$(MAKE) -C docs build
+
+# The test target is for unit tests that can run without an installation.  Of
+# course, many tests require a machine running Xen itself, and these are
+# handled elsewhere.
+.PHONY: test
+test:
+	$(MAKE) -C tools/python test
+
+# build and install everything into local dist directory
+.PHONY: dist
+dist: DESTDIR=$(DISTDIR)/install
+dist: $(TARGS_DIST) dist-misc
+
+dist-misc:
+	$(INSTALL_DIR) $(DISTDIR)/
+	$(INSTALL_DATA) ./COPYING $(DISTDIR)
+	$(INSTALL_DATA) ./README $(DISTDIR)
+	$(INSTALL_PROG) ./install.sh $(DISTDIR)
+dist-%: DESTDIR=$(DISTDIR)/install
+dist-%: install-%
+	@: # do nothing
+
+# Legacy dist targets
+.PHONY: xen tools stubdom kernels docs
+xen: dist-xen
+tools: dist-tools
+kernels: dist-kernels
+stubdom: dist-stubdom
+docs: dist-docs
+
+.PHONY: prep-kernels
+prep-kernels:
+	for i in $(XKERNELS) ; do $(MAKE) $$i-prep || exit 1; done
+
+.PHONY: install-xen
+install-xen:
+	$(MAKE) -C xen install
+
+.PHONY: install-tools
+install-tools:
+	$(MAKE) -C tools install
+
+ifeq ($(CONFIG_IOEMU),y)
+install-tools: tools/qemu-xen-traditional-dir tools/qemu-xen-dir
+endif
+
+.PHONY: install-kernels
+install-kernels:
+	for i in $(XKERNELS) ; do $(MAKE) $$i-install || exit 1; done
+
+.PHONY: install-stubdom
+install-stubdom: tools/qemu-xen-traditional-dir install-tools
+	$(MAKE) -C stubdom install
+ifeq (x86_64,$(XEN_TARGET_ARCH))
+	XEN_TARGET_ARCH=x86_32 $(MAKE) -C stubdom install-grub
+endif
+
+tools/qemu-xen-traditional-dir:
+	$(MAKE) -C tools qemu-xen-traditional-dir-find
+
+.PHONY: tools/qemu-xen-traditional-dir-force-update
+tools/qemu-xen-traditional-dir-force-update:
+	$(MAKE) -C tools qemu-xen-traditional-dir-force-update
+
+tools/qemu-xen-dir:
+	$(MAKE) -C tools qemu-xen-dir-find
+
+.PHONY: tools/qemu-xen-dir-force-update
+tools/qemu-xen-dir-force-update:
+	$(MAKE) -C tools qemu-xen-dir-force-update
+
+.PHONY: tools/firmware/seabios-dir-force-update
+tools/firmware/seabios-dir-force-update:
+	$(MAKE) -C tools/firmware seabios-dir-force-update
+
+.PHONY: install-docs
+install-docs:
+	$(MAKE) -C docs install
+
+.PHONY: dev-docs
+dev-docs:
+	$(MAKE) -C docs dev-docs
+
+# Build all the various kernels and modules
+.PHONY: kbuild
+kbuild: kernels
+
+# Delete the kernel build trees entirely
+.PHONY: kdelete
+kdelete:
+	for i in $(XKERNELS) ; do $(MAKE) $$i-delete ; done
+
+# Clean the kernel build trees
+.PHONY: kclean
+kclean:
+	for i in $(XKERNELS) ; do $(MAKE) $$i-clean ; done
+
+# build xen, the tools, and a domain 0 plus unprivileged linux-xen images,
+# and place them in the install directory. 'make install' should then
+# copy them to the normal system directories
+.PHONY: world
+world: 
+	$(MAKE) clean
+	$(MAKE) kdelete
+	$(MAKE) dist
+
+# Package a build in a debball file, that is inside a .deb format
+# container to allow for easy and clean removal. This is not intended
+# to be a full featured policy compliant .deb package.
+.PHONY: debball
+debball: dist
+	fakeroot sh ./tools/misc/mkdeb $(XEN_ROOT) $$($(MAKE) -C xen xenversion | grep -v :)
+
+# clean doesn't do a kclean
+.PHONY: clean
+clean::
+	$(MAKE) -C xen clean
+	$(MAKE) -C tools clean
+	$(MAKE) -C stubdom crossclean
+ifeq (x86_64,$(XEN_TARGET_ARCH))
+	XEN_TARGET_ARCH=x86_32 $(MAKE) -C stubdom crossclean
+endif
+	$(MAKE) -C docs clean
+
+# clean, but blow away kernel build tree plus tarballs
+.PHONY: distclean
+distclean:
+	-rm config/Toplevel.mk
+	$(MAKE) -C xen distclean
+	$(MAKE) -C tools distclean
+	$(MAKE) -C stubdom distclean
+ifeq (x86_64,$(XEN_TARGET_ARCH))
+	XEN_TARGET_ARCH=x86_32 $(MAKE) -C stubdom distclean
+endif
+	$(MAKE) -C docs distclean
+	rm -rf dist patches/tmp
+	for i in $(ALLKERNELS) ; do $(MAKE) $$i-delete ; done
+	rm -rf patches/*/.makedep
+	rm -rf config.log config.status config.cache autom4te.cache
+
+# Linux name for GNU distclean
+.PHONY: mrproper
+mrproper: distclean
+
+# Prepare for source tarball
+.PHONY: src-tarball
+src-tarball: distclean
+	$(MAKE) -C xen .banner
+	rm -rf xen/tools/figlet .[a-z]*
+	$(MAKE) -C xen distclean
+
+.PHONY: help
+help:
+	@echo 'Installation targets:'
+	@echo '  install          - build and install everything'
+	@echo '  install-xen      - build and install the Xen hypervisor'
+	@echo '  install-tools    - build and install the control tools'
+	@echo '  install-kernels  - build and install guest kernels'
+	@echo '  install-stubdom  - build and install the stubdomain images'
+	@echo '  install-docs     - build and install user documentation'
+	@echo ''
+	@echo 'Building targets:'
+	@echo '  dist             - build and install everything into local dist directory'
+	@echo '  world            - clean everything, delete guest kernel build'
+	@echo '                     trees then make dist'
+	@echo '  xen              - build and install Xen hypervisor'
+	@echo '  tools            - build and install tools'
+	@echo '  stubdom          - build and install the stubdomain images'
+	@echo '  kernels          - build and install guest kernels'
+	@echo '  kbuild           - synonym for make kernels'
+	@echo '  docs             - build and install user documentation'
+	@echo '  dev-docs         - build developer-only documentation'
+	@echo ''
+	@echo 'Cleaning targets:'
+	@echo '  clean            - clean the Xen, tools and docs (but not guest kernel trees)'
+	@echo '  distclean        - clean plus delete kernel build trees and'
+	@echo '                     local downloaded files'
+	@echo '  kdelete          - delete guest kernel build trees'
+	@echo '  kclean           - clean guest kernel build trees'
+	@echo ''
+	@echo 'Miscellaneous targets:'
+	@echo '  prep-kernels     - prepares kernel directories, does not build'
+	@echo '  uninstall        - attempt to remove installed Xen tools'
+	@echo '                     (use with extreme care!)'
+	@echo
+	@echo 'Trusted Boot (tboot) targets:'
+	@echo '  build-tboot      - download and build the tboot module'
+	@echo '  install-tboot    - download, build, and install the tboot module'
+	@echo '  clean-tboot      - clean the tboot module if it exists'
+	@echo
+	@echo 'Environment:'
+	@echo '  [ this documentation is sadly not complete ]'
+
+# Use this target with extreme care!
+.PHONY: uninstall
+uninstall: D=$(DESTDIR)
+uninstall:
+	[ -d $(D)$(XEN_CONFIG_DIR) ] && mv -f $(D)$(XEN_CONFIG_DIR) $(D)$(XEN_CONFIG_DIR).old-`date +%s` || true
+	$(MAKE) -C xen uninstall
+	rm -rf $(D)$(CONFIG_DIR)/init.d/xendomains $(D)$(CONFIG_DIR)/init.d/xend
+	rm -rf $(D)$(CONFIG_DIR)/init.d/xencommons $(D)$(CONFIG_DIR)/init.d/xen-watchdog
+	rm -f  $(D)$(CONFIG_DIR)/udev/rules.d/xen-backend.rules
+	rm -f  $(D)$(CONFIG_DIR)/udev/rules.d/xend.rules
+	rm -f  $(D)$(SYSCONFIG_DIR)/xendomains
+	rm -f  $(D)$(SYSCONFIG_DIR)/xencommons
+	rm -rf $(D)/var/run/xen* $(D)/var/lib/xen*
+	make -C tools uninstall
+	rm -rf $(D)/boot/tboot*
+
+# Legacy targets for compatibility
+.PHONY: linux26
+linux26:
+	$(MAKE) 'KERNELS=linux-2.6*' kernels
+
+.PHONY: xenversion
+xenversion:
+	@$(MAKE) --no-print-directory -C xen xenversion
+
+#
+# tboot targets
+#
+
+TBOOT_TARFILE = tboot-20090330.tar.gz
+#TBOOT_BASE_URL = http://downloads.sourceforge.net/tboot
+TBOOT_BASE_URL = $(XEN_EXTFILES_URL)
+
+.PHONY: build-tboot
+build-tboot: download_tboot
+	$(MAKE) -C tboot build
+
+.PHONY: install-tboot
+install-tboot: download_tboot
+	$(MAKE) -C tboot install
+
+.PHONY: dist-tboot
+dist-tboot: download_tboot
+	$(MAKE) DESTDIR=$(DISTDIR)/install -C tboot dist
+
+.PHONY: clean-tboot
+clean-tboot:
+	[ ! -d tboot ] || $(MAKE) -C tboot clean
+
+.PHONY: distclean-tboot
+distclean-tboot:
+	[ ! -d tboot ] || $(MAKE) -C tboot distclean
+
+.PHONY: download_tboot
+download_tboot: tboot/Makefile
+
+tboot/Makefile: tboot/$(TBOOT_TARFILE)
+	[ -e tboot/Makefile ] || tar -xzf tboot/$(TBOOT_TARFILE) -C tboot/ --strip-components 1
+
+tboot/$(TBOOT_TARFILE):
+	mkdir -p tboot
+	wget -O tboot/$(TBOOT_TARFILE) $(TBOOT_BASE_URL)/$(TBOOT_TARFILE)
diff -Naur xen/config/StdGNU.mk xen-b/config/StdGNU.mk
--- xen/config/StdGNU.mk	2013-03-09 18:06:25.756511944 -0700
+++ xen-b/config/StdGNU.mk	2013-03-16 22:46:20.403178611 -0600
@@ -42,8 +42,8 @@
 PRIVATE_BINDIR = $(PRIVATE_PREFIX)/bin
 
 CONFIG_DIR = /etc
-XEN_LOCK_DIR = /var/lock
-XEN_RUN_DIR = /var/run/xen
+XEN_LOCK_DIR = /run/lock
+XEN_RUN_DIR = /run/xen
 XEN_PAGING_DIR = /var/lib/xen/xenpaging
 
 SYSCONFIG_DIR = $(CONFIG_DIR)/$(CONFIG_LEAF_DIR)
diff -Naur xen/configure xen-b/configure
--- xen/configure	2013-03-09 18:06:25.769845278 -0700
+++ xen-b/configure	2013-03-16 22:46:20.403178611 -0600
@@ -667,7 +667,7 @@
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
+localstatedir='${prefix}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1211,7 +1211,7 @@
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff -Naur xen/extras/mini-os/lib/math.c xen-b/extras/mini-os/lib/math.c
--- xen/extras/mini-os/lib/math.c	2013-03-09 18:06:25.879845279 -0700
+++ xen-b/extras/mini-os/lib/math.c	2013-03-16 22:46:20.403178611 -0600
@@ -186,6 +186,7 @@
 	 * and thus
 	 *	m = 4 - n <= 2
 	 */
+	tmp.ul[H] = tmp.ul[L] = 0;
 	tmp.uq = uq;
 	u[0] = 0;
 	u[1] = HHALF(tmp.ul[H]);
diff -Naur xen/extras/mini-os/minios.mk xen-b/extras/mini-os/minios.mk
--- xen/extras/mini-os/minios.mk	2013-03-09 18:06:25.883178612 -0700
+++ xen-b/extras/mini-os/minios.mk	2013-03-16 22:46:20.403178611 -0600
@@ -6,7 +6,7 @@
 
 # Define some default flags.
 # NB. '-Wcast-qual' is nasty, so I omitted it.
-DEF_CFLAGS += -fno-builtin -Wall -Werror -Wredundant-decls -Wno-format -Wno-redundant-decls
+DEF_CFLAGS += -fno-builtin -Wall -Wredundant-decls -Wno-format -Wno-redundant-decls
 DEF_CFLAGS += $(call cc-option,$(CC),-fno-stack-protector,)
 DEF_CFLAGS += $(call cc-option,$(CC),-fgnu89-inline)
 DEF_CFLAGS += -Wstrict-prototypes -Wnested-externs -Wpointer-arith -Winline
diff -Naur xen/tools/Makefile xen-b/tools/Makefile
--- xen/tools/Makefile	2013-03-09 18:06:25.913178610 -0700
+++ xen-b/tools/Makefile	2013-03-16 22:46:20.403178611 -0600
@@ -67,7 +67,7 @@
 	$(INSTALL_DIR) $(DESTDIR)/var/xen/dump
 	$(INSTALL_DIR) $(DESTDIR)/var/log/xen
 	$(INSTALL_DIR) $(DESTDIR)/var/lib/xen
-	$(INSTALL_DIR) $(DESTDIR)/var/lock/subsys
+	$(INSTALL_DIR) $(DESTDIR)/run/lock/subsys
 
 .PHONY: uninstall
 uninstall: D=$(DESTDIR)
@@ -185,7 +185,7 @@
 		source=.; \
 	fi; \
 	cd qemu-xen-dir; \
-	$$source/configure --enable-xen --target-list=i386-softmmu \
+	$$source/configure --enable-xen --target-list=i386-softmmu,x86_64-softmmu  \
 		--source-path=$$source \
 		--extra-cflags="-I$(XEN_ROOT)/tools/include \
 		-I$(XEN_ROOT)/tools/libxc \
@@ -196,7 +196,18 @@
 		-L$(XEN_ROOT)/tools/xenstore" \
 		--bindir=$(LIBEXEC) \
 		--datadir=$(SHAREDIR)/qemu-xen \
-		--disable-kvm \
+                --disable-werror \
+                --enable-spice \
+                --enable-usb-redir \
+                --enable-guest-agent \
+		--enable-sdl \
+		--enable-linux-aio \
+		--enable-smartcard-nss \
+		--enable-libiscsi \
+                --audio-drv-list=alsa,sdl \
+		--disable-docs \
+                --enable-mixemu \
+                --audio-card-list=ac97,adlib,sb16,hda \
 		--disable-docs \
 		--python=$(PYTHON) \
 		$(IOEMU_CONFIGURE_CROSS); \
diff -Naur xen/tools/Rules.mk xen-b/tools/Rules.mk
--- xen/tools/Rules.mk	2013-03-09 18:06:25.913178610 -0700
+++ xen-b/tools/Rules.mk	2013-03-16 22:46:20.403178611 -0600
@@ -9,6 +9,8 @@
 export _INSTALL := $(INSTALL)
 INSTALL = $(XEN_ROOT)/tools/cross-install
 
+LDFLAGS_RPATH = -Wl,-rpath,'$${ORIGIN}$(if $(1),/$(1))'
+
 XEN_INCLUDE        = $(XEN_ROOT)/tools/include
 XEN_LIBXC          = $(XEN_ROOT)/tools/libxc
 XEN_XENLIGHT       = $(XEN_ROOT)/tools/libxl
diff -Naur xen/tools/blktap/drivers/Makefile xen-b/tools/blktap/drivers/Makefile
--- xen/tools/blktap/drivers/Makefile	2013-03-09 18:06:25.913178610 -0700
+++ xen-b/tools/blktap/drivers/Makefile	2013-03-16 22:52:18.706511944 -0600
@@ -38,8 +38,9 @@
 CFLAGS += $(PTHREAD_CFLAGS)
 LDFLAGS += $(PTHREAD_LDFLAGS)
 
-LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
-LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz
+LDLIBS_xen := $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore)
+LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_xen) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
+LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz $(LDLIBS_xen)
 
 BLK-OBJS-y  := block-aio.o
 BLK-OBJS-y  += block-sync.o
@@ -47,6 +48,7 @@
 BLK-OBJS-y  += block-ram.o
 BLK-OBJS-y  += block-qcow.o
 BLK-OBJS-y  += block-qcow2.o
+BLK-OBJS-y  += block-cdrom.o
 BLK-OBJS-y  += aes.o
 BLK-OBJS-y  += tapaio.o
 BLK-OBJS-$(CONFIG_Linux) += blk_linux.o
diff -Naur xen/tools/blktap/drivers/blktapctrl.c xen-b/tools/blktap/drivers/blktapctrl.c
--- xen/tools/blktap/drivers/blktapctrl.c	2013-03-09 18:06:25.913178610 -0700
+++ xen-b/tools/blktap/drivers/blktapctrl.c	2013-03-16 22:53:49.043178611 -0600
@@ -61,7 +61,7 @@
 #include "list.h"
 #include "xs_api.h" /* for xs_fire_next_watch() */
 
-#define PIDFILE "/var/run/blktapctrl.pid"
+#define PIDFILE "/run/blktapctrl.pid"
 
 #define NUM_POLL_FDS 2
 #define MSG_SIZE 4096
@@ -282,7 +282,7 @@
 	 * qemu-dm instance. We may close the file handle only if there is
 	 * no other disk left for this domain.
 	 */
-	if (dtypes[type]->use_ioemu)
+	if (dtypes[type]->use_ioemu && dtypes[type]->idnum != DISK_TYPE_AIO)
 		return !qemu_instance_has_disks(blkif->tappid);
 
 	/* Caller should close() if no single controller, or list is empty. */
diff -Naur xen/tools/blktap/drivers/block-cdrom.c xen-b/tools/blktap/drivers/block-cdrom.c
--- xen/tools/blktap/drivers/block-cdrom.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/blktap/drivers/block-cdrom.c	2013-03-16 22:52:18.709845278 -0600
@@ -0,0 +1,565 @@
+/* block-cdrom.c
+ *
+ * simple slow synchronous cdrom disk implementation. Based off
+ * of block-sync.c
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ * (c) 2008 Novell Inc. <plc@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+#include "tapdisk.h"
+#include <xen/io/cdromif.h>
+
+struct tdcdrom_state {
+	int fd;
+	int xs_fd;        /* for xen event polling */
+	int media_present;
+	int media_changed;
+	struct xs_handle *xs_handle;
+	char *dev_name;
+	int dev_type;
+	td_flag_t flags;
+};
+
+#define BLOCK_DEVICE   0
+#define FILE_DEVICE    1
+#define CDROM_DEFAULT_SECTOR_SIZE 2048
+#define CDROM_DEFAULT_SIZE 2000000000
+
+/*Get Image size, secsize*/
+static void get_image_info(struct disk_driver *dd)
+{
+	int ret;
+	long size;
+	unsigned long total_size;
+	struct statvfs statBuf;
+	struct stat stat;
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+
+	s->size = 0;
+	s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+	s->info = (VDISK_CDROM | VDISK_REMOVABLE | VDISK_READONLY);
+	prv->media_present = 0;
+
+	ret = fstat(prv->fd, &stat);
+	if (ret != 0) {
+		DPRINTF("ERROR: fstat failed, Couldn't stat image");
+		return;
+	}
+
+	if (S_ISBLK(stat.st_mode)) {
+		/*Accessing block device directly*/
+		int status;
+
+		prv->dev_type = BLOCK_DEVICE;
+		status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+		if (status == CDS_DISC_OK) {
+			prv->media_present = 1;
+			if ((ret =ioctl(prv->fd,BLKGETSIZE,&s->size))!=0) {
+				DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+				s->size = CDROM_DEFAULT_SIZE;
+			}
+		}
+		else {
+			s->size = CDROM_DEFAULT_SIZE;
+		}
+		/*Get the sector size*/
+#if defined(BLKSSZGET)
+		{
+			int arg;
+			s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+			ioctl(prv->fd, BLKSSZGET, &s->sector_size);
+
+			if (s->sector_size != CDROM_DEFAULT_SECTOR_SIZE)
+				DPRINTF("Note: sector size is %llu (not %d)\n",
+					(long long unsigned)s->sector_size,
+					CDROM_DEFAULT_SECTOR_SIZE);
+		}
+#else
+		s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+#endif
+		DPRINTF("Block Device: Image size: %llu"
+			" media_present: %d sector_size: %llu\n",
+			(long long unsigned)s->size, prv->media_present,
+			(long long unsigned)s->sector_size);
+	} else {
+		/*Local file? try fstat instead*/
+		prv->dev_type = FILE_DEVICE;
+		prv->media_present = 1;
+		s->size = (stat.st_size >> SECTOR_SHIFT);
+		s->sector_size = DEFAULT_SECTOR_SIZE;
+		DPRINTF("Local File: Image size: %llu\n",
+				(long long unsigned)s->size);
+	}
+	return;
+}
+
+static inline void init_fds(struct disk_driver *dd)
+{
+	int i;
+	struct tdcdrom_state *prv = dd->private;
+
+	for(i = 0; i < MAX_IOFD; i++)
+		dd->io_fd[i] = 0;
+
+	prv->xs_handle = xs_daemon_open();
+	prv->xs_fd = xs_fileno(prv->xs_handle);
+	dd->io_fd[0] = prv->xs_fd;
+}
+
+void open_device (struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+	int o_flags;
+
+	o_flags = O_NONBLOCK | O_LARGEFILE |
+		((prv->flags == TD_RDONLY) ? O_RDONLY : O_RDWR);
+
+	if (prv->fd < 0) {
+		prv->fd = open(prv->dev_name, o_flags);
+		if (prv->fd == -1) {
+			DPRINTF("Unable tp open: (%s)\n", prv->dev_name);
+			return;
+		}
+	}
+
+	if (prv->fd != -1) {
+
+		get_image_info(dd);
+
+		if (prv->dev_type == BLOCK_DEVICE) {
+			int status;
+			status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+			switch (status) {
+				case CDS_DISC_OK:
+					prv->media_present = 1;
+					break;
+				default:
+					prv->media_present = 0;
+			}
+		}
+		else
+			prv->media_present = 1;
+	}
+}
+
+/*
+ * Main entry point, called when first loaded
+ */
+int tdcdrom_open (struct disk_driver *dd, const char *name, td_flag_t flags)
+{
+	int ret;
+	struct tdcdrom_state *prv = dd->private;
+
+	ret = asprintf(&prv->dev_name, "%s", name);
+	if (ret < 0) {
+		prv->dev_name = NULL;
+		goto out;
+	}
+	prv->fd = -1;
+	prv->media_changed = 0;
+	prv->media_present = 0;
+	prv->flags = flags;
+	init_fds(dd);
+
+	open_device(dd);
+
+out:
+	return ret;
+}
+
+int tdcdrom_queue_read(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	size    = nb_sectors * 512;
+	offset  = sector * (uint64_t)512;
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = read(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_write(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = write(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret : 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_packet(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	union xen_block_packet *sp;
+	struct xen_cdrom_packet *xcp;
+	struct xen_cdrom_support *xcs;
+	struct xen_cdrom_open *xco;
+	struct xen_cdrom_media_info *xcmi;
+	struct xen_cdrom_media_changed *xcmc;
+	struct cdrom_generic_command cgc;
+	struct vcd_generic_command * vgc;
+	struct request_sense sense;
+
+	sp = (union xen_block_packet *)buf;
+	switch(sp->type) {
+		case XEN_TYPE_CDROM_SUPPORT:
+			xcs = &(sp->xcs);
+			xcs->err = 0;
+			xcs->ret = 0;
+			xcs->supported = 1;
+			break;
+		case XEN_TYPE_CDROM_PACKET:
+			xcp = &(sp->xcp);
+			xcp->err = 0;
+			xcp->ret = 0;
+			vgc = (struct vcd_generic_command *)(buf + PACKET_PAYLOAD_OFFSET);
+
+			memset( &cgc, 0, sizeof(struct cdrom_generic_command));
+			memcpy(cgc.cmd, vgc->cmd, CDROM_PACKET_SIZE);
+			cgc.stat = vgc->stat;
+			cgc.data_direction = vgc->data_direction;
+			cgc.quiet = vgc->quiet;
+			cgc.timeout = vgc->timeout;
+
+			if (prv->fd == -1) {
+				xcp = &(sp->xcp);
+				xcp->ret = -1;
+				xcp->err =  0 - ENODEV;
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			if (prv->dev_type == FILE_DEVICE) {
+				DPRINTF("%s() FILE_DEVICE inappropriate packetcmd \n",__func__);
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			switch ( cgc.cmd[0]) {
+				case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+					{
+						int lock;
+						lock = cgc.cmd[4] & 1;
+						if (ioctl (prv->fd, CDROM_LOCKDOOR, lock) < 0) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+					}
+					break;
+				case GPCMD_START_STOP_UNIT:
+					{
+						int start, eject;
+						start = cgc.cmd[4] & 1;
+						eject = (cgc.cmd[4] >> 1) & 1;
+						if (eject && !start) {
+							if (ioctl (prv->fd, CDROMEJECT, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						} else if (eject && start) {
+							if (ioctl (prv->fd, CDROMCLOSETRAY, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						}
+					}
+					break;
+				default:
+					{
+						if (vgc->sense_offset) {
+							cgc.sense = &sense;
+						}
+						if (vgc->buffer_offset) {
+							cgc.buffer = malloc(vgc->buflen);
+							memcpy(cgc.buffer, (char *)sp + PACKET_BUFFER_OFFSET, vgc->buflen);
+							cgc.buflen = vgc->buflen;
+						}
+						if (ioctl (prv->fd, CDROM_SEND_PACKET, &cgc) < 0 ) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+						if (cgc.sense) {
+							memcpy((char *)sp + PACKET_SENSE_OFFSET, cgc.sense, sizeof(struct request_sense));
+						}
+						if (cgc.buffer) {
+							vgc->buflen = cgc.buflen;
+							memcpy((char *)sp + PACKET_BUFFER_OFFSET, cgc.buffer, cgc.buflen);
+							free(cgc.buffer);
+						}
+						break;
+					}
+			}
+			break;
+		case XEN_TYPE_CDROM_OPEN:
+			{
+				unsigned int len;
+				struct stat statbuf;
+				int major = 0;
+				int minor = 0;
+
+				if (stat (prv->dev_name, &statbuf) == 0) {
+					major = major (statbuf.st_rdev);
+					minor = minor (statbuf.st_rdev);
+				}
+				xco = &(sp->xco);
+				xco->err = 0;
+				xco->ret = 0;
+				if (xco->payload_offset) {
+					char *present;
+					char *buf;
+					char *num;
+					char *nodename;
+					char media_present[2];
+					nodename = (char *)sp + xco->payload_offset;
+					if (asprintf(&buf, "%s/media-present", nodename) < 0)
+						goto out_payload_offset;
+					present = xs_read(prv->xs_handle, XBT_NULL, buf, &len);
+					if (present) {
+						free(buf);
+						goto out_payload_offset_free;
+					}
+
+					sprintf(media_present, "%d", prv->media_present);
+					xs_write(prv->xs_handle, XBT_NULL, buf, media_present, strlen(media_present));
+					xs_watch(prv->xs_handle, buf, "media-present");
+					free(buf);
+
+					if (asprintf(&buf, "%s/params", nodename) < 0)
+						goto out_payload_offset_free;
+					xs_watch(prv->xs_handle, buf, "params");
+					free(buf);
+
+					if (asprintf(&num, "%x:%x", major, minor) < 0)
+						goto out_payload_offset_free;
+					if (asprintf(&buf, "%s/physical-device", nodename) < 0) {
+						free(num);
+						goto out_payload_offset_free;
+					}
+					xs_write(prv->xs_handle, XBT_NULL, buf, num, strlen(num));
+					free(buf);
+					free(num);
+out_payload_offset_free:
+					free(present);
+out_payload_offset:
+					;
+				}
+
+				xco->media_present = prv->media_present;
+				xco->sectors = 0;
+				xco->sector_size = 2048;
+				if (prv->media_present && prv->fd != -1 ) {
+					get_image_info(dd);
+					xco->sectors = s->size;
+					xco->sector_size = s->sector_size;
+				}
+			}
+			break;
+		case XEN_TYPE_CDROM_MEDIA_CHANGED:
+			xcmc = &(sp->xcmc);
+			xcmc->err = 0;
+			xcmc->ret = 0;
+			xcmc->media_changed = prv->media_changed;
+			prv->media_changed = 0;
+			break;
+		default:
+			xcp = &(sp->xcp);
+			xcp->err = -EINVAL;
+			xcp->ret = -1;
+			break;
+	}
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_submit(struct disk_driver *dd)
+{
+	return 0;
+}
+
+int tdcdrom_close(struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+
+	if (prv->fd != -1) {
+		close(prv->fd);
+		prv->fd = -1;
+	}
+	prv->xs_fd = -1;
+	xs_daemon_close(prv->xs_handle);
+	free(prv->dev_name);
+
+	return 0;
+}
+
+void tdcdrom_process_media_change_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *media_present;
+    unsigned int len;
+
+	media_present = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (strcmp(media_present, "0") == 0) {
+		close(prv->fd);
+		prv->fd = -1;
+		prv->media_present = 0;
+	}
+	else {
+		open_device(dd);
+		prv->media_changed = 1;
+	}
+	free(media_present);
+}
+
+void tdcrom_process_params_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *params;
+    unsigned int len;
+
+	params = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (params) {
+		char *cp = strchr(params, ':');
+		if (cp) {
+			cp++;
+			if (prv->dev_name)
+				free(prv->dev_name);
+			if (asprintf(&prv->dev_name, "%s", cp) < 0) {
+				prv->dev_name = NULL;
+				return;
+			}
+			if (prv->fd != -1) {
+				close(prv->fd);
+				prv->fd = -1;
+			}
+			open_device(dd);
+			prv->media_changed = 1;
+		}
+		free(params);
+	}
+}
+
+int tdcdrom_do_callbacks(struct disk_driver *dd, int sid)
+{
+	struct tdcdrom_state *prv = dd->private;
+	char **vec;
+	unsigned int num;
+
+	vec = xs_read_watch(prv->xs_handle, &num);
+	if (!vec)
+		return 1;
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "media-present")) {
+        tdcdrom_process_media_change_event(dd, vec);
+        goto out;
+    }
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "params")) {
+        tdcrom_process_params_event(dd, vec);
+        goto out;
+    }
+
+ out:
+    free(vec);
+	return 1;
+}
+
+int tdcdrom_get_parent_id(struct disk_driver *dd, struct disk_id *id)
+{
+	return TD_NO_PARENT;
+}
+
+int tdcdrom_validate_parent(struct disk_driver *dd,
+		struct disk_driver *parent, td_flag_t flags)
+{
+	return -EINVAL;
+}
+
+struct tap_disk tapdisk_cdrom = {
+	.disk_type           = "tapdisk_cdrom",
+	.private_data_size   = sizeof(struct tdcdrom_state),
+	.td_open             = tdcdrom_open,
+	.td_queue_read       = tdcdrom_queue_read,
+	.td_queue_packet     = tdcdrom_queue_packet,
+	.td_queue_write      = tdcdrom_queue_write,
+	.td_submit           = tdcdrom_submit,
+	.td_close            = tdcdrom_close,
+	.td_do_callbacks     = tdcdrom_do_callbacks,
+	.td_get_parent_id    = tdcdrom_get_parent_id,
+	.td_validate_parent  = tdcdrom_validate_parent
+};
diff -Naur xen/tools/blktap/drivers/tapdisk.c xen-b/tools/blktap/drivers/tapdisk.c
--- xen/tools/blktap/drivers/tapdisk.c	2013-03-09 18:06:25.916511944 -0700
+++ xen-b/tools/blktap/drivers/tapdisk.c	2013-03-16 22:52:18.709845278 -0600
@@ -735,6 +735,22 @@
 					goto out;
 				}
 				break;
+			case BLKIF_OP_PACKET:
+				ret = 0;
+				if (drv->td_queue_packet)
+					ret = drv->td_queue_packet(dd, sector_nr,
+							nsects, page,
+							send_responses,
+							idx, (void *)(long)i);
+				if (ret > 0) dd->early += ret;
+				else if (ret == -EBUSY) {
+					/* put req back on queue */
+					--info->fe_ring.req_cons;
+					info->busy.req     = req;
+					info->busy.seg_idx = i;
+					goto out;
+				}
+				break;
 			default:
 				DPRINTF("Unknown block operation\n");
 				break;
diff -Naur xen/tools/blktap/drivers/tapdisk.h xen-b/tools/blktap/drivers/tapdisk.h
--- xen/tools/blktap/drivers/tapdisk.h	2013-03-09 18:06:25.916511944 -0700
+++ xen-b/tools/blktap/drivers/tapdisk.h	2013-03-16 22:52:18.709845278 -0600
@@ -137,6 +137,9 @@
 	int (*td_get_parent_id)  (struct disk_driver *dd, struct disk_id *id);
 	int (*td_validate_parent)(struct disk_driver *dd, 
 				  struct disk_driver *p, td_flag_t flags);
+	int (*td_queue_packet)  (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
 };
 
 typedef struct disk_info {
@@ -160,6 +163,7 @@
 extern struct tap_disk tapdisk_ram;
 extern struct tap_disk tapdisk_qcow;
 extern struct tap_disk tapdisk_qcow2;
+extern struct tap_disk tapdisk_cdrom;
 
 
 /*Define Individual Disk Parameters here */
@@ -229,6 +233,17 @@
 #endif
 };
 
+static disk_info_t cdrom_disk = {
+	DISK_TYPE_CDROM,
+	"raw image (cdrom)",
+	"cdrom",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_cdrom,
+#endif
+};
+
 /*Main disk info array */
 static disk_info_t *dtypes[] = {
 	&aio_disk,
@@ -237,6 +252,7 @@
 	&ram_disk,
 	&qcow_disk,
 	&qcow2_disk,
+	&cdrom_disk,
 };
 
 typedef struct driver_list_entry {
diff -Naur xen/tools/blktap/lib/blktaplib.h xen-b/tools/blktap/lib/blktaplib.h
--- xen/tools/blktap/lib/blktaplib.h	2013-03-09 18:06:25.916511944 -0700
+++ xen-b/tools/blktap/lib/blktaplib.h	2013-03-16 22:52:18.709845278 -0600
@@ -83,7 +83,7 @@
 #define BLKTAP_DEV_DIR   "/dev/xen"
 #define BLKTAP_DEV_NAME  "blktap"
 #define BLKTAP_DEV_MINOR 0
-#define BLKTAP_CTRL_DIR   "/var/run/tap"
+#define BLKTAP_CTRL_DIR   "/run/tap"
 
 extern int blktap_major;
 
@@ -219,6 +219,7 @@
 #define DISK_TYPE_RAM      3
 #define DISK_TYPE_QCOW     4
 #define DISK_TYPE_QCOW2    5
+#define DISK_TYPE_CDROM    6
 
 /* xenstore/xenbus: */
 #define DOMNAME "Domain-0"
diff -Naur xen/tools/blktap2/drivers/Makefile xen-b/tools/blktap2/drivers/Makefile
--- xen/tools/blktap2/drivers/Makefile	2013-03-09 18:06:25.916511944 -0700
+++ xen-b/tools/blktap2/drivers/Makefile	2013-03-16 22:46:20.406511944 -0600
@@ -9,7 +9,7 @@
 LOCK_UTIL  = lock-util
 INST_DIR   = $(SBINDIR)
 
-CFLAGS    += -Werror -g
+CFLAGS    += -g
 CFLAGS    += -Wno-unused
 CFLAGS    += -fno-strict-aliasing
 CFLAGS    += -I$(BLKTAP_ROOT)/include -I$(BLKTAP_ROOT)/drivers
diff -Naur xen/tools/blktap2/include/blktap2.h xen-b/tools/blktap2/include/blktap2.h
--- xen/tools/blktap2/include/blktap2.h	2013-03-09 18:06:25.926511944 -0700
+++ xen-b/tools/blktap2/include/blktap2.h	2013-03-16 22:46:20.406511944 -0600
@@ -45,7 +45,7 @@
 
 #define BLKTAP2_SYSFS_DIR              "/sys/class/blktap2"
 #define BLKTAP2_CONTROL_NAME           "blktap-control"
-#define BLKTAP2_CONTROL_DIR            "/var/run/"BLKTAP2_CONTROL_NAME
+#define BLKTAP2_CONTROL_DIR            "/run/"BLKTAP2_CONTROL_NAME
 #define BLKTAP2_CONTROL_SOCKET         "ctl"
 #define BLKTAP2_DIRECTORY              "/dev/xen/blktap-2"
 #define BLKTAP2_CONTROL_DEVICE         BLKTAP2_DIRECTORY"/control"
diff -Naur xen/tools/blktap2/include/blktaplib.h xen-b/tools/blktap2/include/blktaplib.h
--- xen/tools/blktap2/include/blktaplib.h	2013-03-09 18:06:25.926511944 -0700
+++ xen-b/tools/blktap2/include/blktaplib.h	2013-03-16 22:46:20.406511944 -0600
@@ -81,7 +81,7 @@
 #define BLKTAP_DEV_NAME         "blktap"
 #define BACKDEV_NAME            "backdev"
 #define BLKTAP_DEV_MINOR        0
-#define BLKTAP_CTRL_DIR         "/var/run/tap"
+#define BLKTAP_CTRL_DIR         "/run/tap"
 
 extern int blktap_major;
 
diff -Naur xen/tools/configure xen-b/tools/configure
--- xen/tools/configure	2013-03-09 18:06:25.929845277 -0700
+++ xen-b/tools/configure	2013-03-16 22:46:20.406511944 -0600
@@ -801,7 +801,7 @@
 datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
+localstatedir='${prefix}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
@@ -1345,7 +1345,7 @@
   --libexecdir=DIR        program executables [EPREFIX/libexec]
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff -Naur xen/tools/console/daemon/main.c xen-b/tools/console/daemon/main.c
--- xen/tools/console/daemon/main.c	2013-03-09 18:06:25.939845278 -0700
+++ xen-b/tools/console/daemon/main.c	2013-03-16 22:46:20.406511944 -0600
@@ -155,7 +155,7 @@
 	setlogmask(syslog_mask);
 
 	if (!is_interactive) {
-		daemonize(pidfile ? pidfile : "/var/run/xenconsoled.pid");
+		daemonize(pidfile ? pidfile : "/run/xenconsoled.pid");
 	}
 
 	if (!xen_setup())
diff -Naur xen/tools/debugger/gdbsx/Rules.mk xen-b/tools/debugger/gdbsx/Rules.mk
--- xen/tools/debugger/gdbsx/Rules.mk	2013-03-09 18:06:25.939845278 -0700
+++ xen-b/tools/debugger/gdbsx/Rules.mk	2013-03-16 22:46:20.406511944 -0600
@@ -1,4 +1,4 @@
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS   += -Werror -Wmissing-prototypes 
+CFLAGS   += -Wmissing-prototypes 
 # (gcc 4.3x and later)   -Wconversion -Wno-sign-conversion
diff -Naur xen/tools/debugger/gdbsx/xg/xg_main.c xen-b/tools/debugger/gdbsx/xg/xg_main.c
--- xen/tools/debugger/gdbsx/xg/xg_main.c	2013-03-09 18:06:25.943178611 -0700
+++ xen-b/tools/debugger/gdbsx/xg/xg_main.c	2013-03-16 22:46:20.409845277 -0600
@@ -179,7 +179,7 @@
     hypercall.op = __HYPERVISOR_domctl;
     hypercall.arg[0] = (unsigned long)&domctl;
 
-    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (ulong)&hypercall);
+    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (unsigned long)&hypercall);
     if (domctlarg && sz)
         munlock(domctlarg, sz);
     return rc;
@@ -219,7 +219,7 @@
     hypercall.arg[0] = (unsigned long)XENVER_capabilities;
     hypercall.arg[1] = (unsigned long)&xen_caps;
 
-    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (ulong)&hypercall);
+    rc = ioctl(_dom0_fd, IOCTL_PRIVCMD_HYPERCALL, (unsigned long)&hypercall);
     munlock(&xen_caps, sizeof(xen_caps));
     XGTRC("XENCAPS:%s\n", xen_caps);
 
diff -Naur xen/tools/examples/xend-config.sxp xen-b/tools/examples/xend-config.sxp
--- xen/tools/examples/xend-config.sxp	2013-03-09 18:06:25.943178611 -0700
+++ xen-b/tools/examples/xend-config.sxp	2013-03-16 23:02:10.986511944 -0600
@@ -194,6 +194,26 @@
 #(network-script network-route)
 #(vif-script     vif-route)
 
+# SuSE users note:
+# If using a routed network configuration it is advised to NOT use
+# network-route and vif-route scripts but instead use sysconfig scripts
+# in dom0 and vif-route-ifup script to "connect" the domU vif to dom0.
+# Since this configuration requires a vif sysconfig script in dom0, a static
+# vif name must be used.  E.g. in dom0 the vif sysconfig script
+# (/etc/sysconfig/network/ifcfg-xen1.0) may contain
+#
+#    NAME='XEN vm 1 virtual interface 0'
+#    BOOTPROTO='static'
+#    STARTMODE='hotplug'
+#    ...
+#
+# The corresponding domain vif configuration would contain e.g.
+# vif=[ 'mac=00:16:3e:aa:bb:cc,script=vif-route-ifup,vifname=xen1.0', ]
+#
+# If the vif-route-ifup script will be used for all domains, it can be
+# set here as the default vif script, alleviating the need for
+# 'script=' in domain vif configuration.
+#(vif-script     vif-route-ifup)
 
 ## Use the following if network traffic is routed with NAT, as an alternative
 # to the settings for bridged networking given above.
diff -Naur xen/tools/examples/xend-config.sxp.orig xen-b/tools/examples/xend-config.sxp.orig
--- xen/tools/examples/xend-config.sxp.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/examples/xend-config.sxp.orig	2013-03-09 18:06:25.943178611 -0700
@@ -0,0 +1,304 @@
+# -*- sh -*-
+
+#
+# Xend configuration file.
+#
+
+# This example configuration is appropriate for an installation that 
+# utilizes a bridged network configuration. Access to xend via http
+# is disabled.  
+
+# Commented out entries show the default for that entry, unless otherwise
+# specified.
+
+#(logfile /var/log/xen/xend.log)
+#(loglevel DEBUG)
+
+# Uncomment the line below.  Set the value to flask, acm, or dummy to 
+# select a security module.
+
+#(xsm_module_name dummy)
+
+# The Xen-API server configuration.
+#
+# This value configures the ports, interfaces, and access controls for the
+# Xen-API server.  Each entry in the list starts with either unix, a port
+# number, or an address:port pair.  If this is "unix", then a UDP socket is
+# opened, and this entry applies to that.  If it is a port, then Xend will
+# listen on all interfaces on that TCP port, and if it is an address:port
+# pair, then Xend will listen on the specified port, using the interface with
+# the specified address.
+#
+# The subsequent string configures the user-based access control for the
+# listener in question.  This can be one of "none" or "pam", indicating either
+# that users should be allowed access unconditionally, or that the local
+# Pluggable Authentication Modules configuration should be used.  If this
+# string is missing or empty, then "pam" is used.
+#
+# The final string gives the host-based access control for that listener. If
+# this is missing or empty, then all connections are accepted.  Otherwise,
+# this should be a space-separated sequence of regular expressions; any host
+# with a fully-qualified domain name or an IP address that matches one of
+# these regular expressions will be accepted.
+#
+# Example: listen on TCP port 9363 on all interfaces, accepting connections
+# only from machines in example.com or localhost, and allow access through
+# the unix domain socket unconditionally:
+#
+#   (xen-api-server ((9363 pam '^localhost$ example\\.com$')
+#                    (unix none)))
+#
+# Optionally, the TCP Xen-API server can use SSL by specifying the private
+# key and certificate location:
+#
+#                    (9367 pam '' xen-api.key xen-api.crt)
+#
+# Default:
+#   (xen-api-server ((unix)))
+
+
+#(xend-http-server no)
+#(xend-unix-server no)
+#(xend-tcp-xmlrpc-server no)
+#(xend-unix-xmlrpc-server yes)
+#(xend-relocation-server no)
+(xend-relocation-server yes)
+#(xend-relocation-ssl-server no)
+#(xend-udev-event-server no)
+
+#(xend-unix-path /var/lib/xend/xend-socket)
+
+
+# Address and port xend should use for the legacy TCP XMLRPC interface, 
+# if xend-tcp-xmlrpc-server is set.
+#(xend-tcp-xmlrpc-server-address 'localhost')
+#(xend-tcp-xmlrpc-server-port 8006)
+
+# SSL key and certificate to use for the legacy TCP XMLRPC interface.
+# Setting these will mean that this port serves only SSL connections as
+# opposed to plaintext ones.
+#(xend-tcp-xmlrpc-server-ssl-key-file  xmlrpc.key)
+#(xend-tcp-xmlrpc-server-ssl-cert-file xmlrpc.crt)
+
+
+# Port xend should use for the HTTP interface, if xend-http-server is set.
+#(xend-port            8000)
+
+# Port xend should use for the relocation interface, if xend-relocation-server
+# is set.
+#(xend-relocation-port 8002)
+
+# Port xend should use for the ssl relocation interface, if
+# xend-relocation-ssl-server is set.
+#(xend-relocation-ssl-port 8003)
+
+# SSL key and certificate to use for the ssl relocation interface, if
+# xend-relocation-ssl-server is set.
+#(xend-relocation-server-ssl-key-file   xmlrpc.key)
+#(xend-relocation-server-ssl-cert-file  xmlrpc.crt)
+
+# Whether to use ssl as default when relocating.
+#(xend-relocation-ssl no)
+
+# Address xend should listen on for HTTP connections, if xend-http-server is
+# set.
+# Specifying 'localhost' prevents remote connections.
+# Specifying the empty string '' (the default) allows all connections.
+#(xend-address '')
+#(xend-address localhost)
+
+# Address xend should listen on for relocation-socket connections, if
+# xend-relocation-server is set.
+# Meaning and default as for xend-address above.
+# Also, interface name is allowed (e.g. eth0) there to get the
+# relocation address to be bound on.
+#(xend-relocation-address '')
+
+# The hosts allowed to talk to the relocation port.  If this is empty (the
+# default), then all connections are allowed (assuming that the connection
+# arrives on a port and interface on which we are listening; see
+# xend-relocation-port and xend-relocation-address above).  Otherwise, this
+# should be a space-separated sequence of regular expressions.  Any host with
+# a fully-qualified domain name or an IP address that matches one of these
+# regular expressions will be accepted.
+#
+# For example:
+#  (xend-relocation-hosts-allow '^localhost$ ^.*\\.example\\.org$')
+#
+#(xend-relocation-hosts-allow '')
+(xend-relocation-hosts-allow '^localhost$ ^localhost\\.localdomain$')
+
+# The limit (in kilobytes) on the size of the console buffer
+#(console-limit 1024)
+
+##
+# To bridge network traffic, like this:
+#
+# dom0: ----------------- bridge -> real eth0 -> the network
+#                            |
+# domU: fake eth0 -> vifN.0 -+
+#
+# use
+#
+# (network-script network-bridge)
+#
+# Your default ethernet device is used as the outgoing interface, by default. 
+# To use a different one (e.g. eth1) use
+#
+# (network-script 'network-bridge netdev=eth1')
+#
+# The bridge is named eth0, by default (yes, really!)
+#
+
+# It is normally much better to create the bridge yourself in
+# /etc/network/interfaces.  network-bridge start does nothing if you
+# already have a bridge, and network-bridge stop does nothing if the
+# default bridge name (normally eth0) is not a bridge.  See
+# bridge-utils-interfaces(5) for full information on the syntax in
+# /etc/network/interfaces, but you probably want something like this:
+#    iface xenbr0 inet static
+#        address [etc]
+#        netmask [etc]
+#        [etc]
+#        bridge_ports eth0
+#
+# To have network-bridge create a differently-named bridge, use:
+# (network-script 'network-bridge bridge=<name>')
+#
+# It is possible to use the network-bridge script in more complicated
+# scenarios, such as having two outgoing interfaces, with two bridges, and
+# two fake interfaces per guest domain.  To do things like this, write
+# yourself a wrapper script, and call network-bridge from it, as appropriate.
+#
+(network-script network-bridge)
+
+# The script used to control virtual interfaces.  This can be overridden on a
+# per-vif basis when creating a domain or a configuring a new vif.  The
+# vif-bridge script is designed for use with the network-bridge script, or
+# similar configurations.
+#
+# If you have overridden the bridge name using
+# (network-script 'network-bridge bridge=<name>') then you may wish to do the
+# same here.  The bridge name can also be set when creating a domain or
+# configuring a new vif, but a value specified here would act as a default.
+#
+# If you are using only one bridge, the vif-bridge script will discover that,
+# so there is no need to specify it explicitly.  The default is to use
+# the bridge which is listed first in the output from brctl.
+#
+(vif-script vif-bridge)
+
+
+## Use the following if network traffic is routed, as an alternative to the
+# settings for bridged networking given above.
+#(network-script network-route)
+#(vif-script     vif-route)
+
+
+## Use the following if network traffic is routed with NAT, as an alternative
+# to the settings for bridged networking given above.
+#(network-script network-nat)
+#(vif-script     vif-nat)
+
+# dom0-min-mem is the lowest permissible memory level (in MB) for dom0.
+# This is a minimum both for auto-ballooning (as enabled by
+# enable-dom0-ballooning below) and for xm mem-set when applied to dom0.
+(dom0-min-mem 196)
+
+# Whether to enable auto-ballooning of dom0 to allow domUs to be created.
+# If enable-dom0-ballooning = no, dom0 will never balloon out.
+(enable-dom0-ballooning yes)
+
+# 32-bit paravirtual domains can only consume physical
+# memory below 168GB. On systems with memory beyond that address,
+# they'll be confined to memory below 128GB.
+# Using total_available_memory (in GB) to specify the amount of memory reserved
+# in the memory pool exclusively for 32-bit paravirtual domains.
+# Additionally you should use dom0_mem = <-Value> as a parameter in 
+# xen kernel to reserve the memory for 32-bit paravirtual domains, default 
+# is "0" (0GB).  
+(total_available_memory 0) 
+
+# In SMP system, dom0 will use dom0-cpus # of CPUS
+# If dom0-cpus = 0, dom0 will take all cpus available
+(dom0-cpus 0)
+
+# Whether to enable core-dumps when domains crash.
+#(enable-dump no)
+
+# The tool used for initiating virtual TPM migration
+#(external-migration-tool '')
+
+# The interface for VNC servers to listen on. Defaults
+# to 127.0.0.1  To restore old 'listen everywhere' behaviour
+# set this to 0.0.0.0
+#(vnc-listen '127.0.0.1')
+
+# The default password for VNC console on HVM domain.
+# Empty string is no authentication.
+(vncpasswd '')
+
+# The VNC server can be told to negotiate a TLS session
+# to encryption all traffic, and provide x509 cert to
+# clients enabling them to verify server identity. The
+# GTK-VNC widget, virt-viewer, virt-manager and VeNCrypt
+# all support the VNC extension for TLS used in QEMU. The
+# TightVNC/RealVNC/UltraVNC clients do not.
+#
+# To enable this create x509 certificates / keys in the
+# directory ${XEN_CONFIG_DIR} + vnc
+#
+#  ca-cert.pem       - The CA certificate
+#  server-cert.pem   - The Server certificate signed by the CA
+#  server-key.pem    - The server private key
+#
+# and then uncomment this next line
+# (vnc-tls 1)
+
+# The certificate dir can be pointed elsewhere..
+#
+# (vnc-x509-cert-dir vnc)
+
+# The server can be told to request & validate an x509
+# certificate from the client. Only clients with a cert
+# signed by the trusted CA will be able to connect. This
+# is more secure the password auth alone. Passwd auth can
+# used at the same time if desired. To enable client cert
+# checking uncomment this:
+#
+# (vnc-x509-verify 1)
+
+# The default keymap to use for the VM's virtual keyboard
+# when not specififed in VM's configuration
+#(keymap 'en-us')
+
+# Script to run when the label of a resource has changed.
+#(resource-label-change-script '')
+
+# Rotation count of qemu-dm log file.
+#(qemu-dm-logrotate-count 10)
+
+# Path where persistent domain configuration is stored.
+# Default is /var/lib/xend/domains/
+#(xend-domains-path /var/lib/xend/domains)
+
+# Number of seconds xend will wait for device creation and
+# destruction
+#(device-create-timeout 100)
+#(device-destroy-timeout 100)
+
+# When assigning device to HVM guest, we use the strict check for HVM guest by
+# default. (For PV guest, we use loose check automatically if necessary.)
+# When we assign device to HVM guest, if we meet with the co-assignment
+# issues or the ACS issue, we could try changing the option to 'no' -- however,
+# we have to realize this may incur security issue and we can't make sure the
+# device assignment could really work properly even after we do this.
+#(pci-passthrough-strict-check yes)
+
+# If we have a very big scsi device configuration, start of xend is slow,
+# because xend scans all the device paths to build its internal PSCSI device
+# list.  If we need only a few devices for assigning to a guest, we can reduce
+# the scan to this device. Set list list of device paths in same syntax like in
+# command lsscsi, e.g. ('16:0:0:0' '15:0') 
+# (pscsi-device-mask ('*'))
+
diff -Naur xen/tools/examples/xmexample.disks xen-b/tools/examples/xmexample.disks
--- xen/tools/examples/xmexample.disks	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/examples/xmexample.disks	2013-03-16 23:08:45.063178610 -0600
@@ -0,0 +1,32 @@
+# A VM's disks can be stored in a variety of ways.
+# Here are some examples:
+disk = [
+    # Block device
+    'phy:/dev/hdb,xvda,w',
+    # Raw format, accessed via loopback
+    'file:/var/lib/xen/images/disk-example/disk0,xvdb,w',
+    # Raw format, accessed via blocktap
+    'tap:aio:/var/lib/xen/images/disk-example/disk0,xvdc,w',
+    # QCOW format, accessed via blocktap
+    'tap:qcow:/var/lib/xen/images/disk-example/disk0.qcow,xvdd,w',
+    # NBD (network block device):  IP and port are separated by space
+    'nbd:192.168.0.1 20004,xvde,w',
+    # iSCSI:  The usual colon is replaced with '@'
+    'iscsi:iqn.2006-09.de.suse@0ac47ee2-216e-452a-a341-a12624cd0225,xvdf,w',
+    # Fibre Channel N_Port ID Virtualization
+    'npiv:210400e08b80c40f,xvdg,w' ]
+
+
+# Remaining settings for the example VM:
+name="disk-example"
+memory=512
+vcpus=1
+on_crash="destroy"
+on_poweroff="destroy"
+on_reboot="restart"
+localtime=0
+builder="linux"
+bootloader="/usr/lib/xen/boot/domUloader.py"
+bootargs="--entry=xvda2:/boot/vmlinuz-xen,/boot/initrd-xen"
+vif=[ 'mac=00:16:3e:00:01:02,bridge=xenbr0' ]
+vfb=['type=vnc,vncunused=1']
diff -Naur xen/tools/examples/xmexample.hvm xen-b/tools/examples/xmexample.hvm
--- xen/tools/examples/xmexample.hvm	2013-03-09 18:06:25.943178611 -0700
+++ xen-b/tools/examples/xmexample.hvm	2013-03-16 22:46:20.409845277 -0600
@@ -127,6 +127,15 @@
 # Device Model to be used
 device_model = 'qemu-dm'
 
+# the amount of memory in MiB for the guest
+#actmem=42
+
+# Optional: guest page file
+#xenpaging_file="/var/lib/xen/xenpaging/<domain_name>.<domaind_id>.paging"
+
+# Optional: extra cmdline options for xenpaging
+#xenpaging_extra=[ 'string', 'string' ]
+
 #-----------------------------------------------------------------------------
 # boot on floppy (a), hard disk (c), Network (n) or CD-ROM (d) 
 # default: hard disk, cd-rom, floppy
diff -Naur xen/tools/firmware/Makefile xen-b/tools/firmware/Makefile
--- xen/tools/firmware/Makefile	2013-03-09 18:06:25.946511945 -0700
+++ xen-b/tools/firmware/Makefile	2013-03-17 08:18:23.463178609 -0600
@@ -18,8 +18,9 @@
 	cp ovmf-makefile ovmf/Makefile;
 
 seabios-dir:
-	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_TAG) seabios-dir
-	cp seabios-config seabios-dir/.config;
+	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_TAG) seabios-dir 	
+	cp seabios-config seabios-dir/.config; 
+	patch -d seabios-dir -p1 -i ../seabios-mac-20130223.patch
 
 .PHONY: all
 all: $(SUBDIRS-y)
diff -Naur xen/tools/firmware/etherboot/Config xen-b/tools/firmware/etherboot/Config
--- xen/tools/firmware/etherboot/Config	2013-03-09 18:06:25.946511945 -0700
+++ xen-b/tools/firmware/etherboot/Config	2013-03-16 22:46:20.409845277 -0600
@@ -1,3 +1,4 @@
+NICS = rtl8139 8086100e eepro100 e1000 pcnet32 10ec8029
 
 CFLAGS += -UPXE_DHCP_STRICT
 CFLAGS += -DPXE_DHCP_STRICT
diff -Naur xen/tools/firmware/hvmloader/acpi/ssdt_s3.asl xen-b/tools/firmware/hvmloader/acpi/ssdt_s3.asl
--- xen/tools/firmware/hvmloader/acpi/ssdt_s3.asl	2013-03-09 18:06:25.956511943 -0700
+++ xen-b/tools/firmware/hvmloader/acpi/ssdt_s3.asl	2013-03-16 22:46:20.409845277 -0600
@@ -20,13 +20,9 @@
 
 DefinitionBlock ("SSDT_S3.aml", "SSDT", 2, "Xen", "HVM", 0)
 {
-    /* Must match piix emulation */
-    Name (\_S3, Package (0x04)
-    {
-        0x01,  /* PM1a_CNT.SLP_TYP */
-        0x01,  /* PM1b_CNT.SLP_TYP */
-        0x0,   /* reserved */
-        0x0    /* reserved */
-    })
+    /*
+     * Turn off support for s3 sleep state to deal with SVVP tests.
+     * This is what MSFT does on HyperV.
+     */
 }
 
diff -Naur xen/tools/firmware/hvmloader/acpi/ssdt_s4.asl xen-b/tools/firmware/hvmloader/acpi/ssdt_s4.asl
--- xen/tools/firmware/hvmloader/acpi/ssdt_s4.asl	2013-03-09 18:06:25.956511943 -0700
+++ xen-b/tools/firmware/hvmloader/acpi/ssdt_s4.asl	2013-03-16 22:46:20.409845277 -0600
@@ -20,13 +20,9 @@
 
 DefinitionBlock ("SSDT_S4.aml", "SSDT", 2, "Xen", "HVM", 0)
 {
-    /* Must match piix emulation */
-    Name (\_S4, Package (0x04)
-    {
-        0x00,  /* PM1a_CNT.SLP_TYP */
-        0x00,  /* PM1b_CNT.SLP_TYP */
-        0x00,  /* reserved */
-        0x00   /* reserved */
-    })
+    /*
+     * Turn off support for s4 sleep state to deal with SVVP tests.
+     * This is what MSFT does on HyperV.
+     */
 }
 
diff -Naur xen/tools/firmware/hvmloader/config.h xen-b/tools/firmware/hvmloader/config.h
--- xen/tools/firmware/hvmloader/config.h	2013-03-09 18:06:25.956511943 -0700
+++ xen-b/tools/firmware/hvmloader/config.h	2013-03-16 22:46:20.409845277 -0600
@@ -5,6 +5,9 @@
 
 enum virtual_vga { VGA_none, VGA_std, VGA_cirrus, VGA_pt };
 extern enum virtual_vga virtual_vga;
+//PARCHE//
+extern uint8_t gfx_bdf;
+//PARCHE_END//
 
 extern unsigned long igd_opregion_pgbase;
 #define IGD_OPREGION_PAGES 3
diff -Naur xen/tools/firmware/seabios-config xen-b/tools/firmware/seabios-config
--- xen/tools/firmware/seabios-config	2013-03-09 18:06:25.966511945 -0700
+++ xen-b/tools/firmware/seabios-config	2013-03-16 23:20:58.316511943 -0600
@@ -1,13 +1,16 @@
 #
 # Automatically generated make config: don't edit
 # SeaBIOS Configuration
-# Thu Jan  3 17:25:45 2013
+# Sat Mar 16 23:20:58 2013
 #
 
 #
 # General Features
 #
 # CONFIG_COREBOOT is not set
+CONFIG_QEMU=y
+# CONFIG_CSM is not set
+CONFIG_QEMU_HARDWARE=y
 CONFIG_XEN=y
 CONFIG_THREADS=y
 # CONFIG_THREAD_OPTIONROMS is not set
@@ -15,6 +18,7 @@
 CONFIG_BOOTMENU=y
 # CONFIG_BOOTSPLASH is not set
 CONFIG_BOOTORDER=y
+CONFIG_ENTRY_EXTRASTACK=y
 
 #
 # Hardware support
@@ -27,6 +31,7 @@
 CONFIG_VIRTIO_SCSI=y
 CONFIG_ESP_SCSI=y
 CONFIG_LSI_SCSI=y
+CONFIG_MEGASAS=y
 CONFIG_FLOPPY=y
 CONFIG_PS2PORT=y
 CONFIG_USB=y
@@ -42,6 +47,7 @@
 CONFIG_LPT=y
 CONFIG_USE_SMM=y
 CONFIG_MTRR_INIT=y
+CONFIG_PMTIMER=y
 
 #
 # BIOS interfaces
diff -Naur xen/tools/firmware/seabios-mac-20130223.patch xen-b/tools/firmware/seabios-mac-20130223.patch
--- xen/tools/firmware/seabios-mac-20130223.patch	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/firmware/seabios-mac-20130223.patch	2013-02-23 13:04:54.000000000 -0700
@@ -0,0 +1,378 @@
+###############################################################################
+# Fixed DSDT entry for HPET; add entry for AppleSMC (G. Somlo <somlo@cmu.edu>)
+###############################################################################
+diff --git a/src/acpi-dsdt-hpet.dsl b/src/acpi-dsdt-hpet.dsl
+index f33e527..323818e 100644
+--- a/src/acpi-dsdt-hpet.dsl
++++ b/src/acpi-dsdt-hpet.dsl
+@@ -23,14 +23,23 @@ Scope(\_SB) {
+             }
+             Return (0x0F)
+         }
+-        Name(_CRS, ResourceTemplate() {
+-#if 0       /* This makes WinXP BSOD for not yet figured reasons. */
+-            IRQNoFlags() {2, 8}
+-#endif
++        Name(RESP, ResourceTemplate() {
+             Memory32Fixed(ReadOnly,
+                 0xFED00000,         // Address Base
+                 0x00000400,         // Address Length
+                 )
+         })
++        Name(RESI, ResourceTemplate() {
++            IRQNoFlags() {2, 8}
++        })
++        Method(_CRS, 0) {
++            Store(\_SB.PCI0.ISA.SMC._STA(), Local0)
++            If (LEqual(Local0, 0x0B)) {        // AppleSMC present, add IRQ
++                ConcatenateResTemplate(RESP, RESI, Local1)
++                Return (Local1)
++            } else {
++                Return (RESP)
++            }
++        }
+     }
+ }
+diff --git a/src/acpi-dsdt-isa.dsl b/src/acpi-dsdt-isa.dsl
+index 23761db..6f2aeb4 100644
+--- a/src/acpi-dsdt-isa.dsl
++++ b/src/acpi-dsdt-isa.dsl
+@@ -1,6 +1,28 @@
+ /* Common legacy ISA style devices. */
+ Scope(\_SB.PCI0.ISA) {
+ 
++    Device (SMC) {
++        Name(_HID, EisaId("APP0001"))
++        OperationRegion(SMC, SystemIO, 0x0300, 0x20)
++        Field(SMC, ByteAcc, NoLock, Preserve) {
++            Offset(0x04),
++            CMDP, 8,
++        }
++        Method(_STA, 0) {
++//            Store(0x10, CMDP)    // APPLESMC_READ_CMD
++//            Store(CMDP, Local0)
++//            If (LEqual(Local0, 0x0c)) {
++                Return (0x0B)
++//            } Else {
++//                Return (0x00)
++//            }
++        }
++        Name (_CRS, ResourceTemplate () {
++            IO (Decode16, 0x0300, 0x0300, 0x01, 0x20)
++            IRQNoFlags() { 6 }
++        })
++    }
++
+     Device(RTC) {
+         Name(_HID, EisaId("PNP0B00"))
+         Name(_CRS, ResourceTemplate() {
+###############################################################################
+# 70-more-smbios.patch; (Alexander Graf and/or Rene Rebe)
+# GLS: this patch enables "About This Mac" functionality in OS X, which would
+#      otherwise result in Finder crashing.
+###############################################################################
+diff --git a/src/smbios.c b/src/smbios.c
+index fd63afb..a85c236 100644
+--- a/src/smbios.c
++++ b/src/smbios.c
+@@ -37,7 +37,7 @@ smbios_entry_point_setup(u16 max_structure_size,
+     memcpy(ep->anchor_string, "_SM_", 4);
+     ep->length = 0x1f;
+     ep->smbios_major_version = 2;
+-    ep->smbios_minor_version = 4;
++    ep->smbios_minor_version = 5;
+     ep->max_structure_size = max_structure_size;
+     ep->entry_point_revision = 0;
+     memset(ep->formatted_area, 0, 5);
+@@ -46,7 +46,7 @@ smbios_entry_point_setup(u16 max_structure_size,
+     ep->structure_table_length = structure_table_length;
+     ep->structure_table_address = (u32)finaltable;
+     ep->number_of_structures = number_of_structures;
+-    ep->smbios_bcd_revision = 0x24;
++    ep->smbios_bcd_revision = 0x25;
+ 
+     ep->checksum -= checksum(ep, 0x10);
+ 
+@@ -171,8 +171,8 @@ smbios_init_type_0(void *start)
+     p->header.length = sizeof(struct smbios_type_0);
+     p->header.handle = 0;
+ 
+-    load_str_field_with_default(0, vendor_str, BUILD_APPNAME);
+-    load_str_field_with_default(0, bios_version_str, BUILD_APPNAME);
++    load_str_field_with_default(0, vendor_str, "Apple Inc.");
++    load_str_field_with_default(0, bios_version_str, "IM81.88Z.00C1.B00.0802091538");
+ 
+     p->bios_starting_address_segment = 0xe800;
+ 
+@@ -183,8 +183,10 @@ smbios_init_type_0(void *start)
+     if (!get_field(0, offsetof(struct smbios_type_0, bios_characteristics),
+                    &p->bios_characteristics)) {
+         memset(p->bios_characteristics, 0, 8);
+-        /* BIOS characteristics not supported */
+-        p->bios_characteristics[0] = 0x08;
++        p->bios_characteristics[0] = 0x80;
++        p->bios_characteristics[1] = 0x98;
++        p->bios_characteristics[2] = 0x09;
++        p->bios_characteristics[3] = 0x78;
+     }
+ 
+     if (!get_field(0, offsetof(struct smbios_type_0,
+@@ -219,18 +221,18 @@ smbios_init_type_1(void *start)
+     p->header.length = sizeof(struct smbios_type_1);
+     p->header.handle = 0x100;
+ 
+-    load_str_field_with_default(1, manufacturer_str, BUILD_APPNAME);
+-    load_str_field_with_default(1, product_name_str, BUILD_APPNAME);
+-    load_str_field_or_skip(1, version_str);
+-    load_str_field_or_skip(1, serial_number_str);
++    load_str_field_with_default(1, manufacturer_str, "Apple Inc.");
++    load_str_field_with_default(1, product_name_str, "iMac8,1");
++    load_str_field_with_default(1, version_str, "1.0");
++    load_str_field_with_default(1, serial_number_str, "SystemSerial#");
+ 
+     if (!get_field(1, offsetof(struct smbios_type_1, uuid), &p->uuid))
+         memset(p->uuid, 0, 16);
+ 
+     set_field_with_default(1, wake_up_type, 0x06); /* power switch */
+ 
+-    load_str_field_or_skip(1, sku_number_str);
+-    load_str_field_or_skip(1, family_str);
++    load_str_field_with_default(1, sku_number_str, "SKU#");
++    load_str_field_with_default(1, family_str, "Mac");
+ 
+     *end = 0;
+     end++;
+@@ -242,6 +244,44 @@ smbios_init_type_1(void *start)
+     return end;
+ }
+ 
++/* Type 2 -- Base Board */
++static void *
++smbios_init_type_2(void *start)
++{
++    struct smbios_type_2 *p = (struct smbios_type_2 *)start;
++
++    p->header.type = 2;
++    p->header.length = sizeof(struct smbios_type_2);
++    p->header.handle = 0x300;
++
++    p->manufacturer_str = 1;
++    p->product_str = 2;
++    p->version_str = 3;
++    p->serial_number_str = 4;
++    p->asset_tag_number_str = 0;
++    p->feature_flags = 1; /* Motherboard */
++    p->location_str = 0;
++    p->chassis_handle = 0x301;
++    p->board_type = 0x0a; /* Motherboard */
++    p->contained_element_count = 0;
++
++    start += sizeof(struct smbios_type_2);
++    memcpy((char *)start, "Apple Inc.", sizeof("Apple Inc."));
++    start += sizeof("Apple Inc.");
++
++    memcpy((char *)start, "Mac-F227BEC8", sizeof("Mac-F227BEC8"));
++    start += sizeof("Mac-F227BEC8");
++
++    memcpy((char *)start, "VERSION", sizeof("VERSION"));
++    start += sizeof("VERSION");
++
++    memcpy((char *)start, "BoardSerial#", sizeof("BoardSerial#"));
++    start += sizeof("BoardSerial#");
++
++    *((u8 *)start) = 0;
++    return start + 1;
++}
++
+ /* Type 3 -- System Enclosure */
+ static void *
+ smbios_init_type_3(void *start)
+@@ -253,13 +293,13 @@ smbios_init_type_3(void *start)
+ 
+     p->header.type = 3;
+     p->header.length = sizeof(struct smbios_type_3);
+-    p->header.handle = 0x300;
++    p->header.handle = 0x301;
+ 
+     load_str_field_with_default(3, manufacturer_str, BUILD_APPNAME);
+     set_field_with_default(3, type, 0x01); /* other */
+ 
+-    load_str_field_or_skip(3, version_str);
+-    load_str_field_or_skip(3, serial_number_str);
++    load_str_field_with_default(3, version_str, "VERSION");
++    load_str_field_with_default(3, serial_number_str, "ChassisSerial#");
+     load_str_field_or_skip(3, asset_tag_number_str);
+ 
+     set_field_with_default(3, boot_up_state, 0x03); /* safe */
+@@ -322,7 +362,7 @@ smbios_init_type_4(void *start, unsigned int cpu_number)
+ 
+     load_str_field_or_skip(4, processor_version_str);
+     set_field_with_default(4, voltage, 0);
+-    set_field_with_default(4, external_clock, 0);
++    set_field_with_default(4, external_clock, 800);
+ 
+     set_field_with_default(4, max_speed, 2000);
+     set_field_with_default(4, current_speed, 2000);
+@@ -331,9 +371,16 @@ smbios_init_type_4(void *start, unsigned int cpu_number)
+     set_field_with_default(4, processor_upgrade, 0x01); /* other */
+ 
+     /* cache information structure not provided */
+-    p->l1_cache_handle =  0xffff;
+-    p->l2_cache_handle =  0xffff;
+-    p->l3_cache_handle =  0xffff;
++    p->l1_cache_handle = 0x600 + cpu_number * 2;
++    p->l2_cache_handle = 0x600 + cpu_number * 2 + 1;
++    p->l3_cache_handle = 0xffff; /* cache information structure not provided */
++
++    p->asset_tag_str = 0;
++    p->part_no_str = 0;
++    p->core_count = 2;
++    p->core_enabled = 2;
++    p->thread_count = 2;
++    p->processor_characteristics = 0;
+ 
+     *end = 0;
+     end++;
+@@ -345,6 +392,35 @@ smbios_init_type_4(void *start, unsigned int cpu_number)
+     return end;
+ }
+ 
++static void *
++smbios_init_type_7(void *start, unsigned int cpu_number, unsigned int level)
++{
++    struct smbios_type_7 *p = (struct smbios_type_7 *)start;
++
++    p->header.type = 7;
++    p->header.length = sizeof(struct smbios_type_7);
++    p->header.handle = 0x600 + cpu_number * 2 + level - 1;
++
++    p->socket_designation_str = 1;
++    p->cache_config = 0x80 & (level - 1); /* enabled + level */
++    p->max_cache_size = p->installed_cache_size =
++	level == 1 ? 64 : 512; /* 1k granularity */
++    p->supported_sram_type = p->current_sram_type =
++        0x08 & 0x10 & 0x80; /* Burst, Pipeline Burst, Asynchronous */
++    p->cache_speed = 0; /* in ns, 0 for unknown */
++    p->error_correction = 0x05; /* Single-bit ECC */
++    p->system_cache_type = 0x05; /* Unified */
++    p->associativity = 0x06; /* Fully Associative */
++
++    start += sizeof(struct smbios_type_7);
++
++    snprintf((char*)start, 9, "L%d Cache", level);
++    start += 9;
++
++    *((u8 *)start) = 0;
++    return start + 1;
++}
++
+ /* Type 16 -- Physical Memory Array */
+ static void *
+ smbios_init_type_16(void *start, u32 memory_size_mb, int nr_mem_devs)
+@@ -385,6 +461,8 @@ smbios_init_type_17(void *start, u32 size_mb, int instance)
+     p->header.length = sizeof(struct smbios_type_17);
+     p->header.handle = 0x1100 + instance;
+ 
++    p->speed = 667;
++    p->attributes = 0;
+     p->physical_memory_array_handle = 0x1000;
+     set_field_with_default(17, total_width, 64);
+     set_field_with_default(17, data_width, 64);
+@@ -404,7 +482,10 @@ smbios_init_type_17(void *start, u32 size_mb, int instance)
+     end += strlen(name) + 1;
+     p->device_locator_str = ++str_index;
+ 
+-    load_str_field_or_skip(17, bank_locator_str);
++    load_str_field_with_default(17, bank_locator_str, "Bank 0");
++    load_str_field_with_default(17, manufactor_str, "Manufactor");
++    load_str_field_with_default(17, serial_str, "MemSerial#");
++
+     set_field_with_default(17, memory_type, 0x07); /* RAM */
+     set_field_with_default(17, type_detail, 0);
+ 
+@@ -531,11 +612,15 @@ smbios_setup(void)
+ 
+     add_struct(0, p);
+     add_struct(1, p);
++    add_struct(2, p);
+     add_struct(3, p);
+ 
+     int cpu_num;
+-    for (cpu_num = 1; cpu_num <= MaxCountCPUs; cpu_num++)
++    for (cpu_num = 1; cpu_num <= MaxCountCPUs; cpu_num++) {
+         add_struct(4, p, cpu_num);
++        add_struct(7, p, cpu_num, 1); /* L1 & L2 cache */
++        add_struct(7, p, cpu_num, 2);
++    }
+ 
+     int ram_mb = (RamSize + RamSizeOver4G) >> 20;
+     int nr_mem_devs = (ram_mb + 0x3fff) >> 14;
+diff --git a/src/smbios.h b/src/smbios.h
+index a4c1444..9838719 100644
+--- a/src/smbios.h
++++ b/src/smbios.h
+@@ -62,6 +62,22 @@ struct smbios_type_1 {
+     u8 family_str;
+ } PACKED;
+ 
++/* SMBIOS type 2 - Base Board */
++struct smbios_type_2 {
++    struct smbios_structure_header header;
++    u8 manufacturer_str;
++    u8 product_str;
++    u8 version_str;
++    u8 serial_number_str;
++    u8 asset_tag_number_str;
++    u8 feature_flags;
++    u8 location_str;
++    u16 chassis_handle;
++    u8 board_type;
++    u8 contained_element_count;
++    // contained elements follow
++} PACKED;
++
+ /* SMBIOS type 3 - System Enclosure (v2.3) */
+ struct smbios_type_3 {
+     struct smbios_structure_header header;
+@@ -99,6 +115,28 @@ struct smbios_type_4 {
+     u16 l1_cache_handle;
+     u16 l2_cache_handle;
+     u16 l3_cache_handle;
++    u8 serial_str;
++    u8 asset_tag_str;
++    u8 part_no_str;
++    u8 core_count;
++    u8 core_enabled;
++    u8 thread_count;
++    u16 processor_characteristics;
++} PACKED;
++
++/* SMBIOS type 7 - Cache Information (v2.0) */
++struct smbios_type_7 {
++    struct smbios_structure_header header;
++    u8 socket_designation_str;
++    u16 cache_config;
++    u16 max_cache_size;
++    u16 installed_cache_size;
++    u16 supported_sram_type;
++    u16 current_sram_type;
++    u8 cache_speed;
++    u8 error_correction;
++    u8 system_cache_type;
++    u8 associativity;
+ } PACKED;
+ 
+ /* SMBIOS type 16 - Physical Memory Array
+@@ -130,6 +168,12 @@ struct smbios_type_17 {
+     u8 bank_locator_str;
+     u8 memory_type;
+     u16 type_detail;
++    u16 speed;
++    u8 manufactor_str;
++    u8 serial_str;
++    u8 asset_tag_str;
++    u8 part_no_str;
++    u8 attributes;
+ } PACKED;
+ 
+ /* SMBIOS type 19 - Memory Array Mapped Address */
diff -Naur xen/tools/hotplug/Linux/Makefile xen-b/tools/hotplug/Linux/Makefile
--- xen/tools/hotplug/Linux/Makefile	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/Makefile	2013-03-16 23:02:10.993178611 -0600
@@ -11,7 +11,7 @@
 
 # Xen script dir and scripts to go there.
 XEN_SCRIPTS = network-bridge vif-bridge
-XEN_SCRIPTS += network-route vif-route
+XEN_SCRIPTS += network-route vif-route vif-route-ifup
 XEN_SCRIPTS += network-nat vif-nat
 XEN_SCRIPTS += vif2
 XEN_SCRIPTS += vif-setup
diff -Naur xen/tools/hotplug/Linux/init.d/sysconfig.xencommons xen-b/tools/hotplug/Linux/init.d/sysconfig.xencommons
--- xen/tools/hotplug/Linux/init.d/sysconfig.xencommons	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/init.d/sysconfig.xencommons	2013-03-16 22:46:20.409845277 -0600
@@ -8,7 +8,7 @@
 #XENSTORED_TRACE=[yes|on|1]
 
 # Running xenstored on XENSTORED_ROOTDIR
-#XENSTORED_ROOTDIR=/var/lib/xenstored
+XENSTORED_ROOTDIR=/var/lib/xenstored
 
 # Running xenbackendd in debug mode
 #XENBACKENDD_DEBUG=[yes|on|1]
diff -Naur xen/tools/hotplug/Linux/init.d/xen-watchdog xen-b/tools/hotplug/Linux/init.d/xen-watchdog
--- xen/tools/hotplug/Linux/init.d/xen-watchdog	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/init.d/xen-watchdog	2013-03-16 22:46:20.419845278 -0600
@@ -17,49 +17,32 @@
 ### END INIT INFO
 #
 
+. /etc/rc.conf
+. /etc/rc.d/functions
+
 DAEMON=/usr/sbin/xenwatchdogd
 base=$(basename $DAEMON)
+initname="xen-watchdog"
 
-# Source function library.
-if [ -e  /etc/init.d/functions ] ; then
-    . /etc/init.d/functions
-elif [ -e /lib/lsb/init-functions ] ; then
-    . /lib/lsb/init-functions
-    success () {
-        log_success_msg $*
-    }
-    failure () {
-        log_failure_msg $*
-    }
-else
-    success () {
-        echo $*
-    }
-    failure () {
-        echo $*
-    }
-fi
 
 start() {
 	local r
-	echo -n $"Starting domain watchdog daemon: "
+	stat_busy "Starting domain watchdog daemon"
 
 	$DAEMON 30 15
 	r=$?
-	[ "$r" -eq 0 ] && success $"$base startup" || failure $"$base startup"
-	echo
+	[ "$r" -eq 0 ] && stat_done ; add_daemon $initname || stat_fail
 
 	return $r
 }
 
 stop() {
 	local r
-	echo -n $"Stopping domain watchdog daemon: "
+	stat_busy "Stopping domain watchdog daemon"
 
 	killall -USR1 $base 2>/dev/null
 	r=$?
-	[ "$r" -eq 0 ] && success $"$base stop" || failure $"$base stop"
-	echo
+	[ "$r" -eq 0 ] && stat_done ; rm_daemon $initname || stat_fail
 
 	return $r
 }
diff -Naur xen/tools/hotplug/Linux/init.d/xencommons xen-b/tools/hotplug/Linux/init.d/xencommons
--- xen/tools/hotplug/Linux/init.d/xencommons	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/init.d/xencommons	2013-03-16 22:46:20.569845277 -0600
@@ -18,6 +18,9 @@
 # Description:       Starts and stops the daemons neeeded for xl/xend
 ### END INIT INFO
 
+. /etc/rc.conf
+. /etc/rc.d/functions
+
 if [ -d /etc/sysconfig ]; then
 	xencommons_config=/etc/sysconfig
 else
@@ -26,8 +29,8 @@
 
 test -f $xencommons_config/xencommons && . $xencommons_config/xencommons
 
-XENCONSOLED_PIDFILE=/var/run/xenconsoled.pid
-QEMU_PIDFILE=/var/run/qemu-dom0.pid
+XENCONSOLED_PIDFILE=/run/xenconsoled.pid
+QEMU_PIDFILE=/run/qemu-dom0.pid
 shopt -s extglob
 
 # not running in Xen dom0 or domU
@@ -55,22 +58,27 @@
         local time=0
 	local timeout=30
 
-	modprobe xen-evtchn 2>/dev/null
-	modprobe xen-gntdev 2>/dev/null
-	modprobe xen-gntalloc 2>/dev/null
-	modprobe xen-blkback 2>/dev/null
-	modprobe xen-netback 2>/dev/null
-	modprobe xen-pciback 2>/dev/null
-	modprobe evtchn 2>/dev/null
-	modprobe gntdev 2>/dev/null
-	modprobe netbk 2>/dev/null
-	modprobe blkbk 2>/dev/null
-	modprobe xen-scsibk 2>/dev/null
-	modprobe usbbk 2>/dev/null
-	modprobe pciback 2>/dev/null
-	modprobe xen-acpi-processor 2>/dev/null
-	modprobe blktap2 2>/dev/null || modprobe blktap 2>/dev/null
-	mkdir -p /var/run/xen
+	#modprobe xen-evtchn 2>/dev/null
+	#modprobe xen-gntdev 2>/dev/null
+	#modprobe xen-gntalloc 2>/dev/null
+	#modprobe xen-blkback 2>/dev/null
+	#modprobe xen-netback 2>/dev/null
+	#modprobe xen-pciback 2>/dev/null
+	modprobe evtchn 2>/dev/null || true
+	modprobe gntdev 2>/dev/null || true
+	modprobe gntalloc 2>/dev/null || true
+	modprobe netbk 2>/dev/null || true
+	modprobe blkbk 2>/dev/null || true
+	modprobe xen-scsibk 2>/dev/null || true
+	modprobe usbbk 2>/dev/null || true
+	modprobe pciback 2>/dev/null || true
+	modprobe xen-acpi-processor 2>/dev/null || true
+	modprobe blktap2 2>/dev/null || modprobe blktap 2>/dev/null || true
+	# xenblk (frontend module) is needed in dom0, allowing it to use vbds
+	modprobe xenblk 2>/dev/null || true
+	# support xl create pv guest with qcow/qcow2 disk image
+	modprobe nbd max_part=8 2>/dev/null || true
+	mkdir -p /run/xen
 
 	if ! `xenstore-read -s / >/dev/null 2>&1`
 	then
@@ -80,13 +88,14 @@
 
 		if [ -n "$XENSTORED" ] ; then
 		    echo -n Starting $XENSTORED...
-		    $XENSTORED --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+                    mkdir -p /run/xenstored
+		    $XENSTORED --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		elif [ -x /usr/sbin/oxenstored ] ; then
 		    echo -n Starting oxenstored...
-		    /usr/sbin/oxenstored --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+		    /usr/sbin/oxenstored --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		elif [ -x /usr/sbin/xenstored ] ; then
 		    echo -n Starting C xenstored...
-		    /usr/sbin/xenstored --pid-file /var/run/xenstored.pid $XENSTORED_ARGS
+		    /usr/sbin/xenstored --pid-file /run/xenstored.pid $XENSTORED_ARGS
 		else
 		    echo "No xenstored found"
 		    exit 1
@@ -102,15 +111,16 @@
 
 		# Exit if we timed out
 		if ! [ $time -lt $timeout ] ; then
-		    echo Could not start xenstored
+		    stat_fail
 		    exit 1
 		fi
-
-		echo Setting domain 0 name...
+                 stat_done
+		stat_busy "Setting domain 0 name..."
 		xenstore-write "/local/domain/0/name" "Domain-0"
+                stat_done
 	fi
-
-	echo Starting xenconsoled...
+       
+	stat_busy "Starting xenconsoled"
 	test -z "$XENCONSOLED_TRACE" || XENCONSOLED_ARGS=" --log=$XENCONSOLED_TRACE"
 	xenconsoled --pid-file=$XENCONSOLED_PIDFILE $XENCONSOLED_ARGS
 	test -z "$XENBACKENDD_DEBUG" || XENBACKENDD_ARGS="-d"
diff -Naur xen/tools/hotplug/Linux/init.d/xend xen-b/tools/hotplug/Linux/init.d/xend
--- xen/tools/hotplug/Linux/init.d/xend	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/init.d/xend	2013-03-16 22:46:20.583178611 -0600
@@ -1,76 +1,136 @@
 #!/bin/bash
 #
-# xend		Script to start and stop the Xen control daemon.
+# xend		Starts and stops the Xen management daemon
 #
-# Author:       Keir Fraser <keir.fraser@cl.cam.ac.uk>
+# chkconfig: 35 98 01
+# description: Starts and stops the Xen management daemon
 #
-# chkconfig: 2345 98 01
-# description: Starts and stops the Xen control daemon.
 ### BEGIN INIT INFO
 # Provides:          xend
-# Required-Start:    $syslog $remote_fs xenstored xenconsoled 
-# Should-Start:
-# Required-Stop:     $syslog $remote_fs xenstored xenconsoled 
-# Should-Stop:
-# Default-Start:     2 3 5
-# Default-Stop:      0 1 6
-# Short-Description: Start/stop xend
-# Description:       Starts and stops the Xen control daemon.
+# Required-Start:    $syslog $network $remote_fs
+# Should-Start:      iscsi $time
+# Required-Stop:     $syslog $network $remote_fs
+# Should-Stop:       iscsi $time
+# Default-Start:     3 5
+# Default-Stop:      0 1 2 6
+# Short-Description: Starts and stops the Xen management daemon
+# Description:       Starts and stops the Xen management daemon.  xend is needed
+#                    to create and manage VMs on Xen.
 ### END INIT INFO
 
-shopt -s extglob
+. /etc/rc.status
+rc_reset
 
-# Wait for Xend to be up
-function await_daemons_up
+XEND=`pidof -x /usr/sbin/xend`
+
+await_daemons_up()
 {
 	i=1
 	rets=10
 	xend status
 	while [ $? -ne 0 -a $i -lt $rets ]; do
-	    sleep 1
-	    echo -n .
-	    i=$(($i + 1))
-	    xend status
+		sleep 1
+		echo -n .
+		i=$(($i + 1))
+		xend status
 	done
 }
 
+xend_abort()
+{
+	echo -n "xend "
+	rc_failed $1
+	rc_status -v
+	rc_exit
+}
+
+cleanup()
+{
+	rm -f /var/lib/xen/tmp/* 2>/dev/null
+	rm -f /var/lib/xen/xenbl* 2>/dev/null
+}
+
+check()
+{
+	if [ "$1" == status ]; then
+		if [ ! -e /proc/xen/capabilities ]; then
+			xend_abort 3
+		fi
+	else
+		if [ `id -u` != 0 ]; then
+			xend_abort 4
+		fi
+		if [ ! -e /proc/xen/capabilities ] ||
+		     ! grep control_d /proc/xen/capabilities >/dev/null 2>&1; then
+			if [ "$1" == stop ] ||
+			   [ "$1" == try-restart ]; then
+				xend_abort 0
+			else
+				xend_abort 6
+			fi
+		fi
+	fi
+}
+
 case "$1" in
   start)
-	if [ -z "`ps -C xenconsoled -o pid=`" ]; then
-		echo "xencommons should be started first."
-		exit 1
-	fi
-	# mkdir shouldn't be needed as most distros have this already created. Default to using subsys.
-	# See docs/misc/distro_mapping.txt
-	mkdir -p /var/lock
-	if [ -d /var/lock/subsys ] ; then
-		touch /var/lock/subsys/xend
+	check $1
+	echo -n "Starting xend "
+	if [ ! -z "$XEND" ]; then
+		echo -n "(already running pid $XEND) "
 	else
-		touch /var/lock/xend
+		cleanup
 	fi
 	xend start
 	await_daemons_up
 	;;
   stop)
-	xend stop
-	rm -f /var/lock/subsys/xend /var/lock/xend
+	check $1
+	echo -n "Stopping xend "
+	if [ -z "$XEND" ]; then
+		echo -n "(not running) "
+		xend stop
+		rc_reset
+	else
+		echo -n "(pid $XEND) "
+		xend stop
+		cleanup
+		rc_reset
+	fi
 	;;
   status)
-	xend status
+	check $1
+	echo -n "Checking status of xend "
+	if [ ! -z "$XEND" ]; then
+		echo -n "(pid $XEND) "
+	fi
+	checkproc /usr/sbin/xend
 	;;
-  reload)
-        xend reload
-        ;;
-  restart|force-reload)
+  restart|reload)
+	check $1
+	echo -n "Restarting xend "
+	if [ -z "$XEND" ]; then
+		echo -n "(not running) "
+	else
+		echo -n "(old pid $XEND) "
+	fi
 	xend restart
 	await_daemons_up
 	;;
+  try-restart)
+	check $1
+	$0 status
+	if [ $? = 0 ]; then
+		$0 restart
+	else
+		rc_reset
+	fi
+	;;
   *)
-	# do not advertise unreasonable commands that there is no reason
-	# to use with this device
-	echo $"Usage: $0 {start|stop|status|restart|reload|force-reload}"
-	exit 1
+	echo "Usage: $0 {start|stop|restart|try-restart|reload|status}"
+	rc_failed 2
+	rc_exit
 esac
 
-exit $?
-
+rc_status -v
+rc_exit
diff -Naur xen/tools/hotplug/Linux/init.d/xendomains xen-b/tools/hotplug/Linux/init.d/xendomains
--- xen/tools/hotplug/Linux/init.d/xendomains	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/init.d/xendomains	2013-03-16 22:46:21.159845277 -0600
@@ -1,60 +1,38 @@
 #!/bin/bash
 #
-# /etc/init.d/xendomains
-# Start / stop domains automatically when domain 0 boots / shuts down.
+# xendomains	Starts and stops Xen VMs
 #
-# chkconfig: 345 99 00
-# description: Start / stop Xen domains.
-#
-# This script offers fairly basic functionality.  It should work on Redhat
-# but also on LSB-compliant SuSE releases and on Debian with the LSB package
-# installed.  (LSB is the Linux Standard Base)
-#
-# Based on the example in the "Designing High Quality Integrated Linux
-# Applications HOWTO" by Avi Alkalay
-# <http://www.tldp.org/HOWTO/HighQuality-Apps-HOWTO/>
+# chkconfig: 35 99 00
+# description: Starts and stops Xen VMs
 #
 ### BEGIN INIT INFO
 # Provides:          xendomains
 # Required-Start:    $syslog $remote_fs xenstored xenconsoled
-# Should-Start:      xend
+# Should-Start:      xend iscsi o2cb ocfs2
 # Required-Stop:     $syslog $remote_fs xenstored xenconsoled
-# Should-Stop:       xend
-# Default-Start:     2 3 5
-# Default-Stop:      0 1 6
-# Short-Description: Start/stop secondary xen domains
-# Description:       Start / stop domains automatically when domain 0 
-#                    boots / shuts down.
+# Should-Stop:       xend iscsi
+# Default-Start:     3 5
+# Default-Stop:      0 1 2 6
+# Short-Description: Starts and stops Xen VMs
+# Description:       Starts and stops Xen VMs automatically when the
+#                    host starts and stops.
 ### END INIT INFO
 
-CMD=xm
-$CMD list &> /dev/null
-if test $? -ne 0
-then
-	CMD=xl
-fi
-
-$CMD list &> /dev/null
-if test $? -ne 0
-then
-	exit 0;
-fi
+. /etc/rc.status
+rc_reset
 
-# Correct exit code would probably be 5, but it's enough 
-# if xend complains if we're not running as privileged domain
-if ! [ -e /proc/xen/privcmd ]; then
-	exit 0
-fi
+RETCODE_FILE=/tmp/xendomains.rc.$$
+xm_cmd=echo
 
 # See docs/misc/distro_mapping.txt
-if [ -d /var/lock/subsys ]; then
-	LOCKFILE=/var/lock/subsys/xendomains
+if [ -d /run/lock/subsys ]; then
+	LOCKFILE=/run/lock/subsys/xendomains
 else
-	LOCKFILE=/var/lock/xendomains
+	LOCKFILE=/run/lock/xendomains
 fi
 
-if [ -d /etc/sysconfig ]; then
-	XENDOM_CONFIG=/etc/sysconfig/xendomains
+if [ -d /etc/conf.d ]; then
+	XENDOM_CONFIG=/etc/conf.d/xendomains
 else
 	XENDOM_CONFIG=/etc/default/xendomains
 fi
@@ -63,518 +41,470 @@
 	if [ "$1" = "stop" ]; then exit 0;
 	else exit 6; fi; }
 
-. $XENDOM_CONFIG
+. "$XENDOM_CONFIG"
+
+shopt -s dotglob nullglob
 
-# Use the SUSE rc_ init script functions;
-# emulate them on LSB, RH and other systems
-if test -e /etc/rc.status; then
-    # SUSE rc script library
-    . /etc/rc.status
-else    
-    _cmd=$1
-    declare -a _SMSG
-    if test "${_cmd}" = "status"; then
-	_SMSG=(running dead dead unused unknown)
-	_RC_UNUSED=3
-    else
-	_SMSG=(done failed failed missed failed skipped unused failed failed)
-	_RC_UNUSED=6
-    fi
-    if test -e /etc/init.d/functions; then
-	# REDHAT
-	. /etc/init.d/functions
-	echo_rc()
+smart_term=1
+if [ -z "$esc" ]; then
+	smart_term=0
+	rc_timer_on()
 	{
-	    #echo -n "  [${_SMSG[${_RC_RV}]}] "
-	    if test ${_RC_RV} = 0; then
-		success "  [${_SMSG[${_RC_RV}]}] "
-	    else
-		failure "  [${_SMSG[${_RC_RV}]}] "
-	    fi
+		(trap "exit 0" TERM; sleep $1) & _rc_timer_pid=$!
 	}
-    elif test -e /lib/lsb/init-functions; then
-	# LSB    
-    	. /lib/lsb/init-functions
-        if alias log_success_msg >/dev/null 2>/dev/null; then
-	  echo_rc()
-	  {
-	       echo "  [${_SMSG[${_RC_RV}]}] "
-	  }
-        else
-	  echo_rc()
-	  {
-	    if test ${_RC_RV} = 0; then
-		log_success_msg "  [${_SMSG[${_RC_RV}]}] "
-	    else
-		log_failure_msg "  [${_SMSG[${_RC_RV}]}] "
-	    fi
-	  }
-        fi
-    else    
-	# emulate it
-	echo_rc()
+	rc_timer_off()
 	{
-	    echo "  [${_SMSG[${_RC_RV}]}] "
+		if [ -n "$_rc_timer_pid" ]; then
+			kill -TERM $_rc_timer_pid > /dev/null 2>&1
+		fi
+		unset _rc_timer_pid
 	}
-    fi
-    rc_reset() { _RC_RV=0; }
-    rc_failed()
-    {
-	if test -z "$1"; then 
-	    _RC_RV=1;
-	elif test "$1" != "0"; then 
-	    _RC_RV=$1; 
-    	fi
-	return ${_RC_RV}
-    }
-    rc_check()
-    {
-	return rc_failed $?
-    }	
-    rc_status()
-    {
-	rc_failed $?
-	if test "$1" = "-r"; then _RC_RV=0; shift; fi
-	if test "$1" = "-s"; then rc_failed 5; echo_rc; rc_failed 3; shift; fi
-	if test "$1" = "-u"; then rc_failed ${_RC_UNUSED}; echo_rc; rc_failed 3; shift; fi
-	if test "$1" = "-v"; then echo_rc; shift; fi
-	if test "$1" = "-r"; then _RC_RV=0; shift; fi
-	return ${_RC_RV}
-    }
-    rc_exit() { exit ${_RC_RV}; }
-    rc_active() 
-    {
-	if test -z "$RUNLEVEL"; then read RUNLEVEL REST < <(/sbin/runlevel); fi
-	if test -e /etc/init.d/S[0-9][0-9]${1}; then return 0; fi
-	return 1
-    }
-fi
-
-if ! which usleep >&/dev/null
-then
-  usleep()
-  {
-    if [ -n "$1" ]
-    then
-      sleep $(( $1 / 1000000 ))
-    fi
-  }
 fi
 
-# Reset status of this service
-rc_reset
+xendomains_abort()
+{
+	echo -n "xendomains "
+	rc_failed $1
+	rc_status -v
+	rc_exit
+}
 
-##
-# Returns 0 (success) if the given parameter names a directory, and that
-# directory is not empty.
-#
-contains_something()
+check()
 {
-  if [ -d "$1" ] && [ `/bin/ls $1 | wc -l` -gt 0 ]
-  then
-    return 0
-  else
-    return 1
-  fi
-}
-
-# read name from xen config file
-rdname()
-{
-    NM=$($CMD create --quiet --dryrun --defconfig "$1" |
-         sed -n 's/^.*(name \(.*\))$/\1/p')
-}
-
-rdnames()
-{
-    NAMES=
-    if ! contains_something "$XENDOMAINS_AUTO"
-    then 
-	return
-    fi
-    for dom in $XENDOMAINS_AUTO/*; do
-	rdname $dom
-	if test -z $NAMES; then 
-	    NAMES=$NM; 
+	XEND=`pidof -x /usr/sbin/xend`
+	if [ -z "$XEND" ]; then
+		xm_cmd="xl -f"
+		XEND="xl"
+	else
+		xm_cmd="xm"
+	fi
+	if [ "$1" = status ]; then
+		if [ ! -e /proc/xen/capabilities ] || [ ! -r "$XENDOM_CONFIG" ] || [ -z "$XEND" ]; then
+			xendomains_abort 3
+		fi
 	else
-	    NAMES="$NAMES|$NM"
+		if [ `id -u` != 0 ]; then
+			xendomains_abort 4
+		fi
+		if [ ! -e /proc/xen/capabilities ] || [ -z "$XEND" ] ||
+		     ! grep control_d /proc/xen/capabilities >/dev/null 2>&1; then
+			if [ "$1" = stop ] ||
+			   [ "$1" = restart ]; then
+				xendomains_abort 0
+			else
+				xendomains_abort 6
+			fi
+		fi
+		if [ ! -r "$XENDOM_CONFIG" ]; then
+			xendomains_abort 6
+		fi
 	fi
-    done
 }
 
-LIST_GREP='((domain\|(domid\|(name\|^{$\|"name":\|"domid":'
+dir_contains_something()
+{
+        [ -d "$1" ] || return 1
+	local dirfiles=( "$1"/* )
+	[ ${#dirfiles[@]} != 0 ]
+}
+
+get_name_from_cfg()
+{
+	if grep -q "^name" "$1";then
+		NM=`grep '^name[	 ]*=' "$1" | sed -e 's/^name[	 ]*=[	 ]*['\''"]\([^'\''"]*\)['\''"].*$/\1/'`
+	elif grep -q "(name " "$1";then
+		NM=`grep '(name ' "$1" | sed -e 's/^ *//' | cut -d " " -f 2 | sed -e 's/)//'`
+	fi
+}
+
+running_auto_names()
+{
+	unset AUTONAMES[@]
+	if ! dir_contains_something "$XENDOMAINS_AUTO"; then
+		return
+	fi
+	for dom in "$XENDOMAINS_AUTO"/*; do
+		get_name_from_cfg "$dom"
+		AUTONAMES+=("$NM")
+	done
+}
+
 parseln()
 {
-    if [[ "$1" =~ '(domain' ]] || [[ "$1" = "{" ]]; then
-        name=;id=
-    elif [[ "$1" =~ '(name' ]]; then
-        name=$(echo $1 | sed -e 's/^.*(name \(.*\))$/\1/')
-    elif [[ "$1" =~ '(domid' ]]; then
-        id=$(echo $1 | sed -e 's/^.*(domid \(.*\))$/\1/')
-    elif [[ "$1" =~ '"name":' ]]; then
-        name=$(echo $1 | sed -e 's/^.*"name": "\(.*\)",$/\1/')
-    elif [[ "$1" =~ '"domid":' ]]; then
-        id=$(echo $1 | sed -e 's/^.*"domid": \(.*\),$/\1/')
-    fi
-
-    [ -n "$name" -a -n "$id" ] && return 0 || return 1
-}
-
-is_running()
-{
-    rdname $1
-    RC=1
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	case $name in 
-	    ($NM)
-		RC=0
-		;;
-	esac
-    done < <($CMD list -l | grep $LIST_GREP)
-    return $RC
-}
-
-start() 
-{
-    if [ -f $LOCKFILE ]; then 
-	echo -e "xendomains already running (lockfile exists)"
-	return; 
-    fi
-
-    saved_domains=" "
-    if [ "$XENDOMAINS_RESTORE" = "true" ] &&
-       contains_something "$XENDOMAINS_SAVE"
-    then
-	mkdir -p $(dirname "$LOCKFILE")
-	touch $LOCKFILE
-	echo -n "Restoring Xen domains:"
-	saved_domains=`ls $XENDOMAINS_SAVE`
-        for dom in $XENDOMAINS_SAVE/*; do
-            if [ -f $dom ] ; then
-                HEADER=`head -c 16 $dom | head -n 1 2> /dev/null`
-                if [ $HEADER = "LinuxGuestRecord" ]; then
-                    echo -n " ${dom##*/}"
-                    XMR=`$CMD restore $dom 2>&1 1>/dev/null`
-                    #$CMD restore $dom
-                    if [ $? -ne 0 ]; then
-                        echo -e "\nAn error occurred while restoring domain ${dom##*/}:\n$XMR"
-                        rc_failed $?
-                        echo -e '!'
-                    else
-                        # mv $dom ${dom%/*}/.${dom##*/}
-                        rm $dom
-                    fi
-                fi
-            fi
-        done
-	echo -e
-    fi
-
-    if contains_something "$XENDOMAINS_AUTO"
-    then
-	touch $LOCKFILE
-	echo -n "Starting auto Xen domains:"
-	# We expect config scripts for auto starting domains to be in
-	# XENDOMAINS_AUTO - they could just be symlinks to files elsewhere
-
-	# Create all domains with config files in XENDOMAINS_AUTO.
-	# TODO: We should record which domain name belongs 
-	# so we have the option to selectively shut down / migrate later
-	# If a domain statefile from $XENDOMAINS_SAVE matches a domain name
-	# in $XENDOMAINS_AUTO, do not try to start that domain; if it didn't 
-	# restore correctly it requires administrative attention.
-	for dom in $XENDOMAINS_AUTO/*; do
-	    echo -n " ${dom##*/}"
-	    shortdom=$(echo $dom | sed -n 's/^.*\/\(.*\)$/\1/p')
-	    echo $saved_domains | grep -w $shortdom > /dev/null
-	    if [ $? -eq 0 ] || is_running $dom; then
-		echo -n "(skip)"
-	    else
-		XMC=`$CMD create --quiet --defconfig $dom`
-		if [ $? -ne 0 ]; then
-		    echo -e "\nAn error occurred while creating domain ${dom##*/}: $XMC\n"
-		    rc_failed $?
-		    echo -e '!'
-		else
-		    usleep $XENDOMAINS_CREATE_USLEEP
+	name=${1:0:$((${#1}-36))}
+	name=${name%% *}
+	rest="${1: -36}"
+	id=${rest:0:4}
+	id=`echo $id`
+	mem=${rest:4:6}
+	mem=`echo $mem`
+	vcpu=${rest:10:6}
+	vcpu=`echo $vcpu`
+	state=${rest:16:11}
+	state=`echo $state`
+	tm=${rest:27}
+	tm=`echo $tm`
+}
+
+xm_list()
+{
+	TERM=vt100 ${xm_cmd} list | grep -v '^Name *ID'
+}
+
+is_cfg_running()
+{
+	get_name_from_cfg "$1"
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		if [ "$name" = "$NM" ]; then
+			[ -z "$state" ] && return 1
+			return 0
 		fi
-	    fi
-	done
-    fi
+	done < <(xm_list)
+	return 1
+}
+
+start()
+{
+	if [ -f "$LOCKFILE" ]; then
+		echo -n "xendomains already running (lockfile exists)"
+		rc_reset
+		rc_status -v
+		return 0
+	fi
+
+	local printed=0
+
+	if [ "$XENDOMAINS_RESTORE" = "true" ] &&
+	   dir_contains_something "$XENDOMAINS_SAVE"; then
+		mkdir -p $(dirname "$LOCKFILE")
+		touch "$LOCKFILE"
+		echo "Restoring saved Xen domains"
+		printed=1
+		for dom in "$XENDOMAINS_SAVE"/*; do
+			echo -n "	${dom##*/}: "
+			${xm_cmd} restore "$dom" >/dev/null 2>&1
+			if [ $? -ne 0 ]; then
+				rc_failed
+			else
+				rc_reset
+				rm -f "$dom"
+			fi
+			rc_status -v
+		done
+	fi
+
+	if dir_contains_something "$XENDOMAINS_AUTO"; then
+		touch "$LOCKFILE"
+		echo "Starting auto Xen domains"
+		printed=1
+		for dom in "$XENDOMAINS_AUTO"/*; do
+			echo -n "	${dom##*/}: "
+			if is_cfg_running "$dom"; then
+				rc_status -s
+			else
+				if grep -q "^name" "$dom";then
+					${xm_cmd} create --quiet --defconfig "$dom"
+				elif grep -q "(name .*" "$dom";then
+					${xm_cmd} create --quiet --config "$dom"
+				fi
+				if [ $? -ne 0 ]; then
+				    rc_failed
+				else
+				    usleep $XENDOMAINS_CREATE_USLEEP
+				    rc_reset
+				fi
+				rc_status -v
+			fi
+		done
+	fi
+
+	if [ $printed -eq 0 ]; then
+		echo -n "Starting xendomains"
+		rc_failed 6  # not configured
+		rc_status -v
+	fi
+}
+
+is_zombie_state()
+{
+	[ "$1" = "-b---d" ] || [ "$1" = "-----d" ]
+}
+
+any_non_zombies()
+{
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		[ -z "$state" ] && continue
+		is_zombie_state "$state" || return 0
+	done < <(xm_list)
+	return 1
 }
 
-all_zombies()
+migrate_with_watchdog()
 {
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	if test "$state" != "-b---d" -a "$state" != "-----d"; then
-	    return 1;
-	fi
-    done < <($CMD list -l | grep $LIST_GREP)
-    return 0
-}
-
-# Wait for max $XENDOMAINS_STOP_MAXWAIT for $CMD $1 to finish;
-# if it has not exited by that time kill it, so the init script will
-# succeed within a finite amount of time; if $2 is nonnull, it will
-# kill the command as well as soon as no domain (except for zombies)
-# are left (used for shutdown --all). Third parameter, if any, suppresses
-# output of dots per working state (formatting issues)
-watchdog_xencmd()
-{
-    if test -z "$XENDOMAINS_STOP_MAXWAIT" -o "$XENDOMAINS_STOP_MAXWAIT" = "0"; then
-	exit
-    fi
-
-    usleep 20000
-    for no in `seq 0 $XENDOMAINS_STOP_MAXWAIT`; do
-	# exit if $CMD save/migrate/shutdown is finished
-	PSAX=`ps axlw | grep "$CMD $1" | grep -v grep`
-	if test -z "$PSAX"; then exit; fi
-	if ! test -n "$3"; then echo -n '.'; fi
-	sleep 1
-	# go to kill immediately if there's only zombies left
-	if all_zombies && test -n "$2"; then break; fi
-    done
-    sleep 1
-    read PSF PSUID PSPID PSPPID < <(echo "$PSAX")
-    # kill $CMD $1
-    kill $PSPID >/dev/null 2>&1
-    
-    echo -e .
+	(${xm_cmd} migrate "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+save_with_watchdog()
+{
+	(${xm_cmd} save "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+shutdown_with_watchdog()
+{
+	(${xm_cmd} shutdown -w "$@" ; echo $? > "$RETCODE_FILE") >/dev/null 2>&1 &
+	watchdog_xm $!
+}
+
+get_return_code()
+{
+	local RC=127
+	[ -r "$RETCODE_FILE" ] && RC=`head -c10 "$RETCODE_FILE"`
+	rm -f "$RETCODE_FILE"
+	return $RC
+}
+
+#  $1:  The PID to wait on.
+watchdog_xm()
+{
+	local col=$((COLUMNS-11))
+	if [ -z "$XENDOMAINS_STOP_MAXWAIT" ] || [ "$XENDOMAINS_STOP_MAXWAIT" = "0" ]; then
+		wait $1 >/dev/null 2>&1
+		get_return_code
+		return
+	fi
+
+	rc_timer_on $XENDOMAINS_STOP_MAXWAIT $col
+	while true; do
+		# Prefer "jobs" over "ps":  faster and no false positives
+		pid=`jobs -l | grep " $1 Running"`
+		if [ -z "$pid" ]; then
+			break
+		fi
+		pid=`jobs -l | grep " $_rc_timer_pid Running"`
+		if [ -z "$pid" ]; then
+			disown $1  # To avoid the "Terminated..." message
+			kill $1 >/dev/null 2>&1
+		fi
+		sleep 1
+	done
+	rc_timer_off
+	if [ $smart_term -ne 0 ]; then
+		echo -en "\015${esc}[${col}C      "
+	fi
+	get_return_code
 }
 
 stop()
 {
-    exec 3>&2 2> /dev/null
-    
-    # Collect list of domains to shut down
-    if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
-	rdnames
-    fi
-    echo -n "Shutting down Xen domains:"
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	echo -n " $name"
-	if test "$XENDOMAINS_AUTO_ONLY" = "true"; then
-	    eval "
-	    case \"\$name\" in
-		($NAMES)
-		    # nothing
-		    ;;
-		(*)
-		    echo -e '(skip)'
-		    continue
-		    ;;
-	    esac
-	    "
-	fi
-	# XENDOMAINS_SYSRQ chould be something like just "s" 
-	# or "s e i u" or even "s e s i u o"
-	# for the latter, you should set XENDOMAINS_USLEEP to 1200000 or so
-	if test -n "$XENDOMAINS_SYSRQ"; then
-	    for sysrq in $XENDOMAINS_SYSRQ; do
-		echo -n "(SR-$sysrq)"
-		XMR=`$CMD sysrq $id $sysrq 2>&1 1>/dev/null`
-		if test $? -ne 0; then
-		    echo -e "\nAn error occurred while doing sysrq on domain:\n$XMR\n"
-		    rc_failed $?
-		    echo -n '!'
-		fi
-		# usleep just ignores empty arg
-		usleep $XENDOMAINS_USLEEP
-	    done
-	fi
-	if test "$state" = "-b---d" -o "$state" = "-----d"; then
-	    echo -n "(zomb)"
-	    continue
-	fi
-	if test -n "$XENDOMAINS_MIGRATE"; then
-	    echo -n "(migr)"
-	    watchdog_xencmd migrate &
-	    WDOG_PID=$!
-	    XMR=`$CMD migrate $id $XENDOMAINS_MIGRATE 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while migrating domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-
-		kill $WDOG_PID >/dev/null 2>&1
-	    else
-		kill $WDOG_PID >/dev/null 2>&1
-		
-		echo -e .
-		usleep 1000
-		continue
-	    fi
-	fi
-	if test -n "$XENDOMAINS_SAVE"; then
-	    echo -n "(save)"
-	    watchdog_xencmd save &
-	    WDOG_PID=$!
-	    mkdir -p "$XENDOMAINS_SAVE"
-	    XMR=`$CMD save $id $XENDOMAINS_SAVE/$name 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while saving domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-		kill $WDOG_PID >/dev/null 2>&1
-	    else
-		kill $WDOG_PID >/dev/null 2>&1
-		echo -e .
-		usleep 1000
-		continue
-	    fi
-	fi
-	if test -n "$XENDOMAINS_SHUTDOWN"; then
-	    # XENDOMAINS_SHUTDOWN should be "--wait"
-	    echo -n "(shut)"
-	    watchdog_xencmd shutdown &
-	    WDOG_PID=$!
-	    XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN $id 2>&1 1>/dev/null`
-	    if test $? -ne 0; then
-		echo -e "\nAn error occurred while shutting down domain:\n$XMR\n"
-		rc_failed $?
-		echo -e '!'
-	    fi
-	    kill $WDOG_PID >/dev/null 2>&1
-	fi
-    done < <($CMD list -l | grep $LIST_GREP)
-
-    # NB. this shuts down ALL Xen domains (politely), not just the ones in
-    # AUTODIR/*
-    # This is because it's easier to do ;-) but arguably if this script is run
-    # on system shutdown then it's also the right thing to do.
-    if ! all_zombies && test -n "$XENDOMAINS_SHUTDOWN_ALL"; then
-	# XENDOMAINS_SHUTDOWN_ALL should be "--all --wait"
-	echo -n " SHUTDOWN_ALL "
-	watchdog_xencmd shutdown 1 false &
-	WDOG_PID=$!
-	XMR=`$CMD shutdown $XENDOMAINS_SHUTDOWN_ALL 2>&1 1>/dev/null`
-	if test $? -ne 0; then
-	    echo -e "\nAn error occurred while shutting down all domains: $XMR\n"
-	    rc_failed $?
-	    echo -e '!'
-	fi
-	kill $WDOG_PID >/dev/null 2>&1
-    fi
-
-    # Unconditionally delete lock file
-    rm -f $LOCKFILE
-    
-    exec 2>&3
+	echo "Shutting down Xen domains"
+	if [ "$XENDOMAINS_AUTO_ONLY" = "true" ]; then
+		running_auto_names
+	fi
+	local printed=0
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		[ -z "$state" ] && continue
+		printed=1
+		if [ "$XENDOMAINS_AUTO_ONLY" = "true" ]; then
+			is_auto_domain=0
+			for n in "${AUTONAMES[@]}"; do
+				if [ "$name" = "$n" ]; then
+					is_auto_domain=1
+					break
+				fi
+			done
+			if [ $is_auto_domain -eq 0 ]; then
+				echo -n "	$name: "
+				rc_status -s
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SYSRQ" ]; then
+			for sysrq in $XENDOMAINS_SYSRQ; do
+				echo -n "	$name: "
+				echo -n "sending sysrq '$sysrq'... "
+				${xm_cmd} sysrq $id $sysrq
+				if [ $? -ne 0 ]; then
+					rc_failed
+				else
+					rc_reset
+				fi
+				rc_status -v
+				# usleep just ignores empty arg
+				usleep $XENDOMAINS_USLEEP
+			done
+		fi
+		if is_zombie_state "$state"; then
+			echo -n "	$name: "
+			echo -n "destroying zombie... "
+			${xm_cmd} destroy $id
+			rc_reset
+			rc_status -v
+			continue
+		fi
+		if [ -n "$XENDOMAINS_MIGRATE" ]; then
+			echo -n "	$name: "
+			echo -n "migrating... "
+			migrate_with_watchdog $id "$XENDOMAINS_MIGRATE"
+			if [ $? -ne 0 ]; then
+				rc_failed
+				rc_status -v
+			else
+				rc_reset
+				rc_status -v
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SAVE" ]; then
+			echo -n "	$name: "
+			echo -n "saving... "
+			save_with_watchdog $id "$XENDOMAINS_SAVE/$name"
+			if [ $? -ne 0 ]; then
+				rm -f "$XENDOMAINS_SAVE/$name"
+				rc_failed
+				rc_status -v
+			else
+				rc_reset
+				rc_status -v
+				continue
+			fi
+		fi
+		if [ -n "$XENDOMAINS_SHUTDOWN" ]; then
+			echo -n "	$name: "
+			echo -n "shutting down... "
+			shutdown_with_watchdog $id $XENDOMAINS_SHUTDOWN
+			if [ $? -ne 0 ]; then
+				rc_failed
+			else
+				rc_reset
+			fi
+			rc_status -v
+		fi
+	done < <(xm_list)
+
+	if [ -n "$XENDOMAINS_SHUTDOWN_ALL" ] && any_non_zombies ; then
+		echo -n "	others: shutting down... "
+		shutdown_with_watchdog $XENDOMAINS_SHUTDOWN_ALL
+		if [ $? -ne 0 ]; then
+			rc_failed
+		else
+			rc_reset
+		fi
+		rc_status -v
+	fi
+
+	if [ $printed -eq 0 ]; then
+		echo -e "${rc_done_up}"
+	fi
+
+	# Unconditionally delete lock file
+	rm -f "$LOCKFILE"
 }
 
 check_domain_up()
 {
-    name=;id=
-    while read LN; do
-	parseln "$LN" || continue
-	if test $id = 0; then continue; fi
-	case $name in 
-	    ($1)
-		return 0
-		;;
-	esac
-    done < <($CMD list -l | grep $LIST_GREP)
-    return 1
-}
-
-check_all_auto_domains_up()
-{
-    if ! contains_something "$XENDOMAINS_AUTO"
-    then
-      return 0
-    fi
-    missing=
-    for nm in $XENDOMAINS_AUTO/*; do
-	rdname $nm
-	found=0
-	if check_domain_up "$NM"; then 
-	    echo -n " $name"
-	else 
-	    missing="$missing $NM"
-	fi
-    done
-    if test -n "$missing"; then
-	echo -n " MISS AUTO:$missing"
+	while read LN; do
+		parseln "$LN"
+		[ "$id" = 0 ] && continue
+		if [ "$name" = "$1" ]; then
+			[ -z "$state" ] && return 1
+			return 0
+		fi
+	done < <(xm_list)
 	return 1
-    fi
-    return 0
 }
 
-check_all_saved_domains_up()
+check_all_domains_up()
 {
-    if ! contains_something "$XENDOMAINS_SAVE" 
-    then
-      return 0
-    fi
-    missing=`/bin/ls $XENDOMAINS_SAVE`
-    echo -n " MISS SAVED: " $missing
-    return 1
+	any_auto=0
+	any_save=0
+	dir_contains_something "$XENDOMAINS_AUTO" && any_auto=1
+	dir_contains_something "$XENDOMAINS_SAVE" && any_save=1
+	if [ $any_auto -eq 0 ] && [ $any_save -eq 0 ]; then
+		rc_reset
+		rc_status -v
+		return
+	fi
+	echo
+	if [ $any_auto -ne 0 ]; then
+		for nm in "$XENDOMAINS_AUTO"/*; do
+			get_name_from_cfg "$nm"
+			echo -n "	$nm: "
+			if check_domain_up "$NM"; then
+				rc_reset
+			else
+				rc_failed 2
+			fi
+			rc_status -v
+		done
+	fi
+	if [ $any_save -ne 0 ]; then
+		for nm in "$XENDOMAINS_SAVE"/*; do
+			echo -n "	$nm: "
+			rc_failed 3
+			rc_status -v
+		done
+	fi
 }
 
 # This does NOT necessarily restart all running domains: instead it
 # stops all running domains and then boots all the domains specified in
 # AUTODIR.  If other domains have been started manually then they will
 # not get restarted.
-# Commented out to avoid confusion!
-
 restart()
 {
-    stop
-    start
-}
-
-reload()
-{
-    restart
+	"$0" stop
+	start
 }
 
-
 case "$1" in
-    start)
+ start)
+	check $1
 	start
-	rc_status
-	if test -f $LOCKFILE; then rc_status -v; fi
 	;;
 
-    stop)
+ stop)
+	check $1
 	stop
-	rc_status -v
 	;;
 
-    restart)
+ restart|reload)
+	check $1
 	restart
 	;;
-    reload)
-	reload
+
+ try-restart)
+	check $1
+	"$0" status
+	if [ $? = 0 ]; then
+		"$0" restart
+	else
+		rc_reset
+		rc_status -v
+	fi
 	;;
 
-    status)
-	echo -n "Checking for xendomains:" 
-	if test ! -f $LOCKFILE; then 
-	    rc_failed 3
+ status)
+	check $1
+	echo -n "Checking status of Xen domains"
+	if [ ! -f "$LOCKFILE" ]; then
+		rc_failed 3
+		rc_status -v
 	else
-	    check_all_auto_domains_up
-	    rc_status
-	    check_all_saved_domains_up
-	    rc_status
+		check_all_domains_up
 	fi
-	rc_status -v
 	;;
 
-    *)
-	echo "Usage: $0 {start|stop|restart|reload|status}"
-	rc_failed 3
-	rc_status -v
+ *)
+	echo "Usage: $0 {start|stop|restart|try-restart|reload|status}"
+	rc_failed 2
 	;;
 esac
 
diff -Naur xen/tools/hotplug/Linux/locking.sh xen-b/tools/hotplug/Linux/locking.sh
--- xen/tools/hotplug/Linux/locking.sh	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/locking.sh	2013-03-16 22:46:21.159845277 -0600
@@ -20,7 +20,7 @@
 # Serialisation
 #
 
-LOCK_BASEDIR=/var/run/xen-hotplug
+LOCK_BASEDIR=/run/xen-hotplug
 
 _setlockfd()
 {
diff -Naur xen/tools/hotplug/Linux/network-bridge xen-b/tools/hotplug/Linux/network-bridge
--- xen/tools/hotplug/Linux/network-bridge	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/network-bridge	2013-03-16 22:56:05.246511944 -0600
@@ -280,19 +280,19 @@
     transfer_addrs ${bridge} ${pdev}
     if ! ifdown ${bridge}; then
 	get_ip_info ${bridge}
-    fi
-    ip link set ${pdev} down
-    ip addr flush ${bridge}
+	ip link set ${pdev} down
+	ip addr flush ${bridge}
 
-    brctl delif ${bridge} ${pdev}
-    ip link set ${bridge} down
+	brctl delif ${bridge} ${pdev}
+	ip link set ${bridge} down
 
-    ip link set ${bridge} name ${tdev}
+	ip link set ${bridge} name ${tdev}
+	brctl delbr ${tdev}
+    fi
+    ip link set ${pdev} down
     ip link set ${pdev} name ${netdev}
     do_ifup ${netdev}
 
-    brctl delbr ${tdev}
-
     release_lock "network-bridge"
 }
 
diff -Naur xen/tools/hotplug/Linux/vif-bridge xen-b/tools/hotplug/Linux/vif-bridge
--- xen/tools/hotplug/Linux/vif-bridge	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/vif-bridge	2013-03-16 23:03:06.913178611 -0600
@@ -32,6 +32,13 @@
 dir=$(dirname "$0")
 . "$dir/vif-common.sh"
 
+mac=$(xenstore_read_default "$XENBUS_PATH/mac" "")
+if [ -z "$mac" ]
+then
+    log debug "No device details in $XENBUS_PATH, exiting."
+    exit 0
+fi
+
 bridge=${bridge:-}
 bridge=$(xenstore_read_default "$XENBUS_PATH/bridge" "$bridge")
 
diff -Naur xen/tools/hotplug/Linux/vif-route-ifup xen-b/tools/hotplug/Linux/vif-route-ifup
--- xen/tools/hotplug/Linux/vif-route-ifup	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/hotplug/Linux/vif-route-ifup	2013-03-16 23:02:10.993178611 -0600
@@ -0,0 +1,34 @@
+#!/bin/bash
+#============================================================================
+# /etc/xen/vif-route-ifup
+#
+# Script for configuring a vif in routed mode.
+# The hotplugging system will call this script if it is specified either in
+# the device configuration given to Xend, or the default Xend configuration
+# in /etc/xen/xend-config.sxp.  If the script is specified in neither of those
+# places, then vif-bridge is the default.
+#
+# Usage:
+# vif-route-ifup (add|remove|online|offline)
+#
+# Environment vars:
+# dev         vif interface name (required).
+#============================================================================
+
+dir=$(dirname "$0")
+. "$dir/vif-common.sh"
+
+case "$command" in
+    online)
+        ifup ${dev}
+        ;;
+    offline)
+        do_without_error ifdown ${dev}
+        ;;
+esac
+
+log debug "Successful vif-route-ifup $command for ${dev}."
+if [ "$command" = "online" ]
+then
+  success
+fi
diff -Naur xen/tools/hotplug/Linux/xend.rules xen-b/tools/hotplug/Linux/xend.rules
--- xen/tools/hotplug/Linux/xend.rules	2013-03-09 18:06:25.983178611 -0700
+++ xen-b/tools/hotplug/Linux/xend.rules	2013-03-16 22:46:21.159845277 -0600
@@ -1,4 +1,4 @@
 SUBSYSTEM=="pci", RUN+="socket:/org/xen/xend/udev_event"
 SUBSYSTEM=="scsi", RUN+="socket:/org/xen/xend/udev_event"
 SUBSYSTEM=="usb", RUN+="socket:/org/xen/xend/udev_event"
-#SUBSYSTEM=="net", KERNEL!="vif[0-9]*.[0-9]*|tap[0-9]*.[0-9]*", RUN+="socket:/org/xen/xend/udev_event"
+SUBSYSTEM=="net", KERNEL!="vif[0-9]*.[0-9]*|tap[0-9]*.[0-9]*", RUN+="socket:/org/xen/xend/udev_event"
diff -Naur xen/tools/libaio/harness/Makefile xen-b/tools/libaio/harness/Makefile
--- xen/tools/libaio/harness/Makefile	2013-03-09 18:06:25.999845278 -0700
+++ xen-b/tools/libaio/harness/Makefile	2013-03-16 22:46:21.159845277 -0600
@@ -4,7 +4,7 @@
 HARNESS_SRCS:=main.c
 # io_queue.c
 
-CFLAGS=-Wall -Werror -g -O -laio
+CFLAGS=-Wall -g -O -laio
 #-lpthread -lrt
 
 all: $(PROGS)
diff -Naur xen/tools/libfsimage/Rules.mk xen-b/tools/libfsimage/Rules.mk
--- xen/tools/libfsimage/Rules.mk	2013-03-09 18:06:26.003178611 -0700
+++ xen-b/tools/libfsimage/Rules.mk	2013-03-16 22:46:21.159845277 -0600
@@ -1,7 +1,7 @@
 include $(XEN_ROOT)/tools/Rules.mk
 
 CFLAGS += -Wno-unknown-pragmas -I$(XEN_ROOT)/tools/libfsimage/common/ -DFSIMAGE_FSDIR=\"$(FSDIR)\"
-CFLAGS += -Werror -D_GNU_SOURCE
+CFLAGS += -D_GNU_SOURCE
 LDFLAGS += -L../common/
 
 PIC_OBJS := $(patsubst %.c,%.opic,$(LIB_SRCS-y))
diff -Naur xen/tools/libxc/Makefile xen-b/tools/libxc/Makefile
--- xen/tools/libxc/Makefile	2013-03-09 18:06:26.019845278 -0700
+++ xen-b/tools/libxc/Makefile	2013-03-16 22:46:21.159845277 -0600
@@ -72,7 +72,7 @@
 
 -include $(XEN_TARGET_ARCH)/Makefile
 
-CFLAGS   += -Werror -Wmissing-prototypes
+CFLAGS   += -Wmissing-prototypes
 CFLAGS   += -I. $(CFLAGS_xeninclude)
 
 # Needed for posix_fadvise64() in xc_linux.c
diff -Naur xen/tools/libxc/xc_suspend.c xen-b/tools/libxc/xc_suspend.c
--- xen/tools/libxc/xc_suspend.c	2013-03-09 18:06:26.026511945 -0700
+++ xen-b/tools/libxc/xc_suspend.c	2013-03-16 22:46:21.159845277 -0600
@@ -16,8 +16,43 @@
 
 #include "xc_private.h"
 #include "xenguest.h"
+#include <signal.h>
+#ifdef __MINIOS__
+extern int kill (__pid_t __pid, int __sig);
+#endif
 
 #define SUSPEND_LOCK_FILE "/var/lib/xen/suspend_evtchn"
+/* cleanup obsolete suspend lock file which is unlinked for any reason,
+so that current process can get lock */
+static void clean_obsolete_lock(int domid)
+{
+    int fd, pid, n;
+    char buf[128];
+    char suspend_file[256];
+
+    snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
+        SUSPEND_LOCK_FILE, domid);
+    fd = open(suspend_file, O_RDWR);
+
+    if (fd < 0)
+        return;
+
+    n = read(fd, buf, 127);
+
+    close(fd);
+
+    if (n > 0)
+    {
+        sscanf(buf, "%d", &pid);
+        /* pid does not exist, this lock file is obsolete, just delete it */
+        if ( kill(pid,0) )
+        {
+            unlink(suspend_file);
+            return;
+        }
+    }
+}
+
 static int lock_suspend_event(xc_interface *xch, int domid)
 {
     int fd, rc;
@@ -27,6 +62,7 @@
 
     snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
 	    SUSPEND_LOCK_FILE, domid);
+    clean_obsolete_lock(domid);
     mask = umask(022);
     fd = open(suspend_file, O_CREAT | O_EXCL | O_RDWR, 0666);
     if (fd < 0)
@@ -41,6 +77,9 @@
     rc = write_exact(fd, buf, strlen(buf));
     close(fd);
 
+    if(rc)
+    unlink(suspend_file);
+
     return rc;
 }
 
@@ -127,8 +166,7 @@
     return suspend_evtchn;
 
 cleanup:
-    if (suspend_evtchn != -1)
-        xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
+    xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
 
     return -1;
 }
diff -Naur xen/tools/libxen/src/xen_common.c xen-b/tools/libxen/src/xen_common.c
--- xen/tools/libxen/src/xen_common.c	2013-03-09 18:06:26.033178611 -0700
+++ xen-b/tools/libxen/src/xen_common.c	2013-03-16 22:46:21.159845277 -0600
@@ -904,8 +904,15 @@
             0 != strcmp((char *)value_node->children->name, "struct") ||
             value_node->children->children == NULL)
         {
+#if PERMISSIVE
+            fprintf(stderr,
+                    "Expected Map from the server, but didn't get one\n");
+            ((arbitrary_map **)value)[slot] = NULL;
+#else
+
             server_error(s,
                          "Expected Map from the server, but didn't get it");
+#endif
         }
         else
         {
diff -Naur xen/tools/libxl/Makefile xen-b/tools/libxl/Makefile
--- xen/tools/libxl/Makefile	2013-03-09 18:06:26.036511944 -0700
+++ xen-b/tools/libxl/Makefile	2013-03-16 22:46:21.159845277 -0600
@@ -11,7 +11,7 @@
 XLUMAJOR = 1.0
 XLUMINOR = 1
 
-CFLAGS += -Werror -Wno-format-zero-length -Wmissing-declarations \
+CFLAGS += -Wno-format-zero-length -Wmissing-declarations \
 	-Wno-declaration-after-statement -Wformat-nonliteral
 CFLAGS += -I. -fPIC
 
diff -Naur xen/tools/libxl/libxl_dm.c xen-b/tools/libxl/libxl_dm.c
--- xen/tools/libxl/libxl_dm.c	2013-03-09 18:06:26.039845278 -0700
+++ xen-b/tools/libxl/libxl_dm.c	2013-03-16 22:46:21.159845277 -0600
@@ -50,7 +50,7 @@
             dm = libxl__abs_path(gc, "qemu-dm", libxl__libexec_path());
             break;
         case LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN:
-            dm = libxl__abs_path(gc, "qemu-system-i386", libxl__libexec_path());
+            dm = libxl__abs_path(gc, "qemu-system-x86_64", libxl__libexec_path());
             break;
         default:
             LIBXL__LOG(ctx, LIBXL__LOG_ERROR,
@@ -195,6 +195,12 @@
                                   "-usbdevice", b_info->u.hvm.usbdevice, NULL);
             }
         }
+        if (b_info->u.hvm.watchdog || b_info->u.hvm.watchdog_action) {
+            flexarray_append(dm_args, "-watchdog");
+            if (b_info->u.hvm.watchdog_action) {
+                flexarray_vappend(dm_args, "-watchdog-action", b_info->u.hvm.watchdog_action, NULL);
+            }
+        }
         if (b_info->u.hvm.soundhw) {
             flexarray_vappend(dm_args, "-soundhw", b_info->u.hvm.soundhw, NULL);
         }
@@ -465,6 +471,12 @@
                                   "-usbdevice", b_info->u.hvm.usbdevice, NULL);
             }
         }
+        if (b_info->u.hvm.watchdog || b_info->u.hvm.watchdog_action) {
+            flexarray_append(dm_args, "-watchdog");
+            if (b_info->u.hvm.watchdog_action) {
+                flexarray_vappend(dm_args, "-watchdog-action", b_info->u.hvm.watchdog_action, NULL);
+            }
+        }
         if (b_info->u.hvm.soundhw) {
             flexarray_vappend(dm_args, "-soundhw", b_info->u.hvm.soundhw, NULL);
         }
diff -Naur xen/tools/libxl/libxl_internal.h xen-b/tools/libxl/libxl_internal.h
--- xen/tools/libxl/libxl_internal.h	2013-03-15 23:26:36.449845278 -0600
+++ xen-b/tools/libxl/libxl_internal.h	2013-03-16 22:46:21.163178611 -0600
@@ -377,7 +377,7 @@
 #define PCI_SLOT(devfn)         (((devfn) >> 3) & 0x1f)
 #define PCI_FUNC(devfn)         ((devfn) & 0x07)
 #define AUTO_PHP_SLOT          0x100
-#define XENSTORE_PID_FILE      "/var/run/xenstored.pid"
+#define XENSTORE_PID_FILE      "/run/xenstored.pid"
 
 #define PROC_PCI_NUM_RESOURCES 7
 #define PCI_BAR_IO             0x01
diff -Naur xen/tools/libxl/libxl_types.idl xen-b/tools/libxl/libxl_types.idl
--- xen/tools/libxl/libxl_types.idl	2013-03-16 22:40:58.779845277 -0600
+++ xen-b/tools/libxl/libxl_types.idl	2013-03-16 22:46:21.163178611 -0600
@@ -330,6 +330,8 @@
                                        ("usbdevice",        string),
                                        ("soundhw",          string),
                                        ("xen_platform_pci", libxl_defbool),
+                                       ("watchdog",         string),
+                                       ("watchdog_action",  string),
                                        ])),
                  ("pv", Struct(None, [("kernel", string),
                                       ("slack_memkb", MemKB),
diff -Naur xen/tools/libxl/xl.c xen-b/tools/libxl/xl.c
--- xen/tools/libxl/xl.c	2013-03-16 22:40:58.806511944 -0600
+++ xen-b/tools/libxl/xl.c	2013-03-16 22:46:21.163178611 -0600
@@ -32,7 +32,7 @@
 #include "libxlutil.h"
 #include "xl.h"
 
-#define XEND_LOCK { "/var/lock/subsys/xend", "/var/lock/xend" }
+#define XEND_LOCK { "/run/lock/subsys/xend", "/run/lock/xend" }
 
 xentoollog_logger_stdiostream *logger;
 int dryrun_only;
diff -Naur xen/tools/libxl/xl_cmdimpl.c xen-b/tools/libxl/xl_cmdimpl.c
--- xen/tools/libxl/xl_cmdimpl.c	2013-03-16 22:40:58.873178610 -0600
+++ xen-b/tools/libxl/xl_cmdimpl.c	2013-03-16 22:46:21.163178611 -0600
@@ -1430,6 +1430,8 @@
                         " \"device_model_stubdomain_override\" directive"
                         " for pv guest\n");
         }
+        xlu_cfg_replace_string (config, "watchdog", &b_info->u.hvm.watchdog, 0);
+        xlu_cfg_replace_string (config, "watchdog_action", &b_info->u.hvm.watchdog_action, 0);
     }
 
 
diff -Naur xen/tools/libxl/xl_cmdimpl.c.orig xen-b/tools/libxl/xl_cmdimpl.c.orig
--- xen/tools/libxl/xl_cmdimpl.c.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/libxl/xl_cmdimpl.c.orig	2013-03-16 22:40:58.873178610 -0600
@@ -0,0 +1,7046 @@
+/*
+ * Copyright (C) 2009      Citrix Ltd.
+ * Author Stefano Stabellini <stefano.stabellini@eu.citrix.com>
+ * Author Vincent Hanquez <vincent.hanquez@eu.citrix.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published
+ * by the Free Software Foundation; version 2.1 only. with the special
+ * exception on linking described in file LICENSE.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ */
+
+#include "libxl_osdeps.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <getopt.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <sys/select.h>
+#include <sys/utsname.h> /* for utsname in xl info */
+#include <xentoollog.h>
+#include <ctype.h>
+#include <inttypes.h>
+#include <limits.h>
+
+#include "libxl.h"
+#include "libxl_utils.h"
+#include "libxl_json.h"
+#include "libxlutil.h"
+#include "xl.h"
+
+#define CHK_ERRNO( call ) ({                                            \
+        int chk_errno = (call);                                         \
+        if (chk_errno < 0) {                                                \
+            fprintf(stderr,"xl: fatal error: %s:%d: %s: %s\n",          \
+                    __FILE__,__LINE__, strerror(chk_errno), #call);     \
+            exit(-ERROR_FAIL);                                          \
+        }                                                               \
+    })
+
+#define MUST( call ) ({                                                 \
+        int must_rc = (call);                                           \
+        if (must_rc < 0) {                                                  \
+            fprintf(stderr,"xl: fatal error: %s:%d, rc=%d: %s\n",       \
+                    __FILE__,__LINE__, must_rc, #call);                 \
+            exit(-must_rc);                                             \
+        }                                                               \
+    })
+
+
+int logfile = 2;
+
+/* every libxl action in xl uses this same libxl context */
+libxl_ctx *ctx;
+
+xlchild children[child_max];
+
+#define INVALID_DOMID ~0
+static const char *common_domname;
+static int fd_lock = -1;
+
+/* Stash for specific vcpu to pcpu mappping */
+static int *vcpu_to_pcpu;
+
+static const char savefileheader_magic[32]=
+    "Xen saved domain, xl format\n \0 \r";
+
+static const char migrate_receiver_banner[]=
+    "xl migration receiver ready, send binary domain data.\n";
+static const char migrate_receiver_ready[]=
+    "domain received, ready to unpause";
+static const char migrate_permission_to_go[]=
+    "domain is yours, you are cleared to unpause";
+static const char migrate_report[]=
+    "my copy unpause results are as follows";
+  /* followed by one byte:
+   *     0: everything went well, domain is running
+   *            next thing is we all exit
+   * non-0: things went badly
+   *            next thing should be a migrate_permission_to_go
+   *            from target to source
+   */
+
+struct save_file_header {
+    char magic[32]; /* savefileheader_magic */
+    /* All uint32_ts are in domain's byte order. */
+    uint32_t byteorder; /* SAVEFILE_BYTEORDER_VALUE */
+    uint32_t mandatory_flags; /* unknown flags => reject restore */
+    uint32_t optional_flags; /* unknown flags => reject restore */
+    uint32_t optional_data_len; /* skip, or skip tail, if not understood */
+};
+
+
+static const char *action_on_shutdown_names[] = {
+    [LIBXL_ACTION_ON_SHUTDOWN_DESTROY] = "destroy",
+
+    [LIBXL_ACTION_ON_SHUTDOWN_RESTART] = "restart",
+    [LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME] = "rename-restart",
+
+    [LIBXL_ACTION_ON_SHUTDOWN_PRESERVE] = "preserve",
+
+    [LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY] = "coredump-destroy",
+    [LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART] = "coredump-restart",
+};
+
+/* Optional data, in order:
+ *   4 bytes uint32_t  config file size
+ *   n bytes           config file in Unix text file format
+ */
+
+#define SAVEFILE_BYTEORDER_VALUE ((uint32_t)0x01020304UL)
+
+struct domain_create {
+    int debug;
+    int daemonize;
+    int monitor; /* handle guest reboots etc */
+    int paused;
+    int dryrun;
+    int quiet;
+    int vnc;
+    int vncautopass;
+    int console_autoconnect;
+    const char *config_file;
+    const char *extra_config; /* extra config string */
+    const char *restore_file;
+    int migrate_fd; /* -1 means none */
+    char **migration_domname_r; /* from malloc */
+};
+
+
+
+static int qualifier_to_id(const char *p, uint32_t *id_r)
+{
+    int i, alldigit;
+
+    alldigit = 1;
+    for (i = 0; p[i]; i++) {
+        if (!isdigit((uint8_t)p[i])) {
+            alldigit = 0;
+            break;
+        }
+    }
+
+    if (i > 0 && alldigit) {
+        *id_r = strtoul(p, NULL, 10);
+        return 0;
+    } else {
+        /* check here if it's a uuid and do proper conversion */
+    }
+    return 1;
+}
+
+static int domain_qualifier_to_domid(const char *p, uint32_t *domid_r,
+                                     int *was_name_r)
+{
+    int was_name, rc;
+
+    was_name = qualifier_to_id(p, domid_r);
+    if (was_name_r)
+        *was_name_r = was_name;
+
+    if (was_name) {
+        rc = libxl_name_to_domid(ctx, p, domid_r);
+        if (rc)
+            return rc;
+    } else {
+        rc = libxl_domain_info(ctx, NULL, *domid_r);
+        /* error only if domain does not exist */
+        if (rc == ERROR_INVAL)
+            return rc;
+    }
+
+    return 0;
+}
+
+static int cpupool_qualifier_to_cpupoolid(const char *p, uint32_t *poolid_r,
+                                     int *was_name_r)
+{
+    int was_name;
+
+    was_name = qualifier_to_id(p, poolid_r);
+    if (was_name_r) *was_name_r = was_name;
+    return was_name ? libxl_name_to_cpupoolid(ctx, p, poolid_r) : 0;
+}
+
+static uint32_t find_domain(const char *p) __attribute__((warn_unused_result));
+static uint32_t find_domain(const char *p)
+{
+    uint32_t domid;
+    int rc, was_name;
+
+    rc = domain_qualifier_to_domid(p, &domid, &was_name);
+    if (rc) {
+        fprintf(stderr, "%s is an invalid domain identifier (rc=%d)\n", p, rc);
+        exit(2);
+    }
+    common_domname = was_name ? p : libxl_domid_to_name(ctx, domid);
+    return domid;
+}
+
+static int vncviewer(uint32_t domid, int autopass)
+{
+    libxl_vncviewer_exec(ctx, domid, autopass);
+    fprintf(stderr, "Unable to execute vncviewer\n");
+    return 1;
+}
+
+static int acquire_lock(void)
+{
+    int rc;
+    struct flock fl;
+
+    /* lock already acquired */
+    if (fd_lock >= 0)
+        return ERROR_INVAL;
+
+    fl.l_type = F_WRLCK;
+    fl.l_whence = SEEK_SET;
+    fl.l_start = 0;
+    fl.l_len = 0;
+    fd_lock = open(lockfile, O_WRONLY|O_CREAT, S_IWUSR);
+    if (fd_lock < 0) {
+        fprintf(stderr, "cannot open the lockfile %s errno=%d\n", lockfile, errno);
+        return ERROR_FAIL;
+    }
+    if (fcntl(fd_lock, F_SETFD, FD_CLOEXEC) < 0) {
+        close(fd_lock);
+        fprintf(stderr, "cannot set cloexec to lockfile %s errno=%d\n", lockfile, errno);
+        return ERROR_FAIL;
+    }
+get_lock:
+    rc = fcntl(fd_lock, F_SETLKW, &fl);
+    if (rc < 0 && errno == EINTR)
+        goto get_lock;
+    if (rc < 0) {
+        fprintf(stderr, "cannot acquire lock %s errno=%d\n", lockfile, errno);
+        rc = ERROR_FAIL;
+    } else
+        rc = 0;
+    return rc;
+}
+
+static int release_lock(void)
+{
+    int rc;
+    struct flock fl;
+
+    /* lock not acquired */
+    if (fd_lock < 0)
+        return ERROR_INVAL;
+
+release_lock:
+    fl.l_type = F_UNLCK;
+    fl.l_whence = SEEK_SET;
+    fl.l_start = 0;
+    fl.l_len = 0;
+
+    rc = fcntl(fd_lock, F_SETLKW, &fl);
+    if (rc < 0 && errno == EINTR)
+        goto release_lock;
+    if (rc < 0) {
+        fprintf(stderr, "cannot release lock %s, errno=%d\n", lockfile, errno);
+        rc = ERROR_FAIL;
+    } else
+        rc = 0;
+    close(fd_lock);
+    fd_lock = -1;
+
+    return rc;
+}
+
+static void *xmalloc(size_t sz) {
+    void *r;
+    r = malloc(sz);
+    if (!r) { fprintf(stderr,"xl: Unable to malloc %lu bytes.\n",
+                      (unsigned long)sz); exit(-ERROR_FAIL); }
+    return r;
+}
+
+static void *xrealloc(void *ptr, size_t sz) {
+    void *r;
+    if (!sz) { free(ptr); return 0; }
+      /* realloc(non-0, 0) has a useless return value;
+       * but xrealloc(anything, 0) is like free
+       */
+    r = realloc(ptr, sz);
+    if (!r) { fprintf(stderr,"xl: Unable to realloc to %lu bytes.\n",
+                      (unsigned long)sz); exit(-ERROR_FAIL); }
+    return r;
+}
+
+#define LOG(_f, _a...)   dolog(__FILE__, __LINE__, __func__, _f "\n", ##_a)
+
+static void dolog(const char *file, int line, const char *func, char *fmt, ...)
+     __attribute__((format(printf,4,5)));
+
+static void dolog(const char *file, int line, const char *func, char *fmt, ...)
+{
+    va_list ap;
+    char *s = NULL;
+    int rc;
+
+    va_start(ap, fmt);
+    rc = vasprintf(&s, fmt, ap);
+    va_end(ap);
+    if (rc >= 0)
+        libxl_write_exactly(NULL, logfile, s, rc, NULL, NULL);
+    free(s);
+}
+
+static yajl_gen_status printf_info_one_json(yajl_gen hand, int domid,
+                                            libxl_domain_config *d_config)
+{
+    yajl_gen_status s;
+
+    s = yajl_gen_map_open(hand);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+    s = yajl_gen_string(hand, (const unsigned char *)"domid",
+                        sizeof("domid")-1);
+    if (s != yajl_gen_status_ok)
+        goto out;
+    if (domid != -1)
+        s = yajl_gen_integer(hand, domid);
+    else
+        s = yajl_gen_null(hand);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+    s = yajl_gen_string(hand, (const unsigned char *)"config",
+                        sizeof("config")-1);
+    if (s != yajl_gen_status_ok)
+        goto out;
+    s = libxl_domain_config_gen_json(hand, d_config);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+    s = yajl_gen_map_close(hand);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+out:
+    return s;
+}
+static void printf_info(enum output_format output_format,
+                        int domid,
+                        libxl_domain_config *d_config)
+{
+    if (output_format == OUTPUT_FORMAT_SXP)
+        return printf_info_sexp(domid, d_config);
+
+    const char *buf;
+    libxl_yajl_length len = 0;
+    yajl_gen_status s;
+    yajl_gen hand;
+
+    hand = libxl_yajl_gen_alloc(NULL);
+    if (!hand) {
+        fprintf(stderr, "unable to allocate JSON generator\n");
+        return;
+    }
+
+    s = printf_info_one_json(hand, domid, d_config);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+    s = yajl_gen_get_buf(hand, (const unsigned char **)&buf, &len);
+    if (s != yajl_gen_status_ok)
+        goto out;
+
+    puts(buf);
+
+out:
+    yajl_gen_free(hand);
+
+    if (s != yajl_gen_status_ok)
+        fprintf(stderr,
+                "unable to format domain config as JSON (YAJL:%d)\n", s);
+
+    if (ferror(stdout) || fflush(stdout)) { perror("stdout"); exit(-1); }
+}
+
+static int parse_action_on_shutdown(const char *buf, libxl_action_on_shutdown *a)
+{
+    int i;
+    const char *n;
+
+    for (i = 0; i < sizeof(action_on_shutdown_names) / sizeof(action_on_shutdown_names[0]); i++) {
+        n = action_on_shutdown_names[i];
+
+        if (!n) continue;
+
+        if (strcmp(buf, n) == 0) {
+            *a = i;
+            return 1;
+        }
+    }
+    return 0;
+}
+
+#define DSTATE_INITIAL   0
+#define DSTATE_TAP       1
+#define DSTATE_PHYSPATH  2
+#define DSTATE_VIRTPATH  3
+#define DSTATE_VIRTTYPE  4
+#define DSTATE_RW        5
+#define DSTATE_TERMINAL  6
+
+static void parse_disk_config_multistring(XLU_Config **config,
+                                          int nspecs, const char *const *specs,
+                                          libxl_device_disk *disk)
+{
+    int e;
+
+    libxl_device_disk_init(disk);
+
+    if (!*config) {
+        *config = xlu_cfg_init(stderr, "command line");
+        if (!*config) { perror("xlu_cfg_init"); exit(-1); }
+    }
+
+    e = xlu_disk_parse(*config, nspecs, specs, disk);
+    if (e == EINVAL) exit(-1);
+    if (e) {
+        fprintf(stderr,"xlu_disk_parse failed: %s\n",strerror(errno));
+        exit(-1);
+    }
+}
+
+static void parse_disk_config(XLU_Config **config, const char *spec,
+                              libxl_device_disk *disk)
+{
+    parse_disk_config_multistring(config, 1, &spec, disk);
+}
+
+static void parse_vif_rate(XLU_Config **config, const char *rate,
+                           libxl_device_nic *nic)
+{
+    int e;
+
+    e = xlu_vif_parse_rate(*config, rate, nic);
+    if (e == EINVAL || e == EOVERFLOW) exit(-1);
+    if (e) {
+        fprintf(stderr,"xlu_vif_parse_rate failed: %s\n",strerror(errno));
+        exit(-1);
+    }
+}
+
+static void split_string_into_string_list(const char *str,
+                                          const char *delim,
+                                          libxl_string_list *psl)
+{
+    char *s, *saveptr;
+    const char *p;
+    libxl_string_list sl;
+
+    int i = 0, nr = 0;
+
+    s = strdup(str);
+    if (s == NULL) {
+        fprintf(stderr, "unable to allocate memory to parse bootloader args\n");
+        exit(-1);
+    }
+
+    /* Count number of entries */
+    p = strtok_r(s, delim, &saveptr);
+    do {
+        nr++;
+    } while ((p = strtok_r(NULL, delim, &saveptr)));
+
+    free(s);
+
+    s = strdup(str);
+
+    sl = malloc((nr+1) * sizeof (char *));
+    if (sl == NULL) {
+        fprintf(stderr, "unable to allocate memory for bootloader args\n");
+        exit(-1);
+    }
+
+    p = strtok_r(s, delim, &saveptr);
+    do {
+        assert(i < nr);
+        sl[i] = strdup(p);
+        i++;
+    } while ((p = strtok_r(NULL, delim, &saveptr)));
+    sl[i] = NULL;
+
+    *psl = sl;
+
+    free(s);
+}
+
+static int vcpupin_parse(char *cpu, libxl_bitmap *cpumap)
+{
+    libxl_bitmap exclude_cpumap;
+    uint32_t cpuida, cpuidb;
+    char *endptr, *toka, *tokb, *saveptr = NULL;
+    int i, rc = 0, rmcpu;
+
+    if (!strcmp(cpu, "all")) {
+        libxl_bitmap_set_any(cpumap);
+        return 0;
+    }
+
+    if (libxl_cpu_bitmap_alloc(ctx, &exclude_cpumap, 0)) {
+        fprintf(stderr, "Error: Failed to allocate cpumap.\n");
+        return ENOMEM;
+    }
+
+    for (toka = strtok_r(cpu, ",", &saveptr); toka;
+         toka = strtok_r(NULL, ",", &saveptr)) {
+        rmcpu = 0;
+        if (*toka == '^') {
+            /* This (These) Cpu(s) will be removed from the map */
+            toka++;
+            rmcpu = 1;
+        }
+        /* Extract a valid (range of) cpu(s) */
+        cpuida = cpuidb = strtoul(toka, &endptr, 10);
+        if (endptr == toka) {
+            fprintf(stderr, "Error: Invalid argument.\n");
+            rc = EINVAL;
+            goto vcpp_out;
+        }
+        if (*endptr == '-') {
+            tokb = endptr + 1;
+            cpuidb = strtoul(tokb, &endptr, 10);
+            if (endptr == tokb || cpuida > cpuidb) {
+                fprintf(stderr, "Error: Invalid argument.\n");
+                rc = EINVAL;
+                goto vcpp_out;
+            }
+        }
+        while (cpuida <= cpuidb) {
+            rmcpu == 0 ? libxl_bitmap_set(cpumap, cpuida) :
+                         libxl_bitmap_set(&exclude_cpumap, cpuida);
+            cpuida++;
+        }
+    }
+
+    /* Clear all the cpus from the removal list */
+    libxl_for_each_set_bit(i, exclude_cpumap) {
+        libxl_bitmap_reset(cpumap, i);
+    }
+
+vcpp_out:
+    libxl_bitmap_dispose(&exclude_cpumap);
+
+    return rc;
+}
+
+static void parse_config_data(const char *config_source,
+                              const char *config_data,
+                              int config_len,
+                              libxl_domain_config *d_config,
+                              struct domain_create *dom_info)
+
+{
+    const char *buf;
+    long l;
+    XLU_Config *config;
+    XLU_ConfigList *cpus, *vbds, *nics, *pcis, *cvfbs, *cpuids, *vtpms;
+    XLU_ConfigList *ioports, *irqs, *iomem;
+    int num_ioports, num_irqs, num_iomem;
+    int pci_power_mgmt = 0;
+    int pci_msitranslate = 0;
+    int pci_permissive = 0;
+    int i, e;
+
+    libxl_domain_create_info *c_info = &d_config->c_info;
+    libxl_domain_build_info *b_info = &d_config->b_info;
+
+    config= xlu_cfg_init(stderr, config_source);
+    if (!config) {
+        fprintf(stderr, "Failed to allocate for configuration\n");
+        exit(1);
+    }
+
+    e= xlu_cfg_readdata(config, config_data, config_len);
+    if (e) {
+        fprintf(stderr, "Failed to parse config: %s\n", strerror(e));
+        exit(1);
+    }
+
+    if (!xlu_cfg_get_string (config, "init_seclabel", &buf, 0)) {
+        e = libxl_flask_context_to_sid(ctx, (char *)buf, strlen(buf),
+                                    &c_info->ssidref);
+        if (e) {
+            if (errno == ENOSYS) {
+                fprintf(stderr, "XSM Disabled: init_seclabel not supported\n");
+            } else {
+                fprintf(stderr, "Invalid init_seclabel: %s\n", buf);
+                exit(1);
+            }
+        }
+    }
+
+    if (!xlu_cfg_get_string (config, "seclabel", &buf, 0)) {
+        uint32_t ssidref;
+        e = libxl_flask_context_to_sid(ctx, (char *)buf, strlen(buf),
+                                    &ssidref);
+        if (e) {
+            if (errno == ENOSYS) {
+                fprintf(stderr, "XSM Disabled: seclabel not supported\n");
+            } else {
+                fprintf(stderr, "Invalid seclabel: %s\n", buf);
+                exit(1);
+            }
+        } else if (c_info->ssidref) {
+            b_info->exec_ssidref = ssidref;
+        } else {
+            c_info->ssidref = ssidref;
+        }
+    }
+
+    libxl_defbool_set(&c_info->run_hotplug_scripts, run_hotplug_scripts);
+    c_info->type = LIBXL_DOMAIN_TYPE_PV;
+    if (!xlu_cfg_get_string (config, "builder", &buf, 0) &&
+        !strncmp(buf, "hvm", strlen(buf)))
+        c_info->type = LIBXL_DOMAIN_TYPE_HVM;
+
+    xlu_cfg_get_defbool(config, "hap", &c_info->hap, 0);
+
+    if (xlu_cfg_replace_string (config, "name", &c_info->name, 0)) {
+        fprintf(stderr, "Domain name must be specified.\n");
+        exit(1);
+    }
+
+    if (!xlu_cfg_get_string (config, "uuid", &buf, 0) ) {
+        if ( libxl_uuid_from_string(&c_info->uuid, buf) ) {
+            fprintf(stderr, "Failed to parse UUID: %s\n", buf);
+            exit(1);
+        }
+    }else{
+        libxl_uuid_generate(&c_info->uuid);
+    }
+
+    xlu_cfg_get_defbool(config, "oos", &c_info->oos, 0);
+
+    if (!xlu_cfg_get_string (config, "pool", &buf, 0)) {
+        c_info->poolid = -1;
+        cpupool_qualifier_to_cpupoolid(buf, &c_info->poolid, NULL);
+    }
+    if (!libxl_cpupoolid_is_valid(ctx, c_info->poolid)) {
+        fprintf(stderr, "Illegal pool specified\n");
+        exit(1);
+    }
+
+    libxl_domain_build_info_init_type(b_info, c_info->type);
+    if (blkdev_start)
+        b_info->blkdev_start = strdup(blkdev_start);
+
+    /* the following is the actual config parsing with overriding
+     * values in the structures */
+    if (!xlu_cfg_get_long (config, "cpu_weight", &l, 0))
+        b_info->sched_params.weight = l;
+    if (!xlu_cfg_get_long (config, "cap", &l, 0))
+        b_info->sched_params.cap = l;
+    if (!xlu_cfg_get_long (config, "period", &l, 0))
+        b_info->sched_params.period = l;
+    if (!xlu_cfg_get_long (config, "slice", &l, 0))
+        b_info->sched_params.slice = l;
+    if (!xlu_cfg_get_long (config, "latency", &l, 0))
+        b_info->sched_params.latency = l;
+    if (!xlu_cfg_get_long (config, "extratime", &l, 0))
+        b_info->sched_params.extratime = l;
+
+    if (!xlu_cfg_get_long (config, "vcpus", &l, 0)) {
+        b_info->max_vcpus = l;
+
+        if (libxl_cpu_bitmap_alloc(ctx, &b_info->avail_vcpus, l)) {
+            fprintf(stderr, "Unable to allocate cpumap\n");
+            exit(1);
+        }
+        libxl_bitmap_set_none(&b_info->avail_vcpus);
+        while (l-- > 0)
+            libxl_bitmap_set((&b_info->avail_vcpus), l);
+    }
+
+    if (!xlu_cfg_get_long (config, "maxvcpus", &l, 0))
+        b_info->max_vcpus = l;
+
+    if (!xlu_cfg_get_list (config, "cpus", &cpus, 0, 1)) {
+        int n_cpus = 0;
+
+        if (libxl_cpu_bitmap_alloc(ctx, &b_info->cpumap, 0)) {
+            fprintf(stderr, "Unable to allocate cpumap\n");
+            exit(1);
+        }
+
+        /* Prepare the array for single vcpu to pcpu mappings */
+        vcpu_to_pcpu = xmalloc(sizeof(int) * b_info->max_vcpus);
+        memset(vcpu_to_pcpu, -1, sizeof(int) * b_info->max_vcpus);
+
+        /*
+         * Idea here is to let libxl think all the domain's vcpus
+         * have cpu affinity with all the pcpus on the list.
+         * It is then us, here in xl, that matches each single vcpu
+         * to its pcpu (and that's why we need to stash such info in
+         * the vcpu_to_pcpu array now) after the domain has been created.
+         * Doing it like this saves the burden of passing to libxl
+         * some big array hosting the single mappings. Also, using
+         * the cpumap derived from the list ensures memory is being
+         * allocated on the proper nodes anyway.
+         */
+        libxl_bitmap_set_none(&b_info->cpumap);
+        while ((buf = xlu_cfg_get_listitem(cpus, n_cpus)) != NULL) {
+            i = atoi(buf);
+            if (!libxl_bitmap_cpu_valid(&b_info->cpumap, i)) {
+                fprintf(stderr, "cpu %d illegal\n", i);
+                exit(1);
+            }
+            libxl_bitmap_set(&b_info->cpumap, i);
+            if (n_cpus < b_info->max_vcpus)
+                vcpu_to_pcpu[n_cpus] = i;
+            n_cpus++;
+        }
+
+        /* We have a cpumap, disable automatic placement */
+        libxl_defbool_set(&b_info->numa_placement, false);
+    }
+    else if (!xlu_cfg_get_string (config, "cpus", &buf, 0)) {
+        char *buf2 = strdup(buf);
+
+        if (libxl_cpu_bitmap_alloc(ctx, &b_info->cpumap, 0)) {
+            fprintf(stderr, "Unable to allocate cpumap\n");
+            exit(1);
+        }
+
+        libxl_bitmap_set_none(&b_info->cpumap);
+        if (vcpupin_parse(buf2, &b_info->cpumap))
+            exit(1);
+        free(buf2);
+
+        libxl_defbool_set(&b_info->numa_placement, false);
+    }
+
+    if (!xlu_cfg_get_long (config, "memory", &l, 0)) {
+        b_info->max_memkb = l * 1024;
+        b_info->target_memkb = b_info->max_memkb;
+    }
+
+    if (!xlu_cfg_get_long (config, "maxmem", &l, 0))
+        b_info->max_memkb = l * 1024;
+
+    if (xlu_cfg_get_string (config, "on_poweroff", &buf, 0))
+        buf = "destroy";
+    if (!parse_action_on_shutdown(buf, &d_config->on_poweroff)) {
+        fprintf(stderr, "Unknown on_poweroff action \"%s\" specified\n", buf);
+        exit(1);
+    }
+
+    if (xlu_cfg_get_string (config, "on_reboot", &buf, 0))
+        buf = "restart";
+    if (!parse_action_on_shutdown(buf, &d_config->on_reboot)) {
+        fprintf(stderr, "Unknown on_reboot action \"%s\" specified\n", buf);
+        exit(1);
+    }
+
+    if (xlu_cfg_get_string (config, "on_watchdog", &buf, 0))
+        buf = "destroy";
+    if (!parse_action_on_shutdown(buf, &d_config->on_watchdog)) {
+        fprintf(stderr, "Unknown on_watchdog action \"%s\" specified\n", buf);
+        exit(1);
+    }
+
+
+    if (xlu_cfg_get_string (config, "on_crash", &buf, 0))
+        buf = "destroy";
+    if (!parse_action_on_shutdown(buf, &d_config->on_crash)) {
+        fprintf(stderr, "Unknown on_crash action \"%s\" specified\n", buf);
+        exit(1);
+    }
+
+    /* libxl_get_required_shadow_memory() must be called after final values
+     * (default or specified) for vcpus and memory are set, because the
+     * calculation depends on those values. */
+    b_info->shadow_memkb = !xlu_cfg_get_long(config, "shadow_memory", &l, 0)
+        ? l * 1024
+        : libxl_get_required_shadow_memory(b_info->max_memkb,
+                                           b_info->max_vcpus);
+
+    xlu_cfg_get_defbool(config, "nomigrate", &b_info->disable_migrate, 0);
+
+    if (!xlu_cfg_get_long(config, "tsc_mode", &l, 1)) {
+        const char *s = libxl_tsc_mode_to_string(l);
+        fprintf(stderr, "WARNING: specifying \"tsc_mode\" as an integer is deprecated. "
+                "Please use the named parameter variant. %s%s%s\n",
+                s ? "e.g. tsc_mode=\"" : "",
+                s ? s : "",
+                s ? "\"" : "");
+
+        if (l < LIBXL_TSC_MODE_DEFAULT ||
+            l > LIBXL_TSC_MODE_NATIVE_PARAVIRT) {
+            fprintf(stderr, "ERROR: invalid value %ld for \"tsc_mode\"\n", l);
+            exit (1);
+        }
+        b_info->tsc_mode = l;
+    } else if (!xlu_cfg_get_string(config, "tsc_mode", &buf, 0)) {
+        fprintf(stderr, "got a tsc mode string: \"%s\"\n", buf);
+        if (libxl_tsc_mode_from_string(buf, &b_info->tsc_mode)) {
+            fprintf(stderr, "ERROR: invalid value \"%s\" for \"tsc_mode\"\n",
+                    buf);
+            exit (1);
+        }
+    }
+
+    if (!xlu_cfg_get_long(config, "rtc_timeoffset", &l, 0))
+        b_info->rtc_timeoffset = l;
+
+    if (dom_info && !xlu_cfg_get_long(config, "vncviewer", &l, 0)) {
+        /* Command line arguments must take precedence over what's
+         * specified in the configuration file. */
+        if (!dom_info->vnc)
+            dom_info->vnc = l;
+    }
+
+    xlu_cfg_get_defbool(config, "localtime", &b_info->localtime, 0);
+
+    if (!xlu_cfg_get_long (config, "videoram", &l, 0))
+        b_info->video_memkb = l * 1024;
+
+    switch(b_info->type) {
+    case LIBXL_DOMAIN_TYPE_HVM:
+        if (!xlu_cfg_get_string (config, "kernel", &buf, 0))
+            fprintf(stderr, "WARNING: ignoring \"kernel\" directive for HVM guest. "
+                    "Use \"firmware_override\" instead if you really want a non-default firmware\n");
+
+        xlu_cfg_replace_string (config, "firmware_override",
+                                &b_info->u.hvm.firmware, 0);
+        if (!xlu_cfg_get_string(config, "bios", &buf, 0) &&
+            libxl_bios_type_from_string(buf, &b_info->u.hvm.bios)) {
+                fprintf(stderr, "ERROR: invalid value \"%s\" for \"bios\"\n",
+                    buf);
+                exit (1);
+        }
+
+        xlu_cfg_get_defbool(config, "pae", &b_info->u.hvm.pae, 0);
+        xlu_cfg_get_defbool(config, "apic", &b_info->u.hvm.apic, 0);
+        xlu_cfg_get_defbool(config, "acpi", &b_info->u.hvm.acpi, 0);
+        xlu_cfg_get_defbool(config, "acpi_s3", &b_info->u.hvm.acpi_s3, 0);
+        xlu_cfg_get_defbool(config, "acpi_s4", &b_info->u.hvm.acpi_s4, 0);
+        xlu_cfg_get_defbool(config, "nx", &b_info->u.hvm.nx, 0);
+        xlu_cfg_get_defbool(config, "viridian", &b_info->u.hvm.viridian, 0);
+        xlu_cfg_get_defbool(config, "hpet", &b_info->u.hvm.hpet, 0);
+        xlu_cfg_get_defbool(config, "vpt_align", &b_info->u.hvm.vpt_align, 0);
+
+        if (!xlu_cfg_get_long(config, "timer_mode", &l, 1)) {
+            const char *s = libxl_timer_mode_to_string(l);
+            fprintf(stderr, "WARNING: specifying \"timer_mode\" as an integer is deprecated. "
+                    "Please use the named parameter variant. %s%s%s\n",
+                    s ? "e.g. timer_mode=\"" : "",
+                    s ? s : "",
+                    s ? "\"" : "");
+
+            if (l < LIBXL_TIMER_MODE_DELAY_FOR_MISSED_TICKS ||
+                l > LIBXL_TIMER_MODE_ONE_MISSED_TICK_PENDING) {
+                fprintf(stderr, "ERROR: invalid value %ld for \"timer_mode\"\n", l);
+                exit (1);
+            }
+            b_info->u.hvm.timer_mode = l;
+        } else if (!xlu_cfg_get_string(config, "timer_mode", &buf, 0)) {
+            if (libxl_timer_mode_from_string(buf, &b_info->u.hvm.timer_mode)) {
+                fprintf(stderr, "ERROR: invalid value \"%s\" for \"timer_mode\"\n",
+                        buf);
+                exit (1);
+            }
+        }
+
+        xlu_cfg_get_defbool(config, "nestedhvm", &b_info->u.hvm.nested_hvm, 0);
+
+        xlu_cfg_replace_string(config, "smbios_firmware",
+                               &b_info->u.hvm.smbios_firmware, 0);
+        xlu_cfg_replace_string(config, "acpi_firmware",
+                               &b_info->u.hvm.acpi_firmware, 0);
+        break;
+    case LIBXL_DOMAIN_TYPE_PV:
+    {
+        char *cmdline = NULL;
+        const char *root = NULL, *extra = "";
+
+        xlu_cfg_replace_string (config, "kernel", &b_info->u.pv.kernel, 0);
+
+        xlu_cfg_get_string (config, "root", &root, 0);
+        xlu_cfg_get_string (config, "extra", &extra, 0);
+
+        if (root) {
+            if (asprintf(&cmdline, "root=%s %s", root, extra) == -1)
+                cmdline = NULL;
+        } else {
+            cmdline = strdup(extra);
+        }
+
+        if ((root || extra) && !cmdline) {
+            fprintf(stderr, "Failed to allocate memory for cmdline\n");
+            exit(1);
+        }
+
+        xlu_cfg_replace_string (config, "bootloader", &b_info->u.pv.bootloader, 0);
+        switch (xlu_cfg_get_list_as_string_list(config, "bootloader_args",
+                                      &b_info->u.pv.bootloader_args, 1))
+        {
+
+        case 0: break; /* Success */
+        case ESRCH: break; /* Option not present */
+        case EINVAL:
+            if (!xlu_cfg_get_string(config, "bootloader_args", &buf, 0)) {
+
+                fprintf(stderr, "WARNING: Specifying \"bootloader_args\""
+                        " as a string is deprecated. "
+                        "Please use a list of arguments.\n");
+                split_string_into_string_list(buf, " \t\n",
+                                              &b_info->u.pv.bootloader_args);
+            }
+            break;
+        default:
+            fprintf(stderr,"xl: Unable to parse bootloader_args.\n");
+            exit(-ERROR_FAIL);
+        }
+
+        if (!b_info->u.pv.bootloader && !b_info->u.pv.kernel) {
+            fprintf(stderr, "Neither kernel nor bootloader specified\n");
+            exit(1);
+        }
+
+        b_info->u.pv.cmdline = cmdline;
+        xlu_cfg_replace_string (config, "ramdisk", &b_info->u.pv.ramdisk, 0);
+        break;
+    }
+    default:
+        abort();
+    }
+
+    if (!xlu_cfg_get_list(config, "ioports", &ioports, &num_ioports, 0)) {
+        b_info->num_ioports = num_ioports;
+        b_info->ioports = calloc(num_ioports, sizeof(*b_info->ioports));
+        if (b_info->ioports == NULL) {
+            fprintf(stderr, "unable to allocate memory for ioports\n");
+            exit(-1);
+        }
+
+        for (i = 0; i < num_ioports; i++) {
+            const char *buf2;
+            char *ep;
+            uint32_t start, end;
+            unsigned long ul;
+
+            buf = xlu_cfg_get_listitem (ioports, i);
+            if (!buf) {
+                fprintf(stderr,
+                        "xl: Unable to get element #%d in ioport list\n", i);
+                exit(1);
+            }
+            ul = strtoul(buf, &ep, 16);
+            if (ep == buf) {
+                fprintf(stderr, "xl: Invalid argument parsing ioport: %s\n",
+                        buf);
+                exit(1);
+            }
+            if (ul >= UINT32_MAX) {
+                fprintf(stderr, "xl: ioport %lx too big\n", ul);
+                exit(1);
+            }
+            start = end = ul;
+
+            if (*ep == '-') {
+                buf2 = ep + 1;
+                ul = strtoul(buf2, &ep, 16);
+                if (ep == buf2 || *ep != '\0' || start > end) {
+                    fprintf(stderr,
+                            "xl: Invalid argument parsing ioport: %s\n", buf);
+                    exit(1);
+                }
+                if (ul >= UINT32_MAX) {
+                    fprintf(stderr, "xl: ioport %lx too big\n", ul);
+                    exit(1);
+                }
+                end = ul;
+            } else if ( *ep != '\0' )
+                fprintf(stderr,
+                        "xl: Invalid argument parsing ioport: %s\n", buf);
+            b_info->ioports[i].first = start;
+            b_info->ioports[i].number = end - start + 1;
+        }
+    }
+
+    if (!xlu_cfg_get_list(config, "irqs", &irqs, &num_irqs, 0)) {
+        b_info->num_irqs = num_irqs;
+        b_info->irqs = calloc(num_irqs, sizeof(*b_info->irqs));
+        if (b_info->irqs == NULL) {
+            fprintf(stderr, "unable to allocate memory for ioports\n");
+            exit(-1);
+        }
+        for (i = 0; i < num_irqs; i++) {
+            char *ep;
+            unsigned long ul;
+            buf = xlu_cfg_get_listitem (irqs, i);
+            if (!buf) {
+                fprintf(stderr,
+                        "xl: Unable to get element %d in irq list\n", i);
+                exit(1);
+            }
+            ul = strtoul(buf, &ep, 10);
+            if (ep == buf) {
+                fprintf(stderr,
+                        "xl: Invalid argument parsing irq: %s\n", buf);
+                exit(1);
+            }
+            if (ul >= UINT32_MAX) {
+                fprintf(stderr, "xl: irq %lx too big\n", ul);
+                exit(1);
+            }
+            b_info->irqs[i] = ul;
+        }
+    }
+
+    if (!xlu_cfg_get_list(config, "iomem", &iomem, &num_iomem, 0)) {
+        b_info->num_iomem = num_iomem;
+        b_info->iomem = calloc(num_iomem, sizeof(*b_info->iomem));
+        if (b_info->iomem == NULL) {
+            fprintf(stderr, "unable to allocate memory for iomem\n");
+            exit(-1);
+        }
+        for (i = 0; i < num_iomem; i++) {
+            buf = xlu_cfg_get_listitem (iomem, i);
+            if (!buf) {
+                fprintf(stderr,
+                        "xl: Unable to get element %d in iomem list\n", i);
+                exit(1);
+            }
+            if(sscanf(buf, "%" SCNx64",%" SCNx64,
+                     &b_info->iomem[i].start,
+                     &b_info->iomem[i].number)
+                  != 2) {
+               fprintf(stderr,
+                       "xl: Invalid argument parsing iomem: %s\n", buf);
+               exit(1);
+            }
+        }
+    }
+
+
+
+    if (!xlu_cfg_get_list (config, "disk", &vbds, 0, 0)) {
+        d_config->num_disks = 0;
+        d_config->disks = NULL;
+        while ((buf = xlu_cfg_get_listitem (vbds, d_config->num_disks)) != NULL) {
+            libxl_device_disk *disk;
+            char *buf2 = strdup(buf);
+
+            d_config->disks = (libxl_device_disk *) realloc(d_config->disks, sizeof (libxl_device_disk) * (d_config->num_disks + 1));
+            disk = d_config->disks + d_config->num_disks;
+            parse_disk_config(&config, buf2, disk);
+
+            free(buf2);
+            d_config->num_disks++;
+        }
+    }
+
+    if (!xlu_cfg_get_list(config, "vtpm", &vtpms, 0, 0)) {
+        d_config->num_vtpms = 0;
+        d_config->vtpms = NULL;
+        while ((buf = xlu_cfg_get_listitem (vtpms, d_config->num_vtpms)) != NULL) {
+            libxl_device_vtpm *vtpm;
+            char * buf2 = strdup(buf);
+            char *p, *p2;
+            bool got_backend = false;
+
+            d_config->vtpms = (libxl_device_vtpm *) realloc(d_config->vtpms,
+                  sizeof(libxl_device_vtpm) * (d_config->num_vtpms+1));
+            vtpm = d_config->vtpms + d_config->num_vtpms;
+            libxl_device_vtpm_init(vtpm);
+            vtpm->devid = d_config->num_vtpms;
+
+            p = strtok(buf2, ",");
+            if(p) {
+               do {
+                  while(*p == ' ')
+                     ++p;
+                  if ((p2 = strchr(p, '=')) == NULL)
+                     break;
+                  *p2 = '\0';
+                  if (!strcmp(p, "backend")) {
+                     if(domain_qualifier_to_domid(p2 + 1, &(vtpm->backend_domid), 0))
+                     {
+                        fprintf(stderr,
+                              "Specified vtpm backend domain `%s' does not exist!\n", p2 + 1);
+                        exit(1);
+                     }
+                     got_backend = true;
+                  } else if(!strcmp(p, "uuid")) {
+                     if( libxl_uuid_from_string(&vtpm->uuid, p2 + 1) ) {
+                        fprintf(stderr,
+                              "Failed to parse vtpm UUID: %s\n", p2 + 1);
+                        exit(1);
+                    }
+                  } else {
+                     fprintf(stderr, "Unknown string `%s' in vtpm spec\n", p);
+                     exit(1);
+                  }
+               } while ((p = strtok(NULL, ",")) != NULL);
+            }
+            if(!got_backend) {
+               fprintf(stderr, "vtpm spec missing required backend field!\n");
+               exit(1);
+            }
+            free(buf2);
+            d_config->num_vtpms++;
+        }
+    }
+
+    if (!xlu_cfg_get_list (config, "vif", &nics, 0, 0)) {
+        d_config->num_nics = 0;
+        d_config->nics = NULL;
+        while ((buf = xlu_cfg_get_listitem (nics, d_config->num_nics)) != NULL) {
+            libxl_device_nic *nic;
+            char *buf2 = strdup(buf);
+            char *p, *p2;
+
+            d_config->nics = (libxl_device_nic *) realloc(d_config->nics, sizeof (libxl_device_nic) * (d_config->num_nics+1));
+            nic = d_config->nics + d_config->num_nics;
+            libxl_device_nic_init(nic);
+            nic->devid = d_config->num_nics;
+
+            if (default_vifscript) {
+                free(nic->script);
+                nic->script = strdup(default_vifscript);
+            }
+
+            if (default_bridge) {
+                free(nic->bridge);
+                nic->bridge = strdup(default_bridge);
+            }
+
+            if (default_gatewaydev) {
+                free(nic->gatewaydev);
+                nic->gatewaydev = strdup(default_gatewaydev);
+            }
+
+            p = strtok(buf2, ",");
+            if (!p)
+                goto skip_nic;
+            do {
+                while (*p == ' ')
+                    p++;
+                if ((p2 = strchr(p, '=')) == NULL)
+                    break;
+                *p2 = '\0';
+                if (!strcmp(p, "model")) {
+                    free(nic->model);
+                    nic->model = strdup(p2 + 1);
+                } else if (!strcmp(p, "mac")) {
+                    char *p3 = p2 + 1;
+                    *(p3 + 2) = '\0';
+                    nic->mac[0] = strtol(p3, NULL, 16);
+                    p3 = p3 + 3;
+                    *(p3 + 2) = '\0';
+                    nic->mac[1] = strtol(p3, NULL, 16);
+                    p3 = p3 + 3;
+                    *(p3 + 2) = '\0';
+                    nic->mac[2] = strtol(p3, NULL, 16);
+                    p3 = p3 + 3;
+                    *(p3 + 2) = '\0';
+                    nic->mac[3] = strtol(p3, NULL, 16);
+                    p3 = p3 + 3;
+                    *(p3 + 2) = '\0';
+                    nic->mac[4] = strtol(p3, NULL, 16);
+                    p3 = p3 + 3;
+                    *(p3 + 2) = '\0';
+                    nic->mac[5] = strtol(p3, NULL, 16);
+                } else if (!strcmp(p, "bridge")) {
+                    free(nic->bridge);
+                    nic->bridge = strdup(p2 + 1);
+                } else if (!strcmp(p, "type")) {
+                    if (!strcmp(p2 + 1, "ioemu"))
+                        nic->nictype = LIBXL_NIC_TYPE_VIF_IOEMU;
+                    else
+                        nic->nictype = LIBXL_NIC_TYPE_VIF;
+                } else if (!strcmp(p, "ip")) {
+                    free(nic->ip);
+                    nic->ip = strdup(p2 + 1);
+                } else if (!strcmp(p, "script")) {
+                    free(nic->script);
+                    nic->script = strdup(p2 + 1);
+                } else if (!strcmp(p, "vifname")) {
+                    free(nic->ifname);
+                    nic->ifname = strdup(p2 + 1);
+                } else if (!strcmp(p, "backend")) {
+                    if(libxl_name_to_domid(ctx, (p2 + 1), &(nic->backend_domid))) {
+                        fprintf(stderr, "Specified backend domain does not exist, defaulting to Dom0\n");
+                        nic->backend_domid = 0;
+                    }
+                    if (nic->backend_domid != 0 && run_hotplug_scripts) {
+                        fprintf(stderr, "ERROR: the vif 'backend=' option "
+                                "cannot be used in conjunction with "
+                                "run_hotplug_scripts, please set "
+                                "run_hotplug_scripts to 0 in xl.conf\n");
+                        exit(EXIT_FAILURE);
+                    }
+                } else if (!strcmp(p, "rate")) {
+                    parse_vif_rate(&config, (p2 + 1), nic);
+                } else if (!strcmp(p, "accel")) {
+                    fprintf(stderr, "the accel parameter for vifs is currently not supported\n");
+                } else if (!strcmp(p, "netdev")) {
+                    fprintf(stderr, "the netdev parameter is deprecated, "
+                                    "please use gatewaydev instead\n");
+                    free(nic->gatewaydev);
+                    nic->gatewaydev = strdup(p2 + 1);
+                } else if (!strcmp(p, "gatewaydev")) {
+                    free(nic->gatewaydev);
+                    nic->gatewaydev = strdup(p2 + 1);
+                }
+            } while ((p = strtok(NULL, ",")) != NULL);
+skip_nic:
+            free(buf2);
+            d_config->num_nics++;
+        }
+    }
+
+    if (!xlu_cfg_get_list(config, "vif2", NULL, 0, 0)) {
+        fprintf(stderr, "WARNING: vif2: netchannel2 is deprecated and not supported by xl\n");
+    }
+
+    if (!xlu_cfg_get_list (config, "vfb", &cvfbs, 0, 0)) {
+        d_config->num_vfbs = 0;
+        d_config->num_vkbs = 0;
+        d_config->vfbs = NULL;
+        d_config->vkbs = NULL;
+        while ((buf = xlu_cfg_get_listitem (cvfbs, d_config->num_vfbs)) != NULL) {
+            libxl_device_vfb *vfb;
+            libxl_device_vkb *vkb;
+
+            char *buf2 = strdup(buf);
+            char *p, *p2;
+
+            d_config->vfbs = (libxl_device_vfb *) realloc(d_config->vfbs, sizeof(libxl_device_vfb) * (d_config->num_vfbs + 1));
+            vfb = d_config->vfbs + d_config->num_vfbs;
+            libxl_device_vfb_init(vfb);
+            vfb->devid = d_config->num_vfbs;
+
+            d_config->vkbs = (libxl_device_vkb *) realloc(d_config->vkbs, sizeof(libxl_device_vkb) * (d_config->num_vkbs + 1));
+            vkb = d_config->vkbs + d_config->num_vkbs;
+            libxl_device_vkb_init(vkb);
+            vkb->devid = d_config->num_vkbs;
+
+            p = strtok(buf2, ",");
+            if (!p)
+                goto skip_vfb;
+            do {
+                while (*p == ' ')
+                    p++;
+                if ((p2 = strchr(p, '=')) == NULL)
+                    break;
+                *p2 = '\0';
+                if (!strcmp(p, "vnc")) {
+                    libxl_defbool_set(&vfb->vnc.enable, atoi(p2 + 1));
+                } else if (!strcmp(p, "vnclisten")) {
+                    free(vfb->vnc.listen);
+                    vfb->vnc.listen = strdup(p2 + 1);
+                } else if (!strcmp(p, "vncpasswd")) {
+                    free(vfb->vnc.passwd);
+                    vfb->vnc.passwd = strdup(p2 + 1);
+                } else if (!strcmp(p, "vncdisplay")) {
+                    vfb->vnc.display = atoi(p2 + 1);
+                } else if (!strcmp(p, "vncunused")) {
+                    libxl_defbool_set(&vfb->vnc.findunused, atoi(p2 + 1));
+                } else if (!strcmp(p, "keymap")) {
+                    free(vfb->keymap);
+                    vfb->keymap = strdup(p2 + 1);
+                } else if (!strcmp(p, "sdl")) {
+                    libxl_defbool_set(&vfb->sdl.enable, atoi(p2 + 1));
+                } else if (!strcmp(p, "opengl")) {
+                    libxl_defbool_set(&vfb->sdl.opengl, atoi(p2 + 1));
+                } else if (!strcmp(p, "display")) {
+                    free(vfb->sdl.display);
+                    vfb->sdl.display = strdup(p2 + 1);
+                } else if (!strcmp(p, "xauthority")) {
+                    free(vfb->sdl.xauthority);
+                    vfb->sdl.xauthority = strdup(p2 + 1);
+                }
+            } while ((p = strtok(NULL, ",")) != NULL);
+
+skip_vfb:
+            free(buf2);
+            d_config->num_vfbs++;
+            d_config->num_vkbs++;
+        }
+    }
+
+    if (!xlu_cfg_get_long (config, "pci_msitranslate", &l, 0))
+        pci_msitranslate = l;
+
+    if (!xlu_cfg_get_long (config, "pci_power_mgmt", &l, 0))
+        pci_power_mgmt = l;
+
+    if (!xlu_cfg_get_long (config, "pci_permissive", &l, 0))
+        pci_permissive = l;
+
+    /* To be reworked (automatically enabled) once the auto ballooning
+     * after guest starts is done (with PCI devices passed in). */
+    if (c_info->type == LIBXL_DOMAIN_TYPE_PV) {
+        xlu_cfg_get_defbool(config, "e820_host", &b_info->u.pv.e820_host, 0);
+    }
+
+    if (!xlu_cfg_get_list (config, "pci", &pcis, 0, 0)) {
+        d_config->num_pcidevs = 0;
+        d_config->pcidevs = NULL;
+        for(i = 0; (buf = xlu_cfg_get_listitem (pcis, i)) != NULL; i++) {
+            libxl_device_pci *pcidev;
+
+            d_config->pcidevs = (libxl_device_pci *) realloc(d_config->pcidevs, sizeof (libxl_device_pci) * (d_config->num_pcidevs + 1));
+            pcidev = d_config->pcidevs + d_config->num_pcidevs;
+            libxl_device_pci_init(pcidev);
+
+            pcidev->msitranslate = pci_msitranslate;
+            pcidev->power_mgmt = pci_power_mgmt;
+            pcidev->permissive = pci_permissive;
+            if (!xlu_pci_parse_bdf(config, pcidev, buf))
+                d_config->num_pcidevs++;
+        }
+        if (d_config->num_pcidevs && c_info->type == LIBXL_DOMAIN_TYPE_PV)
+            libxl_defbool_set(&b_info->u.pv.e820_host, true);
+    }
+
+    switch (xlu_cfg_get_list(config, "cpuid", &cpuids, 0, 1)) {
+    case 0:
+        {
+            const char *errstr;
+
+            for (i = 0; (buf = xlu_cfg_get_listitem(cpuids, i)) != NULL; i++) {
+                e = libxl_cpuid_parse_config_xend(&b_info->cpuid, buf);
+                switch (e) {
+                case 0: continue;
+                case 1:
+                    errstr = "illegal leaf number";
+                    break;
+                case 2:
+                    errstr = "illegal subleaf number";
+                    break;
+                case 3:
+                    errstr = "missing colon";
+                    break;
+                case 4:
+                    errstr = "invalid register name (must be e[abcd]x)";
+                    break;
+                case 5:
+                    errstr = "policy string must be exactly 32 characters long";
+                    break;
+                default:
+                    errstr = "unknown error";
+                    break;
+                }
+                fprintf(stderr, "while parsing CPUID line: \"%s\":\n", buf);
+                fprintf(stderr, "  error #%i: %s\n", e, errstr);
+            }
+        }
+        break;
+    case EINVAL:    /* config option is not a list, parse as a string */
+        if (!xlu_cfg_get_string(config, "cpuid", &buf, 0)) {
+            char *buf2, *p, *strtok_ptr = NULL;
+            const char *errstr;
+
+            buf2 = strdup(buf);
+            p = strtok_r(buf2, ",", &strtok_ptr);
+            if (p == NULL) {
+                free(buf2);
+                break;
+            }
+            if (strcmp(p, "host")) {
+                fprintf(stderr, "while parsing CPUID string: \"%s\":\n", buf);
+                fprintf(stderr, "  error: first word must be \"host\"\n");
+                free(buf2);
+                break;
+            }
+            for (p = strtok_r(NULL, ",", &strtok_ptr); p != NULL;
+                 p = strtok_r(NULL, ",", &strtok_ptr)) {
+                e = libxl_cpuid_parse_config(&b_info->cpuid, p);
+                switch (e) {
+                case 0: continue;
+                case 1:
+                    errstr = "missing \"=\" in key=value";
+                    break;
+                case 2:
+                    errstr = "unknown CPUID flag name";
+                    break;
+                case 3:
+                    errstr = "illegal CPUID value (must be: [0|1|x|k|s])";
+                    break;
+                default:
+                    errstr = "unknown error";
+                    break;
+                }
+                fprintf(stderr, "while parsing CPUID flag: \"%s\":\n", p);
+                fprintf(stderr, "  error #%i: %s\n", e, errstr);
+            }
+            free(buf2);
+        }
+        break;
+    default:
+        break;
+    }
+
+    /* parse device model arguments, this works for pv, hvm and stubdom */
+    if (!xlu_cfg_get_string (config, "device_model", &buf, 0)) {
+        fprintf(stderr,
+                "WARNING: ignoring device_model directive.\n"
+                "WARNING: Use \"device_model_override\" instead if you"
+                " really want a non-default device_model\n");
+        if (strstr(buf, "stubdom-dm")) {
+            if (c_info->type == LIBXL_DOMAIN_TYPE_HVM)
+                fprintf(stderr, "WARNING: Or use"
+                        " \"device_model_stubdomain_override\" if you "
+                        " want to enable stubdomains\n");
+            else
+                fprintf(stderr, "WARNING: ignoring"
+                        " \"device_model_stubdomain_override\" directive"
+                        " for pv guest\n");
+        }
+    }
+
+
+    xlu_cfg_replace_string (config, "device_model_override",
+                            &b_info->device_model, 0);
+    if (!xlu_cfg_get_string (config, "device_model_version", &buf, 0)) {
+        if (!strcmp(buf, "qemu-xen-traditional")) {
+            b_info->device_model_version
+                = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;
+        } else if (!strcmp(buf, "qemu-xen")) {
+            b_info->device_model_version
+                = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;
+        } else {
+            fprintf(stderr,
+                    "Unknown device_model_version \"%s\" specified\n", buf);
+            exit(1);
+        }
+    } else if (b_info->device_model)
+        fprintf(stderr, "WARNING: device model override given without specific DM version\n");
+    xlu_cfg_get_defbool (config, "device_model_stubdomain_override",
+                         &b_info->device_model_stubdomain, 0);
+
+    if (!xlu_cfg_get_string (config, "device_model_stubdomain_seclabel",
+                             &buf, 0)) {
+        e = libxl_flask_context_to_sid(ctx, (char *)buf, strlen(buf),
+                                    &b_info->device_model_ssidref);
+        if (e) {
+            if (errno == ENOSYS) {
+                fprintf(stderr, "XSM Disabled:"
+                        " device_model_stubdomain_seclabel not supported\n");
+            } else {
+                fprintf(stderr, "Invalid device_model_stubdomain_seclabel:"
+                        " %s\n", buf);
+                exit(1);
+            }
+        }
+    }
+#define parse_extra_args(type)                                            \
+    e = xlu_cfg_get_list_as_string_list(config, "device_model_args"#type, \
+                                    &b_info->extra##type, 0);            \
+    if (e && e != ESRCH) {                                                \
+        fprintf(stderr,"xl: Unable to parse device_model_args"#type".\n");\
+        exit(-ERROR_FAIL);                                                \
+    }
+
+    /* parse extra args for qemu, common to both pv, hvm */
+    parse_extra_args();
+
+    /* parse extra args dedicated to pv */
+    parse_extra_args(_pv);
+
+    /* parse extra args dedicated to hvm */
+    parse_extra_args(_hvm);
+
+#undef parse_extra_args
+
+    if (c_info->type == LIBXL_DOMAIN_TYPE_HVM) {
+        if (!xlu_cfg_get_string (config, "vga", &buf, 0)) {
+            if (!strcmp(buf, "stdvga")) {
+                b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_STD;
+            } else if (!strcmp(buf, "cirrus")) {
+                b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_CIRRUS;
+            } else if (!strcmp(buf, "qxl")) {
+                b_info->u.hvm.vga.kind = LIBXL_VGA_INTERFACE_TYPE_QXL;
+            } else {
+                fprintf(stderr, "Unknown vga \"%s\" specified\n", buf);
+                exit(1);
+            }
+        } else if (!xlu_cfg_get_long(config, "stdvga", &l, 0))
+            b_info->u.hvm.vga.kind = l ? LIBXL_VGA_INTERFACE_TYPE_STD :
+                                         LIBXL_VGA_INTERFACE_TYPE_CIRRUS;
+
+        xlu_cfg_get_defbool(config, "vnc", &b_info->u.hvm.vnc.enable, 0);
+        xlu_cfg_replace_string (config, "vnclisten",
+                                &b_info->u.hvm.vnc.listen, 0);
+        xlu_cfg_replace_string (config, "vncpasswd",
+                                &b_info->u.hvm.vnc.passwd, 0);
+        if (!xlu_cfg_get_long (config, "vncdisplay", &l, 0))
+            b_info->u.hvm.vnc.display = l;
+        xlu_cfg_get_defbool(config, "vncunused",
+                            &b_info->u.hvm.vnc.findunused, 0);
+        xlu_cfg_replace_string (config, "keymap", &b_info->u.hvm.keymap, 0);
+        xlu_cfg_get_defbool(config, "sdl", &b_info->u.hvm.sdl.enable, 0);
+        xlu_cfg_get_defbool(config, "opengl", &b_info->u.hvm.sdl.opengl, 0);
+        xlu_cfg_get_defbool (config, "spice", &b_info->u.hvm.spice.enable, 0);
+        if (!xlu_cfg_get_long (config, "spiceport", &l, 0))
+            b_info->u.hvm.spice.port = l;
+        if (!xlu_cfg_get_long (config, "spicetls_port", &l, 0))
+            b_info->u.hvm.spice.tls_port = l;
+        xlu_cfg_replace_string (config, "spicehost",
+                                &b_info->u.hvm.spice.host, 0);
+        xlu_cfg_get_defbool(config, "spicedisable_ticketing",
+                            &b_info->u.hvm.spice.disable_ticketing, 0);
+        xlu_cfg_replace_string (config, "spicepasswd",
+                                &b_info->u.hvm.spice.passwd, 0);
+        xlu_cfg_get_defbool(config, "spiceagent_mouse",
+                            &b_info->u.hvm.spice.agent_mouse, 0);
+        xlu_cfg_get_defbool(config, "nographic", &b_info->u.hvm.nographic, 0);
+        xlu_cfg_get_defbool(config, "gfx_passthru", 
+                            &b_info->u.hvm.gfx_passthru, 0);
+        xlu_cfg_replace_string (config, "serial", &b_info->u.hvm.serial, 0);
+        xlu_cfg_replace_string (config, "boot", &b_info->u.hvm.boot, 0);
+        xlu_cfg_get_defbool(config, "usb", &b_info->u.hvm.usb, 0);
+        xlu_cfg_replace_string (config, "usbdevice",
+                                &b_info->u.hvm.usbdevice, 0);
+        xlu_cfg_replace_string (config, "soundhw", &b_info->u.hvm.soundhw, 0);
+        xlu_cfg_get_defbool(config, "xen_platform_pci",
+                            &b_info->u.hvm.xen_platform_pci, 0);
+
+        if(b_info->u.hvm.vnc.listen
+           && b_info->u.hvm.vnc.display
+           && strchr(b_info->u.hvm.vnc.listen, ':') != NULL) {
+            fprintf(stderr,
+                    "ERROR: Display specified both in vnclisten"
+                    " and vncdisplay!\n");
+            exit (1);
+
+        }
+    }
+
+    xlu_cfg_destroy(config);
+}
+
+static void reload_domain_config(uint32_t domid,
+                                 uint8_t **config_data, int *config_len)
+{
+    uint8_t *t_data;
+    int ret, t_len;
+
+    ret = libxl_userdata_retrieve(ctx, domid, "xl", &t_data, &t_len);
+    if (ret) {
+        LOG("failed to retrieve guest configuration (rc=%d). "
+            "reusing old configuration", ret);
+        return;
+    }
+
+    free(*config_data);
+    *config_data = t_data;
+    *config_len = t_len;
+}
+
+/* Returns 1 if domain should be restarted,
+ * 2 if domain should be renamed then restarted, or 0
+ * Can update r_domid if domain is destroyed etc */
+static int handle_domain_death(uint32_t *r_domid,
+                               libxl_event *event,
+                               uint8_t **config_data, int *config_len,
+                               libxl_domain_config *d_config)
+
+{
+    int restart = 0;
+    libxl_action_on_shutdown action;
+
+    switch (event->u.domain_shutdown.shutdown_reason) {
+    case LIBXL_SHUTDOWN_REASON_POWEROFF:
+        action = d_config->on_poweroff;
+        break;
+    case LIBXL_SHUTDOWN_REASON_REBOOT:
+        action = d_config->on_reboot;
+        break;
+    case LIBXL_SHUTDOWN_REASON_SUSPEND:
+        LOG("Domain has suspended.");
+        return 0;
+    case LIBXL_SHUTDOWN_REASON_CRASH:
+        action = d_config->on_crash;
+        break;
+    case LIBXL_SHUTDOWN_REASON_WATCHDOG:
+        action = d_config->on_watchdog;
+        break;
+    default:
+        LOG("Unknown shutdown reason code %d. Destroying domain.",
+            event->u.domain_shutdown.shutdown_reason);
+        action = LIBXL_ACTION_ON_SHUTDOWN_DESTROY;
+    }
+
+    LOG("Action for shutdown reason code %d is %s",
+        event->u.domain_shutdown.shutdown_reason,
+        action_on_shutdown_names[action]);
+
+    if (action == LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY || action == LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART) {
+        char *corefile;
+        int rc;
+
+        if (asprintf(&corefile, "/var/xen/dump/%s", d_config->c_info.name) < 0) {
+            LOG("failed to construct core dump path");
+        } else {
+            LOG("dumping core to %s", corefile);
+            rc=libxl_domain_core_dump(ctx, *r_domid, corefile, NULL);
+            if (rc) LOG("core dump failed (rc=%d).", rc);
+        }
+        /* No point crying over spilled milk, continue on failure. */
+
+        if (action == LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY)
+            action = LIBXL_ACTION_ON_SHUTDOWN_DESTROY;
+        else
+            action = LIBXL_ACTION_ON_SHUTDOWN_RESTART;
+    }
+
+    switch (action) {
+    case LIBXL_ACTION_ON_SHUTDOWN_PRESERVE:
+        break;
+
+    case LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME:
+        reload_domain_config(*r_domid, config_data, config_len);
+        restart = 2;
+        break;
+
+    case LIBXL_ACTION_ON_SHUTDOWN_RESTART:
+        reload_domain_config(*r_domid, config_data, config_len);
+
+        restart = 1;
+        /* fall-through */
+    case LIBXL_ACTION_ON_SHUTDOWN_DESTROY:
+        LOG("Domain %d needs to be cleaned up: destroying the domain",
+            *r_domid);
+        libxl_domain_destroy(ctx, *r_domid, 0);
+        *r_domid = INVALID_DOMID;
+        break;
+
+    case LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY:
+    case LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART:
+        /* Already handled these above. */
+        abort();
+    }
+
+    return restart;
+}
+
+/* for now used only by main_networkattach, but can be reused elsewhere */
+static int match_option_size(const char *prefix, size_t len,
+        char *arg, char **argopt)
+{
+    int rc = strncmp(prefix, arg, len);
+    if (!rc) *argopt = arg+len;
+    return !rc;
+}
+#define MATCH_OPTION(prefix, arg, oparg) \
+    match_option_size((prefix "="), sizeof((prefix)), (arg), &(oparg))
+
+static void replace_string(char **str, const char *val)
+{
+    free(*str);
+    *str = strdup(val);
+}
+
+
+/* Preserve a copy of a domain under a new name. Updates *r_domid */
+static int preserve_domain(uint32_t *r_domid, libxl_event *event,
+                           libxl_domain_config *d_config)
+{
+    time_t now;
+    struct tm tm;
+    char strtime[24];
+
+    libxl_uuid new_uuid;
+
+    int rc;
+
+    now = time(NULL);
+    if (now == ((time_t) -1)) {
+        LOG("Failed to get current time for domain rename");
+        return 0;
+    }
+
+    tzset();
+    if (gmtime_r(&now, &tm) == NULL) {
+        LOG("Failed to convert time to UTC");
+        return 0;
+    }
+
+    if (!strftime(&strtime[0], sizeof(strtime), "-%Y%m%dT%H%MZ", &tm)) {
+        LOG("Failed to format time as a string");
+        return 0;
+    }
+
+    libxl_uuid_generate(&new_uuid);
+
+    LOG("Preserving domain %d %s with suffix%s",
+        *r_domid, d_config->c_info.name, strtime);
+    rc = libxl_domain_preserve(ctx, *r_domid, &d_config->c_info,
+                               strtime, new_uuid);
+
+    /*
+     * Although the domain still exists it is no longer the one we are
+     * concerned with.
+     */
+    *r_domid = INVALID_DOMID;
+
+    return rc == 0 ? 1 : 0;
+}
+
+static int freemem(uint32_t domid, libxl_domain_build_info *b_info)
+{
+    int rc, retries = 3;
+    uint32_t need_memkb, free_memkb;
+
+    if (!autoballoon)
+        return 0;
+
+    rc = libxl_domain_need_memory(ctx, b_info, &need_memkb);
+    if (rc < 0)
+        return rc;
+
+    do {
+        rc = libxl_get_free_memory(ctx, &free_memkb);
+        if (rc < 0)
+            return rc;
+
+        if (free_memkb >= need_memkb)
+            return 0;
+
+        rc = libxl_set_memory_target(ctx, 0, free_memkb - need_memkb, 1, 0);
+        if (rc < 0)
+            return rc;
+
+        rc = libxl_wait_for_free_memory(ctx, domid, need_memkb, 10);
+        if (!rc)
+            return 0;
+        else if (rc != ERROR_NOMEM)
+            return rc;
+
+        /* the memory target has been reached but the free memory is still
+         * not enough: loop over again */
+        rc = libxl_wait_for_memory_target(ctx, 0, 1);
+        if (rc < 0)
+            return rc;
+
+        retries--;
+    } while (retries > 0);
+
+    return ERROR_NOMEM;
+}
+
+static void console_child_report(void)
+{
+    if (xl_child_pid(child_console)) {
+        int status;
+        pid_t got = xl_waitpid(child_console, &status, 0);
+        if (got < 0)
+            perror("xl: warning, failed to waitpid for console child");
+        else if (status)
+            libxl_report_child_exitstatus(ctx, XTL_ERROR, "console child",
+                                          xl_child_pid(child_console), status);
+    }
+}
+
+static void autoconnect_console(libxl_ctx *ctx_ignored,
+                                libxl_event *ev, void *priv)
+{
+    uint32_t bldomid = ev->domid;
+
+    libxl_event_free(ctx, ev);
+
+    console_child_report();
+
+    pid_t pid = xl_fork(child_console);
+    if (pid < 0) {
+        perror("unable to fork xenconsole");
+        return;
+    } else if (pid > 0)
+        return;
+
+    postfork();
+
+    sleep(1);
+    libxl_primary_console_exec(ctx, bldomid);
+    /* Do not return. xl continued in child process */
+    fprintf(stderr, "Unable to attach console\n");
+    _exit(1);
+}
+
+static int domain_wait_event(uint32_t domid, libxl_event **event_r)
+{
+    int ret;
+    for (;;) {
+        ret = libxl_event_wait(ctx, event_r, LIBXL_EVENTMASK_ALL, 0,0);
+        if (ret) {
+            LOG("Domain %d, failed to get event, quitting (rc=%d)", domid, ret);
+            return ret;
+        }
+        if ((*event_r)->domid != domid) {
+            char *evstr = libxl_event_to_json(ctx, *event_r);
+            LOG("INTERNAL PROBLEM - ignoring unexpected event for"
+                " domain %d (expected %d): event=%s",
+                (*event_r)->domid, domid, evstr);
+            free(evstr);
+            libxl_event_free(ctx, *event_r);
+            continue;
+        }
+        return ret;
+    }
+}
+
+static void evdisable_disk_ejects(libxl_evgen_disk_eject **diskws,
+                                 int num_disks)
+{
+    int i;
+
+    for (i = 0; i < num_disks; i++) {
+        if (diskws[i])
+            libxl_evdisable_disk_eject(ctx, diskws[i]);
+        diskws[i] = NULL;
+    }
+}
+
+static uint32_t create_domain(struct domain_create *dom_info)
+{
+    uint32_t domid = INVALID_DOMID;
+
+    libxl_domain_config d_config;
+
+    int debug = dom_info->debug;
+    int daemonize = dom_info->daemonize;
+    int monitor = dom_info->monitor;
+    int paused = dom_info->paused;
+    int vncautopass = dom_info->vncautopass;
+    const char *config_file = dom_info->config_file;
+    const char *extra_config = dom_info->extra_config;
+    const char *restore_file = dom_info->restore_file;
+    const char *config_source = NULL;
+    const char *restore_source = NULL;
+    int migrate_fd = dom_info->migrate_fd;
+
+    int i;
+    int need_daemon = daemonize;
+    int ret, rc;
+    libxl_evgen_domain_death *deathw = NULL;
+    libxl_evgen_disk_eject **diskws = NULL; /* one per disk */
+    void *config_data = 0;
+    int config_len = 0;
+    int restore_fd = -1;
+    int status = 0;
+    const libxl_asyncprogress_how *autoconnect_console_how;
+    struct save_file_header hdr;
+
+    int restoring = (restore_file || (migrate_fd >= 0));
+
+    libxl_domain_config_init(&d_config);
+
+    if (restoring) {
+        uint8_t *optdata_begin = 0;
+        const uint8_t *optdata_here = 0;
+        union { uint32_t u32; char b[4]; } u32buf;
+        uint32_t badflags;
+
+        if (migrate_fd >= 0) {
+            restore_source = "<incoming migration stream>";
+            restore_fd = migrate_fd;
+        } else {
+            restore_source = restore_file;
+            restore_fd = open(restore_file, O_RDONLY);
+            rc = libxl_fd_set_cloexec(ctx, restore_fd, 1);
+            if (rc) return rc;
+        }
+
+        CHK_ERRNO( libxl_read_exactly(ctx, restore_fd, &hdr,
+                   sizeof(hdr), restore_source, "header") );
+        if (memcmp(hdr.magic, savefileheader_magic, sizeof(hdr.magic))) {
+            fprintf(stderr, "File has wrong magic number -"
+                    " corrupt or for a different tool?\n");
+            return ERROR_INVAL;
+        }
+        if (hdr.byteorder != SAVEFILE_BYTEORDER_VALUE) {
+            fprintf(stderr, "File has wrong byte order\n");
+            return ERROR_INVAL;
+        }
+        fprintf(stderr, "Loading new save file %s"
+                " (new xl fmt info"
+                " 0x%"PRIx32"/0x%"PRIx32"/%"PRIu32")\n",
+                restore_source, hdr.mandatory_flags, hdr.optional_flags,
+                hdr.optional_data_len);
+
+        badflags = hdr.mandatory_flags & ~( 0 /* none understood yet */ );
+        if (badflags) {
+            fprintf(stderr, "Savefile has mandatory flag(s) 0x%"PRIx32" "
+                    "which are not supported; need newer xl\n",
+                    badflags);
+            return ERROR_INVAL;
+        }
+        if (hdr.optional_data_len) {
+            optdata_begin = xmalloc(hdr.optional_data_len);
+            CHK_ERRNO( libxl_read_exactly(ctx, restore_fd, optdata_begin,
+                   hdr.optional_data_len, restore_source, "optdata") );
+        }
+
+#define OPTDATA_LEFT  (hdr.optional_data_len - (optdata_here - optdata_begin))
+#define WITH_OPTDATA(amt, body)                                 \
+            if (OPTDATA_LEFT < (amt)) {                         \
+                fprintf(stderr, "Savefile truncated.\n");       \
+                return ERROR_INVAL;                             \
+            } else {                                            \
+                body;                                           \
+                optdata_here += (amt);                          \
+            }
+
+        optdata_here = optdata_begin;
+
+        if (OPTDATA_LEFT) {
+            fprintf(stderr, " Savefile contains xl domain config\n");
+            WITH_OPTDATA(4, {
+                memcpy(u32buf.b, optdata_here, 4);
+                config_len = u32buf.u32;
+            });
+            WITH_OPTDATA(config_len, {
+                config_data = xmalloc(config_len);
+                memcpy(config_data, optdata_here, config_len);
+            });
+        }
+
+    }
+
+    if (config_file) {
+        free(config_data);  config_data = 0;
+        /* /dev/null represents special case (read config. from command line) */
+        if (!strcmp(config_file, "/dev/null")) {
+            config_len = 0;
+        } else {
+            ret = libxl_read_file_contents(ctx, config_file,
+                                           &config_data, &config_len);
+            if (ret) { fprintf(stderr, "Failed to read config file: %s: %s\n",
+                               config_file, strerror(errno)); return ERROR_FAIL; }
+        }
+        if (!restoring && extra_config && strlen(extra_config)) {
+            if (config_len > INT_MAX - (strlen(extra_config) + 2 + 1)) {
+                fprintf(stderr, "Failed to attach extra configration\n");
+                return ERROR_FAIL;
+            }
+            /* allocate space for the extra config plus two EOLs plus \0 */
+            config_data = realloc(config_data, config_len
+                + strlen(extra_config) + 2 + 1);
+            if (!config_data) {
+                fprintf(stderr, "Failed to realloc config_data\n");
+                return ERROR_FAIL;
+            }
+            config_len += sprintf(config_data + config_len, "\n%s\n",
+                extra_config);
+        }
+        config_source=config_file;
+    } else {
+        if (!config_data) {
+            fprintf(stderr, "Config file not specified and"
+                    " none in save file\n");
+            return ERROR_INVAL;
+        }
+        config_source = "<saved>";
+    }
+
+    if (!dom_info->quiet)
+        printf("Parsing config from %s\n", config_source);
+
+    parse_config_data(config_source, config_data, config_len, &d_config, dom_info);
+
+    if (migrate_fd >= 0) {
+        if (d_config.c_info.name) {
+            /* when we receive a domain we get its name from the config
+             * file; and we receive it to a temporary name */
+            assert(!common_domname);
+
+            common_domname = d_config.c_info.name;
+            d_config.c_info.name = 0; /* steals allocation from config */
+
+            if (asprintf(&d_config.c_info.name,
+                         "%s--incoming", common_domname) < 0) {
+                fprintf(stderr, "Failed to allocate memory in asprintf\n");
+                exit(1);
+            }
+            *dom_info->migration_domname_r = strdup(d_config.c_info.name);
+        }
+    }
+
+    if (debug || dom_info->dryrun)
+        printf_info(default_output_format, -1, &d_config);
+
+    ret = 0;
+    if (dom_info->dryrun)
+        goto out;
+
+start:
+    assert(domid == INVALID_DOMID);
+
+    rc = acquire_lock();
+    if (rc < 0)
+        goto error_out;
+
+    ret = freemem(domid, &d_config.b_info);
+    if (ret < 0) {
+        fprintf(stderr, "failed to free memory for the domain\n");
+        ret = ERROR_FAIL;
+        goto error_out;
+    }
+
+    libxl_asyncprogress_how autoconnect_console_how_buf;
+    if ( dom_info->console_autoconnect ) {
+        autoconnect_console_how_buf.callback = autoconnect_console;
+        autoconnect_console_how = &autoconnect_console_how_buf;
+    }else{
+        autoconnect_console_how = 0;
+    }
+
+    if ( restoring ) {
+        ret = libxl_domain_create_restore(ctx, &d_config,
+                                          &domid, restore_fd,
+                                          0, autoconnect_console_how);
+        /*
+         * On subsequent reboot etc we should create the domain, not
+         * restore/migrate-receive it again.
+         */
+        restoring = 0;
+    }else{
+        ret = libxl_domain_create_new(ctx, &d_config, &domid,
+                                      0, autoconnect_console_how);
+    }
+    if ( ret )
+        goto error_out;
+
+    /* If single vcpu to pcpu mapping was requested, honour it */
+    if (vcpu_to_pcpu) {
+        libxl_bitmap vcpu_cpumap;
+
+        ret = libxl_cpu_bitmap_alloc(ctx, &vcpu_cpumap, 0);
+        if (ret)
+            goto error_out;
+        for (i = 0; i < d_config.b_info.max_vcpus; i++) {
+
+            if (vcpu_to_pcpu[i] != -1) {
+                libxl_bitmap_set_none(&vcpu_cpumap);
+                libxl_bitmap_set(&vcpu_cpumap, vcpu_to_pcpu[i]);
+            } else {
+                libxl_bitmap_set_any(&vcpu_cpumap);
+            }
+            if (libxl_set_vcpuaffinity(ctx, domid, i, &vcpu_cpumap)) {
+                fprintf(stderr, "setting affinity failed on vcpu `%d'.\n", i);
+                libxl_bitmap_dispose(&vcpu_cpumap);
+                free(vcpu_to_pcpu);
+                ret = ERROR_FAIL;
+                goto error_out;
+            }
+        }
+        libxl_bitmap_dispose(&vcpu_cpumap);
+        free(vcpu_to_pcpu); vcpu_to_pcpu = NULL;
+    }
+
+    ret = libxl_userdata_store(ctx, domid, "xl",
+                                    config_data, config_len);
+    if (ret) {
+        perror("cannot save config file");
+        ret = ERROR_FAIL;
+        goto error_out;
+    }
+
+    release_lock();
+
+    if (!paused)
+        libxl_domain_unpause(ctx, domid);
+
+    ret = domid; /* caller gets success in parent */
+    if (!daemonize && !monitor)
+        goto out;
+
+    if (dom_info->vnc)
+        vncviewer(domid, vncautopass);
+
+    if (need_daemon) {
+        char *fullname, *name;
+        pid_t child1, got_child;
+        int nullfd;
+
+        child1 = xl_fork(child_waitdaemon);
+        if (child1) {
+            printf("Daemon running with PID %d\n", child1);
+
+            for (;;) {
+                got_child = xl_waitpid(child_waitdaemon, &status, 0);
+                if (got_child == child1) break;
+                assert(got_child == -1);
+                perror("failed to wait for daemonizing child");
+                ret = ERROR_FAIL;
+                goto out;
+            }
+            if (status) {
+                libxl_report_child_exitstatus(ctx, XTL_ERROR,
+                           "daemonizing child", child1, status);
+                ret = ERROR_FAIL;
+                goto out;
+            }
+            ret = domid;
+            goto out;
+        }
+
+        postfork();
+
+        if (asprintf(&name, "xl-%s", d_config.c_info.name) < 0) {
+            LOG("Failed to allocate memory in asprintf");
+            exit(1);
+        }
+        rc = libxl_create_logfile(ctx, name, &fullname);
+        if (rc) {
+            LOG("failed to open logfile %s: %s",fullname,strerror(errno));
+            exit(-1);
+        }
+
+        CHK_ERRNO(( logfile = open(fullname, O_WRONLY|O_CREAT|O_APPEND,
+                                   0644) )<0);
+        free(fullname);
+        free(name);
+
+        CHK_ERRNO(( nullfd = open("/dev/null", O_RDONLY) )<0);
+        dup2(nullfd, 0);
+        dup2(logfile, 1);
+        dup2(logfile, 2);
+
+        CHK_ERRNO(daemon(0, 1) < 0);
+        need_daemon = 0;
+    }
+    LOG("Waiting for domain %s (domid %d) to die [pid %ld]",
+        d_config.c_info.name, domid, (long)getpid());
+
+    ret = libxl_evenable_domain_death(ctx, domid, 0, &deathw);
+    if (ret) goto out;
+
+    if (!diskws) {
+        diskws = xmalloc(sizeof(*diskws) * d_config.num_disks);
+        for (i = 0; i < d_config.num_disks; i++)
+            diskws[i] = NULL;
+    }
+    for (i = 0; i < d_config.num_disks; i++) {
+        if (d_config.disks[i].removable) {
+            ret = libxl_evenable_disk_eject(ctx, domid, d_config.disks[i].vdev,
+                                            0, &diskws[i]);
+            if (ret) goto out;
+        }
+    }
+    while (1) {
+        libxl_event *event;
+        ret = domain_wait_event(domid, &event);
+        if (ret) goto out;
+
+        switch (event->type) {
+
+        case LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN:
+            LOG("Domain %d has shut down, reason code %d 0x%x", domid,
+                event->u.domain_shutdown.shutdown_reason,
+                event->u.domain_shutdown.shutdown_reason);
+            switch (handle_domain_death(&domid, event,
+                                        (uint8_t **)&config_data, &config_len,
+                                        &d_config)) {
+            case 2:
+                if (!preserve_domain(&domid, event, &d_config)) {
+                    /* If we fail then exit leaving the old domain in place. */
+                    ret = -1;
+                    goto out;
+                }
+
+                /* Otherwise fall through and restart. */
+            case 1:
+                libxl_event_free(ctx, event);
+                libxl_evdisable_domain_death(ctx, deathw);
+                deathw = NULL;
+                evdisable_disk_ejects(diskws, d_config.num_disks);
+                /* discard any other events which may have been generated */
+                while (!(ret = libxl_event_check(ctx, &event,
+                                                 LIBXL_EVENTMASK_ALL, 0,0))) {
+                    libxl_event_free(ctx, event);
+                }
+                if (ret != ERROR_NOT_READY) {
+                    LOG("warning, libxl_event_check (cleanup) failed (rc=%d)",
+                        ret);
+                }
+
+                /*
+                 * Do not attempt to reconnect if we come round again due to a
+                 * guest reboot -- the stdin/out will be disconnected by then.
+                 */
+                dom_info->console_autoconnect = 0;
+
+                /* Some settings only make sense on first boot. */
+                paused = 0;
+                if (common_domname
+                    && strcmp(d_config.c_info.name, common_domname)) {
+                    d_config.c_info.name = strdup(common_domname);
+                }
+
+                /* Reparse the configuration in case it has changed */
+                libxl_domain_config_dispose(&d_config);
+                libxl_domain_config_init(&d_config);
+                parse_config_data(config_source, config_data, config_len,
+                                  &d_config, dom_info);
+
+                /*
+                 * XXX FIXME: If this sleep is not there then domain
+                 * re-creation fails sometimes.
+                 */
+                LOG("Done. Rebooting now");
+                sleep(2);
+                goto start;
+
+            case 0:
+                LOG("Done. Exiting now");
+                libxl_event_free(ctx, event);
+                ret = 0;
+                goto out;
+
+            default:
+                abort();
+            }
+
+        case LIBXL_EVENT_TYPE_DOMAIN_DEATH:
+            LOG("Domain %d has been destroyed.", domid);
+            libxl_event_free(ctx, event);
+            ret = 0;
+            goto out;
+
+        case LIBXL_EVENT_TYPE_DISK_EJECT:
+            /* XXX what is this for? */
+            libxl_cdrom_insert(ctx, domid, &event->u.disk_eject.disk, NULL);
+            break;
+
+        default:;
+            char *evstr = libxl_event_to_json(ctx, event);
+            LOG("warning, got unexpected event type %d, event=%s",
+                event->type, evstr);
+            free(evstr);
+        }
+
+        libxl_event_free(ctx, event);
+    }
+
+error_out:
+    release_lock();
+    if (libxl_domid_valid_guest(domid)) {
+        libxl_domain_destroy(ctx, domid, 0);
+        domid = INVALID_DOMID;
+    }
+
+out:
+    if (logfile != 2)
+        close(logfile);
+
+    libxl_domain_config_dispose(&d_config);
+
+    free(config_data);
+
+    console_child_report();
+
+    if (deathw)
+        libxl_evdisable_domain_death(ctx, deathw);
+    if (diskws) {
+        evdisable_disk_ejects(diskws, d_config.num_disks);
+        free(diskws);
+    }
+
+    /*
+     * If we have daemonized then do not return to the caller -- this has
+     * already happened in the parent.
+     */
+    if ( daemonize && !need_daemon )
+        exit(ret);
+
+    return ret;
+}
+
+void help(const char *command)
+{
+    int i;
+    struct cmd_spec *cmd;
+
+    if (!command || !strcmp(command, "help")) {
+        printf("Usage xl [-vfN] <subcommand> [args]\n\n");
+        printf("xl full list of subcommands:\n\n");
+        for (i = 0; i < cmdtable_len; i++) {
+            printf(" %-19s ", cmd_table[i].cmd_name);
+            if (strlen(cmd_table[i].cmd_name) > 19)
+                printf("\n %-19s ", "");
+            printf("%s\n", cmd_table[i].cmd_desc);
+        }
+    } else {
+        cmd = cmdtable_lookup(command);
+        if (cmd) {
+            printf("Usage: xl [-v%s%s] %s %s\n\n%s.\n\n",
+                   cmd->modifies ? "f" : "",
+                   cmd->can_dryrun ? "N" : "",
+                   cmd->cmd_name,
+                   cmd->cmd_usage,
+                   cmd->cmd_desc);
+            if (cmd->cmd_option)
+                printf("Options:\n\n%s\n", cmd->cmd_option);
+        }
+        else {
+            printf("command \"%s\" not implemented\n", command);
+        }
+    }
+}
+
+static int64_t parse_mem_size_kb(const char *mem)
+{
+    char *endptr;
+    int64_t kbytes;
+
+    kbytes = strtoll(mem, &endptr, 10);
+
+    if (strlen(endptr) > 1)
+        return -1;
+
+    switch (tolower((uint8_t)*endptr)) {
+    case 't':
+        kbytes <<= 10;
+    case 'g':
+        kbytes <<= 10;
+    case '\0':
+    case 'm':
+        kbytes <<= 10;
+    case 'k':
+        break;
+    case 'b':
+        kbytes >>= 10;
+        break;
+    default:
+        return -1;
+    }
+
+    return kbytes;
+}
+
+#define COMMON_LONG_OPTS {"help", 0, 0, 'h'}
+
+/*
+ * Callers should use SWITCH_FOREACH_OPT in preference to calling this
+ * directly.
+ */
+static int def_getopt(int argc, char * const argv[],
+                      const char *optstring,
+                      const struct option *longopts,
+                      const char* helpstr, int reqargs)
+{
+    int opt;
+    const struct option def_options[] = {
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    if (!longopts)
+        longopts = def_options;
+
+    opterr = 0;
+    while ((opt = getopt_long(argc, argv, optstring, longopts, NULL)) == '?') {
+        if (optopt == 'h') {
+            help(helpstr);
+            exit(0);
+        }
+        fprintf(stderr, "option `%c' not supported.\n", optopt);
+    }
+    if (opt == 'h') {
+        help(helpstr);
+        exit(0);
+    }
+    if (opt != -1)
+        return opt;
+
+    if (argc - optind <= reqargs - 1) {
+        fprintf(stderr, "'xl %s' requires at least %d argument%s.\n\n",
+                helpstr, reqargs, reqargs > 1 ? "s" : "");
+        help(helpstr);
+        exit(2);
+    }
+    return -1;
+}
+
+/*
+ * Wraps def_getopt into a convenient loop+switch to process all
+ * arguments. This macro is intended to be called from main_XXX().
+ *
+ *   SWITCH_FOREACH_OPT(int *opt, const char *opts,
+ *                      const struct option *longopts,
+ *                      const char *commandname,
+ *                      int num_opts_req) { ...
+ *
+ * opt:               pointer to an int variable, holds the current option
+ *                    during processing.
+ * opts:              short options, as per getopt_long(3)'s optstring argument.
+ * longopts:          long options, as per getopt_long(3)'s longopts argument.
+ *                    May be null.
+ * commandname:       name of this command, for usage string.
+ * num_required_opts: number of non-option command line parameters
+ *                    which are required.
+ *
+ * In addition the calling context is expected to contain variables
+ * "argc" and "argv" in the conventional C-style:
+ *   main(int argc, char **argv)
+ * manner.
+ *
+ * Callers should treat SWITCH_FOREACH_OPT as they would a switch
+ * statement over the value of `opt`. Each option given in `opts` (or
+ * `lopts`) should be handled by a case statement as if it were inside
+ * a switch statement.
+ *
+ * In addition to the options provided in opts the macro will handle
+ * the "help" option and enforce a minimum number of non-option
+ * command line pearameters as follows:
+ *  -- if the user passes a -h or --help option. help will be printed,
+ *     and the macro will cause the process to exit with code 0.
+ *  -- if the user does not provided `num_required_opts` non-option
+ *     arguments, the macro will cause the process to exit with code 2.
+ *
+ * Example:
+ *
+ * int main_foo(int argc, char **argv) {
+ *     int opt;
+ *
+ *     SWITCH_FOREACH_OPT(opt, "blah", NULL, "foo", 0) {
+ *      case 'b':
+ *          ... handle b option...
+ *          break;
+ *      case 'l':
+ *          ... handle l option ...
+ *          break;
+ *      case etc etc...
+ *      }
+ *      ... do something useful with the options ...
+ * }
+ */
+#define SWITCH_FOREACH_OPT(opt, opts, longopts,                         \
+                           commandname, num_required_opts)              \
+    while (((opt) = def_getopt(argc, argv, (opts), (longopts),          \
+                                (commandname), (num_required_opts))) != -1) \
+        switch (opt)
+
+static int set_memory_max(uint32_t domid, const char *mem)
+{
+    int64_t memorykb;
+    int rc;
+
+    memorykb = parse_mem_size_kb(mem);
+    if (memorykb == -1) {
+        fprintf(stderr, "invalid memory size: %s\n", mem);
+        exit(3);
+    }
+
+    rc = libxl_domain_setmaxmem(ctx, domid, memorykb);
+
+    return rc;
+}
+
+int main_memmax(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt = 0;
+    char *mem;
+    int rc;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "mem-max", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+    mem = argv[optind + 1];
+
+    rc = set_memory_max(domid, mem);
+    if (rc) {
+        fprintf(stderr, "cannot set domid %d static max memory to : %s\n", domid, mem);
+        return 1;
+    }
+
+    return 0;
+}
+
+static void set_memory_target(uint32_t domid, const char *mem)
+{
+    long long int memorykb;
+
+    memorykb = parse_mem_size_kb(mem);
+    if (memorykb == -1)  {
+        fprintf(stderr, "invalid memory size: %s\n", mem);
+        exit(3);
+    }
+
+    libxl_set_memory_target(ctx, domid, memorykb, 0, /* enforce */ 1);
+}
+
+int main_memset(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt = 0;
+    const char *mem;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "mem-set", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+    mem = argv[optind + 1];
+
+    set_memory_target(domid, mem);
+    return 0;
+}
+
+static void cd_insert(uint32_t domid, const char *virtdev, char *phys)
+{
+    libxl_device_disk disk; /* we don't free disk's contents */
+    char *buf = NULL;
+    XLU_Config *config = 0;
+
+
+    if (asprintf(&buf, "vdev=%s,access=r,devtype=cdrom,target=%s",
+                 virtdev, phys ? phys : "") < 0) {
+        fprintf(stderr, "out of memory\n");
+        return;
+    }
+
+    parse_disk_config(&config, buf, &disk);
+
+    disk.backend_domid = 0;
+
+    libxl_cdrom_insert(ctx, domid, &disk, NULL);
+
+    libxl_device_disk_dispose(&disk);
+    free(buf);
+}
+
+int main_cd_eject(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt = 0;
+    const char *virtdev;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cd-eject", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+    virtdev = argv[optind + 1];
+
+    cd_insert(domid, virtdev, NULL);
+    return 0;
+}
+
+int main_cd_insert(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt = 0;
+    const char *virtdev;
+    char *file = NULL; /* modified by cd_insert tokenising it */
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cd-insert", 3) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+    virtdev = argv[optind + 1];
+    file = argv[optind + 2];
+
+    cd_insert(domid, virtdev, file);
+    return 0;
+}
+
+int main_console(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt = 0, num = 0;
+    libxl_console_type type = 0;
+
+    SWITCH_FOREACH_OPT(opt, "n:t:", NULL, "console", 1) {
+    case 't':
+        if (!strcmp(optarg, "pv"))
+            type = LIBXL_CONSOLE_TYPE_PV;
+        else if (!strcmp(optarg, "serial"))
+            type = LIBXL_CONSOLE_TYPE_SERIAL;
+        else {
+            fprintf(stderr, "console type supported are: pv, serial\n");
+            return 2;
+        }
+        break;
+    case 'n':
+        num = atoi(optarg);
+        break;
+    }
+
+    domid = find_domain(argv[optind]);
+    if (!type)
+        libxl_primary_console_exec(ctx, domid);
+    else
+        libxl_console_exec(ctx, domid, num, type);
+    fprintf(stderr, "Unable to attach console\n");
+    return 1;
+}
+
+int main_vncviewer(int argc, char **argv)
+{
+    static const struct option opts[] = {
+        {"autopass", 0, 0, 'a'},
+        {"vncviewer-autopass", 0, 0, 'a'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+    uint32_t domid;
+    int opt, autopass = 0;
+
+    SWITCH_FOREACH_OPT(opt, "ah", opts, "vncviewer", 1) {
+    case 'a':
+        autopass = 1;
+        break;
+    }
+
+    domid = find_domain(argv[optind]);
+
+    if (vncviewer(domid, autopass))
+        return 1;
+    return 0;
+}
+
+static void pcilist(uint32_t domid)
+{
+    libxl_device_pci *pcidevs;
+    int num, i;
+
+    pcidevs = libxl_device_pci_list(ctx, domid, &num);
+    if (pcidevs == NULL)
+        return;
+    printf("Vdev Device\n");
+    for (i = 0; i < num; i++) {
+        printf("%02x.%01x %04x:%02x:%02x.%01x\n",
+               (pcidevs[i].vdevfn >> 3) & 0x1f, pcidevs[i].vdevfn & 0x7,
+               pcidevs[i].domain, pcidevs[i].bus, pcidevs[i].dev, pcidevs[i].func);
+        libxl_device_pci_dispose(&pcidevs[i]);
+    }
+    free(pcidevs);
+}
+
+int main_pcilist(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "pci-list", 1) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+
+    pcilist(domid);
+    return 0;
+}
+
+static void pcidetach(uint32_t domid, const char *bdf, int force)
+{
+    libxl_device_pci pcidev;
+    XLU_Config *config;
+
+    libxl_device_pci_init(&pcidev);
+
+    config = xlu_cfg_init(stderr, "command line");
+    if (!config) { perror("xlu_cfg_inig"); exit(-1); }
+
+    if (xlu_pci_parse_bdf(config, &pcidev, bdf)) {
+        fprintf(stderr, "pci-detach: malformed BDF specification \"%s\"\n", bdf);
+        exit(2);
+    }
+    if (force)
+        libxl_device_pci_destroy(ctx, domid, &pcidev, 0);
+    else
+        libxl_device_pci_remove(ctx, domid, &pcidev, 0);
+
+    libxl_device_pci_dispose(&pcidev);
+    xlu_cfg_destroy(config);
+}
+
+int main_pcidetach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    int force = 0;
+    const char *bdf = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "f", NULL, "pci-detach", 2) {
+    case 'f':
+        force = 1;
+        break;
+    }
+
+    domid = find_domain(argv[optind]);
+    bdf = argv[optind + 1];
+
+    pcidetach(domid, bdf, force);
+    return 0;
+}
+static void pciattach(uint32_t domid, const char *bdf, const char *vs)
+{
+    libxl_device_pci pcidev;
+    XLU_Config *config;
+
+    libxl_device_pci_init(&pcidev);
+
+    config = xlu_cfg_init(stderr, "command line");
+    if (!config) { perror("xlu_cfg_inig"); exit(-1); }
+
+    if (xlu_pci_parse_bdf(config, &pcidev, bdf)) {
+        fprintf(stderr, "pci-attach: malformed BDF specification \"%s\"\n", bdf);
+        exit(2);
+    }
+    libxl_device_pci_add(ctx, domid, &pcidev, 0);
+
+    libxl_device_pci_dispose(&pcidev);
+    xlu_cfg_destroy(config);
+}
+
+int main_pciattach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    const char *bdf = NULL, *vs = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "pci-attach", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+    bdf = argv[optind + 1];
+
+    if (optind + 1 < argc)
+        vs = argv[optind + 2];
+
+    pciattach(domid, bdf, vs);
+    return 0;
+}
+
+static void pciassignable_list(void)
+{
+    libxl_device_pci *pcidevs;
+    int num, i;
+
+    pcidevs = libxl_device_pci_assignable_list(ctx, &num);
+
+    if ( pcidevs == NULL )
+        return;
+    for (i = 0; i < num; i++) {
+        printf("%04x:%02x:%02x.%01x\n",
+               pcidevs[i].domain, pcidevs[i].bus, pcidevs[i].dev, pcidevs[i].func);
+        libxl_device_pci_dispose(&pcidevs[i]);
+    }
+    free(pcidevs);
+}
+
+int main_pciassignable_list(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "pci-assignable-list", 0) {
+        /* No options */
+    }
+
+    pciassignable_list();
+    return 0;
+}
+
+static void pciassignable_add(const char *bdf, int rebind)
+{
+    libxl_device_pci pcidev;
+    XLU_Config *config;
+
+    libxl_device_pci_init(&pcidev);
+
+    config = xlu_cfg_init(stderr, "command line");
+    if (!config) { perror("xlu_cfg_init"); exit(-1); }
+
+    if (xlu_pci_parse_bdf(config, &pcidev, bdf)) {
+        fprintf(stderr, "pci-assignable-add: malformed BDF specification \"%s\"\n", bdf);
+        exit(2);
+    }
+    libxl_device_pci_assignable_add(ctx, &pcidev, rebind);
+
+    libxl_device_pci_dispose(&pcidev);
+    xlu_cfg_destroy(config);
+}
+
+int main_pciassignable_add(int argc, char **argv)
+{
+    int opt;
+    const char *bdf = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "pci-assignable-add", 1) {
+        /* No options */
+    }
+
+    bdf = argv[optind];
+
+    pciassignable_add(bdf, 1);
+    return 0;
+}
+
+static void pciassignable_remove(const char *bdf, int rebind)
+{
+    libxl_device_pci pcidev;
+    XLU_Config *config;
+
+    libxl_device_pci_init(&pcidev);
+
+    config = xlu_cfg_init(stderr, "command line");
+    if (!config) { perror("xlu_cfg_init"); exit(-1); }
+
+    if (xlu_pci_parse_bdf(config, &pcidev, bdf)) {
+        fprintf(stderr, "pci-assignable-remove: malformed BDF specification \"%s\"\n", bdf);
+        exit(2);
+    }
+    libxl_device_pci_assignable_remove(ctx, &pcidev, rebind);
+
+    libxl_device_pci_dispose(&pcidev);
+    xlu_cfg_destroy(config);
+}
+
+int main_pciassignable_remove(int argc, char **argv)
+{
+    int opt;
+    const char *bdf = NULL;
+    int rebind = 0;
+
+    SWITCH_FOREACH_OPT(opt, "r", NULL, "pci-assignable-remove", 1) {
+    case 'r':
+        rebind=1;
+        break;
+    }
+
+    bdf = argv[optind];
+
+    pciassignable_remove(bdf, rebind);
+    return 0;
+}
+
+static void pause_domain(uint32_t domid)
+{
+    libxl_domain_pause(ctx, domid);
+}
+
+static void unpause_domain(uint32_t domid)
+{
+    libxl_domain_unpause(ctx, domid);
+}
+
+static void destroy_domain(uint32_t domid)
+{
+    int rc;
+
+    if (domid == 0) {
+        fprintf(stderr, "Cannot destroy privileged domain 0.\n\n");
+        exit(-1);
+    }
+    rc = libxl_domain_destroy(ctx, domid, 0);
+    if (rc) { fprintf(stderr,"destroy failed (rc=%d)\n",rc); exit(-1); }
+}
+
+static void wait_for_domain_deaths(libxl_evgen_domain_death **deathws, int nr)
+{
+    int rc, count = 0;
+    LOG("Waiting for %d domains", nr);
+    while(1 && count < nr) {
+        libxl_event *event;
+        rc = libxl_event_wait(ctx, &event, LIBXL_EVENTMASK_ALL, 0,0);
+        if (rc) {
+            LOG("Failed to get event, quitting (rc=%d)", rc);
+            exit(-1);
+        }
+
+        switch (event->type) {
+        case LIBXL_EVENT_TYPE_DOMAIN_DEATH:
+            LOG("Domain %d has been destroyed", event->domid);
+            libxl_evdisable_domain_death(ctx, deathws[event->for_user]);
+            count++;
+            break;
+        case LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN:
+            LOG("Domain %d has been shut down, reason code %d",
+                event->domid, event->u.domain_shutdown.shutdown_reason);
+            libxl_evdisable_domain_death(ctx, deathws[event->for_user]);
+            count++;
+            break;
+        default:
+            LOG("Unexpected event type %d", event->type);
+            break;
+        }
+        libxl_event_free(ctx, event);
+    }
+}
+
+static void shutdown_domain(uint32_t domid,
+                            libxl_evgen_domain_death **deathw,
+                            libxl_ev_user for_user,
+                            int fallback_trigger)
+{
+    int rc;
+
+    fprintf(stderr, "Shutting down domain %d\n", domid);
+    rc=libxl_domain_shutdown(ctx, domid);
+    if (rc == ERROR_NOPARAVIRT) {
+        if (fallback_trigger) {
+            fprintf(stderr, "PV control interface not available:"
+                    " sending ACPI power button event.\n");
+            rc = libxl_send_trigger(ctx, domid, LIBXL_TRIGGER_POWER, 0);
+        } else {
+            fprintf(stderr, "PV control interface not available:"
+                    " external graceful shutdown not possible.\n");
+            fprintf(stderr, "Use \"-F\" to fallback to ACPI power event.\n");
+        }
+    }
+
+    if (rc) {
+        fprintf(stderr,"shutdown failed (rc=%d)\n",rc);exit(-1);
+    }
+
+    if (deathw) {
+        rc = libxl_evenable_domain_death(ctx, domid, for_user, deathw);
+        if (rc) {
+            fprintf(stderr,"wait for death failed (evgen, rc=%d)\n",rc);
+            exit(-1);
+        }
+    }
+}
+
+static void reboot_domain(uint32_t domid, libxl_evgen_domain_death **deathw,
+                          libxl_ev_user for_user, int fallback_trigger)
+{
+    int rc;
+
+    fprintf(stderr, "Rebooting domain %d\n", domid);
+    rc=libxl_domain_reboot(ctx, domid);
+    if (rc == ERROR_NOPARAVIRT) {
+        if (fallback_trigger) {
+            fprintf(stderr, "PV control interface not available:"
+                    " sending ACPI reset button event.\n");
+            rc = libxl_send_trigger(ctx, domid, LIBXL_TRIGGER_RESET, 0);
+        } else {
+            fprintf(stderr, "PV control interface not available:"
+                    " external graceful reboot not possible.\n");
+            fprintf(stderr, "Use \"-F\" to fallback to ACPI reset event.\n");
+        }
+    }
+    if (rc) {
+        fprintf(stderr,"reboot failed (rc=%d)\n",rc);exit(-1);
+    }
+
+    if (deathw) {
+        rc = libxl_evenable_domain_death(ctx, domid, for_user, deathw);
+        if (rc) {
+            fprintf(stderr,"wait for death failed (evgen, rc=%d)\n",rc);
+            exit(-1);
+        }
+    }
+}
+
+static void list_domains_details(const libxl_dominfo *info, int nb_domain)
+{
+    libxl_domain_config d_config;
+
+    char *config_source;
+    uint8_t *data;
+    int i, len, rc;
+
+    yajl_gen hand = NULL;
+    yajl_gen_status s;
+    const char *buf;
+    libxl_yajl_length yajl_len = 0;
+
+    if (default_output_format == OUTPUT_FORMAT_JSON) {
+        hand = libxl_yajl_gen_alloc(NULL);
+        if (!hand) {
+            fprintf(stderr, "unable to allocate JSON generator\n");
+            return;
+        }
+
+        s = yajl_gen_array_open(hand);
+        if (s != yajl_gen_status_ok)
+            goto out;
+    } else
+        s = yajl_gen_status_ok;
+
+    for (i = 0; i < nb_domain; i++) {
+        /* no detailed info available on dom0 */
+        if (info[i].domid == 0)
+            continue;
+        rc = libxl_userdata_retrieve(ctx, info[i].domid, "xl", &data, &len);
+        if (rc)
+            continue;
+        CHK_ERRNO(asprintf(&config_source, "<domid %d data>", info[i].domid));
+        libxl_domain_config_init(&d_config);
+        parse_config_data(config_source, (char *)data, len, &d_config, NULL);
+        if (default_output_format == OUTPUT_FORMAT_JSON)
+            s = printf_info_one_json(hand, info[i].domid, &d_config);
+        else
+            printf_info_sexp(info[i].domid, &d_config);
+        libxl_domain_config_dispose(&d_config);
+        free(data);
+        free(config_source);
+        if (s != yajl_gen_status_ok)
+            goto out;
+    }
+
+    if (default_output_format == OUTPUT_FORMAT_JSON) {
+        s = yajl_gen_array_close(hand);
+        if (s != yajl_gen_status_ok)
+            goto out;
+
+        s = yajl_gen_get_buf(hand, (const unsigned char **)&buf, &yajl_len);
+        if (s != yajl_gen_status_ok)
+            goto out;
+
+        puts(buf);
+    }
+
+out:
+    if (default_output_format == OUTPUT_FORMAT_JSON) {
+        yajl_gen_free(hand);
+        if (s != yajl_gen_status_ok)
+            fprintf(stderr,
+                    "unable to format domain config as JSON (YAJL:%d)\n", s);
+    }
+}
+
+static void list_domains(int verbose, int context, const libxl_dominfo *info, int nb_domain)
+{
+    int i;
+    static const char shutdown_reason_letters[]= "-rscw";
+
+    printf("Name                                        ID   Mem VCPUs\tState\tTime(s)");
+    if (verbose) printf("   UUID                            Reason-Code\tSecurity Label");
+    if (context && !verbose) printf("   Security Label");
+    printf("\n");
+    for (i = 0; i < nb_domain; i++) {
+        char *domname;
+        unsigned shutdown_reason;
+        domname = libxl_domid_to_name(ctx, info[i].domid);
+        shutdown_reason = info[i].shutdown ? info[i].shutdown_reason : 0;
+        printf("%-40s %5d %5lu %5d     %c%c%c%c%c%c  %8.1f",
+                domname,
+                info[i].domid,
+                (unsigned long) (info[i].current_memkb / 1024),
+                info[i].vcpu_online,
+                info[i].running ? 'r' : '-',
+                info[i].blocked ? 'b' : '-',
+                info[i].paused ? 'p' : '-',
+                info[i].shutdown ? 's' : '-',
+                (shutdown_reason >= 0 &&
+                 shutdown_reason < sizeof(shutdown_reason_letters)-1
+                 ? shutdown_reason_letters[shutdown_reason] : '?'),
+                info[i].dying ? 'd' : '-',
+                ((float)info[i].cpu_time / 1e9));
+        free(domname);
+        if (verbose) {
+            printf(" " LIBXL_UUID_FMT, LIBXL_UUID_BYTES(info[i].uuid));
+            if (info[i].shutdown) printf(" %8x", shutdown_reason);
+            else printf(" %8s", "-");
+        }
+        if (verbose || context) {
+            int rc;
+            size_t size;
+            char *buf;
+            rc = libxl_flask_sid_to_context(ctx, info[i].ssidref, &buf,
+                                            &size);
+            if (rc < 0)
+                printf("  -");
+            else {
+                printf("  %s", buf);
+                free(buf);
+            }
+        }
+        putchar('\n');
+    }
+}
+
+static void list_vm(void)
+{
+    libxl_vminfo *info;
+    char *domname;
+    int nb_vm, i;
+
+    info = libxl_list_vm(ctx, &nb_vm);
+
+    if (info < 0) {
+        fprintf(stderr, "libxl_domain_infolist failed.\n");
+        exit(1);
+    }
+    printf("UUID                                  ID    name\n");
+    for (i = 0; i < nb_vm; i++) {
+        domname = libxl_domid_to_name(ctx, info[i].domid);
+        printf(LIBXL_UUID_FMT "  %d    %-30s\n", LIBXL_UUID_BYTES(info[i].uuid),
+            info[i].domid, domname);
+        free(domname);
+    }
+    libxl_vminfo_list_free(info, nb_vm);
+}
+
+static void save_domain_core_begin(uint32_t domid,
+                                   const char *override_config_file,
+                                   uint8_t **config_data_r,
+                                   int *config_len_r)
+{
+    int rc;
+
+    /* configuration file in optional data: */
+
+    if (override_config_file) {
+        void *config_v = 0;
+        rc = libxl_read_file_contents(ctx, override_config_file,
+                                      &config_v, config_len_r);
+        *config_data_r = config_v;
+    } else {
+        rc = libxl_userdata_retrieve(ctx, domid, "xl",
+                                     config_data_r, config_len_r);
+    }
+    if (rc) {
+        fputs("Unable to get config file\n",stderr);
+        exit(2);
+    }
+}
+
+static void save_domain_core_writeconfig(int fd, const char *source,
+                                  const uint8_t *config_data, int config_len)
+{
+    struct save_file_header hdr;
+    uint8_t *optdata_begin;
+    union { uint32_t u32; char b[4]; } u32buf;
+
+    memset(&hdr, 0, sizeof(hdr));
+    memcpy(hdr.magic, savefileheader_magic, sizeof(hdr.magic));
+    hdr.byteorder = SAVEFILE_BYTEORDER_VALUE;
+
+    optdata_begin= 0;
+
+#define ADD_OPTDATA(ptr, len) ({                                            \
+    if ((len)) {                                                        \
+        hdr.optional_data_len += (len);                                 \
+        optdata_begin = xrealloc(optdata_begin, hdr.optional_data_len); \
+        memcpy(optdata_begin + hdr.optional_data_len - (len),           \
+               (ptr), (len));                                           \
+    }                                                                   \
+                          })
+
+    u32buf.u32 = config_len;
+    ADD_OPTDATA(u32buf.b,    4);
+    ADD_OPTDATA(config_data, config_len);
+
+    /* that's the optional data */
+
+    CHK_ERRNO( libxl_write_exactly(ctx, fd,
+        &hdr, sizeof(hdr), source, "header") );
+    CHK_ERRNO( libxl_write_exactly(ctx, fd,
+        optdata_begin, hdr.optional_data_len, source, "header") );
+
+    fprintf(stderr, "Saving to %s new xl format (info"
+            " 0x%"PRIx32"/0x%"PRIx32"/%"PRIu32")\n",
+            source, hdr.mandatory_flags, hdr.optional_flags,
+            hdr.optional_data_len);
+}
+
+static int save_domain(uint32_t domid, const char *filename, int checkpoint,
+                const char *override_config_file)
+{
+    int fd;
+    uint8_t *config_data;
+    int config_len;
+
+    save_domain_core_begin(domid, override_config_file,
+                           &config_data, &config_len);
+
+    if (!config_len) {
+        fputs(" Savefile will not contain xl domain config\n", stderr);
+    }
+
+    fd = open(filename, O_WRONLY|O_CREAT|O_TRUNC, 0644);
+    if (fd < 0) {
+        fprintf(stderr, "Failed to open temp file %s for writing\n", filename);
+        exit(2);
+    }
+
+    save_domain_core_writeconfig(fd, filename, config_data, config_len);
+
+    int rc = libxl_domain_suspend(ctx, domid, fd, 0, NULL);
+    close(fd);
+
+    if (rc < 0)
+        fprintf(stderr, "Failed to save domain, resuming domain\n");
+
+    if (checkpoint || rc < 0)
+        libxl_domain_resume(ctx, domid, 1, 0);
+    else
+        libxl_domain_destroy(ctx, domid, 0);
+
+    exit(rc < 0 ? 1 : 0);
+}
+
+static pid_t create_migration_child(const char *rune, int *send_fd,
+                                        int *recv_fd)
+{
+    int sendpipe[2], recvpipe[2];
+    pid_t child = -1;
+
+    if (!rune || !send_fd || !recv_fd)
+        return -1;
+
+    MUST( libxl_pipe(ctx, sendpipe) );
+    MUST( libxl_pipe(ctx, recvpipe) );
+
+    child = xl_fork(child_migration);
+
+    if (!child) {
+        dup2(sendpipe[0], 0);
+        dup2(recvpipe[1], 1);
+        close(sendpipe[0]); close(sendpipe[1]);
+        close(recvpipe[0]); close(recvpipe[1]);
+        execlp("sh","sh","-c",rune,(char*)0);
+        perror("failed to exec sh");
+        exit(-1);
+    }
+
+    close(sendpipe[0]);
+    close(recvpipe[1]);
+    *send_fd = sendpipe[1];
+    *recv_fd = recvpipe[0];
+
+    /* if receiver dies, we get an error and can clean up
+       rather than just dying */
+    signal(SIGPIPE, SIG_IGN);
+
+    return child;
+}
+
+static int migrate_read_fixedmessage(int fd, const void *msg, int msgsz,
+                                     const char *what, const char *rune) {
+    char buf[msgsz];
+    const char *stream;
+    int rc;
+
+    stream = rune ? "migration receiver stream" : "migration stream";
+    rc = libxl_read_exactly(ctx, fd, buf, msgsz, stream, what);
+    if (rc) return ERROR_FAIL;
+
+    if (memcmp(buf, msg, msgsz)) {
+        fprintf(stderr, "%s contained unexpected data instead of %s\n",
+                stream, what);
+        if (rune)
+            fprintf(stderr, "(command run was: %s )\n", rune);
+        return ERROR_FAIL;
+    }
+    return 0;
+}
+
+static void migration_child_report(int recv_fd) {
+    pid_t child;
+    int status, sr;
+    struct timeval now, waituntil, timeout;
+    static const struct timeval pollinterval = { 0, 1000 }; /* 1ms */
+
+    if (!xl_child_pid(child_migration)) return;
+
+    CHK_ERRNO( gettimeofday(&waituntil, 0) );
+    waituntil.tv_sec += 2;
+
+    for (;;) {
+        pid_t migration_child = xl_child_pid(child_migration);
+        child = xl_waitpid(child_migration, &status, WNOHANG);
+
+        if (child == migration_child) {
+            if (status)
+                libxl_report_child_exitstatus(ctx, XTL_INFO,
+                                              "migration target process",
+                                              migration_child, status);
+            break;
+        }
+        if (child == -1) {
+            fprintf(stderr, "wait for migration child [%ld] failed: %s\n",
+                    (long)migration_child, strerror(errno));
+            break;
+        }
+        assert(child == 0);
+
+        CHK_ERRNO( gettimeofday(&now, 0) );
+        if (timercmp(&now, &waituntil, >)) {
+            fprintf(stderr, "migration child [%ld] not exiting, no longer"
+                    " waiting (exit status will be unreported)\n",
+                    (long)migration_child);
+            break;
+        }
+        timersub(&waituntil, &now, &timeout);
+
+        if (recv_fd >= 0) {
+            fd_set readfds, exceptfds;
+            FD_ZERO(&readfds);
+            FD_ZERO(&exceptfds);
+            FD_SET(recv_fd, &readfds);
+            FD_SET(recv_fd, &exceptfds);
+            sr = select(recv_fd+1, &readfds,0,&exceptfds, &timeout);
+        } else {
+            if (timercmp(&timeout, &pollinterval, >))
+                timeout = pollinterval;
+            sr = select(0,0,0,0, &timeout);
+        }
+        if (sr > 0) {
+            recv_fd = -1;
+        } else if (sr == 0) {
+        } else if (sr == -1) {
+            if (errno != EINTR) {
+                fprintf(stderr, "migration child [%ld] exit wait select"
+                        " failed unexpectedly: %s\n",
+                        (long)migration_child, strerror(errno));
+                break;
+            }
+        }
+    }
+}
+
+static void migrate_do_preamble(int send_fd, int recv_fd, pid_t child,
+                                uint8_t *config_data, int config_len,
+                                const char *rune)
+{
+    int rc = 0;
+
+    if (send_fd < 0 || recv_fd < 0) {
+        fprintf(stderr, "migrate_do_preamble: invalid file descriptors\n");
+        exit(1);
+    }
+
+    rc = migrate_read_fixedmessage(recv_fd, migrate_receiver_banner,
+                                   sizeof(migrate_receiver_banner)-1,
+                                   "banner", rune);
+    if (rc) {
+        close(send_fd);
+        migration_child_report(recv_fd);
+        exit(-rc);
+    }
+
+    save_domain_core_writeconfig(send_fd, "migration stream",
+                                 config_data, config_len);
+
+}
+
+static void migrate_domain(uint32_t domid, const char *rune, int debug,
+                           const char *override_config_file)
+{
+    pid_t child = -1;
+    int rc;
+    int send_fd = -1, recv_fd = -1;
+    char *away_domname;
+    char rc_buf;
+    uint8_t *config_data;
+    int config_len, flags = LIBXL_SUSPEND_LIVE;
+
+    save_domain_core_begin(domid, override_config_file,
+                           &config_data, &config_len);
+
+    if (!config_len) {
+        fprintf(stderr, "No config file stored for running domain and "
+                "none supplied - cannot migrate.\n");
+        exit(1);
+    }
+
+    child = create_migration_child(rune, &send_fd, &recv_fd);
+
+    migrate_do_preamble(send_fd, recv_fd, child, config_data, config_len,
+                        rune);
+
+    xtl_stdiostream_adjust_flags(logger, XTL_STDIOSTREAM_HIDE_PROGRESS, 0);
+
+    if (debug)
+        flags |= LIBXL_SUSPEND_DEBUG;
+    rc = libxl_domain_suspend(ctx, domid, send_fd, flags, NULL);
+    if (rc) {
+        fprintf(stderr, "migration sender: libxl_domain_suspend failed"
+                " (rc=%d)\n", rc);
+        if (rc == ERROR_GUEST_TIMEDOUT)
+            goto failed_suspend;
+        else
+            goto failed_resume;
+    }
+
+    //fprintf(stderr, "migration sender: Transfer complete.\n");
+    // Should only be printed when debugging as it's a bit messy with
+    // progress indication.
+
+    rc = migrate_read_fixedmessage(recv_fd, migrate_receiver_ready,
+                                   sizeof(migrate_receiver_ready),
+                                   "ready message", rune);
+    if (rc) goto failed_resume;
+
+    xtl_stdiostream_adjust_flags(logger, 0, XTL_STDIOSTREAM_HIDE_PROGRESS);
+
+    /* right, at this point we are about give the destination
+     * permission to rename and resume, so we must first rename the
+     * domain away ourselves */
+
+    fprintf(stderr, "migration sender: Target has acknowledged transfer.\n");
+
+    if (common_domname) {
+        if (asprintf(&away_domname, "%s--migratedaway", common_domname) < 0)
+            goto failed_resume;
+        rc = libxl_domain_rename(ctx, domid, common_domname, away_domname);
+        if (rc) goto failed_resume;
+    }
+
+    /* point of no return - as soon as we have tried to say
+     * "go" to the receiver, it's not safe to carry on.  We leave
+     * the domain renamed to %s--migratedaway in case that's helpful.
+     */
+
+    fprintf(stderr, "migration sender: Giving target permission to start.\n");
+
+    rc = libxl_write_exactly(ctx, send_fd,
+                             migrate_permission_to_go,
+                             sizeof(migrate_permission_to_go),
+                             "migration stream", "GO message");
+    if (rc) goto failed_badly;
+
+    rc = migrate_read_fixedmessage(recv_fd, migrate_report,
+                                   sizeof(migrate_report),
+                                   "success/failure report message", rune);
+    if (rc) goto failed_badly;
+
+    rc = libxl_read_exactly(ctx, recv_fd,
+                            &rc_buf, 1,
+                            "migration ack stream", "success/failure status");
+    if (rc) goto failed_badly;
+
+    if (rc_buf) {
+        fprintf(stderr, "migration sender: Target reports startup failure"
+                " (status code %d).\n", rc_buf);
+
+        rc = migrate_read_fixedmessage(recv_fd, migrate_permission_to_go,
+                                       sizeof(migrate_permission_to_go),
+                                       "permission for sender to resume",
+                                       rune);
+        if (rc) goto failed_badly;
+
+        fprintf(stderr, "migration sender: Trying to resume at our end.\n");
+
+        if (common_domname) {
+            libxl_domain_rename(ctx, domid, away_domname, common_domname);
+        }
+        rc = libxl_domain_resume(ctx, domid, 0, 0);
+        if (!rc) fprintf(stderr, "migration sender: Resumed OK.\n");
+
+        fprintf(stderr, "Migration failed due to problems at target.\n");
+        exit(-ERROR_FAIL);
+    }
+
+    fprintf(stderr, "migration sender: Target reports successful startup.\n");
+    libxl_domain_destroy(ctx, domid, 0); /* bang! */
+    fprintf(stderr, "Migration successful.\n");
+    exit(0);
+
+ failed_suspend:
+    close(send_fd);
+    migration_child_report(recv_fd);
+    fprintf(stderr, "Migration failed, failed to suspend at sender.\n");
+    exit(-ERROR_FAIL);
+
+ failed_resume:
+    close(send_fd);
+    migration_child_report(recv_fd);
+    fprintf(stderr, "Migration failed, resuming at sender.\n");
+    libxl_domain_resume(ctx, domid, 0, 0);
+    exit(-ERROR_FAIL);
+
+ failed_badly:
+    fprintf(stderr,
+ "** Migration failed during final handshake **\n"
+ "Domain state is now undefined !\n"
+ "Please CHECK AT BOTH ENDS for running instances, before renaming and\n"
+ " resuming at most one instance.  Two simultaneous instances of the domain\n"
+ " would probably result in SEVERE DATA LOSS and it is now your\n"
+ " responsibility to avoid that.  Sorry.\n");
+
+    close(send_fd);
+    migration_child_report(recv_fd);
+    exit(-ERROR_BADFAIL);
+}
+
+static void core_dump_domain(uint32_t domid, const char *filename)
+{
+    int rc;
+
+    rc=libxl_domain_core_dump(ctx, domid, filename, NULL);
+    if (rc) { fprintf(stderr,"core dump failed (rc=%d)\n",rc);exit(-1); }
+}
+
+static void migrate_receive(int debug, int daemonize, int monitor,
+                            int send_fd, int recv_fd, int remus)
+{
+    uint32_t domid;
+    int rc, rc2;
+    char rc_buf;
+    char *migration_domname;
+    struct domain_create dom_info;
+
+    signal(SIGPIPE, SIG_IGN);
+    /* if we get SIGPIPE we'd rather just have it as an error */
+
+    fprintf(stderr, "migration target: Ready to receive domain.\n");
+
+    CHK_ERRNO( libxl_write_exactly(ctx, send_fd,
+                                   migrate_receiver_banner,
+                                   sizeof(migrate_receiver_banner)-1,
+                                   "migration ack stream",
+                                   "banner") );
+
+    memset(&dom_info, 0, sizeof(dom_info));
+    dom_info.debug = debug;
+    dom_info.daemonize = daemonize;
+    dom_info.monitor = monitor;
+    dom_info.paused = 1;
+    dom_info.migrate_fd = recv_fd;
+    dom_info.migration_domname_r = &migration_domname;
+
+    rc = create_domain(&dom_info);
+    if (rc < 0) {
+        fprintf(stderr, "migration target: Domain creation failed"
+                " (code %d).\n", rc);
+        exit(-rc);
+    }
+
+    domid = rc;
+
+    if (remus) {
+        /* If we are here, it means that the sender (primary) has crashed.
+         * TODO: Split-Brain Check.
+         */
+        fprintf(stderr, "migration target: Remus Failover for domain %u\n",
+                domid);
+
+        /*
+         * If domain renaming fails, lets just continue (as we need the domain
+         * to be up & dom names may not matter much, as long as its reachable
+         * over network).
+         *
+         * If domain unpausing fails, destroy domain ? Or is it better to have
+         * a consistent copy of the domain (memory, cpu state, disk)
+         * on atleast one physical host ? Right now, lets just leave the domain
+         * as is and let the Administrator decide (or troubleshoot).
+         */
+        if (migration_domname) {
+            rc = libxl_domain_rename(ctx, domid, migration_domname,
+                                     common_domname);
+            if (rc)
+                fprintf(stderr, "migration target (Remus): "
+                        "Failed to rename domain from %s to %s:%d\n",
+                        migration_domname, common_domname, rc);
+        }
+
+        rc = libxl_domain_unpause(ctx, domid);
+        if (rc)
+            fprintf(stderr, "migration target (Remus): "
+                    "Failed to unpause domain %s (id: %u):%d\n",
+                    common_domname, domid, rc);
+
+        exit(rc ? -ERROR_FAIL: 0);
+    }
+
+    fprintf(stderr, "migration target: Transfer complete,"
+            " requesting permission to start domain.\n");
+
+    rc = libxl_write_exactly(ctx, send_fd,
+                             migrate_receiver_ready,
+                             sizeof(migrate_receiver_ready),
+                             "migration ack stream", "ready message");
+    if (rc) exit(-rc);
+
+    rc = migrate_read_fixedmessage(recv_fd, migrate_permission_to_go,
+                                   sizeof(migrate_permission_to_go),
+                                   "GO message", 0);
+    if (rc) goto perhaps_destroy_notify_rc;
+
+    fprintf(stderr, "migration target: Got permission, starting domain.\n");
+
+    if (migration_domname) {
+        rc = libxl_domain_rename(ctx, domid, migration_domname, common_domname);
+        if (rc) goto perhaps_destroy_notify_rc;
+    }
+
+    rc = libxl_domain_unpause(ctx, domid);
+    if (rc) goto perhaps_destroy_notify_rc;
+
+    fprintf(stderr, "migration target: Domain started successsfully.\n");
+    rc = 0;
+
+ perhaps_destroy_notify_rc:
+    rc2 = libxl_write_exactly(ctx, send_fd,
+                              migrate_report, sizeof(migrate_report),
+                              "migration ack stream",
+                              "success/failure report");
+    if (rc2) exit(-ERROR_BADFAIL);
+
+    rc_buf = -rc;
+    assert(!!rc_buf == !!rc);
+    rc2 = libxl_write_exactly(ctx, send_fd, &rc_buf, 1,
+                              "migration ack stream",
+                              "success/failure code");
+    if (rc2) exit(-ERROR_BADFAIL);
+
+    if (rc) {
+        fprintf(stderr, "migration target: Failure, destroying our copy.\n");
+
+        rc2 = libxl_domain_destroy(ctx, domid, 0);
+        if (rc2) {
+            fprintf(stderr, "migration target: Failed to destroy our copy"
+                    " (code %d).\n", rc2);
+            exit(-ERROR_BADFAIL);
+        }
+
+        fprintf(stderr, "migration target: Cleanup OK, granting sender"
+                " permission to resume.\n");
+
+        rc2 = libxl_write_exactly(ctx, send_fd,
+                                  migrate_permission_to_go,
+                                  sizeof(migrate_permission_to_go),
+                                  "migration ack stream",
+                                  "permission to sender to have domain back");
+        if (rc2) exit(-ERROR_BADFAIL);
+    }
+
+    exit(0);
+}
+
+int main_restore(int argc, char **argv)
+{
+    const char *checkpoint_file = NULL;
+    const char *config_file = NULL;
+    struct domain_create dom_info;
+    int paused = 0, debug = 0, daemonize = 1, monitor = 1,
+        console_autoconnect = 0, vnc = 0, vncautopass = 0;
+    int opt, rc;
+    static struct option opts[] = {
+        {"vncviewer", 0, 0, 'V'},
+        {"vncviewer-autopass", 0, 0, 'A'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "FhcpdeVA", opts, "restore", 1) {
+    case 'c':
+        console_autoconnect = 1;
+        break;
+    case 'p':
+        paused = 1;
+        break;
+    case 'd':
+        debug = 1;
+        break;
+    case 'F':
+        daemonize = 0;
+        break;
+    case 'e':
+        daemonize = 0;
+        monitor = 0;
+        break;
+    case 'V':
+        vnc = 1;
+        break;
+    case 'A':
+        vnc = vncautopass = 1;
+        break;
+    }
+
+    if (argc-optind == 1) {
+        checkpoint_file = argv[optind];
+    } else if (argc-optind == 2) {
+        config_file = argv[optind];
+        checkpoint_file = argv[optind + 1];
+    } else {
+        help("restore");
+        return 2;
+    }
+
+    memset(&dom_info, 0, sizeof(dom_info));
+    dom_info.debug = debug;
+    dom_info.daemonize = daemonize;
+    dom_info.monitor = monitor;
+    dom_info.paused = paused;
+    dom_info.config_file = config_file;
+    dom_info.restore_file = checkpoint_file;
+    dom_info.migrate_fd = -1;
+    dom_info.vnc = vnc;
+    dom_info.vncautopass = vncautopass;
+    dom_info.console_autoconnect = console_autoconnect;
+
+    rc = create_domain(&dom_info);
+    if (rc < 0)
+        return -rc;
+
+    return 0;
+}
+
+int main_migrate_receive(int argc, char **argv)
+{
+    int debug = 0, daemonize = 1, monitor = 1, remus = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "Fedr", NULL, "migrate-receive", 0) {
+    case 'F':
+        daemonize = 0;
+        break;
+    case 'e':
+        daemonize = 0;
+        monitor = 0;
+        break;
+    case 'd':
+        debug = 1;
+        break;
+    case 'r':
+        remus = 1;
+        break;
+    }
+
+    if (argc-optind != 0) {
+        help("migrate-receive");
+        return 2;
+    }
+    migrate_receive(debug, daemonize, monitor,
+                    STDOUT_FILENO, STDIN_FILENO,
+                    remus);
+
+    return 0;
+}
+
+int main_save(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *filename;
+    const char *config_filename = NULL;
+    int checkpoint = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "c", NULL, "save", 2) {
+    case 'c':
+        checkpoint = 1;
+        break;
+    }
+
+    if (argc-optind > 3) {
+        help("save");
+        return 2;
+    }
+
+    domid = find_domain(argv[optind]);
+    filename = argv[optind + 1];
+    if ( argc - optind >= 3 )
+        config_filename = argv[optind + 2];
+
+    save_domain(domid, filename, checkpoint, config_filename);
+    return 0;
+}
+
+int main_migrate(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *config_filename = NULL;
+    const char *ssh_command = "ssh";
+    char *rune = NULL;
+    char *host;
+    int opt, daemonize = 1, monitor = 1, debug = 0;
+    static struct option opts[] = {
+        {"debug", 0, 0, 0x100},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "FC:s:e", opts, "migrate", 2) {
+    case 'C':
+        config_filename = optarg;
+        break;
+    case 's':
+        ssh_command = optarg;
+        break;
+    case 'F':
+        daemonize = 0;
+        break;
+    case 'e':
+        daemonize = 0;
+        monitor = 0;
+        break;
+    case 0x100:
+        debug = 1;
+        break;
+    }
+
+    domid = find_domain(argv[optind]);
+    host = argv[optind + 1];
+
+    if (!ssh_command[0]) {
+        rune= host;
+    } else {
+        if (asprintf(&rune, "exec %s %s xl migrate-receive%s%s",
+                     ssh_command, host,
+                     daemonize ? "" : " -e",
+                     debug ? " -d" : "") < 0)
+            return 1;
+    }
+
+    migrate_domain(domid, rune, debug, config_filename);
+    return 0;
+}
+
+int main_dump_core(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "dump-core", 2) {
+        /* No options */
+    }
+
+    core_dump_domain(find_domain(argv[optind]), argv[optind + 1]);
+    return 0;
+}
+
+int main_pause(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "pause", 1) {
+        /* No options */
+    }
+
+    pause_domain(find_domain(argv[optind]));
+
+    return 0;
+}
+
+int main_unpause(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "unpause", 1) {
+        /* No options */
+    }
+
+    unpause_domain(find_domain(argv[optind]));
+
+    return 0;
+}
+
+int main_destroy(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "destroy", 1) {
+        /* No options */
+    }
+
+    destroy_domain(find_domain(argv[optind]));
+    return 0;
+}
+
+static int main_shutdown_or_reboot(int do_reboot, int argc, char **argv)
+{
+    const char *what = do_reboot ? "reboot" : "shutdown";
+    void (*fn)(uint32_t domid,
+               libxl_evgen_domain_death **, libxl_ev_user, int) =
+        do_reboot ? &reboot_domain : &shutdown_domain;
+    int opt, i, nb_domain;
+    int wait_for_it = 0, all =0;
+    int fallback_trigger = 0;
+    static struct option opts[] = {
+        {"all", 0, 0, 'a'},
+        {"wait", 0, 0, 'w'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "awF", opts, what, 0) {
+    case 'a':
+        all = 1;
+        break;
+    case 'w':
+        wait_for_it = 1;
+        break;
+    case 'F':
+        fallback_trigger = 1;
+        break;
+    }
+
+    if (!argv[optind] && !all) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        return opt;
+    }
+
+    if (all) {
+        libxl_dominfo *dominfo;
+        libxl_evgen_domain_death **deathws = NULL;
+        if (!(dominfo = libxl_list_domain(ctx, &nb_domain))) {
+            fprintf(stderr, "libxl_list_domain failed.\n");
+            return -1;
+        }
+
+        if (wait_for_it)
+            deathws = calloc(nb_domain, sizeof(*deathws));
+
+        for (i = 0; i<nb_domain; i++) {
+            if (dominfo[i].domid == 0)
+                continue;
+            fn(dominfo[i].domid, deathws ? &deathws[i] : NULL, i,
+               fallback_trigger);
+        }
+
+        if (wait_for_it)
+            wait_for_domain_deaths(deathws, nb_domain - 1 /* not dom 0 */);
+
+        libxl_dominfo_list_free(dominfo, nb_domain);
+    } else {
+        libxl_evgen_domain_death *deathw = NULL;
+        uint32_t domid = find_domain(argv[optind]);
+
+        fn(domid, wait_for_it ? &deathw : NULL, 0, fallback_trigger);
+
+        if (wait_for_it)
+            wait_for_domain_deaths(&deathw, 1);
+    }
+
+
+    return 0;
+}
+
+int main_shutdown(int argc, char **argv)
+{
+    return main_shutdown_or_reboot(0, argc, argv);
+}
+
+int main_reboot(int argc, char **argv)
+{
+    return main_shutdown_or_reboot(1, argc, argv);
+}
+
+int main_list(int argc, char **argv)
+{
+    int opt, verbose = 0;
+    int context = 0;
+    int details = 0;
+    static struct option opts[] = {
+        {"long", 0, 0, 'l'},
+        {"verbose", 0, 0, 'v'},
+        {"context", 0, 0, 'Z'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    libxl_dominfo info_buf;
+    libxl_dominfo *info, *info_free=0;
+    int nb_domain, rc;
+
+    SWITCH_FOREACH_OPT(opt, "lvhZ", opts, "list", 0) {
+    case 'l':
+        details = 1;
+        break;
+    case 'v':
+        verbose = 1;
+        break;
+    case 'Z':
+        context = 1;
+        break;
+    }
+
+    if (optind >= argc) {
+        info = libxl_list_domain(ctx, &nb_domain);
+        if (!info) {
+            fprintf(stderr, "libxl_domain_infolist failed.\n");
+            return 1;
+        }
+        info_free = info;
+    } else if (optind == argc-1) {
+        uint32_t domid = find_domain(argv[optind]);
+        rc = libxl_domain_info(ctx, &info_buf, domid);
+        if (rc == ERROR_INVAL) {
+            fprintf(stderr, "Error: Domain \'%s\' does not exist.\n",
+                argv[optind]);
+            return -rc;
+        }
+        if (rc) {
+            fprintf(stderr, "libxl_domain_info failed (code %d).\n", rc);
+            return -rc;
+        }
+        info = &info_buf;
+        nb_domain = 1;
+    } else {
+        help("list");
+        return 2;
+    }
+
+    if (details)
+        list_domains_details(info, nb_domain);
+    else
+        list_domains(verbose, context, info, nb_domain);
+
+    if (info_free)
+        libxl_dominfo_list_free(info, nb_domain);
+    else
+        libxl_dominfo_dispose(info);
+
+    return 0;
+}
+
+int main_vm_list(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vm-list", 0) {
+        /* No options */
+    }
+
+    list_vm();
+    return 0;
+}
+
+int main_create(int argc, char **argv)
+{
+    const char *filename = NULL;
+    char *p;
+    char extra_config[1024];
+    struct domain_create dom_info;
+    int paused = 0, debug = 0, daemonize = 1, console_autoconnect = 0,
+        quiet = 0, monitor = 1, vnc = 0, vncautopass = 0;
+    int opt, rc;
+    static struct option opts[] = {
+        {"dryrun", 0, 0, 'n'},
+        {"quiet", 0, 0, 'q'},
+        {"defconfig", 1, 0, 'f'},
+        {"vncviewer", 0, 0, 'V'},
+        {"vncviewer-autopass", 0, 0, 'A'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    if (argv[1] && argv[1][0] != '-' && !strchr(argv[1], '=')) {
+        filename = argv[1];
+        argc--; argv++;
+    }
+
+    SWITCH_FOREACH_OPT(opt, "Fhnqf:pcdeVA", opts, "create", 0) {
+    case 'f':
+        filename = optarg;
+        break;
+    case 'p':
+        paused = 1;
+        break;
+    case 'c':
+        console_autoconnect = 1;
+        break;
+    case 'd':
+        debug = 1;
+        break;
+    case 'F':
+        daemonize = 0;
+        break;
+    case 'e':
+        daemonize = 0;
+        monitor = 0;
+        break;
+    case 'n':
+        dryrun_only = 1;
+        break;
+    case 'q':
+        quiet = 1;
+        break;
+    case 'V':
+        vnc = 1;
+        break;
+    case 'A':
+        vnc = vncautopass = 1;
+        break;
+    }
+
+    extra_config[0] = '\0';
+    for (p = extra_config; optind < argc; optind++) {
+        if (strchr(argv[optind], '=') != NULL) {
+            p += snprintf(p, sizeof(extra_config) - (p - extra_config),
+                "%s\n", argv[optind]);
+        } else if (!filename) {
+            filename = argv[optind];
+        } else {
+            help("create");
+            return 2;
+        }
+    }
+
+    memset(&dom_info, 0, sizeof(dom_info));
+    dom_info.debug = debug;
+    dom_info.daemonize = daemonize;
+    dom_info.monitor = monitor;
+    dom_info.paused = paused;
+    dom_info.dryrun = dryrun_only;
+    dom_info.quiet = quiet;
+    dom_info.config_file = filename;
+    dom_info.extra_config = extra_config;
+    dom_info.migrate_fd = -1;
+    dom_info.vnc = vnc;
+    dom_info.vncautopass = vncautopass;
+    dom_info.console_autoconnect = console_autoconnect;
+
+    rc = create_domain(&dom_info);
+    if (rc < 0)
+        return -rc;
+
+    return 0;
+}
+
+int main_config_update(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *filename = NULL;
+    char *p;
+    char extra_config[1024];
+    void *config_data = 0;
+    int config_len = 0;
+    libxl_domain_config d_config;
+    int opt, rc;
+    int debug = 0;
+    static struct option opts[] = {
+        {"defconfig", 1, 0, 'f'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    if (argc < 2) {
+        fprintf(stderr, "xl config-update requires a domain argument\n");
+        help("config-update");
+        exit(1);
+    }
+
+    domid = find_domain(argv[1]);
+    argc--; argv++;
+
+    if (argv[1] && argv[1][0] != '-' && !strchr(argv[1], '=')) {
+        filename = argv[1];
+        argc--; argv++;
+    }
+
+    SWITCH_FOREACH_OPT(opt, "dhqf:", opts, "config_update", 0) {
+    case 'd':
+        debug = 1;
+        break;
+    case 'f':
+        filename = optarg;
+        break;
+    }
+
+    extra_config[0] = '\0';
+    for (p = extra_config; optind < argc; optind++) {
+        if (strchr(argv[optind], '=') != NULL) {
+            p += snprintf(p, sizeof(extra_config) - (p - extra_config),
+                "%s\n", argv[optind]);
+        } else if (!filename) {
+            filename = argv[optind];
+        } else {
+            help("create");
+            return 2;
+        }
+    }
+    if (filename) {
+        free(config_data);  config_data = 0;
+        rc = libxl_read_file_contents(ctx, filename,
+                                      &config_data, &config_len);
+        if (rc) { fprintf(stderr, "Failed to read config file: %s: %s\n",
+                           filename, strerror(errno)); return ERROR_FAIL; }
+        if (strlen(extra_config)) {
+            if (config_len > INT_MAX - (strlen(extra_config) + 2 + 1)) {
+                fprintf(stderr, "Failed to attach extra configration\n");
+                exit(1);
+            }
+            /* allocate space for the extra config plus two EOLs plus \0 */
+            config_data = realloc(config_data, config_len
+                + strlen(extra_config) + 2 + 1);
+            if (!config_data) {
+                fprintf(stderr, "Failed to realloc config_data\n");
+                exit(1);
+            }
+            config_len += sprintf(config_data + config_len, "\n%s\n",
+                extra_config);
+        }
+    } else {
+        fprintf(stderr, "Config file not specified\n");
+        exit(1);
+    }
+
+    libxl_domain_config_init(&d_config);
+
+    parse_config_data(filename, config_data, config_len, &d_config, NULL);
+
+    if (debug || dryrun_only)
+        printf_info(default_output_format, -1, &d_config);
+
+    if (!dryrun_only) {
+        fprintf(stderr, "setting dom%d configuration\n", domid);
+        rc = libxl_userdata_store(ctx, domid, "xl",
+                                   config_data, config_len);
+        if (rc) {
+            fprintf(stderr, "failed to update configuration\n");
+            exit(1);
+        }
+    }
+
+    libxl_domain_config_dispose(&d_config);
+
+    free(config_data);
+
+    return 0;
+}
+
+static void button_press(uint32_t domid, const char *b)
+{
+    libxl_trigger trigger;
+
+    if (!strcmp(b, "power")) {
+        trigger = LIBXL_TRIGGER_POWER;
+    } else if (!strcmp(b, "sleep")) {
+        trigger = LIBXL_TRIGGER_SLEEP;
+    } else {
+        fprintf(stderr, "%s is an invalid button identifier\n", b);
+        exit(2);
+    }
+
+    libxl_send_trigger(ctx, domid, trigger, 0);
+}
+
+int main_button_press(int argc, char **argv)
+{
+    int opt;
+
+    fprintf(stderr, "WARNING: \"button-press\" is deprecated. "
+            "Please use \"trigger\"\n");
+
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "button-press", 2) {
+        /* No options */
+    }
+
+    button_press(find_domain(argv[optind]), argv[optind + 1]);
+
+    return 0;
+}
+
+static void print_bitmap(uint8_t *map, int maplen, FILE *stream)
+{
+    int i;
+    uint8_t pmap = 0, bitmask = 0;
+    int firstset = 0, state = 0;
+
+    for (i = 0; i < maplen; i++) {
+        if (i % 8 == 0) {
+            pmap = *map++;
+            bitmask = 1;
+        } else bitmask <<= 1;
+
+        switch (state) {
+        case 0:
+        case 2:
+            if ((pmap & bitmask) != 0) {
+                firstset = i;
+                state++;
+            }
+            continue;
+        case 1:
+        case 3:
+            if ((pmap & bitmask) == 0) {
+                fprintf(stream, "%s%d", state > 1 ? "," : "", firstset);
+                if (i - 1 > firstset)
+                    fprintf(stream, "-%d", i - 1);
+                state = 2;
+            }
+            continue;
+        }
+    }
+    switch (state) {
+        case 0:
+            fprintf(stream, "none");
+            break;
+        case 2:
+            break;
+        case 1:
+            if (firstset == 0) {
+                fprintf(stream, "any cpu");
+                break;
+            }
+        case 3:
+            fprintf(stream, "%s%d", state > 1 ? "," : "", firstset);
+            if (i - 1 > firstset)
+                fprintf(stream, "-%d", i - 1);
+            break;
+    }
+}
+
+static void print_vcpuinfo(uint32_t tdomid,
+                           const libxl_vcpuinfo *vcpuinfo,
+                           uint32_t nr_cpus)
+{
+    char *domname;
+
+    /*      NAME  ID  VCPU */
+    domname = libxl_domid_to_name(ctx, tdomid);
+    printf("%-32s %5u %5u",
+           domname, tdomid, vcpuinfo->vcpuid);
+    free(domname);
+    if (!vcpuinfo->online) {
+        /*      CPU STA */
+        printf("%5c %3c%cp ", '-', '-', '-');
+    } else {
+        /*      CPU STA */
+        printf("%5u %3c%c- ", vcpuinfo->cpu,
+               vcpuinfo->running ? 'r' : '-',
+               vcpuinfo->blocked ? 'b' : '-');
+    }
+    /*      TIM */
+    printf("%9.1f  ", ((float)vcpuinfo->vcpu_time / 1e9));
+    /* CPU AFFINITY */
+    print_bitmap(vcpuinfo->cpumap.map, nr_cpus, stdout);
+    printf("\n");
+}
+
+static void print_domain_vcpuinfo(uint32_t domid, uint32_t nr_cpus)
+{
+    libxl_vcpuinfo *vcpuinfo;
+    int i, nb_vcpu, nrcpus;
+
+    vcpuinfo = libxl_list_vcpu(ctx, domid, &nb_vcpu, &nrcpus);
+
+    if (!vcpuinfo) {
+        fprintf(stderr, "libxl_list_vcpu failed.\n");
+        return;
+    }
+
+    for (i = 0; i < nb_vcpu; i++) {
+        print_vcpuinfo(domid, &vcpuinfo[i], nr_cpus);
+    }
+
+    libxl_vcpuinfo_list_free(vcpuinfo, nb_vcpu);
+}
+
+static void vcpulist(int argc, char **argv)
+{
+    libxl_dominfo *dominfo;
+    libxl_physinfo physinfo;
+    int i, nb_domain;
+
+    if (libxl_get_physinfo(ctx, &physinfo) != 0) {
+        fprintf(stderr, "libxl_physinfo failed.\n");
+        goto vcpulist_out;
+    }
+
+    printf("%-32s %5s %5s %5s %5s %9s %s\n",
+           "Name", "ID", "VCPU", "CPU", "State", "Time(s)", "CPU Affinity");
+    if (!argc) {
+        if (!(dominfo = libxl_list_domain(ctx, &nb_domain))) {
+            fprintf(stderr, "libxl_list_domain failed.\n");
+            goto vcpulist_out;
+        }
+
+        for (i = 0; i<nb_domain; i++)
+            print_domain_vcpuinfo(dominfo[i].domid, physinfo.nr_cpus);
+
+        libxl_dominfo_list_free(dominfo, nb_domain);
+    } else {
+        for (; argc > 0; ++argv, --argc) {
+            uint32_t domid = find_domain(*argv);
+            print_domain_vcpuinfo(domid, physinfo.nr_cpus);
+        }
+    }
+  vcpulist_out:
+    libxl_physinfo_dispose(&physinfo);
+}
+
+int main_vcpulist(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpu-list", 0) {
+        /* No options */
+    }
+
+    vcpulist(argc - optind, argv + optind);
+    return 0;
+}
+
+static void vcpupin(uint32_t domid, const char *vcpu, char *cpu)
+{
+    libxl_vcpuinfo *vcpuinfo;
+    libxl_bitmap cpumap;
+
+    uint32_t vcpuid;
+    char *endptr;
+    int i, nb_vcpu;
+
+    vcpuid = strtoul(vcpu, &endptr, 10);
+    if (vcpu == endptr) {
+        if (strcmp(vcpu, "all")) {
+            fprintf(stderr, "Error: Invalid argument.\n");
+            return;
+        }
+        vcpuid = -1;
+    }
+
+    if (libxl_cpu_bitmap_alloc(ctx, &cpumap, 0)) {
+        goto vcpupin_out;
+    }
+
+    if (vcpupin_parse(cpu, &cpumap))
+        goto vcpupin_out1;
+
+    if (vcpuid != -1) {
+        if (libxl_set_vcpuaffinity(ctx, domid, vcpuid, &cpumap) == -1) {
+            fprintf(stderr, "Could not set affinity for vcpu `%u'.\n", vcpuid);
+        }
+    }
+    else {
+        if (!(vcpuinfo = libxl_list_vcpu(ctx, domid, &nb_vcpu, &i))) {
+            fprintf(stderr, "libxl_list_vcpu failed.\n");
+            goto vcpupin_out1;
+        }
+        for (i = 0; i < nb_vcpu; i++) {
+            if (libxl_set_vcpuaffinity(ctx, domid, vcpuinfo[i].vcpuid,
+                                       &cpumap) == -1) {
+                fprintf(stderr, "libxl_set_vcpuaffinity failed"
+                                " on vcpu `%u'.\n", vcpuinfo[i].vcpuid);
+            }
+        }
+        libxl_vcpuinfo_list_free(vcpuinfo, nb_vcpu);
+    }
+  vcpupin_out1:
+    libxl_bitmap_dispose(&cpumap);
+  vcpupin_out:
+    ;
+}
+
+int main_vcpupin(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vcpu-pin", 3) {
+        /* No options */
+    }
+
+    vcpupin(find_domain(argv[optind]), argv[optind+1] , argv[optind+2]);
+    return 0;
+}
+
+static void vcpuset(uint32_t domid, const char* nr_vcpus)
+{
+    char *endptr;
+    unsigned int max_vcpus, i;
+    libxl_bitmap cpumap;
+
+    max_vcpus = strtoul(nr_vcpus, &endptr, 10);
+    if (nr_vcpus == endptr) {
+        fprintf(stderr, "Error: Invalid argument.\n");
+        return;
+    }
+
+    if (libxl_cpu_bitmap_alloc(ctx, &cpumap, 0)) {
+        fprintf(stderr, "libxl_cpu_bitmap_alloc failed\n");
+        return;
+    }
+    for (i = 0; i < max_vcpus; i++)
+        libxl_bitmap_set(&cpumap, i);
+
+    if (libxl_set_vcpuonline(ctx, domid, &cpumap) < 0)
+        fprintf(stderr, "libxl_set_vcpuonline failed domid=%d max_vcpus=%d\n", domid, max_vcpus);
+
+    libxl_bitmap_dispose(&cpumap);
+}
+
+int main_vcpuset(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vcpu-set", 2) {
+        /* No options */
+    }
+
+    vcpuset(find_domain(argv[optind]), argv[optind+1]);
+    return 0;
+}
+
+static void output_xeninfo(void)
+{
+    const libxl_version_info *info;
+    libxl_scheduler sched;
+
+    if (!(info = libxl_get_version_info(ctx))) {
+        fprintf(stderr, "libxl_get_version_info failed.\n");
+        return;
+    }
+
+    if ((sched = libxl_get_scheduler(ctx)) < 0) {
+        fprintf(stderr, "get_scheduler sysctl failed.\n");
+        return;
+    }
+
+    printf("xen_major              : %d\n", info->xen_version_major);
+    printf("xen_minor              : %d\n", info->xen_version_minor);
+    printf("xen_extra              : %s\n", info->xen_version_extra);
+    printf("xen_caps               : %s\n", info->capabilities);
+    printf("xen_scheduler          : %s\n", libxl_scheduler_to_string(sched));
+    printf("xen_pagesize           : %u\n", info->pagesize);
+    printf("platform_params        : virt_start=0x%"PRIx64"\n", info->virt_start);
+    printf("xen_changeset          : %s\n", info->changeset);
+    printf("xen_commandline        : %s\n", info->commandline);
+    printf("cc_compiler            : %s\n", info->compiler);
+    printf("cc_compile_by          : %s\n", info->compile_by);
+    printf("cc_compile_domain      : %s\n", info->compile_domain);
+    printf("cc_compile_date        : %s\n", info->compile_date);
+
+    return;
+}
+
+static void output_nodeinfo(void)
+{
+    struct utsname utsbuf;
+
+    if (uname(&utsbuf) < 0)
+        return;
+
+    printf("host                   : %s\n", utsbuf.nodename);
+    printf("release                : %s\n", utsbuf.release);
+    printf("version                : %s\n", utsbuf.version);
+    printf("machine                : %s\n", utsbuf.machine);
+}
+
+static void output_physinfo(void)
+{
+    libxl_physinfo info;
+    const libxl_version_info *vinfo;
+    unsigned int i;
+    libxl_bitmap cpumap;
+    int n = 0;
+
+    if (libxl_get_physinfo(ctx, &info) != 0) {
+        fprintf(stderr, "libxl_physinfo failed.\n");
+        return;
+    }
+
+    printf("nr_cpus                : %d\n", info.nr_cpus);
+    printf("max_cpu_id             : %d\n", info.max_cpu_id);
+    printf("nr_nodes               : %d\n", info.nr_nodes);
+    printf("cores_per_socket       : %d\n", info.cores_per_socket);
+    printf("threads_per_core       : %d\n", info.threads_per_core);
+    printf("cpu_mhz                : %d\n", info.cpu_khz / 1000);
+    printf("hw_caps                : ");
+    for (i = 0; i < 8; i++)
+        printf("%08x%c", info.hw_cap[i], i < 7 ? ':' : '\n');
+    printf("virt_caps              :");
+    if (info.cap_hvm)
+        printf(" hvm");
+    if (info.cap_hvm_directio)
+        printf(" hvm_directio");
+    printf("\n");
+    vinfo = libxl_get_version_info(ctx);
+    if (vinfo) {
+        i = (1 << 20) / vinfo->pagesize;
+        printf("total_memory           : %"PRIu64"\n", info.total_pages / i);
+        printf("free_memory            : %"PRIu64"\n", info.free_pages / i);
+        printf("sharing_freed_memory   : %"PRIu64"\n", info.sharing_freed_pages / i);
+        printf("sharing_used_memory    : %"PRIu64"\n", info.sharing_used_frames / i);
+    }
+    if (!libxl_get_freecpus(ctx, &cpumap)) {
+        libxl_for_each_bit(i, cpumap)
+            if (libxl_bitmap_test(&cpumap, i))
+                n++;
+        printf("free_cpus              : %d\n", n);
+        free(cpumap.map);
+    }
+
+    libxl_physinfo_dispose(&info);
+    return;
+}
+
+static void output_numainfo(void)
+{
+    libxl_numainfo *info;
+    int i, j, nr;
+
+    info = libxl_get_numainfo(ctx, &nr);
+    if (info == NULL) {
+        fprintf(stderr, "libxl_get_numainfo failed.\n");
+        return;
+    }
+
+    printf("numa_info              :\n");
+    printf("node:    memsize    memfree    distances\n");
+
+    for (i = 0; i < nr; i++) {
+        if (info[i].size != LIBXL_NUMAINFO_INVALID_ENTRY) {
+            printf("%4d:    %6"PRIu64"     %6"PRIu64"      %d", i,
+                   info[i].size >> 20, info[i].free >> 20,
+                   info[i].dists[0]);
+            for (j = 1; j < info[i].num_dists; j++)
+                printf(",%d", info[i].dists[j]);
+            printf("\n");
+        }
+    }
+
+    libxl_numainfo_list_free(info, nr);
+
+    return;
+}
+
+static void output_topologyinfo(void)
+{
+    libxl_cputopology *info;
+    int i, nr;
+
+    info = libxl_get_cpu_topology(ctx, &nr);
+    if (info == NULL) {
+        fprintf(stderr, "libxl_get_topologyinfo failed.\n");
+        return;
+    }
+
+    printf("cpu_topology           :\n");
+    printf("cpu:    core    socket     node\n");
+
+    for (i = 0; i < nr; i++) {
+        if (info[i].core != LIBXL_CPUTOPOLOGY_INVALID_ENTRY)
+            printf("%3d:    %4d     %4d     %4d\n", i,
+                   info[i].core, info[i].socket, info[i].node);
+    }
+
+    libxl_cputopology_list_free(info, nr);
+
+    return;
+}
+
+static void print_info(int numa)
+{
+    output_nodeinfo();
+
+    output_physinfo();
+
+    if (numa) {
+        output_topologyinfo();
+        output_numainfo();
+    }
+
+    output_xeninfo();
+
+    printf("xend_config_format     : 4\n");
+
+    return;
+}
+
+int main_info(int argc, char **argv)
+{
+    int opt;
+    static struct option opts[] = {
+        {"numa", 0, 0, 'n'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+    int numa = 0;
+
+    SWITCH_FOREACH_OPT(opt, "hn", opts, "info", 0) {
+    case 'n':
+        numa = 1;
+        break;
+    }
+
+    print_info(numa);
+    return 0;
+}
+
+static void sharing(const libxl_dominfo *info, int nb_domain)
+{
+    int i;
+
+    printf("Name                                        ID   Mem Shared\n");
+
+    for (i = 0; i < nb_domain; i++) {
+        char *domname;
+        unsigned shutdown_reason;
+        domname = libxl_domid_to_name(ctx, info[i].domid);
+        shutdown_reason = info[i].shutdown ? info[i].shutdown_reason : 0;
+        printf("%-40s %5d %5lu  %5lu\n",
+                domname,
+                info[i].domid,
+                (unsigned long) (info[i].current_memkb / 1024),
+                (unsigned long) (info[i].shared_memkb / 1024));
+        free(domname);
+    }
+}
+
+int main_sharing(int argc, char **argv)
+{
+    int opt = 0;
+    libxl_dominfo info_buf;
+    libxl_dominfo *info, *info_free = NULL;
+    int nb_domain, rc;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "sharing", 0) {
+        /* No options */
+    }
+
+    if (optind >= argc) {
+        info = libxl_list_domain(ctx, &nb_domain);
+        if (!info) {
+            fprintf(stderr, "libxl_domain_infolist failed.\n");
+            return 1;
+        }
+        info_free = info;
+    } else if (optind == argc-1) {
+        uint32_t domid = find_domain(argv[optind]);
+        rc = libxl_domain_info(ctx, &info_buf, domid);
+        if (rc == ERROR_INVAL) {
+            fprintf(stderr, "Error: Domain \'%s\' does not exist.\n",
+                argv[optind]);
+            return -rc;
+        }
+        if (rc) {
+            fprintf(stderr, "libxl_domain_info failed (code %d).\n", rc);
+            return -rc;
+        }
+        info = &info_buf;
+        nb_domain = 1;
+    } else {
+        help("sharing");
+        return 2;
+    }
+
+    sharing(info, nb_domain);
+
+    if (info_free)
+        libxl_dominfo_list_free(info_free, nb_domain);
+    else
+        libxl_dominfo_dispose(info);
+
+    return 0;
+}
+
+static int sched_domain_get(libxl_scheduler sched, int domid,
+                            libxl_domain_sched_params *scinfo)
+{
+    int rc;
+
+    rc = libxl_domain_sched_params_get(ctx, domid, scinfo);
+    if (rc) {
+        fprintf(stderr, "libxl_domain_sched_params_get failed.\n");
+        return rc;
+    }
+    if (scinfo->sched != sched) {
+        fprintf(stderr, "libxl_domain_sched_params_get returned %s not %s.\n",
+                libxl_scheduler_to_string(scinfo->sched),
+                libxl_scheduler_to_string(sched));
+        return ERROR_INVAL;
+    }
+
+    return 0;
+}
+
+static int sched_domain_set(int domid, const libxl_domain_sched_params *scinfo)
+{
+    int rc;
+
+    rc = libxl_domain_sched_params_set(ctx, domid, scinfo);
+    if (rc)
+        fprintf(stderr, "libxl_domain_sched_params_set failed.\n");
+
+    return rc;
+}
+
+static int sched_credit_params_set(int poolid, libxl_sched_credit_params *scinfo)
+{
+    int rc;
+
+    rc = libxl_sched_credit_params_set(ctx, poolid, scinfo);
+    if (rc)
+        fprintf(stderr, "libxl_sched_credit_params_set failed.\n");
+
+    return rc;
+}
+
+static int sched_credit_params_get(int poolid, libxl_sched_credit_params *scinfo)
+{
+    int rc;
+
+    rc = libxl_sched_credit_params_get(ctx, poolid, scinfo);
+    if (rc)
+        fprintf(stderr, "libxl_sched_credit_params_get failed.\n");
+
+    return rc;
+}
+
+static int sched_credit_domain_output(int domid)
+{
+    char *domname;
+    libxl_domain_sched_params scinfo;
+    int rc;
+
+    if (domid < 0) {
+        printf("%-33s %4s %6s %4s\n", "Name", "ID", "Weight", "Cap");
+        return 0;
+    }
+    rc = sched_domain_get(LIBXL_SCHEDULER_CREDIT, domid, &scinfo);
+    if (rc)
+        return rc;
+    domname = libxl_domid_to_name(ctx, domid);
+    printf("%-33s %4d %6d %4d\n",
+        domname,
+        domid,
+        scinfo.weight,
+        scinfo.cap);
+    free(domname);
+    libxl_domain_sched_params_dispose(&scinfo);
+    return 0;
+}
+
+static int sched_credit_pool_output(uint32_t poolid)
+{
+    libxl_sched_credit_params scparam;
+    char *poolname;
+    int rc;
+
+    poolname = libxl_cpupoolid_to_name(ctx, poolid);
+    rc = sched_credit_params_get(poolid, &scparam);
+    if (rc) {
+        printf("Cpupool %s: [sched params unavailable]\n",
+               poolname);
+    } else {
+        printf("Cpupool %s: tslice=%dms ratelimit=%dus\n",
+               poolname,
+               scparam.tslice_ms,
+               scparam.ratelimit_us);
+    }
+    free(poolname);
+    return 0;
+}
+
+static int sched_credit2_domain_output(
+    int domid)
+{
+    char *domname;
+    libxl_domain_sched_params scinfo;
+    int rc;
+
+    if (domid < 0) {
+        printf("%-33s %4s %6s\n", "Name", "ID", "Weight");
+        return 0;
+    }
+    rc = sched_domain_get(LIBXL_SCHEDULER_CREDIT2, domid, &scinfo);
+    if (rc)
+        return rc;
+    domname = libxl_domid_to_name(ctx, domid);
+    printf("%-33s %4d %6d\n",
+        domname,
+        domid,
+        scinfo.weight);
+    free(domname);
+    libxl_domain_sched_params_dispose(&scinfo);
+    return 0;
+}
+
+static int sched_sedf_domain_output(
+    int domid)
+{
+    char *domname;
+    libxl_domain_sched_params scinfo;
+    int rc;
+
+    if (domid < 0) {
+        printf("%-33s %4s %6s %-6s %7s %5s %6s\n", "Name", "ID", "Period",
+               "Slice", "Latency", "Extra", "Weight");
+        return 0;
+    }
+    rc = sched_domain_get(LIBXL_SCHEDULER_SEDF, domid, &scinfo);
+    if (rc)
+        return rc;
+    domname = libxl_domid_to_name(ctx, domid);
+    printf("%-33s %4d %6d %6d %7d %5d %6d\n",
+        domname,
+        domid,
+        scinfo.period,
+        scinfo.slice,
+        scinfo.latency,
+        scinfo.extratime,
+        scinfo.weight);
+    free(domname);
+    libxl_domain_sched_params_dispose(&scinfo);
+    return 0;
+}
+
+static int sched_default_pool_output(uint32_t poolid)
+{
+    char *poolname;
+
+    poolname = libxl_cpupoolid_to_name(ctx, poolid);
+    printf("Cpupool %s:\n",
+           poolname);
+    free(poolname);
+    return 0;
+}
+
+static int sched_domain_output(libxl_scheduler sched, int (*output)(int),
+                               int (*pooloutput)(uint32_t), const char *cpupool)
+{
+    libxl_dominfo *info;
+    libxl_cpupoolinfo *poolinfo = NULL;
+    uint32_t poolid;
+    int nb_domain, n_pools = 0, i, p;
+    int rc = 0;
+
+    if (cpupool) {
+        if (cpupool_qualifier_to_cpupoolid(cpupool, &poolid, NULL) ||
+            !libxl_cpupoolid_is_valid(ctx, poolid)) {
+            fprintf(stderr, "unknown cpupool \'%s\'\n", cpupool);
+            return -ERROR_FAIL;
+        }
+    }
+
+    info = libxl_list_domain(ctx, &nb_domain);
+    if (!info) {
+        fprintf(stderr, "libxl_domain_infolist failed.\n");
+        return 1;
+    }
+    poolinfo = libxl_list_cpupool(ctx, &n_pools);
+    if (!poolinfo) {
+        fprintf(stderr, "error getting cpupool info\n");
+        return -ERROR_NOMEM;
+    }
+
+    for (p = 0; !rc && (p < n_pools); p++) {
+        if ((poolinfo[p].sched != sched) ||
+            (cpupool && (poolid != poolinfo[p].poolid)))
+            continue;
+
+        pooloutput(poolinfo[p].poolid);
+
+        output(-1);
+        for (i = 0; i < nb_domain; i++) {
+            if (info[i].cpupool != poolinfo[p].poolid)
+                continue;
+            rc = output(info[i].domid);
+            if (rc)
+                break;
+        }
+    }
+    if (poolinfo)
+        libxl_cpupoolinfo_list_free(poolinfo, n_pools);
+    return 0;
+}
+
+/* 
+ * <nothing>             : List all domain params and sched params from all pools
+ * -d [domid]            : List domain params for domain
+ * -d [domid] [params]   : Set domain params for domain
+ * -p [pool]             : list all domains and sched params for pool
+ * -s                    : List sched params for poolid 0
+ * -s [params]           : Set sched params for poolid 0
+ * -p [pool] -s          : List sched params for pool
+ * -p [pool] -s [params] : Set sched params for pool
+ * -p [pool] -d...       : Illegal
+ */
+int main_sched_credit(int argc, char **argv)
+{
+    const char *dom = NULL;
+    const char *cpupool = NULL;
+    int weight = 256, cap = 0, opt_w = 0, opt_c = 0;
+    int opt_s = 0;
+    int tslice = 0, opt_t = 0, ratelimit = 0, opt_r = 0;
+    int opt, rc;
+    static struct option opts[] = {
+        {"domain", 1, 0, 'd'},
+        {"weight", 1, 0, 'w'},
+        {"cap", 1, 0, 'c'},
+        {"schedparam", 0, 0, 's'},
+        {"tslice_ms", 1, 0, 't'},
+        {"ratelimit_us", 1, 0, 'r'},
+        {"cpupool", 1, 0, 'p'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "d:w:c:p:t:r:hs", opts, "sched-credit", 0) {
+    case 'd':
+        dom = optarg;
+        break;
+    case 'w':
+        weight = strtol(optarg, NULL, 10);
+        opt_w = 1;
+        break;
+    case 'c':
+        cap = strtol(optarg, NULL, 10);
+        opt_c = 1;
+        break;
+    case 't':
+        tslice = strtol(optarg, NULL, 10);
+        opt_t = 1;
+        break;
+    case 'r':
+        ratelimit = strtol(optarg, NULL, 10);
+        opt_r = 1;
+        break;
+    case 's':
+        opt_s = 1;
+        break;
+    case 'p':
+        cpupool = optarg;
+        break;
+    }
+
+    if ((cpupool || opt_s) && (dom || opt_w || opt_c)) {
+        fprintf(stderr, "Specifying a cpupool or schedparam is not "
+                "allowed with domain options.\n");
+        return 1;
+    }
+    if (!dom && (opt_w || opt_c)) {
+        fprintf(stderr, "Must specify a domain.\n");
+        return 1;
+    }
+    if (!opt_s && (opt_t || opt_r)) {
+        fprintf(stderr, "Must specify schedparam to set schedule "
+                "parameter values.\n");
+        return 1;
+    }
+
+    if (opt_s) {
+        libxl_sched_credit_params scparam;
+        uint32_t poolid = 0;
+
+        if (cpupool) {
+            if (cpupool_qualifier_to_cpupoolid(cpupool, &poolid, NULL) ||
+                !libxl_cpupoolid_is_valid(ctx, poolid)) {
+                fprintf(stderr, "unknown cpupool \'%s\'\n", cpupool);
+                return -ERROR_FAIL;
+            }
+        }
+
+        if (!opt_t && !opt_r) { /* Output scheduling parameters */
+            return -sched_credit_pool_output(poolid);
+        } else { /* Set scheduling parameters*/
+            rc = sched_credit_params_get(poolid, &scparam);
+            if (rc)
+                return -rc;
+
+            if (opt_t)
+                scparam.tslice_ms = tslice;
+
+            if (opt_r)
+                scparam.ratelimit_us = ratelimit;
+
+            rc = sched_credit_params_set(poolid, &scparam);
+            if (rc)
+                return -rc;
+        }
+    } else if (!dom) { /* list all domain's credit scheduler info */
+        return -sched_domain_output(LIBXL_SCHEDULER_CREDIT,
+                                    sched_credit_domain_output,
+                                    sched_credit_pool_output,
+                                    cpupool);
+    } else {
+        uint32_t domid = find_domain(dom);
+
+        if (!opt_w && !opt_c) { /* output credit scheduler info */
+            sched_credit_domain_output(-1);
+            return -sched_credit_domain_output(domid);
+        } else { /* set credit scheduler paramaters */
+            libxl_domain_sched_params scinfo;
+            libxl_domain_sched_params_init(&scinfo);
+            scinfo.sched = LIBXL_SCHEDULER_CREDIT;
+            if (opt_w)
+                scinfo.weight = weight;
+            if (opt_c)
+                scinfo.cap = cap;
+            rc = sched_domain_set(domid, &scinfo);
+            libxl_domain_sched_params_dispose(&scinfo);
+            if (rc)
+                return -rc;
+        }
+    }
+
+    return 0;
+}
+
+int main_sched_credit2(int argc, char **argv)
+{
+    const char *dom = NULL;
+    const char *cpupool = NULL;
+    int weight = 256, opt_w = 0;
+    int opt, rc;
+    static struct option opts[] = {
+        {"domain", 1, 0, 'd'},
+        {"weight", 1, 0, 'w'},
+        {"cpupool", 1, 0, 'p'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "d:w:p:h", opts, "sched-credit2", 0) {
+    case 'd':
+        dom = optarg;
+        break;
+    case 'w':
+        weight = strtol(optarg, NULL, 10);
+        opt_w = 1;
+        break;
+    case 'p':
+        cpupool = optarg;
+        break;
+    }
+
+    if (cpupool && (dom || opt_w)) {
+        fprintf(stderr, "Specifying a cpupool is not allowed with other "
+                "options.\n");
+        return 1;
+    }
+    if (!dom && opt_w) {
+        fprintf(stderr, "Must specify a domain.\n");
+        return 1;
+    }
+
+    if (!dom) { /* list all domain's credit scheduler info */
+        return -sched_domain_output(LIBXL_SCHEDULER_CREDIT2,
+                                    sched_credit2_domain_output,
+                                    sched_default_pool_output,
+                                    cpupool);
+    } else {
+        uint32_t domid = find_domain(dom);
+
+        if (!opt_w) { /* output credit2 scheduler info */
+            sched_credit2_domain_output(-1);
+            return -sched_credit2_domain_output(domid);
+        } else { /* set credit2 scheduler paramaters */
+            libxl_domain_sched_params scinfo;
+            libxl_domain_sched_params_init(&scinfo);
+            scinfo.sched = LIBXL_SCHEDULER_CREDIT2;
+            if (opt_w)
+                scinfo.weight = weight;
+            rc = sched_domain_set(domid, &scinfo);
+            libxl_domain_sched_params_dispose(&scinfo);
+            if (rc)
+                return -rc;
+        }
+    }
+
+    return 0;
+}
+
+int main_sched_sedf(int argc, char **argv)
+{
+    const char *dom = NULL;
+    const char *cpupool = NULL;
+    int period = 0, opt_p = 0;
+    int slice = 0, opt_s = 0;
+    int latency = 0, opt_l = 0;
+    int extra = 0, opt_e = 0;
+    int weight = 0, opt_w = 0;
+    int opt, rc;
+    static struct option opts[] = {
+        {"period", 1, 0, 'p'},
+        {"slice", 1, 0, 's'},
+        {"latency", 1, 0, 'l'},
+        {"extra", 1, 0, 'e'},
+        {"weight", 1, 0, 'w'},
+        {"cpupool", 1, 0, 'c'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+
+    SWITCH_FOREACH_OPT(opt, "d:p:s:l:e:w:c:h", opts, "sched-sedf", 0) {
+    case 'd':
+        dom = optarg;
+        break;
+    case 'p':
+        period = strtol(optarg, NULL, 10);
+        opt_p = 1;
+        break;
+    case 's':
+        slice = strtol(optarg, NULL, 10);
+        opt_s = 1;
+        break;
+    case 'l':
+        latency = strtol(optarg, NULL, 10);
+        opt_l = 1;
+        break;
+    case 'e':
+        extra = strtol(optarg, NULL, 10);
+        opt_e = 1;
+        break;
+    case 'w':
+        weight = strtol(optarg, NULL, 10);
+        opt_w = 1;
+        break;
+    case 'c':
+        cpupool = optarg;
+        break;
+    }
+
+    if (cpupool && (dom || opt_p || opt_s || opt_l || opt_e || opt_w)) {
+        fprintf(stderr, "Specifying a cpupool is not allowed with other "
+                "options.\n");
+        return 1;
+    }
+    if (!dom && (opt_p || opt_s || opt_l || opt_e || opt_w)) {
+        fprintf(stderr, "Must specify a domain.\n");
+        return 1;
+    }
+    if (opt_w && (opt_p || opt_s)) {
+        fprintf(stderr, "Specifying a weight AND period or slice is not "
+                "allowed.\n");
+    }
+
+    if (!dom) { /* list all domain's credit scheduler info */
+        return -sched_domain_output(LIBXL_SCHEDULER_SEDF,
+                                    sched_sedf_domain_output,
+                                    sched_default_pool_output,
+                                    cpupool);
+    } else {
+        uint32_t domid = find_domain(dom);
+
+        if (!opt_p && !opt_s && !opt_l && !opt_e && !opt_w) {
+            /* output sedf scheduler info */
+            sched_sedf_domain_output(-1);
+            return -sched_sedf_domain_output(domid);
+        } else { /* set sedf scheduler paramaters */
+            libxl_domain_sched_params scinfo;
+            libxl_domain_sched_params_init(&scinfo);
+            scinfo.sched = LIBXL_SCHEDULER_SEDF;
+
+            if (opt_p) {
+                scinfo.period = period;
+                scinfo.weight = 0;
+            }
+            if (opt_s) {
+                scinfo.slice = slice;
+                scinfo.weight = 0;
+            }
+            if (opt_l)
+                scinfo.latency = latency;
+            if (opt_e)
+                scinfo.extratime = extra;
+            if (opt_w) {
+                scinfo.weight = weight;
+                scinfo.period = 0;
+                scinfo.slice = 0;
+            }
+            rc = sched_domain_set(domid, &scinfo);
+            libxl_domain_sched_params_dispose(&scinfo);
+            if (rc)
+                return -rc;
+        }
+    }
+
+    return 0;
+}
+
+int main_domid(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    const char *domname = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "domid", 1) {
+        /* No options */
+    }
+
+    domname = argv[optind];
+
+    if (libxl_name_to_domid(ctx, domname, &domid)) {
+        fprintf(stderr, "Can't get domid of domain name '%s', maybe this domain does not exist.\n", domname);
+        return 1;
+    }
+
+    printf("%d\n", domid);
+
+    return 0;
+}
+
+int main_domname(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    char *domname = NULL;
+    char *endptr = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "domname", 1) {
+        /* No options */
+    }
+
+    domid = strtol(argv[optind], &endptr, 10);
+    if (domid == 0 && !strcmp(endptr, argv[optind])) {
+        /*no digits at all*/
+        fprintf(stderr, "Invalid domain id.\n\n");
+        return 1;
+    }
+
+    domname = libxl_domid_to_name(ctx, domid);
+    if (!domname) {
+        fprintf(stderr, "Can't get domain name of domain id '%d', maybe this domain does not exist.\n", domid);
+        return 1;
+    }
+
+    printf("%s\n", domname);
+    free(domname);
+
+    return 0;
+}
+
+int main_rename(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    const char *dom, *new_name;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "rename", 2) {
+        /* No options */
+    }
+
+    dom = argv[optind++];
+    new_name = argv[optind];
+
+    domid = find_domain(dom);
+    if (libxl_domain_rename(ctx, domid, common_domname, new_name)) {
+        fprintf(stderr, "Can't rename domain '%s'.\n", dom);
+        return 1;
+    }
+
+    return 0;
+}
+
+int main_trigger(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    char *endptr = NULL;
+    int vcpuid = 0;
+    const char *trigger_name = NULL;
+    libxl_trigger trigger;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "trigger", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind++]);
+
+    trigger_name = argv[optind++];
+    if (libxl_trigger_from_string(trigger_name, &trigger)) {
+        fprintf(stderr, "Invalid trigger \"%s\"\n", trigger_name);
+        return -1;
+    }
+
+    if (argv[optind]) {
+        vcpuid = strtol(argv[optind], &endptr, 10);
+        if (vcpuid == 0 && !strcmp(endptr, argv[optind])) {
+            fprintf(stderr, "Invalid vcpuid, using default vcpuid=0.\n\n");
+        }
+    }
+
+    libxl_send_trigger(ctx, domid, trigger, vcpuid);
+
+    return 0;
+}
+
+
+int main_sysrq(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    const char *sysrq = NULL;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "sysrq", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind++]);
+
+    sysrq = argv[optind];
+
+    if (sysrq[1] != '\0') {
+        fprintf(stderr, "Invalid sysrq.\n\n");
+        help("sysrq");
+        return 1;
+    }
+
+    libxl_send_sysrq(ctx, domid, sysrq[0]);
+
+    return 0;
+}
+
+int main_debug_keys(int argc, char **argv)
+{
+    int opt;
+    char *keys;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "debug-keys", 1) {
+        /* No options */
+    }
+
+    keys = argv[optind];
+
+    if (libxl_send_debug_keys(ctx, keys)) {
+        fprintf(stderr, "cannot send debug keys: %s\n", keys);
+        return 1;
+    }
+
+    return 0;
+}
+
+int main_dmesg(int argc, char **argv)
+{
+    unsigned int clear = 0;
+    libxl_xen_console_reader *cr;
+    char *line;
+    int opt, ret = 1;
+
+    SWITCH_FOREACH_OPT(opt, "c", NULL, "dmesg", 0) {
+    case 'c':
+        clear = 1;
+        break;
+    }
+
+    cr = libxl_xen_console_read_start(ctx, clear);
+    if (!cr)
+        goto finish;
+
+    while ((ret = libxl_xen_console_read_line(ctx, cr, &line)) > 0)
+        printf("%s", line);
+
+finish:
+    libxl_xen_console_read_finish(ctx, cr);
+    return ret;
+}
+
+int main_top(int argc, char **argv)
+{
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "top", 0) {
+        /* No options */
+    }
+
+    return system("xentop");
+}
+
+int main_networkattach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    libxl_device_nic nic;
+    XLU_Config *config = 0;
+    char *endptr, *oparg;
+    const char *tok;
+    int i;
+    unsigned int val;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "network-attach", 1) {
+        /* No options */
+    }
+
+    if (argc-optind > 11) {
+        help("network-attach");
+        return 0;
+    }
+
+    domid = find_domain(argv[optind]);
+
+    config= xlu_cfg_init(stderr, "command line");
+    if (!config) {
+        fprintf(stderr, "Failed to allocate for configuration\n");
+        return 1;
+    }
+
+    libxl_device_nic_init(&nic);
+    for (argv += optind+1, argc -= optind+1; argc > 0; ++argv, --argc) {
+        if (MATCH_OPTION("type", *argv, oparg)) {
+            if (!strcmp("vif", oparg)) {
+                nic.nictype = LIBXL_NIC_TYPE_VIF;
+            } else if (!strcmp("ioemu", oparg)) {
+                nic.nictype = LIBXL_NIC_TYPE_VIF_IOEMU;
+            } else {
+                fprintf(stderr, "Invalid parameter `type'.\n");
+                return 1;
+            }
+        } else if (MATCH_OPTION("mac", *argv, oparg)) {
+            tok = strtok(oparg, ":");
+            for (i = 0; tok && i < 6; tok = strtok(NULL, ":"), ++i) {
+                val = strtoul(tok, &endptr, 16);
+                if ((tok == endptr) || (val > 255)) {
+                    fprintf(stderr, "Invalid parameter `mac'.\n");
+                    return 1;
+                }
+                nic.mac[i] = val;
+            }
+        } else if (MATCH_OPTION("bridge", *argv, oparg)) {
+            replace_string(&nic.bridge, oparg);
+        } else if (MATCH_OPTION("netdev", *argv, oparg)) {
+            fprintf(stderr, "the netdev parameter is deprecated, "
+                            "please use gatewaydev instead\n");
+            replace_string(&nic.gatewaydev, oparg);
+        } else if (MATCH_OPTION("gatewaydev", *argv, oparg)) {
+            replace_string(&nic.gatewaydev, oparg);
+        } else if (MATCH_OPTION("ip", *argv, oparg)) {
+            replace_string(&nic.ip, oparg);
+        } else if (MATCH_OPTION("script", *argv, oparg)) {
+            replace_string(&nic.script, oparg);
+        } else if (MATCH_OPTION("backend", *argv, oparg)) {
+            if(libxl_name_to_domid(ctx, oparg, &val)) {
+                fprintf(stderr, "Specified backend domain does not exist, defaulting to Dom0\n");
+                val = 0;
+            }
+            nic.backend_domid = val;
+        } else if (MATCH_OPTION("vifname", *argv, oparg)) {
+            replace_string(&nic.ifname, oparg);
+        } else if (MATCH_OPTION("model", *argv, oparg)) {
+            replace_string(&nic.model, oparg);
+        } else if (MATCH_OPTION("rate", *argv, oparg)) {
+            parse_vif_rate(&config, oparg, &nic);
+        } else if (MATCH_OPTION("accel", *argv, oparg)) {
+        } else {
+            fprintf(stderr, "unrecognized argument `%s'\n", *argv);
+            return 1;
+        }
+    }
+
+    if (dryrun_only) {
+        char *json = libxl_device_nic_to_json(ctx, &nic);
+        printf("vif: %s\n", json);
+        free(json);
+        libxl_device_nic_dispose(&nic);
+        if (ferror(stdout) || fflush(stdout)) { perror("stdout"); exit(-1); }
+        return 0;
+    }
+
+    if (libxl_device_nic_add(ctx, domid, &nic, 0)) {
+        fprintf(stderr, "libxl_device_nic_add failed.\n");
+        return 1;
+    }
+    libxl_device_nic_dispose(&nic);
+    xlu_cfg_destroy(config);
+    return 0;
+}
+
+int main_networklist(int argc, char **argv)
+{
+    int opt;
+    libxl_device_nic *nics;
+    libxl_nicinfo nicinfo;
+    int nb, i;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "network-list", 1) {
+        /* No options */
+    }
+
+    /*      Idx  BE   MAC   Hdl  Sta  evch txr/rxr  BE-path */
+    printf("%-3s %-2s %-17s %-6s %-5s %-6s %5s/%-5s %-30s\n",
+           "Idx", "BE", "Mac Addr.", "handle", "state", "evt-ch", "tx-", "rx-ring-ref", "BE-path");
+    for (argv += optind, argc -= optind; argc > 0; --argc, ++argv) {
+        uint32_t domid = find_domain(*argv);
+        nics = libxl_device_nic_list(ctx, domid, &nb);
+        if (!nics) {
+            continue;
+        }
+        for (i = 0; i < nb; ++i) {
+            if (!libxl_device_nic_getinfo(ctx, domid, &nics[i], &nicinfo)) {
+                /* Idx BE */
+                printf("%-3d %-2d ", nicinfo.devid, nicinfo.backend_id);
+                /* MAC */
+                printf(LIBXL_MAC_FMT, LIBXL_MAC_BYTES(nics[i].mac));
+                /* Hdl  Sta  evch txr/rxr  BE-path */
+                printf("%6d %5d %6d %5d/%-11d %-30s\n",
+                       nicinfo.devid, nicinfo.state, nicinfo.evtch,
+                       nicinfo.rref_tx, nicinfo.rref_rx, nicinfo.backend);
+                libxl_nicinfo_dispose(&nicinfo);
+            }
+            libxl_device_nic_dispose(&nics[i]);
+        }
+        free(nics);
+    }
+    return 0;
+}
+
+int main_networkdetach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt;
+    libxl_device_nic nic;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "network-detach", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+
+    if (!strchr(argv[optind+1], ':')) {
+        if (libxl_devid_to_device_nic(ctx, domid, atoi(argv[optind+1]), &nic)) {
+            fprintf(stderr, "Unknown device %s.\n", argv[optind+1]);
+            return 1;
+        }
+    } else {
+        if (libxl_mac_to_device_nic(ctx, domid, argv[optind+1], &nic)) {
+            fprintf(stderr, "Unknown device %s.\n", argv[optind+1]);
+            return 1;
+        }
+    }
+    if (libxl_device_nic_remove(ctx, domid, &nic, 0)) {
+        fprintf(stderr, "libxl_device_nic_del failed.\n");
+        return 1;
+    }
+    libxl_device_nic_dispose(&nic);
+    return 0;
+}
+
+int main_blockattach(int argc, char **argv)
+{
+    int opt;
+    uint32_t fe_domid, be_domid = 0;
+    libxl_device_disk disk = { 0 };
+    XLU_Config *config = 0;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "block-attach", 2) {
+        /* No options */
+    }
+
+    if (domain_qualifier_to_domid(argv[optind], &fe_domid, 0) < 0) {
+        fprintf(stderr, "%s is an invalid domain identifier\n", argv[optind]);
+        return 1;
+    }
+    optind++;
+
+    parse_disk_config_multistring
+        (&config, argc-optind, (const char* const*)argv + optind, &disk);
+
+    disk.backend_domid = be_domid;
+
+    if (dryrun_only) {
+        char *json = libxl_device_disk_to_json(ctx, &disk);
+        printf("disk: %s\n", json);
+        free(json);
+        if (ferror(stdout) || fflush(stdout)) { perror("stdout"); exit(-1); }
+        return 0;
+    }
+
+    if (libxl_device_disk_add(ctx, fe_domid, &disk, 0)) {
+        fprintf(stderr, "libxl_device_disk_add failed.\n");
+    }
+    return 0;
+}
+
+int main_blocklist(int argc, char **argv)
+{
+    int opt;
+    int i, nb;
+    libxl_device_disk *disks;
+    libxl_diskinfo diskinfo;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "block-list", 1) {
+        /* No options */
+    }
+
+    printf("%-5s %-3s %-6s %-5s %-6s %-8s %-30s\n",
+           "Vdev", "BE", "handle", "state", "evt-ch", "ring-ref", "BE-path");
+    for (argv += optind, argc -= optind; argc > 0; --argc, ++argv) {
+        uint32_t domid;
+        if (domain_qualifier_to_domid(*argv, &domid, 0) < 0) {
+            fprintf(stderr, "%s is an invalid domain identifier\n", *argv);
+            continue;
+        }
+        disks = libxl_device_disk_list(ctx, domid, &nb);
+        if (!disks) {
+            continue;
+        }
+        for (i=0; i<nb; i++) {
+            if (!libxl_device_disk_getinfo(ctx, domid, &disks[i], &diskinfo)) {
+                /*      Vdev BE   hdl  st   evch rref BE-path*/
+                printf("%-5d %-3d %-6d %-5d %-6d %-8d %-30s\n",
+                       diskinfo.devid, diskinfo.backend_id, diskinfo.frontend_id,
+                       diskinfo.state, diskinfo.evtch, diskinfo.rref, diskinfo.backend);
+                libxl_diskinfo_dispose(&diskinfo);
+            }
+            libxl_device_disk_dispose(&disks[i]);
+        }
+        free(disks);
+    }
+    return 0;
+}
+
+int main_blockdetach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt, rc = 0;
+    libxl_device_disk disk;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "block-detach", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+
+    if (libxl_vdev_to_device_disk(ctx, domid, argv[optind+1], &disk)) {
+        fprintf(stderr, "Error: Device %s not connected.\n", argv[optind+1]);
+        return 1;
+    }
+    rc = libxl_device_disk_remove(ctx, domid, &disk, 0);
+    if (rc) {
+        fprintf(stderr, "libxl_device_disk_remove failed.\n");
+    }
+    libxl_device_disk_dispose(&disk);
+    return rc;
+}
+
+int main_vtpmattach(int argc, char **argv)
+{
+    int opt;
+    libxl_device_vtpm vtpm;
+    char *oparg;
+    unsigned int val;
+    uint32_t domid;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vtpm-attach", 1) {
+        /* No options */
+    }
+
+    if (domain_qualifier_to_domid(argv[optind], &domid, 0) < 0) {
+        fprintf(stderr, "%s is an invalid domain identifier\n", argv[optind]);
+        return 1;
+    }
+    ++optind;
+
+    libxl_device_vtpm_init(&vtpm);
+    for (argv += optind, argc -= optind; argc > 0; ++argv, --argc) {
+        if (MATCH_OPTION("uuid", *argv, oparg)) {
+            if(libxl_uuid_from_string(&(vtpm.uuid), oparg)) {
+                fprintf(stderr, "Invalid uuid specified (%s)\n", oparg);
+                return 1;
+            }
+        } else if (MATCH_OPTION("backend", *argv, oparg)) {
+            if(domain_qualifier_to_domid(oparg, &val, 0)) {
+                fprintf(stderr,
+                      "Specified backend domain does not exist, defaulting to Dom0\n");
+                val = 0;
+            }
+            vtpm.backend_domid = val;
+        } else {
+            fprintf(stderr, "unrecognized argument `%s'\n", *argv);
+            return 1;
+        }
+    }
+
+    if(dryrun_only) {
+       char* json = libxl_device_vtpm_to_json(ctx, &vtpm);
+       printf("vtpm: %s\n", json);
+       free(json);
+       libxl_device_vtpm_dispose(&vtpm);
+       if (ferror(stdout) || fflush(stdout)) { perror("stdout"); exit(-1); }
+       return 0;
+    }
+
+    if (libxl_device_vtpm_add(ctx, domid, &vtpm, 0)) {
+        fprintf(stderr, "libxl_device_vtpm_add failed.\n");
+        return 1;
+    }
+    libxl_device_vtpm_dispose(&vtpm);
+    return 0;
+}
+
+int main_vtpmlist(int argc, char **argv)
+{
+    int opt;
+    libxl_device_vtpm *vtpms;
+    libxl_vtpminfo vtpminfo;
+    int nb, i;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vtpm-list", 1) {
+        /* No options */
+    }
+
+    /*      Idx  BE   UUID   Hdl  Sta  evch rref  BE-path */
+    printf("%-3s %-2s %-36s %-6s %-5s %-6s %-5s %-10s\n",
+           "Idx", "BE", "Uuid", "handle", "state", "evt-ch", "ring-ref", "BE-path");
+    for (argv += optind, argc -= optind; argc > 0; --argc, ++argv) {
+        uint32_t domid;
+        if (domain_qualifier_to_domid(*argv, &domid, 0) < 0) {
+            fprintf(stderr, "%s is an invalid domain identifier\n", *argv);
+            continue;
+        }
+        if (!(vtpms = libxl_device_vtpm_list(ctx, domid, &nb))) {
+            continue;
+        }
+        for (i = 0; i < nb; ++i) {
+           if(!libxl_device_vtpm_getinfo(ctx, domid, &vtpms[i], &vtpminfo)) {
+              /*      Idx  BE     UUID             Hdl Sta evch rref BE-path*/
+              printf("%-3d %-2d " LIBXL_UUID_FMT " %6d %5d %6d %8d %-30s\n",
+                    vtpminfo.devid, vtpminfo.backend_id,
+                    LIBXL_UUID_BYTES(vtpminfo.uuid),
+                    vtpminfo.devid, vtpminfo.state, vtpminfo.evtch,
+                    vtpminfo.rref, vtpminfo.backend);
+
+              libxl_vtpminfo_dispose(&vtpminfo);
+           }
+           libxl_device_vtpm_dispose(&vtpms[i]);
+        }
+        free(vtpms);
+    }
+    return 0;
+}
+
+int main_vtpmdetach(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt, rc=0;
+    libxl_device_vtpm vtpm;
+    libxl_uuid uuid;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "vtpm-detach", 2) {
+        /* No options */
+    }
+
+    domid = find_domain(argv[optind]);
+
+    if ( libxl_uuid_from_string(&uuid, argv[optind+1])) {
+        if (libxl_devid_to_device_vtpm(ctx, domid, atoi(argv[optind+1]), &vtpm)) {
+            fprintf(stderr, "Unknown device %s.\n", argv[optind+1]);
+            return 1;
+        }
+    } else {
+        if (libxl_uuid_to_device_vtpm(ctx, domid, &uuid, &vtpm)) {
+            fprintf(stderr, "Unknown device %s.\n", argv[optind+1]);
+            return 1;
+        }
+    }
+    rc = libxl_device_vtpm_remove(ctx, domid, &vtpm, 0);
+    if (rc) {
+        fprintf(stderr, "libxl_device_vtpm_remove failed.\n");
+    }
+    libxl_device_vtpm_dispose(&vtpm);
+    return rc;
+}
+
+
+static char *uptime_to_string(unsigned long uptime, int short_mode)
+{
+    int sec, min, hour, day;
+    char *time_string;
+    int ret;
+
+    day = (int)(uptime / 86400);
+    uptime -= (day * 86400);
+    hour = (int)(uptime / 3600);
+    uptime -= (hour * 3600);
+    min = (int)(uptime / 60);
+    uptime -= (min * 60);
+    sec = uptime;
+
+    if (short_mode)
+        if (day > 1)
+            ret = asprintf(&time_string, "%d days, %2d:%02d", day, hour, min);
+        else if (day == 1)
+            ret = asprintf(&time_string, "%d day, %2d:%02d", day, hour, min);
+        else
+            ret = asprintf(&time_string, "%2d:%02d", hour, min);
+    else
+        if (day > 1)
+            ret = asprintf(&time_string, "%d days, %2d:%02d:%02d", day, hour, min, sec);
+        else if (day == 1)
+            ret = asprintf(&time_string, "%d day, %2d:%02d:%02d", day, hour, min, sec);
+        else
+            ret = asprintf(&time_string, "%2d:%02d:%02d", hour, min, sec);
+
+    if (ret < 0)
+        return NULL;
+    return time_string;
+}
+
+static char *current_time_to_string(time_t now)
+{
+    char now_str[100];
+    struct tm *tmp;
+
+    tmp = localtime(&now);
+    if (tmp == NULL) {
+        fprintf(stderr, "Get localtime error");
+        exit(-1);
+    }
+    if (strftime(now_str, sizeof(now_str), "%H:%M:%S", tmp) == 0) {
+        fprintf(stderr, "strftime returned 0");
+        exit(-1);
+    }
+    return strdup(now_str);
+}
+
+static void print_dom0_uptime(int short_mode, time_t now)
+{
+    int fd;
+    char buf[512];
+    uint32_t uptime = 0;
+    char *uptime_str = NULL;
+    char *now_str = NULL;
+    char *domname;
+
+    fd = open("/proc/uptime", O_RDONLY);
+    if (fd == -1)
+        goto err;
+
+    if (read(fd, buf, sizeof(buf)) == -1) {
+        close(fd);
+        goto err;
+    }
+    close(fd);
+
+    strtok(buf, " ");
+    uptime = strtoul(buf, NULL, 10);
+
+    domname = libxl_domid_to_name(ctx, 0);
+    if (short_mode)
+    {
+        now_str = current_time_to_string(now);
+        uptime_str = uptime_to_string(uptime, 1);
+        printf(" %s up %s, %s (%d)\n", now_str, uptime_str,
+               domname, 0);
+    }
+    else
+    {
+        now_str = NULL;
+        uptime_str = uptime_to_string(uptime, 0);
+        printf("%-33s %4d %s\n", domname,
+               0, uptime_str);
+    }
+
+    free(now_str);
+    free(uptime_str);
+    free(domname);
+    return;
+err:
+    fprintf(stderr, "Can not get Dom0 uptime.\n");
+    exit(-1);
+}
+
+static void print_domU_uptime(uint32_t domuid, int short_mode, time_t now)
+{
+    uint32_t s_time = 0;
+    uint32_t uptime = 0;
+    char *uptime_str = NULL;
+    char *now_str = NULL;
+    char *domname;
+
+    s_time = libxl_vm_get_start_time(ctx, domuid);
+    if (s_time == -1)
+        return;
+    uptime = now - s_time;
+    domname = libxl_domid_to_name(ctx, domuid);
+    if (short_mode)
+    {
+        now_str = current_time_to_string(now);
+        uptime_str = uptime_to_string(uptime, 1);
+        printf(" %s up %s, %s (%d)\n", now_str, uptime_str,
+               domname, domuid);
+    }
+    else
+    {
+        now_str = NULL;
+        uptime_str = uptime_to_string(uptime, 0);
+        printf("%-33s %4d %s\n", domname,
+               domuid, uptime_str);
+    }
+
+    free(domname);
+    free(now_str);
+    free(uptime_str);
+    return;
+}
+
+static void print_uptime(int short_mode, uint32_t doms[], int nb_doms)
+{
+    libxl_vminfo *info;
+    time_t now;
+    int nb_vm, i;
+
+    now = time(NULL);
+
+    if (!short_mode)
+        printf("%-33s %4s %s\n", "Name", "ID", "Uptime");
+
+    if (nb_doms == 0) {
+        print_dom0_uptime(short_mode, now);
+        info = libxl_list_vm(ctx, &nb_vm);
+        for (i = 0; i < nb_vm; i++)
+            print_domU_uptime(info[i].domid, short_mode, now);
+        libxl_vminfo_list_free(info, nb_vm);
+    } else {
+        for (i = 0; i < nb_doms; i++) {
+            if (doms[i] == 0)
+                print_dom0_uptime(short_mode, now);
+            else
+                print_domU_uptime(doms[i], short_mode, now);
+        }
+    }
+}
+
+int main_uptime(int argc, char **argv)
+{
+    const char *dom;
+    int short_mode = 0;
+    uint32_t domains[100];
+    int nb_doms = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "s", NULL, "uptime", 1) {
+    case 's':
+        short_mode = 1;
+        break;
+    }
+
+    for (;(dom = argv[optind]) != NULL; nb_doms++,optind++)
+        domains[nb_doms] = find_domain(dom);
+
+    print_uptime(short_mode, domains, nb_doms);
+
+    return 0;
+}
+
+int main_tmem_list(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *dom = NULL;
+    char *buf = NULL;
+    int use_long = 0;
+    int all = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "al", NULL, "tmem-list", 0) {
+    case 'l':
+        use_long = 1;
+        break;
+    case 'a':
+        all = 1;
+        break;
+    }
+
+    dom = argv[optind];
+    if (!dom && all == 0) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        help("tmem-list");
+        return 1;
+    }
+
+    if (all)
+        domid = INVALID_DOMID;
+    else
+        domid = find_domain(dom);
+
+    buf = libxl_tmem_list(ctx, domid, use_long);
+    if (buf == NULL)
+        return -1;
+
+    printf("%s\n", buf);
+    free(buf);
+    return 0;
+}
+
+int main_tmem_freeze(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *dom = NULL;
+    int all = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "a", NULL, "tmem-freeze", 0) {
+    case 'a':
+        all = 1;
+        break;
+    }
+
+    dom = argv[optind];
+    if (!dom && all == 0) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        help("tmem-freeze");
+        return 1;
+    }
+
+    if (all)
+        domid = INVALID_DOMID;
+    else
+        domid = find_domain(dom);
+
+    libxl_tmem_freeze(ctx, domid);
+    return 0;
+}
+
+int main_tmem_thaw(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *dom = NULL;
+    int all = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "a", NULL, "tmem-thaw", 0) {
+    case 'a':
+        all = 1;
+        break;
+    }
+
+    dom = argv[optind];
+    if (!dom && all == 0) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        help("tmem-thaw");
+        return 1;
+    }
+
+    if (all)
+        domid = INVALID_DOMID;
+    else
+        domid = find_domain(dom);
+
+    libxl_tmem_thaw(ctx, domid);
+    return 0;
+}
+
+int main_tmem_set(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *dom = NULL;
+    uint32_t weight = 0, cap = 0, compress = 0;
+    int opt_w = 0, opt_c = 0, opt_p = 0;
+    int all = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "aw:c:p:", NULL, "tmem-set", 0) {
+    case 'a':
+        all = 1;
+        break;
+    case 'w':
+        weight = strtol(optarg, NULL, 10);
+        opt_w = 1;
+        break;
+    case 'c':
+        cap = strtol(optarg, NULL, 10);
+        opt_c = 1;
+        break;
+    case 'p':
+        compress = strtol(optarg, NULL, 10);
+        opt_p = 1;
+        break;
+    }
+
+    dom = argv[optind];
+    if (!dom && all == 0) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        help("tmem-set");
+        return 1;
+    }
+
+    if (all)
+        domid = INVALID_DOMID;
+    else
+        domid = find_domain(dom);
+
+    if (!opt_w && !opt_c && !opt_p) {
+        fprintf(stderr, "No set value specified.\n\n");
+        help("tmem-set");
+        return 1;
+    }
+
+    if (opt_w)
+        libxl_tmem_set(ctx, domid, "weight", weight);
+    if (opt_c)
+        libxl_tmem_set(ctx, domid, "cap", cap);
+    if (opt_p)
+        libxl_tmem_set(ctx, domid, "compress", compress);
+
+    return 0;
+}
+
+int main_tmem_shared_auth(int argc, char **argv)
+{
+    uint32_t domid;
+    const char *autharg = NULL;
+    char *endptr = NULL;
+    const char *dom = NULL;
+    char *uuid = NULL;
+    int auth = -1;
+    int all = 0;
+    int opt;
+
+    SWITCH_FOREACH_OPT(opt, "au:A:", NULL, "tmem-shared-auth", 0) {
+    case 'a':
+        all = 1;
+        break;
+    case 'u':
+        uuid = optarg;
+        break;
+    case 'A':
+        autharg = optarg;
+        break;
+    }
+
+    dom = argv[optind];
+    if (!dom && all == 0) {
+        fprintf(stderr, "You must specify -a or a domain id.\n\n");
+        help("tmem-shared-auth");
+        return 1;
+    }
+
+    if (all)
+        domid = INVALID_DOMID;
+    else
+        domid = find_domain(dom);
+
+    if (uuid == NULL || autharg == NULL) {
+        fprintf(stderr, "No uuid or auth specified.\n\n");
+        help("tmem-shared-auth");
+        return 1;
+    }
+
+    auth = strtol(autharg, &endptr, 10);
+    if (*endptr != '\0') {
+        fprintf(stderr, "Invalid auth, valid auth are <0|1>.\n\n");
+        return 1;
+    }
+
+    libxl_tmem_shared_auth(ctx, domid, uuid, auth);
+
+    return 0;
+}
+
+int main_tmem_freeable(int argc, char **argv)
+{
+    int opt;
+    int mb;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "tmem-freeale", 0) {
+        /* No options */
+    }
+
+    mb = libxl_tmem_freeable(ctx);
+    if (mb == -1)
+        return -1;
+
+    printf("%d\n", mb);
+    return 0;
+}
+
+int main_cpupoolcreate(int argc, char **argv)
+{
+    const char *filename = NULL, *config_src=NULL;
+    const char *p;
+    char extra_config[1024];
+    int opt;
+    static struct option opts[] = {
+        {"defconfig", 1, 0, 'f'},
+        {"dryrun", 0, 0, 'n'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+    int ret;
+    char *config_data = 0;
+    int config_len = 0;
+    XLU_Config *config;
+    const char *buf;
+    const char *name;
+    uint32_t poolid;
+    libxl_scheduler sched = 0;
+    XLU_ConfigList *cpus;
+    XLU_ConfigList *nodes;
+    int n_cpus, n_nodes, i, n;
+    libxl_bitmap freemap;
+    libxl_bitmap cpumap;
+    libxl_uuid uuid;
+    libxl_cputopology *topology;
+    int rc = -ERROR_FAIL;
+
+    SWITCH_FOREACH_OPT(opt, "hnf:", opts, "cpupool-create", 0) {
+    case 'f':
+        filename = optarg;
+        break;
+    case 'n':
+        dryrun_only = 1;
+        break;
+    }
+
+    memset(extra_config, 0, sizeof(extra_config));
+    while (optind < argc) {
+        if ((p = strchr(argv[optind], '='))) {
+            if (strlen(extra_config) + 1 + strlen(argv[optind]) < sizeof(extra_config)) {
+                strcat(extra_config, "\n");
+                strcat(extra_config, argv[optind]);
+            }
+        } else if (!filename) {
+            filename = argv[optind];
+        } else {
+            help("cpupool-create");
+            goto out;
+        }
+        optind++;
+    }
+
+    if (filename)
+    {
+        if (libxl_read_file_contents(ctx, filename, (void **)&config_data,
+                                     &config_len)) {
+            fprintf(stderr, "Failed to read config file: %s: %s\n",
+                    filename, strerror(errno));
+            goto out;
+        }
+        config_src=filename;
+    }
+    else
+        config_src="command line";
+
+    if (strlen(extra_config)) {
+        if (config_len > INT_MAX - (strlen(extra_config) + 2)) {
+            fprintf(stderr, "Failed to attach extra configration\n");
+            goto out;
+        }
+        config_data = xrealloc(config_data,
+                               config_len + strlen(extra_config) + 2);
+        if (!config_data) {
+            fprintf(stderr, "Failed to realloc config_data\n");
+            goto out;
+        }
+        config_data[config_len] = 0;
+        strcat(config_data, extra_config);
+        strcat(config_data, "\n");
+        config_len += strlen(extra_config) + 1;
+    }
+
+    config = xlu_cfg_init(stderr, config_src);
+    if (!config) {
+        fprintf(stderr, "Failed to allocate for configuration\n");
+        goto out;
+    }
+
+    ret = xlu_cfg_readdata(config, config_data, config_len);
+    if (ret) {
+        fprintf(stderr, "Failed to parse config file: %s\n", strerror(ret));
+        goto out_cfg;
+    }
+
+    if (!xlu_cfg_get_string (config, "name", &buf, 0))
+        name = strdup(buf);
+    else if (filename)
+        name = libxl_basename(filename);
+    else {
+        fprintf(stderr, "Missing cpupool name!\n");
+        goto out_cfg;
+    }
+    if (!libxl_name_to_cpupoolid(ctx, name, &poolid)) {
+        fprintf(stderr, "Pool name \"%s\" already exists\n", name);
+        goto out_cfg;
+    }
+
+    if (!xlu_cfg_get_string (config, "sched", &buf, 0)) {
+        if ((libxl_scheduler_from_string(buf, &sched)) < 0) {
+            fprintf(stderr, "Unknown scheduler\n");
+            goto out_cfg;
+        }
+    } else {
+        if ((sched = libxl_get_scheduler(ctx)) < 0) {
+            fprintf(stderr, "get_scheduler sysctl failed.\n");
+            goto out_cfg;
+        }
+    }
+
+    if (libxl_get_freecpus(ctx, &freemap)) {
+        fprintf(stderr, "libxl_get_freecpus failed\n");
+        goto out_cfg;
+    }
+    if (libxl_cpu_bitmap_alloc(ctx, &cpumap, 0)) {
+        fprintf(stderr, "Failed to allocate cpumap\n");
+        goto out_cfg;
+    }
+    if (!xlu_cfg_get_list(config, "nodes", &nodes, 0, 0)) {
+        int nr;
+        n_cpus = 0;
+        n_nodes = 0;
+        topology = libxl_get_cpu_topology(ctx, &nr);
+        if (topology == NULL) {
+            fprintf(stderr, "libxl_get_topologyinfo failed\n");
+            goto out_cfg;
+        }
+        while ((buf = xlu_cfg_get_listitem(nodes, n_nodes)) != NULL) {
+            n = atoi(buf);
+            for (i = 0; i < nr; i++) {
+                if ((topology[i].node == n) &&
+                    libxl_bitmap_test(&freemap, i)) {
+                    libxl_bitmap_set(&cpumap, i);
+                    n_cpus++;
+                }
+            }
+            n_nodes++;
+        }
+
+        libxl_cputopology_list_free(topology, nr);
+
+        if (n_cpus == 0) {
+            fprintf(stderr, "no free cpu found\n");
+            goto out_cfg;
+        }
+    } else if (!xlu_cfg_get_list(config, "cpus", &cpus, 0, 0)) {
+        n_cpus = 0;
+        while ((buf = xlu_cfg_get_listitem(cpus, n_cpus)) != NULL) {
+            i = atoi(buf);
+            if ((i < 0) || (i >= freemap.size * 8) ||
+                !libxl_bitmap_test(&freemap, i)) {
+                fprintf(stderr, "cpu %d illegal or not free\n", i);
+                goto out_cfg;
+            }
+            libxl_bitmap_set(&cpumap, i);
+            n_cpus++;
+        }
+    } else
+        n_cpus = 0;
+
+    libxl_uuid_generate(&uuid);
+
+    printf("Using config file \"%s\"\n", config_src);
+    printf("cpupool name:   %s\n", name);
+    printf("scheduler:      %s\n", libxl_scheduler_to_string(sched));
+    printf("number of cpus: %d\n", n_cpus);
+
+    if (!dryrun_only) {
+        poolid = 0;
+        if (libxl_cpupool_create(ctx, name, sched, cpumap, &uuid, &poolid)) {
+            fprintf(stderr, "error on creating cpupool\n");
+            goto out_cfg;
+        }
+    }
+    /* We made it! */
+    rc = 0;
+   
+out_cfg:
+    xlu_cfg_destroy(config);
+out:
+    return rc;
+}
+
+int main_cpupoollist(int argc, char **argv)
+{
+    int opt;
+    static struct option opts[] = {
+        {"cpus", 0, 0, 'c'},
+        COMMON_LONG_OPTS,
+        {0, 0, 0, 0}
+    };
+    int opt_cpus = 0;
+    const char *pool = NULL;
+    libxl_cpupoolinfo *poolinfo;
+    int n_pools, p, c, n;
+    uint32_t poolid;
+    char *name;
+    int ret = 0;
+
+    SWITCH_FOREACH_OPT(opt, "hc", opts, "cpupool-list", 1) {
+    case 'c':
+        opt_cpus = 1;
+        break;
+    }
+
+    if (optind < argc) {
+        pool = argv[optind];
+        if (libxl_name_to_cpupoolid(ctx, pool, &poolid)) {
+            fprintf(stderr, "Pool \'%s\' does not exist\n", pool);
+            return -ERROR_FAIL;
+        }
+    }
+
+    poolinfo = libxl_list_cpupool(ctx, &n_pools);
+    if (!poolinfo) {
+        fprintf(stderr, "error getting cpupool info\n");
+        return -ERROR_NOMEM;
+    }
+
+    printf("%-19s", "Name");
+    if (opt_cpus)
+        printf("CPU list\n");
+    else
+        printf("CPUs   Sched     Active   Domain count\n");
+
+    for (p = 0; p < n_pools; p++) {
+        if (!ret && (!pool || (poolinfo[p].poolid == poolid))) {
+            name = libxl_cpupoolid_to_name(ctx, poolinfo[p].poolid);
+            if (!name) {
+                fprintf(stderr, "error getting cpupool info\n");
+                ret = -ERROR_NOMEM;
+            } else {
+                printf("%-19s", name);
+                free(name);
+                n = 0;
+                libxl_for_each_bit(c, poolinfo[p].cpumap)
+                    if (libxl_bitmap_test(&poolinfo[p].cpumap, c)) {
+                        if (n && opt_cpus) printf(",");
+                        if (opt_cpus) printf("%d", c);
+                        n++;
+                    }
+                if (!opt_cpus) {
+                    printf("%3d %9s       y       %4d", n,
+                           libxl_scheduler_to_string(poolinfo[p].sched),
+                           poolinfo[p].n_dom);
+                }
+                printf("\n");
+            }
+        }
+    }
+
+    libxl_cpupoolinfo_list_free(poolinfo, n_pools);
+
+    return ret;
+}
+
+int main_cpupooldestroy(int argc, char **argv)
+{
+    int opt;
+    const char *pool;
+    uint32_t poolid;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-destroy", 1) {
+        /* No options */
+    }
+
+    pool = argv[optind];
+
+    if (cpupool_qualifier_to_cpupoolid(pool, &poolid, NULL) ||
+        !libxl_cpupoolid_is_valid(ctx, poolid)) {
+        fprintf(stderr, "unknown cpupool \'%s\'\n", pool);
+        return -ERROR_FAIL;
+    }
+
+    return -libxl_cpupool_destroy(ctx, poolid);
+}
+
+int main_cpupoolrename(int argc, char **argv)
+{
+    int opt;
+    const char *pool;
+    const char *new_name;
+    uint32_t poolid;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-rename", 2) {
+        /* No options */
+    }
+
+    pool = argv[optind++];
+
+    if (cpupool_qualifier_to_cpupoolid(pool, &poolid, NULL) ||
+        !libxl_cpupoolid_is_valid(ctx, poolid)) {
+        fprintf(stderr, "unknown cpupool \'%s\'\n", pool);
+        return -ERROR_FAIL;
+    }
+
+    new_name = argv[optind];
+
+    if (libxl_cpupool_rename(ctx, new_name, poolid)) {
+        fprintf(stderr, "Can't rename cpupool '%s'.\n", pool);
+        return 1;
+    }
+
+    return 0;
+}
+
+int main_cpupoolcpuadd(int argc, char **argv)
+{
+    int opt;
+    const char *pool;
+    uint32_t poolid;
+    int cpu;
+    int node;
+    int n;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-cpu-add", 2) {
+        /* No options */
+    }
+
+    pool = argv[optind++];
+    node = -1;
+    cpu = -1;
+    if (strncmp(argv[optind], "node:", 5) == 0) {
+        node = atoi(argv[optind] + 5);
+    } else {
+        cpu = atoi(argv[optind]);
+    }
+
+    if (cpupool_qualifier_to_cpupoolid(pool, &poolid, NULL) ||
+        !libxl_cpupoolid_is_valid(ctx, poolid)) {
+        fprintf(stderr, "unknown cpupool \'%s\'\n", pool);
+        return -ERROR_FAIL;
+    }
+
+    if (cpu >= 0) {
+        return -libxl_cpupool_cpuadd(ctx, poolid, cpu);
+    }
+
+    if (libxl_cpupool_cpuadd_node(ctx, poolid, node, &n)) {
+        fprintf(stderr, "libxl_cpupool_cpuadd_node failed\n");
+        return -ERROR_FAIL;
+    }
+
+    if (n > 0) {
+        return 0;
+    }
+
+    fprintf(stderr, "no free cpu found\n");
+    return -ERROR_FAIL;
+}
+
+int main_cpupoolcpuremove(int argc, char **argv)
+{
+    int opt;
+    const char *pool;
+    uint32_t poolid;
+    int cpu;
+    int node;
+    int n;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-cpu-remove", 2) {
+        /* No options */
+    }
+
+    pool = argv[optind++];
+    node = -1;
+    cpu = -1;
+    if (strncmp(argv[optind], "node:", 5) == 0) {
+        node = atoi(argv[optind] + 5);
+    } else {
+        cpu = atoi(argv[optind]);
+    }
+
+    if (cpupool_qualifier_to_cpupoolid(pool, &poolid, NULL) ||
+        !libxl_cpupoolid_is_valid(ctx, poolid)) {
+        fprintf(stderr, "unknown cpupool \'%s\'\n", pool);
+        return -ERROR_FAIL;
+    }
+
+    if (cpu >= 0) {
+        return -libxl_cpupool_cpuremove(ctx, poolid, cpu);
+    }
+
+    if (libxl_cpupool_cpuremove_node(ctx, poolid, node, &n)) {
+        fprintf(stderr, "libxl_cpupool_cpuremove_node failed\n");
+        return -ERROR_FAIL;
+    }
+
+    if (n == 0) {
+        fprintf(stderr, "no cpu of node found in cpupool\n");
+        return -ERROR_FAIL;
+    }
+
+    return 0;
+}
+
+int main_cpupoolmigrate(int argc, char **argv)
+{
+    int opt;
+    const char *pool;
+    uint32_t poolid;
+    const char *dom;
+    uint32_t domid;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-migrate", 2) {
+        /* No options */
+    }
+
+    dom = argv[optind++];
+    pool = argv[optind];
+
+    if (domain_qualifier_to_domid(dom, &domid, NULL) ||
+        !libxl_domid_to_name(ctx, domid)) {
+        fprintf(stderr, "unknown domain \'%s\'\n", dom);
+        return -ERROR_FAIL;
+    }
+
+    if (cpupool_qualifier_to_cpupoolid(pool, &poolid, NULL) ||
+        !libxl_cpupoolid_is_valid(ctx, poolid)) {
+        fprintf(stderr, "unknown cpupool \'%s\'\n", pool);
+        return -ERROR_FAIL;
+    }
+
+    return -libxl_cpupool_movedomain(ctx, poolid, domid);
+}
+
+int main_cpupoolnumasplit(int argc, char **argv)
+{
+    int ret;
+    int opt;
+    int p;
+    int c;
+    int n;
+    uint32_t poolid;
+    libxl_scheduler sched;
+    int n_pools;
+    int node;
+    int n_cpus;
+    char name[16];
+    libxl_uuid uuid;
+    libxl_bitmap cpumap;
+    libxl_cpupoolinfo *poolinfo;
+    libxl_cputopology *topology;
+    libxl_dominfo info;
+
+    SWITCH_FOREACH_OPT(opt, "", NULL, "cpupool-numa-split", 0) {
+        /* No options */
+    }
+
+    ret = 0;
+
+    poolinfo = libxl_list_cpupool(ctx, &n_pools);
+    if (!poolinfo) {
+        fprintf(stderr, "error getting cpupool info\n");
+        return -ERROR_NOMEM;
+    }
+    poolid = poolinfo[0].poolid;
+    sched = poolinfo[0].sched;
+    for (p = 0; p < n_pools; p++) {
+        libxl_cpupoolinfo_dispose(poolinfo + p);
+    }
+    if (n_pools > 1) {
+        fprintf(stderr, "splitting not possible, already cpupools in use\n");
+        return -ERROR_FAIL;
+    }
+
+    topology = libxl_get_cpu_topology(ctx, &n_cpus);
+    if (topology == NULL) {
+        fprintf(stderr, "libxl_get_topologyinfo failed\n");
+        return -ERROR_FAIL;
+    }
+
+    if (libxl_cpu_bitmap_alloc(ctx, &cpumap, 0)) {
+        fprintf(stderr, "Failed to allocate cpumap\n");
+        libxl_cputopology_list_free(topology, n_cpus);
+        return -ERROR_FAIL;
+    }
+
+    /* Reset Pool-0 to 1st node: first add cpus, then remove cpus to avoid
+       a cpupool without cpus in between */
+
+    node = topology[0].node;
+    if (libxl_cpupool_cpuadd_node(ctx, 0, node, &n)) {
+        fprintf(stderr, "error on adding cpu to Pool 0\n");
+        return -ERROR_FAIL;
+    }
+
+    snprintf(name, 15, "Pool-node%d", node);
+    ret = -libxl_cpupool_rename(ctx, name, 0);
+    if (ret) {
+        fprintf(stderr, "error on renaming Pool 0\n");
+        goto out;
+    }
+
+    n = 0;
+    for (c = 0; c < n_cpus; c++) {
+        if (topology[c].node == node) {
+            topology[c].node = LIBXL_CPUTOPOLOGY_INVALID_ENTRY;
+            libxl_bitmap_set(&cpumap, n);
+            n++;
+        }
+    }
+    if (libxl_set_vcpuonline(ctx, 0, &cpumap)) {
+        fprintf(stderr, "error on removing vcpus for Domain-0\n");
+        goto out;
+    }
+    for (c = 0; c < 10; c++) {
+        if (libxl_domain_info(ctx, &info, 0)) {
+            fprintf(stderr, "error on getting info for Domain-0\n");
+            goto out;
+        }
+        if (info.vcpu_online == n) {
+            break;
+        }
+        sleep(1);
+    }
+    if (info.vcpu_online > n) {
+        fprintf(stderr, "failed to offline vcpus\n");
+        goto out;
+    }
+    libxl_bitmap_set_none(&cpumap);
+
+    for (c = 0; c < n_cpus; c++) {
+        if (topology[c].node == LIBXL_CPUTOPOLOGY_INVALID_ENTRY) {
+            continue;
+        }
+
+        node = topology[c].node;
+        ret = -libxl_cpupool_cpuremove_node(ctx, 0, node, &n);
+        if (ret) {
+            fprintf(stderr, "error on removing cpu from Pool 0\n");
+            goto out;
+        }
+
+        snprintf(name, 15, "Pool-node%d", node);
+        libxl_uuid_generate(&uuid);
+        poolid = 0;
+        ret = -libxl_cpupool_create(ctx, name, sched, cpumap, &uuid, &poolid);
+        if (ret) {
+            fprintf(stderr, "error on creating cpupool\n");
+            goto out;
+        }
+
+        ret = -libxl_cpupool_cpuadd_node(ctx, poolid, node, &n);
+        if (ret) {
+            fprintf(stderr, "error on adding cpus to cpupool\n");
+            goto out;
+        }
+
+        for (p = c; p < n_cpus; p++) {
+            if (topology[p].node == node) {
+                topology[p].node = LIBXL_CPUTOPOLOGY_INVALID_ENTRY;
+            }
+        }
+    }
+
+out:
+    libxl_cputopology_list_free(topology, n_cpus);
+    libxl_bitmap_dispose(&cpumap);
+
+    return ret;
+}
+
+int main_getenforce(int argc, char **argv)
+{
+    int ret;
+
+    ret = libxl_flask_getenforce(ctx);
+
+    if (ret < 0) {
+        if (errno == ENOSYS)
+            printf("Flask XSM Disabled\n");
+        else
+            fprintf(stderr, "Failed to get enforcing mode\n");
+    }
+    else if (ret == 1)
+        printf("Enforcing\n");
+    else if (ret == 0)
+        printf("Permissive\n");
+
+    return ret;
+}
+
+int main_setenforce(int argc, char **argv)
+{
+    int ret, mode = -1;
+    const char *p = NULL;
+
+    if (optind >= argc) {
+        help("setenforce");
+        return 2;
+    }
+
+    p = argv[optind];
+
+    if (!strcmp(p, "0"))
+        mode = 0;
+    else if (!strcmp(p, "1"))
+        mode = 1;
+    else if (!strcasecmp(p, "permissive"))
+        mode = 0;
+    else if (!strcasecmp(p, "enforcing"))
+        mode = 1;
+    else {
+        help("setenforce");
+        return 2;
+    }
+
+    ret = libxl_flask_setenforce(ctx, mode);
+
+    if (ret) {
+        if (errno == ENOSYS) {
+            fprintf(stderr, "Flask XSM disabled\n");
+        }
+        else
+            fprintf(stderr, "error occured while setting enforcing mode (%i)\n", ret);
+    }
+
+    return ret;
+}
+
+int main_loadpolicy(int argc, char **argv)
+{
+    const char *polFName;
+    int polFd = 0;
+    void *polMemCp = NULL;
+    struct stat info;
+    int ret;
+
+    if (optind >= argc) {
+        help("loadpolicy");
+        return 2;
+    }
+
+    polFName = argv[optind];
+    polFd = open(polFName, O_RDONLY);
+    if ( polFd < 0 ) {
+        fprintf(stderr, "Error occurred opening policy file '%s': %s\n",
+                polFName, strerror(errno));
+        ret = -1;
+        goto done;
+    }
+
+    ret = stat(polFName, &info);
+    if ( ret < 0 ) {
+        fprintf(stderr, "Error occurred retrieving information about"
+                "policy file '%s': %s\n", polFName, strerror(errno));
+        goto done;
+    }
+
+    polMemCp = malloc(info.st_size);
+
+    ret = read(polFd, polMemCp, info.st_size);
+    if ( ret < 0 ) {
+        fprintf(stderr, "Unable to read new Flask policy file: %s\n",
+                strerror(errno));
+        goto done;
+    }
+
+    ret = libxl_flask_loadpolicy(ctx, polMemCp, info.st_size);
+
+    if (ret < 0) {
+        if (errno == ENOSYS) {
+            fprintf(stderr, "Flask XSM disabled\n");
+        } else {
+            errno = -ret;
+            fprintf(stderr, "Unable to load new Flask policy: %s\n",
+                    strerror(errno));
+            ret = -1;
+        }
+    } else {
+        printf("Successfully loaded policy.\n");
+    }
+
+done:
+    free(polMemCp);
+    if ( polFd > 0 )
+        close(polFd);
+
+    return ret;
+}
+
+int main_remus(int argc, char **argv)
+{
+    uint32_t domid;
+    int opt, rc, daemonize = 1;
+    const char *ssh_command = "ssh";
+    char *host = NULL, *rune = NULL;
+    libxl_domain_remus_info r_info;
+    int send_fd = -1, recv_fd = -1;
+    pid_t child = -1;
+    uint8_t *config_data;
+    int config_len;
+
+    memset(&r_info, 0, sizeof(libxl_domain_remus_info));
+    /* Defaults */
+    r_info.interval = 200;
+    r_info.blackhole = 0;
+    r_info.compression = 1;
+
+    SWITCH_FOREACH_OPT(opt, "bui:s:e", NULL, "remus", 2) {
+    case 'i':
+        r_info.interval = atoi(optarg);
+        break;
+    case 'b':
+        r_info.blackhole = 1;
+        break;
+    case 'u':
+        r_info.compression = 0;
+        break;
+    case 's':
+        ssh_command = optarg;
+        break;
+    case 'e':
+        daemonize = 0;
+        break;
+    }
+
+    domid = find_domain(argv[optind]);
+    host = argv[optind + 1];
+
+    if (r_info.blackhole) {
+        send_fd = open("/dev/null", O_RDWR, 0644);
+        if (send_fd < 0) {
+            perror("failed to open /dev/null");
+            exit(-1);
+        }
+    } else {
+
+        if (!ssh_command[0]) {
+            rune = host;
+        } else {
+            if (asprintf(&rune, "exec %s %s xl migrate-receive -r %s",
+                         ssh_command, host,
+                         daemonize ? "" : " -e") < 0)
+                return 1;
+        }
+
+        save_domain_core_begin(domid, NULL, &config_data, &config_len);
+
+        if (!config_len) {
+            fprintf(stderr, "No config file stored for running domain and "
+                    "none supplied - cannot start remus.\n");
+            exit(1);
+        }
+
+        child = create_migration_child(rune, &send_fd, &recv_fd);
+
+        migrate_do_preamble(send_fd, recv_fd, child, config_data, config_len,
+                            rune);
+    }
+
+    /* Point of no return */
+    rc = libxl_domain_remus_start(ctx, &r_info, domid, send_fd, recv_fd, 0);
+
+    /* If we are here, it means backup has failed/domain suspend failed.
+     * Try to resume the domain and exit gracefully.
+     * TODO: Split-Brain check.
+     */
+    fprintf(stderr, "remus sender: libxl_domain_suspend failed"
+            " (rc=%d)\n", rc);
+
+    if (rc == ERROR_GUEST_TIMEDOUT)
+        fprintf(stderr, "Failed to suspend domain at primary.\n");
+    else {
+        fprintf(stderr, "Remus: Backup failed? resuming domain at primary.\n");
+        libxl_domain_resume(ctx, domid, 1, 0);
+    }
+
+    close(send_fd);
+    return -ERROR_FAIL;
+}
+
+/*
+ * Local variables:
+ * mode: C
+ * c-basic-offset: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -Naur xen/tools/misc/serial-split/Makefile xen-b/tools/misc/serial-split/Makefile
--- xen/tools/misc/serial-split/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/misc/serial-split/Makefile	2013-03-16 22:46:21.173178611 -0600
@@ -0,0 +1,20 @@
+CC     ?= gcc
+CFLAGS ?= -Wall -Os
+CFILES = $(wildcard *.c)
+OBJS   = $(patsubst %.c,%.o,$(wildcard *.c))
+TARGET = serial-split
+
+all: $(TARGET)
+
+install: all
+	install -d $(DESTDIR)/usr/bin
+	install -s $(TARGET) $(DESTDIR)/usr/bin/
+
+clean:
+	rm *.o $(TARGET) *~
+
+$(TARGET): $(OBJS)
+	$(CC) $(CFLAGS) -o $@ $^
+
+%.o: %.c Makefile
+	$(CC) $(CFLAGS) -c -o $@ $<
diff -Naur xen/tools/misc/serial-split/serial-split.c xen-b/tools/misc/serial-split/serial-split.c
--- xen/tools/misc/serial-split/serial-split.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/tools/misc/serial-split/serial-split.c	2013-03-16 22:46:21.173178611 -0600
@@ -0,0 +1,422 @@
+/*
+ *  serial-split.c
+ *  pdb / console splitter
+ *
+ *  Copyright 2005 Charles Coffing <ccoffing@novell.com>
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ */
+
+/*
+ *  Typical setup:
+ *
+ *               Development box          Xen box
+ *                      ...-----+        +-----...
+ *  +---------+                 |        |
+ *  | gdb     |                 |        |
+ *  |         |\ high           |        |
+ *  +---------+ \               |        |
+ *               \+-----------+ | serial | +------------------+
+ *                |  splitter |------------| Xen              |
+ *               /+-----------+ |        | |  - pdb    (com1H)|
+ *  +---------+ /               |        | |  - printk (com1) |
+ *  | console |/ low            |        | +------------------+
+ *  | viewer  |                 |        |
+ *  +---------+                 |        |
+ *                      ...-----+        +-----...
+ */
+
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <termios.h>
+#include <sys/signal.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+
+const unsigned int DefaultLowPort = 12010;
+const unsigned int DefaultBaud = 115200;
+const char DefaultSerialDevice[] = "/dev/ttyS0";
+
+#define DEBUG 0
+#define MAX(a,b) ((a)<(b)?(b):(a))
+
+
+static int cook_baud(int baud)
+{
+    int cooked_baud = 0;
+    switch (baud)
+    {
+    case     50: cooked_baud =     B50; break;
+    case     75: cooked_baud =     B75; break;
+    case    110: cooked_baud =    B110; break;
+    case    134: cooked_baud =    B134; break;
+    case    150: cooked_baud =    B150; break;
+    case    200: cooked_baud =    B200; break;
+    case    300: cooked_baud =    B300; break;
+    case    600: cooked_baud =    B600; break;
+    case   1200: cooked_baud =   B1200; break;
+    case   1800: cooked_baud =   B1800; break;
+    case   2400: cooked_baud =   B2400; break;
+    case   4800: cooked_baud =   B4800; break;
+    case   9600: cooked_baud =   B9600; break;
+    case  19200: cooked_baud =  B19200; break;
+    case  38400: cooked_baud =  B38400; break;
+    case  57600: cooked_baud =  B57600; break;
+    case 115200: cooked_baud = B115200; break;
+    }
+    return cooked_baud;
+}
+
+
+static int start_listener(unsigned short port)
+{
+    int fd;
+    struct sockaddr_in sin;
+    int on = 1;
+
+    if ((fd = socket (AF_INET, SOCK_STREAM, 0)) < 0)
+    {
+        perror("socket");
+        goto out1;
+    }
+
+    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on));
+
+    memset(&sin, 0, sizeof(sin));
+    sin.sin_family = AF_INET;
+    sin.sin_port = htons (port);
+    sin.sin_addr.s_addr = INADDR_ANY;
+    if (bind(fd, (struct sockaddr *)&sin, sizeof(sin)) < 0)
+    {
+        perror("bind");
+        goto out2;
+    }
+
+    if (listen(fd, 1) < 0)
+    {
+        perror("listen");
+        goto out2;
+    }
+
+    fprintf(stderr, "Listening on port %d\n", port);
+
+    return fd;
+
+out2:
+    close(fd);
+out1:
+    return -1;
+}
+
+
+static int accept_conn(int fd)
+{
+    int on = 1;
+    int new_fd;
+    struct sockaddr_in from;
+    socklen_t fromlen = sizeof(from);
+
+    new_fd = accept(fd, (struct sockaddr *)&from, &fromlen);
+    if (new_fd < 0)
+        perror("accept");
+    ioctl(new_fd, FIONBIO, &on);
+
+    fprintf(stderr, "Accepted connection on %d\n", new_fd);
+
+    return new_fd;
+}
+
+
+static void close_conn(int * fd)
+{
+    shutdown(*fd, 2);
+    close(*fd);
+    *fd = -1;
+}
+
+
+static int receive_data(int * fd, char * buf, ssize_t max_bytes, int * poll)
+{
+    ssize_t bytes;
+    if ((bytes = read(*fd, buf, max_bytes)) < 0)
+    {
+        perror("read");
+        *poll = 1;
+        return 0;
+    }
+    else if (bytes == 0)
+    {
+        close_conn(fd);
+        *poll = 0;
+        return 0;
+    }
+    else
+    {
+        if (bytes == max_bytes)
+            *poll = 1;
+        else
+            *poll = 0;
+#if DEBUG
+        {
+            ssize_t i;
+            fprintf(stderr, "Received %d bytes on %d:\n", bytes, *fd);
+            for (i = 0; i < bytes; ++ i)
+            {
+                if ((i & 0xf) == 0)
+                    printf("    ");
+                printf("%02x", buf[i] & 0xff);
+                if (((i+1) & 0xf) == 0 || i + 1 == bytes)
+                    printf("\n");
+                else
+                    printf(" ");
+            }
+        }
+#endif
+        return bytes;
+    }
+}
+
+
+static void set_high_bit(char * buf, size_t bytes)
+{
+    size_t i;
+    for(i = 0; i < bytes; ++ i)
+        buf[i] |= 0x80;
+}
+
+
+static void clear_high_bit(char * buf, size_t bytes)
+{
+    size_t i;
+    for(i = 0; i < bytes; ++ i)
+        buf[i] &= 0x7f;
+}
+
+
+static int open_serial(char const * serial_dev, int baud)
+{
+    struct termios newsertio;
+    int serial_fd;
+    memset(&newsertio, 0, sizeof(newsertio));
+
+    if ((serial_fd = open(serial_dev, O_RDWR | O_NOCTTY | O_NONBLOCK)) < 0)
+    {
+        perror(serial_dev);
+        return -1;
+    }
+
+    newsertio.c_cflag = baud | CS8 | CLOCAL | CREAD;
+    newsertio.c_iflag = IGNBRK | IGNPAR;    /* raw input */
+    newsertio.c_oflag = 0;                  /* raw output */
+    newsertio.c_lflag = 0;                  /* no echo, no signals */
+    newsertio.c_cc[VMIN] = 1;
+    newsertio.c_cc[VTIME] = 0;
+    tcflush(serial_fd, TCIFLUSH);
+    tcsetattr(serial_fd, TCSANOW, &newsertio);
+
+    fprintf(stderr, "Listening on %s\n", serial_dev);
+
+    return serial_fd;
+}
+
+
+static void main_loop(int serial_fd, int low_listener, int high_listener)
+{
+    fd_set rdfds;
+    int low_poll = 0, high_poll = 0, serial_poll = 0;
+    int low_fd = -1, high_fd = -1;
+
+    while(1)
+    {
+        char buf[1024];
+        ssize_t bytes;
+        int max;
+
+        FD_ZERO(&rdfds);
+        FD_SET(low_fd < 0 ? low_listener : low_fd, &rdfds);
+        FD_SET(high_fd < 0 ? high_listener : high_fd, &rdfds);
+        FD_SET(serial_fd, &rdfds);
+
+        max = MAX(low_fd, low_listener);
+        max = MAX(max, high_fd);
+        max = MAX(max, high_listener);
+        max = MAX(max, serial_fd);
+
+        if (select(max + 1, &rdfds, NULL, NULL, NULL) < 0)
+        {
+            perror("select");
+            continue;
+        }
+
+        if (FD_ISSET(low_listener, &rdfds))
+        {
+            assert(low_fd < 0);
+            low_fd = accept_conn(low_listener);
+        }
+
+        if (FD_ISSET(high_listener, &rdfds))
+        {
+            assert(high_fd < 0);
+            high_fd = accept_conn(high_listener);
+        }
+
+        if (low_poll || (low_fd >= 0 && FD_ISSET(low_fd, &rdfds)))
+        {
+            if ((bytes = receive_data(&low_fd, &buf[0], sizeof(buf),
+                                      &low_poll)) > 0)
+            {
+                clear_high_bit(&buf[0], bytes);
+                if (write(serial_fd, &buf[0], bytes) < 0)
+                    perror("write");
+            }
+        }
+
+        if (high_poll || (high_fd >= 0 && FD_ISSET(high_fd, &rdfds)))
+        {
+            if ((bytes = receive_data(&high_fd, &buf[0], sizeof(buf),
+                                      &high_poll)) > 0)
+            {
+                set_high_bit(&buf[0], bytes);
+                if (write(serial_fd, &buf[0], bytes) < 0)
+                    perror("write");
+            }
+        }
+
+        if (serial_poll || FD_ISSET(serial_fd, &rdfds))
+        {
+            if ((bytes = receive_data(&serial_fd, &buf[0], sizeof(buf),
+                                      &serial_poll)) > 0)
+            {
+                ssize_t i;
+                for (i = 0; i < bytes; ++ i)
+                {
+                    if (buf[i] & 0x80)
+                    {
+                        if (high_fd >= 0)
+                        {
+                            buf[i] &= 0x7f;
+                            if ((write(high_fd, &buf[i], 1)) < 0)
+                            {
+                                perror("write");
+                                close_conn(&high_fd);
+                                high_poll = 0;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (low_fd >= 0)
+                        {
+                            if ((write(low_fd, &buf[i], 1)) < 0)
+                            {
+                                perror("write");
+                                close_conn(&low_fd);
+                                low_poll = 0;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+static void usage()
+{
+    printf(
+"Description:\n"
+"        Splits the serial port between two TCP ports.  Bytes read from the\n"
+"        serial port will be delivered to one of the two TCP ports (high or\n"
+"        low) depending on whether the high bit is set.  Bytes written to the\n"
+"        TCP ports will be forwarded to the serial port; the high bit will be\n"
+"        set or cleared to denote the source.\n"
+"Usage:\n"
+"        serial-split [-d<serial-device>] [-b<baud>]\n"
+"                     [-l<low-port>] [-h<high-port>]\n"
+"Parameters:\n"
+"        -d<serial-device>  Defaults to %s.\n"
+"        -b<baud>           Baud rate of the serial port.  Defaults to %d.\n"
+"                           Also assumes 8N1.\n"
+"        -l<low-port>       Low TCP port.  Defaults to %d, or one less than\n"
+"                           the high port.\n"
+"        -h<high-port>      High TCP port.  Defaults to %d, or one more than\n"
+"                           the low port.\n",
+DefaultSerialDevice, DefaultBaud, DefaultLowPort, DefaultLowPort + 1);
+
+    exit(1);
+}
+
+
+int main(int argc, char **argv)
+{
+    int cooked_baud = cook_baud(DefaultBaud);
+    char const * serial_dev = DefaultSerialDevice;
+    int low_port = -1, high_port = -1;
+    int serial_fd, low_listener, high_listener;
+
+    while ( --argc != 0 )
+    {
+        char *p = argv[argc];
+        if ( *(p++) != '-' )
+            usage();
+        switch (*(p++))
+        {
+        case 'b':
+            if ( (cooked_baud = cook_baud(atoi(p))) == 0 )
+            {
+                fprintf(stderr, "Bad baud rate\n");
+                exit(1);
+            }
+            break;
+        case 'd':
+            serial_dev = p;
+            break;
+        case 'l':
+            if ((low_port = atoi(p)) <= 0)
+                usage();
+            break;
+        case 'h':
+            if ((high_port = atoi(p)) <= 0)
+                usage();
+            break;
+        default:
+            usage();
+        }
+    }
+
+    if (low_port == -1 && high_port == -1)
+        low_port = DefaultLowPort;
+    if (low_port == -1)
+        low_port = high_port - 1;
+    if (high_port == -1)
+        high_port = low_port + 1;
+
+    if ((serial_fd = open_serial(serial_dev, cooked_baud)) < 0 ||
+        (low_listener = start_listener(low_port)) < 0 ||
+        (high_listener = start_listener(high_port)) < 0)
+        exit(1);
+
+    main_loop(serial_fd, low_listener, high_listener);
+
+    return 0;
+}
+
diff -Naur xen/tools/misc/xend xen-b/tools/misc/xend
--- xen/tools/misc/xend	2013-03-09 18:06:26.053178611 -0700
+++ xen-b/tools/misc/xend	2013-03-16 22:46:21.173178611 -0600
@@ -1,4 +1,4 @@
-#!/usr/bin/env python
+#!/usr/bin/python -Es
 #  -*- mode: python; -*-
 #============================================================================
 # Copyright (C) 2004 Mike Wray <mike.wray@hp.com>
diff -Naur xen/tools/misc/xenpvnetboot xen-b/tools/misc/xenpvnetboot
--- xen/tools/misc/xenpvnetboot	2013-03-09 18:06:26.053178611 -0700
+++ xen-b/tools/misc/xenpvnetboot	2013-03-16 22:46:21.173178611 -0600
@@ -194,7 +194,7 @@
                       help='Arguments pass to the kernel.')
     parser.add_option('', '--output',
                       help='Redirect output to this file instead of stdout.')
-    parser.add_option('', '--output-directory', default='/var/run/libxl',
+    parser.add_option('', '--output-directory', default='/run/libxl',
                       help='Output directory.')
     parser.add_option('', '--output-format', default='sxp',
                       help='Output format: sxp, simple or simple0.')
diff -Naur xen/tools/ocaml/libs/xs/xs.ml xen-b/tools/ocaml/libs/xs/xs.ml
--- xen/tools/ocaml/libs/xs/xs.ml	2013-03-09 18:06:26.066511944 -0700
+++ xen-b/tools/ocaml/libs/xs/xs.ml	2013-03-16 22:46:21.173178611 -0600
@@ -147,7 +147,7 @@
 	end;
 	unwatch ()
 
-let daemon_socket = "/var/run/xenstored/socket"
+let daemon_socket = "/run/xenstored/socket"
 
 (** Throws this rather than a miscellaneous Unix.connect failed *)
 exception Failed_to_connect
diff -Naur xen/tools/ocaml/xenstored/define.ml xen-b/tools/ocaml/xenstored/define.ml
--- xen/tools/ocaml/xenstored/define.ml	2013-03-09 18:06:26.066511944 -0700
+++ xen-b/tools/ocaml/xenstored/define.ml	2013-03-16 22:46:21.173178611 -0600
@@ -20,8 +20,8 @@
 let xenstored_proc_kva = "/proc/xen/xsd_kva"
 let xenstored_proc_port = "/proc/xen/xsd_port"
 
-let xs_daemon_socket = "/var/run/xenstored/socket"
-let xs_daemon_socket_ro = "/var/run/xenstored/socket_ro"
+let xs_daemon_socket = "/run/xenstored/socket"
+let xs_daemon_socket_ro = "/run/xenstored/socket_ro"
 
 let default_config_dir = "/etc/xen"
 
diff -Naur xen/tools/ocaml/xenstored/disk.ml xen-b/tools/ocaml/xenstored/disk.ml
--- xen/tools/ocaml/xenstored/disk.ml	2013-03-09 18:06:26.066511944 -0700
+++ xen-b/tools/ocaml/xenstored/disk.ml	2013-03-16 22:46:21.173178611 -0600
@@ -15,7 +15,7 @@
  *)
 
 let enable = ref false
-let xs_daemon_database = "/var/run/xenstored/db"
+let xs_daemon_database = "/run/xenstored/db"
 
 let error fmt = Logging.error "disk" fmt
 
diff -Naur xen/tools/ocaml/xenstored/oxenstored.conf xen-b/tools/ocaml/xenstored/oxenstored.conf
--- xen/tools/ocaml/xenstored/oxenstored.conf	2013-03-09 18:06:26.066511944 -0700
+++ xen-b/tools/ocaml/xenstored/oxenstored.conf	2013-03-16 22:46:21.176511944 -0600
@@ -1,7 +1,7 @@
 # default xenstored config
 
 # Where the pid file is stored
-pid-file = /var/run/xenstored.pid
+pid-file = /run/xenstored.pid
 
 # Randomly failed a transaction with EAGAIN. Used for testing Xs user
 test-eagain = false
diff -Naur xen/tools/ocaml/xenstored/xenstored.ml xen-b/tools/ocaml/xenstored/xenstored.ml
--- xen/tools/ocaml/xenstored/xenstored.ml	2013-03-09 18:06:26.069845278 -0700
+++ xen-b/tools/ocaml/xenstored/xenstored.ml	2013-03-16 22:46:21.176511944 -0600
@@ -58,7 +58,7 @@
 let sigusr1_handler store =
 	try
 		let channel = open_out_gen [ Open_wronly; Open_creat; Open_trunc; ]
-		                           0o600 "/var/run/xenstored/db.debug" in
+		                           0o600 "/run/daemonsxenstored/db.debug" in
 		finally (fun () -> Store.dump store channel)
 			(fun () -> close_out channel)
 	with _ ->
@@ -73,7 +73,7 @@
 	| Some name -> name
 	| None      -> Define.default_config_dir ^ "/oxenstored.conf"
 
-let default_pidfile = "/var/run/xenstored.pid"
+let default_pidfile = "/run/xenstored.pid"
 
 let parse_config filename =
 	let pidfile = ref default_pidfile in
@@ -254,7 +254,7 @@
 	let quit = ref false in
 
 	if cf.restart then (
-		DB.from_file store domains cons "/var/run/xenstored/db";
+		DB.from_file store domains cons "/run/xenstored/db";
 		Event.bind_dom_exc_virq eventchn
 	) else (
 		if !Disk.enable then (
@@ -280,7 +280,7 @@
 
 	Logging.init_xenstored_log();
 	if cf.activate_access_log then begin
-		let post_rotate () = DB.to_file store cons "/var/run/xenstored/db" in
+		let post_rotate () = DB.to_file store cons "/run/xenstored/db" in
 		Logging.init_access_log post_rotate
 	end;
 
@@ -389,5 +389,5 @@
 				raise exc
 	done;
 	info "stopping xenstored";
-	DB.to_file store cons "/var/run/xenstored/db";
+	DB.to_file store cons "/run/xenstored/db";
 	()
diff -Naur xen/tools/pygrub/Makefile xen-b/tools/pygrub/Makefile
--- xen/tools/pygrub/Makefile	2013-03-09 18:06:26.069845278 -0700
+++ xen-b/tools/pygrub/Makefile	2013-03-16 22:46:21.176511944 -0600
@@ -13,7 +13,7 @@
 	CC="$(CC)" CFLAGS="$(CFLAGS)" $(PYTHON) setup.py install \
 		$(PYTHON_PREFIX_ARG) --root="$(DESTDIR)" \
 		--install-scripts=$(PRIVATE_BINDIR) --force
-	$(INSTALL_DIR) $(DESTDIR)/var/run/xend/boot
+	$(INSTALL_DIR) $(DESTDIR)/run/xend/boot
 	set -e; if [ "`readlink -f $(DESTDIR)/$(BINDIR)`" != \
 	             "`readlink -f $(PRIVATE_BINDIR)`" ]; then \
 	    ln -sf $(PRIVATE_BINDIR)/pygrub $(DESTDIR)/$(BINDIR); \
diff -Naur xen/tools/pygrub/src/pygrub xen-b/tools/pygrub/src/pygrub
--- xen/tools/pygrub/src/pygrub	2013-03-09 18:06:26.069845278 -0700
+++ xen-b/tools/pygrub/src/pygrub	2013-03-16 22:46:21.176511944 -0600
@@ -17,7 +17,6 @@
 import copy
 import logging
 import platform
-import xen.lowlevel.xc
 
 import curses, _curses, curses.wrapper, curses.textpad, curses.ascii
 import getopt
@@ -26,6 +25,7 @@
 import grub.GrubConf
 import grub.LiloConf
 import grub.ExtLinuxConf
+import xnloader
 
 PYGRUB_VER = 0.6
 FS_READ_MAX = 1024 * 1024
@@ -119,6 +119,7 @@
     fd = os.open(file, os.O_RDONLY)
     buf = os.read(fd, 512)
     os.close(fd)
+    offzerocount = 0
     for poff in (446, 462, 478, 494): # partition offsets
 
         # MBR contains a 16 byte descriptor per partition
@@ -128,6 +129,7 @@
         
         # offset == 0 implies this partition is not enabled
         if offset == 0:
+            offzerocount += 1
             continue
 
         if type == FDISK_PART_SOLARIS or type == FDISK_PART_SOLARIS_OLD:
@@ -148,6 +150,9 @@
         else:
             part_offs.append(offset)
 
+    if offzerocount == 4:
+        # Might be a grub boot sector pretending to be an MBR
+        part_offs.append(0)
     return part_offs
 
 class GrubLineEditor(curses.textpad.Textbox):
@@ -637,51 +642,6 @@
 
     return grubcfg
 
-def supports64bitPVguest():
-    xc = xen.lowlevel.xc.xc()
-    caps = xc.xeninfo()['xen_caps'].split(" ")
-    for cap in caps:
-        if cap == "xen-3.0-x86_64":
-            return True
-    return False
-
-# If nothing has been specified, look for a Solaris domU. If found, perform the
-# necessary tweaks.
-def sniff_solaris(fs, cfg):
-    if not fs.file_exists("/platform/i86xpv/kernel/unix") and \
-       not fs.file_exists("/platform/i86xpv/kernel/amd64/unix"):
-        return cfg
-
-    if not cfg["kernel"]:
-        if supports64bitPVguest() and \
-          fs.file_exists("/platform/i86xpv/kernel/amd64/unix"):
-            cfg["kernel"] = "/platform/i86xpv/kernel/amd64/unix"
-            cfg["ramdisk"] = "/platform/i86pc/amd64/boot_archive"
-        elif fs.file_exists("/platform/i86xpv/kernel/unix"):
-            cfg["kernel"] = "/platform/i86xpv/kernel/unix"
-            cfg["ramdisk"] = "/platform/i86pc/boot_archive"
-        else:
-            return cfg
-
-    # Unpleasant. Typically we'll have 'root=foo -k' or 'root=foo /kernel -k',
-    # and we need to maintain Xen properties (root= and ip=) and the kernel
-    # before any user args.
-    
-    xenargs = ""
-    userargs = ""
-    
-    if not cfg["args"]:
-        cfg["args"] = cfg["kernel"]
-    else:
-        for arg in cfg["args"].split():
-            if re.match("^root=", arg) or re.match("^ip=", arg):
-                xenargs += arg + " "
-            elif arg != cfg["kernel"]:
-                userargs += arg + " "
-        cfg["args"] = xenargs + " " + cfg["kernel"] + " " + userargs
-
-    return cfg
- 
 def sniff_netware(fs, cfg):
     if not fs.file_exists("/nwserver/xnloader.sys"):
         return cfg
@@ -734,6 +694,8 @@
             if len(data) == 0:
                 os.close(tfd)
                 del datafile
+                if file_to_read == "/nwserver/xnloader.sys":
+                    xnloader.patch_netware_loader(ret)
                 return ret
             try:
                 os.write(tfd, data)
@@ -768,7 +730,7 @@
     debug = False
     not_really = False
     output_format = "sxp"
-    output_directory = "/var/run/xend/boot"
+    output_directory = "/run/xend/boot"
 
     # what was passed in
     incfg = { "kernel": None, "ramdisk": None, "args": "" }
@@ -846,10 +808,7 @@
         try:
             fs = fsimage.open(file, offset, bootfsoptions)
 
-            chosencfg = sniff_solaris(fs, incfg)
-
-            if not chosencfg["kernel"]:
-                chosencfg = sniff_netware(fs, incfg)
+            chosencfg = sniff_netware(fs, incfg)
 
             if not chosencfg["kernel"]:
                 chosencfg = run_grub(file, entry, fs, incfg["args"])
diff -Naur xen/tools/python/README.XendConfig xen-b/tools/python/README.XendConfig
--- xen/tools/python/README.XendConfig	2013-03-09 18:06:26.069845278 -0700
+++ xen-b/tools/python/README.XendConfig	2013-03-16 22:46:21.176511944 -0600
@@ -118,6 +118,9 @@
                                 image.vncdisplay
                                 image.vncunused
                                 image.hvm.device_model
+                                image.hvm.actmem
+                                image.hvm.xenpaging_file
+                                image.hvm.xenpaging_extra
                                 image.hvm.display
                                 image.hvm.xauthority
                                 image.hvm.vncconsole
diff -Naur xen/tools/python/README.sxpcfg xen-b/tools/python/README.sxpcfg
--- xen/tools/python/README.sxpcfg	2013-03-09 18:06:26.069845278 -0700
+++ xen-b/tools/python/README.sxpcfg	2013-03-16 22:46:21.176511944 -0600
@@ -51,6 +51,9 @@
   - vncunused
   (HVM)
   - device_model
+  - actmem
+  - xenpaging_file
+  - xenpaging_extra
   - display
   - xauthority
   - vncconsole
diff -Naur xen/tools/python/xen/util/fileuri.py xen-b/tools/python/xen/util/fileuri.py
--- xen/tools/python/xen/util/fileuri.py	2013-03-09 18:06:26.089845278 -0700
+++ xen-b/tools/python/xen/util/fileuri.py	2013-03-16 22:46:21.179845277 -0600
@@ -81,10 +81,10 @@
     # and a flag if this file in temporary only and must be deleted
     # after starting the VM.
     def decode(encoded_data):
-        mkdir.parents("/var/run/xend/boot/", stat.S_IRWXU)
+        mkdir.parents("/run/xend/boot/", stat.S_IRWXU)
         mediatype, encoding, data_start = scheme_data.parse(encoded_data)
         fd, filename = tempfile.mkstemp(
-            prefix="data_uri_file.", dir="/var/run/xend/boot")
+            prefix="data_uri_file.", dir="/run/xend/boot")
         # Because of python 2.3 support, there is a need to nest these
         # (see http://www.python.org/doc/2.3/ref/try.html)
         try:
diff -Naur xen/tools/python/xen/util/pci.py xen-b/tools/python/xen/util/pci.py
--- xen/tools/python/xen/util/pci.py	2013-03-09 18:06:26.093178611 -0700
+++ xen-b/tools/python/xen/util/pci.py	2013-03-16 22:46:21.179845277 -0600
@@ -1268,7 +1268,11 @@
             pass
 
     def get_info_from_sysfs(self):
-        self.find_capability(0x11)
+        try:
+            self.find_capability(0x11)
+        except PciDeviceParseError, err:
+            log.error("Caught '%s'" % err)
+             return False
         sysfs_mnt = find_sysfs_mnt()
         if sysfs_mnt == None:
             return False
diff -Naur xen/tools/python/xen/xend/XendAPI.py xen-b/tools/python/xen/xend/XendAPI.py
--- xen/tools/python/xen/xend/XendAPI.py	2013-03-09 18:06:26.106511944 -0700
+++ xen-b/tools/python/xen/xend/XendAPI.py	2013-03-16 22:46:21.179845277 -0600
@@ -1941,10 +1941,10 @@
                               bool(live), port, node, ssl, bool(chs))
         return xen_api_success_void()
 
-    def VM_save(self, _, vm_ref, dest, checkpoint):
+    def VM_save(self, _, vm_ref, dest, checkpoint, force):
         xendom = XendDomain.instance()
         xeninfo = xendom.get_vm_by_uuid(vm_ref)
-        xendom.domain_save(xeninfo.getDomid(), dest, checkpoint)
+        xendom.domain_save(xeninfo.getDomid(), dest, checkpoint, force)
         return xen_api_success_void()
 
     def VM_restore(self, _, src, paused):
diff -Naur xen/tools/python/xen/xend/XendAPIConstants.py xen-b/tools/python/xen/xend/XendAPIConstants.py
--- xen/tools/python/xen/xend/XendAPIConstants.py	2013-03-09 18:06:26.106511944 -0700
+++ xen-b/tools/python/xen/xend/XendAPIConstants.py	2013-03-16 22:46:21.179845277 -0600
@@ -45,8 +45,10 @@
 XEN_API_ON_CRASH_BEHAVIOUR = [
     'destroy',
     'coredump_and_destroy',
+    'coredump_destroy',
     'restart',
     'coredump_and_restart',
+    'coredump_restart',
     'preserve',
     'rename_restart'
 ]
diff -Naur xen/tools/python/xen/xend/XendCheckpoint.py xen-b/tools/python/xen/xend/XendCheckpoint.py
--- xen/tools/python/xen/xend/XendCheckpoint.py	2013-03-09 18:06:26.106511944 -0700
+++ xen-b/tools/python/xen/xend/XendCheckpoint.py	2013-03-16 22:46:21.179845277 -0600
@@ -172,7 +172,7 @@
             dominfo.destroy()
             dominfo.testDeviceComplete()
         try:
-            dominfo.setName(domain_name, False)
+            dominfo.setName(domain_name)
         except VmError:
             # Ignore this.  The name conflict (hopefully) arises because we
             # are doing localhost migration; if we are doing a suspend of a
diff -Naur xen/tools/python/xen/xend/XendConfig.py xen-b/tools/python/xen/xend/XendConfig.py
--- xen/tools/python/xen/xend/XendConfig.py	2013-03-09 18:06:26.106511944 -0700
+++ xen-b/tools/python/xen/xend/XendConfig.py	2013-03-16 22:46:21.179845277 -0600
@@ -147,6 +147,9 @@
     'apic': int,
     'boot': str,
     'device_model': str,
+    'actmem': str,
+    'xenpaging_file': str,
+    'xenpaging_extra': str,
     'loader': str,
     'display' : str,
     'fda': str,
@@ -159,6 +162,7 @@
     'nographic': int,
     'nomigrate': int,
     'pae' : int,
+    'extid': int,
     'rtc_timeoffset': int,
     'parallel': str,
     'serial': str,
@@ -192,6 +196,8 @@
     'xen_platform_pci': int,
     "gfx_passthru": int,
     'oos' : int,
+    'watchdog': str,
+    'watchdog_action': str,
 }
 
 # Xen API console 'other_config' keys.
@@ -512,8 +518,16 @@
             self['platform']['nomigrate'] = 0
 
         if self.is_hvm():
+            if 'actmem' not in self['platform']:
+                self['platform']['actmem'] = "0"
+            if 'xenpaging_file' not in self['platform']:
+                self['platform']['xenpaging_file'] = ""
+            if 'xenpaging_extra' not in self['platform']:
+                self['platform']['xenpaging_extra'] = []
             if 'timer_mode' not in self['platform']:
                 self['platform']['timer_mode'] = 1
+            if 'extid' in self['platform'] and int(self['platform']['extid']) == 1:
+                self['platform']['viridian'] = 1
             if 'viridian' not in self['platform']:
                 self['platform']['viridian'] = 0
             if 'rtc_timeoffset' not in self['platform']:
@@ -1865,7 +1879,14 @@
         ports = sxp.child(dev_sxp, 'port')
         for port in ports[1:]:
             try:
-                num, bus = port
+                # When ['port' ['1','']] is saved into sxp file, it will become (port (1 ))
+                # If using this sxp file, here variable "port" will be port=1,
+                # we should process it, otherwise, it will report error.
+                if len(port) == 1:
+                    num = port[0]
+                    bus = ""
+                else:
+                    num, bus = port
                 dev_config['port-%i' % int(num)] = str(bus)
             except TypeError:
                 pass
diff -Naur xen/tools/python/xen/xend/XendDomain.py xen-b/tools/python/xen/xend/XendDomain.py
--- xen/tools/python/xen/xend/XendDomain.py	2013-03-09 18:06:26.106511944 -0700
+++ xen-b/tools/python/xen/xend/XendDomain.py	2013-03-16 22:46:21.183178611 -0600
@@ -1505,7 +1505,7 @@
                     pass
                 sock.close()
 
-    def domain_save(self, domid, dst, checkpoint=False):
+    def domain_save(self, domid, dst, checkpoint=False, force=False):
         """Start saving a domain to file.
 
         @param domid: Domain ID or Name
@@ -1521,6 +1521,9 @@
             if not dominfo:
                 raise XendInvalidDomain(str(domid))
 
+            if os.access(dst, os.F_OK) and not force:
+                raise XendError("Save file:%s exist!\n" % dst)
+
             if dominfo.getDomid() == DOM0_ID:
                 raise XendError("Cannot save privileged domain %s" % str(domid))
             if dominfo._stateGet() != DOM_STATE_RUNNING:
@@ -1832,6 +1835,21 @@
             log.exception(ex)
             raise XendError(str(ex))
 
+    def domain_swaptarget_set(self, domid, mem):
+        """Set the memory limit for a domain.
+
+        @param domid: Domain ID or Name
+        @type domid: int or string.
+        @param mem: memory limit (in MiB)
+        @type mem: int
+        @raise XendError: fail to set memory
+        @rtype: 0
+        """
+        dominfo = self.domain_lookup_nr(domid)
+        if not dominfo:
+            raise XendInvalidDomain(str(domid))
+        dominfo.setSwapTarget(mem)
+
     def domain_maxmem_set(self, domid, mem):
         """Set the memory limit for a domain.
 
diff -Naur xen/tools/python/xen/xend/XendDomainInfo.py xen-b/tools/python/xen/xend/XendDomainInfo.py
--- xen/tools/python/xen/xend/XendDomainInfo.py	2013-03-09 18:06:26.109845278 -0700
+++ xen-b/tools/python/xen/xend/XendDomainInfo.py	2013-03-16 22:46:21.183178611 -0600
@@ -1295,8 +1295,15 @@
                 frontpath = self.getDeviceController(deviceClass).frontendPath(dev)
                 backpath = xstransact.Read(frontpath, "backend")
                 thread.start_new_thread(self.getDeviceController(deviceClass).finishDeviceCleanup, (backpath, path))
-
-            rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
+            if deviceClass =='vusb':
+                dev = self.getDeviceController(deviceClass).convertToDeviceNumber(devid)
+                state = self.getDeviceController(deviceClass).readBackend(dev, 'state')
+                if state == '1':
+                    rc = self.getDeviceController(deviceClass).destroyDevice(devid, True)
+                else:
+                    rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
+            else:
+                rc = self.getDeviceController(deviceClass).destroyDevice(devid, force)
             if not force and rm_cfg:
                 # The backend path, other than the device itself,
                 # has to be passed because its accompanied frontend
@@ -1459,6 +1466,17 @@
         pci_conf = self.info['devices'][dev_uuid][1]
         return map(pci_dict_to_bdf_str, pci_conf['devs'])
 
+    def setSwapTarget(self, target):
+        """Set the swap target of this domain.
+        @param target: In MiB.
+        """
+        log.debug("Setting swap target of domain %s (%s) to %d MiB.",
+                  self.info['name_label'], str(self.domid), target)
+
+        if self.domid > 0:
+            self.storeDom("memory/target-tot_pages", target * 1024)
+            self.info['platform']['actmem'] = str(target)
+
     def setMemoryTarget(self, target):
         """Set the memory target of this domain.
         @param target: In MiB.
@@ -2247,6 +2265,8 @@
                  self.info['name_label'], self.domid, self.info['uuid'],
                  new_name, new_uuid)
         self._unwatchVm()
+        if self.image:
+            self.image.destroyXenPaging()
         self._releaseDevices()
         # Remove existing vm node in xenstore
         self._removeVm()
@@ -2884,7 +2904,7 @@
 
             self.guest_bitsize = self.image.getBitSize()
             # Make sure there's enough RAM available for the domain
-            balloon.free(memory + shadow + vtd_mem, self)
+            balloon.free(memory + shadow + vtd_mem + 512, self)
 
             # Set up the shadow memory
             shadow_cur = xc.shadow_mem_control(self.domid, shadow / 1024)
@@ -2919,6 +2939,9 @@
 
             self._createDevices()
 
+            if self.image:
+                self.image.createXenPaging()
+
             self.image.cleanupTmpImages()
 
             self.info['start_time'] = time.time()
@@ -2943,6 +2966,8 @@
         self.refresh_shutdown_lock.acquire()
         try:
             self.unwatchShutdown()
+            if self.image:
+                self.image.destroyXenPaging()
             self._releaseDevices()
             bootloader_tidy(self)
 
@@ -3027,6 +3052,7 @@
         self.refreshShutdown()
 
         log.debug("XendDomainInfo.completeRestore done")
+            self.image.createXenPaging()
 
 
     def _endRestore(self):
@@ -3157,6 +3183,8 @@
             # could also fetch a parsed note from xenstore
             fast = self.info.get_notes().get('SUSPEND_CANCEL') and 1 or 0
             if not fast:
+                if self.image:
+                    self.image.destroyXenPaging()
                 self._releaseDevices()
                 self.testDeviceComplete()
                 self.testvifsComplete()
@@ -3172,6 +3200,8 @@
                 self._storeDomDetails()
 
                 self._createDevices()
+                if self.image:
+                    self.image.createXenPaging()
                 log.debug("XendDomainInfo.resumeDomain: devices created")
 
             xc.domain_resume(self.domid, fast)
@@ -3908,6 +3938,14 @@
             else:
                 config['mode'] = 'RW'
 
+        if dev_class == 'console':
+            if not config.has_key('protocol'):
+                con_type = config.get('type', '')
+                if con_type == 'vnc':
+                    config['protocol'] = 'rfb'
+                elif con_type == 'sdl':
+                    config['protocol'] = 'rdp'
+
         return config
 
     def get_dev_property(self, dev_class, dev_uuid, field):
diff -Naur xen/tools/python/xen/xend/image.py xen-b/tools/python/xen/xend/image.py
--- xen/tools/python/xen/xend/image.py	2013-03-09 18:06:26.109845278 -0700
+++ xen-b/tools/python/xen/xend/image.py	2013-03-16 22:46:21.183178611 -0600
@@ -122,6 +122,10 @@
         self.vm.permissionsVm("image/cmdline", { 'dom': self.vm.getDomid(), 'read': True } )
 
         self.device_model = vmConfig['platform'].get('device_model')
+        self.actmem = str(vmConfig['platform'].get('actmem'))
+        self.xenpaging_file = str(vmConfig['platform'].get('xenpaging_file'))
+        self.xenpaging_extra = vmConfig['platform'].get('xenpaging_extra')
+        self.xenpaging_pid = None
 
         self.display = vmConfig['platform'].get('display')
         self.xauthority = vmConfig['platform'].get('xauthority')
@@ -392,6 +396,87 @@
         sentinel_fifos_inuse[sentinel_path_fifo] = 1
         self.sentinel_path_fifo = sentinel_path_fifo
 
+    def createXenPaging(self):
+        if not self.vm.info.is_hvm():
+            return
+        if self.actmem == "0":
+            return
+        if self.xenpaging_pid:
+            return
+        xenpaging_bin = auxbin.pathTo("xenpaging")
+        args = [xenpaging_bin]
+        args = args + ([ "-f", "/var/lib/xen/xenpaging/%s.%d.paging" % (str(self.vm.info['name_label']), self.vm.getDomid())])
+        if self.xenpaging_extra:
+            args = args + (self.xenpaging_extra)
+        args = args + ([ "-d", "%d" % self.vm.getDomid()])
+        self.xenpaging_logfile = "/var/log/xen/xenpaging-%s.log" %  str(self.vm.info['name_label'])
+        logfile_mode = os.O_WRONLY|os.O_CREAT|os.O_APPEND|os.O_TRUNC
+        null = os.open("/dev/null", os.O_RDONLY)
+        try:
+            os.unlink(self.xenpaging_logfile)
+        except:
+            pass
+        logfd = os.open(self.xenpaging_logfile, logfile_mode, 0644)
+        sys.stderr.flush()
+        contract = osdep.prefork("%s:%d" % (self.vm.getName(), self.vm.getDomid()))
+        xenpaging_pid = os.fork()
+        if xenpaging_pid == 0: #child
+            try:
+                osdep.postfork(contract)
+                os.dup2(null, 0)
+                os.dup2(logfd, 1)
+                os.dup2(logfd, 2)
+                try:
+                    env = dict(os.environ)
+                    log.info("starting %s" % args)
+                    os.execve(xenpaging_bin, args, env)
+                except Exception, e:
+                    log.warn('failed to execute xenpaging: %s' % utils.exception_string(e))
+                    os._exit(126)
+            except:
+                log.warn("starting xenpaging failed")
+                os._exit(127)
+        else:
+            osdep.postfork(contract, abandon=True)
+            self.xenpaging_pid = xenpaging_pid
+            os.close(null)
+            os.close(logfd)
+        self.vm.storeDom("xenpaging/xenpaging-pid", self.xenpaging_pid)
+        self.vm.storeDom("memory/target-tot_pages", int(self.actmem) * 1024)
+
+    def destroyXenPaging(self):
+        if self.actmem == "0":
+            return
+        if self.xenpaging_pid:
+            try:
+                os.kill(self.xenpaging_pid, signal.SIGHUP)
+            except OSError, exn:
+                log.exception(exn)
+            for i in xrange(100):
+                try:
+                    (p, rv) = os.waitpid(self.xenpaging_pid, os.WNOHANG)
+                    if p == self.xenpaging_pid:
+                        break
+                except OSError:
+                    # This is expected if Xend has been restarted within
+                    # the life of this domain.  In this case, we can kill
+                    # the process, but we can't wait for it because it's
+                    # not our child. We continue this loop, and after it is
+                    # terminated make really sure the process is going away
+                    # (SIGKILL).
+                    pass
+                time.sleep(0.1)
+            else:
+                log.warning("xenpaging %d took more than 10s "
+                            "to terminate: sending SIGKILL" % self.xenpaging_pid)
+                try:
+                    os.kill(self.xenpaging_pid, signal.SIGKILL)
+                    os.waitpid(self.xenpaging_pid, 0)
+                except OSError:
+                    # This happens if the process doesn't exist.
+                    pass
+        self.xenpaging_pid = None
+
     def createDeviceModel(self, restore = False):
         if self.device_model is None:
             return
@@ -828,6 +913,7 @@
 
         self.apic = int(vmConfig['platform'].get('apic', 0))
         self.acpi = int(vmConfig['platform'].get('acpi', 0))
+        self.extid = int(vmConfig['platform'].get('extid', 0))
         self.guest_os_type = vmConfig['platform'].get('guest_os_type')
         self.memory_sharing = int(vmConfig['memory_sharing'])
         try:
@@ -855,7 +941,8 @@
 
         dmargs = [ 'boot', 'fda', 'fdb', 'soundhw',
                    'localtime', 'serial', 'stdvga', 'isa',
-                   'acpi', 'usb', 'usbdevice', 'gfx_passthru' ]
+                   'acpi', 'usb', 'usbdevice', 'gfx_passthru',
+                   'watchdog', 'watchdog_action' ]
 
         for a in dmargs:
             v = vmConfig['platform'].get(a)
@@ -863,6 +950,7 @@
             # python doesn't allow '-' in variable names
             if a == 'stdvga': a = 'std-vga'
             if a == 'keymap': a = 'k'
+            if a == 'watchdog_action': a = 'watchdog-action'
 
             # Handle booleans gracefully
             if a in ['localtime', 'std-vga', 'isa', 'usb', 'acpi']:
@@ -1036,7 +1124,7 @@
 
     def configure(self, vmConfig):
         HVMImageHandler.configure(self, vmConfig)
-        self.pae = int(vmConfig['platform'].get('pae',  0))
+        self.pae = int(vmConfig['platform'].get('pae',  1))
         self.vramsize = int(vmConfig['platform'].get('videoram',4)) * 1024
 
     def buildDomain(self):
diff -Naur xen/tools/python/xen/xend/server/BlktapController.py xen-b/tools/python/xen/xend/server/BlktapController.py
--- xen/tools/python/xen/xend/server/BlktapController.py	2013-03-09 18:06:26.109845278 -0700
+++ xen-b/tools/python/xen/xend/server/BlktapController.py	2013-03-16 22:52:18.709845278 -0600
@@ -15,6 +15,7 @@
     'ram',
     'qcow',
     'qcow2',
+    'cdrom',
     'ioemu',
     ]
 
diff -Naur xen/tools/python/xen/xend/server/DevController.py xen-b/tools/python/xen/xend/server/DevController.py
--- xen/tools/python/xen/xend/server/DevController.py	2013-03-09 18:06:26.113178611 -0700
+++ xen-b/tools/python/xen/xend/server/DevController.py	2013-03-16 22:46:25.789845277 -0600
@@ -149,7 +149,10 @@
         (status, err) = self.waitForBackend(devid)
 
         if status == Timeout:
-            self.destroyDevice(devid, False)
+            #Clean timeout backend resource
+            dev = self.convertToDeviceNumber(devid)
+            self.writeBackend(dev, HOTPLUG_STATUS_NODE, HOTPLUG_STATUS_ERROR)
+            self.destroyDevice(devid, True)
             raise VmError("Device %s (%s) could not be connected. "
                           "Hotplug scripts not working." %
                           (devid, self.deviceClass))
@@ -554,7 +557,17 @@
 
             xswatch(statusPath, hotplugStatusCallback, ev, result)
 
-            ev.wait(DEVICE_CREATE_TIMEOUT)
+            for i in range(1, 50):
+                ev.wait(DEVICE_CREATE_TIMEOUT/50)
+                status = xstransact.Read(statusPath)
+                if status is not None:
+                    if status == HOTPLUG_STATUS_ERROR:
+                        result['status'] = Error
+                    elif status == HOTPLUG_STATUS_BUSY:
+                        result['status'] = Busy
+                    else:
+                        result['status'] = Connected
+                    break
 
             err = xstransact.Read(backpath, HOTPLUG_ERROR_NODE)
 
@@ -571,7 +584,12 @@
 
         xswatch(statusPath, deviceDestroyCallback, ev, result)
 
-        ev.wait(DEVICE_DESTROY_TIMEOUT)
+        for i in range(1, 50):
+            ev.wait(DEVICE_DESTROY_TIMEOUT/50)
+            status = xstransact.Read(statusPath)
+            if status is None:
+                result['status'] = Disconnected
+                break 
 
         return result['status']
 
diff -Naur xen/tools/python/xen/xm/cpupool.py xen-b/tools/python/xen/xm/cpupool.py
--- xen/tools/python/xen/xm/cpupool.py	2013-03-09 18:06:26.119845277 -0700
+++ xen-b/tools/python/xen/xm/cpupool.py	2013-03-16 22:46:21.183178611 -0600
@@ -157,9 +157,17 @@
             #    ["0,2","1,3"]       -> [[0,2],[1,3]]
             #    ["0-3,^1","1-4,^2"] -> [[0,2,3],[1,3,4]]
             try:
-                for c in cfg_cpus:
-                    cpus = cnv(c)
-                    cpus_list.append(cpus)
+                cpus_str = ""
+                list_len = len(cfg_cpus)
+                n = 0
+                while n < list_len:
+                    if type(cfg_cpus[n]) != str:
+                        raise SyntaxError('cpus = %s' % cfg_cpus)
+                    cpus_str += cfg_cpus[n]
+                    n += 1
+                    if n < list_len:
+                        cpus_str += ', '
+                cpus_list = cnv(cpus_str)
             except ValueError, e:
                 raise err('cpus = %s: %s' % (cfg_cpus, e))
     else:
diff -Naur xen/tools/python/xen/xm/create.py xen-b/tools/python/xen/xm/create.py
--- xen/tools/python/xen/xm/create.py	2013-03-09 18:06:26.119845277 -0700
+++ xen-b/tools/python/xen/xm/create.py	2013-03-16 22:46:21.183178611 -0600
@@ -36,7 +36,7 @@
 from xen.util import blkif
 from xen.util import vscsi_util
 import xen.util.xsm.xsm as security
-from xen.xm.main import serverType, SERVER_XEN_API, get_single_vm
+from xen.xm.main import serverType, SERVER_XEN_API, SERVER_LEGACY_XMLRPC, get_single_vm
 from xen.util import utils, auxbin
 from xen.util.pci import dev_dict_to_sxp, \
                          parse_pci_name_extended, PciDeviceParseError
@@ -242,6 +242,10 @@
           use="""Expose Viridian interface to x86 HVM guest?
           (Default is 0).""")
 
+gopts.var('extid', val='EXTID',
+          fn=set_int, default=0,
+          use="Specify extention ID for a HVM domain.")
+
 gopts.var('acpi', val='ACPI',
           fn=set_int, default=1,
           use="Disable or enable ACPI of HVM domain.")
@@ -473,6 +477,18 @@
           fn=set_value, default=None,
           use="Set the path of the root NFS directory.")
 
+gopts.var('actmem', val='NUM',
+          fn=set_value, default='0',
+          use="Number of pages to swap.")
+
+gopts.var('xenpaging_file', val='PATH',
+          fn=set_value, default=None,
+          use="pagefile to use (optional)")
+
+gopts.var('xenpaging_extra', val='string1,string2',
+          fn=append_value, default=[],
+          use="additional args for xenpaging (optional)")
+
 gopts.var('device_model', val='FILE',
           fn=set_value, default=None,
           use="Path to device model program.")
@@ -517,6 +533,21 @@
           fn=set_value, default='',
           use="Name of USB device to add?")
 
+gopts.var('watchdog', val='NAME',
+          fn=set_value, default='',
+          use="Watchdog device to use. May be ib700 or i6300esb")
+
+gopts.var('watchdog_action', val='reset|shutdown|poweroff|pause|none|dump',
+          fn=set_value, default="reset",
+          use="""Action when watchdog timer expires:
+          - reset:     Default, forcefully reset the guest;
+          - shutdown:  Gracefully shutdown the guest (not recommended);
+          - poweroff:  Forcefully power off the guest;
+          - pause:     Pause the guest;
+          - none:      Do nothing;
+          - dump:      Automatically dump the guest;
+          """)
+
 gopts.var('description', val='NAME',
           fn=set_value, default='',
           use="Description of a domain")
@@ -1032,6 +1063,9 @@
     args = [ 'acpi', 'apic',
              'boot',
              'cpuid', 'cpuid_check',
+             'actmem',
+             'xenpaging_file',
+             'xenpaging_extra',
              'device_model', 'display',
              'fda', 'fdb',
              'gfx_passthru', 'guest_os_type',
@@ -1047,7 +1081,7 @@
              'timer_mode',
              'usb', 'usbdevice',
              'vcpus', 'vnc', 'vncconsole', 'vncdisplay', 'vnclisten',
-             'vncunused', 'viridian', 'vpt_align',
+             'vncunused', 'vpt_align',
              'xauthority', 'xen_extended_power_mgmt', 'xen_platform_pci',
              'memory_sharing' ]
 
@@ -1056,6 +1090,10 @@
             config_image.append([a, vals.__dict__[a]])
     if vals.vncpasswd is not None:
         config_image.append(['vncpasswd', vals.vncpasswd])
+    if vals.extid and vals.extid == 1:
+        config_image.append(['viridian', vals.extid])
+    elif vals.viridian:
+        config_image.append(['viridian', vals.viridian])
 
 
 def make_config(vals):
@@ -1072,6 +1110,7 @@
         if hasattr(vals, 'vcpus'):
             vcpus = getattr(vals, 'vcpus')
 
+             'watchdog', 'watchdog_action',
         if maxvcpus and not vcpus:
             config.append(['vcpus', maxvcpus])
         if maxvcpus and vcpus:
@@ -1465,7 +1504,7 @@
             except IOError, exn:
                 raise OptionError("Cannot read file %s: %s" % (config, exn[1]))
         
-        if serverType == SERVER_XEN_API:
+        if serverType == SERVER_XEN_API or serverType == SERVER_LEGACY_XMLRPC:
             from xen.xm.xenapi_create import sxp2xml
             sxp2xml_inst = sxp2xml()
             doc = sxp2xml_inst.convert_sxp_to_xml(config, transient=True)
@@ -1473,7 +1512,7 @@
         if opts.vals.dryrun and not opts.is_xml:
             SXPPrettyPrint.prettyprint(config)
 
-        if opts.vals.xmldryrun and serverType == SERVER_XEN_API:
+        if opts.vals.xmldryrun:
             print doc.toprettyxml()
 
     if opts.vals.dryrun or opts.vals.xmldryrun:
diff -Naur xen/tools/python/xen/xm/main.py xen-b/tools/python/xen/xm/main.py
--- xen/tools/python/xen/xm/main.py	2013-03-09 18:06:26.119845277 -0700
+++ xen-b/tools/python/xen/xm/main.py	2013-03-16 22:46:21.186511944 -0600
@@ -114,6 +114,8 @@
                      'Set the maximum amount reservation for a domain.'),
     'mem-set'     : ('<Domain> <Mem>',
                      'Set the current memory usage for a domain.'),
+    'mem-swap-target' : ('<Domain> <Mem>',
+                     'Set the memory usage for a domain.'),
     'migrate'     : ('<Domain> <Host>',
                      'Migrate a domain to another machine.'),
     'pause'       : ('<Domain>', 'Pause execution of a domain.'),
@@ -121,7 +123,7 @@
     'reset'       : ('<Domain>', 'Reset a domain.'),
     'restore'     : ('<CheckpointFile> [-p]',
                      'Restore a domain from a saved state.'),
-    'save'        : ('[-c] <Domain> <CheckpointFile>',
+    'save'        : ('[-c|-f] <Domain> <CheckpointFile>',
                      'Save a domain state to restore later.'),
     'shutdown'    : ('<Domain> [-waRH]', 'Shutdown a domain.'),
     'top'         : ('', 'Monitor a host and the domains in real time.'),
@@ -341,6 +343,7 @@
     ),
     'save': (
        ('-c', '--checkpoint', 'Leave domain running after creating snapshot'),
+       ('-f', '--force', 'Force to overwrite exist file'),
     ),
     'restore': (
        ('-p', '--paused', 'Do not unpause domain after restoring it'),
@@ -862,18 +865,21 @@
 
 def xm_save(args):
 
-    arg_check(args, "save", 2, 3)
+    arg_check(args, "save", 2, 4)
     
     try:
-        (options, params) = getopt.gnu_getopt(args, 'c', ['checkpoint'])
+        (options, params) = getopt.gnu_getopt(args, 'cf', ['checkpoint', 'force'])
     except getopt.GetoptError, opterr:
         err(opterr)
         usage('save')
 
     checkpoint = False
+    force = False
     for (k, v) in options:
         if k in ['-c', '--checkpoint']:
             checkpoint = True
+        if k in ['-f', '--force']:
+            force = True
 
     if len(params) != 2:
         err("Wrong number of parameters")
@@ -1580,6 +1586,17 @@
         mem_target = int_unit(args[1], 'm')
         server.xend.domain.setMemoryTarget(dom, mem_target)
 
+def xm_mem_swap_target(args):
+    arg_check(args, "mem-swap-target", 2)
+
+    dom = args[0]
+
+    if serverType == SERVER_XEN_API:
+        err("xenapi not supported")
+    else:
+        swap_target = int_unit(args[1], 'm')
+        server.xend.domain.swaptarget_set(dom, swap_target)
+
 def xm_usb_add(args):
     arg_check(args, "usb-add", 2)
     server.xend.domain.usb_add(args[0],args[1])
@@ -3782,6 +3799,7 @@
     # memory commands
     "mem-max": xm_mem_max,
     "mem-set": xm_mem_set,
+    "mem-swap-target": xm_mem_swap_target,
     # cpu commands
     "vcpu-pin": xm_vcpu_pin,
     "vcpu-list": xm_vcpu_list,
diff -Naur xen/tools/python/xen/xm/xenapi_create.py xen-b/tools/python/xen/xm/xenapi_create.py
--- xen/tools/python/xen/xm/xenapi_create.py	2013-03-09 18:06:26.123178611 -0700
+++ xen-b/tools/python/xen/xm/xenapi_create.py	2013-03-16 22:46:21.186511944 -0600
@@ -1046,6 +1046,9 @@
             'acpi',
             'apic',
             'boot',
+            'actmem',
+            'xenpaging_file',
+            'xenpaging_extra',
             'device_model',
             'loader',
             'fda',
@@ -1074,7 +1077,9 @@
             'xen_platform_pci',
             'tsc_mode'
             'description',
-            'nomigrate'
+            'nomigrate',
+            'watchdog',
+            'watchdog_action'
         ]
 
         platform_configs = []
diff -Naur xen/tools/tests/mce-test/tools/Makefile xen-b/tools/tests/mce-test/tools/Makefile
--- xen/tools/tests/mce-test/tools/Makefile	2013-03-09 18:06:26.136511944 -0700
+++ xen-b/tools/tests/mce-test/tools/Makefile	2013-03-16 22:46:21.186511944 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_libxenguest)
 CFLAGS += $(CFLAGS_libxenstore) 
diff -Naur xen/tools/tests/mem-sharing/Makefile xen-b/tools/tests/mem-sharing/Makefile
--- xen/tools/tests/mem-sharing/Makefile	2013-03-09 18:06:26.136511944 -0700
+++ xen-b/tools/tests/mem-sharing/Makefile	2013-03-16 22:46:21.186511944 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_xeninclude)
diff -Naur xen/tools/tests/xen-access/Makefile xen-b/tools/tests/xen-access/Makefile
--- xen/tools/tests/xen-access/Makefile	2013-03-09 18:06:26.146511944 -0700
+++ xen-b/tools/tests/xen-access/Makefile	2013-03-16 22:46:21.186511944 -0600
@@ -1,7 +1,7 @@
 XEN_ROOT=$(CURDIR)/../../..
 include $(XEN_ROOT)/tools/Rules.mk
 
-CFLAGS += -Werror
+CFLAGS +=
 
 CFLAGS += $(CFLAGS_libxenctrl)
 CFLAGS += $(CFLAGS_libxenguest)
diff -Naur xen/tools/xenbackendd/xenbackendd.c xen-b/tools/xenbackendd/xenbackendd.c
--- xen/tools/xenbackendd/xenbackendd.c	2013-03-09 18:06:26.146511944 -0700
+++ xen-b/tools/xenbackendd/xenbackendd.c	2013-03-16 22:46:21.186511944 -0600
@@ -48,7 +48,7 @@
 #define LOG_FILE "/var/log/xen/xenbackendd.log"
 #endif
 #ifndef PID_FILE
-#define PID_FILE "/var/run/xenbackendd.pid"
+#define PID_FILE "/run/xenbackendd.pid"
 #endif
 
 
diff -Naur xen/tools/xenballoon/xenballoon.conf xen-b/tools/xenballoon/xenballoon.conf
--- xen/tools/xenballoon/xenballoon.conf	2013-03-09 18:06:26.146511944 -0700
+++ xen-b/tools/xenballoon/xenballoon.conf	2013-03-16 22:46:21.186511944 -0600
@@ -61,13 +61,13 @@
 XENBALLOON_MINMEM=0
 
 ## Type: string
-## Default: "/var/run/xenballoon-maxmem"
+## Default: "/run/xenballoon-maxmem"
 #
 # Location where memory high-water mark is stored; if a guest supports
 # hot-add memory, maxmem might increase across time and the minimum
 # target heuristic is based on max memory. NOTE: Reboot after changing
 # this variable, else overballooning may occur.
-XENBALLOON_MAXMEMFILE=/var/run/xenballoon-maxmem
+XENBALLOON_MAXMEMFILE=/run/xenballoon-maxmem
 
 ## Type: integer (0 or 1)
 ## Default: 1
diff -Naur xen/tools/xenmon/xenbaked.c xen-b/tools/xenmon/xenbaked.c
--- xen/tools/xenmon/xenbaked.c	2013-03-09 18:06:26.149845278 -0700
+++ xen-b/tools/xenmon/xenbaked.c	2013-03-16 22:46:21.186511944 -0600
@@ -645,7 +645,7 @@
     }
 }
 
-#define SHARED_MEM_FILE "/var/run/xenq-shm"
+#define SHARED_MEM_FILE "/run/xenq-shm"
 static void alloc_qos_data(int ncpu)
 {
     int i, n, pgsize, off=0;
diff -Naur xen/tools/xenmon/xenmon.py xen-b/tools/xenmon/xenmon.py
--- xen/tools/xenmon/xenmon.py	2013-03-09 18:06:26.149845278 -0700
+++ xen-b/tools/xenmon/xenmon.py	2013-03-16 22:46:21.189845278 -0600
@@ -46,7 +46,7 @@
 QOS_DATA_SIZE = struct.calcsize(ST_QDATA)*NSAMPLES + struct.calcsize(ST_DOM_INFO)*NDOMAINS + struct.calcsize("4i")
 
 # location of mmaped file, hard coded right now
-SHM_FILE = "/var/run/xenq-shm"
+SHM_FILE = "/run/xenq-shm"
 
 # format strings
 TOTALS = 15*' ' + "%6.2f%%" + 35*' ' + "%6.2f%%"
diff -Naur xen/tools/xenstat/xentop/Makefile xen-b/tools/xenstat/xentop/Makefile
--- xen/tools/xenstat/xentop/Makefile	2013-03-09 18:06:26.159845277 -0700
+++ xen-b/tools/xenstat/xentop/Makefile	2013-03-16 22:46:21.189845278 -0600
@@ -18,7 +18,7 @@
 all install xentop:
 else
 
-CFLAGS += -DGCC_PRINTF -Wall -Werror $(CFLAGS_libxenstat)
+CFLAGS += -DGCC_PRINTF -Wall $(CFLAGS_libxenstat)
 LDLIBS += $(LDLIBS_libxenstat) $(CURSES_LIBS) $(SOCKET_LIBS)
 CFLAGS += -DHOST_$(XEN_OS)
 
diff -Naur xen/tools/xenstore/Makefile xen-b/tools/xenstore/Makefile
--- xen/tools/xenstore/Makefile	2013-03-09 18:06:26.163178610 -0700
+++ xen-b/tools/xenstore/Makefile	2013-03-16 22:46:21.189845278 -0600
@@ -110,7 +110,7 @@
 	$(INSTALL_DIR) $(DESTDIR)$(SBINDIR)
 	$(INSTALL_DIR) $(DESTDIR)$(INCLUDEDIR)
 	$(INSTALL_DIR) $(DESTDIR)$(INCLUDEDIR)/xenstore-compat
-	$(INSTALL_DIR) $(DESTDIR)/var/run/xenstored
+	$(INSTALL_DIR) $(DESTDIR)/run/xenstored
 	$(INSTALL_DIR) $(DESTDIR)/var/lib/xenstored
 	$(INSTALL_PROG) xenstored $(DESTDIR)$(SBINDIR)
 	$(INSTALL_PROG) xenstore-control $(DESTDIR)$(BINDIR)
diff -Naur xen/tools/xenstore/xenstore.h xen-b/tools/xenstore/xenstore.h
--- xen/tools/xenstore/xenstore.h	2013-03-09 18:06:26.169845278 -0700
+++ xen-b/tools/xenstore/xenstore.h	2013-03-16 22:46:21.189845278 -0600
@@ -26,6 +26,7 @@
 
 #define XS_OPEN_READONLY	1UL<<0
 #define XS_OPEN_SOCKETONLY      1UL<<1
+#define XS_OPEN_DOMAINONLY      1UL<<2
 
 /*
  * Setting XS_UNWATCH_FILTER arranges that after xs_unwatch, no
diff -Naur xen/tools/xenstore/xenstore_client.c xen-b/tools/xenstore/xenstore_client.c
--- xen/tools/xenstore/xenstore_client.c	2013-03-09 18:06:26.169845278 -0700
+++ xen-b/tools/xenstore/xenstore_client.c	2013-03-16 22:46:21.189845278 -0600
@@ -629,7 +629,7 @@
 	    max_width = ws.ws_col - 2;
     }
 
-    xsh = xs_open(socket ? XS_OPEN_SOCKETONLY : 0);
+    xsh = xs_open(socket ? XS_OPEN_SOCKETONLY : XS_OPEN_DOMAINONLY);
     if (xsh == NULL) err(1, "xs_open");
 
 again:
diff -Naur xen/tools/xenstore/xs.c xen-b/tools/xenstore/xs.c
--- xen/tools/xenstore/xs.c	2013-03-09 18:06:26.169845278 -0700
+++ xen-b/tools/xenstore/xs.c	2013-03-16 22:46:21.189845278 -0600
@@ -278,17 +278,19 @@
 
 struct xs_handle *xs_domain_open(void)
 {
-	return xs_open(0);
+	return xs_open(XS_OPEN_DOMAINONLY);
 }
 
 struct xs_handle *xs_open(unsigned long flags)
 {
 	struct xs_handle *xsh = NULL;
 
+	if (!(flags & XS_OPEN_DOMAINONLY)) {
 	if (flags & XS_OPEN_READONLY)
 		xsh = get_handle(xs_daemon_socket_ro());
 	else
 		xsh = get_handle(xs_daemon_socket());
+	}
 
 	if (!xsh && !(flags & XS_OPEN_SOCKETONLY))
 		xsh = get_handle(xs_domain_dev());
diff -Naur xen/tools/xenstore/xs_lib.c xen-b/tools/xenstore/xs_lib.c
--- xen/tools/xenstore/xs_lib.c	2013-03-09 18:06:26.169845278 -0700
+++ xen-b/tools/xenstore/xs_lib.c	2013-03-16 22:46:21.189845278 -0600
@@ -36,7 +36,7 @@
 const char *xs_daemon_rundir(void)
 {
 	char *s = getenv("XENSTORED_RUNDIR");
-	return (s ? s : "/var/run/xenstored");
+	return (s ? s : "/run/xenstored");
 }
 
 static const char *xs_daemon_path(void)
diff -Naur xen/unmodified_drivers/linux-2.6/Module.supported xen-b/unmodified_drivers/linux-2.6/Module.supported
--- xen/unmodified_drivers/linux-2.6/Module.supported	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/unmodified_drivers/linux-2.6/Module.supported	2013-03-16 22:46:21.189845278 -0600
@@ -0,0 +1,6 @@
+xen-vbd
+xen-platform-pci
+xen-vnif
+xenbus
+xen-balloon
+xen-scsi
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/evtchn.c xen-b/unmodified_drivers/linux-2.6/platform-pci/evtchn.c
--- xen/unmodified_drivers/linux-2.6/platform-pci/evtchn.c	2013-03-09 18:06:26.236511944 -0700
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/evtchn.c	2013-03-16 22:46:21.189845278 -0600
@@ -40,7 +40,9 @@
 #include <xen/platform-compat.h>
 #endif
 
+#ifndef shared_info_area
 void *shared_info_area;
+#endif
 
 #define is_valid_evtchn(x)	((x) != 0)
 #define evtchn_from_irq(x)	(irq_evtchn[irq].evtchn)
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c
--- xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2013-03-09 18:06:26.236511944 -0700
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.c	2013-03-16 22:46:21.189845278 -0600
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/version.h>
+#include <linux/dmi.h>
 #include <linux/interrupt.h>
 #include <linux/vmalloc.h>
 #include <linux/mm.h>
@@ -76,7 +77,6 @@
 static int __devinit init_xen_info(void)
 {
 	struct xen_add_to_physmap xatp;
-	extern void *shared_info_area;
 
 #ifdef __ia64__
 	xencomm_initialize();
@@ -84,6 +84,7 @@
 
 	setup_xen_features();
 
+#ifndef shared_info_area
 	shared_info_frame = alloc_xen_mmio(PAGE_SIZE) >> PAGE_SHIFT;
 	xatp.domid = DOMID_SELF;
 	xatp.idx = 0;
@@ -96,6 +97,11 @@
 		ioremap(shared_info_frame << PAGE_SHIFT, PAGE_SIZE);
 	if (shared_info_area == NULL)
 		panic("can't map shared info\n");
+#else
+	shared_info_frame = __pa(shared_info_area) >> PAGE_SHIFT;
+	printk(KERN_INFO "Using kernel provided shared info (pfn=%lx)\n",
+	       shared_info_frame);
+#endif
 
 	return 0;
 }
@@ -469,6 +475,18 @@
 
 MODULE_DEVICE_TABLE(pci, platform_pci_tbl);
 
+static const struct dmi_system_id platform_dmi_tbl[] = {
+	{
+		.ident = "Xen PV-on-HVM",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Xen"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "HVM domU"),
+		},
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(dmi, platform_dmi_tbl);
+
 static struct pci_driver platform_driver = {
 	name:     DRV_NAME,
 	probe:    platform_pci_init,
diff -Naur xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h
--- xen/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h	2013-03-09 18:06:26.236511944 -0700
+++ xen-b/unmodified_drivers/linux-2.6/platform-pci/platform-pci.h	2013-03-16 22:46:21.189845278 -0600
@@ -27,6 +27,11 @@
 unsigned long alloc_xen_mmio(unsigned long len);
 void platform_pci_resume(void);
 
+#ifdef CONFIG_ENLIGHTEN_SPINLOCKS
+#define shared_info_area xen_shared_info
+#endif
+extern void *shared_info_area;
+
 extern struct pci_dev *xen_platform_pdev;
 
 #endif /* _XEN_PLATFORM_PCI_H */
diff -Naur xen/xen/Makefile xen-b/xen/Makefile
--- xen/xen/Makefile	2013-03-09 18:06:26.246511944 -0700
+++ xen-b/xen/Makefile	2013-03-16 22:46:21.189845278 -0600
@@ -13,6 +13,8 @@
 export XEN_ROOT := $(BASEDIR)/..
 
 EFI_MOUNTPOINT ?= /boot/efi
+EFI_VENDOR=fedora
+LD_EFI ?= $(LD)
 
 .PHONY: default
 default: build
diff -Naur xen/xen/arch/arm/Rules.mk xen-b/xen/arch/arm/Rules.mk
--- xen/xen/arch/arm/Rules.mk	2013-03-09 18:06:26.246511944 -0700
+++ xen-b/xen/arch/arm/Rules.mk	2013-03-16 22:46:21.193178611 -0600
@@ -11,7 +11,7 @@
 HAS_ARM_HDLCD := y
 
 CFLAGS += -fno-builtin -fno-common -Wredundant-decls
-CFLAGS += -iwithprefix include -Werror -Wno-pointer-arith -pipe
+CFLAGS += -iwithprefix include -Wno-pointer-arith -pipe
 CFLAGS += -I$(BASEDIR)/include
 
 $(call cc-options-add,CFLAGS,CC,$(EMBEDDED_EXTRA_CFLAGS))
diff -Naur xen/xen/arch/arm/gic.c xen-b/xen/arch/arm/gic.c
--- xen/xen/arch/arm/gic.c	2013-03-09 18:06:26.249845278 -0700
+++ xen-b/xen/arch/arm/gic.c	2013-03-16 22:46:21.193178611 -0600
@@ -26,7 +26,6 @@
 #include <xen/errno.h>
 #include <xen/softirq.h>
 #include <xen/list.h>
-#include <xen/device_tree.h>
 #include <asm/p2m.h>
 #include <asm/domain.h>
 
@@ -43,7 +42,6 @@
     paddr_t dbase;       /* Address of distributor registers */
     paddr_t cbase;       /* Address of CPU interface registers */
     paddr_t hbase;       /* Address of virtual interface registers */
-    paddr_t vbase;       /* Address of virtual cpu interface registers */
     unsigned int lines;
     unsigned int cpus;
     spinlock_t lock;
@@ -334,10 +332,10 @@
          (early_info.gic.gic_vcpu_addr & ~PAGE_MASK) )
         panic("GIC interfaces not page aligned.\n");
 
-    gic.dbase = early_info.gic.gic_dist_addr;
-    gic.cbase = early_info.gic.gic_cpu_addr;
-    gic.hbase = early_info.gic.gic_hyp_addr;
-    gic.vbase = early_info.gic.gic_vcpu_addr;
+    /* XXX FIXME get this from devicetree */
+    gic.dbase = GIC_BASE_ADDRESS + GIC_DR_OFFSET;
+    gic.cbase = GIC_BASE_ADDRESS + GIC_CR_OFFSET;
+    gic.hbase = GIC_BASE_ADDRESS + GIC_HR_OFFSET;
     set_fixmap(FIXMAP_GICD, gic.dbase >> PAGE_SHIFT, DEV_SHARED);
     BUILD_BUG_ON(FIXMAP_ADDR(FIXMAP_GICC1) !=
                  FIXMAP_ADDR(FIXMAP_GICC2)-PAGE_SIZE);
@@ -612,9 +610,9 @@
 {
     /* map the gic virtual cpu interface in the gic cpu interface region of
      * the guest */
-    return map_mmio_regions(d, gic.cbase,
-                        gic.cbase + (2 * PAGE_SIZE) - 1,
-                        gic.vbase);
+    return map_mmio_regions(d, GIC_BASE_ADDRESS + GIC_CR_OFFSET,
+                        GIC_BASE_ADDRESS + GIC_CR_OFFSET + (2 * PAGE_SIZE) - 1,
+                        GIC_BASE_ADDRESS + GIC_VR_OFFSET);
 }
 
 static void maintenance_interrupt(int irq, void *dev_id, struct cpu_user_regs *regs)
diff -Naur xen/xen/arch/x86/Makefile xen-b/xen/arch/x86/Makefile
--- xen/xen/arch/x86/Makefile	2013-03-09 18:06:26.253178611 -0700
+++ xen-b/xen/arch/x86/Makefile	2013-03-16 22:46:21.193178611 -0600
@@ -112,7 +112,7 @@
 	    $(@D)/.$(@F).1.o -o $@
 	rm -f $(@D)/.$(@F).[0-9]*
 
-EFI_LDFLAGS = $(patsubst -m%,-mi386pep,$(LDFLAGS)) --subsystem=10
+EFI_LDFLAGS = -mi386pep $(patsubst -m%,-mi386pep,$(LDFLAGS)) --subsystem=10
 EFI_LDFLAGS += --image-base=$(1) --stack=0,0 --heap=0,0 --strip-debug
 EFI_LDFLAGS += --section-alignment=0x200000 --file-alignment=0x20
 EFI_LDFLAGS += --major-image-version=$(XEN_VERSION)
@@ -126,18 +126,18 @@
 $(TARGET).efi: guard = $(if $(shell echo efi/dis* | grep disabled),:)
 $(TARGET).efi: prelink-efi.o efi.lds efi/relocs-dummy.o $(BASEDIR)/common/symbols-dummy.o efi/mkreloc
 	$(foreach base, $(VIRT_BASE) $(ALT_BASE), \
-	          $(guard) $(LD) $(call EFI_LDFLAGS,$(base)) -T efi.lds -N $< efi/relocs-dummy.o \
+	          $(guard) $(LD_EFI) $(call EFI_LDFLAGS,$(base)) -T efi.lds -N $< efi/relocs-dummy.o \
 	                $(BASEDIR)/common/symbols-dummy.o -o $(@D)/.$(@F).$(base).0 &&) :
 	$(guard) efi/mkreloc $(foreach base,$(VIRT_BASE) $(ALT_BASE),$(@D)/.$(@F).$(base).0) >$(@D)/.$(@F).0r.S
 	$(guard) $(NM) -n $(@D)/.$(@F).$(VIRT_BASE).0 | $(guard) $(BASEDIR)/tools/symbols >$(@D)/.$(@F).0s.S
 	$(guard) $(MAKE) -f $(BASEDIR)/Rules.mk $(@D)/.$(@F).0r.o $(@D)/.$(@F).0s.o
 	$(foreach base, $(VIRT_BASE) $(ALT_BASE), \
-	          $(guard) $(LD) $(call EFI_LDFLAGS,$(base)) -T efi.lds -N $< \
+	          $(guard) $(LD_EFI) $(call EFI_LDFLAGS,$(base)) -T efi.lds -N $< \
 	                $(@D)/.$(@F).0r.o $(@D)/.$(@F).0s.o -o $(@D)/.$(@F).$(base).1 &&) :
 	$(guard) efi/mkreloc $(foreach base,$(VIRT_BASE) $(ALT_BASE),$(@D)/.$(@F).$(base).1) >$(@D)/.$(@F).1r.S
 	$(guard) $(NM) -n $(@D)/.$(@F).$(VIRT_BASE).1 | $(guard) $(BASEDIR)/tools/symbols >$(@D)/.$(@F).1s.S
 	$(guard) $(MAKE) -f $(BASEDIR)/Rules.mk $(@D)/.$(@F).1r.o $(@D)/.$(@F).1s.o
-	$(guard) $(LD) $(call EFI_LDFLAGS,$(VIRT_BASE)) -T efi.lds -N $< \
+	$(guard) $(LD_EFI) $(call EFI_LDFLAGS,$(VIRT_BASE)) -T efi.lds -N $< \
 	                $(@D)/.$(@F).1r.o $(@D)/.$(@F).1s.o -o $@
 	if $(guard) false; then rm -f $@; echo 'EFI support disabled'; fi
 	rm -f $(@D)/.$(@F).[0-9]*
diff -Naur xen/xen/arch/x86/Rules.mk xen-b/xen/arch/x86/Rules.mk
--- xen/xen/arch/x86/Rules.mk	2013-03-09 18:06:26.253178611 -0700
+++ xen-b/xen/arch/x86/Rules.mk	2013-03-16 22:46:21.193178611 -0600
@@ -26,7 +26,7 @@
 endif
 
 CFLAGS += -fno-builtin -fno-common -Wredundant-decls
-CFLAGS += -iwithprefix include -Werror -Wno-pointer-arith -pipe
+CFLAGS += -iwithprefix include -Wno-pointer-arith -pipe
 CFLAGS += -I$(BASEDIR)/include 
 CFLAGS += -I$(BASEDIR)/include/asm-x86/mach-generic
 CFLAGS += -I$(BASEDIR)/include/asm-x86/mach-default
diff -Naur xen/xen/arch/x86/efi/Makefile xen-b/xen/arch/x86/efi/Makefile
--- xen/xen/arch/x86/efi/Makefile	2013-03-09 18:06:26.273178611 -0700
+++ xen-b/xen/arch/x86/efi/Makefile	2013-03-16 22:46:21.193178611 -0600
@@ -6,7 +6,7 @@
 
 efi := $(filter y,$(x86_64)$(shell rm -f disabled))
 efi := $(if $(efi),$(shell $(CC) $(filter-out $(CFLAGS-y) .%.d,$(CFLAGS)) -c check.c 2>disabled && echo y))
-efi := $(if $(efi),$(shell $(LD) -mi386pep --subsystem=10 -o check.efi check.o 2>disabled && echo y))
+efi := $(if $(efi),$(shell $(LD_EFI) -mi386pep --subsystem=10 -o check.efi check.o 2>disabled && echo y))
 efi := $(if $(efi),$(shell rm disabled)y,$(shell $(call create,boot.init.o); $(call create,runtime.o)))
 
 extra-$(efi) += boot.init.o relocs-dummy.o runtime.o compat.o
diff -Naur xen/xen/arch/x86/hvm/stdvga.c xen-b/xen/arch/x86/hvm/stdvga.c
--- xen/xen/arch/x86/hvm/stdvga.c	2013-03-09 18:06:26.276511945 -0700
+++ xen-b/xen/arch/x86/hvm/stdvga.c	2013-03-16 22:46:21.193178611 -0600
@@ -135,7 +135,10 @@
 
     /* When in standard vga mode, emulate here all writes to the vram buffer
      * so we can immediately satisfy reads without waiting for qemu. */
-    s->stdvga = (s->sr[7] == 0x00);
+    s->stdvga =
+        (s->sr[7] == 0x00) &&  /* standard vga mode */
+        (s->gr[6] == 0x05);    /* misc graphics register w/ MemoryMapSelect=1
+                                * 0xa0000-0xaffff (64k region), AlphaDis=1 */
 
     if ( !prev_stdvga && s->stdvga )
     {
diff -Naur xen/xen/arch/x86/io_apic.c xen-b/xen/arch/x86/io_apic.c
--- xen/xen/arch/x86/io_apic.c	2013-03-09 18:06:26.283178610 -0700
+++ xen-b/xen/arch/x86/io_apic.c	2013-03-16 22:46:21.193178611 -0600
@@ -1995,7 +1995,10 @@
         io_apic_irqs = ~PIC_IRQS;
 
     printk("ENABLING IO-APIC IRQs\n");
-    printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    if (!directed_eoi_enabled && !ioapic_ack_forced) {
+        ioapic_ack_new = (nr_ioapics > 1);
+        printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    }
 
     if (ioapic_ack_new) {
         ioapic_level_type.ack = irq_complete_move;
diff -Naur xen/xen/arch/x86/platform_hypercall.c xen-b/xen/arch/x86/platform_hypercall.c
--- xen/xen/arch/x86/platform_hypercall.c	2013-03-09 18:06:26.303178611 -0700
+++ xen-b/xen/arch/x86/platform_hypercall.c	2013-03-16 22:46:21.193178611 -0600
@@ -25,7 +25,7 @@
 #include <xen/irq.h>
 #include <asm/current.h>
 #include <public/platform.h>
-#include <acpi/cpufreq/processor_perf.h>
+#include <acpi/cpufreq/cpufreq.h>
 #include <asm/edd.h>
 #include <asm/mtrr.h>
 #include <asm/io_apic.h>
@@ -597,6 +597,41 @@
     }
     break;
 
+    case XENPF_get_cpu_freq:
+    case XENPF_get_cpu_freq_min:
+    case XENPF_get_cpu_freq_max:
+    {
+        struct vcpu *v;
+        const struct cpufreq_policy *policy;
+
+        if ( op->u.get_cpu_freq.vcpu >= current->domain->max_vcpus ||
+             !(v = current->domain->vcpu[op->u.get_cpu_freq.vcpu]) )
+        {
+            ret = -EINVAL;
+            break;
+        }
+
+        policy = per_cpu(cpufreq_cpu_policy, v->processor);
+        switch ( op->cmd & -!!policy )
+        {
+        case XENPF_get_cpu_freq:
+            op->u.get_cpu_freq.freq = policy->cur;
+            break;
+        case XENPF_get_cpu_freq_min:
+            op->u.get_cpu_freq.freq = policy->min;
+            break;
+        case XENPF_get_cpu_freq_max:
+            op->u.get_cpu_freq.freq = policy->max;
+            break;
+        default:
+            op->u.get_cpu_freq.freq = 0;
+            break;
+        }
+        if ( copy_field_to_guest(u_xenpf_op, op, u.get_cpu_freq.freq) )
+            ret = -EFAULT;
+    }
+    break;
+
     default:
         ret = -ENOSYS;
         break;
diff -Naur xen/xen/arch/x86/x86_64/entry.S xen-b/xen/arch/x86/x86_64/entry.S
--- xen/xen/arch/x86/x86_64/entry.S	2013-03-12 14:53:23.459845278 -0600
+++ xen-b/xen/arch/x86/x86_64/entry.S	2013-03-16 22:46:21.193178611 -0600
@@ -426,22 +426,35 @@
         jz    domain_crash_synchronous
         movq  %rax,UREGS_rip+8(%rsp)
         ret
-        _ASM_EXTABLE(.Lft2,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft3,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft4,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft5,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft6,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft7,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft8,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft9,  domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft10, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft11, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft12, domain_crash_synchronous)
-        _ASM_EXTABLE(.Lft13, domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft2,  domain_crash_page_fault_32)
+        _ASM_EXTABLE(.Lft3,  domain_crash_page_fault_24)
+        _ASM_EXTABLE(.Lft4,  domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft5,  domain_crash_page_fault_16)
+        _ASM_EXTABLE(.Lft6,  domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft7,  domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft8,  domain_crash_page_fault_24)
+        _ASM_EXTABLE(.Lft9,  domain_crash_page_fault_16)
+        _ASM_EXTABLE(.Lft10, domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft11, domain_crash_page_fault)
+        _ASM_EXTABLE(.Lft12, domain_crash_page_fault_8)
+        _ASM_EXTABLE(.Lft13, domain_crash_page_fault)
 
+.section .rodata, "a", @progbits
 domain_crash_synchronous_string:
         .asciz "domain_crash_sync called from entry.S\n"
+.previous
 
+domain_crash_page_fault_32:
+        addq  $8,%rsi
+domain_crash_page_fault_24:
+        addq  $8,%rsi
+domain_crash_page_fault_16:
+        addq  $8,%rsi
+domain_crash_page_fault_8:
+        addq  $8,%rsi
+domain_crash_page_fault:
+        movq  %rsi,%rdi
+        call  show_page_walk
 ENTRY(domain_crash_synchronous)
         # Get out of the guest-save area of the stack.
         GET_STACK_BASE(%rax)
diff -Naur xen/xen/arch/x86/x86_64/entry.S.orig xen-b/xen/arch/x86/x86_64/entry.S.orig
--- xen/xen/arch/x86/x86_64/entry.S.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/xen/arch/x86/x86_64/entry.S.orig	2013-03-12 14:53:23.459845278 -0600
@@ -0,0 +1,812 @@
+/*
+ * Hypercall and fault low-level handling routines.
+ *
+ * Copyright (c) 2005, K A Fraser
+ */
+
+#include <xen/config.h>
+#include <xen/errno.h>
+#include <xen/softirq.h>
+#include <asm/asm_defns.h>
+#include <asm/apicdef.h>
+#include <asm/page.h>
+#include <public/xen.h>
+#include <irq_vectors.h>
+
+        ALIGN
+/* %rbx: struct vcpu */
+switch_to_kernel:
+        leaq  VCPU_trap_bounce(%rbx),%rdx
+        /* TB_eip = (32-bit syscall && syscall32_addr) ?
+         *          syscall32_addr : syscall_addr */
+        xor   %eax,%eax
+        cmpw  $FLAT_USER_CS32,UREGS_cs(%rsp)
+        cmoveq VCPU_syscall32_addr(%rbx),%rax
+        testq %rax,%rax
+        cmovzq VCPU_syscall_addr(%rbx),%rax
+        movq  %rax,TRAPBOUNCE_eip(%rdx)
+        /* TB_flags = VGCF_syscall_disables_events ? TBF_INTERRUPT : 0 */
+        btl   $_VGCF_syscall_disables_events,VCPU_guest_context_flags(%rbx)
+        setc  %cl
+        leal  (,%rcx,TBF_INTERRUPT),%ecx
+        movb  %cl,TRAPBOUNCE_flags(%rdx)
+        call  create_bounce_frame
+        andl  $~X86_EFLAGS_DF,UREGS_eflags(%rsp)
+        jmp   test_all_events
+
+/* %rbx: struct vcpu, interrupts disabled */
+restore_all_guest:
+        ASSERT_INTERRUPTS_DISABLED
+        RESTORE_ALL
+        testw $TRAP_syscall,4(%rsp)
+        jz    iret_exit_to_guest
+
+        /* Don't use SYSRET path if the return address is not canonical. */
+        movq  8(%rsp),%rcx
+        sarq  $47,%rcx
+        incl  %ecx
+        cmpl  $1,%ecx
+        ja    .Lforce_iret
+
+        cmpw  $FLAT_USER_CS32,16(%rsp)# CS
+        movq  8(%rsp),%rcx            # RIP
+        movq  24(%rsp),%r11           # RFLAGS
+        movq  32(%rsp),%rsp           # RSP
+        je    1f
+        sysretq
+1:      sysretl
+
+.Lforce_iret:
+        /* Mimic SYSRET behavior. */
+        movq  8(%rsp),%rcx            # RIP
+        movq  24(%rsp),%r11           # RFLAGS
+        ALIGN
+/* No special register assumptions. */
+iret_exit_to_guest:
+        addq  $8,%rsp
+.Lft0:  iretq
+
+.section .fixup,"ax"
+.Lfx0:  sti
+        SAVE_ALL
+        movq  UREGS_error_code(%rsp),%rsi
+        movq  %rsp,%rax
+        andq  $~0xf,%rsp
+        pushq $__HYPERVISOR_DS         # SS
+        pushq %rax                     # RSP
+        pushfq                         # RFLAGS
+        pushq $__HYPERVISOR_CS         # CS
+        leaq  .Ldf0(%rip),%rax
+        pushq %rax                     # RIP
+        pushq %rsi                     # error_code/entry_vector
+        jmp   handle_exception
+.Ldf0:  GET_CURRENT(%rbx)
+        jmp   test_all_events
+failsafe_callback:
+        GET_CURRENT(%rbx)
+        leaq  VCPU_trap_bounce(%rbx),%rdx
+        movq  VCPU_failsafe_addr(%rbx),%rax
+        movq  %rax,TRAPBOUNCE_eip(%rdx)
+        movb  $TBF_FAILSAFE,TRAPBOUNCE_flags(%rdx)
+        bt    $_VGCF_failsafe_disables_events,VCPU_guest_context_flags(%rbx)
+        jnc   1f
+        orb   $TBF_INTERRUPT,TRAPBOUNCE_flags(%rdx)
+1:      call  create_bounce_frame
+        jmp   test_all_events
+.previous
+        _ASM_PRE_EXTABLE(.Lft0, .Lfx0)
+        _ASM_EXTABLE(.Ldf0, failsafe_callback)
+
+        ALIGN
+/* No special register assumptions. */
+restore_all_xen:
+        RESTORE_ALL adj=8
+        iretq
+
+/*
+ * When entering SYSCALL from kernel mode:
+ *  %rax                            = hypercall vector
+ *  %rdi, %rsi, %rdx, %r10, %r8, %9 = hypercall arguments
+ *  %rcx                            = SYSCALL-saved %rip
+ *  NB. We must move %r10 to %rcx for C function-calling ABI.
+ *
+ * When entering SYSCALL from user mode:
+ *  Vector directly to the registered arch.syscall_addr.
+ *
+ * Initial work is done by per-CPU stack trampolines. At this point %rsp
+ * has been initialised to point at the correct Xen stack, and %rsp, %rflags
+ * and %cs have been saved. All other registers are still to be saved onto
+ * the stack, starting with %rip, and an appropriate %ss must be saved into
+ * the space left by the trampoline.
+ */
+ENTRY(syscall_enter)
+        sti
+        movl  $FLAT_KERNEL_SS,24(%rsp)
+        pushq %rcx
+        pushq $0
+        movq  24(%rsp),%r11 /* Re-load user RFLAGS into %r11 before saving */
+        SAVE_VOLATILE TRAP_syscall
+        GET_CURRENT(%rbx)
+        movq  VCPU_domain(%rbx),%rcx
+        testb $1,DOMAIN_is_32bit_pv(%rcx)
+        jnz   compat_syscall
+        testb $TF_kernel_mode,VCPU_thread_flags(%rbx)
+        jz    switch_to_kernel
+
+/*hypercall:*/
+        movq  %r10,%rcx
+        cmpq  $NR_hypercalls,%rax
+        jae   bad_hypercall
+#ifndef NDEBUG
+        /* Deliberately corrupt parameter regs not used by this hypercall. */
+        pushq %rdi; pushq %rsi; pushq %rdx; pushq %rcx; pushq %r8 ; pushq %r9 
+        leaq  hypercall_args_table(%rip),%r10
+        movq  $6,%rcx
+        sub   (%r10,%rax,1),%cl
+        movq  %rsp,%rdi
+        movl  $0xDEADBEEF,%eax
+        rep   stosq
+        popq  %r9 ; popq  %r8 ; popq  %rcx; popq  %rdx; popq  %rsi; popq  %rdi
+        movq  UREGS_rax(%rsp),%rax
+        pushq %rax
+        pushq UREGS_rip+8(%rsp)
+#define SHADOW_BYTES 16 /* Shadow EIP + shadow hypercall # */
+#else
+#define SHADOW_BYTES 0  /* No on-stack shadow state */
+#endif
+        cmpb  $0,tb_init_done(%rip)
+UNLIKELY_START(ne, trace)
+        call  __trace_hypercall_entry
+        /* Restore the registers that __trace_hypercall_entry clobbered. */
+        movq  UREGS_rax+SHADOW_BYTES(%rsp),%rax   /* Hypercall #  */
+        movq  UREGS_rdi+SHADOW_BYTES(%rsp),%rdi   /* Arg 1        */
+        movq  UREGS_rsi+SHADOW_BYTES(%rsp),%rsi   /* Arg 2        */
+        movq  UREGS_rdx+SHADOW_BYTES(%rsp),%rdx   /* Arg 3        */
+        movq  UREGS_r10+SHADOW_BYTES(%rsp),%rcx   /* Arg 4        */
+        movq  UREGS_r8 +SHADOW_BYTES(%rsp),%r8    /* Arg 5        */
+        movq  UREGS_r9 +SHADOW_BYTES(%rsp),%r9    /* Arg 6        */
+#undef SHADOW_BYTES
+UNLIKELY_END(trace)
+        leaq  hypercall_table(%rip),%r10
+        PERFC_INCR(hypercalls, %rax, %rbx)
+        callq *(%r10,%rax,8)
+#ifndef NDEBUG
+        /* Deliberately corrupt parameter regs used by this hypercall. */
+        popq  %r10         # Shadow RIP
+        cmpq  %r10,UREGS_rip+8(%rsp)
+        popq  %rcx         # Shadow hypercall index
+        jne   skip_clobber /* If RIP has changed then don't clobber. */
+        leaq  hypercall_args_table(%rip),%r10
+        movb  (%r10,%rcx,1),%cl
+        movl  $0xDEADBEEF,%r10d
+        cmpb  $1,%cl; jb skip_clobber; movq %r10,UREGS_rdi(%rsp)
+        cmpb  $2,%cl; jb skip_clobber; movq %r10,UREGS_rsi(%rsp)
+        cmpb  $3,%cl; jb skip_clobber; movq %r10,UREGS_rdx(%rsp)
+        cmpb  $4,%cl; jb skip_clobber; movq %r10,UREGS_r10(%rsp)
+        cmpb  $5,%cl; jb skip_clobber; movq %r10,UREGS_r8(%rsp)
+        cmpb  $6,%cl; jb skip_clobber; movq %r10,UREGS_r9(%rsp)
+skip_clobber:
+#endif
+        movq  %rax,UREGS_rax(%rsp)       # save the return value
+
+/* %rbx: struct vcpu */
+test_all_events:
+        ASSERT_NOT_IN_ATOMIC
+        cli                             # tests must not race interrupts
+/*test_softirqs:*/  
+        movl  VCPU_processor(%rbx),%eax
+        shll  $IRQSTAT_shift,%eax
+        leaq  irq_stat+IRQSTAT_softirq_pending(%rip),%rcx
+        cmpl  $0,(%rcx,%rax,1)
+        jne   process_softirqs
+        testb $1,VCPU_mce_pending(%rbx)
+        jnz   process_mce
+.Ltest_guest_nmi:
+        testb $1,VCPU_nmi_pending(%rbx)
+        jnz   process_nmi
+test_guest_events:
+        movq  VCPU_vcpu_info(%rbx),%rax
+        movzwl VCPUINFO_upcall_pending(%rax),%eax
+        decl  %eax
+        cmpl  $0xfe,%eax
+        ja    restore_all_guest
+/*process_guest_events:*/
+        sti
+        leaq  VCPU_trap_bounce(%rbx),%rdx
+        movq  VCPU_event_addr(%rbx),%rax
+        movq  %rax,TRAPBOUNCE_eip(%rdx)
+        movb  $TBF_INTERRUPT,TRAPBOUNCE_flags(%rdx)
+        call  create_bounce_frame
+        jmp   test_all_events
+
+        ALIGN
+/* %rbx: struct vcpu */
+process_softirqs:
+        sti       
+        SAVE_PRESERVED
+        call do_softirq
+        jmp  test_all_events
+
+        ALIGN
+/* %rbx: struct vcpu */
+process_mce:
+        testb $1 << VCPU_TRAP_MCE,VCPU_async_exception_mask(%rbx)
+        jnz  .Ltest_guest_nmi
+        sti
+        movb $0,VCPU_mce_pending(%rbx)
+        call set_guest_machinecheck_trapbounce
+        test %eax,%eax
+        jz   test_all_events
+        movzbl VCPU_async_exception_mask(%rbx),%edx # save mask for the
+        movb %dl,VCPU_mce_old_mask(%rbx)            # iret hypercall
+        orl  $1 << VCPU_TRAP_MCE,%edx
+        movb %dl,VCPU_async_exception_mask(%rbx)
+        jmp  process_trap
+
+        ALIGN
+/* %rbx: struct vcpu */
+process_nmi:
+        testb $1 << VCPU_TRAP_NMI,VCPU_async_exception_mask(%rbx)
+        jnz  test_guest_events
+        sti
+        movb $0,VCPU_nmi_pending(%rbx)
+        call set_guest_nmi_trapbounce
+        test %eax,%eax
+        jz   test_all_events
+        movzbl VCPU_async_exception_mask(%rbx),%edx # save mask for the
+        movb %dl,VCPU_nmi_old_mask(%rbx)            # iret hypercall
+        orl  $1 << VCPU_TRAP_NMI,%edx
+        movb %dl,VCPU_async_exception_mask(%rbx)
+        /* FALLTHROUGH */
+process_trap:
+        leaq VCPU_trap_bounce(%rbx),%rdx
+        call create_bounce_frame
+        jmp  test_all_events
+
+bad_hypercall:
+        movq $-ENOSYS,UREGS_rax(%rsp)
+        jmp  test_all_events
+
+ENTRY(sysenter_entry)
+        sti
+        pushq $FLAT_USER_SS
+        pushq $0
+        pushfq
+        .globl sysenter_eflags_saved
+sysenter_eflags_saved:
+        pushq $3 /* ring 3 null cs */
+        pushq $0 /* null rip */
+        pushq $0
+        SAVE_VOLATILE TRAP_syscall
+        GET_CURRENT(%rbx)
+        cmpb  $0,VCPU_sysenter_disables_events(%rbx)
+        movq  VCPU_sysenter_addr(%rbx),%rax
+        setne %cl
+        leaq  VCPU_trap_bounce(%rbx),%rdx
+        testq %rax,%rax
+        leal  (,%rcx,TBF_INTERRUPT),%ecx
+UNLIKELY_START(z, sysenter_gpf)
+        movq  VCPU_trap_ctxt(%rbx),%rsi
+        SAVE_PRESERVED
+        movl  $TRAP_gp_fault,UREGS_entry_vector(%rsp)
+        movl  %eax,TRAPBOUNCE_error_code(%rdx)
+        movq  TRAP_gp_fault * TRAPINFO_sizeof + TRAPINFO_eip(%rsi),%rax
+        testb $4,TRAP_gp_fault * TRAPINFO_sizeof + TRAPINFO_flags(%rsi)
+        setnz %cl
+        leal  TBF_EXCEPTION|TBF_EXCEPTION_ERRCODE(,%rcx,TBF_INTERRUPT),%ecx
+UNLIKELY_END(sysenter_gpf)
+        movq  VCPU_domain(%rbx),%rdi
+        movq  %rax,TRAPBOUNCE_eip(%rdx)
+        movb  %cl,TRAPBOUNCE_flags(%rdx)
+        testb $1,DOMAIN_is_32bit_pv(%rdi)
+        jnz   compat_sysenter
+        jmp   .Lbounce_exception
+
+ENTRY(int80_direct_trap)
+        pushq $0
+        SAVE_VOLATILE 0x80
+
+        cmpb  $0,untrusted_msi(%rip)
+UNLIKELY_START(ne, msi_check)
+        movl  $0x80,%edi
+        call  check_for_unexpected_msi
+        LOAD_C_CLOBBERED
+UNLIKELY_END(msi_check)
+
+        GET_CURRENT(%rbx)
+
+        /* Check that the callback is non-null. */
+        leaq  VCPU_int80_bounce(%rbx),%rdx
+        cmpb  $0,TRAPBOUNCE_flags(%rdx)
+        jz    int80_slow_path
+
+        movq  VCPU_domain(%rbx),%rax
+        testb $1,DOMAIN_is_32bit_pv(%rax)
+        jnz   compat_int80_direct_trap
+
+        call  create_bounce_frame
+        jmp   test_all_events
+
+int80_slow_path:
+        /* 
+         * Setup entry vector and error code as if this was a GPF caused by an
+         * IDT entry with DPL==0.
+         */
+        movl  $((0x80 << 3) | 0x2),UREGS_error_code(%rsp)
+        SAVE_PRESERVED
+        movl  $TRAP_gp_fault,UREGS_entry_vector(%rsp)
+        /* A GPF wouldn't have incremented the instruction pointer. */
+        subq  $2,UREGS_rip(%rsp)
+        jmp   handle_exception_saved
+
+/* CREATE A BASIC EXCEPTION FRAME ON GUEST OS STACK:                     */
+/*   { RCX, R11, [DS-GS,] [CR2,] [ERRCODE,] RIP, CS, RFLAGS, RSP, SS }   */
+/* %rdx: trap_bounce, %rbx: struct vcpu                                  */
+/* On return only %rbx and %rdx are guaranteed non-clobbered.            */
+create_bounce_frame:
+        ASSERT_INTERRUPTS_ENABLED
+        testb $TF_kernel_mode,VCPU_thread_flags(%rbx)
+        jnz   1f
+        /* Push new frame at registered guest-OS stack base. */
+        pushq %rdx
+        movq  %rbx,%rdi
+        call  toggle_guest_mode
+        popq  %rdx
+        movq  VCPU_kernel_sp(%rbx),%rsi
+        jmp   2f
+1:      /* In kernel context already: push new frame at existing %rsp. */
+        movq  UREGS_rsp+8(%rsp),%rsi
+        andb  $0xfc,UREGS_cs+8(%rsp)    # Indicate kernel context to guest.
+2:      andq  $~0xf,%rsi                # Stack frames are 16-byte aligned.
+        movq  $HYPERVISOR_VIRT_START,%rax
+        cmpq  %rax,%rsi
+        movq  $HYPERVISOR_VIRT_END+60,%rax
+        sbb   %ecx,%ecx                 # In +ve address space? Then okay.
+        cmpq  %rax,%rsi
+        adc   %ecx,%ecx                 # Above Xen private area? Then okay.
+        jg    domain_crash_synchronous
+        movb  TRAPBOUNCE_flags(%rdx),%cl
+        subq  $40,%rsi
+        movq  UREGS_ss+8(%rsp),%rax
+.Lft2:  movq  %rax,32(%rsi)             # SS
+        movq  UREGS_rsp+8(%rsp),%rax
+.Lft3:  movq  %rax,24(%rsi)             # RSP
+        movq  VCPU_vcpu_info(%rbx),%rax
+        pushq VCPUINFO_upcall_mask(%rax)
+        testb $TBF_INTERRUPT,%cl
+        setnz %ch                       # TBF_INTERRUPT -> set upcall mask
+        orb   %ch,VCPUINFO_upcall_mask(%rax)
+        popq  %rax
+        shlq  $32,%rax                  # Bits 32-39: saved_upcall_mask
+        movw  UREGS_cs+8(%rsp),%ax      # Bits  0-15: CS
+.Lft4:  movq  %rax,8(%rsi)              # CS / saved_upcall_mask
+        shrq  $32,%rax
+        testb $0xFF,%al                 # Bits 0-7: saved_upcall_mask
+        setz  %ch                       # %ch == !saved_upcall_mask
+        movl  UREGS_eflags+8(%rsp),%eax
+        andl  $~X86_EFLAGS_IF,%eax
+        addb  %ch,%ch                   # Bit 9 (EFLAGS.IF)
+        orb   %ch,%ah                   # Fold EFLAGS.IF into %eax
+.Lft5:  movq  %rax,16(%rsi)             # RFLAGS
+        movq  UREGS_rip+8(%rsp),%rax
+.Lft6:  movq  %rax,(%rsi)               # RIP
+        testb $TBF_EXCEPTION_ERRCODE,%cl
+        jz    1f
+        subq  $8,%rsi
+        movl  TRAPBOUNCE_error_code(%rdx),%eax
+.Lft7:  movq  %rax,(%rsi)               # ERROR CODE
+1:      testb $TBF_FAILSAFE,%cl
+UNLIKELY_START(nz, bounce_failsafe)
+        subq  $32,%rsi
+        movl  %gs,%eax
+.Lft8:  movq  %rax,24(%rsi)             # GS
+        movl  %fs,%eax
+.Lft9:  movq  %rax,16(%rsi)             # FS
+        movl  %es,%eax
+.Lft10: movq  %rax,8(%rsi)              # ES
+        movl  %ds,%eax
+.Lft11: movq  %rax,(%rsi)               # DS
+UNLIKELY_END(bounce_failsafe)
+        subq  $16,%rsi
+        movq  UREGS_r11+8(%rsp),%rax
+.Lft12: movq  %rax,8(%rsi)              # R11
+        movq  UREGS_rcx+8(%rsp),%rax
+.Lft13: movq  %rax,(%rsi)               # RCX
+        /* Rewrite our stack frame and return to guest-OS mode. */
+        /* IA32 Ref. Vol. 3: TF, VM, RF and NT flags are cleared on trap. */
+        /* Also clear AC: alignment checks shouldn't trigger in kernel mode. */
+        orl   $TRAP_syscall,UREGS_entry_vector+8(%rsp)
+        andl  $~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF|\
+                 X86_EFLAGS_NT|X86_EFLAGS_TF),UREGS_eflags+8(%rsp)
+        movq  $FLAT_KERNEL_SS,UREGS_ss+8(%rsp)
+        movq  %rsi,UREGS_rsp+8(%rsp)
+        movq  $FLAT_KERNEL_CS,UREGS_cs+8(%rsp)
+        movq  TRAPBOUNCE_eip(%rdx),%rax
+        testq %rax,%rax
+        jz    domain_crash_synchronous
+        movq  %rax,UREGS_rip+8(%rsp)
+        ret
+        _ASM_EXTABLE(.Lft2,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft3,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft4,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft5,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft6,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft7,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft8,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft9,  domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft10, domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft11, domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft12, domain_crash_synchronous)
+        _ASM_EXTABLE(.Lft13, domain_crash_synchronous)
+
+domain_crash_synchronous_string:
+        .asciz "domain_crash_sync called from entry.S\n"
+
+ENTRY(domain_crash_synchronous)
+        # Get out of the guest-save area of the stack.
+        GET_STACK_BASE(%rax)
+        leaq  STACK_CPUINFO_FIELD(guest_cpu_user_regs)(%rax),%rsp
+        # create_bounce_frame() temporarily clobbers CS.RPL. Fix up.
+        __GET_CURRENT(%rax)
+        movq  VCPU_domain(%rax),%rax
+        testb $1,DOMAIN_is_32bit_pv(%rax)
+        setz  %al
+        leal  (%rax,%rax,2),%eax
+        orb   %al,UREGS_cs(%rsp)
+        # printk(domain_crash_synchronous_string)
+        leaq  domain_crash_synchronous_string(%rip),%rdi
+        xorl  %eax,%eax
+        call  printk
+        jmp  __domain_crash_synchronous
+
+/* No special register assumptions. */
+ENTRY(ret_from_intr)
+        GET_CURRENT(%rbx)
+        testb $3,UREGS_cs(%rsp)
+        jz    restore_all_xen
+        movq  VCPU_domain(%rbx),%rax
+        testb $1,DOMAIN_is_32bit_pv(%rax)
+        jz    test_all_events
+        jmp   compat_test_all_events
+
+ENTRY(page_fault)
+        movl  $TRAP_page_fault,4(%rsp)
+/* No special register assumptions. */
+	.globl handle_exception
+handle_exception:
+        SAVE_ALL
+handle_exception_saved:
+        testb $X86_EFLAGS_IF>>8,UREGS_eflags+1(%rsp)
+        jz    exception_with_ints_disabled
+        sti
+1:      movq  %rsp,%rdi
+        movzbl UREGS_entry_vector(%rsp),%eax
+        leaq  exception_table(%rip),%rdx
+        GET_CURRENT(%rbx)
+        PERFC_INCR(exceptions, %rax, %rbx)
+        callq *(%rdx,%rax,8)
+        testb $3,UREGS_cs(%rsp)
+        jz    restore_all_xen
+        leaq  VCPU_trap_bounce(%rbx),%rdx
+        movq  VCPU_domain(%rbx),%rax
+        testb $1,DOMAIN_is_32bit_pv(%rax)
+        jnz   compat_post_handle_exception
+        testb $TBF_EXCEPTION,TRAPBOUNCE_flags(%rdx)
+        jz    test_all_events
+.Lbounce_exception:
+        call  create_bounce_frame
+        movb  $0,TRAPBOUNCE_flags(%rdx)
+        jmp   test_all_events
+
+/* No special register assumptions. */
+exception_with_ints_disabled:
+        testb $3,UREGS_cs(%rsp)         # interrupts disabled outside Xen?
+        jnz   FATAL_exception_with_ints_disabled
+        movq  %rsp,%rdi
+        call  search_pre_exception_table
+        testq %rax,%rax                 # no fixup code for faulting EIP?
+        jz    1b
+        movq  %rax,UREGS_rip(%rsp)
+        subq  $8,UREGS_rsp(%rsp)        # add ec/ev to previous stack frame
+        testb $15,UREGS_rsp(%rsp)       # return %rsp is now aligned?
+        jz    1f                        # then there is a pad quadword already
+        movq  %rsp,%rsi
+        subq  $8,%rsp
+        movq  %rsp,%rdi
+        movq  $UREGS_kernel_sizeof/8,%rcx
+        rep;  movsq                     # make room for ec/ev
+1:      movq  UREGS_error_code(%rsp),%rax # ec/ev
+        movq  %rax,UREGS_kernel_sizeof(%rsp)
+        jmp   restore_all_xen           # return to fixup code
+
+/* No special register assumptions. */
+FATAL_exception_with_ints_disabled:
+        movzbl UREGS_entry_vector(%rsp),%edi
+        movq  %rsp,%rsi
+        call  fatal_trap
+        ud2
+
+ENTRY(divide_error)
+        pushq $0
+        movl  $TRAP_divide_error,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(coprocessor_error)
+        pushq $0
+        movl  $TRAP_copro_error,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(simd_coprocessor_error)
+        pushq $0
+        movl  $TRAP_simd_error,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(device_not_available)
+        pushq $0
+        movl  $TRAP_no_device,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(debug)
+        pushq $0
+        movl  $TRAP_debug,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(int3)
+        pushq $0
+        movl  $TRAP_int3,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(overflow)
+        pushq $0
+        movl  $TRAP_overflow,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(bounds)
+        pushq $0
+        movl  $TRAP_bounds,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(invalid_op)
+        pushq $0
+        movl  $TRAP_invalid_op,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(coprocessor_segment_overrun)
+        pushq $0
+        movl  $TRAP_copro_seg,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(invalid_TSS)
+        movl  $TRAP_invalid_tss,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(segment_not_present)
+        movl  $TRAP_no_segment,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(stack_segment)
+        movl  $TRAP_stack_error,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(general_protection)
+        movl  $TRAP_gp_fault,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(alignment_check)
+        movl  $TRAP_alignment_check,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(spurious_interrupt_bug)
+        pushq $0
+        movl  $TRAP_spurious_int,4(%rsp)
+        jmp   handle_exception
+
+ENTRY(double_fault)
+        movl  $TRAP_double_fault,4(%rsp)
+        SAVE_ALL
+        movq  %rsp,%rdi
+        call  do_double_fault
+        ud2
+
+        .pushsection .init.text, "ax", @progbits
+ENTRY(early_page_fault)
+        SAVE_ALL
+        movq  %rsp,%rdi
+        call  do_early_page_fault
+        jmp   restore_all_xen
+        .popsection
+
+ENTRY(nmi)
+        pushq $0
+        movl  $TRAP_nmi,4(%rsp)
+handle_ist_exception:
+        SAVE_ALL
+        testb $3,UREGS_cs(%rsp)
+        jz    1f
+        /* Interrupted guest context. Copy the context to stack bottom. */
+        GET_CPUINFO_FIELD(guest_cpu_user_regs,%rdi)
+        movq  %rsp,%rsi
+        movl  $UREGS_kernel_sizeof/8,%ecx
+        movq  %rdi,%rsp
+        rep   movsq
+1:      movq  %rsp,%rdi
+        movzbl UREGS_entry_vector(%rsp),%eax
+        leaq  exception_table(%rip),%rdx
+        callq *(%rdx,%rax,8)
+        cmpb  $TRAP_nmi,UREGS_entry_vector(%rsp)
+        jne   ret_from_intr
+
+        /* We want to get straight to the IRET on the NMI exit path. */
+        testb $3,UREGS_cs(%rsp)
+        jz    restore_all_xen
+        GET_CURRENT(%rbx)
+        /* Send an IPI to ourselves to cover for the lack of event checking. */
+        movl  VCPU_processor(%rbx),%eax
+        shll  $IRQSTAT_shift,%eax
+        leaq  irq_stat+IRQSTAT_softirq_pending(%rip),%rcx
+        cmpl  $0,(%rcx,%rax,1)
+        je    1f
+        movl  $EVENT_CHECK_VECTOR,%edi
+        call  send_IPI_self
+1:      movq  VCPU_domain(%rbx),%rax
+        cmpb  $0,DOMAIN_is_32bit_pv(%rax)
+        je    restore_all_guest
+        jmp   compat_restore_all_guest
+
+ENTRY(nmi_crash)
+        pushq $0
+        movl $TRAP_nmi,4(%rsp)
+        SAVE_ALL
+        movq %rsp,%rdi
+        callq do_nmi_crash /* Does not return */
+        ud2
+
+ENTRY(machine_check)
+        pushq $0
+        movl  $TRAP_machine_check,4(%rsp)
+        jmp   handle_ist_exception
+
+/* Enable NMIs.  No special register assumptions. Only %rax is not preserved. */
+ENTRY(enable_nmis)
+        movq  %rsp, %rax /* Grab RSP before pushing */
+
+        /* Set up stack frame */
+        pushq $0               /* SS */
+        pushq %rax             /* RSP */
+        pushfq                 /* RFLAGS */
+        pushq $__HYPERVISOR_CS /* CS */
+        leaq  1f(%rip),%rax
+        pushq %rax             /* RIP */
+
+        iretq /* Disable the hardware NMI latch */
+1:
+        retq
+
+/* No op trap handler.  Required for kexec crash path.  This is not
+ * declared with the ENTRY() macro to avoid wasted alignment space.
+ */
+.globl trap_nop
+trap_nop:
+        iretq
+
+
+
+.section .rodata, "a", @progbits
+
+ENTRY(exception_table)
+        .quad do_divide_error
+        .quad do_debug
+        .quad do_nmi
+        .quad do_int3
+        .quad do_overflow
+        .quad do_bounds
+        .quad do_invalid_op
+        .quad do_device_not_available
+        .quad 0 # double_fault
+        .quad do_coprocessor_segment_overrun
+        .quad do_invalid_TSS
+        .quad do_segment_not_present
+        .quad do_stack_segment
+        .quad do_general_protection
+        .quad do_page_fault
+        .quad do_spurious_interrupt_bug
+        .quad do_coprocessor_error
+        .quad do_alignment_check
+        .quad do_machine_check
+        .quad do_simd_coprocessor_error
+
+ENTRY(hypercall_table)
+        .quad do_set_trap_table     /*  0 */
+        .quad do_mmu_update
+        .quad do_set_gdt
+        .quad do_stack_switch
+        .quad do_set_callbacks
+        .quad do_fpu_taskswitch     /*  5 */
+        .quad do_sched_op_compat
+        .quad do_platform_op
+        .quad do_set_debugreg
+        .quad do_get_debugreg
+        .quad do_update_descriptor  /* 10 */
+        .quad do_ni_hypercall
+        .quad do_memory_op
+        .quad do_multicall
+        .quad do_update_va_mapping
+        .quad do_set_timer_op       /* 15 */
+        .quad do_event_channel_op_compat
+        .quad do_xen_version
+        .quad do_console_io
+        .quad do_physdev_op_compat
+        .quad do_grant_table_op     /* 20 */
+        .quad do_vm_assist
+        .quad do_update_va_mapping_otherdomain
+        .quad do_iret
+        .quad do_vcpu_op
+        .quad do_set_segment_base   /* 25 */
+        .quad do_mmuext_op
+        .quad do_xsm_op
+        .quad do_nmi_op
+        .quad do_sched_op
+        .quad do_callback_op        /* 30 */
+        .quad do_xenoprof_op
+        .quad do_event_channel_op
+        .quad do_physdev_op
+        .quad do_hvm_op
+        .quad do_sysctl             /* 35 */
+        .quad do_domctl
+        .quad do_kexec_op
+        .quad do_tmem_op
+        .rept __HYPERVISOR_arch_0-((.-hypercall_table)/8)
+        .quad do_ni_hypercall
+        .endr
+        .quad do_mca                /* 48 */
+        .rept NR_hypercalls-((.-hypercall_table)/8)
+        .quad do_ni_hypercall
+        .endr
+
+ENTRY(hypercall_args_table)
+        .byte 1 /* do_set_trap_table    */  /*  0 */
+        .byte 4 /* do_mmu_update        */
+        .byte 2 /* do_set_gdt           */
+        .byte 2 /* do_stack_switch      */
+        .byte 3 /* do_set_callbacks     */
+        .byte 1 /* do_fpu_taskswitch    */  /*  5 */
+        .byte 2 /* do_sched_op_compat   */
+        .byte 1 /* do_platform_op       */
+        .byte 2 /* do_set_debugreg      */
+        .byte 1 /* do_get_debugreg      */
+        .byte 2 /* do_update_descriptor */  /* 10 */
+        .byte 0 /* do_ni_hypercall      */
+        .byte 2 /* do_memory_op         */
+        .byte 2 /* do_multicall         */
+        .byte 3 /* do_update_va_mapping */
+        .byte 1 /* do_set_timer_op      */  /* 15 */
+        .byte 1 /* do_event_channel_op_compat */
+        .byte 2 /* do_xen_version       */
+        .byte 3 /* do_console_io        */
+        .byte 1 /* do_physdev_op_compat */
+        .byte 3 /* do_grant_table_op    */  /* 20 */
+        .byte 2 /* do_vm_assist         */
+        .byte 4 /* do_update_va_mapping_otherdomain */
+        .byte 0 /* do_iret              */
+        .byte 3 /* do_vcpu_op           */
+        .byte 2 /* do_set_segment_base  */  /* 25 */
+        .byte 4 /* do_mmuext_op         */
+        .byte 1 /* do_xsm_op            */
+        .byte 2 /* do_nmi_op            */
+        .byte 2 /* do_sched_op          */
+        .byte 2 /* do_callback_op       */  /* 30 */
+        .byte 2 /* do_xenoprof_op       */
+        .byte 2 /* do_event_channel_op  */
+        .byte 2 /* do_physdev_op        */
+        .byte 2 /* do_hvm_op            */
+        .byte 1 /* do_sysctl            */  /* 35 */
+        .byte 1 /* do_domctl            */
+        .byte 2 /* do_kexec             */
+        .byte 1 /* do_tmem_op           */
+        .rept __HYPERVISOR_arch_0-(.-hypercall_args_table)
+        .byte 0 /* do_ni_hypercall      */
+        .endr
+        .byte 1 /* do_mca               */  /* 48 */
+        .rept NR_hypercalls-(.-hypercall_args_table)
+        .byte 0 /* do_ni_hypercall      */
+        .endr
diff -Naur xen/xen/include/Makefile xen-b/xen/include/Makefile
--- xen/xen/include/Makefile	2013-03-09 18:06:26.343178611 -0700
+++ xen-b/xen/include/Makefile	2013-03-16 22:46:21.193178611 -0600
@@ -78,7 +78,7 @@
 all: headers.chk
 
 headers.chk: $(filter-out public/arch-% public/%ctl.h public/xsm/% public/%hvm/save.h, $(wildcard public/*.h public/*/*.h) $(public-y)) Makefile
-	for i in $(filter %.h,$^); do $(CC) -ansi -include stdint.h -Wall -W -Werror -S -o /dev/null -xc $$i || exit 1; echo $$i; done >$@.new
+	for i in $(filter %.h,$^); do $(CC) -ansi -include stdint.h -Wall -W -S -o /dev/null -xc $$i || exit 1; echo $$i; done >$@.new
 	mv $@.new $@
 
 endif
diff -Naur xen/xen/include/public/io/blkif.h xen-b/xen/include/public/io/blkif.h
--- xen/xen/include/public/io/blkif.h	2013-03-09 18:06:26.379845278 -0700
+++ xen-b/xen/include/public/io/blkif.h	2013-03-16 22:52:18.709845278 -0600
@@ -439,7 +439,7 @@
  * Used in SLES sources for device specific command packet
  * contained within the request. Reserved for that purpose.
  */
-#define BLKIF_OP_RESERVED_1        4
+#define BLKIF_OP_PACKET        4
 /*
  * Indicate to the backend device that a region of storage is no longer in
  * use, and may be discarded at any time without impact to the client.  If
diff -Naur xen/xen/include/public/io/blkif.h.orig xen-b/xen/include/public/io/blkif.h.orig
--- xen/xen/include/public/io/blkif.h.orig	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/xen/include/public/io/blkif.h.orig	2013-03-09 18:06:26.379845278 -0700
@@ -0,0 +1,550 @@
+/******************************************************************************
+ * blkif.h
+ *
+ * Unified block-device I/O interface for Xen guest OSes.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright (c) 2003-2004, Keir Fraser
+ * Copyright (c) 2012, Spectra Logic Corporation
+ */
+
+#ifndef __XEN_PUBLIC_IO_BLKIF_H__
+#define __XEN_PUBLIC_IO_BLKIF_H__
+
+#include "ring.h"
+#include "../grant_table.h"
+
+/*
+ * Front->back notifications: When enqueuing a new request, sending a
+ * notification can be made conditional on req_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Backends must set
+ * req_event appropriately (e.g., using RING_FINAL_CHECK_FOR_REQUESTS()).
+ *
+ * Back->front notifications: When enqueuing a new response, sending a
+ * notification can be made conditional on rsp_event (i.e., the generic
+ * hold-off mechanism provided by the ring macros). Frontends must set
+ * rsp_event appropriately (e.g., using RING_FINAL_CHECK_FOR_RESPONSES()).
+ */
+
+#ifndef blkif_vdev_t
+#define blkif_vdev_t   uint16_t
+#endif
+#define blkif_sector_t uint64_t
+
+/*
+ * Feature and Parameter Negotiation
+ * =================================
+ * The two halves of a Xen block driver utilize nodes within the XenStore to
+ * communicate capabilities and to negotiate operating parameters.  This
+ * section enumerates these nodes which reside in the respective front and
+ * backend portions of the XenStore, following the XenBus convention.
+ *
+ * All data in the XenStore is stored as strings.  Nodes specifying numeric
+ * values are encoded in decimal.  Integer value ranges listed below are
+ * expressed as fixed sized integer types capable of storing the conversion
+ * of a properly formated node string, without loss of information.
+ *
+ * Any specified default value is in effect if the corresponding XenBus node
+ * is not present in the XenStore.
+ *
+ * XenStore nodes in sections marked "PRIVATE" are solely for use by the
+ * driver side whose XenBus tree contains them.
+ *
+ * XenStore nodes marked "DEPRECATED" in their notes section should only be
+ * used to provide interoperability with legacy implementations.
+ *
+ * See the XenBus state transition diagram below for details on when XenBus
+ * nodes must be published and when they can be queried.
+ *
+ *****************************************************************************
+ *                            Backend XenBus Nodes
+ *****************************************************************************
+ *
+ *------------------ Backend Device Identification (PRIVATE) ------------------
+ *
+ * mode
+ *      Values:         "r" (read only), "w" (writable)
+ *
+ *      The read or write access permissions to the backing store to be
+ *      granted to the frontend.
+ *
+ * params
+ *      Values:         string
+ *
+ *      A free formatted string providing sufficient information for the
+ *      backend driver to open the backing device.  (e.g. the path to the
+ *      file or block device representing the backing store.)
+ *
+ * type
+ *      Values:         "file", "phy", "tap"
+ *
+ *      The type of the backing device/object.
+ *
+ *--------------------------------- Features ---------------------------------
+ *
+ * feature-barrier
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_WRITE_BARRIER request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-flush-cache
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_FLUSH_DISKCACHE request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-discard
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process requests
+ *      containing the BLKIF_OP_DISCARD request opcode.  Requests
+ *      of this type may still be returned at any time with the
+ *      BLKIF_RSP_EOPNOTSUPP result code.
+ *
+ * feature-persistent
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *      Notes: 7
+ *
+ *      A value of "1" indicates that the backend can keep the grants used
+ *      by the frontend driver mapped, so the same set of grants should be
+ *      used in all transactions. The maximum number of grants the backend
+ *      can map persistently depends on the implementation, but ideally it
+ *      should be RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST. Using this
+ *      feature the backend doesn't need to unmap each grant, preventing
+ *      costly TLB flushes. The backend driver should only map grants
+ *      persistently if the frontend supports it. If a backend driver chooses
+ *      to use the persistent protocol when the frontend doesn't support it,
+ *      it will probably hit the maximum number of persistently mapped grants
+ *      (due to the fact that the frontend won't be reusing the same grants),
+ *      and fall back to non-persistent mode. Backend implementations may
+ *      shrink or expand the number of persistently mapped grants without
+ *      notifying the frontend depending on memory constraints (this might
+ *      cause a performance degradation).
+ *
+ *      If a backend driver wants to limit the maximum number of persistently
+ *      mapped grants to a value less than RING_SIZE *
+ *      BLKIF_MAX_SEGMENTS_PER_REQUEST a LRU strategy should be used to
+ *      discard the grants that are less commonly used. Using a LRU in the
+ *      backend driver paired with a LIFO queue in the frontend will
+ *      allow us to have better performance in this scenario.
+ *
+ *----------------------- Request Transport Parameters ------------------------
+ *
+ * max-ring-page-order
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Notes:          1, 3
+ *
+ *      The maximum supported size of the request ring buffer in units of
+ *      lb(machine pages). (e.g. 0 == 1 page,  1 = 2 pages, 2 == 4 pages,
+ *      etc.).
+ *
+ * max-ring-pages
+ *      Values:         <uint32_t>
+ *      Default Value:  1
+ *      Notes:          DEPRECATED, 2, 3
+ *
+ *      The maximum supported size of the request ring buffer in units of
+ *      machine pages.  The value must be a power of 2.
+ *
+ *------------------------- Backend Device Properties -------------------------
+ *
+ * discard-aligment
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Notes:          4, 5
+ *
+ *      The offset, in bytes from the beginning of the virtual block device,
+ *      to the first, addressable, discard extent on the underlying device.
+ *
+ * discard-granularity
+ *      Values:         <uint32_t>
+ *      Default Value:  <"sector-size">
+ *      Notes:          4
+ *
+ *      The size, in bytes, of the individually addressable discard extents
+ *      of the underlying device.
+ *
+ * discard-secure
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *
+ *      A value of "1" indicates that the backend can process BLKIF_OP_DISCARD
+ *      requests with the BLKIF_DISCARD_SECURE flag set.
+ *
+ * info
+ *      Values:         <uint32_t> (bitmap)
+ *
+ *      A collection of bit flags describing attributes of the backing
+ *      device.  The VDISK_* macros define the meaning of each bit
+ *      location.
+ *
+ * sector-size
+ *      Values:         <uint32_t>
+ *
+ *      The native sector size, in bytes, of the backend device.
+ *
+ * sectors
+ *      Values:         <uint64_t>
+ *
+ *      The size of the backend device, expressed in units of its native
+ *      sector size ("sector-size").
+ *
+ *****************************************************************************
+ *                            Frontend XenBus Nodes
+ *****************************************************************************
+ *
+ *----------------------- Request Transport Parameters -----------------------
+ *
+ * event-channel
+ *      Values:         <uint32_t>
+ *
+ *      The identifier of the Xen event channel used to signal activity
+ *      in the ring buffer.
+ *
+ * ring-ref
+ *      Values:         <uint32_t>
+ *      Notes:          6
+ *
+ *      The Xen grant reference granting permission for the backend to map
+ *      the sole page in a single page sized ring buffer.
+ *
+ * ring-ref%u
+ *      Values:         <uint32_t>
+ *      Notes:          6
+ *
+ *      For a frontend providing a multi-page ring, a "number of ring pages"
+ *      sized list of nodes, each containing a Xen grant reference granting
+ *      permission for the backend to map the page of the ring located
+ *      at page index "%u".  Page indexes are zero based.
+ *
+ * protocol
+ *      Values:         string (XEN_IO_PROTO_ABI_*)
+ *      Default Value:  XEN_IO_PROTO_ABI_NATIVE
+ *
+ *      The machine ABI rules governing the format of all ring request and
+ *      response structures.
+ *
+ * ring-page-order
+ *      Values:         <uint32_t>
+ *      Default Value:  0
+ *      Maximum Value:  MAX(ffs(max-ring-pages) - 1, max-ring-page-order)
+ *      Notes:          1, 3
+ *
+ *      The size of the frontend allocated request ring buffer in units
+ *      of lb(machine pages). (e.g. 0 == 1 page, 1 = 2 pages, 2 == 4 pages,
+ *      etc.).
+ *
+ * num-ring-pages
+ *      Values:         <uint32_t>
+ *      Default Value:  1
+ *      Maximum Value:  MAX(max-ring-pages,(0x1 << max-ring-page-order))
+ *      Notes:          DEPRECATED, 2, 3
+ *
+ *      The size of the frontend allocated request ring buffer in units of
+ *      machine pages.  The value must be a power of 2.
+ *
+ * feature-persistent
+ *      Values:         0/1 (boolean)
+ *      Default Value:  0
+ *      Notes: 7, 8, 9
+ *
+ *      A value of "1" indicates that the frontend will reuse the same grants
+ *      for all transactions, allowing the backend to map them with write
+ *      access (even when it should be read-only). If the frontend hits the
+ *      maximum number of allowed persistently mapped grants, it can fallback
+ *      to non persistent mode. This will cause a performance degradation,
+ *      since the the backend driver will still try to map those grants
+ *      persistently. Since the persistent grants protocol is compatible with
+ *      the previous protocol, a frontend driver can choose to work in
+ *      persistent mode even when the backend doesn't support it.
+ *
+ *      It is recommended that the frontend driver stores the persistently
+ *      mapped grants in a LIFO queue, so a subset of all persistently mapped
+ *      grants gets used commonly. This is done in case the backend driver
+ *      decides to limit the maximum number of persistently mapped grants
+ *      to a value less than RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST.
+ *
+ *------------------------- Virtual Device Properties -------------------------
+ *
+ * device-type
+ *      Values:         "disk", "cdrom", "floppy", etc.
+ *
+ * virtual-device
+ *      Values:         <uint32_t>
+ *
+ *      A value indicating the physical device to virtualize within the
+ *      frontend's domain.  (e.g. "The first ATA disk", "The third SCSI
+ *      disk", etc.)
+ *
+ *      See docs/misc/vbd-interface.txt for details on the format of this
+ *      value.
+ *
+ * Notes
+ * -----
+ * (1) Multi-page ring buffer scheme first developed in the Citrix XenServer
+ *     PV drivers.
+ * (2) Multi-page ring buffer scheme first used in some RedHat distributions
+ *     including a distribution deployed on certain nodes of the Amazon
+ *     EC2 cluster.
+ * (3) Support for multi-page ring buffers was implemented independently,
+ *     in slightly different forms, by both Citrix and RedHat/Amazon.
+ *     For full interoperability, block front and backends should publish
+ *     identical ring parameters, adjusted for unit differences, to the
+ *     XenStore nodes used in both schemes.
+ * (4) Devices that support discard functionality may internally allocate
+ *     space (discardable extents) in units that are larger than the
+ *     exported logical block size.
+ * (5) The discard-alignment parameter allows a physical device to be
+ *     partitioned into virtual devices that do not necessarily begin or
+ *     end on a discardable extent boundary.
+ * (6) When there is only a single page allocated to the request ring,
+ *     'ring-ref' is used to communicate the grant reference for this
+ *     page to the backend.  When using a multi-page ring, the 'ring-ref'
+ *     node is not created.  Instead 'ring-ref0' - 'ring-refN' are used.
+ * (7) When using persistent grants data has to be copied from/to the page
+ *     where the grant is currently mapped. The overhead of doing this copy
+ *     however doesn't suppress the speed improvement of not having to unmap
+ *     the grants.
+ * (8) The frontend driver has to allow the backend driver to map all grants
+ *     with write access, even when they should be mapped read-only, since
+ *     further requests may reuse these grants and require write permissions.
+ * (9) Linux implementation doesn't have a limit on the maximum number of
+ *     grants that can be persistently mapped in the frontend driver, but
+ *     due to the frontent driver implementation it should never be bigger
+ *     than RING_SIZE * BLKIF_MAX_SEGMENTS_PER_REQUEST.
+ */
+
+/*
+ * STATE DIAGRAMS
+ *
+ *****************************************************************************
+ *                                   Startup                                 *
+ *****************************************************************************
+ *
+ * Tool stack creates front and back nodes with state XenbusStateInitialising.
+ *
+ * Front                                Back
+ * =================================    =====================================
+ * XenbusStateInitialising              XenbusStateInitialising
+ *  o Query virtual device               o Query backend device identification
+ *    properties.                          data.
+ *  o Setup OS device instance.          o Open and validate backend device.
+ *                                       o Publish backend features and
+ *                                         transport parameters.
+ *                                                      |
+ *                                                      |
+ *                                                      V
+ *                                      XenbusStateInitWait
+ *
+ * o Query backend features and
+ *   transport parameters.
+ * o Allocate and initialize the
+ *   request ring.
+ * o Publish transport parameters
+ *   that will be in effect during
+ *   this connection.
+ *              |
+ *              |
+ *              V
+ * XenbusStateInitialised
+ *
+ *                                       o Query frontend transport parameters.
+ *                                       o Connect to the request ring and
+ *                                         event channel.
+ *                                       o Publish backend device properties.
+ *                                                      |
+ *                                                      |
+ *                                                      V
+ *                                      XenbusStateConnected
+ *
+ *  o Query backend device properties.
+ *  o Finalize OS virtual device
+ *    instance.
+ *              |
+ *              |
+ *              V
+ * XenbusStateConnected
+ *
+ * Note: Drivers that do not support any optional features, or the negotiation
+ *       of transport parameters, can skip certain states in the state machine:
+ *
+ *       o A frontend may transition to XenbusStateInitialised without
+ *         waiting for the backend to enter XenbusStateInitWait.  In this
+ *         case, default transport parameters are in effect and any
+ *         transport parameters published by the frontend must contain
+ *         their default values.
+ *
+ *       o A backend may transition to XenbusStateInitialised, bypassing
+ *         XenbusStateInitWait, without waiting for the frontend to first
+ *         enter the XenbusStateInitialised state.  In this case, default
+ *         transport parameters are in effect and any transport parameters
+ *         published by the backend must contain their default values.
+ *
+ *       Drivers that support optional features and/or transport parameter
+ *       negotiation must tolerate these additional state transition paths.
+ *       In general this means performing the work of any skipped state
+ *       transition, if it has not already been performed, in addition to the
+ *       work associated with entry into the current state.
+ */
+
+/*
+ * REQUEST CODES.
+ */
+#define BLKIF_OP_READ              0
+#define BLKIF_OP_WRITE             1
+/*
+ * All writes issued prior to a request with the BLKIF_OP_WRITE_BARRIER
+ * operation code ("barrier request") must be completed prior to the
+ * execution of the barrier request.  All writes issued after the barrier
+ * request must not execute until after the completion of the barrier request.
+ *
+ * Optional.  See "feature-barrier" XenBus node documentation above.
+ */
+#define BLKIF_OP_WRITE_BARRIER     2
+/*
+ * Commit any uncommitted contents of the backing device's volatile cache
+ * to stable storage.
+ *
+ * Optional.  See "feature-flush-cache" XenBus node documentation above.
+ */
+#define BLKIF_OP_FLUSH_DISKCACHE   3
+/*
+ * Used in SLES sources for device specific command packet
+ * contained within the request. Reserved for that purpose.
+ */
+#define BLKIF_OP_RESERVED_1        4
+/*
+ * Indicate to the backend device that a region of storage is no longer in
+ * use, and may be discarded at any time without impact to the client.  If
+ * the BLKIF_DISCARD_SECURE flag is set on the request, all copies of the
+ * discarded region on the device must be rendered unrecoverable before the
+ * command returns.
+ *
+ * This operation is analogous to performing a trim (ATA) or unamp (SCSI),
+ * command on a native device.
+ *
+ * More information about trim/unmap operations can be found at:
+ * http://t13.org/Documents/UploadedDocuments/docs2008/
+ *     e07154r6-Data_Set_Management_Proposal_for_ATA-ACS2.doc
+ * http://www.seagate.com/staticfiles/support/disc/manuals/
+ *     Interface%20manuals/100293068c.pdf
+ *
+ * Optional.  See "feature-discard", "discard-alignment",
+ * "discard-granularity", and "discard-secure" in the XenBus node
+ * documentation above.
+ */
+#define BLKIF_OP_DISCARD           5
+
+/*
+ * Maximum scatter/gather segments per request.
+ * This is carefully chosen so that sizeof(blkif_ring_t) <= PAGE_SIZE.
+ * NB. This could be 12 if the ring indexes weren't stored in the same page.
+ */
+#define BLKIF_MAX_SEGMENTS_PER_REQUEST 11
+
+/*
+ * NB. first_sect and last_sect in blkif_request_segment, as well as
+ * sector_number in blkif_request, are always expressed in 512-byte units.
+ * However they must be properly aligned to the real sector size of the
+ * physical disk, which is reported in the "sector-size" node in the backend
+ * xenbus info. Also the xenbus "sectors" node is expressed in 512-byte units.
+ */
+struct blkif_request_segment {
+    grant_ref_t gref;        /* reference to I/O buffer frame        */
+    /* @first_sect: first sector in frame to transfer (inclusive).   */
+    /* @last_sect: last sector in frame to transfer (inclusive).     */
+    uint8_t     first_sect, last_sect;
+};
+
+/*
+ * Starting ring element for any I/O request.
+ */
+struct blkif_request {
+    uint8_t        operation;    /* BLKIF_OP_???                         */
+    uint8_t        nr_segments;  /* number of segments                   */
+    blkif_vdev_t   handle;       /* only for read/write requests         */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk (r/w only)  */
+    struct blkif_request_segment seg[BLKIF_MAX_SEGMENTS_PER_REQUEST];
+};
+typedef struct blkif_request blkif_request_t;
+
+/*
+ * Cast to this structure when blkif_request.operation == BLKIF_OP_DISCARD
+ * sizeof(struct blkif_request_discard) <= sizeof(struct blkif_request)
+ */
+struct blkif_request_discard {
+    uint8_t        operation;    /* BLKIF_OP_DISCARD                     */
+    uint8_t        flag;         /* BLKIF_DISCARD_SECURE or zero         */
+#define BLKIF_DISCARD_SECURE (1<<0)  /* ignored if discard-secure=0      */
+    blkif_vdev_t   handle;       /* same as for read/write requests      */
+    uint64_t       id;           /* private guest value, echoed in resp  */
+    blkif_sector_t sector_number;/* start sector idx on disk             */
+    uint64_t       nr_sectors;   /* number of contiguous sectors to discard*/
+};
+typedef struct blkif_request_discard blkif_request_discard_t;
+
+struct blkif_response {
+    uint64_t        id;              /* copied from request */
+    uint8_t         operation;       /* copied from request */
+    int16_t         status;          /* BLKIF_RSP_???       */
+};
+typedef struct blkif_response blkif_response_t;
+
+/*
+ * STATUS RETURN CODES.
+ */
+ /* Operation not supported (only happens on barrier writes). */
+#define BLKIF_RSP_EOPNOTSUPP  -2
+ /* Operation failed for some unspecified reason (-EIO). */
+#define BLKIF_RSP_ERROR       -1
+ /* Operation completed successfully. */
+#define BLKIF_RSP_OKAY         0
+
+/*
+ * Generate blkif ring structures and types.
+ */
+DEFINE_RING_TYPES(blkif, struct blkif_request, struct blkif_response);
+
+#define VDISK_CDROM        0x1
+#define VDISK_REMOVABLE    0x2
+#define VDISK_READONLY     0x4
+
+#endif /* __XEN_PUBLIC_IO_BLKIF_H__ */
+
+/*
+ * Local variables:
+ * mode: C
+ * c-file-style: "BSD"
+ * c-basic-offset: 4
+ * tab-width: 4
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -Naur xen/xen/include/public/io/cdromif.h xen-b/xen/include/public/io/cdromif.h
--- xen/xen/include/public/io/cdromif.h	1969-12-31 17:00:00.000000000 -0700
+++ xen-b/xen/include/public/io/cdromif.h	2013-03-16 22:52:18.709845278 -0600
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * cdromif.h
+ *
+ * Shared definitions between backend driver and Xen guest Virtual CDROM
+ * block device.
+ *
+ * Copyright (c) 2008, Pat Campell  plc@novell.com
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __XEN_PUBLIC_IO_CDROMIF_H__
+#define __XEN_PUBLIC_IO_CDROMIF_H__
+
+#include <linux/cdrom.h>
+
+/*
+ * Queries backend for CDROM support
+ */
+#define XEN_TYPE_CDROM_SUPPORT         _IO('c', 1)
+
+struct xen_cdrom_support
+{
+	uint32_t type;
+	int8_t ret;                  /* returned, 0 succeded, -1 error */
+	int8_t err;                  /* returned, backend errno */
+	int8_t supported;            /* returned, 1 supported */
+};
+
+/*
+ * Opens backend device, returns drive geometry or
+ * any encountered errors
+ */
+#define XEN_TYPE_CDROM_OPEN            _IO('c', 2)
+
+struct xen_cdrom_open
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad;
+	int8_t media_present;        /* returned */
+	uint32_t sectors;            /* returned */
+	uint32_t sector_size;        /* returned */
+	int32_t payload_offset;      /* offset to backend node name payload */
+};
+
+/*
+ * Queries backend for media changed status
+ */
+#define XEN_TYPE_CDROM_MEDIA_CHANGED   _IO('c', 3)
+
+struct xen_cdrom_media_changed
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t media_changed;        /* returned */
+};
+
+/*
+ * Sends vcd generic CDROM packet to backend, followed
+ * immediately by the vcd_generic_command payload
+ */
+#define XEN_TYPE_CDROM_PACKET          _IO('c', 4)
+
+struct xen_cdrom_packet
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad[2];
+	int32_t payload_offset;      /* offset to struct vcd_generic_command payload */
+};
+
+/* CDROM_PACKET_COMMAND, payload for XEN_TYPE_CDROM_PACKET */
+struct vcd_generic_command
+{
+	uint8_t  cmd[CDROM_PACKET_SIZE];
+	uint8_t  pad[4];
+	uint32_t buffer_offset;
+	uint32_t buflen;
+	int32_t  stat;
+	uint32_t sense_offset;
+	uint8_t  data_direction;
+	uint8_t  pad1[3];
+	int32_t  quiet;
+	int32_t  timeout;
+};
+
+union xen_block_packet
+{
+	uint32_t type;
+	struct xen_cdrom_support xcs;
+	struct xen_cdrom_open xco;
+	struct xen_cdrom_media_changed xcmc;
+	struct xen_cdrom_packet xcp;
+};
+
+#define PACKET_PAYLOAD_OFFSET (sizeof(struct xen_cdrom_packet))
+#define PACKET_SENSE_OFFSET (PACKET_PAYLOAD_OFFSET + sizeof(struct vcd_generic_command))
+#define PACKET_BUFFER_OFFSET (PACKET_SENSE_OFFSET + sizeof(struct request_sense))
+#define MAX_PACKET_DATA (PAGE_SIZE - sizeof(struct xen_cdrom_packet) - \
+            sizeof(struct vcd_generic_command) - sizeof(struct request_sense))
+
+#endif
diff -Naur xen/xen/include/public/platform.h xen-b/xen/include/public/platform.h
--- xen/xen/include/public/platform.h	2013-03-09 18:06:26.379845278 -0700
+++ xen-b/xen/include/public/platform.h	2013-03-16 22:46:21.193178611 -0600
@@ -526,6 +526,16 @@
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
+#define XENPF_get_cpu_freq        ('N' << 24)
+#define XENPF_get_cpu_freq_min    (XENPF_get_cpu_freq + 1)
+#define XENPF_get_cpu_freq_max    (XENPF_get_cpu_freq_min + 1)
+struct xenpf_get_cpu_freq {
+    /* IN variables */
+    uint32_t vcpu;
+    /* OUT variables */
+    uint32_t freq; /* in kHz */
+};
+
 /*
  * ` enum neg_errnoval
  * ` HYPERVISOR_platform_op(const struct xen_platform_op*);
@@ -552,6 +562,7 @@
         struct xenpf_cpu_hotadd        cpu_add;
         struct xenpf_mem_hotadd        mem_add;
         struct xenpf_core_parking      core_parking;
+        struct xenpf_get_cpu_freq      get_cpu_freq;
         uint8_t                        pad[128];
     } u;
 };
diff -Naur xen/xen/include/xen/device_tree.h xen-b/xen/include/xen/device_tree.h
--- xen/xen/include/xen/device_tree.h	2013-03-15 23:26:36.966511944 -0600
+++ xen-b/xen/include/xen/device_tree.h	2013-03-16 22:46:21.196511944 -0600
@@ -46,9 +46,25 @@
     struct dt_mb_module module[NR_MODULES + 1];
 };
 
+struct dt_gic_info {
+    paddr_t gic_dist_addr;
+    paddr_t gic_cpu_addr;
+    paddr_t gic_hyp_addr;
+    paddr_t gic_vcpu_addr;
+};
+
+struct dt_gic_info {
+    paddr_t gic_dist_addr;
+    paddr_t gic_cpu_addr;
+    paddr_t gic_hyp_addr;
+    paddr_t gic_vcpu_addr;
+};
+
 struct dt_early_info {
     struct dt_mem_info mem;
     struct dt_gic_info gic;
+    struct dt_gic_info gic;
+    struct dt_gic_info gic;
     struct dt_module_info modules;
 };
 
