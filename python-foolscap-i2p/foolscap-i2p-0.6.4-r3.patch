diff --git a/foolscap/negotiate.py b/foolscap/negotiate.py
index 36b08ec..f601fb4 100644
--- a/foolscap/negotiate.py
+++ b/foolscap/negotiate.py
@@ -331,13 +331,18 @@ class Negotiation(protocol.Protocol):
         # we are using an encrypted Tub is separate, and expressed in our
         # Hello block.
         req = []
+        proxyPrefix = ''
+        if 'outbound_proxy' in self.tub.options:
+            proxyPrefix = 'http://' + self.targetHost
+            self.log("sendPlaintextClient: using HTTP Proxy %s"
+                % self.tub.options['outbound_proxy'])
         if self.target.encrypted:
             self.log("sendPlaintextClient: GET for tubID %s" %
                      self.target.tubID)
-            req.append("GET /id/%s HTTP/1.1" % self.target.tubID)
+            req.append("GET %s/id/%s HTTP/1.1" % (proxyPrefix, self.target.tubID))
         else:
             self.log("sendPlaintextClient: GET for no tubID")
-            req.append("GET /id/ HTTP/1.1")
+            req.append("GET %s/id/ HTTP/1.1" % proxyPrefix)
         req.append("Host: %s" % self.targetHost)
         self.log("sendPlaintextClient: wantEncryption=%s" % self.wantEncryption)
         if self.wantEncryption:
@@ -1379,10 +1384,15 @@ class TubConnector(object):
             if location in self.attemptedLocations:
                 continue
             self.attemptedLocations.append(location)
-            host, port = location
+            if 'outbound_proxy' in self.tub.options:
+                host, port = self.tub.options['outbound_proxy'].split(':')
+                destination = location[0]
+            else:
+                host, port = location
+                destination = host
             lp = self.log("connectTCP to %s" % (location,))
-            f = TubConnectorClientFactory(self, host, lp)
-            c = reactor.connectTCP(host, port, f)
+            f = TubConnectorClientFactory(self, destination, lp)
+            c = reactor.connectTCP(host, int(port), f)
             self.pendingConnections[f] = c
             # the tcp.Connector that we get back from reactor.connectTCP will
             # retain a reference to the transport that it creates, so we can
diff --git a/foolscap/pb.py b/foolscap/pb.py
index 473d853..1506ca6 100644
--- a/foolscap/pb.py
+++ b/foolscap/pb.py
@@ -205,6 +205,7 @@ class Tub(service.MultiService):
                     connection negotiation. Currently defined keys are:
                      - debug_slow: if True, wait half a second between
                                    each negotiation response
+                     - outbound_proxy: if set, connect using this HTTP proxy
 
     @ivar brokers: maps TubIDs to L{Broker} instances
 
@@ -363,6 +364,8 @@ class Tub(service.MultiService):
             self.setLogGathererFURL(value)
         elif name == "log-gatherer-furlfile":
             self.setLogGathererFURLFile(value)
+        elif name == "outbound_proxy":
+            self.options['outbound_proxy'] = value
         elif name == "bridge-twisted-logs":
             assert value is not False, "cannot unbridge twisted logs"
             if value is True:
diff --git a/foolscap/referenceable.py b/foolscap/referenceable.py
index c1cc63b..b466382 100644
--- a/foolscap/referenceable.py
+++ b/foolscap/referenceable.py
@@ -782,13 +782,25 @@ def decode_location_hints(hints_s):
     hints = []
     if hints_s:
         for hint_s in hints_s.split(","):
-            if ":" not in hint_s:
+            if (
+                ":" not in hint_s and not hint_s.endswith(".i2p")
+                        and not hint_s.startswith("i2p:")
+                        and not hint_s.startswith("tor:")
+                        and not hint_s.endswith(".onion")
+                ):
                 raise BadFURLError("bad connection hint '%s' "
                                    "(hostname, but no port)" % hint_s)
             mo = IPV4_HINT_RE.search(hint_s)
             if mo:
                 hint = ( "ipv4", mo.group(1), int(mo.group(2)) )
                 hints.append(hint)
+            elif hint_s.startswith("i2p:"):
+                (protocol, destination) = hints_s.split(":", 2)
+                hint = ( "ipv4", destination, 0) # I2P destinations have no port
+                hints.append(hint)
+            elif hint_s.endswith(".i2p"): # For compatibility, to be removed in a future version
+                hint = ( "ipv4", hint_s, 0)
+                hints.append(hint)
             else:
                 # This is some extension from the future that we will ignore.
                 # All extensions are required to start with "TYPE:" (where
