Index: linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/xfrm4_udp_encap.c
+++ linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
@@ -221,10 +221,50 @@ static int find_inside_proto(struct sk_b
 	return -1;
 }
 
+/* Eat the routing headers and ip options of IPv6 packet to find the next protocol */
+static int find_ipv6_payload_type (struct sk_buff *skb, __u8 *next)
+{
+	struct ipv6hdr * ip6h = ipv6_hdr(skb);
+	size_t hdrlen = sizeof(struct ipv6hdr);
+	__u8 * p = (__u8 *)(ip6h+1);
+
+	printk(KERN_DEBUG "%s:%d - %s ( inspecting packet )\n", __FILE__, __LINE__, __FUNCTION__);
+
+	if (!pskb_may_pull(skb, hdrlen))
+		return -1;	/* No space for IPv6 header. */
+
+	*next = ip6h->nexthdr;
+
+next_hdr:
+	switch (*next) {
+		case IPPROTO_HOPOPTS:	/* IPv6 hop-by-hop options	*/
+		case IPPROTO_ROUTING:	/* IPv6 routing header		*/
+		/* case IPPROTO_FRAGMENT:*/	/* IPv6 fragmentation header	*/
+		case IPPROTO_DSTOPTS:	/* IPv6 destination options	*/
+		/* We have to eat this and go on */
+			if (!pskb_may_pull(skb, hdrlen + 2))
+				return -1;	/* could not get to hdr len. */
+			if (!pskb_may_pull(skb, hdrlen + ipv6_optlen((struct ipv6_opt_hdr *)p)))
+				return -1;	/* could not get the full option. */
+			*next = *p;
+			hdrlen 	+= ipv6_optlen((struct ipv6_opt_hdr *)p);
+			p 	+= ipv6_optlen((struct ipv6_opt_hdr *)p);
+			goto next_hdr;
+	}
+	/* We found the last header, return this */
+	printk(KERN_DEBUG "%s:%d - %s ( final header: %d )\n", __FILE__, __LINE__, __FUNCTION__, *next);
+	return 0;
+}
+
+
 static int udp_encap_proto_input(struct sk_buff *skb)
 {
 	struct iphdr *top_iph = ip_hdr(skb);
+	struct net *net = sock_net(skb->sk);
 	int proto=0;
+	struct xfrm_state *x;
+	int accept=0;
+	__u8 next=0;
 #ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
 	__be32 saddr = top_iph->saddr;
 	struct udphdr *uh = udp_hdr(skb);
@@ -242,6 +282,19 @@ static int udp_encap_proto_input(struct 
 
 	/* We know here the packet has gone through UDP checks and is valid. */
 
+	/* Let's find if we have some XFRM state for this packet. */
+	x = xfrm_state_lookup_byaddr(	net,
+					(xfrm_address_t *)&top_iph->daddr,
+					(xfrm_address_t *)&top_iph->saddr,
+					IPPROTO_UDP_ENCAPSULATION,
+					AF_INET);
+	if (x != NULL) {
+		printk(KERN_DEBUG "%s:%d - %s ( state found: accept packet )\n", __FILE__, __LINE__, __FUNCTION__);
+		/* We have a valid state for this packet, it means that the v4 coa of MN is registered */
+		accept = 1;
+		xfrm_state_put(x);
+	}
+
 	/* Let's eat the UDP header -- TLV will be eaten later */
 	skb_pull(skb, sizeof(struct udphdr));
 
@@ -260,9 +313,13 @@ static int udp_encap_proto_input(struct 
 	proto = find_inside_proto(skb);
 	switch (proto) {
 		case IPPROTO_IP: /* IP in the UDP vanilla encapsulation */
+			if (!accept)
+				goto drop;
 			goto ipv4;
 
 		case IPPROTO_IPV6: /* IPv6 in the UDP packet */
+			if (!accept)
+				goto look_inside;
 			goto ipv6;
 
 		default:
@@ -274,6 +331,21 @@ ipv4:
 		goto drop;
 	goto end;
 
+look_inside:
+	/* We have received a new packet from unknown source. We check it contains
+	   either ESP or MH; otherwise we discard it. */
+	if (find_ipv6_payload_type (skb, &next) < 0)
+		goto drop;
+	switch (next) {
+		case IPPROTO_MH:	/* we accept all MH */
+		case IPPROTO_ESP:	/* We also accept ESP and AH since they will be */
+		case IPPROTO_AH:	/* discarded if no IPsec policy corresponds */
+			break;
+		default:
+			printk(KERN_DEBUG "Unsupported inside protocol (%d), dropped\n", next);
+			goto drop;
+	}
+
 ipv6:
 	if (resubmit_as_ipv6(skb, top_iph) < 0)
 		goto drop;
