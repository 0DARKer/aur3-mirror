Index: linux-2.6.30/include/linux/skbuff.h
===================================================================
--- linux-2.6.30.orig/include/linux/skbuff.h
+++ linux-2.6.30/include/linux/skbuff.h
@@ -307,6 +307,7 @@ typedef unsigned char *sk_buff_data_t;
  *	@dma_cookie: a cookie to one of several possible DMA operations
  *		done by skb DMA functions
  *	@secmark: security marking
+ *	@udp_encap_info: IPv4 source address and UDP port for NAT-traversal
  *	@vlan_tci: vlan tag control information
  */
 
@@ -390,6 +391,12 @@ struct sk_buff {
 #ifdef CONFIG_NETWORK_SECMARK
 	__u32			secmark;
 #endif
+#ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
+	struct	{
+		__be32		saddr;
+		__be16		sport;
+	}			udp_encap_info;
+#endif
 
 	__u32			mark;
 
Index: linux-2.6.30/net/ipv4/Kconfig
===================================================================
--- linux-2.6.30.orig/net/ipv4/Kconfig
+++ linux-2.6.30/net/ipv4/Kconfig
@@ -375,9 +375,18 @@ config INET_XFRM_UDP_ENCAP
 	select XFRM
 	select INET_XFRM_TUNNEL
 	---help---
-	  Suport for UDP encapsulation over IPv4,
+	  Support for UDP encapsulation over IPv4,
     	  typically needed for DSMIPv6
+	  
+	  If unsure, say Y.
 
+config INET_XFRM_UDP_ENCAP_NATT
+	bool "IP: UDP Encapsulation transformation - NAT Traversal support"
+	depends on INET_XFRM_UDP_ENCAP
+	---help---
+	  Allow reporting of IP address and UDP port source of UDP encapsulated
+	  messages received on raw socket. Typical use is DSMIPv6 NAT Traversal.
+	  
 	  If unsure, say Y.
 
 config INET_XFRM_TUNNEL
Index: linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
===================================================================
--- linux-2.6.30.orig/net/ipv4/xfrm4_udp_encap.c
+++ linux-2.6.30/net/ipv4/xfrm4_udp_encap.c
@@ -224,10 +224,11 @@ static int find_inside_proto(struct sk_b
 static int udp_encap_proto_input(struct sk_buff *skb)
 {
 	struct iphdr *top_iph = ip_hdr(skb);
+	int proto=0;
+#ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
 	__be32 saddr = top_iph->saddr;
-	__be32 daddr = top_iph->daddr;
 	struct udphdr *uh = udp_hdr(skb);
-	int proto=0;
+#endif
 
 	/* This function was called by ip_local_deliver_finish after
 	    udp_rcv has resubmitted the skb */
@@ -248,8 +249,12 @@ static int udp_encap_proto_input(struct 
 	skb->mac_header = skb->network_header;
 	skb_reset_network_header(skb);
 
+#ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
 	/* We must save saddr and ntohs(uh->source) as ancialliary data here */
-	printk("Seb: TODO: save %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u\n", NIPQUAD(saddr), ntohs(uh->source), NIPQUAD(daddr), ntohs(uh->dest));
+	printk(KERN_DEBUG "Saving source %u.%u.%u.%u:%u into skb\n", NIPQUAD(saddr), ntohs(uh->source));
+	skb->udp_encap_info.saddr = saddr;
+	skb->udp_encap_info.sport = uh->source;
+#endif
 
 	/* Now the inside is either IP or IPv6. We will do as in ipip_rcv or ipip6_rcv accordingly */
 	proto = find_inside_proto(skb);
Index: linux-2.6.30/net/ipv6/datagram.c
===================================================================
--- linux-2.6.30.orig/net/ipv6/datagram.c
+++ linux-2.6.30/net/ipv6/datagram.c
@@ -463,6 +463,16 @@ int datagram_recv_ctl(struct sock *sk, s
 			off += len;
 		}
 	}
+#ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
+	if (skb->udp_encap_info.saddr != 0) {
+		struct sockaddr_in sin;
+		sin.sin_family      = AF_INET;
+		sin.sin_port        = skb->udp_encap_info.sport;
+		sin.sin_addr.s_addr = skb->udp_encap_info.saddr;
+		printk("Seb: %s:%d/%s: %u.%u.%u.%u:%d\n", __FILE__, __LINE__,__FUNCTION__, NIPQUAD(skb->udp_encap_info.saddr), ntohs(skb->udp_encap_info.sport));
+		put_cmsg(msg, IPPROTO_UDP_ENCAPSULATION, 0, sizeof(sin), &sin);
+	}
+#endif
 
 	/* socket options in old style */
 	if (np->rxopt.bits.rxoinfo) {
Index: linux-2.6.30/net/core/skbuff.c
===================================================================
--- linux-2.6.30.orig/net/core/skbuff.c
+++ linux-2.6.30/net/core/skbuff.c
@@ -537,6 +537,10 @@ static void __copy_skb_header(struct sk_
 	new->ipvs_property	= old->ipvs_property;
 #endif
 	new->protocol		= old->protocol;
+#ifdef CONFIG_INET_XFRM_UDP_ENCAP_NATT
+	new->udp_encap_info.saddr = old->udp_encap_info.saddr;
+	new->udp_encap_info.sport = old->udp_encap_info.sport;
+#endif
 	new->mark		= old->mark;
 	__nf_copy(new, old);
 #if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \
