#!/bin/bash

#****************************************************************#
#                         _                _                	 #
#      ___ _____      __ | |__   __ _  ___| | ___   _ _ __  	 #
#     / __/ _ \ \ /\ / / | '_ \ / _` |/ __| |/ / | | | '_ \ 	 #
#    | (_| (_) \ V  V /  | |_) | (_| | (__|   <| |_| | |_) |	 #
#     \___\___/ \_/\_/___|_.__/ \__,_|\___|_|\_\\__,_| .__/ 	 #
#                   |_____|                          |_|  	 #
#								 #
#		       cow_backup-1.6.6                          #
#							         #
#             Simple interactive bash script for                 #
#            full backups and recoveries using tar               #
#						 		 #
#                Copyright (c) 2011 by edloaa                    #
#						 		 #
#                      Important Notes:   	 	         #
#							         #
#   - It is recommended to use this script in a live-system.     #
#   - Make shure /mnt is not used as mount point!                #
#   - Always check the output and log file for error messages.   #
#							         #
#****************************************************************#

#----- VARIABLES -----#

version="cow_backup-1.6.6"      # cow_backup version

cow_date=$(date +"%Y-%m-%d")	# YYYY-mm-dd

log="cb-errors-${cow_date}.log" # log file name

# available colors

    n_c=$(echo -e '\033[0m')	# no color
    red=$(echo -e '\e[0;31m')	# red
  b_red=$(echo -e '\e[1;31m')	# bold red
   blue=$(echo -e '\e[0;34m')	# blue
 b_blue=$(echo -e '\e[1;34m')	# bold blue
   cyan=$(echo -e '\e[0;36m')	# cyan
 b_cyan=$(echo -e '\e[1;36m')	# bold cyan
  black=$(echo -e '\e[0;30m')	# black
b_black=$(echo -e '\e[1;30m')	# bold black
     gr=$(echo -e '\e[0;32m')	# green
   b_gr=$(echo -e '\e[1;32m')	# bold green
    ylw=$(echo -e '\e[0;33m')	# yellow
  b_ylw=$(echo -e '\e[1;33m')	# bold yellow
    mag=$(echo -e '\e[0;35m')	# magenta
  b_mag=$(echo -e '\e[1;35m')	# bold magenta
  white=$(echo -e '\e[0;37m')	# white
b_white=$(echo -e '\e[1;37m')	# bold white

# colors used for dialogue and messages:

c0=$b_ylw 			# c0 => cow_say
c1=$b_gr			# c1 => dialogs and messages
c2=$b_red			# c2 => errors
c3=$b_blue			# c3 => user input
c4=$n_c			        # c4 => no color; shouldn't be changed!

X=1

#----- FUNCTIONS -----#

# optional variables for "cow_say"; defines duration of "sleep" 

 T1="0"
 T2="0"

function cow_say() {

 char=$(echo "$@" | wc -m)

 t_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "_" ; done)
 b_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "-" ; done)

 echo "  $t_l"					  ; sleep $T1
 echo " < ${c0}${@}${c4} >	      		" ; sleep $T1
 echo "  $b_l"					  ; sleep $T1
 echo '         \   ^__^			' ; sleep $T1
 echo '          \  (oo)\_______		' ; sleep $T1
 echo '             (__)\       )\/\		' ; sleep $T1
 echo '                 ||----w |		' ; sleep $T1
 echo '                 ||     ||		' ; sleep $T2
 echo

}

function headline() {
 echo "[ ${c0}cow_backup - ${cow_date}${c4} ]"
 echo "==========================="
}

# error messages

M1="Failed to mount the partition to /mnt..."
M2="An error occurred, please check output of tar."
M3="Unable to delete files."
M4="Unable to unmount the partition, please unmount manually."

err_ok() {

# $1 => "$Mx"         -> error message
# $2 => "true/ false" -> echo "OK" or "FAILED" 
# $3 => "true/ false" -> exit

 # program exits without any errors

 if [ $? -eq "0" ] && [ $2 = true ]
 then
    echo "${c1}OK${c4}"
    echo

 # program exits with errors

 elif [ $? -gt "0" ]
 then

    if [ $2 = true ]
    then
       echo "${c2}FAILED${c4}"
       echo
    fi

    echo "${c2}${1}${c4}"
    echo

    echo "${c2}Check $log_dest/$log for error messages.${c4}"

    if [ $3 = true ]
    then
       cow_say "Unable to proceed. Abort."
       exit 1
    fi

    echo
 fi

}

#----- ALIAS -----#

# necessary to use alias

shopt -s expand_aliases

alias     press_key='read -p "${c1}Press any key...${c4}"'
alias    start_diag='read -p "${c1}Press any key to start the ${task}...${c4}"'
alias   backup_info='echo    "${c1}${partition} will be backed to ${backup_dest}/backup_${partition_diag}_${cow_date}.tar.gz${c4}" | sed "s!//!/!g"'
alias recovery_info='echo    "${c1}${backup_dest} will be recovered to ${partition}...${c4}"'

#------------------------- SCRIPT START -------------------------#

 	while [ true ] ; do

if [ $UID != 0 ]
then
   clear
   cow_say "Please run script as root."
   exit 1
fi

if [ $X -eq "1" ]
then
   clear
   echo -n $c4
   cow_say $version
fi

# main menu

headline
echo "# 1. BACKUP WITH TAR    (1)"
echo "# 2. RECOVERY WITH TAR  (2)"
echo "# 3. EXIT               (3)"
echo
echo -n "${c1}Enter an option (1-3): ${c3}"
read option
echo $c4

# option 1 and 2

if [ "$option" = "1" -o "$option" = "2" ] ; then

	# some specific variables depending on option you chose

	if [ "$option" = "1"  ]
	then
	       a_cow="backuped"
	   green_cow="backup directory (absolute path)"
	        task="backup"

	elif [ "$option" = "2"  ]
	then
	       a_cow="recovered"
	   green_cow="archive file (Enter: /Path/to/backup.tar.gz)"
	        task="recovery"
	fi

	clear
	headline
	echo
	echo "${c1}==> Available Partitions${c4}"
	echo "==========================="
	fdisk -l
	# echo ; for block_dev in $(ls -lR /dev/ | grep ^b | awk '{print $NF}'); do echo "/dev/$block_dev"; done
	echo

	echo -n "${c1}Specify the partition that shall be ${a_cow} (Enter: /dev/sdX -> e.g. /dev/sda3): ${c3}"
	read -e partition
	echo $c4

	# checks if partition exists

	while [ ! -b "$partition" ]
	do
	   echo -n "${c2}\"${partition}\" is no valid partition. Please enter a existing partition: ${c3}"
	   read -e partition
	   echo $c4
	done

	# converts strings like "/dev/sda3" to "sda3" => important for name of backup file

	if [ "$option" = "1"  ]
	then
	   partition_diag=$(echo $partition | sed 's!/dev/!!')
	fi

	echo -n "${c1}Specify the ${green_cow}: ${c3}"
	read -e backup_dest
	echo $c4

	# checks if green cow exists

	if [ "$option" = "1" ]
	then

	   # checks if dir exists and if it is an absolute directory path

	   until [ -d "$backup_dest" ] && [ $(echo $backup_dest | grep "^/" &>/dev/null ; echo $?) -eq "0" ]
	   do
	      echo -n "${c2}\"${backup_dest}\" is no valid (absolute) directory path. Please enter a new directory: ${c3}"
	      read -e backup_dest
	      echo $c4
	   done

	elif [ "$option" = "2" ]
	then

	   # checks if file exists and is a gzip compressed archive

	   until [ -f "$backup_dest" ] && [ $(file $backup_dest | grep "gzip" &>/dev/null ; echo $?) -eq "0" ]
	   do
	      echo -n "${c2}\"${backup_dest}\" is no valid archive file. Please enter a valid file: ${c3}"
	      read -e backup_dest
	      echo $c4
	   done
	fi

	# variable for log file destination

        if [ -f "$backup_dest" ]
	then
           log_dest=$(dirname $backup_dest)
	else
	   log_dest=$(echo $backup_dest | sed 's/\/$//')
	fi

	# checks if partition is mounted

	if [ $(mount | grep "$partition" &>/dev/null ; echo $?) -eq "0" ]
	then
	   echo "${c2}${partition} is already mounted...${c4}"
	   echo
 	   echo -n "${c1}=> Proceed anyway? (may cause errors) [y/n] ${c3}"
	   read ans
           echo -n $c4

	   case $ans in
	     y)
	       echo
	       umount $partition
	       if [ $? -gt "0" ]
	       then
	          cow_say "Unable to proceed. Abort."
	          echo "${c2}Please unmount ${partition} manually and try again.${c4}"
	          echo
	          exit 1
	       fi
	     ;;

	      *)
	        cow_say "Abort!"
	        exit 1
	      ;;
	   esac
	fi

	echo -n "${c1}${partition} will be mounted to /mnt... ${c4}"

	# -> option 1

	if [ "$option" = "1" ]
	then

	   # mounts partition read-only

	   mount -o ro $partition /mnt 2>> $log_dest/$log
	   err_ok "$M1" true true
	   cd /mnt
	   backup_info
	   echo
	   start_diag
	   echo

	   # tar backup command

	   tar -cvzf $backup_dest/backup_${partition_diag}_${cow_date}.tar.gz . 2>> $log_dest/$log && echo
	   err_ok "$M2" false false

	   # 1 ==>

	# -> option 2

	elif [ "$option" = "2" ]
	then
	   mount $partition /mnt 2>> $log_dest/$log
	   err_ok "$M1" true true
	   echo "${c1}==> Content of /mnt${c4}"
	   echo "==================="
	   echo
	   cd /mnt
	   ls -a --color=auto .
	   echo
	   echo -n "${c1}Delet these files? (yes/no)${c3} "
	   read delete
	   echo $c4

	   case $delete in
	     yes)
	       echo -n "${c1}Files will be deleted... ${c4}" 
	       rm -rf /mnt/* 2>> $log_dest/$log
	       err_ok "$M3" true false
	       recovery_info
	       echo
	       start_diag
	       echo

	       # tar recovery command

	       tar -xvf $backup_dest -C /mnt 2>> $log_dest/$log && echo
	       err_ok "$M2" false false

	       # 2 ==>

	     ;;

	     *)
	       echo -n "${c1}Trying to unmount ${partition}... ${c4}"
	       cd /
	       umount ${partition} 2>> $log_dest/$log
	       err_ok "$M4" true false
	       cow_say "Files were not deleted. Aborting..."
	       exit 0
	     ;;
	   esac

	fi

	# 1/2 ==>

	cd /
	echo -n "${c1}Trying to unmount ${partition}... ${c4}"
	umount ${partition} 2>> $log_dest/$log
	err_ok "$M4" true false
	press_key
	clear
	cow_say $version

# other options

elif [ "$option" = "3" ] ; then

	clear
	cow_say "Goodbye! ;-)"
	exit 0

elif [ "$option" = "moo" -o -z "$option" ] ; then

	clear
	cow_say "Mooooo...!?"

else

	clear
	cow_say "Invalid Option \"${option}\""

fi

((X++))

	done

#------------------------ END OF SCRIPT -------------------------#
