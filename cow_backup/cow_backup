#!/bin/bash

#                         _                _                	 
#      ___ _____      __ | |__   __ _  ___| | ___   _ _ __  	 
#     / __/ _ \ \ /\ / / | '_ \ / _` |/ __| |/ / | | | '_ \ 	 
#    | (_| (_) \ V  V /  | |_) | (_| | (__|   <| |_| | |_) |	 
#     \___\___/ \_/\_/___|_.__/ \__,_|\___|_|\_\\__,_| .__/ 	 
#                   |_____|                          |_|  	 
#								 
#		        cow_backup-203
#   
# Interactive bash script for compressed and gpg-encrypted
# full backups and recoveries of linux file systems using tar
#
# Copyright (c) 2012 by edloaa <edloaa at googlemail dot com>
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 2 of
#   the License, or (at your option) any later version.
#    
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.


#----- VARIABLES -----#

version="cow_backup-203"        # cow_backup version

cow_date=$(date +"%Y-%m-%d")	# YYYY-mm-dd

log="cb-errors-${cow_date}.log" # log file name

# available font colors

    n_c=$(echo -e '\033[0m')	# no color

    red=$(echo -e '\e[0;31m')	# red
   blue=$(echo -e '\e[0;34m')	# blue
   cyan=$(echo -e '\e[0;36m')	# cyan
  black=$(echo -e '\e[0;30m')	# black
     gr=$(echo -e '\e[0;32m')	# green
    ylw=$(echo -e '\e[0;33m')	# yellow
    mag=$(echo -e '\e[0;35m')	# magenta
  white=$(echo -e '\e[0;37m')	# white

# bold font colors

  b_red=$(echo -e '\e[1;31m')	# red
 b_blue=$(echo -e '\e[1;34m')	# blue
 b_cyan=$(echo -e '\e[1;36m')	# cyan
b_black=$(echo -e '\e[1;30m')	# black
   b_gr=$(echo -e '\e[1;32m')	# green
  b_ylw=$(echo -e '\e[1;33m')	# yellow
  b_mag=$(echo -e '\e[1;35m')	# magenta
b_white=$(echo -e '\e[1;37m')	# white

# colors used for dialogues and messages:

c0=$b_ylw 			# c0 => cow_say
c1=$b_gr			# c1 => dialogs and messages
c2=$b_red			# c2 => errors
c3=$b_blue			# c3 => user input
c4=$n_c			        # c4 => no color; shouldn't be changed!

X=1

#----- FUNCTIONS -----#

function cow_say()
{
	char=$(echo "$@" | wc -m)

	t_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "_" ; done)
	b_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "-" ; done)

	echo "  $t_l"
	echo " < ${c0}${@}${c4} >	      		"
	echo "  $b_l"
	echo '         \   ^__^			'
	echo '          \  (oo)\_______		'
	echo '             (__)\       )\/\		'
	echo '                 ||----w |		'
	echo '                 ||     ||		'
	echo
}

function headline()
{
	echo "[ ${c0}cow_backup - ${cow_date}${c4} ]"
	echo "==========================="
}

# error messages; variables for messages M1-M3, because they are used more than once

M1="Failed to mount the partition to /mnt."
M2="Errors might have occurred."
M3="Unable to unmount the partition, please unmount manually."

function cow_error()
{
	# $1 => "$Mx"         -> error message
	# $2 => "true/ false" -> echo "OK" or "FAILED" 
	# $3 => "true/ false" -> exit
	# $4 => "true/ false" -> proceed? (y/n)

	# program exits without any errors

	if [ $? -eq "0" ]; then

		if [ $2 = true ]; then
			echo "${c1}OK${c4}"
			echo
		fi

		# program exits with errors

	elif [ $? -gt "0" ]; then

		if [ $2 = true ]; then
			echo "${c2}FAILED${c4}"
			echo
		fi

	echo "$c2$1$c4"
	echo

	echo "${c2}Check $log_dest/$log for error messages.${c4}"

		if [ $3 = true ]; then
			cow_say "Unable to proceed. Abort."
			exit 1
		fi

		if [ $4 = true ]; then
			echo
			echo -n "${c1}Proceed anyway? (y/n) ${c3}"
			read ans
			echo $c4

		case $ans in
		y)
			echo "${c1}Proceeding...${c4}"
			;;

		*)
			cow_say "Abort!"
			exit 1
			;;
		esac
		fi

	echo
	  
	fi
}

function password()
{
	pwd1=a
	pwd2=b

	y=0

	until [ "$pwd1" == "$pwd2" ]; do

		if [ $y -gt "0" ]; then
			echo "${c2}The passwords differ. Please try again.${c4}"
			echo
		fi

		echo -n "${c1}Please enter a password for ${1}: ${c4}"
		read -s 'pwd1'
		echo
		echo
		echo -n "${c1}Repeat the password: ${c4}"
		read -s 'pwd2'
		echo
		echo

		((y++))

	done
}

function summary()
{
	echo "${c1}----------------------------------------------------------------------${c4}"
	echo
	echo "[   ${c1}Summary${c4}   ]"
	echo "==============="
	echo
	echo "${c1}Task started:  ${c0}${start_date}${c4}"
	echo "${c1}Task finished: ${c0}$(date +%Y-%m-%d_%T)${c4}"
	echo

	if [ -n "$ERR" ]; then
		echo "$ERR"
		echo
	fi

	if [ "$option" = "1" ]; then
		echo "${c1}Archive file information:${c4}"
		echo
		cd $(dirname $backup)
		echo "${c0}$(ls -lh $(basename $backup))${c4}"
		cd /
		echo
	fi

	echo "${c1}----------------------------------------------------------------------${c4}"
	echo
}

#----- ALIAS -----#

# necessary to use alias

shopt -s expand_aliases

alias     press_key='read -p "${c1}Press any key...${c4}"'
alias    start_diag='read -p "${c1}Press any key to start the ${task}...${c4}"'
alias   backup_info='echo    "${c1}${partition} will be backuped to ${backup_dest}/backup_${partition_diag}_${cow_date}.tar.gz${gpg}${c4}" | sed "s!//!/!g"'
alias recovery_info='echo    "${c1}${backup_dest} will be recovered to ${partition}.${c4}"'

#------------------------- SCRIPT START -------------------------#

# infinite loop; script always returns to the main menu

while [ 1 ]; do

	# check for root privileges

	if [ $UID != 0 ]; then
		clear
		cow_say "Please run script as root."
		exit 1
	fi

	# "cow_say $version" when script is started for the first time

	if [ $X -eq "1" ]; then
		clear
		echo -n $c4
		cow_say $version
	fi

	# main menu

	headline
	echo "# 1. Backup             (1)"
	echo "# 2. Recovery           (2)"
	echo "# 3. Exit               (3)"
	echo
	echo -n "${c1}Please enter an option (1-3): ${c3}"
	read option
	echo $c4

	# ===> option 1 and 2 --->

	if [ "$option" = "1" -o "$option" = "2" ]; then

		# some specific variables depending on $option

		if [ "$option" = "1"  ]; then
			a_cow="backuped"
			green_cow="backup directory (absolute path)"
			task="backup"

		elif [ "$option" = "2" ]; then
			a_cow="recovered"
			green_cow="archive file (/Path/to/backup.tar.gz.[gpg])"
			task="recovery"
		fi

		clear
		headline
		echo
		echo "[  ${c1}Available Partitions${c4}   ]"
		echo "==========================="
		# echo ; for block_dev in $(ls -lR /dev/ | grep ^b | awk '{print $NF}'); do echo "/dev/$block_dev"; done	
		fdisk -l
		echo
		echo -n "${c1}Specify the partition that shall be ${a_cow} (e.g. /dev/sda3): ${c3}"
		read -e partition
		echo $c4

		# checks if partition exists

		while [ ! -b "$partition" ]; do
			echo -n "${c2}\"${partition}\" is no valid partition. Please enter a existing partition: ${c3}"
			read -e partition
			echo $c4
		done

		# converts the partition name such as "/dev/sda3" to "sda3" => important for name of backup file

		if [ "$option" = "1" ]; then
			partition_diag=$(basename $partition)
		fi

		echo -n "${c1}Specify the ${green_cow}: ${c3}"
		read -e backup_dest
		echo $c4

		# checks if $green_cow exists

		# ---> option 1 --->

		if [ "$option" = "1" ]; then

			# checks if dir exists and if it is an absolute directory path

			until [ -d "$backup_dest" ] && [ $(echo $backup_dest | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; do
				echo -n "${c2}\"${backup_dest}\" is no valid (absolute) directory path. Please enter a new directory: ${c3}"
				read -e backup_dest
				echo $c4
			done

			# GPG encryption dialogue

			echo -n "${c1}Would you like to encrypt your backup files with GPG? (y/n) ${c3}"
			read GPG
			echo $c4
		   
			case $GPG in
			y|Y|yes|Yes|"")
				GPG="y"
				gpg=".gpg"
				password "encryption"
				;;

			*)
				gpg=""
				echo "${c2}Backup file will not be encrypted with GPG.${c4}"
				echo
				;;
			esac

		# ---> option 2 --->

		elif [ "$option" = "2" ]; then

			# checks if file exists and is a gzip compressed archive (and gpg encrypted)

			until [ -f "$backup_dest" ] && [ $(file $backup_dest | grep -e "gzip" -e "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; do
				echo -n "${c2}\"${backup_dest}\" is no valid archive file. Please enter a valid file: ${c3}"
				read -e backup_dest
				echo $c4
			done

		fi

		# variable for log file destination

		if [ -f "$backup_dest" ]; then
			log_dest=$(dirname $backup_dest)
		else
			log_dest=$(echo $backup_dest | sed 's/\/$//')
		fi

		# checks if partition is mounted

		if [ $(mount | grep "$partition" &>/dev/null ; echo $?) -eq "0" ]; then
			echo "${c2}${partition} is already mounted...${c4}"
			echo
			echo -n "${c1}=> Trying to proceed anyway? (y/n) ${c3}"
			read ans
			echo -n $c4

			case $ans in
			y)
				echo
				umount $partition

				if [ $? -gt "0" ]; then
					cow_say "Unable to proceed. Abort."
					echo "${c2}Please unmount ${partition} manually and try again.${c4}"
					echo
					exit 1
				fi
				;;

			*)
				cow_say "Abort!"
				exit 1
				;;
			esac
		fi

		# checks if /mnt is used as mkount point

		if [ $(mount | grep "/mnt" &>/dev/null ; echo $?) -eq "0" ]; then
			echo "${c2}/mnt is already used as mount point...${c4}"
			echo
			echo -n "${c1}=> Trying to proceed anyway? (y/n) ${c3}"
			read ans
			echo -n $c4

			case $ans in
			y)
				echo
				umount /mnt

				if [ $? -gt "0" ]; then
					cow_say "Unable to proceed. Abort."
					echo "${c2}Please unmount $(mount | grep "/mnt" | awk '{print $1}') manually and try again.${c4}"
					echo
					exit 1
				fi

				;;
			*)
				cow_say "Abort!"
				exit 1
				;;
			esac
		fi

		# MD5 hash will be checked (if *.md5-file exists)

		if [ "$option" = "2" ]; then

			if [ -e ${backup_dest}.md5 ]; then
				cd $(dirname $backup_dest)
				echo -n "${c1}Checking MD5 hash... ${c4}"  
				md5sum -c "${backup_dest}.md5" >/dev/null 2>&1
				cow_error "Wrong MD5 hash. File could be compromised." true false true
				cd /
			fi

		fi

		echo -n "${c1}${partition} will be mounted to /mnt... ${c4}"

		# ---> option 1 ===>

		if [ "$option" = "1" ]; then

			# mounts partition read-only

			mount -o ro $partition /mnt 2>> $log_dest/$log
			cow_error "$M1" true true false
			cd /mnt
			backup_info
			echo
			start_diag
			echo

			start_date=$(date +%Y-%m-%d_%T)

			#----- tar backup command -----#
		   
			if [ $GPG == "y" ]; then
				backup=$(echo $backup_dest/backup_${partition_diag}_${cow_date}.tar.gz.gpg | sed "s!//!/!g")
				tar -cvz . | gpg -c --force-mdc --passphrase "$pwd1" > $backup 2>> $log_dest/$log && echo
			else
				backup=$(echo $backup_dest/backup_${partition_diag}_${cow_date}.tar.gz | sed "s!//!/!g")
				tar -cvzf $backup . 2>> $log_dest/$log && echo
			fi

			ERR=$(cow_error "$M2" false false false)

			#------------------------------#

			summary

			# create MD5 hashes

			if [ -e $backup ]; then
				cd $(dirname $backup)
				echo -n "${c1}Creating MD5 hash... ${c4}"
				md5sum ./$(basename $backup) > $(basename $backup).md5 2>> $log_dest/$log
				cow_error "Failed to create a md5 hash." true false false
				cd /
			fi
		fi

		# ---> 1 ===>

		# ---> option 2 ===>

		if [ "$option" = "2" ]; then

			mount $partition /mnt 2>> $log_dest/$log
			cow_error "$M1" true true false

			if [ $(file $backup_dest | grep "gzip" &>/dev/null ; echo $?) -eq "0" ]; then
				GPG="n"
				echo "${c1}File seems no to be encrypted.${c4}"
				echo
			elif [ $(file $backup_dest | grep "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; then
				GPG="y"	
				echo "${c1}File seems to be encrypted.${c4}"
				echo
				password "decryption"
				echo
			fi

			echo "[ ${c1}Content of /mnt ]${c4}"
			echo "==================="
			echo
			cd /mnt
			ls -a --color=auto .
			echo
			echo -n "${c1}Delet these files? (yes/no)${c3} "
			read delete
			echo $c4

			case $delete in
			yes)
				echo -n "${c1}Files will be deleted... ${c4}" 
				rm -rf /mnt/* 2>> $log_dest/$log
				cow_error "Unable to delete files." true false false
				recovery_info
				echo
				start_diag
				echo

				start_date=$(date +%Y-%m-%d_%T)

				#---- tar recovery command ----#

				if [ $GPG == "y" ]; then
					(gpg -d --passphrase "$pwd1" $backup_dest | tar -xzv -C /mnt) 2>> $log_dest/$log && echo
				elif [ $GPG == "n" ]; then
					tar -xvf $backup_dest -C /mnt 2>> $log_dest/$log && echo
				fi

				ERR=$(cow_error "$M2" false false false)

				#------------------------------#

				summary

				# ---> 2 ===>

				;;

			*)
				echo -n "${c1}Trying to unmount ${partition}... ${c4}"
				cd /
				umount ${partition} 2>> $log_dest/$log
				cow_error "$M3" true false false
				cow_say "Files were not deleted. Aborting..."
				exit 0
				;;
			esac
		fi

		# =====> option 1 and 2

		cd /
		echo -n "${c1}Trying to unmount ${partition}... ${c4}"
		umount ${partition} 2>> $log_dest/$log
		cow_error "$M3" true false false

		# if log file is empty, it will be removed

		if [ $(md5sum "$log_dest/$log" | awk '{print $1}' ) == "d41d8cd98f00b204e9800998ecf8427e" ]; then
			rm $log_dest/$log
		fi

		press_key
		clear
		cow_say $version

	# other options

	elif [ "$option" = "3" ]; then
		clear
		cow_say "Goodbye! ;-)"
		exit 0
	elif [ "$option" = "moo" -o -z "$option" ]; then
		clear
		cow_say "Mooooo...!?"
	else
		clear
		cow_say "Invalid Option \"${option}\""
	fi

	((X++))

done

#------------------------ END OF SCRIPT -------------------------#
