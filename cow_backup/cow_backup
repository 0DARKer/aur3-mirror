#!/bin/bash

#                         _                _                	 
#      ___ _____      __ | |__   __ _  ___| | ___   _ _ __  	 
#     / __/ _ \ \ /\ / / | '_ \ / _` |/ __| |/ / | | | '_ \ 	 
#    | (_| (_) \ V  V /  | |_) | (_| | (__|   <| |_| | |_) |	 
#     \___\___/ \_/\_/___|_.__/ \__,_|\___|_|\_\\__,_| .__/ 	 
#                   |_____|                          |_|  	 
#								 		        
#                        cow_backup-205
#
#  script for compressed and gpg-encrypted backups and recoveries
#  of complete partitions, directories or files using tar and gpg
# 
#  Copyright (c) 2012 by edloaa <edloaa at googlemail dot com>
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as
#   published by the Free Software Foundation; either version 2 of
#   the License, or (at your option) any later version.
#    
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.


#----- VARIABLES -----#

version="cow_backup-205"        # cow_backup version

cowdate=$(date +"%Y-%m-%d")	# YYYY-mm-dd

log="cb-errors-${cowdate}.log"  # log file name

# available font colors

    n_c=$(echo -e '\033[0m')	# no color

    red=$(echo -e '\e[0;31m')	# red
   blue=$(echo -e '\e[0;34m')	# blue
   cyan=$(echo -e '\e[0;36m')	# cyan
  black=$(echo -e '\e[0;30m')	# black
     gr=$(echo -e '\e[0;32m')	# green
    ylw=$(echo -e '\e[0;33m')	# yellow
    mag=$(echo -e '\e[0;35m')	# magenta
  white=$(echo -e '\e[0;37m')	# white

# bold font colors

  b_red=$(echo -e '\e[1;31m')	# red
 b_blue=$(echo -e '\e[1;34m')	# blue
 b_cyan=$(echo -e '\e[1;36m')	# cyan
b_black=$(echo -e '\e[1;30m')	# black
   b_gr=$(echo -e '\e[1;32m')	# green
  b_ylw=$(echo -e '\e[1;33m')	# yellow
  b_mag=$(echo -e '\e[1;35m')	# magenta
b_white=$(echo -e '\e[1;37m')	# white

# colors used for dialogues and messages:

c0=$b_ylw 			# c0 => cow_say
c1=$b_gr			# c1 => dialogs and messages
c2=$b_red			# c2 => errors
c3=$b_blue			# c3 => user input
c4=$n_c			        # c4 => no color; shouldn't be changed!

X=1

#----- FUNCTIONS -----#

function cow_say()
{
	char=$(echo "$@" | wc -m)

	t_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "_" ; done)
	b_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "-" ; done)

	echo "  $t_l"
	echo " < ${c0}${@}${c4} >	      		"
	echo "  $b_l"
	echo '         \   ^__^				'
	echo '          \  (oo)\_______			'
	echo '             (__)\       )\/\		'
	echo '                 ||----w |		'
	echo '                 ||     ||		'
	echo
}

function headline()
{
	echo "${c0}[ cow_backup - ${cowdate} ]${c4}"
	echo "${c0}===========================${c4}"
}

# error messages; variables for messages M1-M3, because they are used more than once

M1="Failed to mount the partition to /mnt."
M2="Errors might have occurred."
M3="Unable to unmount the partition, please unmount manually."

function cow_error()
{
	# $1 => "$Mx"         -> error message
	# $2 => "true/ false" -> echo "OK" or "FAILED" 
	# $3 => "true/ false" -> exit
	# $4 => "true/ false" -> proceed? (y/n)

	# program exits without any errors

	if [ $? -eq "0" ]; then

		if [ $2 = true ]; then
			echo "${c1}OK${c4}"
			echo
		fi

		# program exits with errors

	elif [ $? -gt "0" ]; then

		if [ $2 = true ]; then
			echo "${c2}FAILED${c4}"
			echo
		fi

	echo "$c2$1$c4"
	echo

	echo "${c2}Check $log_dest/$log for error messages.${c4}"

		if [ $3 = true ]; then
			cow_say "Unable to proceed. Abort."
			exit 1
		fi

		if [ $4 = true ]; then
			echo
			echo -n "${c1}Proceed anyway? (y/n) ${c3}"
			read ans
			echo $c4

		case $ans in
		y)
			echo "${c1}Proceeding...${c4}"
			;;

		*)
			cow_say "Abort!"
			exit 1
			;;
		esac
		fi

	echo
	  
	fi
}

function password()
{
	pwd1=a
	pwd2=b

	y=0

	until [ "$pwd1" == "$pwd2" ]; do

		if [ $y -gt "0" ]; then
			echo "${c2}The passwords differ. Please try again.${c4}"
			echo
		fi

		echo -n "${c1}Please enter a password for ${1}: ${c4}"
		read -s 'pwd1'
		echo
		echo
		echo -n "${c1}Repeat the password: ${c4}"
		read -s 'pwd2'
		echo
		echo

		((y++))

	done
}

function summary()
{
	bline="$c1$(for ((x = 0 ; x <= 70 ; x++)) ; do echo -n "-" ; done)$c4"
	echo
	echo $bline
	echo
	echo "${c1}[   Summary   ]${c4}"
	echo "${c1}===============${c4}"
	echo
	echo "${c1}Task started:  ${c0}${sdate}${c4}"
	echo "${c1}Task finished: ${c0}$(date +%Y-%m-%d_%T)${c4}"
	echo

	if [ -n "$ERR" ]; then
		echo "$ERR"
		echo
	fi

	if [ $fileinf = true ]; then
		echo "${c1}Archive file information:${c4}"
		echo
		cd $(dirname $backup)
		echo "${c0}$(ls -lh $(basename $backup))${c4}"
		cd /
		echo
	fi

	echo $bline
	echo
}

#----- ALIAS -----#

# necessary to use alias

shopt -s expand_aliases

alias     press_key='read -p "${c1}Press any key...${c4}"'
alias    start_diag='read -p "${c1}Press any key to start the ${task}...${c4}"'
alias   backup_info='echo    "${c1}${part} will be backuped to ${bdest}/backup_${partname}_${cowdate}.tar.gz${gpg}${c4}" | sed "s!//!/!g"'
alias recovery_info='echo    "${c1}${bdest} will be recovered to ${part}.${c4}"'

#------------------------- SCRIPT START -------------------------#

# interactive mode

if [ -z "$*" ]; then

	# infinite loop; script always returns to the main menu

	while [ 1 ]; do

		# check for root privileges

		if [ $UID != 0 ]; then
			clear
			cow_say "Please run script as root."
			exit 1
		fi

		# "cow_say $version" when script is started for the first time

		if [ $X -eq "1" ]; then
			clear
			echo -n $c4
			cow_say $version
		fi

		# main menu

		headline
		echo "# 1. Backup             (1)"
		echo "# 2. Recovery           (2)"
		echo "# 3. Exit               (3)"
		echo
		echo -n "${c1}Please enter an option: ${c3}"
		read option
		echo $c4

		# ===> option 1 and 2 --->

		if [ "$option" = "1" -o "$option" = "2" ]; then

			# some specific variables depending on $option

			if [ "$option" = "1"  ]; then
				a_cow="backuped"
				green_cow="backup directory (absolute path)"
				task="backup"
				fileinf=true

			elif [ "$option" = "2" ]; then
				a_cow="recovered"
				green_cow="archive file (/Path/to/backup.tar.gz.[gpg])"
				task="recovery"
			fi

			clear
			headline
			echo
			echo "${c1}[  Available Partitions   ]${c4}"
			echo "${c1}===========================${c4}"
			# echo ; for block_dev in $(ls -lR /dev/ | grep ^b | awk '{print $NF}'); do echo "/dev/$block_dev"; done	
			fdisk -l
			echo
			echo -n "${c1}Specify the partition that shall be ${a_cow} (e.g. /dev/sda3): ${c3}"
			read -e part
			echo $c4

			# check if partition exists

			while [ ! -b "$part" ]; do
				echo -n "${c2}\"${part}\" is no valid partition. Please enter a existing partition: ${c3}"
				read -e part
				echo $c4
			done

			# converts the partition name such as "/dev/sda3" to "sda3" => important for name of backup file

			if [ "$option" = "1" ]; then
				partname=$(basename $part)
			fi

			echo -n "${c1}Specify the ${green_cow}: ${c3}"
			read -e bdest
			echo $c4

			# check if $green_cow exists

			# ---> option 1 --->

			if [ "$option" = "1" ]; then

				# check if dir exists and if it is an absolute directory path

				until [ -d "$bdest" ] && [ $(echo $bdest | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "${c2}\"${bdest}\" is no valid (absolute) directory path. Please enter a new directory: ${c3}"
					read -e bdest
					echo $c4
				done

				# GPG encryption dialogue

				echo -n "${c1}Would you like to encrypt your backup files with GPG? (y/n) ${c3}"
				read GPG
				echo $c4
			   
				case $GPG in
				y|Y|yes|Yes|"")
					GPG="y"
					gpg=".gpg"
					password "encryption"
					;;

				*)
					gpg=""
					echo "${c0}Backup file will not be encrypted with GPG.${c4}"
					echo
					;;
				esac

			# ---> option 2 --->

			elif [ "$option" = "2" ]; then

				# check if file exists and is a gzip compressed archive (and gpg encrypted)

				until [ -f "$bdest" ] && [ $(file $bdest | grep -e "gzip" -e "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "${c2}\"${bdest}\" is no valid archive file. Please enter a valid file: ${c3}"
					read -e bdest
					echo $c4
				done

			fi

			# variable for log file destination

			if [ -f "$bdest" ]; then
				log_dest=$(dirname $bdest)
			else
				log_dest=$(echo $bdest | sed 's/\/$//')
			fi

			# check if partition is mounted

			if [ $(mount | grep "$part" &>/dev/null ; echo $?) -eq "0" ]; then
				echo "${c2}${part} is already mounted...${c4}"
				echo
				echo -n "${c1}=> Trying to proceed anyway? (y/n) ${c3}"
				read ans
				echo -n $c4

				case $ans in
				y)
					echo
					umount $part

					if [ $? -gt "0" ]; then
						cow_say "Unable to proceed. Abort."
						echo "${c2}Please unmount ${part} manually and try again.${c4}"
						echo
						exit 1
					fi
					;;

				*)
					cow_say "Abort!"
					exit 1
					;;
				esac
			fi

			# check if /mnt is used as mkount point

			if [ $(mount | grep "/mnt" &>/dev/null ; echo $?) -eq "0" ]; then
				echo "${c2}/mnt is already used as mount point...${c4}"
				echo
				echo -n "${c1}=> Trying to proceed anyway? (y/n) ${c3}"
				read ans
				echo -n $c4

				case $ans in
				y)
					echo
					umount /mnt

					if [ $? -gt "0" ]; then
						cow_say "Unable to proceed. Abort."
						echo "${c2}Please unmount $(mount | grep "/mnt" | awk '{print $1}') manually and try again.${c4}"
						echo
						exit 1
					fi

					;;
				*)
					cow_say "Abort!"
					exit 1
					;;
				esac
			fi

			# MD5 hash will be checked (if *.md5-file exists)

			if [ "$option" = "2" ]; then

				if [ -e ${bdest}.md5 ]; then
					cd $(dirname $bdest)
					echo -n "${c1}Checking MD5 hash... ${c4}"  
					md5sum -c "${bdest}.md5" >/dev/null 2>&1
					cow_error "Wrong MD5 hash. File could be compromised." true false true
					cd /
				fi

			fi

			echo -n "${c1}${part} will be mounted to /mnt... ${c4}"

			# ---> option 1 ===>

			if [ "$option" = "1" ]; then

				# mounting partition read-only

				mount -o ro $part /mnt 2>> $log_dest/$log
				cow_error "$M1" true true false
				cd /mnt
				backup_info
				echo
				start_diag
				echo

				sdate=$(date +%Y-%m-%d_%T)

				#----- tar backup command -----#
			   
				if [ $GPG == "y" ]; then
					backup=$(echo $bdest/backup_${partname}_${cowdate}.tar.gz.gpg | sed "s!//!/!g")
					tar -cvz . | gpg --batch -c --force-mdc --passphrase "$pwd1" -o $backup 2>> $log_dest/$log && echo
				else
					backup=$(echo $bdest/backup_${partname}_${cowdate}.tar.gz | sed "s!//!/!g")
					tar -cvzf $backup . 2>> $log_dest/$log
				fi

				ERR=$(cow_error "$M2" false false false)

				#------------------------------#

				summary

				# create MD5 hashes

				if [ -f $backup ]; then
					cd $(dirname $backup)
					echo -n "${c1}Creating MD5 hash... ${c4}"
					md5sum ./$(basename $backup) > $(basename $backup).md5 2>> $log_dest/$log
					cow_error "Failed to create a md5 hash." true false false
					cd /
				fi
			fi

			# ---> 1 ===>

			# ---> option 2 ===>

			if [ "$option" = "2" ]; then

				mount $part /mnt 2>> $log_dest/$log
				cow_error "$M1" true true false

				if [ $(file $bdest | grep "gzip" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="n"
					echo "${c1}File seems no to be encrypted.${c4}"
					echo
				elif [ $(file $bdest | grep "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="y"	
					echo "${c1}File seems to be encrypted.${c4}"
					echo
					password "decryption"
					echo
				fi

				echo "${c1}[ Content of /mnt ]${c4}"
				echo "${c1}===================${c4}"
				echo
				cd /mnt
				ls -a --color=auto .
				echo
				echo -n "${c1}Delet these files? (yes/no)${c3} "
				read delete
				echo $c4

				case $delete in
				yes)
					echo -n "${c1}Files will be deleted... ${c4}" 
					rm -rf /mnt/* 2>> $log_dest/$log
					cow_error "Unable to delete files." true false false
					recovery_info
					echo
					start_diag
					echo

					sdate=$(date +%Y-%m-%d_%T)

					#---- tar recovery command ----#

					if [ $GPG == "y" ]; then
						(gpg --batch -d --passphrase "$pwd1" $bdest | tar -xzv -C /mnt) 2>> $log_dest/$log && echo
					elif [ $GPG == "n" ]; then
						tar -xvf $bdest -C /mnt 2>> $log_dest/$log
					fi

					ERR=$(cow_error "$M2" false false false)

					#------------------------------#

					summary

					# ---> 2 ===>

					;;

				*)
					echo -n "${c1}Trying to unmount ${part}... ${c4}"
					cd /
					umount $part 2>> $log_dest/$log
					cow_error "$M3" true false false
					cow_say "Files were not deleted. Aborting..."
					exit 0
					;;
				esac
			fi

			# =====> option 1 and 2

			cd /
			echo -n "${c1}Trying to unmount ${part}... ${c4}"
			umount $part 2>> $log_dest/$log
			cow_error "$M3" true false false

			# if log file is empty, it will be removed

			if [ $(md5sum "$log_dest/$log" | awk '{print $1}' ) == "d41d8cd98f00b204e9800998ecf8427e" ]; then
				rm $log_dest/$log
			fi

			press_key
			clear
			cow_say $version

		# other options

		elif [ "$option" = "3" ]; then
			clear
			cow_say "Goodbye! ;-)"
			exit 0
		elif [ "$option" = "moo" -o -z "$option" ]; then
			clear
			cow_say "Mooooo...!?"
		else
			clear
			cow_say "Invalid Option \"${option}\""
		fi

		((X++))

	done

# non-interactive mode

elif [ -n "$*" ]; then

	# no colors in non-interactive mode

	c0=''
	c1=''
	c2=''
	c3=''
	c4=''

	# help page

	case $1 in
	-h|--help)
		echo "${version}: backup and recoveries with tar and gpg"
		echo
		echo " usage [interactive]: '$0' (start script without any parameters)"
		echo
		echo " usage [non-interactive]: '$0 <source> <destination> <password>'"
		echo
		echo " - source:       partition or an absolute path you want to backup"
		echo " - destination:  /absolute/path/to/your/destination-folder"
		echo " - gpg-password: you can specify a password for encryption here"
		echo
		echo " -> example: ./cow_backup /dev/sda3 /media/backups 'MyPa55w0rd'"
		echo
		echo " Note: You can only create backups in non-interactive mode."
		echo
		exit 0
		;;
	esac

	echo $version
	echo

	# some tests at the beginning...

	if [ $UID != 0 ]; then
		EXIT="yes"
		echo "Error: Root privileges needed."
	fi

	if [ -b "$1" ]; then
		opt=1

	elif [ -d "$1" -o -f "$1" ] && [ $(echo "$1" | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; then
		opt=2

	else
		EXIT="yes"
		echo "Error: No valid block device or directory. Abort."
	fi

	if [ ! -d "$2" -o $(echo "$2" | grep "^/" &>/dev/null ; echo $?) -ne "0" ]; then
		EXIT="yes"
		echo "Error: No valid directory. Abort."
	fi

	if [ -z "$3" ]; then
		echo "Warning: File will not be encrypted."
	fi

	if [ "$EXIT" == "yes" ]; then
		echo
		echo "Try '$0 -h' for more information."
		exit 1
	fi

	# check if partition is mounted or /mnt is used

	if [ $(mount | grep -e "$1" -e "/mnt" &>/dev/null ; echo $?) -eq "0" ]; then
		echo
		echo "Error: "$1" is mounted or /mnt is already used as mount point. Abort."
		exit 1
	fi

	fileinf=true

	# variable for log file destination

	log_dest=$(echo $2 | sed 's/\/$//')

	# partition backup

	if [ "$opt" = "1" ]; then

		echo
		echo -n "$2 will be mounted to /mnt... "

		partname=$(basename $1)

		# mounting partition read-only

		mount -o ro $1 /mnt 2>> $log_dest/$log
		cow_error "$M1" true true false
		cd /mnt
		echo "$2 will be backuped to $3/backup_${partname}_${cowdate}.tar.gz${gpg}" | sed "s!//!/!g"
		echo

		sdate=$(date +%Y-%m-%d_%T)
	
		#----- tar backup command -----#

		if [ -n "$3" ]; then
			backup=$(echo $2/backup_${partname}_${cowdate}.tar.gz.gpg | sed "s!//!/!g")
			tar -cvz . | gpg --batch -c --force-mdc --passphrase "$3" > $backup 2>> $log_dest/$log && echo
		else
			backup=$(echo $2/backup_${partname}_${cowdate}.tar.gz | sed "s!//!/!g")
			tar -cvzf $backup . 2>> $log_dest/$log
		fi

		ERR=$(cow_error "$M2" false false false)

		#------------------------------#

		summary

		echo -n "Trying to unmount $1... "
		umount $1 2>> $log_dest/$log
		cow_error "$M3" true false false

	# directory or file backup

	elif [ "$opt" = "2" ]; then

		dirname=$(basename $1)

		sdate=$(date +%Y-%m-%d_%T)
	
		#----- tar backup command -----#

		if [ -n "$3" ]; then
			backup=$(echo $2/backup_${dirname}_${cowdate}.tar.gz.gpg | sed "s!//!/!g")
			tar -cvz $1 | gpg --batch -c --force-mdc --passphrase "$3" -o $backup 2>> $log_dest/$log && echo
		else
			backup=$(echo $2/backup_${dirname}_${cowdate}.tar.gz | sed "s!//!/!g")
			tar -cvzf $backup $1 2>> $log_dest/$log
		fi

		ERR=$(cow_error "$M2" false false false)

		#------------------------------#

		summary

	fi

	# create MD5 hashes

	if [ -f $backup ]; then
		cd $(dirname $backup)
		echo -n "Creating MD5 hash... "
		md5sum ./$(basename "$backup") > $(basename $backup).md5 2>> $log_dest/$log
		cow_error "Error: Failed to create a md5 hash." true false false
		cd /
	fi

	# if log file is empty, it will be removed
	
	if [ "$(md5sum "$log_dest/$log" | awk '{print $1}')" == "d41d8cd98f00b204e9800998ecf8427e" ]; then
		rm $log_dest/$log
	fi

	echo "Finished..."
	exit 0
fi
#------------------------ END OF SCRIPT -------------------------#
