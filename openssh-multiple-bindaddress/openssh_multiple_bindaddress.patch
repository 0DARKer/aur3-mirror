diff -ru openssh-6.1p1/readconf.c openssh-6.1p1.new/readconf.c
--- openssh-6.1p1/readconf.c	2011-10-02 09:59:03.000000000 +0200
+++ openssh-6.1p1.new/readconf.c	2012-12-18 15:21:00.000000000 +0100
@@ -642,8 +642,10 @@
 		goto parse_string;
 
 	case oBindAddress:
-		charptr = &options->bind_address;
-		goto parse_string;
+          cpptr = (char**)&options->bind_addresses;
+          uintptr = &options->num_bind_address;
+          max_entries =SSH_MAX_BIND_ADDRESSES;
+          goto parse_char_array;
 
 	case oPKCS11Provider:
 		charptr = &options->pkcs11_provider;
@@ -1177,7 +1179,7 @@
 	options->clear_forwardings = -1;
 	options->log_level = SYSLOG_LEVEL_NOT_SET;
 	options->preferred_authentications = NULL;
-	options->bind_address = NULL;
+     options->num_bind_address = 0;
 	options->pkcs11_provider = NULL;
 	options->enable_ssh_keysign = - 1;
 	options->no_host_authentication_for_localhost = - 1;
diff -ru openssh-6.1p1/readconf.h openssh-6.1p1.new/readconf.h
--- openssh-6.1p1/readconf.h	2011-10-02 09:59:03.000000000 +0200
+++ openssh-6.1p1.new/readconf.h	2012-12-18 15:21:00.000000000 +0100
@@ -30,6 +30,11 @@
 
 #define MAX_SEND_ENV		256
 #define SSH_MAX_HOSTS_FILES	256
+#define SSH_MAX_BIND_ADDRESSES     8   /* 16 addresses, should be enough */
+
+#define SSH_BIND_ADDRESS_ANY  "any" /* any address mark, used in
+                                       configuration file */
+#define SSH_BIND_ADDRESS_ANYlen strlen(SSH_BIND_ADDRESS_ANY)
 
 typedef struct {
 	int     forward_agent;	/* Forward authentication agent. */
@@ -90,8 +95,13 @@
 	u_int	num_user_hostfiles;	/* Path for $HOME/.ssh/known_hosts */
 	char   *user_hostfiles[SSH_MAX_HOSTS_FILES];
 	char   *preferred_authentications;
-	char   *bind_address;	/* local socket address for connection to sshd */
-	char   *pkcs11_provider; /* PKCS#11 provider */
+
+     char   *bind_addresses[SSH_MAX_BIND_ADDRESSES];   /* local socket
+                                                          address list for connection to sshd, main reason for this is ipv4 and
+                                                          ipv6 only hosts, when using global host match */
+     u_int   num_bind_address; /* count of bind_addresses */
+
+     char   *pkcs11_provider; /* PKCS#11 provider */
 	int	verify_host_key_dns;	/* Verify host key using DNS */
 
 	int     num_identity_files;	/* Number of files for RSA/DSA identities. */
diff -ru openssh-6.1p1/ssh.c openssh-6.1p1.new/ssh.c
--- openssh-6.1p1/ssh.c	2012-07-06 05:45:01.000000000 +0200
+++ openssh-6.1p1.new/ssh.c	2012-12-18 15:21:00.000000000 +0100
@@ -597,7 +597,8 @@
 			options.control_path = xstrdup(optarg);
 			break;
 		case 'b':
-			options.bind_address = optarg;
+               options.bind_addresses[0]  = optarg;
+               options.num_bind_address = 1;
 			break;
 		case 'F':
 			config = optarg;
diff -ru openssh-6.1p1/ssh_config openssh-6.1p1.new/ssh_config
--- openssh-6.1p1/ssh_config	2010-01-12 09:40:27.000000000 +0100
+++ openssh-6.1p1.new/ssh_config	2012-12-16 13:18:30.000000000 +0100
@@ -45,3 +45,8 @@
 #   PermitLocalCommand no
 #   VisualHostKey no
 #   ProxyCommand ssh -q -W %h:%p gateway.example.com
+
+#   --Example of BindAddress
+#   BindAddress 192.168.0.1 3004:aaaa::beef any
+#   This means, that ssh tries 192.168.0.1 if fail to bind, next address willbe 3004:aaaa::beef and if it fails,
+#    uses default bind strategy, bind on any address
diff -ru openssh-6.1p1/ssh_config.5 openssh-6.1p1.new/ssh_config.5
--- openssh-6.1p1/ssh_config.5	2012-07-02 10:53:38.000000000 +0200
+++ openssh-6.1p1.new/ssh_config.5	2012-12-16 13:19:23.000000000 +0100
@@ -145,8 +145,11 @@
 The default is
 .Dq no .
 .It Cm BindAddress
-Use the specified address on the local machine as the source address of
-the connection.
+Use the specified address (or addresses seperated by space ) on the
+local machine as the source address of
+the connection. This list can be interrupted with
+.Dq any
+address.
 Only useful on systems with more than one address.
 Note that this option does not work if
 .Cm UsePrivilegedPort
diff -ru openssh-6.1p1/sshconnect.c openssh-6.1p1.new/sshconnect.c
--- openssh-6.1p1/sshconnect.c	2011-05-29 13:42:34.000000000 +0200
+++ openssh-6.1p1.new/sshconnect.c	2012-12-18 15:21:00.000000000 +0100
@@ -189,6 +189,7 @@
 {
 	int sock, gaierr;
 	struct addrinfo hints, *res;
+     uint i=0;
 
 	/*
 	 * If we are running as root and want to connect to a privileged
@@ -214,28 +215,61 @@
 	fcntl(sock, F_SETFD, FD_CLOEXEC);
 
 	/* Bind the socket to an alternative local IP address */
-	if (options.bind_address == NULL)
+     if (options.num_bind_address == 0){
 		return sock;
+     }
 
-	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = ai->ai_family;
-	hints.ai_socktype = ai->ai_socktype;
-	hints.ai_protocol = ai->ai_protocol;
-	hints.ai_flags = AI_PASSIVE;
-	gaierr = getaddrinfo(options.bind_address, NULL, &hints, &res);
-	if (gaierr) {
-		error("getaddrinfo: %s: %s", options.bind_address,
-		    ssh_gai_strerror(gaierr));
-		close(sock);
-		return -1;
+     uint addrfound = 0;
+     uint last_idx = options.num_bind_address - 1; // last address index
+
+     verbose("Trying %d addresses to connect",options.num_bind_address);
+     for(i=0;i<options.num_bind_address;++i){
+
+          if (strncmp(options.bind_addresses[i],SSH_BIND_ADDRESS_ANY,SSH_BIND_ADDRESS_ANYlen) == 0){ // any flag, do not bind, can by anywhere
+               logit("warning requested 'any' address in BindAddress");
+               return sock;
+          }
+
+          memset(&hints, 0, sizeof(hints));
+          hints.ai_family = ai->ai_family;
+          hints.ai_socktype = ai->ai_socktype;
+          hints.ai_protocol = ai->ai_protocol;
+          hints.ai_flags = AI_PASSIVE;
+          gaierr = getaddrinfo(options.bind_addresses[i], NULL, &hints, &res);
+          if (gaierr) {
+               error("getaddrinfo: %s: %s", options.bind_addresses[i],
+                    ssh_gai_strerror(gaierr));
+               if ( i == last_idx){
+                    close(sock);
+                    return -1;
+               } else {
+                    error("We have more addresses, trying next address: %s",options.bind_addresses[i+1]);
+                    continue;
+               }
+          }
+
+          if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
+               error("bind: %s: %s", options.bind_addresses[i], strerror(errno));
+               if (  i == last_idx){
+                    close(sock);
+                    freeaddrinfo(res);
+                    return -1;
+               } else {
+                    error("We have more addresses, trying next address: %s",options.bind_addresses[i+1]);
+                    continue;
+               }
+          } else {
+             addrfound = 1;
+             break;
+          }
+          freeaddrinfo(res);
 	}
-	if (bind(sock, res->ai_addr, res->ai_addrlen) < 0) {
-		error("bind: %s: %s", options.bind_address, strerror(errno));
+
+     if (!addrfound){
+          error("no bindable addres is found, exiting");
 		close(sock);
-		freeaddrinfo(res);
 		return -1;
 	}
-	freeaddrinfo(res);
 	return sock;
 }
 
