diff -urN xf86-input-wacom-0.10.10.orig/src/wcmUSB.c xf86-input-wacom-0.10.10/src/wcmUSB.c
--- xf86-input-wacom-0.10.10.orig/src/wcmUSB.c	2010-11-19 00:19:26.000000000 +0100
+++ xf86-input-wacom-0.10.10/src/wcmUSB.c	2011-01-01 21:56:27.000000000 +0100
@@ -28,9 +28,6 @@
 #include <linux/input.h>
 #include <sys/utsname.h>
 
-#ifndef BTN_TASK
-#define BTN_TASK 0x117
-#endif
 #define MAX_USB_EVENTS 32
 
 typedef struct {
@@ -147,7 +144,7 @@
 }
 
 /* Key codes used to mark tablet buttons -- must be in sync
- * with the keycode array in wacom.c kernel driver.
+ * with the keycode array in wacom kernel drivers.
  */
 static unsigned short padkey_codes [] = {
 	BTN_0, BTN_1, BTN_2, BTN_3, BTN_4,
@@ -158,6 +155,16 @@
 	BTN_TL, BTN_TR, BTN_TL2, BTN_TR2, BTN_SELECT
 };
 
+/* Fixed mapped stylus and mouse buttons */
+
+#define WCM_USB_MAX_MOUSE_BUTTONS 5
+#define WCM_USB_MAX_STYLUS_BUTTONS 3
+
+static unsigned short mouse_codes [] = {
+	BTN_LEFT, BTN_MIDDLE, BTN_RIGHT, BTN_BACK, BTN_FORWARD,
+	BTN_SIDE, BTN_EXTRA
+};
+
 static struct
 {
 	const unsigned int vendor_id;
@@ -333,25 +340,37 @@
 		common->wcmResolX = common->wcmResolY = 1016;
 	}
 
-	/* Find out supported button codes - except mouse button codes
-	 * BTN_LEFT and BTN_RIGHT, which are always fixed. */
+	/* Find out supported button codes. */
 	common->npadkeys = 0;
 	for (i = 0; i < sizeof (padkey_codes) / sizeof (padkey_codes [0]); i++)
 		if (ISBITSET (common->wcmKeys, padkey_codes [i]))
 			common->padkey_code [common->npadkeys++] = padkey_codes [i];
 
-	if (ISBITSET (common->wcmKeys, BTN_TASK))
-		common->nbuttons = 10;
-	else if (ISBITSET (common->wcmKeys, BTN_BACK))
-		common->nbuttons = 9;
-	else if (ISBITSET (common->wcmKeys, BTN_FORWARD))
-		common->nbuttons = 8;
-	else if (ISBITSET (common->wcmKeys, BTN_EXTRA))
-		common->nbuttons = 7;
-	else if (ISBITSET (common->wcmKeys, BTN_SIDE))
-		common->nbuttons = 6;
+	if (!(ISBITSET (common->wcmKeys, BTN_TOOL_MOUSE)))
+	{
+		/* If mouse buttons detected but no mouse tool
+		 * then they must be associated with pad buttons.
+		 */
+		for (i = sizeof(mouse_codes)/sizeof(mouse_codes[0]); i > 0; i--)
+			if (ISBITSET(common->wcmKeys, mouse_codes[i]))
+				break;
+
+		/* Make sure room for fixed map mouse buttons.  This
+		 * means mappings may overlap with padkey_codes[].
+		 */
+		if (i != 0 && common->npadkeys < WCM_USB_MAX_MOUSE_BUTTONS)
+			common->npadkeys = WCM_USB_MAX_MOUSE_BUTTONS;
+	}
+
+	/* nbuttons tracks maximum buttons on all tools (stylus/mouse).
+	 *
+	 * Mouse support left, middle, right, side, and extra side button.
+	 * Stylus support tip and 2 stlyus buttons.
+	 */
+	if (ISBITSET (common->wcmKeys, BTN_TOOL_MOUSE))
+		common->nbuttons = WCM_USB_MAX_MOUSE_BUTTONS;
 	else
-		common->nbuttons = 5;
+		common->nbuttons = WCM_USB_MAX_STYLUS_BUTTONS;
 
 	return Success;
 }
@@ -923,8 +942,11 @@
 			ds->proximity = (event->value != 0);
 			break;
 
-		case BTN_0:
-		case BTN_FORWARD:
+		case BTN_TOOL_FINGER:
+			/* If a real finger report, ignore. */
+			if (common->wcmProtocolLevel == WCM_PROTOCOL_GENERIC)
+				break;
+
 			DBG(6, common,
 			    "USB Pad detected %x (value=%d)\n",
 			    event->code, event->value);
@@ -1048,10 +1070,12 @@
 			break;
 
 		case BTN_SIDE:
+		case BTN_BACK:
 			MOD_BUTTONS(3, event->value);
 			break;
 
 		case BTN_EXTRA:
+		case BTN_FORWARD:
 			MOD_BUTTONS(4, event->value);
 			break;
 
