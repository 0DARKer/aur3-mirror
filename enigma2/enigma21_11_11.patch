diff -crB Enigma2PC/data/keymap.xml Enigma2PC_orig/data/keymap.xml
*** Enigma2PC/data/keymap.xml	2011-11-20 21:56:11.100830925 +0400
--- Enigma2PC_orig/data/keymap.xml	2011-11-20 03:22:00.000000000 +0400
***************
*** 1,680 ****
! <keymap>
! 	<map context="ListboxActions">
! 		<device name="keyboard">
! 			<key id="a" mapto="up" flags="mr" />
! 			<key id="b" mapto="down" flags="mr" />
! 		</device>
! 		<key id="KEY_UP" mapto="moveUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="moveDown" flags="mr" />
! 		<key id="KEY_HOME" mapto="moveTop" flags="mr" />
! 		<key id="KEY_END" mapto="moveEnd" flags="mr" />
! 		<key id="KEY_PAGEUP" mapto="pageUp" flags="mr" />
! 		<key id="KEY_PAGEDOWN" mapto="pageDown" flags="mr" />
! 		<key id="KEY_LEFT" mapto="pageUp" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="pageDown" flags="mr" />
! 		
! 		<key id="1" mapto="moveUp" flags="mr" />
! 		<key id="2" mapto="moveDown" flags="mr" />
! 	</map>
! 	
! 	<map context="KeyboardInputActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_HOME" mapto="home" flags="mr" />
! 		<key id="KEY_END" mapto="end" flags="mr" />
! 		<key id="KEY_BACK" mapto="home" flags="mr" />
! 		<key id="KEY_FORWARD" mapto="end" flags="mr" />
! 		<key id="KEY_DELETE" mapto="deleteForward" flags="mr" />
! 		<key id="KEY_BACKSPACE" mapto="deleteBackward" flags="mr" />
! 		<key id="KEY_TAB" mapto="tab" flags="mr" />
! 		<key id="KEY_INSERT" mapto="toggleOverwrite" flags="m" />
! 	</map>
! 
! 	<map context="SetupActions">
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_RED" mapto="cancel" flags="m" />
! 		<key id="KEY_GREEN" mapto="save" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 	
! 	<map context="InputActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="InfobarEPGActions">
! 		<key id="KEY_INFO" mapto="showEventInfo" flags="b" />
! 		<key id="KEY_INFO" mapto="showEventInfoPlugin" flags="l" />
! 	</map>
! 	
! 	<map context="InfobarInstantRecord">
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 			<!-- this breaks timeshift end!!! key id="KEY_STOP" mapto="instantRecord" flags="m" /-->
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 		</device>
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="instantRecord" flags="b" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarExtensions">
! 		<key id="KEY_BLUE" mapto="extensions" flags="b" />
! 	</map>
! 	
! 	<map context="SatlistShortcutAction">
! 		<key id="KEY_BLUE" mapto="nothingconnected" flags="b" />
! 	</map>
! 	
! 	<map context="InfobarChannelSelection">
! 		<key id="KEY_LEFT" mapto="zapUp" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="zapDown" flags="mr" />
! 		<key id="KEY_UP" mapto="switchChannelUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="switchChannelDown" flags="mr" />
! 		<key id="KEY_PREVIOUS" mapto="historyBack" flags="mr" />
! 		<key id="KEY_NEXT" mapto="historyNext" flags="mr" />
! 		<key id="KEY_BACK" mapto="historyBack" flags="mr" />
! 		<key id="KEY_FORWARD" mapto="historyNext" flags="mr" />
! 		<key id="KEY_CHANNELUP" mapto="openServiceList" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="openServiceList" flags="m" />
! 		<key id="BTN_0" mapto="zapUp" flags="mr" />
! 		<key id="BTN_1" mapto="zapDown" flags="mr" />
! 	</map>
! 	
! 	<map context="MinuteInputActions">
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="InputAsciiActions">
! 		<device name="Console">
! 			<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
! 		</device>
! 		<device name="SDL">
! 			<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
! 		</device>
! 	</map>
! 
! 	<map context="InputBoxActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="back" flags="m" />
! 		<key id="KEY_ESC" mapto="back" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 	
! 	<map context="WizardActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="back" flags="m" />
! 		<key id="KEY_ESC" mapto="back" flags="m" />
! 	</map>
! 	
! 	<map context="InfobarMenuActions">
! 		<key id="KEY_MENU" mapto="mainMenu" flags="mr" />
! 		<key id="KEY_SPACE" mapto="mainMenu" flags="mr" />
! 	</map>
! 	
! 	<map context="MenuActions">
! 		<key id="KEY_MENU" mapto="menu" flags="mr" />
! 		<key id="KEY_SPACE" mapto="menu" flags="mr" />
! 	</map>
! 	
! 	<map context="InfobarShowHideActions">
! 		<key id="KEY_OK" mapto="toggleShow" flags="m" />
! 		<key id="KEY_ENTER" mapto="toggleShow" flags="m" />
! 		<key id="KEY_EXIT" mapto="hide" flags="m" />
! 		<key id="KEY_ESC" mapto="hide" flags="m" />
! 	</map>
! 
! 	<map context="InfobarActions">
! 		<key id="KEY_VIDEO" mapto="showMovies" flags="m" />
! 		<key id="KEY_RADIO" mapto="showRadio" flags="m" />
! 		<key id="KEY_TV" mapto="showTv" flags="m" />
! 	</map>
! 
! 	<map context="InfobarAudioSelectionActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_YELLOW" mapto="audioSelection" flags="b" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarSubserviceSelectionActions">
! 		<key id="KEY_GREEN" mapto="subserviceSelection" flags="b" />
! 	</map>
! 
! 	<map context="InfobarSubserviceQuickzapActions">
! 		<key id="KEY_PREVIOUS" mapto="prevSubservice" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextSubservice" flags="m" />
! 		<key id="KEY_BACK" mapto="prevSubservice" flags="m" />
! 		<key id="KEY_FORWARD" mapto="nextSubservice" flags="m" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_TV" mapto="exit" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_TV" mapto="exit" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="GlobalActions">
! 		<key id="KEY_VOLUMEUP" mapto="volumeUp" flags="mr" />
! 		<key id="KEY_VOLUMEDOWN" mapto="volumeDown" flags="mr" />
! 		<key id="KEY_MUTE" mapto="volumeMute" flags="mr" />
! 		<key id="KEY_POWER" mapto="power_long" flags="l" />
! 		<key id="KEY_POWER" mapto="power_down" flags="m" />
! 		<key id="KEY_POWER" mapto="power_up" flags="b" />
! 		<device name="dreambox front panel">
! 			<key id="KEY_POWER" mapto="deepstandby" flags="l" />
! 		</device>
! 	</map>
! 	
! 	<map context="PowerKeyActions">
! 		<key id="KEY_POWER" mapto="powerdown" flags="m" />
! 		<key id="KEY_POWER" mapto="powerup" flags="b" />
! 	</map>
! 	
! 	<map context="NumberActions">
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="TextEntryActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 	</map>	
! 
! 	<map context="InfobarSeekActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="pauseService" flags="b" />
! 			<key id="KEY_GREEN" mapto="unPauseService" flags="b" />
! 			<key id="KEY_RED" mapto="seekBack" flags="b" />
! 			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
! 			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAY" mapto="playpauseService" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="playpauseService" flags="m" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PAUSE" mapto="pauseService" flags="m" />
! 			<key id="KEY_PLAY" mapto="playpauseService" flags="m" />
! 			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
! 			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		
! 		<key id="KEY_LEFT" mapto="seekBack" flags="m" />
! 		<key id="KEY_RIGHT" mapto="seekFwd" flags="m" />
! 
! 		<key id="KEY_OK" mapto="unPauseService" flags="m" />
! 		
! 		<key id="KEY_1" mapto="seekdef:1" flags="m" />
! 		<key id="KEY_3" mapto="seekdef:3" flags="m" />
! 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
! 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
! 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
! 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
! 	</map>
! 
! 	<map context="MediaPlayerSeekActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="seekBack" flags="b" />
! 			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
! 			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
! 			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		
! 		<key id="KEY_1" mapto="seekdef:1" flags="m" />
! 		<key id="KEY_3" mapto="seekdef:3" flags="m" />
! 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
! 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
! 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
! 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
! 	</map>
! 
! 	<map context="InfobarTimeshiftActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAY" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 			<key id="KEY_STOP" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_PAUSE" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_STOP" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarTimeshiftActivateActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="timeshiftActivateEnd" flags="b" />
! 			<key id="KEY_YELLOW" mapto="timeshiftActivateEndAndPause" flags="b" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUSSONG" mapto="timeshiftActivateEnd" flags="m" />
! 			<key id="KEY_PLAY" mapto="timeshiftActivateEndAndPause" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_REWIND" mapto="timeshiftActivateEnd" flags="m" />
! 			<key id="KEY_PAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="MovieSelectionActions">
! 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
! 		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
! 		<key id="KEY_INFO" mapto="showEventInfo" flags="m" />
! 	</map>
! 
! 	<map context="InfobarMovieListActions">
! 		<key id="KEY_UP" mapto="up" flags="m" />
! 		<key id="KEY_DOWN" mapto="down" flags="m" />
! 		<key id="KEY_VIDEO" mapto="movieList" flags="m" />
! 	</map>
! 
! 	<map context="MoviePlayerActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 	</map>
! 	
! 	<map context="InfobarCueSheetActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PREVIOUSSONG" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
! 			<key id="KEY_NEXTSONG" mapto="jumpNextMark" flags="m" />
! 		</device>
! 	</map>
! 	
! 	<map context="MediaPlayerCueSheetActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 			<key id="KEY_YELLOW" mapto="toggleMark" flags="b" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="VirtualKeyboardActions">
! 		<key id="KEY_TEXT" mapto="showVirtualKeyboard" flags="m" />
! 	</map>
! 	
! 	<map context="InfobarTeletextActions">
! 		<key id="KEY_TEXT" mapto="startTeletext" flags="m" />
! 	</map>
! 
! 	<map context="InfobarRdsActions">
! 		<key id="KEY_TEXT" mapto="startRassInteractive" flags="m" />
! 	</map>
! 
! 	<map context="RassInteractiveActions">
! 		<key id="KEY_LEFT" mapto="prevSubPage" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="nextSubPage" flags="mr" />
! 		<key id="KEY_UP" mapto="prevPage" flags="mr" />
! 		<key id="KEY_DOWN" mapto="nextPage" flags="mr" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectBaseActions">
! 		<key id="KEY_RED" mapto="showAllServices" flags="m" />
! 		<key id="KEY_GREEN" mapto="showSatellites" flags="m" />
! 		<key id="KEY_YELLOW" mapto="showProviders" flags="m" />
! 		<key id="KEY_BLUE" mapto="showFavourites" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_PREVIOUS" mapto="prevMarker" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextMarker" flags="m" />
! 		<key id="KEY_BACK" mapto="prevMarker" flags="m" />
! 		<key id="KEY_FORWARD" mapto="nextMarker" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectEPGActions">
! 		<key id="KEY_INFO" mapto="showEPGList" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectEditActions">
! 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
! 		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
! 	</map>
! 
! 	<map context="TvRadioActions">
! 		<key id="KEY_TV" mapto="keyTV" flags="m" />
! 		<key id="KEY_RADIO" mapto="keyRadio" flags="m" />
! 	</map>
! 
! 	<map context="TimerEditActions">
! 		<key id="KEY_INFO" mapto="log" flags="m" />
! 	</map>
! 	
! 	<map context="EPGSelectActions">
! 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
! 		<key id="KEY_BLUE" mapto="blue" flags="mr" />
! 		<key id="KEY_RED" mapto="red" flags="m" />
! 		<key id="KEY_INFO" mapto="info" flags="m" />
! 		<key id="KEY_MENU" mapto="input_date_time" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextService" flags="m" />
! 		<key id="KEY_PREVIOUS" mapto="prevService" flags="m" />
! 	</map>
! 
! 	<map context="EventViewActions">
! 		<key id="KEY_UP" mapto="pageUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="pageDown" flags="mr" />
! 		<key id="KEY_LEFT" mapto="prevEvent" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="nextEvent" flags="mr" />
! 		<key id="KEY_RED" mapto="openSimilarList" flags="m" />
! 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
! 		<key id="KEY_INFO" mapto="cancel" flags="m" />
! 	</map>
! 	
! 	<map context="EventViewEPGActions">
! 		<key id="KEY_YELLOW" mapto="openSingleServiceEPG" flags="m" />
! 		<key id="KEY_BLUE" mapto="openMultiServiceEPG" flags="m" />
! 	</map>
! 
! 	<map context="OkCancelActions">
! 		<key id="\x0a" mapto="ok" flags="m" />
! 		<key id="\x1b" mapto="cancel" flags="m" />
! 
! 		<!-- use this on rcu, ok? -->
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 	
! 	<map context="DirectionActions">
! 		<key id="KEY_UP" mapto="up" flags="m" />
! 		<key id="KEY_DOWN" mapto="down" flags="m" />
! 		<key id="KEY_LEFT" mapto="left" flags="m" />
! 		<key id="KEY_RIGHT" mapto="right" flags="m" />
! 
! 		<key id="KEY_UP" mapto="upRepeated" flags="r" />
! 		<key id="KEY_DOWN" mapto="downRepeated" flags="r" />
! 		<key id="KEY_LEFT" mapto="leftRepeated" flags="r" />
! 		<key id="KEY_RIGHT" mapto="rightRepeated" flags="r" />
! 		
! 		<key id="KEY_LEFT" mapto="leftUp" flags="b" />
! 		<key id="KEY_RIGHT" mapto="rightUp" flags="b" />
! 		<key id="KEY_UP" mapto="upUp" flags="b" />
! 		<key id="KEY_DOWN" mapto="downUp" flags="b" />
! 	</map>
! 	
! 	<map context="ColorActions">
! 		<key id="KEY_RED" mapto="red" flags="m" />
! 		<key id="KEY_GREEN" mapto="green" flags="m" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="m" />
! 		<key id="KEY_BLUE" mapto="blue" flags="m" />
! 	</map>
! 
! 	<map context="MsgBoxActions">
! 		<key id="KEY_GREEN" mapto="alwaysOK" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_RED" mapto="cancel" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="WindowActions">
! 		
! 	</map>
! 	
! 	<map context="HelpActions">
! 		<key id="KEY_HELP" mapto="displayHelp" flags="m" />
! 	</map>
! 
! 	<map context="ShortcutActions">
! 		<key id="KEY_F1" mapto="red" flags="mr" />
! 		<key id="KEY_F2" mapto="yellow" flags="mr" />
! 		<key id="KEY_F3" mapto="green" flags="mr" />
! 		<key id="KEY_F4" mapto="blue" flags="mr" />
! 
! 		<key id="KEY_RED" mapto="red" flags="mr" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
! 		<key id="KEY_GREEN" mapto="green" flags="mr" />
! 		<key id="KEY_BLUE" mapto="blue" flags="mr" />
! 	</map>
! 	<map context="StandbyActions">
! 		<key id="KEY_POWER" mapto="power" flags="m" />
! 	</map>
! 	
! 	<map context="SleepTimerEditorActions">
! 		<key id="KEY_OK" mapto="select" flags="m" />
! 		<key id="KEY_ENTER" mapto="select" flags="m" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 		<key id="KEY_LEFT" mapto="selectLeft" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="selectRight" flags="mr" />
! 		<key id="KEY_RED" mapto="disableTimer" flags="mr" />
! 		<key id="KEY_YELLOW" mapto="toggleAsk" flags="mr" />
! 		<key id="KEY_GREEN" mapto="toggleAction" flags="mr" />
! 		<key id="KEY_BLUE" mapto="useServiceTime" flags="mr" />
! 	</map>	
! 	
! 	<map context="CiSelectionActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 	</map>
! 
! 	<map context="PiPSetupActions">
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="size+" flags="mr" />
! 		<key id="KEY_CHANNELDOWN" mapto="size-" flags="mr" />
! 	</map>
! 	
! 	<map context="MediaPlayerActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="pause" flags="m" />
! 			<key id="KEY_GREEN" mapto="play" flags="m" />
! 			<key id="KEY_TV" mapto="stop" flags="b" />
! 			<key id="KEY_TV" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RADIO" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
! 			<key id="KEY_NEXT" mapto="next" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAYPAUSE" mapto="pause" flags="m" />
! 			<key id="KEY_PLAY" mapto="pause" flags="m" />
! 			<key id="KEY_STOP" mapto="stop" flags="b" />
! 			<key id="KEY_STOP" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
! 			<key id="KEY_NEXT" mapto="next" flags="m" />
! 			<key id="KEY_RED" mapto="previous" flags="m" />
! 			<key id="KEY_BLUE" mapto="next" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PAUSE" mapto="pause" flags="m" />
! 			<key id="KEY_PLAY" mapto="play" flags="m" />
! 			<key id="KEY_STOP" mapto="stop" flags="b" />
! 			<key id="KEY_STOP" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUSSONG" mapto="previous" flags="m" />
! 			<key id="KEY_NEXTSONG" mapto="next" flags="m" />
! 		</device>
! 		
! 		<key id="KEY_MENU" mapto="menu" flags="m" />
! 		<key id="KEY_SPACE" mapto="menu" flags="m" />
! 
! 		<key id="KEY_2" mapto="skipListbegin" flags="m" />
! 		<key id="KEY_8" mapto="skipListend" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_VIDEO" mapto="delete" flags="m" />
! 		<key id="KEY_TEXT" mapto="subtitles" flags="m" />
! 	</map>
! </keymap>
--- 1,687 ----
! <keymap>
! 	<map context="ListboxActions">
! 		<device name="keyboard">
! 			<key id="a" mapto="up" flags="mr" />
! 			<key id="b" mapto="down" flags="mr" />
! 		</device>
! 		<key id="KEY_UP" mapto="moveUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="moveDown" flags="mr" />
! 		<key id="KEY_HOME" mapto="moveTop" flags="mr" />
! 		<key id="KEY_END" mapto="moveEnd" flags="mr" />
! 		<key id="KEY_PAGEUP" mapto="pageUp" flags="mr" />
! 		<key id="KEY_PAGEDOWN" mapto="pageDown" flags="mr" />
! 		<key id="KEY_LEFT" mapto="pageUp" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="pageDown" flags="mr" />
! 		<key id="1" mapto="moveUp" flags="mr" />
! 		<key id="2" mapto="moveDown" flags="mr" />
! 	</map>
! 
! 	<map context="KeyboardInputActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_HOME" mapto="home" flags="mr" />
! 		<key id="KEY_END" mapto="end" flags="mr" />
! 		<key id="KEY_BACK" mapto="home" flags="mr" />
! 		<key id="KEY_FORWARD" mapto="end" flags="mr" />
! 		<key id="KEY_DELETE" mapto="deleteForward" flags="mr" />
! 		<key id="KEY_BACKSPACE" mapto="deleteBackward" flags="mr" />
! 		<key id="KEY_TAB" mapto="tab" flags="mr" />
! 		<key id="KEY_INSERT" mapto="toggleOverwrite" flags="m" />
! 	</map>
! 
! 	<map context="SetupActions">
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_RED" mapto="cancel" flags="m" />
! 		<key id="KEY_GREEN" mapto="save" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="InputActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="InfobarEPGActions">
! 		<key id="KEY_INFO" mapto="showEventInfo" flags="b" />
! 		<key id="KEY_INFO" mapto="showEventInfoPlugin" flags="l" />
! 	</map>
! 
! 	<map context="InfobarInstantRecord">
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 			<!-- this breaks timeshift end!!! key id="KEY_STOP" mapto="instantRecord" flags="m" /-->
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 		</device>
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="instantRecord" flags="b" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_RECORD" mapto="instantRecord" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarExtensions">
! 		<key id="KEY_BLUE" mapto="extensions" flags="b" />
! 	</map>
! 
! 	<map context="SatlistShortcutAction">
! 		<key id="KEY_BLUE" mapto="nothingconnected" flags="b" />
! 	</map>
! 
! 	<map context="InfobarChannelSelection">
! 		<key id="KEY_LEFT" mapto="zapUp" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="zapDown" flags="mr" />
! 		<key id="KEY_UP" mapto="switchChannelUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="switchChannelDown" flags="mr" />
! 		<key id="KEY_PREVIOUS" mapto="historyBack" flags="mr" />
! 		<key id="KEY_NEXT" mapto="historyNext" flags="mr" />
! 		<key id="KEY_BACK" mapto="historyBack" flags="mr" />
! 		<key id="KEY_FORWARD" mapto="historyNext" flags="mr" />
! 		<key id="KEY_CHANNELUP" mapto="openServiceList" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="openServiceList" flags="m" />
! 		<key id="BTN_0" mapto="zapUp" flags="mr" />
! 		<key id="BTN_1" mapto="zapDown" flags="mr" />
! 	</map>
! 
! 	<map context="MinuteInputActions">
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="InputAsciiActions">
! 		<device name="Console">
! 			<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
! 		</device>
! 		<device name="SDL">
! 			<key id="KEY_ASCII" mapto="gotAsciiCode" flags="mr" />
! 		</device>
! 	</map>
! 
! 	<map context="InputBoxActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="back" flags="m" />
! 		<key id="KEY_ESC" mapto="back" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="WizardActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="back" flags="m" />
! 		<key id="KEY_ESC" mapto="back" flags="m" />
! 	</map>
! 
! 	<map context="InfobarMenuActions">
! 		<key id="KEY_MENU" mapto="mainMenu" flags="mr" />
! 		<key id="KEY_SPACE" mapto="mainMenu" flags="mr" />
! 	</map>
! 
! 	<map context="MenuActions">
! 		<key id="KEY_MENU" mapto="menu" flags="mr" />
! 		<key id="KEY_SPACE" mapto="menu" flags="mr" />
! 	</map>
! 
! 	<map context="InfobarShowHideActions">
! 		<key id="KEY_OK" mapto="toggleShow" flags="m" />
! 		<key id="KEY_ENTER" mapto="toggleShow" flags="m" />
! 		<key id="KEY_EXIT" mapto="hide" flags="m" />
! 		<key id="KEY_ESC" mapto="hide" flags="m" />
! 	</map>
! 
! 	<map context="InfobarActions">
! 		<key id="KEY_VIDEO" mapto="showMovies" flags="m" />
! 		<key id="KEY_RADIO" mapto="showRadio" flags="m" />
! 		<key id="KEY_TV" mapto="showTv" flags="m" />
! 	</map>
! 
! 	<map context="InfobarAudioSelectionActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_YELLOW" mapto="audioSelection" flags="b" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_AUDIO" mapto="audioSelection" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarSubserviceSelectionActions">
! 		<key id="KEY_GREEN" mapto="subserviceSelection" flags="b" />
! 	</map>
! 
! 	<map context="InfobarSubserviceQuickzapActions">
! 		<key id="KEY_PREVIOUS" mapto="prevSubservice" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextSubservice" flags="m" />
! 		<key id="KEY_BACK" mapto="prevSubservice" flags="m" />
! 		<key id="KEY_FORWARD" mapto="nextSubservice" flags="m" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_TV" mapto="exit" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_TV" mapto="exit" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="GlobalActions">
! 		<key id="KEY_VOLUMEUP" mapto="volumeUp" flags="mr" />
! 		<key id="KEY_VOLUMEDOWN" mapto="volumeDown" flags="mr" />
! 		<key id="KEY_MUTE" mapto="volumeMute" flags="mr" />
! 		<key id="KEY_POWER" mapto="power_long" flags="l" />
! 		<key id="KEY_POWER" mapto="power_down" flags="m" />
! 		<key id="KEY_POWER" mapto="power_up" flags="b" />
! 		<device name="dreambox front panel">
! 			<key id="KEY_POWER" mapto="deepstandby" flags="l" />
! 		</device>
! 	</map>
! 
! 	<map context="PowerKeyActions">
! 		<key id="KEY_POWER" mapto="powerdown" flags="m" />
! 		<key id="KEY_POWER" mapto="powerup" flags="b" />
! 	</map>
! 
! 	<map context="NumberActions">
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 	</map>
! 
! 	<map context="TextEntryActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_MUTE" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_NEXT" mapto="deleteForward" flags="mr" />
! 			<key id="KEY_PREVIOUS" mapto="deleteBackward" flags="mr" />
! 		</device>
! 	</map>	
! 
! 	<map context="InfobarSeekActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="pauseService" flags="b" />
! 			<key id="KEY_GREEN" mapto="unPauseService" flags="b" />
! 			<key id="KEY_RED" mapto="seekBack" flags="b" />
! 			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
! 			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAY" mapto="playpauseService" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="playpauseService" flags="m" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PAUSE" mapto="pauseService" flags="m" />
! 			<key id="KEY_PLAY" mapto="playpauseService" flags="m" />
! 			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
! 			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_PAUSE" mapto="pauseService" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="playpauseService" flags="m" />
! 			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
! 			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<key id="KEY_LEFT" mapto="seekBack" flags="m" />
! 		<key id="KEY_RIGHT" mapto="seekFwd" flags="m" />
! 		<key id="KEY_OK" mapto="unPauseService" flags="m" />
! 		<key id="KEY_1" mapto="seekdef:1" flags="m" />
! 		<key id="KEY_3" mapto="seekdef:3" flags="m" />
! 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
! 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
! 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
! 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
! 	</map>
! 
! 	<map context="MediaPlayerSeekActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="seekBack" flags="b" />
! 			<key id="KEY_BLUE" mapto="seekFwd" flags="b" />
! 			<key id="KEY_RED" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_BLUE" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBack" flags="b" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwd" flags="b" />
! 			<key id="KEY_PREVIOUSSONG" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_NEXTSONG" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_REWIND" mapto="seekBack" flags="b" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwd" flags="b" />
! 			<key id="KEY_REWIND" mapto="seekBackManual" flags="l" />
! 			<key id="KEY_FASTFORWARD" mapto="seekFwdManual" flags="l" />
! 		</device>
! 		<key id="KEY_1" mapto="seekdef:1" flags="m" />
! 		<key id="KEY_3" mapto="seekdef:3" flags="m" />
! 		<key id="KEY_4" mapto="seekdef:4" flags="m" />
! 		<key id="KEY_6" mapto="seekdef:6" flags="m" />
! 		<key id="KEY_7" mapto="seekdef:7" flags="m" />
! 		<key id="KEY_8" mapto="seekFwd" flags="b" />
! 	    <key id="KEY_0" mapto="seekBack" flags="b" />
! 		<key id="KEY_9" mapto="seekdef:9" flags="m" />
! 	</map>
! 
! 	<map context="InfobarTimeshiftActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAY" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 			<key id="KEY_STOP" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_PAUSE" mapto="timeshiftStart" flags="m" />
! 			<key id="KEY_STOP" mapto="timeshiftStop" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_YELLOW" mapto="timeshiftStart" flags="b" />
! 			<key id="KEY_TV" mapto="timeshiftStop" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftStart" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarTimeshiftActivateActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_RED" mapto="timeshiftActivateEnd" flags="b" />
! 			<key id="KEY_YELLOW" mapto="timeshiftActivateEndAndPause" flags="b" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUSSONG" mapto="timeshiftActivateEnd" flags="m" />
! 			<key id="KEY_PLAY" mapto="timeshiftActivateEndAndPause" flags="m" />
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_REWIND" mapto="timeshiftActivateEnd" flags="m" />
! 			<key id="KEY_PAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_PLAYPAUSE" mapto="timeshiftActivateEndAndPause" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="MovieSelectionActions">
! 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
! 		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
! 		<key id="KEY_INFO" mapto="showEventInfo" flags="m" />
! 	</map>
! 
! 	<map context="InfobarMovieListActions">
! 		<key id="KEY_UP" mapto="up" flags="m" />
! 		<key id="KEY_DOWN" mapto="down" flags="m" />
! 		<key id="KEY_VIDEO" mapto="movieList" flags="m" />
! 	</map>
! 
! 	<map context="MoviePlayerActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_TV" mapto="leavePlayer" flags="m" />
! 			<key id="KEY_STOP" mapto="leavePlayer" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="InfobarCueSheetActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PREVIOUS" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 			<key id="KEY_NEXT" mapto="jumpNextMark" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PREVIOUSSONG" mapto="jumpPreviousMark" flags="m" />
! 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
! 			<key id="KEY_NEXTSONG" mapto="jumpNextMark" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="MediaPlayerCueSheetActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_0" mapto="toggleMark" flags="m" />
! 			<key id="KEY_YELLOW" mapto="toggleMark" flags="b" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_TAB" mapto="toggleMark" flags="m" />
! 		</device>
! 	</map>
! 
! 	<map context="VirtualKeyboardActions">
! 		<key id="KEY_TEXT" mapto="showVirtualKeyboard" flags="m" />
! 	</map>
! 
! 	<map context="InfobarTeletextActions">
! 		<key id="KEY_TEXT" mapto="startTeletext" flags="m" />
! 	</map>
! 
! 	<map context="InfobarRdsActions">
! 		<key id="KEY_TEXT" mapto="startRassInteractive" flags="m" />
! 	</map>
! 
! 	<map context="RassInteractiveActions">
! 		<key id="KEY_LEFT" mapto="prevSubPage" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="nextSubPage" flags="mr" />
! 		<key id="KEY_UP" mapto="prevPage" flags="mr" />
! 		<key id="KEY_DOWN" mapto="nextPage" flags="mr" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectBaseActions">
! 		<key id="KEY_RED" mapto="showAllServices" flags="m" />
! 		<key id="KEY_GREEN" mapto="showSatellites" flags="m" />
! 		<key id="KEY_YELLOW" mapto="showProviders" flags="m" />
! 		<key id="KEY_BLUE" mapto="showFavourites" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_PREVIOUS" mapto="prevMarker" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextMarker" flags="m" />
! 		<key id="KEY_BACK" mapto="prevMarker" flags="m" />
! 		<key id="KEY_FORWARD" mapto="nextMarker" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectEPGActions">
! 		<key id="KEY_INFO" mapto="showEPGList" flags="m" />
! 		<key id="KEY_EPG" mapto="showEPGList" flags="m" />
! 	</map>
! 
! 	<map context="ChannelSelectEditActions">
! 		<key id="KEY_MENU" mapto="contextMenu" flags="m" />
! 		<key id="KEY_SPACE" mapto="contextMenu" flags="m" />
! 	</map>
! 
! 	<map context="TvRadioActions">
! 		<key id="KEY_TV" mapto="keyTV" flags="m" />
! 		<key id="KEY_RADIO" mapto="keyRadio" flags="m" />
! 	</map>
! 
! 	<map context="TimerEditActions">
! 		<key id="KEY_INFO" mapto="log" flags="m" />
! 	</map>
! 
! 	<map context="EPGSelectActions">
! 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
! 		<key id="KEY_BLUE" mapto="blue" flags="mr" />
! 		<key id="KEY_RED" mapto="red" flags="m" />
! 		<key id="KEY_INFO" mapto="info" flags="m" />
! 		<key id="KEY_MENU" mapto="input_date_time" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_NEXT" mapto="nextService" flags="m" />
! 		<key id="KEY_PREVIOUS" mapto="prevService" flags="m" />
! 	</map>
! 
! 	<map context="EventViewActions">
! 		<key id="KEY_UP" mapto="pageUp" flags="mr" />
! 		<key id="KEY_DOWN" mapto="pageDown" flags="mr" />
! 		<key id="KEY_LEFT" mapto="prevEvent" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="nextEvent" flags="mr" />
! 		<key id="KEY_RED" mapto="openSimilarList" flags="m" />
! 		<key id="KEY_GREEN" mapto="timerAdd" flags="m" />
! 		<key id="KEY_INFO" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="EventViewEPGActions">
! 		<key id="KEY_YELLOW" mapto="openSingleServiceEPG" flags="m" />
! 		<key id="KEY_BLUE" mapto="openMultiServiceEPG" flags="m" />
! 	</map>
! 
! 	<map context="OkCancelActions">
! 		<key id="\x0a" mapto="ok" flags="m" />
! 		<key id="\x1b" mapto="cancel" flags="m" />
! 		<!-- use this on rcu, ok? -->
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="DirectionActions">
! 		<key id="KEY_UP" mapto="up" flags="m" />
! 		<key id="KEY_DOWN" mapto="down" flags="m" />
! 		<key id="KEY_LEFT" mapto="left" flags="m" />
! 		<key id="KEY_RIGHT" mapto="right" flags="m" />
! 		<key id="KEY_UP" mapto="upRepeated" flags="r" />
! 		<key id="KEY_DOWN" mapto="downRepeated" flags="r" />
! 		<key id="KEY_LEFT" mapto="leftRepeated" flags="r" />
! 		<key id="KEY_RIGHT" mapto="rightRepeated" flags="r" />
! 		<key id="KEY_LEFT" mapto="leftUp" flags="b" />
! 		<key id="KEY_RIGHT" mapto="rightUp" flags="b" />
! 		<key id="KEY_UP" mapto="upUp" flags="b" />
! 		<key id="KEY_DOWN" mapto="downUp" flags="b" />
! 	</map>
! 
! 	<map context="ColorActions">
! 		<key id="KEY_RED" mapto="red" flags="m" />
! 		<key id="KEY_GREEN" mapto="green" flags="m" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="m" />
! 		<key id="KEY_BLUE" mapto="blue" flags="m" />
! 	</map>
! 
! 	<map context="MsgBoxActions">
! 		<key id="KEY_GREEN" mapto="alwaysOK" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_RED" mapto="cancel" flags="m" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 	</map>
! 
! 	<map context="WindowActions">
! 	</map>
! 
! 	<map context="HelpActions">
! 		<key id="KEY_HELP" mapto="displayHelp" flags="m" />
! 	</map>
! 
! 	<map context="ShortcutActions">
! 		<key id="KEY_F1" mapto="red" flags="mr" />
! 		<key id="KEY_F2" mapto="yellow" flags="mr" />
! 		<key id="KEY_F3" mapto="green" flags="mr" />
! 		<key id="KEY_F4" mapto="blue" flags="mr" />
! 		<key id="KEY_RED" mapto="red" flags="mr" />
! 		<key id="KEY_YELLOW" mapto="yellow" flags="mr" />
! 		<key id="KEY_GREEN" mapto="green" flags="mr" />
! 		<key id="KEY_BLUE" mapto="blue" flags="mr" />
! 	</map>
! 
! 	<map context="StandbyActions">
! 		<key id="KEY_POWER" mapto="power" flags="m" />
! 	</map>
! 
! 	<map context="SleepTimerEditorActions">
! 		<key id="KEY_OK" mapto="select" flags="m" />
! 		<key id="KEY_ENTER" mapto="select" flags="m" />
! 		<key id="KEY_EXIT" mapto="exit" flags="m" />
! 		<key id="KEY_ESC" mapto="exit" flags="m" />
! 		<key id="KEY_1" mapto="1" flags="m" />
! 		<key id="KEY_2" mapto="2" flags="m" />
! 		<key id="KEY_3" mapto="3" flags="m" />
! 		<key id="KEY_4" mapto="4" flags="m" />
! 		<key id="KEY_5" mapto="5" flags="m" />
! 		<key id="KEY_6" mapto="6" flags="m" />
! 		<key id="KEY_7" mapto="7" flags="m" />
! 		<key id="KEY_8" mapto="8" flags="m" />
! 		<key id="KEY_9" mapto="9" flags="m" />
! 		<key id="KEY_0" mapto="0" flags="m" />
! 		<key id="KEY_LEFT" mapto="selectLeft" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="selectRight" flags="mr" />
! 		<key id="KEY_RED" mapto="disableTimer" flags="mr" />
! 		<key id="KEY_YELLOW" mapto="toggleAsk" flags="mr" />
! 		<key id="KEY_GREEN" mapto="toggleAction" flags="mr" />
! 		<key id="KEY_BLUE" mapto="useServiceTime" flags="mr" />
! 	</map>
! 
! 	<map context="CiSelectionActions">
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 	</map>
! 
! 	<map context="PiPSetupActions">
! 		<key id="KEY_UP" mapto="up" flags="mr" />
! 		<key id="KEY_DOWN" mapto="down" flags="mr" />
! 		<key id="KEY_LEFT" mapto="left" flags="mr" />
! 		<key id="KEY_RIGHT" mapto="right" flags="mr" />
! 		<key id="KEY_EXIT" mapto="cancel" flags="m" />
! 		<key id="KEY_ESC" mapto="cancel" flags="m" />
! 		<key id="KEY_ENTER" mapto="ok" flags="m" />
! 		<key id="KEY_OK" mapto="ok" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="size+" flags="mr" />
! 		<key id="KEY_CHANNELDOWN" mapto="size-" flags="mr" />
! 	</map>
! 
! 	<map context="MediaPlayerActions">
! 		<device name="dreambox remote control (native)">
! 			<key id="KEY_YELLOW" mapto="pause" flags="m" />
! 			<key id="KEY_GREEN" mapto="play" flags="m" />
! 			<key id="KEY_TV" mapto="stop" flags="b" />
! 			<key id="KEY_TV" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RADIO" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
! 			<key id="KEY_NEXT" mapto="next" flags="m" />
! 		</device>
! 		<device name="dreambox advanced remote control (native)">
! 			<key id="KEY_PLAYPAUSE" mapto="pause" flags="m" />
! 			<key id="KEY_PLAY" mapto="pause" flags="m" />
! 			<key id="KEY_STOP" mapto="stop" flags="b" />
! 			<key id="KEY_STOP" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUS" mapto="previous" flags="m" />
! 			<key id="KEY_NEXT" mapto="next" flags="m" />
! 			<key id="KEY_RED" mapto="previous" flags="m" />
! 			<key id="KEY_BLUE" mapto="next" flags="m" />
! 		</device>
! 		<device name="dreambox ir keyboard">
! 			<key id="KEY_PAUSE" mapto="pause" flags="m" />
! 			<key id="KEY_PLAY" mapto="play" flags="m" />
! 			<key id="KEY_STOP" mapto="stop" flags="b" />
! 			<key id="KEY_STOP" mapto="shift_stop" flags="l" />
! 			<key id="KEY_RECORD" mapto="shift_record" flags="l" />
! 			<key id="KEY_PREVIOUSSONG" mapto="previous" flags="m" />
! 			<key id="KEY_NEXTSONG" mapto="next" flags="m" />
! 		</device>
! 		<device name="Xlib">
! 			<key id="KEY_YELLOW" mapto="pause" flags="b" />
! 			<key id="KEY_GREEN" mapto="play" flags="m" />
! 			<key id="KEY_RED" mapto="previous" flags="m" />
! 			<key id="KEY_BLUE" mapto="next" flags="m" />
! 			<key id="KEY_2" mapto="pause" flags="b" />
! 			<key id="KEY_5" mapto="play" flags="b" />
! 		</device>
! 		<key id="KEY_MENU" mapto="menu" flags="m" />
! 		<key id="KEY_SPACE" mapto="menu" flags="m" />
! 		<key id="KEY_2" mapto="skipListbegin" flags="m" />
! 		<key id="KEY_8" mapto="skipListend" flags="m" />
! 		<key id="KEY_CHANNELUP" mapto="nextBouquet" flags="m" />
! 		<key id="KEY_CHANNELDOWN" mapto="prevBouquet" flags="m" />
! 		<key id="KEY_VIDEO" mapto="delete" flags="m" />
! 		<key id="KEY_TEXT" mapto="subtitles" flags="m" />
! 	</map>
! </keymap>
diff -crB Enigma2PC/lib/base/condVar.cpp Enigma2PC_orig/lib/base/condVar.cpp
*** Enigma2PC/lib/base/condVar.cpp	2011-11-20 21:56:11.124164167 +0400
--- Enigma2PC_orig/lib/base/condVar.cpp	2011-11-21 02:05:11.705895672 +0400
***************
*** 187,247 ****
    return false;
  }
  
- 
- // --- cTimeMs ---------------------------------------------------------------
- 
- cTimeMs::cTimeMs(int Ms)
- {
-   Set(Ms);
- }
- 
- uint64_t cTimeMs::Now(void)
- {
- #if _POSIX_TIMERS > 0 && defined(_POSIX_MONOTONIC_CLOCK)
- #define MIN_RESOLUTION 5 // ms
-   static bool initialized = false;
-   static bool monotonic = false;
-   struct timespec tp;
-   if (!initialized) {
-      // check if monotonic timer is available and provides enough accurate resolution:
-      if (clock_getres(CLOCK_MONOTONIC, &tp) == 0) {
-         long Resolution = tp.tv_nsec;
-         // require a minimum resolution:
-         if (tp.tv_sec == 0 && tp.tv_nsec <= MIN_RESOLUTION * 1000000) {
-            if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0) {
-               monotonic = true;
-            }
-         }
-      }
-      initialized = true;
-   }
-   if (monotonic) {
-      if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
-         return (uint64_t(tp.tv_sec)) * 1000 + tp.tv_nsec / 1000000;
-      monotonic = false;
-      // fall back to gettimeofday()
-   }
- #else
- #  warning Posix monotonic clock not available
- #endif
-   struct timeval t;
-   if (gettimeofday(&t, NULL) == 0)
-      return (uint64_t(t.tv_sec)) * 1000 + t.tv_usec / 1000;
-   return 0;
- }
- 
- void cTimeMs::Set(int Ms)
- {
-   begin = Now() + Ms;
- }
- 
- bool cTimeMs::TimedOut(void)
- {
-   return Now() >= begin;
- }
- 
- uint64_t cTimeMs::Elapsed(void)
- {
-   return Now() - begin;
- }
- 
--- 187,189 ----
diff -crB Enigma2PC/lib/base/condVar.h Enigma2PC_orig/lib/base/condVar.h
*** Enigma2PC/lib/base/condVar.h	2011-11-20 21:56:11.124164167 +0400
--- Enigma2PC_orig/lib/base/condVar.h	2011-11-21 02:05:11.705895672 +0400
***************
*** 49,64 ****
    bool Lock(cMutex *Mutex);
  };
  
- class cTimeMs {
- private:
-   uint64_t begin;
- public:
-   cTimeMs(int Ms = 0);
-       ///< Creates a timer with ms resolution and an initial timeout of Ms.
-   static uint64_t Now(void);
-   void Set(int Ms = 0);
-   bool TimedOut(void);
-   uint64_t Elapsed(void);
- };
- 
  #endif
--- 49,52 ----
diff -crB Enigma2PC/lib/driver/Makefile.am Enigma2PC_orig/lib/driver/Makefile.am
*** Enigma2PC/lib/driver/Makefile.am	2011-11-20 21:56:11.130830808 +0400
--- Enigma2PC_orig/lib/driver/Makefile.am	2011-11-21 02:05:11.705895672 +0400
***************
*** 40,46 ****
  if HAVE_XLIB
  libenigma_driver_a_SOURCES += \
  	rcxlib.cpp \
! 	rcxlib.h \
! 	rclirc.cpp \
! 	rclirc.h
  endif
--- 40,44 ----
  if HAVE_XLIB
  libenigma_driver_a_SOURCES += \
  	rcxlib.cpp \
! 	rcxlib.h
  endif
Only in Enigma2PC/lib/driver: rclirc.cpp
Only in Enigma2PC/lib/driver: rclirc.h
diff -crB Enigma2PC/lib/dvb/decoder.cpp Enigma2PC_orig/lib/dvb/decoder.cpp
*** Enigma2PC/lib/dvb/decoder.cpp	2011-11-20 21:56:11.134164129 +0400
--- Enigma2PC_orig/lib/dvb/decoder.cpp	2011-11-20 02:56:00.000000000 +0400
***************
*** 1,722 ****
! #include <lib/base/ebase.h>
! #include <lib/base/eerror.h>
! #include <lib/dvb/decoder.h>
! #include <lib/gdi/xineLib.h>
! 
! #include <unistd.h>
! #include <fcntl.h>
! #include <sys/ioctl.h>
! #include <sys/types.h>
! #include <sys/stat.h>
! #include <errno.h>
! 
! 
! DEFINE_REF(eDVBAudio);
! 
! eDVBAudio::eDVBAudio(int dev) : m_dev(dev) {}
! 
! #define ISO_13818_AUDIO          0x04
! #define HDMV_AUDIO_80_PCM        0x80
! #define STREAM_AUDIO_AC3         0x81
! #define HDMV_AUDIO_82_DTS        0x82
! #define HDMV_AUDIO_86_DTS_HD_MA  0x86
! 
! int eDVBAudio::startPid(int pid, int type)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 
! 	int bypass = 0;
! 
! 	switch (type)
! 	{
! 	case aMPEG:
! 		bypass = ISO_13818_AUDIO;
! 		break;
! 	case aAC3:
! 		bypass = STREAM_AUDIO_AC3;
! 		break;
! 	case aDTS:
! 		bypass = HDMV_AUDIO_82_DTS;
! 		break;
! 	case aAAC:
! 		bypass = 8;
! 		break;
! 	case aAACHE:
! 		bypass = 9;
! 		break;
! 	case aLPCM:
! 		bypass = HDMV_AUDIO_80_PCM;
! 		break;
! 	case aDTSHD:
! 		bypass = HDMV_AUDIO_86_DTS_HD_MA;
! 		break;
! 	}
! 
! 	xineLib->setAudioType(pid, bypass);
! 
! 	return 0;
! }
! 
! void eDVBAudio::stop()
! {
! 	eDebug("AUDIO_STOP");
! }
! 
! void eDVBAudio::flush()
! {
! 	eDebug("AUDIO_CLEAR_BUFFER");
! }
! 
! void eDVBAudio::freeze()
! {
! 	eDebug("AUDIO_PAUSE");
! }
! 
! void eDVBAudio::unfreeze()
! {
! 	eDebug("AUDIO_CONTINUE");
! }
! 
! void eDVBAudio::setChannel(int channel)
! {
! 	int val = 0;//AUDIO_STEREO;
! 
! 	/*switch (channel)
! 	{
! 	case aMonoLeft:
! 		val = AUDIO_MONO_LEFT;
! 		break;
! 	case aMonoRight:
! 		val = AUDIO_MONO_RIGHT;
! 		break;
! 	default:
! 		break;
! 	}*/
! 
! 	eDebug("AUDIO_CHANNEL_SELECT(%d)", val);
! }
! 
! int eDVBAudio::getPTS(pts_t &now)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	//if (xineLib->getPTS(now) < 0)
! 	//	eDebug("AUDIO_GET_PTS failed (%m)");
! 	return 0;
! }
! 
! eDVBAudio::~eDVBAudio()
! {
! 	unfreeze();  // why unfreeze here... but not unfreeze video in ~eDVBVideo ?!?
! }
! 
! DEFINE_REF(eDVBVideo);
! 
! eDVBVideo::eDVBVideo(int dev) : m_dev(dev), m_progressive(-1) {}
! 
! // not finally values i think.. !!
! #define VIDEO_STREAMTYPE_MPEG2       0x02
! #define VIDEO_STREAMTYPE_MPEG4_H264  0x1B
! #define VIDEO_STREAMTYPE_VC1         0xEA
! #define VIDEO_STREAMTYPE_MPEG4_Part2 0x10
! #define VIDEO_STREAMTYPE_VC1_SM      0xEA
! #define VIDEO_STREAMTYPE_MPEG1       0x01
! 
! int eDVBVideo::startPid(int pid, int type)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	int streamtype = VIDEO_STREAMTYPE_MPEG2;
! 
! 	switch(type)
! 	{
! 	default:
! 	case MPEG2:
! 		break;
! 	case MPEG4_H264:
! 		streamtype = VIDEO_STREAMTYPE_MPEG4_H264;
! 		break;
! 	case MPEG1:
! 		streamtype = VIDEO_STREAMTYPE_MPEG1;
! 		break;
! 	case MPEG4_Part2:
! 		streamtype = VIDEO_STREAMTYPE_MPEG4_Part2;
! 		break;
! 	case VC1:
! 		streamtype = VIDEO_STREAMTYPE_VC1;
! 		break;
! 	case VC1_SM:
! 		streamtype = VIDEO_STREAMTYPE_VC1_SM;
! 		break;
! 	}
! 
! 	eDebug("VIDEO_SET_STREAMTYPE %d", streamtype);
! 
! 	xineLib->setVideoType(pid, streamtype);
! 
! 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in 
! 	eDebug("VIDEO_PLAY\n");
! 
! 	xineLib->playVideo();
! 
! 	return 0;
! }
! 
! void eDVBVideo::stop()
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	xineLib->stopVideo();
! }
! 
! void eDVBVideo::flush()
! {
! 	eDebug("VIDEO_CLEAR_BUFFER");
! }
! 
! void eDVBVideo::freeze()
! {
! 	eDebug("VIDEO_FREEZE");
! }
! 
! void eDVBVideo::unfreeze()
! {
! 	eDebug("VIDEO_CONTINUE");
! }
! 
! int eDVBVideo::setSlowMotion(int repeat)
! {
! 	eDebug("VIDEO_SLOWMOTION(%d)", repeat);
! 	int ret = 0;
! 
! 	return ret;
! }
! 
! int eDVBVideo::setFastForward(int skip)
! {
! 	eDebug("VIDEO_FAST_FORWARD(%d)", skip);
! 	int ret = 0;
! 
! 	return ret;
! }
! 
! int eDVBVideo::getPTS(pts_t &now)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 
! 	int ret = 0;//xineLib->getPTS(now);
! 	now = 0;
! 
! 	if (ret < 0)
! 		eDebug("VIDEO_GET_PTS failed(%m)");
! 	return ret;
! }
! 
! eDVBVideo::~eDVBVideo() {}
! 
! void eDVBVideo::video_event(int)
! {
! 	struct video_event evt;
! 	eDebug("VIDEO_GET_EVENT");
! #if 0
! 	if (::ioctl(m_fd, VIDEO_GET_EVENT, &evt) < 0)
! 		eDebug("failed (%m)");
! 	else
! 	{
! 		else if (evt.type == VIDEO_EVENT_FRAME_RATE_CHANGED)
! 		{
! 			struct iTSMPEGDecoder::videoEvent event;
! 			event.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
! 			m_framerate = event.framerate = evt.u.frame_rate;
! 			/* emit */ m_event(event);
! 		}
! 		else if (evt.type == 16 /*VIDEO_EVENT_PROGRESSIVE_CHANGED*/)
! 		{
! 			struct iTSMPEGDecoder::videoEvent event;
! 			event.type = iTSMPEGDecoder::videoEvent::eventProgressiveChanged;
! 			m_progressive = event.progressive = evt.u.frame_rate;
! 			/* emit */ m_event(event);
! 		}
! 		else
! 			eDebug("unhandled DVBAPI Video Event %d", evt.type);
! 	}
! #endif
! }
! 
! DEFINE_REF(eDVBPCR);
! 
! eDVBPCR::eDVBPCR(int dev) : m_dev(dev) {}
! 
! int eDVBPCR::startPid(int pid)
! {
! 	eDebug("DEMUX_START - pcr");
! 	return 0;
! }
! 
! void eDVBPCR::stop()
! {
! 	eDebug("DEMUX_STOP - pcr");
! }
! 
! eDVBPCR::~eDVBPCR() {}
! 
! DEFINE_REF(eDVBTText);
! 
! eDVBTText::eDVBTText(int dev) : m_dev(dev) {}
! 
! int eDVBTText::startPid(int pid)
! {
! 	eDebug("DEMUX_START - ttx");
! 
! 	return 0;
! }
! 
! void eDVBTText::stop()
! {
! 	eDebug("DEMUX_STOP - ttx");
! }
! 
! eDVBTText::~eDVBTText() {}
! 
! DEFINE_REF(eTSMPEGDecoder);
! 
! int eTSMPEGDecoder::setState()
! {
! 	int res = 0;
! 
! 	int noaudio = (m_state != statePlay) && (m_state != statePause);
! 	int nott = noaudio; /* actually same conditions */
! 
! 	if ((noaudio && m_audio) || (!m_audio && !noaudio))
! 		m_changed |= changeAudio | changeState;
! 
! 	if ((nott && m_text) || (!m_text && !nott))
! 		m_changed |= changeText | changeState;
! 
! 	const char *decoder_states[] = {"stop", "pause", "play", "decoderfastforward", "trickmode", "slowmotion"};
! 	eDebug("decoder state: %s, vpid=%d, apid=%d", decoder_states[m_state], m_vpid, m_apid);
! 
! 	int changed = m_changed;
! 
! 	if (m_changed & changePCR)
! 	{
! 		if (m_pcr)
! 			m_pcr->stop();
! 		m_pcr = 0;
! 	}
! 	if (m_changed & changeVideo)
! 	{
! 		if (m_video)
! 		{
! 			m_video->stop();
! 			m_video = 0;
! 		}
! 	}
! 	if (m_changed & changeAudio)
! 	{
! 		if (m_audio)
! 			m_audio->stop();
! 		m_audio = 0;
! 	}
! 	if (m_changed & changeText)
! 	{
! 		if (m_text)
! 			m_text->stop();
! 		m_text = 0;
! 	}
! 	if (m_changed & changePCR)
! 	{
! 		if ((m_pcrpid >= 0) && (m_pcrpid < 0x1FFF))
! 		{
! 			m_pcr = new eDVBPCR(m_decoder);
! 			if (m_pcr->startPid(m_pcrpid))
! 				res = -1;
! 		}
! 		m_changed &= ~changePCR;
! 	}
! 	if (m_changed & changeAudio)
! 	{
! 		if ((m_apid >= 0) && (m_apid < 0x1FFF) && !noaudio)
! 		{
! 			m_audio = new eDVBAudio(m_decoder);
! 			if (m_audio->startPid(m_apid, m_atype))
! 				res = -1;
! 		}
! 		m_changed &= ~changeAudio;
! 	}
! 	if (m_changed & changeVideo)
! 	{
! 		if ((m_vpid >= 0) && (m_vpid < 0x1FFF))
! 		{
! 			m_video = new eDVBVideo(m_decoder);
! 			if (m_video->startPid(m_vpid, m_vtype))
! 				res = -1;
! 		}
! 		m_changed &= ~changeVideo;
! 	}
! 	if (m_changed & changeText)
! 	{
! 		if ((m_textpid >= 0) && (m_textpid < 0x1FFF) && !nott)
! 		{
! 			m_text = new eDVBTText(m_decoder);
! 			if (m_text->startPid(m_textpid))
! 				res = -1;
! 		}
! 		m_changed &= ~changeText;
! 	}
! 
! 	if (changed & (changeState|changeVideo|changeAudio))
! 	{
! 					/* play, slowmotion, fast-forward */
! 		int state_table[6][4] = 
! 			{
! 				/* [stateStop] =                 */ {0, 0, 0},
! 				/* [statePause] =                */ {0, 0, 0},
! 				/* [statePlay] =                 */ {1, 0, 0},
! 				/* [stateDecoderFastForward] =   */ {1, 0, m_ff_sm_ratio},
! 				/* [stateHighspeedFastForward] = */ {1, 0, 1},
! 				/* [stateSlowMotion] =           */ {1, m_ff_sm_ratio, 0}
! 			};
! 		int *s = state_table[m_state];
! 		if (changed & (changeState|changeVideo) && m_video)
! 		{
! 			m_video->setSlowMotion(s[1]);
! 			m_video->setFastForward(s[2]);
! 			if (s[0])
! 				m_video->unfreeze();
! 			else
! 				m_video->freeze();
! 		}
! 		if (changed & (changeState|changeAudio) && m_audio)
! 		{
! 			if (s[0])
! 				m_audio->unfreeze();
! 			else
! 				m_audio->freeze();
! 		}
! 		m_changed &= ~changeState;
! 	}
! 
! 	if (changed && !m_video && m_audio && m_radio_pic.length())
! 		showSinglePic(m_radio_pic.c_str());
! 
! 	return res;
! }
! 
! int eTSMPEGDecoder::m_pcm_delay=-1,
! 	eTSMPEGDecoder::m_ac3_delay=-1;
! 
! RESULT eTSMPEGDecoder::setHwPCMDelay(int delay)
! {
! 	if (delay != m_pcm_delay )
! 	{
! 		FILE *fp = fopen("/proc/stb/audio/audio_delay_pcm", "w");
! 		if (fp)
! 		{
! 			fprintf(fp, "%x", delay*90);
! 			fclose(fp);
! 			m_pcm_delay = delay;
! 			return 0;
! 		}
! 	}
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::setHwAC3Delay(int delay)
! {
! 	if ( delay != m_ac3_delay )
! 	{
! 		FILE *fp = fopen("/proc/stb/audio/audio_delay_bitstream", "w");
! 		if (fp)
! 		{
! 			fprintf(fp, "%x", delay*90);
! 			fclose(fp);
! 			m_ac3_delay = delay;
! 			return 0;
! 		}
! 	}
! 	return -1;
! }
! 
! 
! RESULT eTSMPEGDecoder::setPCMDelay(int delay)
! {
! 	return m_decoder == 0 ? setHwPCMDelay(delay) : -1;
! }
! 
! RESULT eTSMPEGDecoder::setAC3Delay(int delay)
! {
! 	return m_decoder == 0 ? setHwAC3Delay(delay) : -1;
! }
! 
! eTSMPEGDecoder::eTSMPEGDecoder(int decoder)
! 	: m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
! 	  m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
! {
! 	CONNECT(m_showSinglePicTimer->timeout, eTSMPEGDecoder::finishShowSinglePic);
! 	m_state = stateStop;
! }
! 
! eTSMPEGDecoder::~eTSMPEGDecoder()
! {
! 	finishShowSinglePic();
! 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
! 	m_changed = -1;
! 	setState();
! }
! 
! RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
! {
! printf("eTSMPEGDecoder setVideoPID %d\n", vpid);
! 	if ((m_vpid != vpid) || (m_vtype != type))
! 	{
! 		m_changed |= changeVideo;
! 		m_vpid = vpid;
! 		m_vtype = type;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
! {
! printf("eTSMPEGDecoder setAudioPID %d\n", apid);
! 	if ((m_apid != apid) || (m_atype != type))
! 	{
! 		m_changed |= changeAudio;
! 		m_atype = type;
! 		m_apid = apid;
! 	}
! 
! 	return 0;
! }
! 
! int eTSMPEGDecoder::m_audio_channel = -1;
! 
! RESULT eTSMPEGDecoder::setAudioChannel(int channel)
! {
! 	if (channel == -1)
! 		channel = ac_stereo;
! 	if (m_decoder == 0 && m_audio_channel != channel)
! 	{
! 		if (m_audio)
! 		{
! 			m_audio->setChannel(channel);
! 			m_audio_channel=channel;
! 		}
! 		else
! 			eDebug("eTSMPEGDecoder::setAudioChannel but no audio decoder exist");
! 	}
! 	return 0;
! }
! 
! int eTSMPEGDecoder::getAudioChannel()
! {
! 	return m_audio_channel == -1 ? ac_stereo : m_audio_channel;
! }
! 
! RESULT eTSMPEGDecoder::setSyncPCR(int pcrpid)
! {
! 	if (m_pcrpid != pcrpid)
! 	{
! 		m_changed |= changePCR;
! 		m_pcrpid = pcrpid;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setTextPID(int textpid)
! {
! 	if (m_textpid != textpid)
! 	{
! 		m_changed |= changeText;
! 		m_textpid = textpid;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setSyncMaster(int who)
! {
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::set()
! {
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::play()
! {
! printf("eTSMPEGDecoder play\n");
! 	if (m_state == statePlay)
! 	{
! 		if (!m_changed)
! 			return 0;
! 	} else  
! 	{
! 		m_state = statePlay;
! 		m_changed |= changeState;
! 	}
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::pause()
! {
! printf("eTSMPEGDecoder pause\n");
! 	if (m_state == statePause)
! 		return 0;
! 	m_state = statePause;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::setFastForward(int frames_to_skip)
! {
! 	if ((m_state == stateDecoderFastForward) && (m_ff_sm_ratio == frames_to_skip))
! 		return 0;
! 
! 	m_state = stateDecoderFastForward;
! 	m_ff_sm_ratio = frames_to_skip;
! 	m_changed |= changeState;
! 	return setState();
! 
! //		return m_video->setFastForward(frames_to_skip);
! }
! 
! RESULT eTSMPEGDecoder::setSlowMotion(int repeat)
! {
! 	if ((m_state == stateSlowMotion) && (m_ff_sm_ratio == repeat))
! 		return 0;
! 
! 	m_state = stateSlowMotion;
! 	m_ff_sm_ratio = repeat;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::setTrickmode()
! {
! 	if (m_state == stateTrickmode)
! 		return 0;
! 
! 	m_state = stateTrickmode;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::flush()
! {
! 	if (m_audio)
! 		m_audio->flush();
! 	if (m_video)
! 		m_video->flush();
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::getPTS(int what, pts_t &pts)
! {
! 	if (what == 0) /* auto */
! 		what = m_video ? 1 : 2;
! 
! 	if (what == 1) /* video */
! 	{
! 		if (m_video)
! 			return m_video->getPTS(pts);
! 		else
! 			return -1;
! 	}
! 
! 	if (what == 2) /* audio */
! 	{
! 		if (m_audio)
! 			return m_audio->getPTS(pts);
! 		else
! 			return -1;
! 	}
! 
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::setRadioPic(const std::string &filename)
! {
! 	m_radio_pic = filename;
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::showSinglePic(const char *filename)
! {
! 	if (m_decoder == 0)
! 	{
! 		eDebug("showSinglePic %s", filename);
! 		int f = open(filename, O_RDONLY);
! 		if (f >= 0)
! 		{
! 			struct stat s;
! 			size_t written=0;
! 			fstat(f, &s);
! 			if (m_video_clip_fd == -1)
! 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
! 			if (m_video_clip_fd >= 0)
! 			{
! 				bool seq_end_avail = false;
! 				size_t pos=0;
! 				unsigned char pes_header[] = { 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x80, 0x00, 0x00 };
! 				unsigned char seq_end[] = { 0x00, 0x00, 0x01, 0xB7 };
! 				unsigned char iframe[s.st_size];
! 				unsigned char stuffing[8192];
! 				int streamtype = VIDEO_STREAMTYPE_MPEG2;
! 				memset(stuffing, 0, 8192);
! 				read(f, iframe, s.st_size);
! 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
! 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
! 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
! 					eDebug("VIDEO_PLAY failed (%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
! 					eDebug("video: VIDEO_CONTINUE: %m");
! 				if (ioctl(m_video_clip_fd, VIDEO_CLEAR_BUFFER) < 0)
! 					eDebug("video: VIDEO_CLEAR_BUFFER: %m");
! 				while(pos <= (s.st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
! 					++pos;
! 				if ((iframe[3] >> 4) != 0xE) // no pes header
! 					write(m_video_clip_fd, pes_header, sizeof(pes_header));
! 				else
! 					iframe[4] = iframe[5] = 0x00;
! 				write(m_video_clip_fd, iframe, s.st_size);
! 				if (!seq_end_avail)
! 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
! 				write(m_video_clip_fd, stuffing, 8192);
! 				m_showSinglePicTimer->start(150, true);
! 			}
! 			close(f);
! 		}
! 		else
! 		{
! 			eDebug("couldnt open %s", filename);
! 			return -1;
! 		}
! 	}
! 	else
! 	{
! 		eDebug("only show single pics on first decoder");
! 		return -1;
! 	}
! 	return 0;
! }
! 
! void eTSMPEGDecoder::finishShowSinglePic()
! {
! 	if (m_video_clip_fd >= 0)
! 	{
! 		if (ioctl(m_video_clip_fd, VIDEO_STOP, 0) < 0)
! 			eDebug("VIDEO_STOP failed (%m)");
! 		if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX) < 0)
! 				eDebug("VIDEO_SELECT_SOURCE DEMUX failed (%m)");
! 		close(m_video_clip_fd);
! 		m_video_clip_fd = -1;
! 	}
! }
! 
! RESULT eTSMPEGDecoder::connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
! {
! 	conn = new eConnection(this, m_video_event.connect(event));
! 	return 0;
! }
! 
--- 1,731 ----
! #include <lib/base/ebase.h>
! #include <lib/base/eerror.h>
! #include <lib/dvb/decoder.h>
! #include <lib/gdi/xineLib.h>
! 
! #include <unistd.h>
! #include <fcntl.h>
! #include <sys/ioctl.h>
! #include <sys/types.h>
! #include <sys/stat.h>
! #include <errno.h>
! 
! 
! DEFINE_REF(eDVBAudio);
! 
! eDVBAudio::eDVBAudio(int dev) : m_dev(dev) {}
! 
!       #define STREAM_SPU_BITMAP_HDMV   0x90
! 	  #define ISO_13818_AUDIO          0x04
!       #define STREAM_VIDEO_VC1         0xea    /* VC-1 Video */
!       #define HDMV_AUDIO_80_PCM        0x80 /* BluRay PCM */
! 	  #define STREAM_AUDIO_AC3         0x81
!       #define HDMV_AUDIO_82_DTS        0x82 /* DTS */
!       #define HDMV_AUDIO_83_TRUEHD     0x83 /* Dolby TrueHD, primary audio */
!       #define HDMV_AUDIO_84_EAC3       0x84 /* Dolby Digital plus, primary audio */
!       #define HDMV_AUDIO_85_DTS_HRA    0x85 /* DTS-HRA */
!       #define HDMV_AUDIO_86_DTS_HD_MA  0x86 /* DTS-HD Master audio */
! 
! 
! int eDVBAudio::startPid(int pid, int type)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 
! 	int bypass = 0;
! 
! 	switch (type)
! 	{
! 	case aMPEG:
! 		bypass = ISO_13818_AUDIO;
! 		break;
! 	case aAC3:
! 		bypass = STREAM_AUDIO_AC3;
! 		break;
! 	case aDTS:
! 		bypass = HDMV_AUDIO_82_DTS;
! 		break;
! 	case aAAC:
! 		bypass = 8;
! 		break;
! 	case aAACHE:
! 		bypass = 9;
! 		break;
! 	case aLPCM:
! 		bypass = HDMV_AUDIO_80_PCM;
! 		break;
! 	case aDTSHD:
! 		bypass = HDMV_AUDIO_86_DTS_HD_MA;
! 		break;
! 	}
! 	xineLib->setAudioType(pid, bypass);
! xineLib->playVideo();
! 	return 0;
! }
! 
! void eDVBAudio::stop()
! {
! 	eDebug("AUDIO_STOP");
! }
! 
! void eDVBAudio::flush()
! {
! 	eDebug("AUDIO_CLEAR_BUFFER");
! }
! 
! void eDVBAudio::freeze()
! {
! 	eDebug("AUDIO_PAUSE");
! }
! 
! void eDVBAudio::unfreeze()
! {
! 	eDebug("AUDIO_CONTINUE");
! }
! 
! void eDVBAudio::setChannel(int channel)
! {
! 	int val = 0;//AUDIO_STEREO;
! 
! 	/*switch (channel)
! 	{
! 	case aMonoLeft:
! 		val = AUDIO_MONO_LEFT;
! 		break;
! 	case aMonoRight:
! 		val = AUDIO_MONO_RIGHT;
! 		break;
! 	default:
! 		break;
! 	}*/
! 
! 	eDebug("AUDIO_CHANNEL_SELECT(%d)", val);
! }
! 
! int eDVBAudio::getPTS(pts_t &now)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	//if (xineLib->getPTS(now) < 0)
! 	//	eDebug("AUDIO_GET_PTS failed (%m)");
! 	return 0;
! }
! 
! eDVBAudio::~eDVBAudio()
! {
! 	unfreeze();  // why unfreeze here... but not unfreeze video in ~eDVBVideo ?!?
! }
! 
! DEFINE_REF(eDVBVideo);
! 
! eDVBVideo::eDVBVideo(int dev) : m_dev(dev), m_progressive(-1) {}
! 
! // not finally values i think.. !!
! #define VIDEO_STREAMTYPE_MPEG2       0x02
! #define VIDEO_STREAMTYPE_MPEG4_H264  0x1B
! #define VIDEO_STREAMTYPE_VC1         0xEA
! #define VIDEO_STREAMTYPE_MPEG4_Part2 0x10
! #define VIDEO_STREAMTYPE_VC1_SM      0xEA
! #define VIDEO_STREAMTYPE_MPEG1       0x01
! 
! int eDVBVideo::startPid(int pid, int type)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	int streamtype = VIDEO_STREAMTYPE_MPEG2;
! 
! 	switch(type)
! 	{
! 	default:
! 	case MPEG2:
! 		break;
! 	case MPEG4_H264:
! 		streamtype = VIDEO_STREAMTYPE_MPEG4_H264;
! 		break;
! 	case MPEG1:
! 		streamtype = VIDEO_STREAMTYPE_MPEG1;
! 		break;
! 	case MPEG4_Part2:
! 		streamtype = VIDEO_STREAMTYPE_MPEG4_Part2;
! 		break;
! 	case VC1:
! 		streamtype = VIDEO_STREAMTYPE_VC1;
! 		break;
! 	case VC1_SM:
! 		streamtype = VIDEO_STREAMTYPE_VC1_SM;
! 		break;
! 	}
! 
! 	eDebug("VIDEO_SET_STREAMTYPE %d", streamtype);
! 
! 	xineLib->setVideoType(pid, streamtype);
! 
! 	freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in 
! 	eDebug("VIDEO_PLAY\n");
! 
! 	xineLib->playVideo();
! 
! 	return 0;
! }
! 
! void eDVBVideo::stop()
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	xineLib->stopVideo();
! }
! 
! void eDVBVideo::flush()
! {
! 	eDebug("VIDEO_CLEAR_BUFFER");
! }
! 
! void eDVBVideo::freeze()
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	xineLib->VideoPause();
! 	eDebug("VIDEO_FREEZE");
! }
! 
! void eDVBVideo::unfreeze()
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 	xineLib->VideoResume();
! 	eDebug("VIDEO_CONTINUE");
! }
! 
! int eDVBVideo::setSlowMotion(int repeat)
! {
! 	eDebug("VIDEO_SLOWMOTION(%d)", repeat);
! 	int ret = 0;
! 
! 	return ret;
! }
! 
! int eDVBVideo::setFastForward(int skip)
! {
! 	eDebug("VIDEO_FAST_FORWARD(%d)", skip);
! 	int ret = 0;
! 
! 	return ret;
! }
! 
! int eDVBVideo::getPTS(pts_t &now)
! {
! 	cXineLib *xineLib = cXineLib::getInstance();
! 
! 	int ret = 0;//xineLib->getPTS(now);
! 	now = 0;
! 
! 	if (ret < 0)
! 		eDebug("VIDEO_GET_PTS failed(%m)");
! 	return ret;
! }
! 
! eDVBVideo::~eDVBVideo() {}
! 
! void eDVBVideo::video_event(int)
! {
! 	struct video_event evt;
! 	eDebug("VIDEO_GET_EVENT");
! #if 0
! 	if (::ioctl(m_fd, VIDEO_GET_EVENT, &evt) < 0)
! 		eDebug("failed (%m)");
! 	else
! 	{
! 		else if (evt.type == VIDEO_EVENT_FRAME_RATE_CHANGED)
! 		{
! 			struct iTSMPEGDecoder::videoEvent event;
! 			event.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
! 			m_framerate = event.framerate = evt.u.frame_rate;
! 			/* emit */ m_event(event);
! 		}
! 		else if (evt.type == 16 /*VIDEO_EVENT_PROGRESSIVE_CHANGED*/)
! 		{
! 			struct iTSMPEGDecoder::videoEvent event;
! 			event.type = iTSMPEGDecoder::videoEvent::eventProgressiveChanged;
! 			m_progressive = event.progressive = evt.u.frame_rate;
! 			/* emit */ m_event(event);
! 		}
! 		else
! 			eDebug("unhandled DVBAPI Video Event %d", evt.type);
! 	}
! #endif
! }
! 
! DEFINE_REF(eDVBPCR);
! 
! eDVBPCR::eDVBPCR(int dev) : m_dev(dev) {}
! 
! int eDVBPCR::startPid(int pid)
! {
! 	eDebug("DEMUX_START - pcr");
! 	return 0;
! }
! 
! void eDVBPCR::stop()
! {
! 	eDebug("DEMUX_STOP - pcr");
! }
! 
! eDVBPCR::~eDVBPCR() {}
! 
! DEFINE_REF(eDVBTText);
! 
! eDVBTText::eDVBTText(int dev) : m_dev(dev) {}
! 
! int eDVBTText::startPid(int pid)
! {
! 	eDebug("DEMUX_START - ttx");
! 
! 	return 0;
! }
! 
! void eDVBTText::stop()
! {
! 	eDebug("DEMUX_STOP - ttx");
! }
! 
! eDVBTText::~eDVBTText() {}
! 
! DEFINE_REF(eTSMPEGDecoder);
! 
! int eTSMPEGDecoder::setState()
! {
! 	int res = 0;
! 
! 	int noaudio = (m_state != statePlay) && (m_state != statePause);
! 	int nott = noaudio; /* actually same conditions */
! 
! 	if ((noaudio && m_audio) || (!m_audio && !noaudio))
! 		m_changed |= changeAudio | changeState;
! 
! 	if ((nott && m_text) || (!m_text && !nott))
! 		m_changed |= changeText | changeState;
! 
! 	const char *decoder_states[] = {"stop", "pause", "play", "decoderfastforward", "trickmode", "slowmotion"};
! 	eDebug("decoder state: %s, vpid=%d, apid=%d", decoder_states[m_state], m_vpid, m_apid);
! 
! 	int changed = m_changed;
! 
! 	if (m_changed & changePCR)
! 	{
! 		if (m_pcr)
! 			m_pcr->stop();
! 		m_pcr = 0;
! 	}
! 	if (m_changed & changeVideo)
! 	{
! 		if (m_video)
! 		{
! 			m_video->stop();
! 			m_video = 0;
! 		}
! 	}
! 	if (m_changed & changeAudio)
! 	{
! 		if (m_audio)
! 			m_audio->stop();
! 		m_audio = 0;
! 	}
! 	if (m_changed & changeText)
! 	{
! 		if (m_text)
! 			m_text->stop();
! 		m_text = 0;
! 	}
! 	if (m_changed & changePCR)
! 	{
! 		if ((m_pcrpid >= 0) && (m_pcrpid < 0x1FFF))
! 		{
! 			m_pcr = new eDVBPCR(m_decoder);
! 			if (m_pcr->startPid(m_pcrpid))
! 				res = -1;
! 		}
! 		m_changed &= ~changePCR;
! 	}
! 	if (m_changed & changeAudio)
! 	{
! 		if ((m_apid >= 0) && (m_apid < 0x1FFF) && !noaudio)
! 		{
! 			m_audio = new eDVBAudio(m_decoder);
! 			if (m_audio->startPid(m_apid, m_atype))
! 				res = -1;
! 		}
! 		m_changed &= ~changeAudio;
! 	}
! 	if (m_changed & changeVideo)
! 	{
! 		if ((m_vpid >= 0) && (m_vpid < 0x1FFF))
! 		{
! 			m_video = new eDVBVideo(m_decoder);
! 			if (m_video->startPid(m_vpid, m_vtype))
! 				res = -1;
! 		}
! 		m_changed &= ~changeVideo;
! 	}
! 	if (m_changed & changeText)
! 	{
! 		if ((m_textpid >= 0) && (m_textpid < 0x1FFF) && !nott)
! 		{
! 			m_text = new eDVBTText(m_decoder);
! 			if (m_text->startPid(m_textpid))
! 				res = -1;
! 		}
! 		m_changed &= ~changeText;
! 	}
! 
! 	if (changed & (changeState|changeVideo|changeAudio))
! 	{
! 					/* play, slowmotion, fast-forward */
! 		int state_table[6][4] = 
! 			{
! 				/* [stateStop] =                 */ {0, 0, 0},
! 				/* [statePause] =                */ {0, 0, 0},
! 				/* [statePlay] =                 */ {1, 0, 0},
! 				/* [stateDecoderFastForward] =   */ {1, 0, m_ff_sm_ratio},
! 				/* [stateHighspeedFastForward] = */ {1, 0, 1},
! 				/* [stateSlowMotion] =           */ {1, m_ff_sm_ratio, 0}
! 			};
! 		int *s = state_table[m_state];
! 		if (changed & (changeState|changeVideo) && m_video)
! 		{
! 			m_video->setSlowMotion(s[1]);
! 			m_video->setFastForward(s[2]);
! 			if (s[0])
! 				m_video->unfreeze();
! 			else
! 				m_video->freeze();
! 		}
! 		if (changed & (changeState|changeAudio) && m_audio)
! 		{
! 			if (s[0])
! 				m_audio->unfreeze();
! 			else
! 				m_audio->freeze();
! 		}
! 		m_changed &= ~changeState;
! 	}
! 
! 	if (changed && !m_video && m_audio && m_radio_pic.length())
! 		showSinglePic(m_radio_pic.c_str());
! 
! 	return res;
! }
! 
! int eTSMPEGDecoder::m_pcm_delay=-1,
! 	eTSMPEGDecoder::m_ac3_delay=-1;
! 
! RESULT eTSMPEGDecoder::setHwPCMDelay(int delay)
! {
! 	if (delay != m_pcm_delay )
! 	{
! 		FILE *fp = fopen("/usr/local/etc/stb/audio/audio_delay_pcm", "w");
! 		if (fp)
! 		{
! 			fprintf(fp, "%x", delay*90);
! 			fclose(fp);
! 			m_pcm_delay = delay;
! 			return 0;
! 		}
! 	}
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::setHwAC3Delay(int delay)
! {
! 	if ( delay != m_ac3_delay )
! 	{
! 		FILE *fp = fopen("/usr/local/etc/stb/audio/audio_delay_bitstream", "w");
! 		if (fp)
! 		{
! 			fprintf(fp, "%x", delay*90);
! 			fclose(fp);
! 			m_ac3_delay = delay;
! 			return 0;
! 		}
! 	}
! 	return -1;
! }
! 
! 
! RESULT eTSMPEGDecoder::setPCMDelay(int delay)
! {
! 	return m_decoder == 0 ? setHwPCMDelay(delay) : -1;
! }
! 
! RESULT eTSMPEGDecoder::setAC3Delay(int delay)
! {
! 	return m_decoder == 0 ? setHwAC3Delay(delay) : -1;
! }
! 
! eTSMPEGDecoder::eTSMPEGDecoder(int decoder)
! 	: m_vpid(-1), m_vtype(-1), m_apid(-1), m_atype(-1), m_pcrpid(-1), m_textpid(-1),
! 	  m_changed(0), m_decoder(decoder), m_video_clip_fd(-1), m_showSinglePicTimer(eTimer::create(eApp))
! {
! 	CONNECT(m_showSinglePicTimer->timeout, eTSMPEGDecoder::finishShowSinglePic);
! 	m_state = stateStop;
! }
! 
! eTSMPEGDecoder::~eTSMPEGDecoder()
! {
! 	finishShowSinglePic();
! 	m_vpid = m_apid = m_pcrpid = m_textpid = pidNone;
! 	m_changed = -1;
! 	setState();
! }
! 
! RESULT eTSMPEGDecoder::setVideoPID(int vpid, int type)
! {
! printf("eTSMPEGDecoder setVideoPID %d\n", vpid);
! 	if ((m_vpid != vpid) || (m_vtype != type))
! 	{
! 		m_changed |= changeVideo;
! 		m_vpid = vpid;
! 		m_vtype = type;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setAudioPID(int apid, int type)
! {
! printf("eTSMPEGDecoder setAudioPID %d\n", apid);
! 	if ((m_apid != apid) || (m_atype != type))
! 	{
! 		m_changed |= changeAudio;
! 		m_atype = type;
! 		m_apid = apid;
! 	}
! 
! 	return 0;
! }
! 
! int eTSMPEGDecoder::m_audio_channel = -1;
! 
! RESULT eTSMPEGDecoder::setAudioChannel(int channel)
! {
! 	if (channel == -1)
! 		channel = ac_stereo;
! 	if (m_decoder == 0 && m_audio_channel != channel)
! 	{
! 		if (m_audio)
! 		{
! 			m_audio->setChannel(channel);
! 			m_audio_channel=channel;
! 		}
! 		else
! 			eDebug("eTSMPEGDecoder::setAudioChannel but no audio decoder exist");
! 	}
! 	return 0;
! }
! 
! int eTSMPEGDecoder::getAudioChannel()
! {
! 	return m_audio_channel == -1 ? ac_stereo : m_audio_channel;
! }
! 
! RESULT eTSMPEGDecoder::setSyncPCR(int pcrpid)
! {
! 	if (m_pcrpid != pcrpid)
! 	{
! 		m_changed |= changePCR;
! 		m_pcrpid = pcrpid;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setTextPID(int textpid)
! {
! 	if (m_textpid != textpid)
! 	{
! 		m_changed |= changeText;
! 		m_textpid = textpid;
! 	}
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::setSyncMaster(int who)
! {
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::set()
! {
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::play()
! {
! printf("eTSMPEGDecoder play\n");
! 	if (m_state == statePlay)
! 	{
! 		if (!m_changed)
! 			return 0;
! 	} else  
! 	{
! 		m_state = statePlay;
! 		m_changed |= changeState;
! 	}
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::pause()
! {
! printf("eTSMPEGDecoder pause\n");
! 	if (m_state == statePause)
! 		return 0;
! 	m_state = statePause;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::setFastForward(int frames_to_skip)
! {
! 	if ((m_state == stateDecoderFastForward) && (m_ff_sm_ratio == frames_to_skip))
! 		return 0;
! 
! 	m_state = stateDecoderFastForward;
! 	m_ff_sm_ratio = frames_to_skip;
! 	m_changed |= changeState;
! 	return setState();
! 
! //		return m_video->setFastForward(frames_to_skip);
! }
! 
! RESULT eTSMPEGDecoder::setSlowMotion(int repeat)
! {
! 	if ((m_state == stateSlowMotion) && (m_ff_sm_ratio == repeat))
! 		return 0;
! 
! 	m_state = stateSlowMotion;
! 	m_ff_sm_ratio = repeat;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::setTrickmode()
! {
! 	if (m_state == stateTrickmode)
! 		return 0;
! 
! 	m_state = stateTrickmode;
! 	m_changed |= changeState;
! 	return setState();
! }
! 
! RESULT eTSMPEGDecoder::flush()
! {
! 	if (m_audio)
! 		m_audio->flush();
! 	if (m_video)
! 		m_video->flush();
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::getPTS(int what, pts_t &pts)
! {
! 	if (what == 0) /* auto */
! 		what = m_video ? 1 : 2;
! 
! 	if (what == 1) /* video */
! 	{
! 		if (m_video)
! 			return m_video->getPTS(pts);
! 		else
! 			return -1;
! 	}
! 
! 	if (what == 2) /* audio */
! 	{
! 		if (m_audio)
! 			return m_audio->getPTS(pts);
! 		else
! 			return -1;
! 	}
! 
! 	return -1;
! }
! 
! RESULT eTSMPEGDecoder::setRadioPic(const std::string &filename)
! {
! 	m_radio_pic = filename;
! 	return 0;
! }
! 
! RESULT eTSMPEGDecoder::showSinglePic(const char *filename)
! {
! 	if (m_decoder == 0)
! 	{
! 		eDebug("showSinglePic %s", filename);
! 		int f = open(filename, O_RDONLY);
! 		if (f >= 0)
! 		{
! 			struct stat s;
! 			size_t written=0;
! 			fstat(f, &s);
! 			if (m_video_clip_fd == -1)
! 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
! 			if (m_video_clip_fd >= 0)
! 			{
! 				bool seq_end_avail = false;
! 				size_t pos=0;
! 				unsigned char pes_header[] = { 0x00, 0x00, 0x01, 0xE0, 0x00, 0x00, 0x80, 0x00, 0x00 };
! 				unsigned char seq_end[] = { 0x00, 0x00, 0x01, 0xB7 };
! 				unsigned char iframe[s.st_size];
! 				unsigned char stuffing[8192];
! 				int streamtype = VIDEO_STREAMTYPE_MPEG2;
! 				memset(stuffing, 0, 8192);
! 				read(f, iframe, s.st_size);
! 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
! 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
! 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
! 					eDebug("VIDEO_PLAY failed (%m)");
! 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
! 					eDebug("video: VIDEO_CONTINUE: %m");
! 				if (ioctl(m_video_clip_fd, VIDEO_CLEAR_BUFFER) < 0)
! 					eDebug("video: VIDEO_CLEAR_BUFFER: %m");
! 				while(pos <= (s.st_size-4) && !(seq_end_avail = (!iframe[pos] && !iframe[pos+1] && iframe[pos+2] == 1 && iframe[pos+3] == 0xB7)))
! 					++pos;
! 				if ((iframe[3] >> 4) != 0xE) // no pes header
! 					write(m_video_clip_fd, pes_header, sizeof(pes_header));
! 				else
! 					iframe[4] = iframe[5] = 0x00;
! 				write(m_video_clip_fd, iframe, s.st_size);
! 				if (!seq_end_avail)
! 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
! 				write(m_video_clip_fd, stuffing, 8192);
! 				m_showSinglePicTimer->start(150, true);
! 			}
! 			close(f);
! 		}
! 		else
! 		{
! 			eDebug("couldnt open %s", filename);
! 			return -1;
! 		}
! 	}
! 	else
! 	{
! 		eDebug("only show single pics on first decoder");
! 		return -1;
! 	}
! 	return 0;
! }
! 
! void eTSMPEGDecoder::finishShowSinglePic()
! {
! 	if (m_video_clip_fd >= 0)
! 	{
! 		if (ioctl(m_video_clip_fd, VIDEO_STOP, 0) < 0)
! 			eDebug("VIDEO_STOP failed (%m)");
! 		if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_DEMUX) < 0)
! 				eDebug("VIDEO_SELECT_SOURCE DEMUX failed (%m)");
! 		close(m_video_clip_fd);
! 		m_video_clip_fd = -1;
! 	}
! }
! 
! RESULT eTSMPEGDecoder::connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &conn)
! {
! 	conn = new eConnection(this, m_video_event.connect(event));
! 	return 0;
! }
! 
diff -crB Enigma2PC/lib/dvb/decoder.h Enigma2PC_orig/lib/dvb/decoder.h
*** Enigma2PC/lib/dvb/decoder.h	2011-11-20 21:56:11.134164129 +0400
--- Enigma2PC_orig/lib/dvb/decoder.h	2011-11-17 00:36:00.000000000 +0400
***************
*** 1,168 ****
! #ifndef __decoder_h
! #define __decoder_h
! 
! #include <lib/base/object.h>
! #include <lib/dvb/demux.h>
! #include <lib/gdi/gxlibdc.h>
! 
! class eSocketNotifier;
! 
! class eDVBAudio: public iObject
! {
! 	DECLARE_REF(eDVBAudio);
! private:
! 	int m_dev, m_is_freezed;
! public:
! 	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD };
! 	eDVBAudio(int dev);
! 	enum { aMonoLeft, aStereo, aMonoRight };
! 	void setChannel(int channel);
! 	void stop();
! 	int startPid(int pid, int type);
! 
! 	void flush();
! 	void freeze();
! 	void unfreeze();
! 	int getPTS(pts_t &now);
! 	virtual ~eDVBAudio();
! };
! 
! class eDVBVideo: public iObject, public Object
! {
! 	DECLARE_REF(eDVBVideo);
! private:
! 	int m_dev;
! 
! 	int m_is_slow_motion, m_is_fast_forward, m_is_freezed;
! 	ePtr<eSocketNotifier> m_sn;
! 	void video_event(int what);
! 	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
! 	int m_progressive;
! public:
! 	enum { MPEG2, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM };
! 	eDVBVideo(int dev);
! 	void stop();
! 	int startPid(int pid, int type=MPEG2);
! 
! 	void flush();
! 	void freeze();
! 	int setSlowMotion(int repeat);
! 	int setFastForward(int skip);
! 	void unfreeze();
! 	int getPTS(pts_t &now);
! 	virtual ~eDVBVideo();
! };
! 
! class eDVBPCR: public iObject
! {
! 	DECLARE_REF(eDVBPCR);
! private:
! 	int m_dev;
! public:
! 	eDVBPCR(int dev);
! 	int startPid(int pid);
! 	void stop();
! 	virtual ~eDVBPCR();
! };
! 
! class eDVBTText: public iObject
! {
! 	DECLARE_REF(eDVBTText);
! private:
! 	int m_dev;
! public:
! 	eDVBTText(int dev);
! 	int startPid(int pid);
! 	void stop();
! 	virtual ~eDVBTText();
! };
! 
! class eTSMPEGDecoder: public Object, public iTSMPEGDecoder
! {
! 	DECLARE_REF(eTSMPEGDecoder);
! private:
! 	static int m_pcm_delay;
! 	static int m_ac3_delay;
! 	static int m_audio_channel;
! 	std::string m_radio_pic;
! 	ePtr<eDVBAudio> m_audio;
! 	ePtr<eDVBVideo> m_video;
! 	ePtr<eDVBPCR> m_pcr;
! 	ePtr<eDVBTText> m_text;
! 	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid;
! 	enum
! 	{
! 		changeVideo = 1, 
! 		changeAudio = 2, 
! 		changePCR   = 4,
! 		changeText  = 8,
! 		changeState = 16,
! 	};
! 	int m_changed, m_decoder;
! 	int m_state;
! 	int m_ff_sm_ratio;
! 	int setState();
! 	
! 	Signal1<void, struct videoEvent> m_video_event;
! 	int m_video_clip_fd;
! 	ePtr<eTimer> m_showSinglePicTimer;
! 	void finishShowSinglePic(); // called by timer
! 
! public:
! 
! 	enum { pidNone = -1 };
! 	eTSMPEGDecoder(int decoder);
! 	virtual ~eTSMPEGDecoder();
! 	RESULT setVideoPID(int vpid, int type);
! 	RESULT setAudioPID(int apid, int type);
! 	RESULT setAudioChannel(int channel);
! 	int getAudioChannel();
! 	RESULT setPCMDelay(int delay);
! 	int getPCMDelay() { return m_pcm_delay; }
! 	RESULT setAC3Delay(int delay);
! 	int getAC3Delay() { return m_ac3_delay; }
! 	RESULT setSyncPCR(int pcrpid);
! 	RESULT setTextPID(int textpid);
! 	RESULT setSyncMaster(int who);
! 	
! 		/*
! 		The following states exist:
! 		
! 		 - stop: data source closed, no playback
! 		 - pause: data source active, decoder paused
! 		 - play: data source active, decoder consuming
! 		 - decoder fast forward: data source linear, decoder drops frames
! 		 - trickmode, highspeed reverse: data source fast forwards / reverses, decoder just displays frames as fast as it can
! 		 - slow motion: decoder displays frames multiple times
! 		*/
! 	enum {
! 		stateStop,
! 		statePause,
! 		statePlay,
! 		stateDecoderFastForward,
! 		stateTrickmode,
! 		stateSlowMotion
! 	};
! 	RESULT set(); /* just apply settings, keep state */
! 	RESULT play(); /* -> play */
! 	RESULT pause(); /* -> pause */
! 	RESULT setFastForward(int frames_to_skip); /* -> decoder fast forward */
! 	RESULT setSlowMotion(int repeat); /* -> slow motion **/
! 	RESULT setTrickmode(); /* -> highspeed fast forward */
! 
! 	RESULT flush();
! 	RESULT showSinglePic(const char *filename);
! 	RESULT setRadioPic(const std::string &filename);
! 		/* what 0=auto, 1=video, 2=audio. */
! 	RESULT getPTS(int what, pts_t &pts);
! 	RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
! 	int getVideoWidth() { return -1; };
! 	int getVideoHeight() { return -1; };
! 	int getVideoProgressive() { return -1; };
! 	int getVideoFrameRate() { return -1; };
! 	int getVideoAspect() { return -1; };
! 	static RESULT setHwPCMDelay(int delay);
! 	static RESULT setHwAC3Delay(int delay);
! };
! 
! #endif
--- 1,168 ----
! #ifndef __decoder_h
! #define __decoder_h
! 
! #include <lib/base/object.h>
! #include <lib/dvb/demux.h>
! #include <lib/gdi/gxlibdc.h>
! 
! class eSocketNotifier;
! 
! class eDVBAudio: public iObject
! {
! 	DECLARE_REF(eDVBAudio);
! private:
! 	int m_dev, m_is_freezed;
! public:
! 	enum { aMPEG, aAC3, aDTS, aAAC, aAACHE, aLPCM, aDTSHD };
! 	eDVBAudio(int dev);
! 	enum { aMonoLeft, aStereo, aMonoRight };
! 	void setChannel(int channel);
! 	void stop();
! 	int startPid(int pid, int type);
! 
! 	void flush();
! 	void freeze();
! 	void unfreeze();
! 	int getPTS(pts_t &now);
! 	virtual ~eDVBAudio();
! };
! 
! class eDVBVideo: public iObject, public Object
! {
! 	DECLARE_REF(eDVBVideo);
! private:
! 	int m_dev;
! 
! 	int m_is_slow_motion, m_is_fast_forward, m_is_freezed;
! 	ePtr<eSocketNotifier> m_sn;
! 	void video_event(int what);
! 	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
! 	int m_progressive;
! public:
! 	enum { MPEG2, MPEG4_H264, MPEG1, MPEG4_Part2, VC1, VC1_SM };
! 	eDVBVideo(int dev);
! 	void stop();
! 	int startPid(int pid, int type=MPEG2);
! 
! 	void flush();
! 	void freeze();
! 	int setSlowMotion(int repeat);
! 	int setFastForward(int skip);
! 	void unfreeze();
! 	int getPTS(pts_t &now);
! 	virtual ~eDVBVideo();
! };
! 
! class eDVBPCR: public iObject
! {
! 	DECLARE_REF(eDVBPCR);
! private:
! 	int m_dev;
! public:
! 	eDVBPCR(int dev);
! 	int startPid(int pid);
! 	void stop();
! 	virtual ~eDVBPCR();
! };
! 
! class eDVBTText: public iObject
! {
! 	DECLARE_REF(eDVBTText);
! private:
! 	int m_dev;
! public:
! 	eDVBTText(int dev);
! 	int startPid(int pid);
! 	void stop();
! 	virtual ~eDVBTText();
! };
! 
! class eTSMPEGDecoder: public Object, public iTSMPEGDecoder
! {
! 	DECLARE_REF(eTSMPEGDecoder);
! private:
! 	static int m_pcm_delay;
! 	static int m_ac3_delay;
! 	static int m_audio_channel;
! 	std::string m_radio_pic;
! 	ePtr<eDVBAudio> m_audio;
! 	ePtr<eDVBVideo> m_video;
! 	ePtr<eDVBPCR> m_pcr;
! 	ePtr<eDVBTText> m_text;
! 	int m_vpid, m_vtype, m_apid, m_atype, m_pcrpid, m_textpid;
! 	enum
! 	{
! 		changeVideo = 1, 
! 		changeAudio = 2, 
! 		changePCR   = 4,
! 		changeText  = 8,
! 		changeState = 16,
! 	};
! 	int m_changed, m_decoder;
! 	int m_state;
! 	int m_ff_sm_ratio;
! 	int setState();
! 	
! 	Signal1<void, struct videoEvent> m_video_event;
! 	int m_video_clip_fd;
! 	ePtr<eTimer> m_showSinglePicTimer;
! 	void finishShowSinglePic(); // called by timer
! 
! public:
! 
! 	enum { pidNone = -1 };
! 	eTSMPEGDecoder(int decoder);
! 	virtual ~eTSMPEGDecoder();
! 	RESULT setVideoPID(int vpid, int type);
! 	RESULT setAudioPID(int apid, int type);
! 	RESULT setAudioChannel(int channel);
! 	int getAudioChannel();
! 	RESULT setPCMDelay(int delay);
! 	int getPCMDelay() { return m_pcm_delay; }
! 	RESULT setAC3Delay(int delay);
! 	int getAC3Delay() { return m_ac3_delay; }
! 	RESULT setSyncPCR(int pcrpid);
! 	RESULT setTextPID(int textpid);
! 	RESULT setSyncMaster(int who);
! 	
! 		/*
! 		The following states exist:
! 		
! 		 - stop: data source closed, no playback
! 		 - pause: data source active, decoder paused
! 		 - play: data source active, decoder consuming
! 		 - decoder fast forward: data source linear, decoder drops frames
! 		 - trickmode, highspeed reverse: data source fast forwards / reverses, decoder just displays frames as fast as it can
! 		 - slow motion: decoder displays frames multiple times
! 		*/
! 	enum {
! 		stateStop,
! 		statePause,
! 		statePlay,
! 		stateDecoderFastForward,
! 		stateTrickmode,
! 		stateSlowMotion
! 	};
! 	RESULT set(); /* just apply settings, keep state */
! 	RESULT play(); /* -> play */
! 	RESULT pause(); /* -> pause */
! 	RESULT setFastForward(int frames_to_skip); /* -> decoder fast forward */
! 	RESULT setSlowMotion(int repeat); /* -> slow motion **/
! 	RESULT setTrickmode(); /* -> highspeed fast forward */
! 
! 	RESULT flush();
! 	RESULT showSinglePic(const char *filename);
! 	RESULT setRadioPic(const std::string &filename);
! 		/* what 0=auto, 1=video, 2=audio. */
! 	RESULT getPTS(int what, pts_t &pts);
! 	RESULT connectVideoEvent(const Slot1<void, struct videoEvent> &event, ePtr<eConnection> &connection);
! 	int getVideoWidth() { return -1; };
! 	int getVideoHeight() { return -1; };
! 	int getVideoProgressive() { return -1; };
! 	int getVideoFrameRate() { return -1; };
! 	int getVideoAspect() { return -1; };
! 	static RESULT setHwPCMDelay(int delay);
! 	static RESULT setHwAC3Delay(int delay);
! };
! 
! #endif
diff -crB Enigma2PC/lib/gdi/gxlibdc.cpp Enigma2PC_orig/lib/gdi/gxlibdc.cpp
*** Enigma2PC/lib/gdi/gxlibdc.cpp	2011-11-20 21:56:11.150830730 +0400
--- Enigma2PC_orig/lib/gdi/gxlibdc.cpp	2011-11-20 02:53:00.000000000 +0400
***************
*** 1,356 ****
! #include <fstream>
! #include <lib/gdi/gxlibdc.h>
! #include <lib/actions/action.h>
! #include <lib/base/init.h>
! #include <lib/base/init_num.h>
! #include <lib/base/eenv.h>
! #include <lib/driver/input_fake.h>
! #include <lib/driver/rcxlib.h>
! 
! gXlibDC   *gXlibDC::instance;
! Display   *gXlibDC::display;
! Window    gXlibDC::window;
! int       gXlibDC::width, gXlibDC::height;
! double    gXlibDC::pixel_aspect;
! 
! static const std::string getConfigString(const std::string &key, const std::string &defaultValue)
! {
! 	std::string value = defaultValue;
! 
! 	// get value from enigma2 settings file
! 	std::ifstream in(eEnv::resolve("${sysconfdir}/enigma2/settings").c_str());
! 	if (in.good()) {
! 		do {
! 			std::string line;
! 			std::getline(in, line);
! 			size_t size = key.size();
! 			if (!line.compare(0, size, key) && line[size] == '=') {
! 				value = line.substr(size + 1);
! 				break;
! 			}
! 		} while (in.good());
! 		in.close();
! 	}
! 
! 	return value;
! }
! 
! static bool getConfigBool(const std::string &key, bool defaultValue)
! {
! 	std::string value = getConfigString(key, defaultValue ? "true" : "false");
! 	const char *cvalue = value.c_str();
! 
! 	if (!strcasecmp(cvalue, "true"))
! 		return true;
! 	if (!strcasecmp(cvalue, "false"))
! 		return false;
! 
! 	return defaultValue;
! }
! 
! gXlibDC::gXlibDC() : m_pump(eApp, 1)
! {
! 	double      res_h, res_v;
! 	
! 	umask(0);
! 	mknod("/tmp/ENIGMA_FIFO", S_IFIFO|0666, 0);
! 
! 	CONNECT(m_pump.recv_msg, gXlibDC::pumpEvent);
! 
! 	argb_buffer = NULL;
! 	fullscreen = getConfigBool("config.pc.default_fullscreen", false);
! 	windowWidth  = 720;
! 	windowHeight = 576;
! 
! 	ASSERT(instance == 0);
! 	instance = this;
! 	
! 	if(!XInitThreads())
! 	{
! 		eFatal("XInitThreads() failed\n");
! 		return;
! 	}
! 
! 	if((display = XOpenDisplay(getenv("DISPLAY"))) == NULL) {
! 		eFatal("XOpenDisplay() failed.\n");
! 		return;
! 	}
! 
! 	screen       = XDefaultScreen(display);
! 
! 	if (fullscreen)	{
! 		width  = DisplayWidth( display, screen );
! 		height = DisplayHeight( display, screen );
! 	} else {
! 		width  = windowWidth;
! 		height = windowHeight;
! 	}
! 
! 	XLockDisplay(display);
!  	window = XCreateSimpleWindow(display, XDefaultRootWindow(display), 0, 0, windowWidth, windowHeight, 0, 0, 0);
! 	XSelectInput (display, window, INPUT_MOTION);
! 	XMapRaised(display, window);
! 	res_h = (DisplayWidth(display, screen) * 1000 / DisplayWidthMM(display, screen));
! 	res_v = (DisplayHeight(display, screen) * 1000 / DisplayHeightMM(display, screen));
! 	XSync(display, False);
! 	XUnlockDisplay(display);
! 
! 	wmDelete=XInternAtom(display, "WM_DELETE_WINDOW", True);
! 	XSetWMProtocols(display, window, &wmDelete, 1);
! 
! 	printf("Display resolution %d %d\n", DisplayWidth(display, screen), DisplayHeight(display, screen));
! 
! 	vis.display           = display;
! 	vis.screen            = screen;
! 	vis.d                 = window;
! 	vis.dest_size_cb      = dest_size_cb;
! 	vis.frame_output_cb   = frame_output_cb;
! 	vis.user_data         = NULL;
! 	pixel_aspect          = res_v / res_h;
! 
! 	if(fabs(pixel_aspect - 1.0) < 0.01)
! 		pixel_aspect = 1.0;
! 
! 	xineLib = new cXineLib(&vis);
! 
! 	setResolution(width, height); // default res
! 
! 	run();
! 
! 	/*m_surface.type = 0;
! 	m_surface.clut.colors = 256;
! 	m_surface.clut.data = new gRGB[m_surface.clut.colors];
! 
! 	m_pixmap = new gPixmap(&m_surface);
! 
! 	memset(m_surface.clut.data, 0, sizeof(*m_surface.clut.data)*m_surface.clut.colors);*/
! }
! 
! gXlibDC::~gXlibDC()
! {
! 	instance = 0;
! 
! 	thread_stop = true;
! 	kill();
! 
! 	if (xineLib) {
! 		delete xineLib;
! 		xineLib = NULL;
! 	}
! 
! 	XLockDisplay(display);
! 	XUnmapWindow(display, window);
! 	XDestroyWindow(display, window);
! 	XUnlockDisplay(display);
! 
! 	XCloseDisplay (display);
! }
! 
! void gXlibDC::keyEvent(const XKeyEvent &event)
! {
! 	eXlibInputDriver *driver = eXlibInputDriver::getInstance();
! 
! 	eDebug("SDL Key %s: key=%d", (event.type == KeyPress) ? "Down" : "Up", event.keycode);
! 
! 	if (driver)
! 		driver->keyPressed(event);
! }
! 
! void gXlibDC::pumpEvent(const XKeyEvent &event)
! {
! 	switch (event.type) {
! 	case KeyPress:
! 	case KeyRelease:
! 		switch (event.keycode) {
! 		case 95: // F11
! 			if (event.type==KeyPress) {
! 				fullscreen_switch();
! 			}
! 			break;
! 		case 53: // X
! 			if (event.type==KeyPress) {
! 				eDebug("Enigma2 Quit");
! 				extern void quitMainloop(int exit_code);
! 				quitMainloop(0);
! 			}
! 			break;
! 		default:
! 			keyEvent(event);
! 			break;
! 		}
! 		break;
! 	}
! }
! 
! /*void gSDLDC::pushEvent(enum event code, void *data1, void *data2)
! {
! 	SDL_Event event;
! 
! 	event.type = SDL_USEREVENT;
! 	event.user.code = code;
! 	event.user.data1 = data1;
! 	event.user.data2 = data2;
! 
! 	SDL_PushEvent(&event);
! }*/
! 
! void gXlibDC::exec(const gOpcode *o)
! {
! 	switch (o->opcode)
! 	{
! 	case gOpcode::flush:
! 		eDebug("FLUSH");
! 		xineLib->showOsd();
! 		break;
! 	default:
! 		gDC::exec(o);
! 		break;
! 	}
! }
! 
! void gXlibDC::setResolution(int xres, int yres)
! {
! 	printf("setResolution %d %d\n", xres, yres);
! 	windowWidth  = xres;
! 	windowHeight = yres;
! 
! 	if (!fullscreen) {
! 		width = xres;
! 		height = yres;
! 	}
! 
! 	if (argb_buffer)
! 		delete [] argb_buffer;
! 	argb_buffer = new uint32_t[windowWidth*windowHeight];
! 
! 	xineLib->newOsd(windowWidth, windowHeight, argb_buffer);
! 
! 	m_surface.type = 0;
! 	m_surface.x = windowWidth;
! 	m_surface.y = windowHeight;
! 	m_surface.bpp = 32;
! 	m_surface.bypp = 4;
! 	m_surface.stride = windowWidth*4;
! 	m_surface.data = argb_buffer;
! 	m_surface.offset = 0;
! 
! 	m_pixmap = new gPixmap(&m_surface);
! 
! 	updateWindowState();
! }
! 
! void gXlibDC::updateWindowState() {
! 	if (fullscreen)	{
! 		width  = DisplayWidth( display, screen );
! 		height = DisplayHeight( display, screen );
! 	} else {
! 		width  = windowWidth;
! 		height = windowHeight;
! 	}
! 
! 	XEvent xev;
! 	Atom wm_state = XInternAtom(display, "_NET_WM_STATE", False);
! 	Atom fullscreenAtom = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
! 
! 	memset(&xev, 0, sizeof(xev));
! 	xev.type = ClientMessage;
! 	xev.xclient.window = window;
! 	xev.xclient.message_type = wm_state;
! 	xev.xclient.format = 32;
! 	xev.xclient.data.l[0] = fullscreen ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
! 	xev.xclient.data.l[1] = fullscreenAtom;
! 	xev.xclient.data.l[2] = 0;
! 	XSendEvent(display, XDefaultRootWindow(display), False, SubstructureNotifyMask, &xev);
! 
! 	if (!fullscreen)
! 		XResizeWindow(display, window, windowWidth, windowHeight);
! 
! 	XFlush(display);
! 
! 	xineLib->updateWindowSize(width, height);
! 	xineLib->showOsd();
! }
! 
! void gXlibDC::fullscreen_switch() {
! 	printf("FULLSCREEN EVENT\n");
! 	fullscreen ^= 1;
! 	updateWindowState();
! }
! 
! void gXlibDC::evFlip()
! {
! 	//SDL_Flip(m_screen);
! }
! 
! void gXlibDC::thread()
! {
! 	hasStarted();
! 
! 	int x11_fd = ConnectionNumber(display);
! 	thread_stop = false;
! 	fd_set in_fds;
! 	struct timeval tv;
! 	XEvent event;
! 
! 	while (!thread_stop) {
! 		FD_ZERO(&in_fds);
! 		FD_SET(x11_fd, &in_fds);
! 
! 		tv.tv_usec = 100000;
! 		tv.tv_sec = 0;
! 
! 		if (select(x11_fd+1, &in_fds, 0, 0, &tv))
! 			printf("Event Received!\n");
! 
! 		while(XPending(display))
! 		{
! 			XNextEvent(display, &event);
! 			printf("XNextEvent %d\n", event.type);
! 			switch(event.type)
! 			{
! 			case KeyPress:
! 			case KeyRelease:
! 				{
! 					XKeyEvent& xKeyEvent = (XKeyEvent&)event;
! 					m_pump.send(xKeyEvent);
! 				}
! 				break;
! 			case ClientMessage:
! 				if (event.xclient.data.l[0] == wmDelete) {
! 					thread_stop = true;
! 					XKeyEvent xKeyEvent;
! 					xKeyEvent.type = KeyPress;
! 					xKeyEvent.keycode = 53; // X
! 					m_pump.send(xKeyEvent);
! 				}
! 				break;
! 			case Expose:
! 				xineLib->showOsd();
! 				break;
! 			}
! 		}
! 	}
! }
! 
! void gXlibDC::frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
! 		int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
! 		int *win_x, int *win_y)
! {
! 	*dest_x            = 0;
! 	*dest_y            = 0;
! 	*win_x             = 0;
! 	*win_y             = 0;
! 	*dest_width        = gXlibDC::width;
! 	*dest_height       = gXlibDC::height;
! 	*dest_pixel_aspect = gXlibDC::pixel_aspect;
! }
! 
! void gXlibDC::dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
! 			 int *dest_width, int *dest_height, double *dest_pixel_aspect)
! {
! 	*dest_width        = gXlibDC::width;
! 	*dest_height       = gXlibDC::height;
! 	*dest_pixel_aspect = gXlibDC::pixel_aspect;
! }
! 
! eAutoInitPtr<gXlibDC> init_gXlibDC(eAutoInitNumbers::graphic-1, "gXlibDC");
--- 1,356 ----
! #include <fstream>
! #include <lib/gdi/gxlibdc.h>
! #include <lib/actions/action.h>
! #include <lib/base/init.h>
! #include <lib/base/init_num.h>
! #include <lib/base/eenv.h>
! #include <lib/driver/input_fake.h>
! #include <lib/driver/rcxlib.h>
! 
! gXlibDC   *gXlibDC::instance;
! Display   *gXlibDC::display;
! Window    gXlibDC::window;
! int       gXlibDC::width, gXlibDC::height;
! double    gXlibDC::pixel_aspect;
! static const std::string getConfigString(const std::string &key, const std::string &defaultValue)
! {
! 	std::string value = defaultValue;
! 
! 	// get value from enigma2 settings file
! 	std::ifstream in(eEnv::resolve("${sysconfdir}/enigma2/settings").c_str());
! 	if (in.good()) {
! 		do {
! 			std::string line;
! 			std::getline(in, line);
! 			size_t size = key.size();
! 			if (!line.compare(0, size, key) && line[size] == '=') {
! 				value = line.substr(size + 1);
! 				break;
! 			}
! 		} while (in.good());
! 		in.close();
! 	}
! 
! 	return value;
! }
! 
! static bool getConfigBool(const std::string &key, bool defaultValue)
! {
! 	std::string value = getConfigString(key, defaultValue ? "true" : "false");
! 	const char *cvalue = value.c_str();
! 
! 	if (!strcasecmp(cvalue, "true"))
! 		return true;
! 	if (!strcasecmp(cvalue, "false"))
! 		return false;
! 
! 	return defaultValue;
! }
! 
! gXlibDC::gXlibDC() : m_pump(eApp, 1)
! {
! 	double      res_h, res_v;
! 	
! 	umask(0);
! 	mknod("/tmp/ENIGMA_FIFO", S_IFIFO|0666, 0);
! 
! 	CONNECT(m_pump.recv_msg, gXlibDC::pumpEvent);
! 
! 	argb_buffer = NULL;
! 	fullscreen = getConfigBool("config.pc.default_fullscreen", false);
! 	windowWidth  = 720;
! 	windowHeight = 576;
! 
! 	ASSERT(instance == 0);
! 	instance = this;
! 	
! 	if(!XInitThreads())
! 	{
! 		eFatal("XInitThreads() failed\n");
! 		return;
! 	}
! 
! 	if((display = XOpenDisplay(getenv("DISPLAY"))) == NULL) {
! 		eFatal("XOpenDisplay() failed.\n");
! 		return;
! 	}
! 
! 	screen       = XDefaultScreen(display);
! 
! 	if (fullscreen)	{
! 		width  = DisplayWidth( display, screen );
! 		height = DisplayHeight( display, screen );
! 	} else {
! 		width  = windowWidth;
! 		height = windowHeight;
! 	}
! 
! 	XLockDisplay(display);
!  	window = XCreateSimpleWindow(display, XDefaultRootWindow(display), 0, 0, windowWidth, windowHeight, 0, 0, 0);
! 	XSelectInput (display, window, INPUT_MOTION);
! 	XMapRaised(display, window);
! 	res_h = (DisplayWidth(display, screen) * 1000 / DisplayWidthMM(display, screen));
! 	res_v = (DisplayHeight(display, screen) * 1000 / DisplayHeightMM(display, screen));
! 	XSync(display, False);
! 	XUnlockDisplay(display);
! 
! 	wmDelete=XInternAtom(display, "WM_DELETE_WINDOW", True);
! 	XSetWMProtocols(display, window, &wmDelete, 1);
! 
! 	printf("Display resolution %d %d\n", DisplayWidth(display, screen), DisplayHeight(display, screen));
! 
! 	vis.display           = display;
! 	vis.screen            = screen;
! 	vis.d                 = window;
! 	vis.dest_size_cb      = dest_size_cb;
! 	vis.frame_output_cb   = frame_output_cb;
! 	vis.user_data         = NULL;
! 	pixel_aspect          = res_v / res_h;
! 
! 	if(fabs(pixel_aspect - 1.0) < 0.01)
! 		pixel_aspect = 1.0;
! 
! 	xineLib = new cXineLib(&vis);
! 
! 	setResolution(width, height); // default res
! 
! 	run();
! 
! 	/*m_surface.type = 0;
! 	m_surface.clut.colors = 256;
! 	m_surface.clut.data = new gRGB[m_surface.clut.colors];
! 
! 	m_pixmap = new gPixmap(&m_surface);
! 
! 	memset(m_surface.clut.data, 0, sizeof(*m_surface.clut.data)*m_surface.clut.colors);*/
! }
! 
! gXlibDC::~gXlibDC()
! {
! 	instance = 0;
! 
! 	thread_stop = true;
! 	kill();
! 
! 	if (xineLib) {
! 		delete xineLib;
! 		xineLib = NULL;
! 	}
! 
! 	XLockDisplay(display);
! 	XUnmapWindow(display, window);
! 	XDestroyWindow(display, window);
! 	XUnlockDisplay(display);
! 
! 	XCloseDisplay (display);
! }
! 
! void gXlibDC::keyEvent(const XKeyEvent &event)
! {
! 	eXlibInputDriver *driver = eXlibInputDriver::getInstance();
! xineLib->getVideoFrameRate();
! 	eDebug("SDL Key %s: key=%d", (event.type == KeyPress) ? "Down" : "Up", event.keycode);
! 
! 	if (driver)
! 		driver->keyPressed(event);
! }
! 
! void gXlibDC::pumpEvent(const XKeyEvent &event)
! {
! 	switch (event.type) {
! 	case KeyPress:
! 	case KeyRelease:
! 		switch (event.keycode) {
! 		case 95: // F11
! 			if (event.type==KeyPress) {
! 				fullscreen_switch();
! 			}
! 			break;
! 		case 53: // X
! 			if (event.type==KeyPress) {
! 				eDebug("Enigma2 Quit");
! 				extern void quitMainloop(int exit_code);
! 				quitMainloop(0);
! 			}
! 			break;		
! 		default:
! 			keyEvent(event);
! 			break;
! 		}
! 		break;
! 	}
! 	
! }
! 
! /*void gSDLDC::pushEvent(enum event code, void *data1, void *data2)
! {
! 	SDL_Event event;
! 
! 	event.type = SDL_USEREVENT;
! 	event.user.code = code;
! 	event.user.data1 = data1;
! 	event.user.data2 = data2;
! 
! 	SDL_PushEvent(&event);
! }*/
! 
! void gXlibDC::exec(const gOpcode *o)
! {
! 	switch (o->opcode)
! 	{
! 	case gOpcode::flush:
! 		eDebug("FLUSH");
! 		xineLib->showOsd();
! 		break;
! 	default:
! 		gDC::exec(o);
! 		break;
! 	}
! }
! 
! void gXlibDC::setResolution(int xres, int yres)
! {
! 	printf("setResolution %d %d\n", xres, yres);
! 	windowWidth  = xres;
! 	windowHeight = yres;
! 
! 	if (!fullscreen) {
! 		width = xres;
! 		height = yres;
! 	}
! 
! 	if (argb_buffer)
! 		delete [] argb_buffer;
! 	argb_buffer = new uint32_t[windowWidth*windowHeight];
! 
! 	xineLib->newOsd(windowWidth, windowHeight, argb_buffer);
! 
! 	m_surface.type = 0;
! 	m_surface.x = windowWidth;
! 	m_surface.y = windowHeight;
! 	m_surface.bpp = 32;
! 	m_surface.bypp = 4;
! 	m_surface.stride = windowWidth*4;
! 	m_surface.data = argb_buffer;
! 	m_surface.offset = 0;
! 
! 	m_pixmap = new gPixmap(&m_surface);
! 
! 	updateWindowState();
! }
! 
! void gXlibDC::updateWindowState() {
! 	if (fullscreen)	{
! 		width  = DisplayWidth( display, screen );
! 		height = DisplayHeight( display, screen );
! 	} else {
! 		width  = windowWidth;
! 		height = windowHeight;
! 	}
! 
! 	XEvent xev;
! 	Atom wm_state = XInternAtom(display, "_NET_WM_STATE", False);
! 	Atom fullscreenAtom = XInternAtom(display, "_NET_WM_STATE_FULLSCREEN", False);
! 
! 	memset(&xev, 0, sizeof(xev));
! 	xev.type = ClientMessage;
! 	xev.xclient.window = window;
! 	xev.xclient.message_type = wm_state;
! 	xev.xclient.format = 32;
! 	xev.xclient.data.l[0] = fullscreen ? _NET_WM_STATE_ADD : _NET_WM_STATE_REMOVE;
! 	xev.xclient.data.l[1] = fullscreenAtom;
! 	xev.xclient.data.l[2] = 0;
! 	XSendEvent(display, XDefaultRootWindow(display), False, SubstructureNotifyMask, &xev);
! 
! 	if (!fullscreen)
! 		XResizeWindow(display, window, windowWidth, windowHeight);
! 
! 	XFlush(display);
! 
! 	xineLib->updateWindowSize(width, height);
! 	xineLib->showOsd();
! }
! 
! void gXlibDC::fullscreen_switch() {
! 	printf("FULLSCREEN EVENT\n");
! 	fullscreen ^= 1;
! 	updateWindowState();
! }
! 
! void gXlibDC::evFlip()
! {
! 	//SDL_Flip(m_screen);
! }
! 
! void gXlibDC::thread()
! {
! 	hasStarted();
! 
! 	int x11_fd = ConnectionNumber(display);
! 	thread_stop = false;
! 	fd_set in_fds;
! 	struct timeval tv;
! 	XEvent event;
! 
! 	while (!thread_stop) {
! 		FD_ZERO(&in_fds);
! 		FD_SET(x11_fd, &in_fds);
! 
! 		tv.tv_usec = 100000;
! 		tv.tv_sec = 0;
! 
! 		if (select(x11_fd+1, &in_fds, 0, 0, &tv))
! 			printf("Event Received!\n");
! 
! 		while(XPending(display))
! 		{
! 			XNextEvent(display, &event);
! 			printf("XNextEvent %d\n", event.type);
! 			switch(event.type)
! 			{
! 			case KeyPress:
! 			case KeyRelease:
! 				{
! 					XKeyEvent& xKeyEvent = (XKeyEvent&)event;
! 					m_pump.send(xKeyEvent);
! 				}
! 				break;
! 			case ClientMessage:
! 				if (event.xclient.data.l[0] == wmDelete) {
! 					thread_stop = true;
! 					XKeyEvent xKeyEvent;
! 					xKeyEvent.type = KeyPress;
! 					xKeyEvent.keycode = 53; // X
! 					m_pump.send(xKeyEvent);
! 				}
! 				break;
! 			case Expose:
! 				xineLib->showOsd();
! 				break;
! 			}
! 		}
! 	}
! }
! 
! void gXlibDC::frame_output_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
! 		int *dest_x, int *dest_y, int *dest_width, int *dest_height, double *dest_pixel_aspect,
! 		int *win_x, int *win_y)
! {
! 	*dest_x            = 0;
! 	*dest_y            = 0;
! 	*win_x             = 0;
! 	*win_y             = 0;
! 	*dest_width        = gXlibDC::width;
! 	*dest_height       = gXlibDC::height;
! 	*dest_pixel_aspect = gXlibDC::pixel_aspect;
! }
! 
! void gXlibDC::dest_size_cb(void *data, int video_width, int video_height, double video_pixel_aspect,
! 			 int *dest_width, int *dest_height, double *dest_pixel_aspect)
! {
! 	*dest_width        = gXlibDC::width;
! 	*dest_height       = gXlibDC::height;
! 	*dest_pixel_aspect = gXlibDC::pixel_aspect;
! }
! 
! eAutoInitPtr<gXlibDC> init_gXlibDC(eAutoInitNumbers::graphic-1, "gXlibDC");
diff -crB Enigma2PC/lib/gdi/xineLib.cpp Enigma2PC_orig/lib/gdi/xineLib.cpp
*** Enigma2PC/lib/gdi/xineLib.cpp	2011-11-20 21:56:11.150830730 +0400
--- Enigma2PC_orig/lib/gdi/xineLib.cpp	2011-11-20 03:00:00.000000000 +0400
***************
*** 1,463 ****
! #include <fstream>
! #include <lib/gdi/xineLib.h>
! #include <lib/base/eenv.h>
! 
! cXineLib   *cXineLib::instance;
! 
! DEFINE_REF(cXineLib);
! 
! cXineLib::cXineLib(x11_visual_t *vis) : m_pump(eApp, 1) {
! 	char        configfile[150];
! 	char        vo_driver[] = "vdpau";
! 	char        ao_driver[] = "alsa";
! 
! 	instance = this;
! 	osd = NULL;
! 	stream = NULL;
! 	end_of_stream = false;
! 	videoPlayed = false;
! 
! 	printf("XINE-LIB version: %s\n", xine_get_version_string() );
! 
! 	xine = xine_new();
! 	strcpy(configfile, eEnv::resolve("${datadir}/enigma2/xine.conf").c_str());
! 	printf("configfile  %s\n", configfile);
! 	xine_config_load(xine, configfile);
! 	xine_init(xine);
! 
! 	if((vo_port = xine_open_video_driver(xine, vo_driver, XINE_VISUAL_TYPE_X11, (void *) vis)) == NULL)
! 	{
! 		printf("I'm unable to initialize '%s' video driver. Giving up.\n", vo_driver);
! 		return;
! 	}
! 
! 	ao_port     = xine_open_audio_driver(xine , ao_driver, NULL);
! 	stream      = xine_stream_new(xine, ao_port, vo_port);
! 
! 	if ( (!xine_open(stream, eEnv::resolve("${sysconfdir}/tuxbox/logo.mvi").c_str()))
! 			|| (!xine_play(stream, 0, 0)) ) {
! 		return;
! 	}
! 
! 	//setPrebuffer(150000);
! 	xine_engine_set_param(xine, XINE_ENGINE_PARAM_VERBOSITY, XINE_VERBOSITY_DEBUG);
! 
! 	xine_queue = xine_event_new_queue (stream);
! 	xine_event_create_listener_thread(xine_queue, xine_event_handler, this);
! 
! 	CONNECT(m_pump.recv_msg, cXineLib::pumpEvent);
! 
! 	m_width     = 0;
! 	m_height    = 0;
! 	m_framerate = 0;
! 	m_aspect    = -1;
! 	m_windowAspectRatio = 0;
! 	m_policy43 = 0;
! 	m_policy169 = 0;
! 
! 	m_sharpness = 0;
! 	m_noise = 0;
! }
! 
! cXineLib::~cXineLib() {
! 	instance = 0;
! 
! 	if (stream)
! 	{
! 		xine_stop(stream);
! 		xine_close(stream);
! 
! 		if (xine_queue)
! 		{
! 			xine_event_dispose_queue(xine_queue);
! 			xine_queue = 0;
! 		}
! 
! 		_x_demux_flush_engine(stream);
! 
! 		xine_dispose(stream);
! 		stream = NULL;
! 	}
! 
! 	if (ao_port)
! 		xine_close_audio_driver(xine, ao_port);
! 	if (vo_port)
! 		xine_close_video_driver(xine, vo_port);
! }
! 
! void cXineLib::setVolume(int value) {
! 	xine_set_param (stream, XINE_PARAM_AUDIO_VOLUME, value);
! }
! 
! void cXineLib::setVolumeMute(int value) {
! 	xine_set_param (stream, XINE_PARAM_AUDIO_MUTE, value==0?0:1);
! }
! 
! void cXineLib::showOsd() {
! 	xine_osd_show_scaled(osd, 0);
! 	//stream->osd_renderer->draw_bitmap(osd, (uint8_t*)m_surface.data, 0, 0, 720, 576, temp_bitmap_mapping);
! }
! 
! void cXineLib::newOsd(int width, int height, uint32_t *argb_buffer) {
! 	osdWidth  = width;
! 	osdHeight = height;
! 
! 	if (osd)
! 		xine_osd_free(osd);
! 
! 	osd = xine_osd_new(stream, 0, 0, osdWidth, osdHeight);
! 	xine_osd_set_extent(osd, osdWidth, osdHeight);
! 	xine_osd_set_argb_buffer(osd, argb_buffer, 0, 0, osdWidth, osdHeight);
! }
! 
! void cXineLib::playVideo(void) {
! 	//xine_stop(stream);
! 	end_of_stream = false;
! 	videoPlayed = false;
! 
! 	printf("XINE try START !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	if ( !xine_open(stream, "enigma:/") ) {
! 		printf("Unable to open stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	}
! 
! 	setStreamType(1);
! 	setStreamType(0);
! 
!         //_x_demux_control_start(stream);
!         //_x_demux_seek(stream, 0, 0, 0);
! 
! 	if( !xine_play(stream, 0, 0) ) {
! 		printf("Unable to play stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	}
! 	printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 
! 	videoPlayed = true;
! }
! 
! void cXineLib::stopVideo(void) {
! 	xine_stop(stream);
! 	end_of_stream = false;
! 	videoPlayed = false;
! }
! 
! void cXineLib::setStreamType(int video) {
! 	xine_event_t event;
! 
! 	if (video) {
! 		event.type = XINE_EVENT_SET_VIDEO_STREAMTYPE;
! 		event.data = &videoData;
! 	} else {
! 		event.type = XINE_EVENT_SET_AUDIO_STREAMTYPE;
! 		event.data = &audioData;
! 	}
! 
! 	event.data_length = sizeof (xine_streamtype_data_t);
! 
! 	xine_event_send (stream, &event);
! }
! 
! void cXineLib::setVideoType(int pid, int type) {
! 	videoData.pid = pid;
! 	videoData.streamtype = type;
! }
! 
! void cXineLib::setAudioType(int pid, int type) {
! 	audioData.pid = pid;
! 	audioData.streamtype = type;
! }
! 
! void cXineLib::setPrebuffer(int prebuffer) {
! 	xine_set_param(stream, XINE_PARAM_METRONOM_PREBUFFER, prebuffer);
! }
! 
! void cXineLib::xine_event_handler(void *user_data, const xine_event_t *event)
! {
! 	cXineLib *xineLib = (cXineLib*)user_data;
! 	//if (event->type!=15)
! 	//	printf("I have event %d\n", event->type);
! 
! 	switch (event->type)
! 	{
! 	case XINE_EVENT_UI_PLAYBACK_FINISHED:
! 		printf("XINE_EVENT_UI_PLAYBACK_FINISHED\n");
! 		break;
! 	case XINE_EVENT_NBC_STATS:
! 		return;
! 	case XINE_EVENT_FRAME_FORMAT_CHANGE:
! 		printf("XINE_EVENT_FRAME_FORMAT_CHANGE\n");
! 		{
! 			xine_format_change_data_t* data = (xine_format_change_data_t*)event->data;
! 			printf("width %d  height %d  aspect %d\n", data->width, data->height, data->aspect);
! 
! 			struct iTSMPEGDecoder::videoEvent evt;
! 			evt.type = iTSMPEGDecoder::videoEvent::eventSizeChanged;
! 			xineLib->m_aspect = evt.aspect = data->aspect;
! 			xineLib->m_height = evt.height = data->height;
! 			xineLib->m_width  = evt.width  = data->width;
! 			xineLib->m_pump.send(evt);
! 
! 			xineLib->adjust_policy();
! 		}
! 		return;
! 	case XINE_EVENT_FRAMERATE_CHANGE:
! 		printf("XINE_EVENT_FRAMERATE_CHANGE\n");
! 		{
! 			xine_framerate_data_t* data = (xine_framerate_data_t*)event->data;
! 			printf("framerate %d  \n", data->framerate);
! 
! 			struct iTSMPEGDecoder::videoEvent evt;
! 			evt.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
! 			xineLib->m_framerate = evt.framerate = data->framerate;
! 			xineLib->m_pump.send(evt);
! 		}
! 		return;
! 	case XINE_EVENT_PROGRESS:
! 		{
! 			xine_progress_data_t* data = (xine_progress_data_t*) event->data;
! 			printf("XINE_EVENT_PROGRESS  %s  %d\n", data->description, data->percent);
! 			if (xineLib->videoPlayed && data->percent==0)
! 				xineLib->end_of_stream = true;
! 		}
! 		break;
! 
! 	default:
! 		printf("xine_event_handler(): event->type: %d\n", event->type);
! 		return;
! 	}
! }
! 
! void cXineLib::pumpEvent(const iTSMPEGDecoder::videoEvent &event)
! {
! 	m_event(event);
! }
! 
! int cXineLib::getVideoWidth()
! {
! 	return m_width;
! }
! 
! int cXineLib::getVideoHeight()
! {
! 	return m_height;
! }
! 
! int cXineLib::getVideoFrameRate()
! {
! 	return m_framerate;
! }
! 
! int cXineLib::getVideoAspect()
! {
! 	return m_aspect;
! }
! 
! RESULT cXineLib::getPTS(pts_t &pts)
! {
! 	pts_t* last_pts_l = (pts_t*)vo_port->get_property(vo_port, VO_PROP_LAST_PTS);
! 
! 	pts = *last_pts_l;
! 
! 	if (pts != 0)
! 		return 0;
! 	
! 	return -1;
! }
! 
! void cXineLib::setVideoWindow(int window_x, int window_y, int window_width, int window_height)
! {
! 	int left = window_x * windowWidth / osdWidth;
! 	int top = window_y * windowHeight / osdHeight;
! 	int width = window_width * windowWidth / osdWidth;
! 	int height = window_height * windowHeight / osdHeight;
! 
! 	xine_osd_set_video_window(osd, left, top, width, height);
! 	showOsd();
! }
! 
! void cXineLib::updateWindowSize(int width, int height)
! {
! 	windowWidth  = width;
! 	windowHeight = height;
! }
! 
! void cXineLib::setDeinterlace(int global, int sd, int hd)
! {
! 	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_SD, sd);
! 	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_HD, hd);
! 	vo_port->set_property(vo_port, VO_PROP_INTERLACED, global);
! }
! 
! void cXineLib::setSDfeatures(int sharpness, int noise)
! {
! 	m_sharpness = sharpness;
! 	m_noise = noise;
! }
! 
! void cXineLib::setAspectRatio(int ratio)
! {
! 	m_windowAspectRatio = ratio;
! }
! 
! void cXineLib::setPolicy43(int mode)
! {
! 	m_policy43 = mode;
! }
! 
! void cXineLib::setPolicy169(int mode)
! {
! 	m_policy169 = mode;
! }
! 
! void cXineLib::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y)
! {
! 	m_zoom43_x = zoom43_x;
! 	m_zoom43_y = zoom43_y;
! 	m_zoom169_x = zoom169_x;
! 	m_zoom169_y = zoom169_y;
! }
! 
! void cXineLib::set_zoom_settings(int x, int y)
! {
! 	xine_set_param(stream, XINE_PARAM_VO_ZOOM_X, x);
! 	xine_set_param(stream, XINE_PARAM_VO_ZOOM_Y, y);
! }
! 
! void cXineLib::set_crop_settings(int left, int right, int top, int bottom)
! {
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_LEFT, left);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_RIGHT, right);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_TOP, top);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_BOTTOM, bottom);
! }
! 
! void cXineLib::adjust_policy()
! {
! 	switch (m_windowAspectRatio) {
! 	case XINE_VO_ASPECT_AUTO:
! 		printf("XINE_VO_ASPECT_AUTO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, 0);
! 		set_zoom_settings(100, 100);
! 	 	set_crop_settings(0, 0, 0, 0);
! 		break;
! 	case XINE_VO_ASPECT_4_3:
! 		printf("XINE_VO_ASPECT_4_3 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		switch (m_aspect) {
! 		case 2: // 4:3
! 			printf("m_policy43 %d\n", m_policy43);
! 			switch (m_policy43) {
! 			case 0: // scale
! 			case 1: // nonlinear
! 			case 2: // panscan
! 			case 3: // pillarbox
! 				printf("4:3 SCALE/NONLINEAR/PANSCAN/PILLARBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 4: // zoom
! 				printf("4:3 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom43_x, m_zoom43_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		case 3: // 16:9
! 			printf("m_policy169 %d\n", m_policy169);
! 			switch (m_policy169) {
! 			case 0: // scale
! 				printf("16:9 SCALE\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 1: // panscan
! 				printf("16:9 PANSCAN\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(m_width/8, m_width/8, 0, 0);
! 				break;
! 			case 2: // letterbox
! 				printf("16:9 LETTERBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 3: // zoom
! 				printf("16:9 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom169_x, m_zoom169_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		}
! 		break;
! 	case XINE_VO_ASPECT_ANAMORPHIC: //16:9
! 		printf("XINE_VO_ASPECT_ANAMORPHIC (16:9) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		switch (m_aspect) {
! 		case 2: // 4:3
! 			switch (m_policy43) {
! 			case 0: // scale
! 				printf("4:3 SCALE\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 1: // nonlinear
! 				printf("4:3 NONLINEAR\n");
! 				break;
! 			case 2: // panscan
! 				printf("4:3 PANSCAN\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, m_height/8, m_height/8);
! 				break;
! 			case 3: // pillarbox
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 				printf("4:3 PILLARBOX\n");
! 				break;
! 			case 4: // zoom
! 				printf("4:3 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom43_x, m_zoom43_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		case 3: // 16:9
! 			printf("m_policy169 %d\n", m_policy169);
! 			switch (m_policy169) {
! 			case 0: // scale
! 			case 1: // panscan
! 			case 2: // letterbox
! 				printf("16:9 SCALE/PANSCAN/LETTERBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 3: // zoom
! 				printf("16:9 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom169_x, m_zoom169_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		}
! 		break;
! 	}
! 
! 	if (m_width<=720) // SD channels
! 	{
! 		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, m_sharpness);
! 		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, m_noise);
! 	}
! 	else // HD channels
! 	{
! 		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, 0);
! 		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, 0);
! 	}
! }
! 
--- 1,558 ----
! #include <fstream>
! #include <lib/gdi/xineLib.h>
! #include <lib/base/eenv.h>
! 
! cXineLib   *cXineLib::instance;
! 
! DEFINE_REF(cXineLib);
! 
! cXineLib::cXineLib(x11_visual_t *vis) : m_pump(eApp, 1) {
! 	char        configfile[150];
! 	char        vo_driver[] = "vdpau";
! 	char        ao_driver[] = "alsa";
! 
! 	instance = this;
! 	osd = NULL;
! 	stream = NULL;
! 	end_of_stream = false;
! 	videoPlayed = false;
! 
! 	printf("XINE-LIB version: %s\n", xine_get_version_string() );
! 
! 	xine = xine_new();
! 	strcpy(configfile, eEnv::resolve("${datadir}/enigma2/xine.conf").c_str());
! 	printf("configfile  %s\n", configfile);
! 	xine_config_load(xine, configfile);
! 	xine_init(xine);
! 
! 	if((vo_port = xine_open_video_driver(xine, vo_driver, XINE_VISUAL_TYPE_X11, (void *) vis)) == NULL)
! 	{
! 		printf("I'm unable to initialize '%s' video driver. Giving up.\n", vo_driver);
! 		return;
! 	}
! 
! 	ao_port     = xine_open_audio_driver(xine , ao_driver, NULL);
! 	stream      = xine_stream_new(xine, ao_port, vo_port);
! 
! 	if ( (!xine_open(stream, eEnv::resolve("${sysconfdir}/tuxbox/logo.mvi").c_str()))
! 			|| (!xine_play(stream, 0, 0)) ) {
! 		return;
! 	}
! 
! 	//setPrebuffer(150000);
! 	xine_engine_set_param(xine, XINE_ENGINE_PARAM_VERBOSITY, XINE_VERBOSITY_DEBUG);
! 
! 	xine_queue = xine_event_new_queue (stream);
! 	xine_event_create_listener_thread(xine_queue, xine_event_handler, this);
! 
! 	CONNECT(m_pump.recv_msg, cXineLib::pumpEvent);
! 
! 	m_width     = 0;
! 	m_height    = 0;
! 	m_framerate = 0;
! 	m_aspect    = -1;
! 	m_windowAspectRatio = 0;
! 	m_policy43 = 0;
! 	m_policy169 = 0;
! 
! 	m_sharpness = 0;
! 	m_noise = 0;
! }
! 
! cXineLib::~cXineLib() {
! 	instance = 0;
! 
! 	if (stream)
! 	{
! 		xine_stop(stream);
! 		xine_close(stream);
! 
! 		if (xine_queue)
! 		{
! 			xine_event_dispose_queue(xine_queue);
! 			xine_queue = 0;
! 		}
! 
! 		_x_demux_flush_engine(stream);
! 
! 		xine_dispose(stream);
! 		stream = NULL;
! 	}
! 
! 	if (ao_port)
! 		xine_close_audio_driver(xine, ao_port);
! 	if (vo_port)
! 		xine_close_video_driver(xine, vo_port);
! }
! 
! void cXineLib::setVolume(int value) {
! //	xine_set_param (stream, XINE_PARAM_AUDIO_VOLUME, value);
! 	xine_set_param (stream, XINE_PARAM_AUDIO_AMP_LEVEL , value);
! }
! 
! void cXineLib::setVolumeMute(int value) {
! //	xine_set_param (stream, XINE_PARAM_AUDIO_MUTE, value==0?0:1);
! 	xine_set_param(stream, XINE_PARAM_AUDIO_AMP_MUTE, value==0?0:1);
! }
! 
! void cXineLib::showOsd() {
! 	xine_osd_show_scaled(osd, 0);
! 	//stream->osd_renderer->draw_bitmap(osd, (uint8_t*)m_surface.data, 0, 0, 720, 576, temp_bitmap_mapping);
! }
! 
! void cXineLib::newOsd(int width, int height, uint32_t *argb_buffer) {
! 	osdWidth  = width;
! 	osdHeight = height;
! 
! 	if (osd)
! 		xine_osd_free(osd);
! 
! 	osd = xine_osd_new(stream, 0, 0, osdWidth, osdHeight);
! 	xine_osd_set_extent(osd, osdWidth, osdHeight);
! 	xine_osd_set_argb_buffer(osd, argb_buffer, 0, 0, osdWidth, osdHeight);
! }
! 
! void cXineLib::playVideo(void) {
! 	xine_stop(stream);
! 	end_of_stream = false;
! 	videoPlayed = false;
! 
! 	printf("XINE try START !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	if ( !xine_open(stream, "enigma:/") ) {
! 		printf("Unable to open stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	}
! 
! //	setStreamType(1);
! //	setStreamType(0);
! xine_pids_data_t data;
! xine_event_t event;
!   event.type = XINE_EVENT_PIDS_CHANGE;
!   data.vpid = videoData.pid;
!   data.apid = audioData.pid;
!   event.data = &data;
!   event.data_length = sizeof (xine_pids_data_t);
! 
!   printf ("input_dvb: sending event\n");
! 
!   xine_event_send (stream, &event);
! setStreamType(1);
! setStreamType(0);
!         //_x_demux_control_start(stream);
!         //_x_demux_seek(stream, 0, 0, 0);
! 
! 	if( !xine_play(stream, 0, 0) ) {
! 		printf("Unable to play stream !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 	}
! 	printf("XINE STARTED !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 
! 	videoPlayed = true;
! }
! 
! void cXineLib::stopVideo(void) {
! 	xine_stop(stream);
! 	xine_close (stream);
! 	end_of_stream = false;
! 	videoPlayed = false;
! }
! 
! void cXineLib::setStreamType(int video) {
! 	xine_event_t event;
! 
! 	if (video==1) {
! 		event.type = XINE_EVENT_SET_VIDEO_STREAMTYPE;
! 		event.data = &videoData;
! 	} else {
! 		event.type = XINE_EVENT_SET_AUDIO_STREAMTYPE;
! 		event.data = &audioData;
! 	}
! 
! 	event.data_length = sizeof (xine_streamtype_data_t);
! 
! 	xine_event_send (stream, &event);
! }
! 
! void cXineLib::setVideoType(int pid, int type) {
! 	videoData.pid = pid;
! 	videoData.streamtype = type;
! }
! 
! //////////////////////7
! void cXineLib::FilmVideo(char *mrl) {
! ASSERT(stream);
! 	
! 	if (!xine_open(stream, mrl))
! 	{
! 		eWarning("xine_open failed!");
! 		return ;
! 	}
! 	
! 	if (!xine_play(stream, 0, 0))
! 	{
! 		eWarning("xine_play failed!");
! 		return ;
! 	}
! videoPlayed = true;
! }
! 
! int
! cXineLib::VideoPause()
! {
! xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
! return 1;
! }
! 
! 
! int
! cXineLib::VideoResume()
! {
! 	int ret;
! 	/* Resume the playback. */
! 	ret = xine_get_param(stream, XINE_PARAM_SPEED);
! 	if( ret != XINE_SPEED_NORMAL ){
! 		xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
! 	}
! 	return 1;
! }
! 
! int
! cXineLib::VideoGeriT(pts_t Sar)
! {// 10 saniye Geri Sarma 
! pts_t geriSar;
! xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_PAUSE);
! VideoPosisyon();
! geriSar=Vpos+Sar;
! printf("%d---Vpos=%d---Sar=%d",geriSar,Vpos,Sar);
! if (geriSar<0) geriSar=0;
! xine_play(stream, 0, geriSar);
! xine_set_param(stream, XINE_PARAM_SPEED, XINE_SPEED_NORMAL);
! return 1;
! }
! 
! int
! cXineLib::VideoIleriF()
! {
! 	int ret;
! 	/* Slow the playback. */
! 	ret = xine_get_param(stream, XINE_PARAM_SPEED);
! 	if( ret != XINE_EVENT_INPUT_RIGHT){
! 		xine_set_param(stream, XINE_PARAM_SPEED, XINE_EVENT_INPUT_RIGHT);
! 	}
! 	return 1;
! }
! 
! int
! cXineLib::VideoPosisyon()
! {
! xine_get_pos_length (stream, &VposStream, &Vpos, &Vlength);
! return 1;
! }
! /*
! XINE_SPEED_SLOW_4
! XINE_SPEED_SLOW_2
! XINE_SPEED_NORMAL
! XINE_SPEED_FAST_2
! XINE_SPEED_FAST_4
! XINE_FINE_SPEED_NORMAL
! */
! /////////////////////
! 
! void cXineLib::setAudioType(int pid, int type) {
! 	audioData.pid = pid;
! 	audioData.streamtype = type;
! }
! 
! void cXineLib::setPrebuffer(int prebuffer) {
! 	xine_set_param(stream, XINE_PARAM_METRONOM_PREBUFFER, prebuffer);
! }
! 
! void cXineLib::xine_event_handler(void *user_data, const xine_event_t *event)
! {
! 	cXineLib *xineLib = (cXineLib*)user_data;
! 	//if (event->type!=15)
! 	//	printf("I have event %d\n", event->type);
! 
! 	switch (event->type)
! 	{
! 	case XINE_EVENT_UI_PLAYBACK_FINISHED:
! 		printf("XINE_EVENT_UI_PLAYBACK_FINISHED\n");
! 		break;
! 	case XINE_EVENT_NBC_STATS:
! 		return;
! 	case XINE_EVENT_FRAME_FORMAT_CHANGE:
! 		printf("XINE_EVENT_FRAME_FORMAT_CHANGE\n");
! 		{
! 			xine_format_change_data_t* data = (xine_format_change_data_t*)event->data;
! 			printf("width %d  height %d  aspect %d\n", data->width, data->height, data->aspect);
! 
! 			struct iTSMPEGDecoder::videoEvent evt;
! 			evt.type = iTSMPEGDecoder::videoEvent::eventSizeChanged;
! 			xineLib->m_aspect = evt.aspect = data->aspect;
! 			xineLib->m_height = evt.height = data->height;
! 			xineLib->m_width  = evt.width  = data->width;
! 			xineLib->m_pump.send(evt);
! 
! 			xineLib->adjust_policy();
! 		}
! 		return;
! 	case XINE_EVENT_FRAMERATE_CHANGE:
! 		printf("XINE_EVENT_FRAMERATE_CHANGE\n");
! 		{
! 			xine_framerate_data_t* data = (xine_framerate_data_t*)event->data;
! 			printf("framerate %d  \n", data->framerate);
! 
! 			struct iTSMPEGDecoder::videoEvent evt;
! 			evt.type = iTSMPEGDecoder::videoEvent::eventFrameRateChanged;
! 			xineLib->m_framerate = evt.framerate = data->framerate;
! 			xineLib->m_pump.send(evt);
! 		}
! 		return;
! 	case XINE_EVENT_PROGRESS:
! 		{
! 			xine_progress_data_t* data = (xine_progress_data_t*) event->data;
! 			printf("XINE_EVENT_PROGRESS  %s  %d\n", data->description, data->percent);
! 			if (xineLib->videoPlayed && data->percent==0)
! 				xineLib->end_of_stream = true;
! 		}
! 		break;
! 
! 	default:
! 		printf("xine_event_handler(): event->type: %d\n", event->type);
! 		return;
! 	}
! }
! 
! void cXineLib::pumpEvent(const iTSMPEGDecoder::videoEvent &event)
! {
! 	m_event(event);
! }
! 
! int cXineLib::getVideoWidth()
! {
! 	return m_width;
! }
! 
! int cXineLib::getVideoHeight()
! {
! 	return m_height;
! }
! 
! int cXineLib::getVideoFrameRate()
! {
! 	return m_framerate;
! }
! 
! int cXineLib::getVideoAspect()
! {
! 	return m_aspect;
! }
! 
! RESULT cXineLib::getPTS(pts_t &pts)
! {
! 	pts_t* last_pts_l = (pts_t*)vo_port->get_property(vo_port, VO_PROP_LAST_PTS);
! 
! 	pts = *last_pts_l;
! 
! 	if (pts != 0)
! 		return 0;
! 	
! 	return -1;
! }
! 
! void cXineLib::setVideoWindow(int window_x, int window_y, int window_width, int window_height)
! {
! 	int left = window_x * windowWidth / osdWidth;
! 	int top = window_y * windowHeight / osdHeight;
! 	int width = window_width * windowWidth / osdWidth;
! 	int height = window_height * windowHeight / osdHeight;
! 
! 	xine_osd_set_video_window(osd, left, top, width, height);
! 	showOsd();
! }
! 
! void cXineLib::updateWindowSize(int width, int height)
! {
! 	windowWidth  = width;
! 	windowHeight = height;
! }
! 
! void cXineLib::setDeinterlace(int global, int sd, int hd)
! {
! 	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_SD, sd);
! 	vo_port->set_property(vo_port, VO_PROP_DEINTERLACE_HD, hd);
! 	vo_port->set_property(vo_port, VO_PROP_INTERLACED, global);
! }
! 
! void cXineLib::setSDfeatures(int sharpness, int noise)
! {
! 	m_sharpness = sharpness;
! 	m_noise = noise;
! }
! 
! void cXineLib::setAspectRatio(int ratio)
! {
! 	m_windowAspectRatio = ratio;
! }
! 
! void cXineLib::setPolicy43(int mode)
! {
! 	m_policy43 = mode;
! }
! 
! void cXineLib::setPolicy169(int mode)
! {
! 	m_policy169 = mode;
! }
! 
! void cXineLib::setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y)
! {
! 	m_zoom43_x = zoom43_x;
! 	m_zoom43_y = zoom43_y;
! 	m_zoom169_x = zoom169_x;
! 	m_zoom169_y = zoom169_y;
! }
! 
! void cXineLib::set_zoom_settings(int x, int y)
! {
! 	xine_set_param(stream, XINE_PARAM_VO_ZOOM_X, x);
! 	xine_set_param(stream, XINE_PARAM_VO_ZOOM_Y, y);
! }
! 
! void cXineLib::set_crop_settings(int left, int right, int top, int bottom)
! {
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_LEFT, left);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_RIGHT, right);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_TOP, top);
! 	xine_set_param(stream, XINE_PARAM_VO_CROP_BOTTOM, bottom);
! }
! 
! void cXineLib::adjust_policy()
! {
! 	switch (m_windowAspectRatio) {
! 	case XINE_VO_ASPECT_AUTO:
! 		printf("XINE_VO_ASPECT_AUTO !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, 0);
! 		set_zoom_settings(100, 100);
! 	 	set_crop_settings(0, 0, 0, 0);
! 		break;
! 	case XINE_VO_ASPECT_4_3:
! 		printf("XINE_VO_ASPECT_4_3 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		switch (m_aspect) {
! 		case 2: // 4:3
! 			printf("m_policy43 %d\n", m_policy43);
! 			switch (m_policy43) {
! 			case 0: // scale
! 			case 1: // nonlinear
! 			case 2: // panscan
! 			case 3: // pillarbox
! 				printf("4:3 SCALE/NONLINEAR/PANSCAN/PILLARBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 4: // zoom
! 				printf("4:3 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom43_x, m_zoom43_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		case 3: // 16:9
! 			printf("m_policy169 %d\n", m_policy169);
! 			switch (m_policy169) {
! 			case 0: // scale
! 				printf("16:9 SCALE\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 1: // panscan
! 				printf("16:9 PANSCAN\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(m_width/8, m_width/8, 0, 0);
! 				break;
! 			case 2: // letterbox
! 				printf("16:9 LETTERBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 3: // zoom
! 				printf("16:9 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom169_x, m_zoom169_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		}
! 		break;
! 	case XINE_VO_ASPECT_ANAMORPHIC: //16:9
! 		printf("XINE_VO_ASPECT_ANAMORPHIC (16:9) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
! 		switch (m_aspect) {
! 		case 2: // 4:3
! 			switch (m_policy43) {
! 			case 0: // scale
! 				printf("4:3 SCALE\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 1: // nonlinear
! 				printf("4:3 NONLINEAR\n");
! 				break;
! 			case 2: // panscan
! 				printf("4:3 PANSCAN\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, m_height/8, m_height/8);
! 				break;
! 			case 3: // pillarbox
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_4_3);
! 				set_zoom_settings(100, 100);
! 				printf("4:3 PILLARBOX\n");
! 				break;
! 			case 4: // zoom
! 				printf("4:3 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom43_x, m_zoom43_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		case 3: // 16:9
! 			printf("m_policy169 %d\n", m_policy169);
! 			switch (m_policy169) {
! 			case 0: // scale
! 			case 1: // panscan
! 			case 2: // letterbox
! 				printf("16:9 SCALE/PANSCAN/LETTERBOX\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_ANAMORPHIC);
! 				set_zoom_settings(100, 100);
! 			 	set_crop_settings(0, 0, 0, 0);
! 				break;
! 			case 3: // zoom
! 				printf("16:9 ZOOM\n");
! 				xine_set_param(stream, XINE_PARAM_VO_ASPECT_RATIO, XINE_VO_ASPECT_AUTO);
! 				set_zoom_settings(m_zoom169_x, m_zoom169_y);
! 	 			set_crop_settings(0, 0, 0, 0);
! 				break;
! 			}
! 			break;
! 		}
! 		break;
! 	}
! 
! 	if (m_width<=720) // SD channels
! 	{
! 		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, m_sharpness);
! 		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, m_noise);
! 	}
! 	else // HD channels
! 	{
! 		vo_port->set_property(vo_port, VO_PROP_SHARPNESS, 0);
! 		vo_port->set_property(vo_port, VO_PROP_NOISE_REDUCTION, 0);
! 	}
! }
! 
diff -crB Enigma2PC/lib/gdi/xineLib.h Enigma2PC_orig/lib/gdi/xineLib.h
*** Enigma2PC/lib/gdi/xineLib.h	2011-11-20 21:56:11.154164050 +0400
--- Enigma2PC_orig/lib/gdi/xineLib.h	2011-11-20 02:55:00.000000000 +0400
***************
*** 1,80 ****
! #ifndef __lib_gdi_xineLib_h
! #define __lib_gdi_xineLib_h
! 
! #include <lib/gdi/gpixmap.h>
! #include <xine.h>
! #include <xine/xineutils.h>
! #include <xine/xine_internal.h>
! #include <lib/dvb/idvb.h>
! #include <lib/base/message.h>
! 
! class cXineLib : public Object {
! 	DECLARE_REF(cXineLib);
! private:
! 	static cXineLib        *instance;
! 
! 	xine_t                 *xine;
! 	xine_stream_t          *stream;
! 	xine_video_port_t      *vo_port;
! 	xine_audio_port_t      *ao_port;
! 	xine_osd_t             *osd;
! 	xine_event_queue_t     *xine_queue;
! 
!         xine_streamtype_data_t  videoData, audioData;
! 
! 	bool                    videoPlayed;
! 	int                     osdWidth, osdHeight;
! 	int                     windowWidth, windowHeight;
! 
! 	int m_width, m_height, m_framerate, m_aspect, m_progressive;
! 	int m_windowAspectRatio, m_policy43, m_policy169;
! 	int m_zoom43_x, m_zoom43_y, m_zoom169_x, m_zoom169_y;
! 	int m_sharpness, m_noise;
! 
! 	void setStreamType(int video);
! 
! 	static void xine_event_handler(void *user_data, const xine_event_t *event);
! 
! 	eFixedMessagePump<iTSMPEGDecoder::videoEvent> m_pump;
! 	void pumpEvent(const iTSMPEGDecoder::videoEvent &event);
! 
! 	void set_zoom_settings(int x, int y);
! 	void set_crop_settings(int left, int right, int top, int bottom);
! public:
! 	bool                    end_of_stream;
! 
! 	cXineLib(x11_visual_t *vis);
! 	virtual ~cXineLib();
! 
! 	static cXineLib *getInstance() { return instance; }
! 
! 	void setPrebuffer(int prebuffer);
! 	void setVolume(int value);
! 	void setVolumeMute(int value);
! 	void showOsd();
! 	void newOsd(int width, int height, uint32_t *argb_buffer);
! 	void playVideo(void);
! 	void stopVideo(void);
! 	void setVideoType(int pid, int type);
! 	void setAudioType(int pid, int type);
! 
! 	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
! 
! 	int getVideoWidth();
! 	int getVideoHeight();
! 	int getVideoFrameRate();
! 	int getVideoAspect();
! 	void adjust_policy();
! 	RESULT getPTS(pts_t &pts);
! 	void setVideoWindow(int window_x, int window_y, int window_width, int window_height);
! 	void updateWindowSize(int width, int height);
! 
! 	void setDeinterlace(int global, int sd, int hd);
! 	void setSDfeatures(int sharpness, int noise);
! 	void setAspectRatio(int ratio);
! 	void setPolicy43(int mode);
! 	void setPolicy169(int mode);
! 	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
! };
! 
! #endif
--- 1,92 ----
! #ifndef __lib_gdi_xineLib_h
! #define __lib_gdi_xineLib_h
! 
! #include <lib/gdi/gpixmap.h>
! #include <xine.h>
! #include <xine/xineutils.h>
! #include <xine/xine_internal.h>
! #include <lib/dvb/idvb.h>
! #include <lib/base/message.h>
! 
! class cXineLib : public Object {
! 	DECLARE_REF(cXineLib);
! private:
! 	static cXineLib        *instance;
! 
! 	xine_t                 *xine;
! 	xine_stream_t          *stream;
! 	xine_video_port_t      *vo_port;
! 	xine_audio_port_t      *ao_port;
! 	xine_osd_t             *osd;
! 	xine_event_queue_t     *xine_queue;
! 
!         xine_streamtype_data_t  videoData, audioData;
! 
! 	bool                    videoPlayed;
! 	int                     osdWidth, osdHeight;
! 	int                     windowWidth, windowHeight;
! 
! 	int m_width, m_height, m_framerate, m_aspect, m_progressive;
! 	int m_windowAspectRatio, m_policy43, m_policy169;
! 	int m_zoom43_x, m_zoom43_y, m_zoom169_x, m_zoom169_y;
! 	int m_sharpness, m_noise;
!     	
! 	void setStreamType(int video);
! 
! 	static void xine_event_handler(void *user_data, const xine_event_t *event);
! 
! 	eFixedMessagePump<iTSMPEGDecoder::videoEvent> m_pump;
! 	void pumpEvent(const iTSMPEGDecoder::videoEvent &event);
! 
! 	void set_zoom_settings(int x, int y);
! 	void set_crop_settings(int left, int right, int top, int bottom);
! public:
! 	bool                    end_of_stream;
! 
! 	cXineLib(x11_visual_t *vis);
! 	virtual ~cXineLib();
! 
! 	static cXineLib *getInstance() { return instance; }
! 
! 	void setPrebuffer(int prebuffer);
! 	void setVolume(int value);
! 	void setVolumeMute(int value);
! 	void showOsd();
! 	void newOsd(int width, int height, uint32_t *argb_buffer);
! 	void playVideo(void);
! 	void stopVideo(void);
! 	void setVideoType(int pid, int type);
! 	void setAudioType(int pid, int type);
! 	
! 	//////////////////////////////
!    	void FilmVideo(char *mrl); 
! 	int VideoPause();
! 	int VideoResume();
! 	int VideoPosisyon();
! 	int VideoIleriF();
!     int VposStream;
!     int Vpos; 
!     int Vlength;
! 	int VideoGeriT(pts_t Sar);
! 	///////////////////////
! 	
! 	Signal1<void, struct iTSMPEGDecoder::videoEvent> m_event;
! 
! 	int getVideoWidth();
! 	int getVideoHeight();
! 	int getVideoFrameRate();
! 	int getVideoAspect();
! 	void adjust_policy();
! 	RESULT getPTS(pts_t &pts);
! 	void setVideoWindow(int window_x, int window_y, int window_width, int window_height);
! 	void updateWindowSize(int width, int height);
! 
! 	void setDeinterlace(int global, int sd, int hd);
! 	void setSDfeatures(int sharpness, int noise);
! 	void setAspectRatio(int ratio);
! 	void setPolicy43(int mode);
! 	void setPolicy169(int mode);
! 	void setZoom(int zoom43_x, int zoom43_y, int zoom169_x, int zoom169_y);
! };
! 
! #endif
diff -crB Enigma2PC/lib/service/servicedvb.cpp Enigma2PC_orig/lib/service/servicedvb.cpp
*** Enigma2PC/lib/service/servicedvb.cpp	2011-11-20 21:56:11.260830302 +0400
--- Enigma2PC_orig/lib/service/servicedvb.cpp	2011-11-20 04:14:00.000000000 +0400
***************
*** 1,3187 ****
! #include <lib/base/eerror.h>
! #include <lib/base/object.h>
! #include <string>
! #include <lib/service/servicedvb.h>
! #include <lib/service/service.h>
! #include <lib/base/estring.h>
! #include <lib/base/init_num.h>
! #include <lib/base/init.h>
! #include <lib/dvb/dvb.h>
! #include <lib/dvb/db.h>
! #include <lib/dvb/decoder.h>
! 
! #include <lib/components/file_eraser.h>
! #include <lib/service/servicedvbrecord.h>
! #include <lib/service/event.h>
! #include <lib/dvb/metaparser.h>
! #include <lib/dvb/tstools.h>
! #include <lib/python/python.h>
! #include <lib/base/nconfig.h> // access to python config
! 
! 		/* for subtitles */
! #include <lib/gui/esubtitle.h>
! 
! #include <sys/vfs.h>
! #include <sys/stat.h>
! 
! #include <byteswap.h>
! #include <netinet/in.h>
! 
! #ifndef BYTE_ORDER
! #error no byte order defined!
! #endif
! 
! class eStaticServiceDVBInformation: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceDVBInformation);
! public:
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore);
! 	PyObject *getInfoObject(const eServiceReference &ref, int);
! };
! 
! DEFINE_REF(eStaticServiceDVBInformation);
! 
! RESULT eStaticServiceDVBInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	eServiceReferenceDVB &service = (eServiceReferenceDVB&)ref;
! 	if ( !ref.name.empty() )
! 	{
! 		if (service.getParentTransportStreamID().get()) // linkage subservice
! 		{
! 			ePtr<iServiceHandler> service_center;
! 			if (!eServiceCenter::getInstance(service_center))
! 			{
! 				eServiceReferenceDVB parent = service;
! 				parent.setTransportStreamID( service.getParentTransportStreamID() );
! 				parent.setServiceID( service.getParentServiceID() );
! 				parent.setParentTransportStreamID(eTransportStreamID(0));
! 				parent.setParentServiceID(eServiceID(0));
! 				parent.name="";
! 				ePtr<iStaticServiceInformation> service_info;
! 				if (!service_center->info(parent, service_info))
! 				{
! 					if (!service_info->getName(parent, name))
! 						name=buildShortName(name) + " - ";
! 				}
! 			}
! 		}
! 		else
! 			name="";
! 		name += ref.name;
! 		return 0;
! 	}
! 	else
! 		return -1;
! }
! 
! int eStaticServiceDVBInformation::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! int eStaticServiceDVBInformation::isPlayable(const eServiceReference &ref, const eServiceReference &ignore)
! {
! 	ePtr<eDVBResourceManager> res_mgr;
! 	if ( eDVBResourceManager::getInstance( res_mgr ) )
! 		eDebug("isPlayable... no res manager!!");
! 	else
! 	{
! 		eDVBChannelID chid, chid_ignore;
! 		((const eServiceReferenceDVB&)ref).getChannelID(chid);
! 		((const eServiceReferenceDVB&)ignore).getChannelID(chid_ignore);
! 		return res_mgr->canAllocateChannel(chid, chid_ignore);
! 	}
! 	return false;
! }
! 
! extern void PutToDict(ePyObject &dict, const char*key, long value);  // defined in dvb/frontend.cpp
! extern void PutSatelliteDataToDict(ePyObject &dict, eDVBFrontendParametersSatellite &feparm); // defined in dvb/frontend.cpp
! extern void PutTerrestrialDataToDict(ePyObject &dict, eDVBFrontendParametersTerrestrial &feparm); // defined in dvb/frontend.cpp
! extern void PutCableDataToDict(ePyObject &dict, eDVBFrontendParametersCable &feparm); // defined in dvb/frontend.cpp
! 
! PyObject *eStaticServiceDVBInformation::getInfoObject(const eServiceReference &r, int what)
! {
! 	if (r.type == eServiceReference::idDVB)
! 	{
! 		const eServiceReferenceDVB &ref = (const eServiceReferenceDVB&)r;
! 		switch(what)
! 		{
! 			case iServiceInformation::sTransponderData:
! 			{
! 				ePtr<eDVBResourceManager> res;
! 				if (!eDVBResourceManager::getInstance(res))
! 				{
! 					ePtr<iDVBChannelList> db;
! 					if (!res->getChannelList(db))
! 					{
! 						eDVBChannelID chid;
! 						ref.getChannelID(chid);
! 						ePtr<iDVBFrontendParameters> feparm;
! 						if (!db->getChannelFrontendData(chid, feparm))
! 						{
! 							int system;
! 							if (!feparm->getSystem(system))
! 							{
! 								ePyObject dict = PyDict_New();
! 								switch(system)
! 								{
! 									case iDVBFrontend::feSatellite:
! 									{
! 										eDVBFrontendParametersSatellite s;
! 										feparm->getDVBS(s);
! 										PutSatelliteDataToDict(dict, s);
! 										break;
! 									}
! 									case iDVBFrontend::feTerrestrial:
! 									{
! 										eDVBFrontendParametersTerrestrial t;
! 										feparm->getDVBT(t);
! 										PutTerrestrialDataToDict(dict, t);
! 										break;
! 									}
! 									case iDVBFrontend::feCable:
! 									{
! 										eDVBFrontendParametersCable c;
! 										feparm->getDVBC(c);
! 										PutCableDataToDict(dict, c);
! 										break;
! 									}
! 									default:
! 										eDebug("unknown frontend type %d", system);
! 										Py_DECREF(dict);
! 										break;
! 								}
! 								return dict;
! 							}
! 						}
! 					}
! 				}
! 			}
! 		}
! 	}
! 	Py_RETURN_NONE;
! }
! 
! DEFINE_REF(eStaticServiceDVBBouquetInformation);
! 
! RESULT eStaticServiceDVBBouquetInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	ePtr<iDVBChannelList> db;
! 	ePtr<eDVBResourceManager> res;
! 
! 	int err;
! 	if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. no resource manager!");
! 		return err;
! 	}
! 	if ((err = res->getChannelList(db)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. no channel list!");
! 		return err;
! 	}
! 
! 	eBouquet *bouquet=0;
! 	if ((err = db->getBouquet(ref, bouquet)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. getBouquet failed!");
! 		return -1;
! 	}
! 
! 	if ( bouquet && bouquet->m_bouquet_name.length() )
! 	{
! 		name = bouquet->m_bouquet_name;
! 		return 0;
! 	}
! 	else
! 		return -1;
! }
! 
! int eStaticServiceDVBBouquetInformation::isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate)
! {
! 	if (ref.flags & eServiceReference::isGroup)
! 	{
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> res;
! 
! 		if (eDVBResourceManager::getInstance(res))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. no resource manager!");
! 			return 0;
! 		}
! 
! 		if (res->getChannelList(db))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. no channel list!");
! 			return 0;
! 		}
! 
! 		eBouquet *bouquet=0;
! 		if (db->getBouquet(ref, bouquet))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. getBouquet failed!");
! 			return 0;
! 		}
! 
! 		int prio_order = eDVBFrontend::getTypePriorityOrder();
! 		int cur=0;
! 		eDVBChannelID chid, chid_ignore;
! 		((const eServiceReferenceDVB&)ignore).getChannelID(chid_ignore);
! 		for (std::list<eServiceReference>::iterator it(bouquet->m_services.begin()); it != bouquet->m_services.end(); ++it)
! 		{
! 			static unsigned char prio_map[6][3] = {
! 				{ 3, 2, 1 }, // -S -C -T
! 				{ 3, 1, 2 }, // -S -T -C
! 				{ 2, 3, 1 }, // -C -S -T
! 				{ 1, 3, 2 }, // -C -T -S
! 				{ 1, 2, 3 }, // -T -C -S
! 				{ 2, 1, 3 }  // -T -S -C
! 			};
! 			((const eServiceReferenceDVB&)*it).getChannelID(chid);
! 			int tmp=res->canAllocateChannel(chid, chid_ignore, simulate);
! 			switch(tmp)
! 			{
! 				case 0:
! 					break;
! 				case 30000: // cached DVB-T channel
! 				case 1: // DVB-T frontend
! 					tmp = prio_map[prio_order][2];
! 					break;
! 				case 40000: // cached DVB-C channel
! 				case 2:
! 					tmp = prio_map[prio_order][1];
! 					break;
! 				default: // DVB-S
! 					tmp = prio_map[prio_order][0];
! 					break;
! 			}
! 			if (tmp > cur)
! 			{
! 				m_playable_service = *it;
! 				cur = tmp;
! 			}
! 		}
! 		if (cur)
! 			return cur;
! 	}
! 	m_playable_service = eServiceReference();
! 	return 0;
! }
! 
! int eStaticServiceDVBBouquetInformation::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! #include <lib/dvb/epgcache.h>
! 
! RESULT eStaticServiceDVBBouquetInformation::getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &ptr, time_t start_time)
! {
! 	return eEPGCache::getInstance()->lookupEventTime(ref, start_time, ptr);
! }
! 
! class eStaticServiceDVBPVRInformation: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceDVBPVRInformation);
! 	eServiceReference m_ref;
! 	eDVBMetaParser m_parser;
! public:
! 	eStaticServiceDVBPVRInformation(const eServiceReference &ref);
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	RESULT getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &SWIG_OUTPUT, time_t start_time);
! 	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore) { return 1; }
! 	int getInfo(const eServiceReference &ref, int w);
! 	std::string getInfoString(const eServiceReference &ref,int w);
! 	PyObject *getInfoObject(const eServiceReference &r, int what);
! };
! 
! DEFINE_REF(eStaticServiceDVBPVRInformation);
! 
! eStaticServiceDVBPVRInformation::eStaticServiceDVBPVRInformation(const eServiceReference &ref)
! {
! 	m_ref = ref;
! 	m_parser.parseFile(ref.path);
! }
! 
! RESULT eStaticServiceDVBPVRInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	ASSERT(ref == m_ref);
! 	if (!ref.name.empty())
! 		name = ref.name;
! 	else if (!m_parser.m_name.empty())
! 		name = m_parser.m_name;
! 	else
! 	{
! 		name = ref.path;
! 		size_t n = name.rfind('/');
! 		if (n != std::string::npos)
! 			name = name.substr(n + 1);
! 	}
! 	return 0;
! }
! 
! int eStaticServiceDVBPVRInformation::getLength(const eServiceReference &ref)
! {
! 	ASSERT(ref == m_ref);
! 	
! 	eDVBTSTools tstools;
! 	
! 	struct stat s;
! 	stat(ref.path.c_str(), &s);
! 
! 	if (tstools.openFile(ref.path.c_str(), 1))
! 		return 0;
! 
! 			/* check if cached data is still valid */
! 	if (m_parser.m_data_ok && (s.st_size == m_parser.m_filesize) && (m_parser.m_length))
! 		return m_parser.m_length / 90000;
! 
! 			/* open again, this time with stream info */
! 	if (tstools.openFile(ref.path.c_str()))
! 		return 0;
! 
! 			/* otherwise, re-calc length and update meta file */
! 	pts_t len;
! 	if (tstools.calcLen(len))
! 		return 0;
! 
!  	m_parser.m_length = len;
! 	m_parser.m_filesize = s.st_size;
! 	m_parser.updateMeta(ref.path);
! 	return m_parser.m_length / 90000;
! }
! 
! int eStaticServiceDVBPVRInformation::getInfo(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sDescription:
! 		return iServiceInformation::resIsString;
! 	case iServiceInformation::sServiceref:
! 		return iServiceInformation::resIsString;
! 	case iServiceInformation::sFileSize:
! 		return m_parser.m_filesize;
! 	case iServiceInformation::sTimeCreate:
! 		if (m_parser.m_time_create)
! 			return m_parser.m_time_create;
! 		else
! 			return iServiceInformation::resNA;
! 	default:
! 		return iServiceInformation::resNA;
! 	}
! }
! 
! std::string eStaticServiceDVBPVRInformation::getInfoString(const eServiceReference &ref,int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sDescription:
! 		return m_parser.m_description;
! 	case iServiceInformation::sServiceref:
! 		return m_parser.m_ref.toString();
! 	case iServiceInformation::sTags:
! 		return m_parser.m_tags;
! 	default:
! 		return "";
! 	}
! }
! 
! PyObject *eStaticServiceDVBPVRInformation::getInfoObject(const eServiceReference &r, int what)
! {
! 	switch (what)
! 	{
! 	case iServiceInformation::sFileSize:
! 		return PyLong_FromLongLong(m_parser.m_filesize);
! 	default:
! 		Py_RETURN_NONE;
! 	}
! }
! 
! RESULT eStaticServiceDVBPVRInformation::getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &evt, time_t start_time)
! {
! 	if (!ref.path.empty())
! 	{
! 		ePtr<eServiceEvent> event = new eServiceEvent;
! 		std::string filename = ref.path;
! 		filename.erase(filename.length()-2, 2);
! 		filename+="eit";
! 		if (!event->parseFrom(filename, (m_parser.m_ref.getTransportStreamID().get()<<16)|m_parser.m_ref.getOriginalNetworkID().get()))
! 		{
! 			evt = event;
! 			return 0;
! 		}
! 	}
! 	evt = 0;
! 	return -1;
! }
! 
! class eDVBPVRServiceOfflineOperations: public iServiceOfflineOperations
! {
! 	DECLARE_REF(eDVBPVRServiceOfflineOperations);
! 	eServiceReferenceDVB m_ref;
! public:
! 	eDVBPVRServiceOfflineOperations(const eServiceReference &ref);
! 	
! 	RESULT deleteFromDisk(int simulate);
! 	RESULT getListOfFilenames(std::list<std::string> &);
! 	RESULT reindex();
! };
! 
! DEFINE_REF(eDVBPVRServiceOfflineOperations);
! 
! eDVBPVRServiceOfflineOperations::eDVBPVRServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReferenceDVB&)ref)
! {
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::deleteFromDisk(int simulate)
! {
! 	if (simulate)
! 		return 0;
! 	else
! 	{
! 		std::list<std::string> res;
! 		if (getListOfFilenames(res))
! 			return -1;
! 		
! 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
! 		if (!eraser)
! 			eDebug("FATAL !! can't get background file eraser");
! 		
! 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
! 		{
! 			eDebug("Removing %s...", i->c_str());
! 			if (eraser)
! 				eraser->erase(i->c_str());
! 			else
! 				::unlink(i->c_str());
! 		}
! 		
! 		return 0;
! 	}
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
! {
! 	res.clear();
! 	res.push_back(m_ref.path);
! 
! // handling for old splitted recordings (enigma 1)
! 	char buf[255];
! 	int slice=1;
! 	while(true)
! 	{
! 		snprintf(buf, 255, "%s.%03d", m_ref.path.c_str(), slice++);
! 		struct stat s;
! 		if (stat(buf, &s) < 0)
! 			break;
! 		res.push_back(buf);
! 	}	
! 
! 	res.push_back(m_ref.path + ".meta");
! 	res.push_back(m_ref.path + ".ap");
! 	res.push_back(m_ref.path + ".sc");
! 	res.push_back(m_ref.path + ".cuts");
! 	std::string tmp = m_ref.path;
! 	tmp.erase(m_ref.path.length()-3);
! 	res.push_back(tmp + ".eit");
! 	return 0;
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::reindex()
! {
! 	const char *filename = m_ref.path.c_str();
! 	eDebug("reindexing %s...", filename);
! 
! 	eMPEGStreamInformation info;
! 	eMPEGStreamParserTS parser(info);
! 	
! 	info.startSave(filename);
! 	
! 	eRawFile f;
! 	
! 	int err = f.open(m_ref.path.c_str(), 0);
! 	if (err < 0)
! 		return -1;
! 
! 	off_t offset = 0;
! 	off_t length = f.length();
! 	unsigned char buffer[188*256*4];
! 	while (1)
! 	{
! 		eDebug("at %08llx / %08llx (%d %%)", offset, length, (int)(offset * 100 / length));
! 		int r = f.read(offset, buffer, sizeof(buffer));
! 		if (!r)
! 			break;
! 		if (r < 0)
! 			return r;
! 		offset += r;
! 		parser.parseData(offset, buffer, r);
! 	}
! 	
! 	info.stopSave();
! 	f.close();
! 	
! 	return 0;
! }
! 
! DEFINE_REF(eServiceFactoryDVB)
! 
! eServiceFactoryDVB::eServiceFactoryDVB()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 	{
! 		std::list<std::string> extensions;
! 		extensions.push_back("ts");
! 		extensions.push_back("trp");
! 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
! 	}
! 
! 	m_StaticServiceDVBInfo = new eStaticServiceDVBInformation;
! 	m_StaticServiceDVBBouquetInfo = new eStaticServiceDVBBouquetInformation;
! }
! 
! eServiceFactoryDVB::~eServiceFactoryDVB()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 		sc->removeServiceFactory(eServiceFactoryDVB::id);
! }
! 
! DEFINE_REF(eDVBServiceList);
! 
! eDVBServiceList::eDVBServiceList(const eServiceReference &parent): m_parent(parent)
! {
! }
! 
! eDVBServiceList::~eDVBServiceList()
! {
! }
! 
! RESULT eDVBServiceList::startQuery()
! {
! 	ePtr<iDVBChannelList> db;
! 	ePtr<eDVBResourceManager> res;
! 	
! 	int err;
! 	if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 	{
! 		eDebug("no resource manager");
! 		return err;
! 	}
! 	if ((err = res->getChannelList(db)) != 0)
! 	{
! 		eDebug("no channel list");
! 		return err;
! 	}
! 	
! 	ePtr<eDVBChannelQuery> q;
! 	
! 	if (!m_parent.path.empty())
! 	{
! 		eDVBChannelQuery::compile(q, m_parent.path);
! 		if (!q)
! 		{
! 			eDebug("compile query failed");
! 			return err;
! 		}
! 	}
! 	
! 	if ((err = db->startQuery(m_query, q, m_parent)) != 0)
! 	{
! 		eDebug("startQuery failed");
! 		return err;
! 	}
! 
! 	return 0;
! }
! 
! RESULT eDVBServiceList::getContent(std::list<eServiceReference> &list, bool sorted)
! {
! 	eServiceReferenceDVB ref;
! 	
! 	if (!m_query)
! 		return -1;
! 
! 	while (!m_query->getNextResult(ref))
! 		list.push_back(ref);
! 
! 	if (sorted)
! 		list.sort(iListableServiceCompare(this));
! 
! 	return 0;
! }
! 
! //   The first argument of this function is a format string to specify the order and
! //   the content of the returned list
! //   useable format options are
! //   R = Service Reference (as swig object .. this is very slow)
! //   S = Service Reference (as python string object .. same as ref.toString())
! //   C = Service Reference (as python string object .. same as ref.toCompareString())
! //   N = Service Name (as python string object)
! //   n = Short Service Name (short name brakets used) (as python string object)
! //   when exactly one return value per service is selected in the format string,
! //   then each value is directly a list entry
! //   when more than one value is returned per service, then the list is a list of
! //   python tuples
! //   unknown format string chars are returned as python None values !
! PyObject *eDVBServiceList::getContent(const char* format, bool sorted)
! {
! 	ePyObject ret;
! 	std::list<eServiceReference> tmplist;
! 	int retcount=1;
! 
! 	if (!format || !(retcount=strlen(format)))
! 		format = "R"; // just return service reference swig object ...
! 
! 	if (!getContent(tmplist, sorted))
! 	{
! 		int services=tmplist.size();
! 		ePtr<iStaticServiceInformation> sptr;
! 		eServiceCenterPtr service_center;
! 
! 		if (strchr(format, 'N') || strchr(format, 'n'))
! 			eServiceCenter::getPrivInstance(service_center);
! 
! 		ret = PyList_New(services);
! 		std::list<eServiceReference>::iterator it(tmplist.begin());
! 
! 		for (int cnt=0; cnt < services; ++cnt)
! 		{
! 			eServiceReference &ref=*it++;
! 			ePyObject tuple = retcount > 1 ? PyTuple_New(retcount) : ePyObject();
! 			for (int i=0; i < retcount; ++i)
! 			{
! 				ePyObject tmp;
! 				switch(format[i])
! 				{
! 				case 'R':  // service reference (swig)object
! 					tmp = NEW_eServiceReference(ref);
! 					break;
! 				case 'C':  // service reference compare string
! 					tmp = PyString_FromString(ref.toCompareString().c_str());
! 					break;
! 				case 'S':  // service reference string
! 					tmp = PyString_FromString(ref.toString().c_str());
! 					break;
! 				case 'N':  // service name
! 					if (service_center)
! 					{
! 						service_center->info(ref, sptr);
! 						if (sptr)
! 						{
! 							std::string name;
! 							sptr->getName(ref, name);
! 
! 							// filter short name brakets
! 							size_t pos;
! 							while((pos = name.find("\xc2\x86")) != std::string::npos)
! 								name.erase(pos,2);
! 							while((pos = name.find("\xc2\x87")) != std::string::npos)
! 								name.erase(pos,2);
! 
! 							if (name.length())
! 								tmp = PyString_FromString(name.c_str());
! 						}
! 					}
! 					if (!tmp)
! 						tmp = PyString_FromString("<n/a>");
! 					break;
! 				case 'n':  // short service name
! 					if (service_center)
! 					{
! 						service_center->info(ref, sptr);
! 						if (sptr)
! 						{
! 							std::string name;
! 							sptr->getName(ref, name);
! 							name = buildShortName(name);
! 							if (name.length())
! 								tmp = PyString_FromString(name.c_str());
! 						}
! 					}
! 					if (!tmp)
! 						tmp = PyString_FromString("<n/a>");
! 					break;
! 				default:
! 					if (tuple)
! 					{
! 						tmp = Py_None;
! 						Py_INCREF(Py_None);
! 					}
! 					break;
! 				}
! 				if (tmp)
! 				{
! 					if (tuple)
! 						PyTuple_SET_ITEM(tuple, i, tmp);
! 					else
! 						PyList_SET_ITEM(ret, cnt, tmp);
! 				}
! 			}
! 			if (tuple)
! 				PyList_SET_ITEM(ret, cnt, tuple);
! 		}
! 	}
! 	return ret ? (PyObject*)ret : (PyObject*)PyList_New(0);
! }
! 
! RESULT eDVBServiceList::getNext(eServiceReference &ref)
! {
! 	if (!m_query)
! 		return -1;
! 	
! 	return m_query->getNextResult((eServiceReferenceDVB&)ref);
! }
! 
! RESULT eDVBServiceList::startEdit(ePtr<iMutableServiceList> &res)
! {
! 	if (m_parent.flags & eServiceReference::canDescent) // bouquet
! 	{
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> resm;
! 
! 		if (eDVBResourceManager::getInstance(resm) || resm->getChannelList(db))
! 			return -1;
! 
! 		if (db->getBouquet(m_parent, m_bouquet) != 0)
! 			return -1;
! 
! 		res = this;
! 		
! 		return 0;
! 	}
! 	res = 0;
! 	return -1;
! }
! 
! RESULT eDVBServiceList::addService(eServiceReference &ref, eServiceReference before)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->addService(ref, before);
! }
! 
! RESULT eDVBServiceList::removeService(eServiceReference &ref)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->removeService(ref);
! }
! 
! RESULT eDVBServiceList::moveService(eServiceReference &ref, int pos)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->moveService(ref, pos);
! }
! 
! RESULT eDVBServiceList::flushChanges()
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->flushChanges();
! }
! 
! RESULT eDVBServiceList::setListName(const std::string &name)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->setListName(name);
! }
! 
! RESULT eServiceFactoryDVB::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
! {
! 	ePtr<eDVBService> service;
! 	int r = lookupService(service, ref);
! 	if (r)
! 		service = 0;
! 		// check resources...
! 	ptr = new eDVBServicePlay(ref, service);
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
! {
! 	if (ref.path.empty())
! 	{
! 		ptr = new eDVBServiceRecord((eServiceReferenceDVB&)ref);
! 		return 0;
! 	} else
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! }
! 
! RESULT eServiceFactoryDVB::list(const eServiceReference &ref, ePtr<iListableService> &ptr)
! {
! 	ePtr<eDVBServiceList> list = new eDVBServiceList(ref);
! 	if (list->startQuery())
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! 	
! 	ptr = list;
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
! {
! 	/* is a listable service? */
! 	if (ref.flags & eServiceReference::canDescent) // bouquet
! 	{
! 		if ( !ref.name.empty() )  // satellites or providers list
! 			ptr = m_StaticServiceDVBInfo;
! 		else // a dvb bouquet
! 			ptr = m_StaticServiceDVBBouquetInfo;
! 	}
! 	else if (!ref.path.empty()) /* do we have a PVR service? */
! 		ptr = new eStaticServiceDVBPVRInformation(ref);
! 	else // normal dvb service
! 	{
! 		ePtr<eDVBService> service;
! 		if (lookupService(service, ref)) // no eDVBService avail for this reference ( Linkage Services... )
! 			ptr = m_StaticServiceDVBInfo;
! 		else
! 			/* eDVBService has the iStaticServiceInformation interface, so we pass it here. */
! 			ptr = service;
! 	}
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
! {
! 	if (ref.path.empty())
! 	{
! 		ptr = 0;
! 		return -1;
! 	} else
! 	{
! 		ptr = new eDVBPVRServiceOfflineOperations(ref);
! 		return 0;
! 	}
! }
! 
! RESULT eServiceFactoryDVB::lookupService(ePtr<eDVBService> &service, const eServiceReference &ref)
! {
! 	if (!ref.path.empty()) // playback
! 	{
! 		eDVBMetaParser parser;
! 		int ret=parser.parseFile(ref.path);
! 		service = new eDVBService;
! 		if (!ret)
! 			eDVBDB::getInstance()->parseServiceData(service, parser.m_service_data);
! 	}
! 	else
! 	{
! 			// TODO: handle the listing itself
! 		// if (ref.... == -1) .. return "... bouquets ...";
! 		// could be also done in another serviceFactory (with seperate ID) to seperate actual services and lists
! 			// TODO: cache
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> res;
! 	
! 		int err;
! 		if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 		{
! 			eDebug("no resource manager");
! 			return err;
! 		}
! 		if ((err = res->getChannelList(db)) != 0)
! 		{
! 			eDebug("no channel list");
! 			return err;
! 		}
! 	
! 		/* we are sure to have a ..DVB reference as the info() call was forwarded here according to it's ID. */
! 		if ((err = db->getService((eServiceReferenceDVB&)ref, service)) != 0)
! 		{
! //			eDebug("getService failed!");
! 			return err;
! 		}
! 	}
! 
! 	return 0;
! }
! 
! eDVBServicePlay::eDVBServicePlay(const eServiceReference &ref, eDVBService *service):
! 	m_reference(ref), m_dvb_service(service), m_have_video_pid(0), m_is_paused(0)
! {
! 	m_is_primary = 1;
! 	m_is_pvr = !m_reference.path.empty();
! 	
! 	m_timeshift_enabled = m_timeshift_active = 0, m_timeshift_changed = 0;
! 	m_skipmode = m_fastforward = m_slowmotion = 0;
! 	
! 	CONNECT(m_service_handler.serviceEvent, eDVBServicePlay::serviceEvent);
! 	CONNECT(m_service_handler_timeshift.serviceEvent, eDVBServicePlay::serviceEventTimeshift);
! 	CONNECT(m_event_handler.m_eit_changed, eDVBServicePlay::gotNewEvent);
! 
! 	m_cuesheet_changed = 0;
! 	m_cutlist_enabled = 1;
! 	
! 	m_subtitle_widget = 0;
! 	
! 	m_tune_state = -1;
! 
! 	m_subtitle_sync_timer = eTimer::create(eApp);
! 
! 	CONNECT(m_subtitle_sync_timer->timeout, eDVBServicePlay::checkSubtitleTiming);
! 
! 	m_player = 0;
! 
! 	xineLib = cXineLib::getInstance();
! 	xine_connection = CONNECT(xineLib->m_event, eDVBServicePlay::video_event);
! }
! 
! eDVBServicePlay::~eDVBServicePlay()
! {
! 	if (m_is_pvr)
! 	{
! 		eDVBMetaParser meta;
! 		int ret=meta.parseFile(m_reference.path);
! 		if (!ret)
! 		{
! 			char tmp[255];
! 			meta.m_service_data="";
! 			sprintf(tmp, "f:%x", m_dvb_service->m_flags);
! 			meta.m_service_data += tmp;
! 			// cached pids
! 			for (int x=0; x < eDVBService::cacheMax; ++x)
! 			{
! 				int entry = m_dvb_service->getCacheEntry((eDVBService::cacheID)x);
! 				if (entry != -1)
! 				{
! 					sprintf(tmp, ",c:%02d%04x", x, entry);
! 					meta.m_service_data += tmp;
! 				}
! 			}
! 			meta.updateMeta(m_reference.path);
! 		}
! 	}
! 
! 	xine_connection.disconnect();
! 
! 	delete m_subtitle_widget;
! }
! 
! void eDVBServicePlay::gotNewEvent()
! {
! #if 0
! 		// debug only
! 	ePtr<eServiceEvent> m_event_now, m_event_next;
! 	getEvent(m_event_now, 0);
! 	getEvent(m_event_next, 1);
! 
! 	if (m_event_now)
! 		eDebug("now running: %s (%d seconds :)", m_event_now->m_event_name.c_str(), m_event_now->m_duration);
! 	if (m_event_next)
! 		eDebug("next running: %s (%d seconds :)", m_event_next->m_event_name.c_str(), m_event_next->m_duration);
! #endif
! 	m_event((iPlayableService*)this, evUpdatedEventInfo);
! }
! 
! void eDVBServicePlay::serviceEvent(int event)
! {
! 	m_tune_state = event;
! 
! 	switch (event)
! 	{
! 	case eDVBServicePMTHandler::eventTuned:
! 	{
! 		ePtr<iDVBDemux> m_demux;
! 		if (!m_service_handler.getDataDemux(m_demux))
! 		{
! 			eServiceReferenceDVB &ref = (eServiceReferenceDVB&) m_reference;
! 			int sid = ref.getParentServiceID().get();
! 			if (!sid)
! 				sid = ref.getServiceID().get();
! 			if ( ref.getParentTransportStreamID().get() &&
! 				ref.getParentTransportStreamID() != ref.getTransportStreamID() )
! 				m_event_handler.startOther(m_demux, sid);
! 			else
! 				m_event_handler.start(m_demux, sid);
! 		}
! 		m_event((iPlayableService*)this, evTunedIn);
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventNoResources:
! 	case eDVBServicePMTHandler::eventNoPAT:
! 	case eDVBServicePMTHandler::eventNoPATEntry:
! 	case eDVBServicePMTHandler::eventNoPMT:
! 	case eDVBServicePMTHandler::eventTuneFailed:
! 	case eDVBServicePMTHandler::eventMisconfiguration:
! 	{
! 		eDebug("DVB service failed to tune - error %d", event);
! 		m_event((iPlayableService*)this, evTuneFailed);
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventNewProgramInfo:
! 	{
! 		eDebug("eventNewProgramInfo %d %d", m_timeshift_enabled, m_timeshift_active);
! 		if (m_timeshift_enabled)
! 			updateTimeshiftPids();
! 		if (!m_timeshift_active)
! 			updateDecoder();
! 		if (m_first_program_info & 1 && m_is_pvr)
! 		{
! 			m_first_program_info &= ~1;
! 			seekTo(0);
! 		}
! 		if (!m_timeshift_active)
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 
! 		ePtr<iDVBDemux> m_demux;
! 		if (!m_service_handler.getDataDemux(m_demux))
! 		{
! 			printf("Start live TV!\n");
! 
! 			m_demux->createTSPlayer(m_player);
! 			if (!m_player)
! 				printf("ERROR: !m_player\n");
! 			
! 			m_player->setTargetFD(m_fd_dst);
! 			updateTimeshiftPids();
! 			m_player->start();
! 
! 			printf("Start live TV END\n");
! 		}
! 
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventPreStart:
! 		loadCuesheet();
! 		break;
! 	case eDVBServicePMTHandler::eventEOF:
! 		m_event((iPlayableService*)this, evEOF);
! 		break;
! 	case eDVBServicePMTHandler::eventSOF:
! 		m_event((iPlayableService*)this, evSOF);
! 		break;
! 	}
! }
! 
! void eDVBServicePlay::serviceEventTimeshift(int event)
! {
! 	switch (event)
! 	{
! 	case eDVBServicePMTHandler::eventNewProgramInfo:
! 		eDebug("eventNewProgramInfo TS");
! 		if (m_timeshift_active)
! 		{
! 			updateDecoder();
! 			if (m_first_program_info & 2)
! 			{
! 				if (m_slowmotion)
! 				{
! 					eDebug("re-apply slowmotion after timeshift file change");
! 					m_decoder->setSlowMotion(m_slowmotion);
! 				}
! 				if (m_fastforward)
! 				{
! 					eDebug("re-apply skip %d, ratio %d after timeshift file change", m_skipmode, m_fastforward);
! 					if (m_skipmode)
! 						m_cue->setSkipmode(m_skipmode * 90000); /* convert to 90000 per second */
! 					if (m_fastforward != 1)
! 						m_decoder->setFastForward(m_fastforward);
! 					else
! 						m_decoder->setTrickmode();
! 				}
! 				else
! 					seekTo(0);
! 				m_first_program_info &= ~2;
! 			}
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 		}
! 		break;
! 	case eDVBServicePMTHandler::eventSOF:
! #if 0
! 		if (!m_timeshift_file_next.empty())
! 		{
! 			eDebug("timeshift SOF, switch to next file");
! 			m_decoder->pause();
! 
! 			m_first_program_info |= 2;
! 
! 			eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 			r.path = m_timeshift_file_next;
! 
! 			/* free the timeshift service handler, we need the resources */
! 			m_service_handler_timeshift.free();
! 			resetTimeshift(1);
! 
! 			if (m_skipmode < 0)
! 				m_cue->seekTo(0, -1000);
! 			ePtr<iTsSource> source = createTsSource(r);
! 			m_service_handler_timeshift.tuneExt(r, 1, source, r.path.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 			m_event((iPlayableService*)this, evUser+1);
! 		}
! 		else
! #endif
! 			m_event((iPlayableService*)this, evSOF);
! 		break;
! 	case eDVBServicePMTHandler::eventEOF:
! 		if ((!m_is_paused) && (m_skipmode >= 0))
! 		{
! 			if (m_timeshift_file_next.empty())
! 			{
! 				eDebug("timeshift EOF, so let's go live");
! 				switchToLive();
! 			}
! 			else
! 			{
! 				eDebug("timeshift EOF, switch to next file");
! 
! 				m_first_program_info |= 2;
! 
! 				eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 				r.path = m_timeshift_file_next;
! 
! 				/* free the timeshift service handler, we need the resources */
! 				m_service_handler_timeshift.free();
! 				resetTimeshift(1);
! 
! 				ePtr<iTsSource> source = createTsSource(r);
! 				m_service_handler_timeshift.tuneExt(r, 1, source, m_timeshift_file_next.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 				m_event((iPlayableService*)this, evUser+1);
! 			}
! 		}
! 		break;
! 	}
! }
! 
! RESULT eDVBServicePlay::start()
! {
! 	printf("eDVBServicePlay::start\n");
! 	eServiceReferenceDVB service = (eServiceReferenceDVB&)m_reference;
! 
! 	m_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
! 	if (m_fd_dst < 0)
! 	{
! 		eDebug("can't open DVR device - FIFO file (%m)");
! 	}
! 
! 		/* in pvr mode, we only want to use one demux. in tv mode, we're using 
! 		   two (one for decoding, one for data source), as we must be prepared
! 		   to start recording from the data demux. */
! 	if (m_is_pvr)
! 	{
! 		eDVBMetaParser meta;
! 		if (!meta.parseFile(m_reference.path))
! 		{
! 			service = meta.m_ref;
! 			service.path = m_reference.path;
! 		}
! 		m_cue = new eCueSheet();
! 	}
! 	else
! 		m_event(this, evStart);
! 
! 	m_first_program_info = 1;
! 	ePtr<iTsSource> source = createTsSource(service);
! 	m_service_handler.tuneExt(service, m_is_pvr, source, service.path.c_str(), m_cue, false, m_dvb_service);
! 
! 	if (m_is_pvr)
! 	{
! 		/* inject EIT if there is a stored one */
! 		std::string filename = service.path;
! 		filename.erase(filename.length()-2, 2);
! 		filename+="eit";
! 		ePtr<eServiceEvent> event = new eServiceEvent;
! 		if (!event->parseFrom(filename, (service.getTransportStreamID().get()<<16)|service.getOriginalNetworkID().get()))
! 		{
! 			ePtr<eServiceEvent> empty;
! 			m_event_handler.inject(event, 0);
! 			m_event_handler.inject(empty, 1);
! 		}
! 		m_event(this, evStart);
! 	}
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::stop()
! {
! 	printf("eDVBServicePlay::stop\n");
! 		/* add bookmark for last play position */
! 	if (m_is_pvr)
! 	{
! 		pts_t play_position, length;
! 		if (!getPlayPosition(play_position))
! 		{
! 				/* remove last position */
! 			for (std::multiset<struct cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end();)
! 			{
! 				if (i->what == 3) /* current play position */
! 				{
! 					m_cue_entries.erase(i);
! 					i = m_cue_entries.begin();
! 					continue;
! 				} else
! 					++i;
! 			}
! 			
! 			if (getLength(length))
! 				length = 0;
! 			
! 			if (length)
! 			{
! 				m_cue_entries.insert(cueEntry(play_position, 3)); /* last play position */
! 			}
! 			m_cuesheet_changed = 1;
! 		}
! 	}
! 
! 	stopTimeshift(); /* in case timeshift was enabled, remove buffer etc. */
! 
! 	// stop TSPlayer
! 	if (m_player) {
! 		m_player->stop();
! 		m_player = 0;
! 	}
! 	if (m_fd_dst>0) {
! 		printf("close(m_fd_dst)  %d\n", m_fd_dst);
! 		close(m_fd_dst);
! 	}
! 
! 	m_service_handler_timeshift.free();
! 	m_service_handler.free();
! 	
! 	if (m_is_pvr && m_cuesheet_changed)
! 	{
! 		struct stat s;
! 				/* save cuesheet only when main file is accessible. */
! 		if (!::stat(m_reference.path.c_str(), &s))
! 			saveCuesheet();
! 	}
! 	m_event((iPlayableService*)this, evStopped);
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::setTarget(int target)
! {
! 	m_is_primary = !target;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
! {
! 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::pause(ePtr<iPauseableService> &ptr)
! {
! 		/* note: we check for timeshift to be enabled,
! 		   not neccessary active. if you pause when timeshift
! 		   is not active, you should activate it when unpausing */
! 	if ((!m_is_pvr) && (!m_timeshift_enabled))
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! 
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::setSlowMotion(int ratio)
! {
! 	ASSERT(ratio); /* The API changed: instead of calling setSlowMotion(0), call play! */
! 	eDebug("eDVBServicePlay::setSlowMotion(%d)", ratio);
! 	setFastForward_internal(0);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = ratio;
! 		return m_decoder->setSlowMotion(ratio);
! 	}
! 	else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::setFastForward(int ratio)
! {
! 	eDebug("eDVBServicePlay::setFastForward(%d)", ratio);
! 	ASSERT(ratio);
! 	return setFastForward_internal(ratio);
! }
! 
! RESULT eDVBServicePlay::setFastForward_internal(int ratio, bool final_seek)
! {
! 	int skipmode, ffratio, ret = 0;
! 	pts_t pos=0;
! 
! 	if (ratio > 8)
! 	{
! 		skipmode = ratio;
! 		ffratio = 1;
! 	} else if (ratio > 0)
! 	{
! 		skipmode = 0;
! 		ffratio = ratio;
! 	} else if (!ratio)
! 	{
! 		skipmode = 0;
! 		ffratio = 0;
! 	} else // if (ratio < 0)
! 	{
! 		skipmode = ratio;
! 		ffratio = 1;
! 	}
! 
! 	if (m_skipmode != skipmode)
! 	{
! 		eDebug("setting cue skipmode to %d", skipmode);
! 		if (m_cue)
! 			m_cue->setSkipmode(skipmode * 90000); /* convert to 90000 per second */
! 	}
! 
! 	m_skipmode = skipmode;
! 
! 	if (final_seek)
! 		eDebug("trickplay stopped .. ret %d, pos %lld", getPlayPosition(pos), pos);
! 
! 	m_fastforward = ffratio;
! 
! 	if (!m_decoder)
! 		return -1;
! 
! 	if (ffratio == 0)
! 		; /* return m_decoder->play(); is done in caller*/
! 	else if (ffratio != 1)
! 		ret = m_decoder->setFastForward(ffratio);
! 	else
! 		ret = m_decoder->setTrickmode();
! 
! 	if (pos)
! 		eDebug("final seek after trickplay ret %d", seekTo(pos));
! 
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::seek(ePtr<iSeekableService> &ptr)
! {
! 	if (m_is_pvr || m_timeshift_enabled)
! 	{
! 		ptr = this;
! 		return 0;
! 	}
! 	
! 	ptr = 0;
! 	return -1;
! }
! 
! 	/* TODO: when timeshift is enabled but not active, this doesn't work. */
! RESULT eDVBServicePlay::getLength(pts_t &len)
! {
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	return pvr_channel->getLength(len);
! }
! 
! RESULT eDVBServicePlay::pause()
! {
! 	eDebug("eDVBServicePlay::pause");
! 	setFastForward_internal(0, m_slowmotion || m_fastforward > 1);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = 0;
! 		m_is_paused = 1;
! 		return m_decoder->pause();
! 	} else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::unpause()
! {
! 	eDebug("eDVBServicePlay::unpause");
! 	setFastForward_internal(0, m_slowmotion || m_fastforward > 1);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = 0;
! 		m_is_paused = 0;
! 		return m_decoder->play();
! 	} else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::seekTo(pts_t to)
! {
! 	eDebug("eDVBServicePlay::seekTo: jump %lld", to);
! 	
! 	if (!m_decode_demux)
! 		return -1;
! 
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	if (!m_cue)
! 		return -1;
! 	
! 	m_cue->seekTo(0, to);
! 	m_dvb_subtitle_pages.clear();
! 	m_subtitle_pages.clear();
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::seekRelative(int direction, pts_t to)
! {
! 	eDebug("eDVBServicePlay::seekRelative: jump %d, %lld", direction, to);
! 	
! 	if (!m_decode_demux)
! 		return -1;
! 
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	int mode = 1;
! 	
! 			/* HACK until we have skip-AP api */
! 	if ((to > 0) && (to < 100))
! 		mode = 2;
! 	
! 	to *= direction;
! 	
! 	if (!m_cue)
! 		return 0;
! 	
! 	m_cue->seekTo(mode, to);
! 	m_dvb_subtitle_pages.clear();
! 	m_subtitle_pages.clear();
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getPlayPosition(pts_t &pos)
! {
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	int r = 0;
! 
! 	r = xineLib->getPTS(pos);
! 	if (r)
! 		return r;
! 	
! 		/* fixup */
! 	return pvr_channel->getCurrentPosition(m_decode_demux, pos, 1);
! }
! 
! RESULT eDVBServicePlay::setTrickmode(int trick)
! {
! 		/* currently unimplemented */
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::isCurrentlySeekable()
! {
! 	int ret = 0;
! 	if (m_decoder)
! 	{
! 		ret = (m_is_pvr || m_timeshift_active) ? 3 : 0; // fast forward/backward possible and seeking possible
! 		if (m_decoder->getVideoProgressive() == -1)
! 			ret &= ~2;
! 	}
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::frontendInfo(ePtr<iFrontendInformation> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::info(ePtr<iServiceInformation> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioChannel(ePtr<iAudioChannelSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioTracks(ePtr<iAudioTrackSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::subServices(ePtr<iSubserviceList> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::timeshift(ePtr<iTimeshiftService> &ptr)
! {
! 	ptr = 0;
! 	if (m_have_video_pid &&  // HACK !!! FIXMEE !! temporary no timeshift on radio services !!
! 		(m_timeshift_enabled || !m_is_pvr))
! 	{
! 		if (!m_timeshift_enabled)
! 		{
! 			/* query config path */
! 			std::string tspath;
! 			if(ePythonConfigQuery::getConfigValue("config.usage.timeshift_path", tspath) == -1){
! 				eDebug("could not query ts path from config");
! 				return -4;
! 			}
! 			tspath.append("/");
! 			/* we need enough diskspace */
! 			struct statfs fs;
! 			if (statfs(tspath.c_str(), &fs) < 0)
! 			{
! 				eDebug("statfs failed!");
! 				return -2;
! 			}
! 		
! 			if (((off_t)fs.f_bavail) * ((off_t)fs.f_bsize) < 1024*1024*1024LL)
! 			{
! 				eDebug("not enough diskspace for timeshift! (less than 1GB)");
! 				return -3;
! 			}
! 		}
! 		ptr = this;
! 		return 0;
! 	}
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::cueSheet(ePtr<iCueSheet> &ptr)
! {
! 	if (m_is_pvr)
! 	{
! 		ptr = this;
! 		return 0;
! 	}
! 	ptr = 0;
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::subtitle(ePtr<iSubtitleOutput> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioDelay(ePtr<iAudioDelay> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::rdsDecoder(ePtr<iRdsDecoder> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getName(std::string &name)
! {
! 	if (m_is_pvr)
! 	{
! 		ePtr<iStaticServiceInformation> i = new eStaticServiceDVBPVRInformation(m_reference);
! 		return i->getName(m_reference, name);
! 	}
! 	else if (m_dvb_service)
! 	{
! 		m_dvb_service->getName(m_reference, name);
! 		if (name.empty())
! 			name = "(...)";
! 	}
! 	else if (!m_reference.name.empty())
! 		eStaticServiceDVBInformation().getName(m_reference, name);
! 	else
! 		name = "DVB service";
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getEvent(ePtr<eServiceEvent> &evt, int nownext)
! {
! 	return m_event_handler.getEvent(evt, nownext);
! }
! 
! int eDVBServicePlay::getInfo(int w)
! {
! 	eDVBServicePMTHandler::program program;
! 
! 	if (w == sCAIDs || w == sCAIDPIDs)
! 		return resIsPyObject;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	int no_program_info = 0;
! 
! 	if (h.getProgramInfo(program))
! 		no_program_info = 1;
! 
! 	switch (w)
! 	{
! 	case sVideoHeight:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoHeight();
! 		return xineLib->getVideoHeight();
! 		break;
! 	case sVideoWidth:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoWidth();
! 		return xineLib->getVideoWidth();
! 		break;
! 	case sFrameRate:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoFrameRate();
! 		return xineLib->getVideoFrameRate();
! 		break;
! 	case sProgressive:
! 		if (m_decoder)
! 			return m_decoder->getVideoProgressive();
! 		break;
! 	case sAspect:
! 	{
! 		//if (m_decoder)
! 		//	aspect = m_decoder->getVideoAspect();
! 		int aspect = xineLib->getVideoAspect();
! 
! 		if (aspect == -1 && no_program_info)
! 			break;
! 		else if (aspect == -1 && !program.videoStreams.empty() && program.videoStreams[0].component_tag != -1)
! 		{
! 			ePtr<eServiceEvent> evt;
! 			if (!m_event_handler.getEvent(evt, 0))
! 			{
! 				ePtr<eComponentData> data;
! 				if (!evt->getComponentData(data, program.videoStreams[0].component_tag))
! 				{
! 					if ( data->getStreamContent() == 1 )
! 					{
! 						switch(data->getComponentType())
! 						{
! 							// SD
! 							case 1: // 4:3 SD PAL
! 							case 2:
! 							case 3: // 16:9 SD PAL
! 							case 4: // > 16:9 PAL
! 							case 5: // 4:3 SD NTSC
! 							case 6: 
! 							case 7: // 16:9 SD NTSC
! 							case 8: // > 16:9 NTSC
! 
! 							// HD
! 							case 9: // 4:3 HD PAL
! 							case 0xA:
! 							case 0xB: // 16:9 HD PAL
! 							case 0xC: // > 16:9 HD PAL
! 							case 0xD: // 4:3 HD NTSC
! 							case 0xE:
! 							case 0xF: // 16:9 HD NTSC
! 							case 0x10: // > 16:9 HD PAL
! 								return data->getComponentType();
! 						}
! 					}
! 				}
! 			}
! 		}
! 		else
! 			return aspect;
! 		break;
! 	}
! 	case sIsCrypted: if (no_program_info) return -1; return program.isCrypted();
! 	case sVideoPID:
! 		if (m_dvb_service)
! 		{
! 			int vpid = m_dvb_service->getCacheEntry(eDVBService::cVPID);
! 			if (vpid != -1)
! 				return vpid;
! 		}
! 		if (no_program_info) return -1; if (program.videoStreams.empty()) return -1; return program.videoStreams[0].pid;
! 	case sVideoType: if (no_program_info) return -1; if (program.videoStreams.empty()) return -1; return program.videoStreams[0].type;
! 	case sAudioPID:
! 		if (m_dvb_service)
! 		{
! 			int apid = m_dvb_service->getCacheEntry(eDVBService::cAPID);
! 			if (apid != -1)
! 				return apid;
! 			apid = m_dvb_service->getCacheEntry(eDVBService::cAC3PID);
! 			if (apid != -1)
! 				return apid;
! 		}
! 		if (no_program_info) return -1; if (program.audioStreams.empty()) return -1; return program.audioStreams[0].pid;
! 	case sPCRPID:
! 		if (m_dvb_service)
! 		{
! 			int pcrpid = m_dvb_service->getCacheEntry(eDVBService::cPCRPID);
! 			if (pcrpid != -1)
! 				return pcrpid;
! 		}
! 		if (no_program_info) return -1; return program.pcrPid;
! 	case sPMTPID: if (no_program_info) return -1; return program.pmtPid;
! 	case sTXTPID: if (no_program_info) return -1; return program.textPid;
! 	case sSID: return ((const eServiceReferenceDVB&)m_reference).getServiceID().get();
! 	case sONID: return ((const eServiceReferenceDVB&)m_reference).getOriginalNetworkID().get();
! 	case sTSID: return ((const eServiceReferenceDVB&)m_reference).getTransportStreamID().get();
! 	case sNamespace: return ((const eServiceReferenceDVB&)m_reference).getDVBNamespace().get();
! 	case sProvider: if (!m_dvb_service) return -1; return -2;
! 	case sServiceref: return resIsString;
! 	case sDVBState: return m_tune_state;
! 	default:
! 		break;
! 	}
! 	return -1;
! }
! 
! std::string eDVBServicePlay::getInfoString(int w)
! {
! 	switch (w)
! 	{
! 	case sProvider:
! 		if (!m_dvb_service) return "";
! 		return m_dvb_service->m_provider_name;
! 	case sServiceref:
! 		return m_reference.toString();
! 	default:
! 		break;
! 	}
! 	return iServiceInformation::getInfoString(w);
! }
! 
! PyObject *eDVBServicePlay::getInfoObject(int w)
! {
! 	switch (w)
! 	{
! 	case sCAIDs:
! 		return m_service_handler.getCaIds();
! 	case sCAIDPIDs:
! 		return m_service_handler.getCaIds(true);
! 	case sTransponderData:
! 		return eStaticServiceDVBInformation().getInfoObject(m_reference, w);
! 	default:
! 		break;
! 	}
! 	return iServiceInformation::getInfoObject(w);
! }
! 
! int eDVBServicePlay::getNumberOfTracks()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	if (h.getProgramInfo(program))
! 		return 0;
! 	return program.audioStreams.size();
! }
! 
! int eDVBServicePlay::getCurrentTrack()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	if (h.getProgramInfo(program))
! 		return 0;
! 
! 	int max = program.audioStreams.size();
! 	int i;
! 
! 	for (i = 0; i < max; ++i)
! 		if (program.audioStreams[i].pid == m_current_audio_pid)
! 			return i;
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::selectTrack(unsigned int i)
! {
! 	int ret = selectAudioStream(i);
! 
! 	if (m_decoder->set())
! 		return -5;
! 
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	if (h.getProgramInfo(program))
! 		return -1;
! 	
! 	if (i >= program.audioStreams.size())
! 		return -2;
! 	
! 	info.m_pid = program.audioStreams[i].pid;
! 
! 	if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atMPEG)
! 		info.m_description = "MPEG";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAC3)
! 		info.m_description = "AC3";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAAC)
! 		info.m_description = "AAC";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAACHE)
! 		info.m_description = "AAC-HE";
! 	else  if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDTS)
! 		info.m_description = "DTS";
! 	else  if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDTSHD)
! 		info.m_description = "DTS-HD";
! 	else
! 		info.m_description = "???";
! 
! 	if (program.audioStreams[i].component_tag != -1)
! 	{
! 		ePtr<eServiceEvent> evt;
! 		if (!m_event_handler.getEvent(evt, 0))
! 		{
! 			ePtr<eComponentData> data;
! 			if (!evt->getComponentData(data, program.audioStreams[i].component_tag))
! 				info.m_language = data->getText();
! 		}
! 	}
! 
! 	if (info.m_language.empty())
! 		info.m_language = program.audioStreams[i].language_code;
! 	
! 	return 0;
! }
! 
! int eDVBServicePlay::selectAudioStream(int i)
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	pts_t position = -1;
! 
! 	if (h.getProgramInfo(program))
! 		return -1;
! 
! 	if ((i != -1) && ((unsigned int)i >= program.audioStreams.size()))
! 		return -2;
! 
! 	if (!m_decoder)
! 		return -3;
! 
! 	int stream = i;
! 	if (stream == -1)
! 		stream = program.defaultAudioStream;
! 
! 	int apid = -1, apidtype = -1;
! 
! 	if (((unsigned int)stream) < program.audioStreams.size())
! 	{
! 		apid = program.audioStreams[stream].pid;
! 		apidtype = program.audioStreams[stream].type;
! 	}
! 
! 	if (i != -1 && apid != m_current_audio_pid && (m_is_pvr || m_timeshift_active))
! 		eDebug("getPlayPosition ret %d, pos %lld in selectAudioStream", getPlayPosition(position), position);
! 
! 	m_current_audio_pid = apid;
! 
! 	if (m_is_primary && m_decoder->setAudioPID(apid, apidtype))
! 	{
! 		eDebug("set audio pid failed");
! 		return -4;
! 	}
! 
! 	if (position != -1)
! 		eDebug("seekTo ret %d", seekTo(position));
! 
! 	int rdsPid = apid;
! 
! 		/* if we are not in PVR mode, timeshift is not active and we are not in pip mode, check if we need to enable the rds reader */
! 	if (!(m_is_pvr || m_timeshift_active || !m_is_primary))
! 	{
! 		int different_pid = program.videoStreams.empty() && program.audioStreams.size() == 1 && program.audioStreams[stream].rdsPid != -1;
! 		if (different_pid)
! 			rdsPid = program.audioStreams[stream].rdsPid;
! 		if (!m_rds_decoder || m_rds_decoder->getPid() != rdsPid)
! 		{
! 			m_rds_decoder = 0;
! 			ePtr<iDVBDemux> data_demux;
! 			if (!h.getDataDemux(data_demux))
! 			{
! 				m_rds_decoder = new eDVBRdsDecoder(data_demux, different_pid);
! 				m_rds_decoder->connectEvent(slot(*this, &eDVBServicePlay::rdsDecoderEvent), m_rds_decoder_event_connection);
! 				m_rds_decoder->start(rdsPid);
! 			}
! 		}
! 	}
! 
! 			/* store new pid as default only when:
! 				a.) we have an entry in the service db for the current service,
! 				b.) we are not playing back something,
! 				c.) we are not selecting the default entry. (we wouldn't change 
! 				    anything in the best case, or destroy the default setting in
! 				    case the real default is not yet available.)
! 			*/
! 	if (m_dvb_service && ((i != -1)
! 		|| ((m_dvb_service->getCacheEntry(eDVBService::cAPID) == -1) && (m_dvb_service->getCacheEntry(eDVBService::cAC3PID)==-1))))
! 	{
! 		if (apidtype == eDVBAudio::aMPEG)
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, apid);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, -1);
! 		}
! 		else if (apidtype == eDVBAudio::aAC3)
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, -1);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, apid);
! 		}
! 		else
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, -1);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, -1);
! 		}
! 	}
! 
! 	h.resetCachedProgram();
! 
! 	return 0;
! }
! 
! int eDVBServicePlay::getCurrentChannel()
! {
! 	return m_decoder ? m_decoder->getAudioChannel() : STEREO;
! }
! 
! RESULT eDVBServicePlay::selectChannel(int i)
! {
! 	if (i < LEFT || i > RIGHT || i == STEREO)
! 		i = -1;  // Stereo
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cACHANNEL, i);
! 	if (m_decoder)
! 		m_decoder->setAudioChannel(i);
! 	return 0;
! }
! 
! std::string eDVBServicePlay::getText(int x)
! {
! 	if (m_rds_decoder)
! 		switch(x)
! 		{
! 			case RadioText:
! 				return convertLatin1UTF8(m_rds_decoder->getRadioText());
! 			case RtpText:
! 				return convertLatin1UTF8(m_rds_decoder->getRtpText());
! 		}
! 	return "";
! }
! 
! void eDVBServicePlay::rdsDecoderEvent(int what)
! {
! 	switch(what)
! 	{
! 		case eDVBRdsDecoder::RadioTextChanged:
! 			m_event((iPlayableService*)this, evUpdatedRadioText);
! 			break;
! 		case eDVBRdsDecoder::RtpTextChanged:
! 			m_event((iPlayableService*)this, evUpdatedRtpText);
! 			break;
! 		case eDVBRdsDecoder::RassInteractivePicMaskChanged:
! 			m_event((iPlayableService*)this, evUpdatedRassInteractivePicMask);
! 			break;
! 		case eDVBRdsDecoder::RecvRassSlidePic:
! 			m_event((iPlayableService*)this, evUpdatedRassSlidePic);
! 			break;
! 	}
! }
! 
! void eDVBServicePlay::showRassSlidePicture()
! {
! 	if (m_rds_decoder)
! 	{
! 		if (m_decoder)
! 		{
! 			std::string rass_slide_pic = m_rds_decoder->getRassSlideshowPicture();
! 			if (rass_slide_pic.length())
! 				m_decoder->showSinglePic(rass_slide_pic.c_str());
! 			else
! 				eDebug("empty filename for rass slide picture received!!");
! 		}
! 		else
! 			eDebug("no MPEG Decoder to show iframes avail");
! 	}
! 	else
! 		eDebug("showRassSlidePicture called.. but not decoder");
! }
! 
! void eDVBServicePlay::showRassInteractivePic(int page, int subpage)
! {
! 	if (m_rds_decoder)
! 	{
! 		if (m_decoder)
! 		{
! 			std::string rass_interactive_pic = m_rds_decoder->getRassPicture(page, subpage);
! 			if (rass_interactive_pic.length())
! 				m_decoder->showSinglePic(rass_interactive_pic.c_str());
! 			else
! 				eDebug("empty filename for rass interactive picture %d/%d received!!", page, subpage);
! 		}
! 		else
! 			eDebug("no MPEG Decoder to show iframes avail");
! 	}
! 	else
! 		eDebug("showRassInteractivePic called.. but not decoder");
! }
! 
! ePyObject eDVBServicePlay::getRassInteractiveMask()
! {
! 	if (m_rds_decoder)
! 		return m_rds_decoder->getRassPictureMask();
! 	Py_RETURN_NONE;
! }
! 
! int eDVBServiceBase::getFrontendInfo(int w)
! {
! 	eUsePtr<iDVBChannel> channel;
! 	if(m_service_handler.getChannel(channel))
! 		return 0;
! 	ePtr<iDVBFrontend> fe;
! 	if(channel->getFrontend(fe))
! 		return 0;
! 	return fe->readFrontendData(w);
! }
! 
! PyObject *eDVBServiceBase::getFrontendData()
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getFrontendData(ret);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getFrontendStatus()
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getFrontendStatus(ret);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getTransponderData(bool original)
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getTransponderData(ret, original);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getAll(bool original)
! {
! 	ePyObject ret = getTransponderData(original);
! 	if (ret != Py_None)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 			{
! 				fe->getFrontendData(ret);
! 				fe->getFrontendStatus(ret);
! 			}
! 		}
! 	}
! 	return ret;
! }
! 
! int eDVBServicePlay::getNumberOfSubservices()
! {
! 	ePtr<eServiceEvent> evt;
! 	if (!m_event_handler.getEvent(evt, 0))
! 		return evt->getNumOfLinkageServices();
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getSubservice(eServiceReference &sub, unsigned int n)
! {
! 	ePtr<eServiceEvent> evt;
! 	if (!m_event_handler.getEvent(evt, 0))
! 	{
! 		if (!evt->getLinkageService(sub, m_reference, n))
! 			return 0;
! 	}
! 	sub.type=eServiceReference::idInvalid;
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::startTimeshift()
! {
! 	ePtr<iDVBDemux> demux;
! 	
! 	eDebug("Start timeshift!");
! 	
! 	if (m_timeshift_enabled)
! 		return -1;
! 	
! 		/* start recording with the data demux. */
! 	if (m_service_handler.getDataDemux(demux))
! 		return -2;
! 
! 	demux->createTSRecorder(m_record);
! 	if (!m_record)
! 		return -3;
! 
! 	std::string tspath;
! 	if(ePythonConfigQuery::getConfigValue("config.usage.timeshift_path", tspath) == -1){ 
! 		eDebug("could not query ts path");
! 		return -5;
! 	}
! 	tspath.append("/timeshift.XXXXXX");
! 	char* templ;
! 	templ = new char[tspath.length() + 1];
! 	strcpy(templ, tspath.c_str());
! 
! 	m_timeshift_fd = mkstemp(templ);
! 	m_timeshift_file = std::string(templ);
! 
! 	eDebug("recording to %s", templ);
! 
! 	delete [] templ;
! 
! 	if (m_timeshift_fd < 0)
! 	{
! 		m_record = 0;
! 		return -4;
! 	}
! 		
! 	m_record->setTargetFD(m_timeshift_fd);
! 
! 	m_timeshift_enabled = 1;
! 	
! 	updateTimeshiftPids();
! 	m_record->start();
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::stopTimeshift(bool swToLive)
! {
! 	if (!m_timeshift_enabled)
! 		return -1;
! 	
! 	if (swToLive)
! 		switchToLive();
! 	
! 	m_timeshift_enabled = 0;
! 	
! 	m_record->stop();
! 	m_record = 0;
! 	
! 	close(m_timeshift_fd);
! 	eDebug("remove timeshift file");
! 	eBackgroundFileEraser::getInstance()->erase(m_timeshift_file.c_str());
! 	
! 	return 0;
! }
! 
! int eDVBServicePlay::isTimeshiftActive()
! {
! 	return m_timeshift_enabled && m_timeshift_active;
! }
! 
! RESULT eDVBServicePlay::activateTimeshift()
! {
! 	if (!m_timeshift_enabled)
! 		return -1;
! 	
! 	if (!m_timeshift_active)
! 	{
! 		switchToTimeshift();
! 		return 0;
! 	}
! 	
! 	return -2;
! }
! 
! PyObject *eDVBServicePlay::getCutList()
! {
! 	ePyObject list = PyList_New(0);
! 	
! 	for (std::multiset<struct cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end(); ++i)
! 	{
! 		ePyObject tuple = PyTuple_New(2);
! 		PyTuple_SET_ITEM(tuple, 0, PyLong_FromLongLong(i->where));
! 		PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(i->what));
! 		PyList_Append(list, tuple);
! 		Py_DECREF(tuple);
! 	}
! 	
! 	return list;
! }
! 
! void eDVBServicePlay::setCutList(ePyObject list)
! {
! 	if (!PyList_Check(list))
! 		return;
! 	int size = PyList_Size(list);
! 	int i;
! 	
! 	m_cue_entries.clear();
! 	
! 	for (i=0; i<size; ++i)
! 	{
! 		ePyObject tuple = PyList_GET_ITEM(list, i);
! 		if (!PyTuple_Check(tuple))
! 		{
! 			eDebug("non-tuple in cutlist");
! 			continue;
! 		}
! 		if (PyTuple_Size(tuple) != 2)
! 		{
! 			eDebug("cutlist entries need to be a 2-tuple");
! 			continue;
! 		}
! 		ePyObject ppts = PyTuple_GET_ITEM(tuple, 0), ptype = PyTuple_GET_ITEM(tuple, 1);
! 		if (!(PyLong_Check(ppts) && PyInt_Check(ptype)))
! 		{
! 			eDebug("cutlist entries need to be (pts, type)-tuples (%d %d)", PyLong_Check(ppts), PyInt_Check(ptype));
! 			continue;
! 		}
! 		pts_t pts = PyLong_AsLongLong(ppts);
! 		int type = PyInt_AsLong(ptype);
! 		m_cue_entries.insert(cueEntry(pts, type));
! 		eDebug("adding %08llx, %d", pts, type);
! 	}
! 	m_cuesheet_changed = 1;
! 	
! 	cutlistToCuesheet();
! 	m_event((iPlayableService*)this, evCuesheetChanged);
! }
! 
! void eDVBServicePlay::setCutListEnable(int enable)
! {
! 	m_cutlist_enabled = enable;
! 	cutlistToCuesheet();
! }
! 
! void eDVBServicePlay::updateTimeshiftPids()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	if (h.getProgramInfo(program))
! 		return;
! 	else
! 	{
! 		std::set<int> pids_to_record;
! 		pids_to_record.insert(0); // PAT
! 		if (program.pmtPid != -1)
! 			pids_to_record.insert(program.pmtPid); // PMT
! 
! 		if (program.textPid != -1)
! 			pids_to_record.insert(program.textPid); // Videotext
! 
! 		for (std::vector<eDVBServicePMTHandler::videoStream>::const_iterator
! 			i(program.videoStreams.begin()); 
! 			i != program.videoStreams.end(); ++i)
! 			pids_to_record.insert(i->pid);
! 
! 		for (std::vector<eDVBServicePMTHandler::audioStream>::const_iterator
! 			i(program.audioStreams.begin()); 
! 			i != program.audioStreams.end(); ++i)
! 				pids_to_record.insert(i->pid);
! 
! 		for (std::vector<eDVBServicePMTHandler::subtitleStream>::const_iterator
! 			i(program.subtitleStreams.begin());
! 			i != program.subtitleStreams.end(); ++i)
! 				pids_to_record.insert(i->pid);
! 
! 		std::set<int> new_pids, obsolete_pids;
! 		
! 		std::set_difference(pids_to_record.begin(), pids_to_record.end(), 
! 				m_pids_active.begin(), m_pids_active.end(),
! 				std::inserter(new_pids, new_pids.begin()));
! 		
! 		std::set_difference(
! 				m_pids_active.begin(), m_pids_active.end(),
! 				pids_to_record.begin(), pids_to_record.end(), 
! 				std::inserter(new_pids, new_pids.begin())
! 				);
! 
! 		if (m_record) {
! 			for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
! 				m_record->addPID(*i);
! 			for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
! 				m_record->removePID(*i);
! 		}
! 
! 		for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
! 			m_player->addPID(*i);
! 		for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
! 			m_player->removePID(*i);
! 	}
! }
! 
! RESULT eDVBServicePlay::setNextPlaybackFile(const char *f)
! {
! 	m_timeshift_file_next = f;
! 	return 0;
! }
! 
! void eDVBServicePlay::switchToLive()
! {
! 	if (!m_timeshift_active)
! 		return;
! 
! 	eDebug("SwitchToLive");
! 
! 	resetTimeshift(0);
! 
! 	m_is_paused = m_skipmode = m_fastforward = m_slowmotion = 0; /* not supported in live mode */
! 
! 	/* free the timeshift service handler, we need the resources */
! 	m_service_handler_timeshift.free();
! 
! 	updateDecoder(true);
! }
! 
! void eDVBServicePlay::resetTimeshift(int start)
! {
! 	m_cue = 0;
! 	m_decode_demux = 0;
! 	m_decoder = 0;
! 	m_teletext_parser = 0;
! 	m_rds_decoder = 0;
! 	m_subtitle_parser = 0;
! 	m_new_subtitle_page_connection = 0;
! 	m_new_dvb_subtitle_page_connection = 0;
! 	m_rds_decoder_event_connection = 0;
! 	m_timeshift_changed = 1;
! 	m_timeshift_file_next.clear();
! 
! 	if (start)
! 	{
! 		m_cue = new eCueSheet();
! 		m_timeshift_active = 1;
! 	}
! 	else
! 		m_timeshift_active = 0;
! }
! 
! ePtr<iTsSource> eDVBServicePlay::createTsSource(eServiceReferenceDVB &ref)
! {
! 	eRawFile *f = new eRawFile();
! 	f->open(ref.path.c_str());
! 	return ePtr<iTsSource>(f);
! }
! 
! void eDVBServicePlay::switchToTimeshift()
! {
! 	if (m_timeshift_active)
! 		return;
! 
! 	resetTimeshift(1);
! 
! 	eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 	r.path = m_timeshift_file;
! 
! 	m_cue->seekTo(0, -1000);
! 
! 	ePtr<iTsSource> source = createTsSource(r);
! 	m_service_handler_timeshift.tuneExt(r, 1, source, m_timeshift_file.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 	eDebug("eDVBServicePlay::switchToTimeshift, in pause mode now.");
! 	pause();
! 	updateDecoder(true); /* mainly to switch off PCR, and to set pause */
! }
! 
! void eDVBServicePlay::updateDecoder(bool sendSeekableStateChanged)
! {
! 	int vpid = -1, vpidtype = -1, pcrpid = -1, tpid = -1, achannel = -1, ac3_delay=-1, pcm_delay=-1;
! 	bool mustPlay = false;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	eDVBServicePMTHandler::program program;
! 	if (h.getProgramInfo(program))
! 		eDebug("getting program info failed.");
! 	else
! 	{
! 		eDebugNoNewLine("have %zd video stream(s)", program.videoStreams.size());
! 		if (!program.videoStreams.empty())
! 		{
! 			eDebugNoNewLine(" (");
! 			for (std::vector<eDVBServicePMTHandler::videoStream>::const_iterator
! 				i(program.videoStreams.begin());
! 				i != program.videoStreams.end(); ++i)
! 			{
! 				if (vpid == -1)
! 				{
! 					vpid = i->pid;
! 					vpidtype = i->type;
! 				}
! 				if (i != program.videoStreams.begin())
! 					eDebugNoNewLine(", ");
! 				eDebugNoNewLine("%04x", i->pid);
! 			}
! 			eDebugNoNewLine(")");
! 		}
! 		eDebugNoNewLine(", and %zd audio stream(s)", program.audioStreams.size());
! 		if (!program.audioStreams.empty())
! 		{
! 			eDebugNoNewLine(" (");
! 			for (std::vector<eDVBServicePMTHandler::audioStream>::const_iterator
! 				i(program.audioStreams.begin());
! 				i != program.audioStreams.end(); ++i)
! 			{
! 				if (i != program.audioStreams.begin())
! 					eDebugNoNewLine(", ");
! 				eDebugNoNewLine("%04x", i->pid);
! 			}
! 			eDebugNoNewLine(")");
! 		}
! 		eDebugNoNewLine(", and the pcr pid is %04x", program.pcrPid);
! 		pcrpid = program.pcrPid;
! 		eDebug(", and the text pid is %04x", program.textPid);
! 		tpid = program.textPid;
! 	}
! 
! 	if (!m_decoder)
! 	{
! 		m_decoder = new eTSMPEGDecoder(m_is_primary ? 0 : 1);
! 
! 		if (!m_is_pvr) {
! 			h.getDecodeDemux(m_decode_demux);
! 			if (m_decode_demux)
! 			{
! 				if (m_is_primary)
! 				{
! 					m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
! 					m_teletext_parser->connectNewPage(slot(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
! 					m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
! 					m_subtitle_parser->connectNewPage(slot(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
! 					if (m_timeshift_changed)
! 					{
! 						ePyObject subs = getCachedSubtitle();
! 						if (subs != Py_None)
! 						{
! 							int type = PyInt_AsLong(PyTuple_GET_ITEM(subs, 0)),
! 							    pid = PyInt_AsLong(PyTuple_GET_ITEM(subs, 1)),
! 							    comp_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 2)), // ttx page
! 							    anc_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 3)); // ttx magazine
! 							if (type == 0) // dvb
! 								m_subtitle_parser->start(pid, comp_page, anc_page);
! 							else if (type == 1) // ttx
! 								m_teletext_parser->setPageAndMagazine(comp_page, anc_page);
! 						}
! 						Py_DECREF(subs);
! 					}
! 				}
! 			}
! 
! 			if (m_cue)
! 				m_cue->setDecodingDemux(m_decode_demux, m_decoder);
! 		}
! 
! 		mustPlay = true;
! 	}
! 
! 	m_timeshift_changed = 0;
! 
! 	if (m_decoder)
! 	{
! 		bool wasSeekable = m_decoder->getVideoProgressive() != -1;
! 		if (m_dvb_service)
! 		{
! 			achannel = m_dvb_service->getCacheEntry(eDVBService::cACHANNEL);
! 			ac3_delay = m_dvb_service->getCacheEntry(eDVBService::cAC3DELAY);
! 			pcm_delay = m_dvb_service->getCacheEntry(eDVBService::cPCMDELAY);
! 		}
! 		else // subservice
! 		{
! 			eServiceReferenceDVB ref;
! 			m_service_handler.getServiceReference(ref);
! 			eServiceReferenceDVB parent = ref.getParentServiceReference();
! 			if (!parent)
! 				parent = ref;
! 			if (parent)
! 			{
! 				ePtr<eDVBResourceManager> res_mgr;
! 				if (!eDVBResourceManager::getInstance(res_mgr))
! 				{
! 					ePtr<iDVBChannelList> db;
! 					if (!res_mgr->getChannelList(db))
! 					{
! 						ePtr<eDVBService> origService;
! 						if (!db->getService(parent, origService))
! 						{
! 		 					ac3_delay = origService->getCacheEntry(eDVBService::cAC3DELAY);
! 							pcm_delay = origService->getCacheEntry(eDVBService::cPCMDELAY);
! 						}
! 					}
! 				}
! 			}
! 		}
! 
! 		setAC3Delay(ac3_delay == -1 ? 0 : ac3_delay);
! 		setPCMDelay(pcm_delay == -1 ? 0 : pcm_delay);
! 
! 		m_decoder->setVideoPID(vpid, vpidtype);
! 		selectAudioStream();
! 
! 		if (!(m_is_pvr || m_timeshift_active || !m_is_primary))
! 			m_decoder->setSyncPCR(pcrpid);
! 		else
! 			m_decoder->setSyncPCR(-1);
! 
! 		if (m_is_primary && m_decode_demux && !m_is_pvr)
! 		{
! 			m_decoder->setTextPID(tpid);
! 			m_teletext_parser->start(program.textPid);
! 		}
! 
! 		if (vpid > 0 && vpid < 0x2000)
! 			;
! 		else
! 		{
! 			std::string radio_pic;
! 			if (!ePythonConfigQuery::getConfigValue("config.misc.radiopic", radio_pic))
! 				m_decoder->setRadioPic(radio_pic);
! 		}
! 
! 		printf("mustPlay %d\n", mustPlay);
! 		if (mustPlay)
! 			m_decoder->play();
! 		else
! 			m_decoder->set();
! 
! 		m_decoder->setAudioChannel(achannel);
! 
! 		/* don't worry about non-existing services, nor pvr services */
! 		if (m_dvb_service)
! 		{
! 				/* (audio pid will be set in selectAudioTrack */
! 			m_dvb_service->setCacheEntry(eDVBService::cVPID, vpid);
! 			m_dvb_service->setCacheEntry(eDVBService::cVTYPE, vpidtype == eDVBVideo::MPEG2 ? -1 : vpidtype);
! 			m_dvb_service->setCacheEntry(eDVBService::cPCRPID, pcrpid);
! 			m_dvb_service->setCacheEntry(eDVBService::cTPID, tpid);
! 		}
! 		if (!sendSeekableStateChanged && (m_decoder->getVideoProgressive() != -1) != wasSeekable)
! 			sendSeekableStateChanged = true;
! 	}
! 	m_have_video_pid = (vpid > 0 && vpid < 0x2000);
! 
! 	if (sendSeekableStateChanged)
! 		m_event((iPlayableService*)this, evSeekableStatusChanged);
! }
! 
! void eDVBServicePlay::loadCuesheet()
! {
! 	std::string filename = m_reference.path + ".cuts";
! 	
! 	m_cue_entries.clear();
! 
! 	FILE *f = fopen(filename.c_str(), "rb");
! 
! 	if (f)
! 	{
! 		eDebug("loading cuts..");
! 		while (1)
! 		{
! 			unsigned long long where;
! 			unsigned int what;
! 			
! 			if (!fread(&where, sizeof(where), 1, f))
! 				break;
! 			if (!fread(&what, sizeof(what), 1, f))
! 				break;
! 			
! #if BYTE_ORDER == LITTLE_ENDIAN
! 			where = bswap_64(where);
! #endif
! 			what = ntohl(what);
! 			
! 			if (what > 3)
! 				break;
! 			
! 			m_cue_entries.insert(cueEntry(where, what));
! 		}
! 		fclose(f);
! 		eDebug("%zd entries", m_cue_entries.size());
! 	} else
! 		eDebug("cutfile not found!");
! 	
! 	m_cuesheet_changed = 0;
! 	cutlistToCuesheet();
! 	m_event((iPlayableService*)this, evCuesheetChanged);
! }
! 
! void eDVBServicePlay::saveCuesheet()
! {
! 	std::string filename = m_reference.path + ".cuts";
! 	
! 	FILE *f = fopen(filename.c_str(), "wb");
! 
! 	if (f)
! 	{
! 		unsigned long long where;
! 		int what;
! 
! 		for (std::multiset<cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end(); ++i)
! 		{
! #if BYTE_ORDER == BIG_ENDIAN
! 			where = i->where;
! #else
! 			where = bswap_64(i->where);
! #endif
! 			what = htonl(i->what);
! 			fwrite(&where, sizeof(where), 1, f);
! 			fwrite(&what, sizeof(what), 1, f);
! 			
! 		}
! 		fclose(f);
! 	}
! 	
! 	m_cuesheet_changed = 0;
! }
! 
! void eDVBServicePlay::cutlistToCuesheet()
! {
! 	if (!m_cue)
! 	{
! 		eDebug("no cue sheet");
! 		return;
! 	}	
! 	m_cue->clear();
! 	
! 	if (!m_cutlist_enabled)
! 	{
! 		m_cue->commitSpans();
! 		eDebug("cutlists were disabled");
! 		return;
! 	}
! 
! 	pts_t in = 0, out = 0, length = 0;
! 	
! 	getLength(length);
! 		
! 	std::multiset<cueEntry>::iterator i(m_cue_entries.begin());
! 	
! 	int have_any_span = 0;
! 	
! 	while (1)
! 	{
! 		if (i == m_cue_entries.end())
! 		{
! 			if (!have_any_span && !in)
! 				break;
! 			out = length;
! 		} else {
! 			if (i->what == 0) /* in */
! 			{
! 				in = i++->where;
! 				continue;
! 			} else if (i->what == 1) /* out */
! 				out = i++->where;
! 			else /* mark (2) or last play position (3) */
! 			{
! 				i++;
! 				continue;
! 			}
! 		}
! 		
! 		if (in < 0)
! 			in = 0;
! 		if (out < 0)
! 			out = 0;
! 		if (in > length)
! 			in = length;
! 		if (out > length)
! 			out = length;
! 		
! 		if (in < out)
! 		{
! 			have_any_span = 1;
! 			m_cue->addSourceSpan(in, out);
! 			in = out = 0;
! 		}
! 		
! 		in = length;
! 		
! 		if (i == m_cue_entries.end())
! 			break;
! 	}
! 	m_cue->commitSpans();
! }
! 
! RESULT eDVBServicePlay::enableSubtitles(eWidget *parent, ePyObject tuple)
! {
! 	if (m_subtitle_widget)
! 		disableSubtitles(parent);
! 
! 	ePyObject entry;
! 	int tuplesize = PyTuple_Size(tuple);
! 	int type = 0;
! 
! 	if (!PyTuple_Check(tuple))
! 		goto error_out;
! 
! 	if (tuplesize < 1)
! 		goto error_out;
! 
! 	entry = PyTuple_GET_ITEM(tuple, 0);
! 
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 
! 	type = PyInt_AsLong(entry);
! 
! 	if (type == 1)  // teletext subtitles
! 	{
! 		int page, magazine, pid;
! 		if (tuplesize < 4)
! 			goto error_out;
! 
! 		if (!m_teletext_parser)
! 		{
! 			eDebug("enable teletext subtitles.. no parser !!!");
! 			return -1;
! 		}
! 
! 		entry = PyTuple_GET_ITEM(tuple, 1);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		pid = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 2);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		page = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 3);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		magazine = PyInt_AsLong(entry);
! 
! 		m_subtitle_widget = new eSubtitleWidget(parent);
! 		m_subtitle_widget->resize(parent->size()); /* full size */
! 		m_teletext_parser->setPageAndMagazine(page, magazine);
! 		if (m_dvb_service)
! 			m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE,((pid&0xFFFF)<<16)|((page&0xFF)<<8)|(magazine&0xFF));
! 	}
! 	else if (type == 0)
! 	{
! 		int pid = 0, composition_page_id = 0, ancillary_page_id = 0;
! 		if (!m_subtitle_parser)
! 		{
! 			eDebug("enable dvb subtitles.. no parser !!!");
! 			return -1;
! 		}
! 		if (tuplesize < 4)
! 			goto error_out;
! 
! 		entry = PyTuple_GET_ITEM(tuple, 1);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		pid = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 2);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		composition_page_id = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 3);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		ancillary_page_id = PyInt_AsLong(entry);
! 
! 		m_subtitle_widget = new eSubtitleWidget(parent);
! 		m_subtitle_widget->resize(parent->size()); /* full size */
! 		m_subtitle_parser->start(pid, composition_page_id, ancillary_page_id);
! 		if (m_dvb_service)
! 			m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE, ((pid&0xFFFF)<<16)|((composition_page_id&0xFF)<<8)|(ancillary_page_id&0xFF));
! 	}
! 	else
! 		goto error_out;
! 	return 0;
! error_out:
! 	eDebug("enableSubtitles needs a tuple as 2nd argument!\n"
! 		"for teletext subtitles (0, pid, teletext_page, teletext_magazine)\n"
! 		"for dvb subtitles (1, pid, composition_page_id, ancillary_page_id)");
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::disableSubtitles(eWidget *parent)
! {
! 	delete m_subtitle_widget;
! 	m_subtitle_widget = 0;
! 	if (m_subtitle_parser)
! 	{
! 		m_subtitle_parser->stop();
! 		m_dvb_subtitle_pages.clear();
! 	}
! 	if (m_teletext_parser)
! 	{
! 		m_teletext_parser->setPageAndMagazine(-1, -1);
! 		m_subtitle_pages.clear();
! 	}
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE, -1);
! 	return 0;
! }
! 
! PyObject *eDVBServicePlay::getCachedSubtitle()
! {
! 	if (m_dvb_service)
! 	{
! 		int tmp = m_dvb_service->getCacheEntry(eDVBService::cSUBTITLE);
! 		if (tmp != -1)
! 		{
! 			unsigned int data = (unsigned int)tmp;
! 			int pid = (data&0xFFFF0000)>>16;
! 			ePyObject tuple = PyTuple_New(4);
! 			eDVBServicePMTHandler::program program;
! 			eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 			if (!h.getProgramInfo(program))
! 			{
! 				if (program.textPid==pid) // teletext
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1)); // type teletext
! 				else
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0)); // type dvb
! 				PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(pid)); // pid
! 				PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong((data&0xFF00)>>8)); // composition_page / page
! 				PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(data&0xFF)); // ancillary_page / magazine
! 				return tuple;
! 			}
! 		}
! 	}
! 	Py_RETURN_NONE;
! }
! 
! PyObject *eDVBServicePlay::getSubtitleList()
! {
! 	if (!m_teletext_parser)
! 		Py_RETURN_NONE;
! 	
! 	ePyObject l = PyList_New(0);
! 	std::set<int> added_ttx_pages;
! 
! 	std::set<eDVBServicePMTHandler::subtitleStream> &subs =
! 		m_teletext_parser->m_found_subtitle_pages;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	eDVBServicePMTHandler::program program;
! 	if (h.getProgramInfo(program))
! 		eDebug("getting program info failed.");
! 	else
! 	{
! 		for (std::vector<eDVBServicePMTHandler::subtitleStream>::iterator it(program.subtitleStreams.begin());
! 			it != program.subtitleStreams.end(); ++it)
! 		{
! 			switch(it->subtitling_type)
! 			{
! 				case 0x01: // ebu teletext subtitles
! 				{
! 					int page_number = it->teletext_page_number & 0xFF;
! 					int magazine_number = it->teletext_magazine_number & 7;
! 					int hash = magazine_number << 8 | page_number;
! 					if (added_ttx_pages.find(hash) == added_ttx_pages.end())
! 					{
! 						ePyObject tuple = PyTuple_New(5);
! 						PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1));
! 						PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 						PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(page_number));
! 						PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(magazine_number));
! 						PyTuple_SET_ITEM(tuple, 4, PyString_FromString(it->language_code.c_str()));
! 						PyList_Append(l, tuple);
! 						Py_DECREF(tuple);
! 						added_ttx_pages.insert(hash);
! 					}
! 					break;
! 				}
! 				case 0x10 ... 0x13:
! 				case 0x20 ... 0x23: // dvb subtitles
! 				{
! 					ePyObject tuple = PyTuple_New(5);
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0));
! 					PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 					PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(it->composition_page_id));
! 					PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(it->ancillary_page_id));
! 					PyTuple_SET_ITEM(tuple, 4, PyString_FromString(it->language_code.c_str()));
! 					PyList_Insert(l, 0, tuple);
! 					Py_DECREF(tuple);
! 					break;
! 				}
! 			}
! 		}
! 	}
! 
! 	for (std::set<eDVBServicePMTHandler::subtitleStream>::iterator it(subs.begin());
! 		it != subs.end(); ++it)
! 	{
! 		int page_number = it->teletext_page_number & 0xFF;
! 		int magazine_number = it->teletext_magazine_number & 7;
! 		int hash = magazine_number << 8 | page_number;
! 		if (added_ttx_pages.find(hash) == added_ttx_pages.end())
! 		{
! 			ePyObject tuple = PyTuple_New(5);
! 			PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1));
! 			PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 			PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(page_number));
! 			PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(magazine_number));
! 			PyTuple_SET_ITEM(tuple, 4, PyString_FromString("und"));  // undetermined
! 			PyList_Append(l, tuple);
! 			Py_DECREF(tuple);
! 		}
! 	}
! 
! 	return l;
! }
! 
! void eDVBServicePlay::newSubtitlePage(const eDVBTeletextSubtitlePage &page)
! {
! 	if (m_subtitle_widget)
! 	{
! 		pts_t pos = 0;
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 		eDebug("got new subtitle page %lld %lld %d", pos, page.m_pts, page.m_have_pts);
! 		m_subtitle_pages.push_back(page);
! 		checkSubtitleTiming();
! 	}
! }
! 
! void eDVBServicePlay::checkSubtitleTiming()
! {
! 	eDebug("checkSubtitleTiming");
! 	if (!m_subtitle_widget)
! 		return;
! 	while (1)
! 	{
! 		enum { TELETEXT, DVB } type;
! 		eDVBTeletextSubtitlePage page;
! 		eDVBSubtitlePage dvb_page;
! 		pts_t show_time;
! 		if (!m_subtitle_pages.empty())
! 		{
! 			page = m_subtitle_pages.front();
! 			type = TELETEXT;
! 			show_time = page.m_pts;
! 		}
! 		else if (!m_dvb_subtitle_pages.empty())
! 		{
! 			dvb_page = m_dvb_subtitle_pages.front();
! 			type = DVB;
! 			show_time = dvb_page.m_show_time;
! 		}
! 		else
! 			return;
! 	
! 		pts_t pos = 0;
! 	
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 
! 		eDebug("%lld %lld", pos, show_time);
! 		int diff = show_time - pos;
! 		if (type == TELETEXT && !page.m_have_pts)
! 		{
! 			eDebug("ttx subtitle page without pts... immediate show");
! 			diff = 0;
! 		}
! 		if (diff < 0)
! 		{
! 			eDebug("[late (%d ms)]", -diff / 90);
! 			diff = 0;
! 		}
! 		if (abs(diff) > 1800000)
! 		{
! 			eDebug("[invalid]... immediate show!");
! 			diff = 0;
! 		}
! 		if ((diff/90)<20)
! 		{
! 			if (type == TELETEXT)
! 			{
! 				eDebug("display teletext subtitle page %lld", show_time);
! 				m_subtitle_widget->setPage(page);
! 				m_subtitle_pages.pop_front();
! 			}
! 			else
! 			{
! 				eDebug("display dvb subtitle Page %lld", show_time);
! 				m_subtitle_widget->setPage(dvb_page);
! 				m_dvb_subtitle_pages.pop_front();
! 			}
! 		} else
! 		{
! 			eDebug("start subtitle delay %d", diff / 90);
! 			m_subtitle_sync_timer->start(diff / 90, 1);
! 			break;
! 		}
! 	}
! }
! 
! void eDVBServicePlay::newDVBSubtitlePage(const eDVBSubtitlePage &p)
! {
! 	if (m_subtitle_widget)
! 	{
! 		pts_t pos = 0;
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 		eDebug("got new subtitle page %lld %lld", pos, p.m_show_time);
! 		m_dvb_subtitle_pages.push_back(p);
! 		checkSubtitleTiming();
! 	}
! }
! 
! int eDVBServicePlay::getAC3Delay()
! {
! 	if (m_dvb_service)
! 		return m_dvb_service->getCacheEntry(eDVBService::cAC3DELAY);
! 	else if (m_decoder)
! 		return m_decoder->getAC3Delay();
! 	else
! 		return 0;
! }
! 
! int eDVBServicePlay::getPCMDelay()
! {
! 	if (m_dvb_service)
! 		return m_dvb_service->getCacheEntry(eDVBService::cPCMDELAY);
! 	else if (m_decoder)
! 		return m_decoder->getPCMDelay();
! 	else
! 		return 0;
! }
! 
! void eDVBServicePlay::setAC3Delay(int delay)
! {
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cAC3DELAY, delay ? delay : -1);
! 	if (m_decoder) {
! 		std::string config_delay;
! 		int config_delay_int = 0;
! 		if(ePythonConfigQuery::getConfigValue("config.av.generalAC3delay", config_delay) == 0)
! 			config_delay_int = atoi(config_delay.c_str());
! 		m_decoder->setAC3Delay(delay + config_delay_int);
! 	}
! }
! 
! void eDVBServicePlay::setPCMDelay(int delay)
! {
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cPCMDELAY, delay ? delay : -1);
! 	if (m_decoder) {
! 		std::string config_delay;
! 		int config_delay_int = 0;
! 		if(ePythonConfigQuery::getConfigValue("config.av.generalPCMdelay", config_delay) == 0)
! 			config_delay_int = atoi(config_delay.c_str());
! 		else
! 			config_delay_int = 0;
! 		m_decoder->setPCMDelay(delay + config_delay_int);
! 	}
! }
! 
! void eDVBServicePlay::video_event(struct iTSMPEGDecoder::videoEvent event)
! {
! 	switch(event.type) {
! 		case iTSMPEGDecoder::videoEvent::eventSizeChanged:
! 			m_event((iPlayableService*)this, evVideoSizeChanged);
! 			break;
! 		case iTSMPEGDecoder::videoEvent::eventFrameRateChanged:
! 			m_event((iPlayableService*)this, evVideoFramerateChanged);
! 			break;
! 		case iTSMPEGDecoder::videoEvent::eventProgressiveChanged:
! 			m_event((iPlayableService*)this, evVideoProgressiveChanged);
! 			break;
! 		default:
! 			break;
! 	}
! }
! 
! RESULT eDVBServicePlay::stream(ePtr<iStreamableService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! PyObject *eDVBServicePlay::getStreamingData()
! {
! 	eDVBServicePMTHandler::program program;
! 	if (m_service_handler.getProgramInfo(program))
! 	{
! 		Py_RETURN_NONE;
! 	}
! 
! 	ePyObject r = program.createPythonObject();
! 	ePtr<iDVBDemux> demux;
! 	if (!m_service_handler.getDataDemux(demux))
! 	{
! 		uint8_t demux_id;
! 		if (!demux->getCADemuxID(demux_id))
! 			PutToDict(r, "demux", demux_id);
! 	}
! 
! 	return r;
! }
! 
! 
! DEFINE_REF(eDVBServicePlay)
! 
! PyObject *eDVBService::getInfoObject(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sTransponderData:
! 		return eStaticServiceDVBInformation().getInfoObject(ref, w);
! 	default:
! 		break;
! 	}
! 	return iStaticServiceInformation::getInfoObject(ref, w);
! }
! 
! eAutoInitPtr<eServiceFactoryDVB> init_eServiceFactoryDVB(eAutoInitNumbers::service+1, "eServiceFactoryDVB");
--- 1,3187 ----
! #include <lib/base/eerror.h>
! #include <lib/base/object.h>
! #include <string>
! #include <lib/service/servicedvb.h>
! #include <lib/service/service.h>
! #include <lib/base/estring.h>
! #include <lib/base/init_num.h>
! #include <lib/base/init.h>
! #include <lib/dvb/dvb.h>
! #include <lib/dvb/db.h>
! #include <lib/dvb/decoder.h>
! 
! #include <lib/components/file_eraser.h>
! #include <lib/service/servicedvbrecord.h>
! #include <lib/service/event.h>
! #include <lib/dvb/metaparser.h>
! #include <lib/dvb/tstools.h>
! #include <lib/python/python.h>
! #include <lib/base/nconfig.h> // access to python config
! 
! 		/* for subtitles */
! #include <lib/gui/esubtitle.h>
! 
! #include <sys/vfs.h>
! #include <sys/stat.h>
! 
! #include <byteswap.h>
! #include <netinet/in.h>
! 
! #ifndef BYTE_ORDER
! #error no byte order defined!
! #endif
! 
! class eStaticServiceDVBInformation: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceDVBInformation);
! public:
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore);
! 	PyObject *getInfoObject(const eServiceReference &ref, int);
! };
! 
! DEFINE_REF(eStaticServiceDVBInformation);
! 
! RESULT eStaticServiceDVBInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	eServiceReferenceDVB &service = (eServiceReferenceDVB&)ref;
! 	if ( !ref.name.empty() )
! 	{
! 		if (service.getParentTransportStreamID().get()) // linkage subservice
! 		{
! 			ePtr<iServiceHandler> service_center;
! 			if (!eServiceCenter::getInstance(service_center))
! 			{
! 				eServiceReferenceDVB parent = service;
! 				parent.setTransportStreamID( service.getParentTransportStreamID() );
! 				parent.setServiceID( service.getParentServiceID() );
! 				parent.setParentTransportStreamID(eTransportStreamID(0));
! 				parent.setParentServiceID(eServiceID(0));
! 				parent.name="";
! 				ePtr<iStaticServiceInformation> service_info;
! 				if (!service_center->info(parent, service_info))
! 				{
! 					if (!service_info->getName(parent, name))
! 						name=buildShortName(name) + " - ";
! 				}
! 			}
! 		}
! 		else
! 			name="";
! 		name += ref.name;
! 		return 0;
! 	}
! 	else
! 		return -1;
! }
! 
! int eStaticServiceDVBInformation::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! int eStaticServiceDVBInformation::isPlayable(const eServiceReference &ref, const eServiceReference &ignore)
! {
! 	ePtr<eDVBResourceManager> res_mgr;
! 	if ( eDVBResourceManager::getInstance( res_mgr ) )
! 		eDebug("isPlayable... no res manager!!");
! 	else
! 	{
! 		eDVBChannelID chid, chid_ignore;
! 		((const eServiceReferenceDVB&)ref).getChannelID(chid);
! 		((const eServiceReferenceDVB&)ignore).getChannelID(chid_ignore);
! 		return res_mgr->canAllocateChannel(chid, chid_ignore);
! 	}
! 	return false;
! }
! 
! extern void PutToDict(ePyObject &dict, const char*key, long value);  // defined in dvb/frontend.cpp
! extern void PutSatelliteDataToDict(ePyObject &dict, eDVBFrontendParametersSatellite &feparm); // defined in dvb/frontend.cpp
! extern void PutTerrestrialDataToDict(ePyObject &dict, eDVBFrontendParametersTerrestrial &feparm); // defined in dvb/frontend.cpp
! extern void PutCableDataToDict(ePyObject &dict, eDVBFrontendParametersCable &feparm); // defined in dvb/frontend.cpp
! 
! PyObject *eStaticServiceDVBInformation::getInfoObject(const eServiceReference &r, int what)
! {
! 	if (r.type == eServiceReference::idDVB)
! 	{
! 		const eServiceReferenceDVB &ref = (const eServiceReferenceDVB&)r;
! 		switch(what)
! 		{
! 			case iServiceInformation::sTransponderData:
! 			{
! 				ePtr<eDVBResourceManager> res;
! 				if (!eDVBResourceManager::getInstance(res))
! 				{
! 					ePtr<iDVBChannelList> db;
! 					if (!res->getChannelList(db))
! 					{
! 						eDVBChannelID chid;
! 						ref.getChannelID(chid);
! 						ePtr<iDVBFrontendParameters> feparm;
! 						if (!db->getChannelFrontendData(chid, feparm))
! 						{
! 							int system;
! 							if (!feparm->getSystem(system))
! 							{
! 								ePyObject dict = PyDict_New();
! 								switch(system)
! 								{
! 									case iDVBFrontend::feSatellite:
! 									{
! 										eDVBFrontendParametersSatellite s;
! 										feparm->getDVBS(s);
! 										PutSatelliteDataToDict(dict, s);
! 										break;
! 									}
! 									case iDVBFrontend::feTerrestrial:
! 									{
! 										eDVBFrontendParametersTerrestrial t;
! 										feparm->getDVBT(t);
! 										PutTerrestrialDataToDict(dict, t);
! 										break;
! 									}
! 									case iDVBFrontend::feCable:
! 									{
! 										eDVBFrontendParametersCable c;
! 										feparm->getDVBC(c);
! 										PutCableDataToDict(dict, c);
! 										break;
! 									}
! 									default:
! 										eDebug("unknown frontend type %d", system);
! 										Py_DECREF(dict);
! 										break;
! 								}
! 								return dict;
! 							}
! 						}
! 					}
! 				}
! 			}
! 		}
! 	}
! 	Py_RETURN_NONE;
! }
! 
! DEFINE_REF(eStaticServiceDVBBouquetInformation);
! 
! RESULT eStaticServiceDVBBouquetInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	ePtr<iDVBChannelList> db;
! 	ePtr<eDVBResourceManager> res;
! 
! 	int err;
! 	if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. no resource manager!");
! 		return err;
! 	}
! 	if ((err = res->getChannelList(db)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. no channel list!");
! 		return err;
! 	}
! 
! 	eBouquet *bouquet=0;
! 	if ((err = db->getBouquet(ref, bouquet)) != 0)
! 	{
! 		eDebug("eStaticServiceDVBBouquetInformation::getName failed.. getBouquet failed!");
! 		return -1;
! 	}
! 
! 	if ( bouquet && bouquet->m_bouquet_name.length() )
! 	{
! 		name = bouquet->m_bouquet_name;
! 		return 0;
! 	}
! 	else
! 		return -1;
! }
! 
! int eStaticServiceDVBBouquetInformation::isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate)
! {
! 	if (ref.flags & eServiceReference::isGroup)
! 	{
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> res;
! 
! 		if (eDVBResourceManager::getInstance(res))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. no resource manager!");
! 			return 0;
! 		}
! 
! 		if (res->getChannelList(db))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. no channel list!");
! 			return 0;
! 		}
! 
! 		eBouquet *bouquet=0;
! 		if (db->getBouquet(ref, bouquet))
! 		{
! 			eDebug("eStaticServiceDVBBouquetInformation::isPlayable failed.. getBouquet failed!");
! 			return 0;
! 		}
! 
! 		int prio_order = eDVBFrontend::getTypePriorityOrder();
! 		int cur=0;
! 		eDVBChannelID chid, chid_ignore;
! 		((const eServiceReferenceDVB&)ignore).getChannelID(chid_ignore);
! 		for (std::list<eServiceReference>::iterator it(bouquet->m_services.begin()); it != bouquet->m_services.end(); ++it)
! 		{
! 			static unsigned char prio_map[6][3] = {
! 				{ 3, 2, 1 }, // -S -C -T
! 				{ 3, 1, 2 }, // -S -T -C
! 				{ 2, 3, 1 }, // -C -S -T
! 				{ 1, 3, 2 }, // -C -T -S
! 				{ 1, 2, 3 }, // -T -C -S
! 				{ 2, 1, 3 }  // -T -S -C
! 			};
! 			((const eServiceReferenceDVB&)*it).getChannelID(chid);
! 			int tmp=res->canAllocateChannel(chid, chid_ignore, simulate);
! 			switch(tmp)
! 			{
! 				case 0:
! 					break;
! 				case 30000: // cached DVB-T channel
! 				case 1: // DVB-T frontend
! 					tmp = prio_map[prio_order][2];
! 					break;
! 				case 40000: // cached DVB-C channel
! 				case 2:
! 					tmp = prio_map[prio_order][1];
! 					break;
! 				default: // DVB-S
! 					tmp = prio_map[prio_order][0];
! 					break;
! 			}
! 			if (tmp > cur)
! 			{
! 				m_playable_service = *it;
! 				cur = tmp;
! 			}
! 		}
! 		if (cur)
! 			return cur;
! 	}
! 	m_playable_service = eServiceReference();
! 	return 0;
! }
! 
! int eStaticServiceDVBBouquetInformation::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! #include <lib/dvb/epgcache.h>
! 
! RESULT eStaticServiceDVBBouquetInformation::getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &ptr, time_t start_time)
! {
! 	return eEPGCache::getInstance()->lookupEventTime(ref, start_time, ptr);
! }
! 
! class eStaticServiceDVBPVRInformation: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceDVBPVRInformation);
! 	eServiceReference m_ref;
! 	eDVBMetaParser m_parser;
! public:
! 	eStaticServiceDVBPVRInformation(const eServiceReference &ref);
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	RESULT getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &SWIG_OUTPUT, time_t start_time);
! 	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore) { return 1; }
! 	int getInfo(const eServiceReference &ref, int w);
! 	std::string getInfoString(const eServiceReference &ref,int w);
! 	PyObject *getInfoObject(const eServiceReference &r, int what);
! };
! 
! DEFINE_REF(eStaticServiceDVBPVRInformation);
! 
! eStaticServiceDVBPVRInformation::eStaticServiceDVBPVRInformation(const eServiceReference &ref)
! {
! 	m_ref = ref;
! 	m_parser.parseFile(ref.path);
! }
! 
! RESULT eStaticServiceDVBPVRInformation::getName(const eServiceReference &ref, std::string &name)
! {
! 	ASSERT(ref == m_ref);
! 	if (!ref.name.empty())
! 		name = ref.name;
! 	else if (!m_parser.m_name.empty())
! 		name = m_parser.m_name;
! 	else
! 	{
! 		name = ref.path;
! 		size_t n = name.rfind('/');
! 		if (n != std::string::npos)
! 			name = name.substr(n + 1);
! 	}
! 	return 0;
! }
! 
! int eStaticServiceDVBPVRInformation::getLength(const eServiceReference &ref)
! {
! 	ASSERT(ref == m_ref);
! 	
! 	eDVBTSTools tstools;
! 	
! 	struct stat s;
! 	stat(ref.path.c_str(), &s);
! 
! 	if (tstools.openFile(ref.path.c_str(), 1))
! 		return 0;
! 
! 			/* check if cached data is still valid */
! 	if (m_parser.m_data_ok && (s.st_size == m_parser.m_filesize) && (m_parser.m_length))
! 		return m_parser.m_length / 90000;
! 
! 			/* open again, this time with stream info */
! 	if (tstools.openFile(ref.path.c_str()))
! 		return 0;
! 
! 			/* otherwise, re-calc length and update meta file */
! 	pts_t len;
! 	if (tstools.calcLen(len))
! 		return 0;
! 
!  	m_parser.m_length = len;
! 	m_parser.m_filesize = s.st_size;
! 	m_parser.updateMeta(ref.path);
! 	return m_parser.m_length / 90000;
! }
! 
! int eStaticServiceDVBPVRInformation::getInfo(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sDescription:
! 		return iServiceInformation::resIsString;
! 	case iServiceInformation::sServiceref:
! 		return iServiceInformation::resIsString;
! 	case iServiceInformation::sFileSize:
! 		return m_parser.m_filesize;
! 	case iServiceInformation::sTimeCreate:
! 		if (m_parser.m_time_create)
! 			return m_parser.m_time_create;
! 		else
! 			return iServiceInformation::resNA;
! 	default:
! 		return iServiceInformation::resNA;
! 	}
! }
! 
! std::string eStaticServiceDVBPVRInformation::getInfoString(const eServiceReference &ref,int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sDescription:
! 		return m_parser.m_description;
! 	case iServiceInformation::sServiceref:
! 		return m_parser.m_ref.toString();
! 	case iServiceInformation::sTags:
! 		return m_parser.m_tags;
! 	default:
! 		return "";
! 	}
! }
! 
! PyObject *eStaticServiceDVBPVRInformation::getInfoObject(const eServiceReference &r, int what)
! {
! 	switch (what)
! 	{
! 	case iServiceInformation::sFileSize:
! 		return PyLong_FromLongLong(m_parser.m_filesize);
! 	default:
! 		Py_RETURN_NONE;
! 	}
! }
! 
! RESULT eStaticServiceDVBPVRInformation::getEvent(const eServiceReference &ref, ePtr<eServiceEvent> &evt, time_t start_time)
! {
! 	if (!ref.path.empty())
! 	{
! 		ePtr<eServiceEvent> event = new eServiceEvent;
! 		std::string filename = ref.path;
! 		filename.erase(filename.length()-2, 2);
! 		filename+="eit";
! 		if (!event->parseFrom(filename, (m_parser.m_ref.getTransportStreamID().get()<<16)|m_parser.m_ref.getOriginalNetworkID().get()))
! 		{
! 			evt = event;
! 			return 0;
! 		}
! 	}
! 	evt = 0;
! 	return -1;
! }
! 
! class eDVBPVRServiceOfflineOperations: public iServiceOfflineOperations
! {
! 	DECLARE_REF(eDVBPVRServiceOfflineOperations);
! 	eServiceReferenceDVB m_ref;
! public:
! 	eDVBPVRServiceOfflineOperations(const eServiceReference &ref);
! 	
! 	RESULT deleteFromDisk(int simulate);
! 	RESULT getListOfFilenames(std::list<std::string> &);
! 	RESULT reindex();
! };
! 
! DEFINE_REF(eDVBPVRServiceOfflineOperations);
! 
! eDVBPVRServiceOfflineOperations::eDVBPVRServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReferenceDVB&)ref)
! {
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::deleteFromDisk(int simulate)
! {
! 	if (simulate)
! 		return 0;
! 	else
! 	{
! 		std::list<std::string> res;
! 		if (getListOfFilenames(res))
! 			return -1;
! 		
! 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
! 		if (!eraser)
! 			eDebug("FATAL !! can't get background file eraser");
! 		
! 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
! 		{
! 			eDebug("Removing %s...", i->c_str());
! 			if (eraser)
! 				eraser->erase(i->c_str());
! 			else
! 				::unlink(i->c_str());
! 		}
! 		
! 		return 0;
! 	}
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
! {
! 	res.clear();
! 	res.push_back(m_ref.path);
! 
! // handling for old splitted recordings (enigma 1)
! 	char buf[255];
! 	int slice=1;
! 	while(true)
! 	{
! 		snprintf(buf, 255, "%s.%03d", m_ref.path.c_str(), slice++);
! 		struct stat s;
! 		if (stat(buf, &s) < 0)
! 			break;
! 		res.push_back(buf);
! 	}	
! 
! 	res.push_back(m_ref.path + ".meta");
! 	res.push_back(m_ref.path + ".ap");
! 	res.push_back(m_ref.path + ".sc");
! 	res.push_back(m_ref.path + ".cuts");
! 	std::string tmp = m_ref.path;
! 	tmp.erase(m_ref.path.length()-3);
! 	res.push_back(tmp + ".eit");
! 	return 0;
! }
! 
! RESULT eDVBPVRServiceOfflineOperations::reindex()
! {
! 	const char *filename = m_ref.path.c_str();
! 	eDebug("reindexing %s...", filename);
! 
! 	eMPEGStreamInformation info;
! 	eMPEGStreamParserTS parser(info);
! 	
! 	info.startSave(filename);
! 	
! 	eRawFile f;
! 	
! 	int err = f.open(m_ref.path.c_str(), 0);
! 	if (err < 0)
! 		return -1;
! 
! 	off_t offset = 0;
! 	off_t length = f.length();
! 	unsigned char buffer[188*256*4];
! 	while (1)
! 	{
! 		eDebug("at %08llx / %08llx (%d %%)", offset, length, (int)(offset * 100 / length));
! 		int r = f.read(offset, buffer, sizeof(buffer));
! 		if (!r)
! 			break;
! 		if (r < 0)
! 			return r;
! 		offset += r;
! 		parser.parseData(offset, buffer, r);
! 	}
! 	
! 	info.stopSave();
! 	f.close();
! 	
! 	return 0;
! }
! 
! DEFINE_REF(eServiceFactoryDVB)
! 
! eServiceFactoryDVB::eServiceFactoryDVB()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 	{
! 		std::list<std::string> extensions;
! 		extensions.push_back("ts");
! 		extensions.push_back("trp");
! 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
! 	}
! 
! 	m_StaticServiceDVBInfo = new eStaticServiceDVBInformation;
! 	m_StaticServiceDVBBouquetInfo = new eStaticServiceDVBBouquetInformation;
! }
! 
! eServiceFactoryDVB::~eServiceFactoryDVB()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 		sc->removeServiceFactory(eServiceFactoryDVB::id);
! }
! 
! DEFINE_REF(eDVBServiceList);
! 
! eDVBServiceList::eDVBServiceList(const eServiceReference &parent): m_parent(parent)
! {
! }
! 
! eDVBServiceList::~eDVBServiceList()
! {
! }
! 
! RESULT eDVBServiceList::startQuery()
! {
! 	ePtr<iDVBChannelList> db;
! 	ePtr<eDVBResourceManager> res;
! 	
! 	int err;
! 	if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 	{
! 		eDebug("no resource manager");
! 		return err;
! 	}
! 	if ((err = res->getChannelList(db)) != 0)
! 	{
! 		eDebug("no channel list");
! 		return err;
! 	}
! 	
! 	ePtr<eDVBChannelQuery> q;
! 	
! 	if (!m_parent.path.empty())
! 	{
! 		eDVBChannelQuery::compile(q, m_parent.path);
! 		if (!q)
! 		{
! 			eDebug("compile query failed");
! 			return err;
! 		}
! 	}
! 	
! 	if ((err = db->startQuery(m_query, q, m_parent)) != 0)
! 	{
! 		eDebug("startQuery failed");
! 		return err;
! 	}
! 
! 	return 0;
! }
! 
! RESULT eDVBServiceList::getContent(std::list<eServiceReference> &list, bool sorted)
! {
! 	eServiceReferenceDVB ref;
! 	
! 	if (!m_query)
! 		return -1;
! 
! 	while (!m_query->getNextResult(ref))
! 		list.push_back(ref);
! 
! 	if (sorted)
! 		list.sort(iListableServiceCompare(this));
! 
! 	return 0;
! }
! 
! //   The first argument of this function is a format string to specify the order and
! //   the content of the returned list
! //   useable format options are
! //   R = Service Reference (as swig object .. this is very slow)
! //   S = Service Reference (as python string object .. same as ref.toString())
! //   C = Service Reference (as python string object .. same as ref.toCompareString())
! //   N = Service Name (as python string object)
! //   n = Short Service Name (short name brakets used) (as python string object)
! //   when exactly one return value per service is selected in the format string,
! //   then each value is directly a list entry
! //   when more than one value is returned per service, then the list is a list of
! //   python tuples
! //   unknown format string chars are returned as python None values !
! PyObject *eDVBServiceList::getContent(const char* format, bool sorted)
! {
! 	ePyObject ret;
! 	std::list<eServiceReference> tmplist;
! 	int retcount=1;
! 
! 	if (!format || !(retcount=strlen(format)))
! 		format = "R"; // just return service reference swig object ...
! 
! 	if (!getContent(tmplist, sorted))
! 	{
! 		int services=tmplist.size();
! 		ePtr<iStaticServiceInformation> sptr;
! 		eServiceCenterPtr service_center;
! 
! 		if (strchr(format, 'N') || strchr(format, 'n'))
! 			eServiceCenter::getPrivInstance(service_center);
! 
! 		ret = PyList_New(services);
! 		std::list<eServiceReference>::iterator it(tmplist.begin());
! 
! 		for (int cnt=0; cnt < services; ++cnt)
! 		{
! 			eServiceReference &ref=*it++;
! 			ePyObject tuple = retcount > 1 ? PyTuple_New(retcount) : ePyObject();
! 			for (int i=0; i < retcount; ++i)
! 			{
! 				ePyObject tmp;
! 				switch(format[i])
! 				{
! 				case 'R':  // service reference (swig)object
! 					tmp = NEW_eServiceReference(ref);
! 					break;
! 				case 'C':  // service reference compare string
! 					tmp = PyString_FromString(ref.toCompareString().c_str());
! 					break;
! 				case 'S':  // service reference string
! 					tmp = PyString_FromString(ref.toString().c_str());
! 					break;
! 				case 'N':  // service name
! 					if (service_center)
! 					{
! 						service_center->info(ref, sptr);
! 						if (sptr)
! 						{
! 							std::string name;
! 							sptr->getName(ref, name);
! 
! 							// filter short name brakets
! 							size_t pos;
! 							while((pos = name.find("\xc2\x86")) != std::string::npos)
! 								name.erase(pos,2);
! 							while((pos = name.find("\xc2\x87")) != std::string::npos)
! 								name.erase(pos,2);
! 
! 							if (name.length())
! 								tmp = PyString_FromString(name.c_str());
! 						}
! 					}
! 					if (!tmp)
! 						tmp = PyString_FromString("<n/a>");
! 					break;
! 				case 'n':  // short service name
! 					if (service_center)
! 					{
! 						service_center->info(ref, sptr);
! 						if (sptr)
! 						{
! 							std::string name;
! 							sptr->getName(ref, name);
! 							name = buildShortName(name);
! 							if (name.length())
! 								tmp = PyString_FromString(name.c_str());
! 						}
! 					}
! 					if (!tmp)
! 						tmp = PyString_FromString("<n/a>");
! 					break;
! 				default:
! 					if (tuple)
! 					{
! 						tmp = Py_None;
! 						Py_INCREF(Py_None);
! 					}
! 					break;
! 				}
! 				if (tmp)
! 				{
! 					if (tuple)
! 						PyTuple_SET_ITEM(tuple, i, tmp);
! 					else
! 						PyList_SET_ITEM(ret, cnt, tmp);
! 				}
! 			}
! 			if (tuple)
! 				PyList_SET_ITEM(ret, cnt, tuple);
! 		}
! 	}
! 	return ret ? (PyObject*)ret : (PyObject*)PyList_New(0);
! }
! 
! RESULT eDVBServiceList::getNext(eServiceReference &ref)
! {
! 	if (!m_query)
! 		return -1;
! 	
! 	return m_query->getNextResult((eServiceReferenceDVB&)ref);
! }
! 
! RESULT eDVBServiceList::startEdit(ePtr<iMutableServiceList> &res)
! {
! 	if (m_parent.flags & eServiceReference::canDescent) // bouquet
! 	{
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> resm;
! 
! 		if (eDVBResourceManager::getInstance(resm) || resm->getChannelList(db))
! 			return -1;
! 
! 		if (db->getBouquet(m_parent, m_bouquet) != 0)
! 			return -1;
! 
! 		res = this;
! 		
! 		return 0;
! 	}
! 	res = 0;
! 	return -1;
! }
! 
! RESULT eDVBServiceList::addService(eServiceReference &ref, eServiceReference before)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->addService(ref, before);
! }
! 
! RESULT eDVBServiceList::removeService(eServiceReference &ref)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->removeService(ref);
! }
! 
! RESULT eDVBServiceList::moveService(eServiceReference &ref, int pos)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->moveService(ref, pos);
! }
! 
! RESULT eDVBServiceList::flushChanges()
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->flushChanges();
! }
! 
! RESULT eDVBServiceList::setListName(const std::string &name)
! {
! 	if (!m_bouquet)
! 		return -1;
! 	return m_bouquet->setListName(name);
! }
! 
! RESULT eServiceFactoryDVB::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
! {
! 	ePtr<eDVBService> service;
! 	int r = lookupService(service, ref);
! 	if (r)
! 		service = 0;
! 		// check resources...
! 	ptr = new eDVBServicePlay(ref, service);
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
! {
! 	if (ref.path.empty())
! 	{
! 		ptr = new eDVBServiceRecord((eServiceReferenceDVB&)ref);
! 		return 0;
! 	} else
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! }
! 
! RESULT eServiceFactoryDVB::list(const eServiceReference &ref, ePtr<iListableService> &ptr)
! {
! 	ePtr<eDVBServiceList> list = new eDVBServiceList(ref);
! 	if (list->startQuery())
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! 	
! 	ptr = list;
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
! {
! 	/* is a listable service? */
! 	if (ref.flags & eServiceReference::canDescent) // bouquet
! 	{
! 		if ( !ref.name.empty() )  // satellites or providers list
! 			ptr = m_StaticServiceDVBInfo;
! 		else // a dvb bouquet
! 			ptr = m_StaticServiceDVBBouquetInfo;
! 	}
! 	else if (!ref.path.empty()) /* do we have a PVR service? */
! 		ptr = new eStaticServiceDVBPVRInformation(ref);
! 	else // normal dvb service
! 	{
! 		ePtr<eDVBService> service;
! 		if (lookupService(service, ref)) // no eDVBService avail for this reference ( Linkage Services... )
! 			ptr = m_StaticServiceDVBInfo;
! 		else
! 			/* eDVBService has the iStaticServiceInformation interface, so we pass it here. */
! 			ptr = service;
! 	}
! 	return 0;
! }
! 
! RESULT eServiceFactoryDVB::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
! {
! 	if (ref.path.empty())
! 	{
! 		ptr = 0;
! 		return -1;
! 	} else
! 	{
! 		ptr = new eDVBPVRServiceOfflineOperations(ref);
! 		return 0;
! 	}
! }
! 
! RESULT eServiceFactoryDVB::lookupService(ePtr<eDVBService> &service, const eServiceReference &ref)
! {
! 	if (!ref.path.empty()) // playback
! 	{
! 		eDVBMetaParser parser;
! 		int ret=parser.parseFile(ref.path);
! 		service = new eDVBService;
! 		if (!ret)
! 			eDVBDB::getInstance()->parseServiceData(service, parser.m_service_data);
! 	}
! 	else
! 	{
! 			// TODO: handle the listing itself
! 		// if (ref.... == -1) .. return "... bouquets ...";
! 		// could be also done in another serviceFactory (with seperate ID) to seperate actual services and lists
! 			// TODO: cache
! 		ePtr<iDVBChannelList> db;
! 		ePtr<eDVBResourceManager> res;
! 	
! 		int err;
! 		if ((err = eDVBResourceManager::getInstance(res)) != 0)
! 		{
! 			eDebug("no resource manager");
! 			return err;
! 		}
! 		if ((err = res->getChannelList(db)) != 0)
! 		{
! 			eDebug("no channel list");
! 			return err;
! 		}
! 	
! 		/* we are sure to have a ..DVB reference as the info() call was forwarded here according to it's ID. */
! 		if ((err = db->getService((eServiceReferenceDVB&)ref, service)) != 0)
! 		{
! //			eDebug("getService failed!");
! 			return err;
! 		}
! 	}
! 
! 	return 0;
! }
! 
! eDVBServicePlay::eDVBServicePlay(const eServiceReference &ref, eDVBService *service):
! 	m_reference(ref), m_dvb_service(service), m_have_video_pid(0), m_is_paused(0)
! {
! 	m_is_primary = 1;
! 	m_is_pvr = !m_reference.path.empty();
! 	
! 	m_timeshift_enabled = m_timeshift_active = 0, m_timeshift_changed = 0;
! 	m_skipmode = m_fastforward = m_slowmotion = 0;
! 	
! 	CONNECT(m_service_handler.serviceEvent, eDVBServicePlay::serviceEvent);
! 	CONNECT(m_service_handler_timeshift.serviceEvent, eDVBServicePlay::serviceEventTimeshift);
! 	CONNECT(m_event_handler.m_eit_changed, eDVBServicePlay::gotNewEvent);
! 
! 	m_cuesheet_changed = 0;
! 	m_cutlist_enabled = 1;
! 	
! 	m_subtitle_widget = 0;
! 	
! 	m_tune_state = -1;
! 
! 	m_subtitle_sync_timer = eTimer::create(eApp);
! 
! 	CONNECT(m_subtitle_sync_timer->timeout, eDVBServicePlay::checkSubtitleTiming);
! 
! 	m_player = 0;
! 
! 	xineLib = cXineLib::getInstance();
! 	xine_connection = CONNECT(xineLib->m_event, eDVBServicePlay::video_event);
! }
! 
! eDVBServicePlay::~eDVBServicePlay()
! {
! 	if (m_is_pvr)
! 	{
! 		eDVBMetaParser meta;
! 		int ret=meta.parseFile(m_reference.path);
! 		if (!ret)
! 		{
! 			char tmp[255];
! 			meta.m_service_data="";
! 			sprintf(tmp, "f:%x", m_dvb_service->m_flags);
! 			meta.m_service_data += tmp;
! 			// cached pids
! 			for (int x=0; x < eDVBService::cacheMax; ++x)
! 			{
! 				int entry = m_dvb_service->getCacheEntry((eDVBService::cacheID)x);
! 				if (entry != -1)
! 				{
! 					sprintf(tmp, ",c:%02d%04x", x, entry);
! 					meta.m_service_data += tmp;
! 				}
! 			}
! 			meta.updateMeta(m_reference.path);
! 		}
! 	}
! 
! 	xine_connection.disconnect();
! 
! 	delete m_subtitle_widget;
! }
! 
! void eDVBServicePlay::gotNewEvent()
! {
! #if 0
! 		// debug only
! 	ePtr<eServiceEvent> m_event_now, m_event_next;
! 	getEvent(m_event_now, 0);
! 	getEvent(m_event_next, 1);
! 
! 	if (m_event_now)
! 		eDebug("now running: %s (%d seconds :)", m_event_now->m_event_name.c_str(), m_event_now->m_duration);
! 	if (m_event_next)
! 		eDebug("next running: %s (%d seconds :)", m_event_next->m_event_name.c_str(), m_event_next->m_duration);
! #endif
! 	m_event((iPlayableService*)this, evUpdatedEventInfo);
! }
! 
! void eDVBServicePlay::serviceEvent(int event)
! {
! 	m_tune_state = event;
! 
! 	switch (event)
! 	{
! 	case eDVBServicePMTHandler::eventTuned:
! 	{
! 		ePtr<iDVBDemux> m_demux;
! 		if (!m_service_handler.getDataDemux(m_demux))
! 		{
! 			eServiceReferenceDVB &ref = (eServiceReferenceDVB&) m_reference;
! 			int sid = ref.getParentServiceID().get();
! 			if (!sid)
! 				sid = ref.getServiceID().get();
! 			if ( ref.getParentTransportStreamID().get() &&
! 				ref.getParentTransportStreamID() != ref.getTransportStreamID() )
! 				m_event_handler.startOther(m_demux, sid);
! 			else
! 				m_event_handler.start(m_demux, sid);
! 		}
! 		m_event((iPlayableService*)this, evTunedIn);
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventNoResources:
! 	case eDVBServicePMTHandler::eventNoPAT:
! 	case eDVBServicePMTHandler::eventNoPATEntry:
! 	case eDVBServicePMTHandler::eventNoPMT:
! 	case eDVBServicePMTHandler::eventTuneFailed:
! 	case eDVBServicePMTHandler::eventMisconfiguration:
! 	{
! 		eDebug("DVB service failed to tune - error %d", event);
! 		m_event((iPlayableService*)this, evTuneFailed);
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventNewProgramInfo:
! 	{
! 		eDebug("eventNewProgramInfo %d %d", m_timeshift_enabled, m_timeshift_active);
! 		if (m_timeshift_enabled)
! 			updateTimeshiftPids();
! 		if (!m_timeshift_active)
! 			updateDecoder();
! 		if (m_first_program_info & 1 && m_is_pvr)
! 		{
! 			m_first_program_info &= ~1;
! 			seekTo(0);
! 		}
! 		if (!m_timeshift_active)
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 
! 		ePtr<iDVBDemux> m_demux;
! 		if (!m_service_handler.getDataDemux(m_demux))
! 		{
! 			printf("Start live TV!\n");
! 
! 			m_demux->createTSPlayer(m_player);
! 			if (!m_player)
! 				printf("ERROR: !m_player\n");
! 			
! 			m_player->setTargetFD(m_fd_dst);
! 			updateTimeshiftPids();
! 			m_player->start();
! 
! 			printf("Start live TV END\n");
! 		}
! 
! 		break;
! 	}
! 	case eDVBServicePMTHandler::eventPreStart:
! 		loadCuesheet();
! 		break;
! 	case eDVBServicePMTHandler::eventEOF:
! 		m_event((iPlayableService*)this, evEOF);
! 		break;
! 	case eDVBServicePMTHandler::eventSOF:
! 		m_event((iPlayableService*)this, evSOF);
! 		break;
! 	}
! }
! 
! void eDVBServicePlay::serviceEventTimeshift(int event)
! {
! 	switch (event)
! 	{
! 	case eDVBServicePMTHandler::eventNewProgramInfo:
! 		eDebug("eventNewProgramInfo TS");
! 		if (m_timeshift_active)
! 		{
! 			updateDecoder();
! 			if (m_first_program_info & 2)
! 			{
! 				if (m_slowmotion)
! 				{
! 					eDebug("re-apply slowmotion after timeshift file change");
! 					m_decoder->setSlowMotion(m_slowmotion);
! 				}
! 				if (m_fastforward)
! 				{
! 					eDebug("re-apply skip %d, ratio %d after timeshift file change", m_skipmode, m_fastforward);
! 					if (m_skipmode)
! 						m_cue->setSkipmode(m_skipmode * 90000); /* convert to 90000 per second */
! 					if (m_fastforward != 1)
! 						m_decoder->setFastForward(m_fastforward);
! 					else
! 						m_decoder->setTrickmode();
! 				}
! 				else
! 					seekTo(0);
! 				m_first_program_info &= ~2;
! 			}
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 		}
! 		break;
! 	case eDVBServicePMTHandler::eventSOF:
! #if 0
! 		if (!m_timeshift_file_next.empty())
! 		{
! 			eDebug("timeshift SOF, switch to next file");
! 			m_decoder->pause();
! 
! 			m_first_program_info |= 2;
! 
! 			eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 			r.path = m_timeshift_file_next;
! 
! 			/* free the timeshift service handler, we need the resources */
! 			m_service_handler_timeshift.free();
! 			resetTimeshift(1);
! 
! 			if (m_skipmode < 0)
! 				m_cue->seekTo(0, -1000);
! 			ePtr<iTsSource> source = createTsSource(r);
! 			m_service_handler_timeshift.tuneExt(r, 1, source, r.path.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 			m_event((iPlayableService*)this, evUser+1);
! 		}
! 		else
! #endif
! 			m_event((iPlayableService*)this, evSOF);
! 		break;
! 	case eDVBServicePMTHandler::eventEOF:
! 		if ((!m_is_paused) && (m_skipmode >= 0))
! 		{
! 			if (m_timeshift_file_next.empty())
! 			{
! 				eDebug("timeshift EOF, so let's go live");
! 				switchToLive();
! 			}
! 			else
! 			{
! 				eDebug("timeshift EOF, switch to next file");
! 
! 				m_first_program_info |= 2;
! 
! 				eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 				r.path = m_timeshift_file_next;
! 
! 				/* free the timeshift service handler, we need the resources */
! 				m_service_handler_timeshift.free();
! 				resetTimeshift(1);
! 
! 				ePtr<iTsSource> source = createTsSource(r);
! 				m_service_handler_timeshift.tuneExt(r, 1, source, m_timeshift_file_next.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 				m_event((iPlayableService*)this, evUser+1);
! 			}
! 		}
! 		break;
! 	}
! }
! 
! RESULT eDVBServicePlay::start()
! {
! 	printf("eDVBServicePlay::start\n");
! 	eServiceReferenceDVB service = (eServiceReferenceDVB&)m_reference;
! 
! 	m_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
! 	if (m_fd_dst < 0)
! 	{
! 		eDebug("can't open DVR device - FIFO file (%m)");
! 	}
! 
! 		/* in pvr mode, we only want to use one demux. in tv mode, we're using 
! 		   two (one for decoding, one for data source), as we must be prepared
! 		   to start recording from the data demux. */
! 	if (m_is_pvr)
! 	{
! 		eDVBMetaParser meta;
! 		if (!meta.parseFile(m_reference.path))
! 		{
! 			service = meta.m_ref;
! 			service.path = m_reference.path;
! 		}
! 		m_cue = new eCueSheet();
! 	}
! 	else
! 		m_event(this, evStart);
! 
! 	m_first_program_info = 1;
! 	ePtr<iTsSource> source = createTsSource(service);
! 	m_service_handler.tuneExt(service, m_is_pvr, source, service.path.c_str(), m_cue, false, m_dvb_service);
! 
! 	if (m_is_pvr)
! 	{
! 		/* inject EIT if there is a stored one */
! 		std::string filename = service.path;
! 		filename.erase(filename.length()-2, 2);
! 		filename+="eit";
! 		ePtr<eServiceEvent> event = new eServiceEvent;
! 		if (!event->parseFrom(filename, (service.getTransportStreamID().get()<<16)|service.getOriginalNetworkID().get()))
! 		{
! 			ePtr<eServiceEvent> empty;
! 			m_event_handler.inject(event, 0);
! 			m_event_handler.inject(empty, 1);
! 		}
! 		m_event(this, evStart);
! 	}
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::stop()
! {
! 	printf("eDVBServicePlay::stop\n");
! 		/* add bookmark for last play position */
! 	if (m_is_pvr)
! 	{
! 		pts_t play_position, length;
! 		if (!getPlayPosition(play_position))
! 		{
! 				/* remove last position */
! 			for (std::multiset<struct cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end();)
! 			{
! 				if (i->what == 3) /* current play position */
! 				{
! 					m_cue_entries.erase(i);
! 					i = m_cue_entries.begin();
! 					continue;
! 				} else
! 					++i;
! 			}
! 			
! 			if (getLength(length))
! 				length = 0;
! 			
! 			if (length)
! 			{
! 				m_cue_entries.insert(cueEntry(play_position, 3)); /* last play position */
! 			}
! 			m_cuesheet_changed = 1;
! 		}
! 	}
! 
! 	stopTimeshift(); /* in case timeshift was enabled, remove buffer etc. */
! 
! 	// stop TSPlayer
! 	if (m_player) {
! 		m_player->stop();
! 		m_player = 0;
! 	}
! 	if (m_fd_dst>0) {
! 		printf("close(m_fd_dst)  %d\n", m_fd_dst);
! 		close(m_fd_dst);
! 	}
! 
! 	m_service_handler_timeshift.free();
! 	m_service_handler.free();
! 	
! 	if (m_is_pvr && m_cuesheet_changed)
! 	{
! 		struct stat s;
! 				/* save cuesheet only when main file is accessible. */
! 		if (!::stat(m_reference.path.c_str(), &s))
! 			saveCuesheet();
! 	}
! 	m_event((iPlayableService*)this, evStopped);
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::setTarget(int target)
! {
! 	m_is_primary = !target;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
! {
! 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::pause(ePtr<iPauseableService> &ptr)
! {
! 		/* note: we check for timeshift to be enabled,
! 		   not neccessary active. if you pause when timeshift
! 		   is not active, you should activate it when unpausing */
! 	if ((!m_is_pvr) && (!m_timeshift_enabled))
! 	{
! 		ptr = 0;
! 		return -1;
! 	}
! 
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::setSlowMotion(int ratio)
! {
! 	ASSERT(ratio); /* The API changed: instead of calling setSlowMotion(0), call play! */
! 	eDebug("eDVBServicePlay::setSlowMotion(%d)", ratio);
! 	setFastForward_internal(0);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = ratio;
! 		return m_decoder->setSlowMotion(ratio);
! 	}
! 	else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::setFastForward(int ratio)
! {
! 	eDebug("eDVBServicePlay::setFastForward(%d)", ratio);
! 	ASSERT(ratio);
! 	return setFastForward_internal(ratio);
! }
! 
! RESULT eDVBServicePlay::setFastForward_internal(int ratio, bool final_seek)
! {
! 	int skipmode, ffratio, ret = 0;
! 	pts_t pos=0;
! 
! 	if (ratio > 8)
! 	{
! 		skipmode = ratio;
! 		ffratio = 1;
! 	} else if (ratio > 0)
! 	{
! 		skipmode = 0;
! 		ffratio = ratio;
! 	} else if (!ratio)
! 	{
! 		skipmode = 0;
! 		ffratio = 0;
! 	} else // if (ratio < 0)
! 	{
! 		skipmode = ratio;
! 		ffratio = 1;
! 	}
! 
! 	if (m_skipmode != skipmode)
! 	{
! 		eDebug("setting cue skipmode to %d", skipmode);
! 		if (m_cue)
! 			m_cue->setSkipmode(skipmode * 90000); /* convert to 90000 per second */
! 	}
! 
! 	m_skipmode = skipmode;
! 
! 	if (final_seek)
! 		eDebug("trickplay stopped .. ret %d, pos %lld", getPlayPosition(pos), pos);
! 
! 	m_fastforward = ffratio;
! 
! 	if (!m_decoder)
! 		return -1;
! 
! 	if (ffratio == 0)
! 		; /* return m_decoder->play(); is done in caller*/
! 	else if (ffratio != 1)
! 		ret = m_decoder->setFastForward(ffratio);
! 	else
! 		ret = m_decoder->setTrickmode();
! 
! 	if (pos)
! 		eDebug("final seek after trickplay ret %d", seekTo(pos));
! 
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::seek(ePtr<iSeekableService> &ptr)
! {
! 	if (m_is_pvr || m_timeshift_enabled)
! 	{
! 		ptr = this;
! 		return 0;
! 	}
! 	
! 	ptr = 0;
! 	return -1;
! }
! 
! 	/* TODO: when timeshift is enabled but not active, this doesn't work. */
! RESULT eDVBServicePlay::getLength(pts_t &len)
! {
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	return pvr_channel->getLength(len);
! }
! 
! RESULT eDVBServicePlay::pause()
! {
! 	eDebug("eDVBServicePlay::pause");
! 	setFastForward_internal(0, m_slowmotion || m_fastforward > 1);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = 0;
! 		m_is_paused = 1;
! 		return m_decoder->pause();
! 	} else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::unpause()
! {
! 	eDebug("eDVBServicePlay::unpause");
! 	setFastForward_internal(0, m_slowmotion || m_fastforward > 1);
! 	if (m_decoder)
! 	{
! 		m_slowmotion = 0;
! 		m_is_paused = 0;
! 		return m_decoder->play();
! 	} else
! 		return -1;
! }
! 
! RESULT eDVBServicePlay::seekTo(pts_t to)
! {
! 	eDebug("eDVBServicePlay::seekTo: jump %lld", to);
! 	
! 	if (!m_decode_demux)
! 		return -1;
! 
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	if (!m_cue)
! 		return -1;
! 	
! 	m_cue->seekTo(0, to);
! 	m_dvb_subtitle_pages.clear();
! 	m_subtitle_pages.clear();
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::seekRelative(int direction, pts_t to)
! {
! 	eDebug("eDVBServicePlay::seekRelative: jump %d, %lld", direction, to);
! 	
! 	if (!m_decode_demux)
! 		return -1;
! 
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	int mode = 1;
! 	
! 			/* HACK until we have skip-AP api */
! 	if ((to > 0) && (to < 100))
! 		mode = 2;
! 	
! 	to *= direction;
! 	
! 	if (!m_cue)
! 		return 0;
! 	
! 	m_cue->seekTo(mode, to);
! 	m_dvb_subtitle_pages.clear();
! 	m_subtitle_pages.clear();
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getPlayPosition(pts_t &pos)
! {
! 	ePtr<iDVBPVRChannel> pvr_channel;
! 	
! 	if ((m_timeshift_enabled ? m_service_handler_timeshift : m_service_handler).getPVRChannel(pvr_channel))
! 		return -1;
! 	
! 	int r = 0;
! 
! 	r = xineLib->getPTS(pos);
! 	if (r)
! 		return r;
! 	
! 		/* fixup */
! 	return pvr_channel->getCurrentPosition(m_decode_demux, pos, 1);
! }
! 
! RESULT eDVBServicePlay::setTrickmode(int trick)
! {
! 		/* currently unimplemented */
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::isCurrentlySeekable()
! {
! 	int ret = 0;
! 	if (m_decoder)
! 	{
! 		ret = (m_is_pvr || m_timeshift_active) ? 3 : 0; // fast forward/backward possible and seeking possible
! 		if (m_decoder->getVideoProgressive() == -1)
! 			ret &= ~2;
! 	}
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::frontendInfo(ePtr<iFrontendInformation> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::info(ePtr<iServiceInformation> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioChannel(ePtr<iAudioChannelSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioTracks(ePtr<iAudioTrackSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::subServices(ePtr<iSubserviceList> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::timeshift(ePtr<iTimeshiftService> &ptr)
! {
! 	ptr = 0;
! 	if (m_have_video_pid &&  // HACK !!! FIXMEE !! temporary no timeshift on radio services !!
! 		(m_timeshift_enabled || !m_is_pvr))
! 	{
! 		if (!m_timeshift_enabled)
! 		{
! 			/* query config path */
! 			std::string tspath;
! 			if(ePythonConfigQuery::getConfigValue("config.usage.timeshift_path", tspath) == -1){
! 				eDebug("could not query ts path from config");
! 				return -4;
! 			}
! 			tspath.append("/");
! 			/* we need enough diskspace */
! 			struct statfs fs;
! 			if (statfs(tspath.c_str(), &fs) < 0)
! 			{
! 				eDebug("statfs failed!");
! 				return -2;
! 			}
! 		
! 			if (((off_t)fs.f_bavail) * ((off_t)fs.f_bsize) < 1024*1024*1024LL)
! 			{
! 				eDebug("not enough diskspace for timeshift! (less than 1GB)");
! 				return -3;
! 			}
! 		}
! 		ptr = this;
! 		return 0;
! 	}
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::cueSheet(ePtr<iCueSheet> &ptr)
! {
! 	if (m_is_pvr)
! 	{
! 		ptr = this;
! 		return 0;
! 	}
! 	ptr = 0;
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::subtitle(ePtr<iSubtitleOutput> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::audioDelay(ePtr<iAudioDelay> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::rdsDecoder(ePtr<iRdsDecoder> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getName(std::string &name)
! {
! 	if (m_is_pvr)
! 	{
! 		ePtr<iStaticServiceInformation> i = new eStaticServiceDVBPVRInformation(m_reference);
! 		return i->getName(m_reference, name);
! 	}
! 	else if (m_dvb_service)
! 	{
! 		m_dvb_service->getName(m_reference, name);
! 		if (name.empty())
! 			name = "(...)";
! 	}
! 	else if (!m_reference.name.empty())
! 		eStaticServiceDVBInformation().getName(m_reference, name);
! 	else
! 		name = "DVB service";
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getEvent(ePtr<eServiceEvent> &evt, int nownext)
! {
! 	return m_event_handler.getEvent(evt, nownext);
! }
! 
! int eDVBServicePlay::getInfo(int w)
! {
! 	eDVBServicePMTHandler::program program;
! 
! 	if (w == sCAIDs || w == sCAIDPIDs)
! 		return resIsPyObject;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	int no_program_info = 0;
! 
! 	if (h.getProgramInfo(program))
! 		no_program_info = 1;
! 
! 	switch (w)
! 	{
! 	case sVideoHeight:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoHeight();
! 		return xineLib->getVideoHeight();
! 		break;
! 	case sVideoWidth:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoWidth();
! 		return xineLib->getVideoWidth();
! 		break;
! 	case sFrameRate:
! 		//if (m_decoder)
! 		//	return m_decoder->getVideoFrameRate();
! 		return xineLib->getVideoFrameRate();
! 		break;
! 	case sProgressive:
! 		if (m_decoder)
! 			return m_decoder->getVideoProgressive();
! 		break;
! 	case sAspect:
! 	{
! 		//if (m_decoder)
! 		//	aspect = m_decoder->getVideoAspect();
! 		int aspect = xineLib->getVideoAspect();
! 
! 		if (aspect == -1 && no_program_info)
! 			break;
! 		else if (aspect == -1 && !program.videoStreams.empty() && program.videoStreams[0].component_tag != -1)
! 		{
! 			ePtr<eServiceEvent> evt;
! 			if (!m_event_handler.getEvent(evt, 0))
! 			{
! 				ePtr<eComponentData> data;
! 				if (!evt->getComponentData(data, program.videoStreams[0].component_tag))
! 				{
! 					if ( data->getStreamContent() == 1 )
! 					{
! 						switch(data->getComponentType())
! 						{
! 							// SD
! 							case 1: // 4:3 SD PAL
! 							case 2:
! 							case 3: // 16:9 SD PAL
! 							case 4: // > 16:9 PAL
! 							case 5: // 4:3 SD NTSC
! 							case 6: 
! 							case 7: // 16:9 SD NTSC
! 							case 8: // > 16:9 NTSC
! 
! 							// HD
! 							case 9: // 4:3 HD PAL
! 							case 0xA:
! 							case 0xB: // 16:9 HD PAL
! 							case 0xC: // > 16:9 HD PAL
! 							case 0xD: // 4:3 HD NTSC
! 							case 0xE:
! 							case 0xF: // 16:9 HD NTSC
! 							case 0x10: // > 16:9 HD PAL
! 								return data->getComponentType();
! 						}
! 					}
! 				}
! 			}
! 		}
! 		else
! 			return aspect;
! 		break;
! 	}
! 	case sIsCrypted: if (no_program_info) return -1; return program.isCrypted();
! 	case sVideoPID:
! 		if (m_dvb_service)
! 		{
! 			int vpid = m_dvb_service->getCacheEntry(eDVBService::cVPID);
! 			if (vpid != -1)
! 				return vpid;
! 		}
! 		if (no_program_info) return -1; if (program.videoStreams.empty()) return -1; return program.videoStreams[0].pid;
! 	case sVideoType: if (no_program_info) return -1; if (program.videoStreams.empty()) return -1; return program.videoStreams[0].type;
! 	case sAudioPID:
! 		if (m_dvb_service)
! 		{
! 			int apid = m_dvb_service->getCacheEntry(eDVBService::cAPID);
! 			if (apid != -1)
! 				return apid;
! 			apid = m_dvb_service->getCacheEntry(eDVBService::cAC3PID);
! 			if (apid != -1)
! 				return apid;
! 		}
! 		if (no_program_info) return -1; if (program.audioStreams.empty()) return -1; return program.audioStreams[0].pid;
! 	case sPCRPID:
! 		if (m_dvb_service)
! 		{
! 			int pcrpid = m_dvb_service->getCacheEntry(eDVBService::cPCRPID);
! 			if (pcrpid != -1)
! 				return pcrpid;
! 		}
! 		if (no_program_info) return -1; return program.pcrPid;
! 	case sPMTPID: if (no_program_info) return -1; return program.pmtPid;
! 	case sTXTPID: if (no_program_info) return -1; return program.textPid;
! 	case sSID: return ((const eServiceReferenceDVB&)m_reference).getServiceID().get();
! 	case sONID: return ((const eServiceReferenceDVB&)m_reference).getOriginalNetworkID().get();
! 	case sTSID: return ((const eServiceReferenceDVB&)m_reference).getTransportStreamID().get();
! 	case sNamespace: return ((const eServiceReferenceDVB&)m_reference).getDVBNamespace().get();
! 	case sProvider: if (!m_dvb_service) return -1; return -2;
! 	case sServiceref: return resIsString;
! 	case sDVBState: return m_tune_state;
! 	default:
! 		break;
! 	}
! 	return -1;
! }
! 
! std::string eDVBServicePlay::getInfoString(int w)
! {
! 	switch (w)
! 	{
! 	case sProvider:
! 		if (!m_dvb_service) return "";
! 		return m_dvb_service->m_provider_name;
! 	case sServiceref:
! 		return m_reference.toString();
! 	default:
! 		break;
! 	}
! 	return iServiceInformation::getInfoString(w);
! }
! 
! PyObject *eDVBServicePlay::getInfoObject(int w)
! {
! 	switch (w)
! 	{
! 	case sCAIDs:
! 		return m_service_handler.getCaIds();
! 	case sCAIDPIDs:
! 		return m_service_handler.getCaIds(true);
! 	case sTransponderData:
! 		return eStaticServiceDVBInformation().getInfoObject(m_reference, w);
! 	default:
! 		break;
! 	}
! 	return iServiceInformation::getInfoObject(w);
! }
! 
! int eDVBServicePlay::getNumberOfTracks()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	if (h.getProgramInfo(program))
! 		return 0;
! 	return program.audioStreams.size();
! }
! 
! int eDVBServicePlay::getCurrentTrack()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	if (h.getProgramInfo(program))
! 		return 0;
! 
! 	int max = program.audioStreams.size();
! 	int i;
! 
! 	for (i = 0; i < max; ++i)
! 		if (program.audioStreams[i].pid == m_current_audio_pid)
! 			return i;
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::selectTrack(unsigned int i)
! {
! 	int ret = selectAudioStream(i);
! 
! 	if (m_decoder->set())
! 		return -5;
! 
! 	return ret;
! }
! 
! RESULT eDVBServicePlay::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	if (h.getProgramInfo(program))
! 		return -1;
! 	
! 	if (i >= program.audioStreams.size())
! 		return -2;
! 	
! 	info.m_pid = program.audioStreams[i].pid;
! 
! 	if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atMPEG)
! 		info.m_description = "MPEG";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAC3)
! 		info.m_description = "AC3";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAAC)
! 		info.m_description = "AAC";
! 	else if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atAACHE)
! 		info.m_description = "AAC-HE";
! 	else  if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDTS)
! 		info.m_description = "DTS";
! 	else  if (program.audioStreams[i].type == eDVBServicePMTHandler::audioStream::atDTSHD)
! 		info.m_description = "DTS-HD";
! 	else
! 		info.m_description = "???";
! 
! 	if (program.audioStreams[i].component_tag != -1)
! 	{
! 		ePtr<eServiceEvent> evt;
! 		if (!m_event_handler.getEvent(evt, 0))
! 		{
! 			ePtr<eComponentData> data;
! 			if (!evt->getComponentData(data, program.audioStreams[i].component_tag))
! 				info.m_language = data->getText();
! 		}
! 	}
! 
! 	if (info.m_language.empty())
! 		info.m_language = program.audioStreams[i].language_code;
! 	
! 	return 0;
! }
! 
! int eDVBServicePlay::selectAudioStream(int i)
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	pts_t position = -1;
! 
! 	if (h.getProgramInfo(program))
! 		return -1;
! 
! 	if ((i != -1) && ((unsigned int)i >= program.audioStreams.size()))
! 		return -2;
! 
! 	if (!m_decoder)
! 		return -3;
! 
! 	int stream = i;
! 	if (stream == -1)
! 		stream = program.defaultAudioStream;
! 
! 	int apid = -1, apidtype = -1;
! 
! 	if (((unsigned int)stream) < program.audioStreams.size())
! 	{
! 		apid = program.audioStreams[stream].pid;
! 		apidtype = program.audioStreams[stream].type;
! 	}
! 
! 	if (i != -1 && apid != m_current_audio_pid && (m_is_pvr || m_timeshift_active))
! 		eDebug("getPlayPosition ret %d, pos %lld in selectAudioStream", getPlayPosition(position), position);
! 
! 	m_current_audio_pid = apid;
! 
! 	if (m_is_primary && m_decoder->setAudioPID(apid, apidtype))
! 	{
! 		eDebug("set audio pid failed");
! 		return -4;
! 	}
! 
! 	if (position != -1)
! 		eDebug("seekTo ret %d", seekTo(position));
! 
! 	int rdsPid = apid;
! 
! 		/* if we are not in PVR mode, timeshift is not active and we are not in pip mode, check if we need to enable the rds reader */
! 	if (!(m_is_pvr || m_timeshift_active || !m_is_primary))
! 	{
! 		int different_pid = program.videoStreams.empty() && program.audioStreams.size() == 1 && program.audioStreams[stream].rdsPid != -1;
! 		if (different_pid)
! 			rdsPid = program.audioStreams[stream].rdsPid;
! 		if (!m_rds_decoder || m_rds_decoder->getPid() != rdsPid)
! 		{
! 			m_rds_decoder = 0;
! 			ePtr<iDVBDemux> data_demux;
! 			if (!h.getDataDemux(data_demux))
! 			{
! 				m_rds_decoder = new eDVBRdsDecoder(data_demux, different_pid);
! 				m_rds_decoder->connectEvent(slot(*this, &eDVBServicePlay::rdsDecoderEvent), m_rds_decoder_event_connection);
! 				m_rds_decoder->start(rdsPid);
! 			}
! 		}
! 	}
! 
! 			/* store new pid as default only when:
! 				a.) we have an entry in the service db for the current service,
! 				b.) we are not playing back something,
! 				c.) we are not selecting the default entry. (we wouldn't change 
! 				    anything in the best case, or destroy the default setting in
! 				    case the real default is not yet available.)
! 			*/
! 	if (m_dvb_service && ((i != -1)
! 		|| ((m_dvb_service->getCacheEntry(eDVBService::cAPID) == -1) && (m_dvb_service->getCacheEntry(eDVBService::cAC3PID)==-1))))
! 	{
! 		if (apidtype == eDVBAudio::aMPEG)
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, apid);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, -1);
! 		}
! 		else if (apidtype == eDVBAudio::aAC3)
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, -1);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, apid);
! 		}
! 		else
! 		{
! 			m_dvb_service->setCacheEntry(eDVBService::cAPID, -1);
! 			m_dvb_service->setCacheEntry(eDVBService::cAC3PID, -1);
! 		}
! 	}
! 
! 	h.resetCachedProgram();
! 
! 	return 0;
! }
! 
! int eDVBServicePlay::getCurrentChannel()
! {
! 	return m_decoder ? m_decoder->getAudioChannel() : STEREO;
! }
! 
! RESULT eDVBServicePlay::selectChannel(int i)
! {
! 	if (i < LEFT || i > RIGHT || i == STEREO)
! 		i = -1;  // Stereo
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cACHANNEL, i);
! 	if (m_decoder)
! 		m_decoder->setAudioChannel(i);
! 	return 0;
! }
! 
! std::string eDVBServicePlay::getText(int x)
! {
! 	if (m_rds_decoder)
! 		switch(x)
! 		{
! 			case RadioText:
! 				return convertLatin1UTF8(m_rds_decoder->getRadioText());
! 			case RtpText:
! 				return convertLatin1UTF8(m_rds_decoder->getRtpText());
! 		}
! 	return "";
! }
! 
! void eDVBServicePlay::rdsDecoderEvent(int what)
! {
! 	switch(what)
! 	{
! 		case eDVBRdsDecoder::RadioTextChanged:
! 			m_event((iPlayableService*)this, evUpdatedRadioText);
! 			break;
! 		case eDVBRdsDecoder::RtpTextChanged:
! 			m_event((iPlayableService*)this, evUpdatedRtpText);
! 			break;
! 		case eDVBRdsDecoder::RassInteractivePicMaskChanged:
! 			m_event((iPlayableService*)this, evUpdatedRassInteractivePicMask);
! 			break;
! 		case eDVBRdsDecoder::RecvRassSlidePic:
! 			m_event((iPlayableService*)this, evUpdatedRassSlidePic);
! 			break;
! 	}
! }
! 
! void eDVBServicePlay::showRassSlidePicture()
! {
! 	if (m_rds_decoder)
! 	{
! 		if (m_decoder)
! 		{
! 			std::string rass_slide_pic = m_rds_decoder->getRassSlideshowPicture();
! 			if (rass_slide_pic.length())
! 				m_decoder->showSinglePic(rass_slide_pic.c_str());
! 			else
! 				eDebug("empty filename for rass slide picture received!!");
! 		}
! 		else
! 			eDebug("no MPEG Decoder to show iframes avail");
! 	}
! 	else
! 		eDebug("showRassSlidePicture called.. but not decoder");
! }
! 
! void eDVBServicePlay::showRassInteractivePic(int page, int subpage)
! {
! 	if (m_rds_decoder)
! 	{
! 		if (m_decoder)
! 		{
! 			std::string rass_interactive_pic = m_rds_decoder->getRassPicture(page, subpage);
! 			if (rass_interactive_pic.length())
! 				m_decoder->showSinglePic(rass_interactive_pic.c_str());
! 			else
! 				eDebug("empty filename for rass interactive picture %d/%d received!!", page, subpage);
! 		}
! 		else
! 			eDebug("no MPEG Decoder to show iframes avail");
! 	}
! 	else
! 		eDebug("showRassInteractivePic called.. but not decoder");
! }
! 
! ePyObject eDVBServicePlay::getRassInteractiveMask()
! {
! 	if (m_rds_decoder)
! 		return m_rds_decoder->getRassPictureMask();
! 	Py_RETURN_NONE;
! }
! 
! int eDVBServiceBase::getFrontendInfo(int w)
! {
! 	eUsePtr<iDVBChannel> channel;
! 	if(m_service_handler.getChannel(channel))
! 		return 0;
! 	ePtr<iDVBFrontend> fe;
! 	if(channel->getFrontend(fe))
! 		return 0;
! 	return fe->readFrontendData(w);
! }
! 
! PyObject *eDVBServiceBase::getFrontendData()
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getFrontendData(ret);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getFrontendStatus()
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getFrontendStatus(ret);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getTransponderData(bool original)
! {
! 	ePyObject ret = PyDict_New();
! 	if (ret)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 				fe->getTransponderData(ret, original);
! 		}
! 	}
! 	else
! 		Py_RETURN_NONE;
! 	return ret;
! }
! 
! PyObject *eDVBServiceBase::getAll(bool original)
! {
! 	ePyObject ret = getTransponderData(original);
! 	if (ret != Py_None)
! 	{
! 		eUsePtr<iDVBChannel> channel;
! 		if(!m_service_handler.getChannel(channel))
! 		{
! 			ePtr<iDVBFrontend> fe;
! 			if(!channel->getFrontend(fe))
! 			{
! 				fe->getFrontendData(ret);
! 				fe->getFrontendStatus(ret);
! 			}
! 		}
! 	}
! 	return ret;
! }
! 
! int eDVBServicePlay::getNumberOfSubservices()
! {
! 	ePtr<eServiceEvent> evt;
! 	if (!m_event_handler.getEvent(evt, 0))
! 		return evt->getNumOfLinkageServices();
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::getSubservice(eServiceReference &sub, unsigned int n)
! {
! 	ePtr<eServiceEvent> evt;
! 	if (!m_event_handler.getEvent(evt, 0))
! 	{
! 		if (!evt->getLinkageService(sub, m_reference, n))
! 			return 0;
! 	}
! 	sub.type=eServiceReference::idInvalid;
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::startTimeshift()
! {
! 	ePtr<iDVBDemux> demux;
! 	
! 	eDebug("Start timeshift!");
! 	
! 	if (m_timeshift_enabled)
! 		return -1;
! 	
! 		/* start recording with the data demux. */
! 	if (m_service_handler.getDataDemux(demux))
! 		return -2;
! 
! 	demux->createTSRecorder(m_record);
! 	if (!m_record)
! 		return -3;
! 
! 	std::string tspath;
! 	if(ePythonConfigQuery::getConfigValue("config.usage.timeshift_path", tspath) == -1){ 
! 		eDebug("could not query ts path");
! 		return -5;
! 	}
! 	tspath.append("/timeshift.XXXXXX");
! 	char* templ;
! 	templ = new char[tspath.length() + 1];
! 	strcpy(templ, tspath.c_str());
! 
! 	m_timeshift_fd = mkstemp(templ);
! 	m_timeshift_file = std::string(templ);
! 
! 	eDebug("recording to %s", templ);
! 
! 	delete [] templ;
! 
! 	if (m_timeshift_fd < 0)
! 	{
! 		m_record = 0;
! 		return -4;
! 	}
! 		
! 	m_record->setTargetFD(m_timeshift_fd);
! 
! 	m_timeshift_enabled = 1;
! 	
! 	updateTimeshiftPids();
! 	m_record->start();
! 
! 	return 0;
! }
! 
! RESULT eDVBServicePlay::stopTimeshift(bool swToLive)
! {
! 	if (!m_timeshift_enabled)
! 		return -1;
! 	
! 	if (swToLive)
! 		switchToLive();
! 	
! 	m_timeshift_enabled = 0;
! 	
! 	m_record->stop();
! 	m_record = 0;
! 	
! 	close(m_timeshift_fd);
! 	eDebug("remove timeshift file");
! 	eBackgroundFileEraser::getInstance()->erase(m_timeshift_file.c_str());
! 	
! 	return 0;
! }
! 
! int eDVBServicePlay::isTimeshiftActive()
! {
! 	return m_timeshift_enabled && m_timeshift_active;
! }
! 
! RESULT eDVBServicePlay::activateTimeshift()
! {
! 	if (!m_timeshift_enabled)
! 		return -1;
! 	
! 	if (!m_timeshift_active)
! 	{
! 		switchToTimeshift();
! 		return 0;
! 	}
! 	
! 	return -2;
! }
! 
! PyObject *eDVBServicePlay::getCutList()
! {
! 	ePyObject list = PyList_New(0);
! 	
! 	for (std::multiset<struct cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end(); ++i)
! 	{
! 		ePyObject tuple = PyTuple_New(2);
! 		PyTuple_SET_ITEM(tuple, 0, PyLong_FromLongLong(i->where));
! 		PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(i->what));
! 		PyList_Append(list, tuple);
! 		Py_DECREF(tuple);
! 	}
! 	
! 	return list;
! }
! 
! void eDVBServicePlay::setCutList(ePyObject list)
! {
! 	if (!PyList_Check(list))
! 		return;
! 	int size = PyList_Size(list);
! 	int i;
! 	
! 	m_cue_entries.clear();
! 	
! 	for (i=0; i<size; ++i)
! 	{
! 		ePyObject tuple = PyList_GET_ITEM(list, i);
! 		if (!PyTuple_Check(tuple))
! 		{
! 			eDebug("non-tuple in cutlist");
! 			continue;
! 		}
! 		if (PyTuple_Size(tuple) != 2)
! 		{
! 			eDebug("cutlist entries need to be a 2-tuple");
! 			continue;
! 		}
! 		ePyObject ppts = PyTuple_GET_ITEM(tuple, 0), ptype = PyTuple_GET_ITEM(tuple, 1);
! 		if (!(PyLong_Check(ppts) && PyInt_Check(ptype)))
! 		{
! 			eDebug("cutlist entries need to be (pts, type)-tuples (%d %d)", PyLong_Check(ppts), PyInt_Check(ptype));
! 			continue;
! 		}
! 		pts_t pts = PyLong_AsLongLong(ppts);
! 		int type = PyInt_AsLong(ptype);
! 		m_cue_entries.insert(cueEntry(pts, type));
! 		eDebug("adding %08llx, %d", pts, type);
! 	}
! 	m_cuesheet_changed = 1;
! 	
! 	cutlistToCuesheet();
! 	m_event((iPlayableService*)this, evCuesheetChanged);
! }
! 
! void eDVBServicePlay::setCutListEnable(int enable)
! {
! 	m_cutlist_enabled = enable;
! 	cutlistToCuesheet();
! }
! 
! void eDVBServicePlay::updateTimeshiftPids()
! {
! 	eDVBServicePMTHandler::program program;
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	if (h.getProgramInfo(program))
! 		return;
! 	else
! 	{
! 		std::set<int> pids_to_record;
! 		pids_to_record.insert(0); // PAT
! 		if (program.pmtPid != -1)
! 			pids_to_record.insert(program.pmtPid); // PMT
! 
! 		if (program.textPid != -1)
! 			pids_to_record.insert(program.textPid); // Videotext
! 
! 		for (std::vector<eDVBServicePMTHandler::videoStream>::const_iterator
! 			i(program.videoStreams.begin()); 
! 			i != program.videoStreams.end(); ++i)
! 			pids_to_record.insert(i->pid);
! 
! 		for (std::vector<eDVBServicePMTHandler::audioStream>::const_iterator
! 			i(program.audioStreams.begin()); 
! 			i != program.audioStreams.end(); ++i)
! 				pids_to_record.insert(i->pid);
! 
! 		for (std::vector<eDVBServicePMTHandler::subtitleStream>::const_iterator
! 			i(program.subtitleStreams.begin());
! 			i != program.subtitleStreams.end(); ++i)
! 				pids_to_record.insert(i->pid);
! 
! 		std::set<int> new_pids, obsolete_pids;
! 		
! 		std::set_difference(pids_to_record.begin(), pids_to_record.end(), 
! 				m_pids_active.begin(), m_pids_active.end(),
! 				std::inserter(new_pids, new_pids.begin()));
! 		
! 		std::set_difference(
! 				m_pids_active.begin(), m_pids_active.end(),
! 				pids_to_record.begin(), pids_to_record.end(), 
! 				std::inserter(new_pids, new_pids.begin())
! 				);
! 
! 		if (m_record) {
! 			for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
! 				m_record->addPID(*i);
! 			for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
! 				m_record->removePID(*i);
! 		}
! 
! 		for (std::set<int>::iterator i(new_pids.begin()); i != new_pids.end(); ++i)
! 			m_player->addPID(*i);
! 		for (std::set<int>::iterator i(obsolete_pids.begin()); i != obsolete_pids.end(); ++i)
! 			m_player->removePID(*i);
! 	}
! }
! 
! RESULT eDVBServicePlay::setNextPlaybackFile(const char *f)
! {
! 	m_timeshift_file_next = f;
! 	return 0;
! }
! 
! void eDVBServicePlay::switchToLive()
! {
! 	if (!m_timeshift_active)
! 		return;
! 
! 	eDebug("SwitchToLive");
! 
! 	resetTimeshift(0);
! 
! 	m_is_paused = m_skipmode = m_fastforward = m_slowmotion = 0; /* not supported in live mode */
! 
! 	/* free the timeshift service handler, we need the resources */
! 	m_service_handler_timeshift.free();
! 
! 	updateDecoder(true);
! }
! 
! void eDVBServicePlay::resetTimeshift(int start)
! {
! 	m_cue = 0;
! 	m_decode_demux = 0;
! 	m_decoder = 0;
! 	m_teletext_parser = 0;
! 	m_rds_decoder = 0;
! 	m_subtitle_parser = 0;
! 	m_new_subtitle_page_connection = 0;
! 	m_new_dvb_subtitle_page_connection = 0;
! 	m_rds_decoder_event_connection = 0;
! 	m_timeshift_changed = 1;
! 	m_timeshift_file_next.clear();
! 
! 	if (start)
! 	{
! 		m_cue = new eCueSheet();
! 		m_timeshift_active = 1;
! 	}
! 	else
! 		m_timeshift_active = 0;
! }
! 
! ePtr<iTsSource> eDVBServicePlay::createTsSource(eServiceReferenceDVB &ref)
! {
! 	eRawFile *f = new eRawFile();
! 	f->open(ref.path.c_str());
! 	return ePtr<iTsSource>(f);
! }
! 
! void eDVBServicePlay::switchToTimeshift()
! {
! 	if (m_timeshift_active)
! 		return;
! 
! 	resetTimeshift(1);
! 
! 	eServiceReferenceDVB r = (eServiceReferenceDVB&)m_reference;
! 	r.path = m_timeshift_file;
! 
! 	m_cue->seekTo(0, -1000);
! 
! 	ePtr<iTsSource> source = createTsSource(r);
! 	m_service_handler_timeshift.tuneExt(r, 1, source, m_timeshift_file.c_str(), m_cue, 0, m_dvb_service); /* use the decoder demux for everything */
! 
! 	eDebug("eDVBServicePlay::switchToTimeshift, in pause mode now.");
! 	pause();
! 	updateDecoder(true); /* mainly to switch off PCR, and to set pause */
! }
! 
! void eDVBServicePlay::updateDecoder(bool sendSeekableStateChanged)
! {
! 	int vpid = -1, vpidtype = -1, pcrpid = -1, tpid = -1, achannel = -1, ac3_delay=-1, pcm_delay=-1;
! 	bool mustPlay = false;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 
! 	eDVBServicePMTHandler::program program;
! 	if (h.getProgramInfo(program))
! 		eDebug("getting program info failed.");
! 	else
! 	{
! 		eDebugNoNewLine("have %zd video stream(s)", program.videoStreams.size());
! 		if (!program.videoStreams.empty())
! 		{
! 			eDebugNoNewLine(" (");
! 			for (std::vector<eDVBServicePMTHandler::videoStream>::const_iterator
! 				i(program.videoStreams.begin());
! 				i != program.videoStreams.end(); ++i)
! 			{
! 				if (vpid == -1)
! 				{
! 					vpid = i->pid;
! 					vpidtype = i->type;
! 				}
! 				if (i != program.videoStreams.begin())
! 					eDebugNoNewLine(", ");
! 				eDebugNoNewLine("%04x", i->pid);
! 			}
! 			eDebugNoNewLine(")");
! 		}
! 		eDebugNoNewLine(", and %zd audio stream(s)", program.audioStreams.size());
! 		if (!program.audioStreams.empty())
! 		{
! 			eDebugNoNewLine(" (");
! 			for (std::vector<eDVBServicePMTHandler::audioStream>::const_iterator
! 				i(program.audioStreams.begin());
! 				i != program.audioStreams.end(); ++i)
! 			{
! 				if (i != program.audioStreams.begin())
! 					eDebugNoNewLine(", ");
! 				eDebugNoNewLine("%04x", i->pid);
! 			}
! 			eDebugNoNewLine(")");
! 		}
! 		eDebugNoNewLine(", and the pcr pid is %04x", program.pcrPid);
! 		pcrpid = program.pcrPid;
! 		eDebug(", and the text pid is %04x", program.textPid);
! 		tpid = program.textPid;
! 	}
! 
! 	if (!m_decoder)
! 	{
! 		m_decoder = new eTSMPEGDecoder(m_is_primary ? 0 : 1);
! 
! 		if (!m_is_pvr) {
! 			h.getDecodeDemux(m_decode_demux);
! 			if (m_decode_demux)
! 			{
! 				if (m_is_primary)
! 				{
! 					m_teletext_parser = new eDVBTeletextParser(m_decode_demux);
! 					m_teletext_parser->connectNewPage(slot(*this, &eDVBServicePlay::newSubtitlePage), m_new_subtitle_page_connection);
! 					m_subtitle_parser = new eDVBSubtitleParser(m_decode_demux);
! 					m_subtitle_parser->connectNewPage(slot(*this, &eDVBServicePlay::newDVBSubtitlePage), m_new_dvb_subtitle_page_connection);
! 					if (m_timeshift_changed)
! 					{
! 						ePyObject subs = getCachedSubtitle();
! 						if (subs != Py_None)
! 						{
! 							int type = PyInt_AsLong(PyTuple_GET_ITEM(subs, 0)),
! 							    pid = PyInt_AsLong(PyTuple_GET_ITEM(subs, 1)),
! 							    comp_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 2)), // ttx page
! 							    anc_page = PyInt_AsLong(PyTuple_GET_ITEM(subs, 3)); // ttx magazine
! 							if (type == 0) // dvb
! 								m_subtitle_parser->start(pid, comp_page, anc_page);
! 							else if (type == 1) // ttx
! 								m_teletext_parser->setPageAndMagazine(comp_page, anc_page);
! 						}
! 						Py_DECREF(subs);
! 					}
! 				}
! 			}
! 
! 			if (m_cue)
! 				m_cue->setDecodingDemux(m_decode_demux, m_decoder);
! 		}
! 
! 		mustPlay = true;
! 	}
! 
! 	m_timeshift_changed = 0;
! 
! 	if (m_decoder)
! 	{
! 		bool wasSeekable = m_decoder->getVideoProgressive() != -1;
! 		if (m_dvb_service)
! 		{
! 			achannel = m_dvb_service->getCacheEntry(eDVBService::cACHANNEL);
! 			ac3_delay = m_dvb_service->getCacheEntry(eDVBService::cAC3DELAY);
! 			pcm_delay = m_dvb_service->getCacheEntry(eDVBService::cPCMDELAY);
! 		}
! 		else // subservice
! 		{
! 			eServiceReferenceDVB ref;
! 			m_service_handler.getServiceReference(ref);
! 			eServiceReferenceDVB parent = ref.getParentServiceReference();
! 			if (!parent)
! 				parent = ref;
! 			if (parent)
! 			{
! 				ePtr<eDVBResourceManager> res_mgr;
! 				if (!eDVBResourceManager::getInstance(res_mgr))
! 				{
! 					ePtr<iDVBChannelList> db;
! 					if (!res_mgr->getChannelList(db))
! 					{
! 						ePtr<eDVBService> origService;
! 						if (!db->getService(parent, origService))
! 						{
! 		 					ac3_delay = origService->getCacheEntry(eDVBService::cAC3DELAY);
! 							pcm_delay = origService->getCacheEntry(eDVBService::cPCMDELAY);
! 						}
! 					}
! 				}
! 			}
! 		}
! 
! 		setAC3Delay(ac3_delay == -1 ? 0 : ac3_delay);
! 		setPCMDelay(pcm_delay == -1 ? 0 : pcm_delay);
! 
! 		m_decoder->setVideoPID(vpid, vpidtype);
! 		selectAudioStream();
! 
! 		if (!(m_is_pvr || m_timeshift_active || !m_is_primary))
! 			m_decoder->setSyncPCR(pcrpid);
! 		else
! 			m_decoder->setSyncPCR(-1);
! 
! 		if (m_is_primary && m_decode_demux && !m_is_pvr)
! 		{
! 			m_decoder->setTextPID(tpid);
! 			m_teletext_parser->start(program.textPid);
! 		}
! 
! 		if (vpid > 0 && vpid < 0x2000)
! 			;
! 		else
! 		{
! 			std::string radio_pic;
! 			if (!ePythonConfigQuery::getConfigValue("config.misc.radiopic", radio_pic))
! 				m_decoder->setRadioPic(radio_pic);
! 		}
! 
! 		printf("mustPlay %d\n", mustPlay);
! 		if (mustPlay)
! 			m_decoder->play();
! 		else
! 			m_decoder->set();
! 
! 		m_decoder->setAudioChannel(achannel);
! 
! 		/* don't worry about non-existing services, nor pvr services */
! 		if (m_dvb_service)
! 		{
! 				/* (audio pid will be set in selectAudioTrack */
! 			m_dvb_service->setCacheEntry(eDVBService::cVPID, vpid);
! 			m_dvb_service->setCacheEntry(eDVBService::cVTYPE, vpidtype == eDVBVideo::MPEG2 ? -1 : vpidtype);
! 			m_dvb_service->setCacheEntry(eDVBService::cPCRPID, pcrpid);
! 			m_dvb_service->setCacheEntry(eDVBService::cTPID, tpid);
! 		}
! 		if (!sendSeekableStateChanged && (m_decoder->getVideoProgressive() != -1) != wasSeekable)
! 			sendSeekableStateChanged = true;
! 	}
! 	m_have_video_pid = (vpid > 0 && vpid < 0x2000);
! 
! 	if (sendSeekableStateChanged)
! 		m_event((iPlayableService*)this, evSeekableStatusChanged);
! }
! 
! void eDVBServicePlay::loadCuesheet()
! {
! 	std::string filename = m_reference.path + ".cuts";
! 	
! 	m_cue_entries.clear();
! 
! 	FILE *f = fopen(filename.c_str(), "rb");
! 
! 	if (f)
! 	{
! 		eDebug("loading cuts..");
! 		while (1)
! 		{
! 			unsigned long long where;
! 			unsigned int what;
! 			
! 			if (!fread(&where, sizeof(where), 1, f))
! 				break;
! 			if (!fread(&what, sizeof(what), 1, f))
! 				break;
! 			
! #if BYTE_ORDER == LITTLE_ENDIAN
! 			where = bswap_64(where);
! #endif
! 			what = ntohl(what);
! 			
! 			if (what > 3)
! 				break;
! 			
! 			m_cue_entries.insert(cueEntry(where, what));
! 		}
! 		fclose(f);
! 		eDebug("%zd entries", m_cue_entries.size());
! 	} else
! 		eDebug("cutfile not found!");
! 	
! 	m_cuesheet_changed = 0;
! 	cutlistToCuesheet();
! 	m_event((iPlayableService*)this, evCuesheetChanged);
! }
! 
! void eDVBServicePlay::saveCuesheet()
! {
! 	std::string filename = m_reference.path + ".cuts";
! 	
! 	FILE *f = fopen(filename.c_str(), "wb");
! 
! 	if (f)
! 	{
! 		unsigned long long where;
! 		int what;
! 
! 		for (std::multiset<cueEntry>::iterator i(m_cue_entries.begin()); i != m_cue_entries.end(); ++i)
! 		{
! #if BYTE_ORDER == BIG_ENDIAN
! 			where = i->where;
! #else
! 			where = bswap_64(i->where);
! #endif
! 			what = htonl(i->what);
! 			fwrite(&where, sizeof(where), 1, f);
! 			fwrite(&what, sizeof(what), 1, f);
! 			
! 		}
! 		fclose(f);
! 	}
! 	
! 	m_cuesheet_changed = 0;
! }
! 
! void eDVBServicePlay::cutlistToCuesheet()
! {
! 	if (!m_cue)
! 	{
! 		eDebug("no cue sheet");
! 		return;
! 	}	
! 	m_cue->clear();
! 	
! 	if (!m_cutlist_enabled)
! 	{
! 		m_cue->commitSpans();
! 		eDebug("cutlists were disabled");
! 		return;
! 	}
! 
! 	pts_t in = 0, out = 0, length = 0;
! 	
! 	getLength(length);
! 		
! 	std::multiset<cueEntry>::iterator i(m_cue_entries.begin());
! 	
! 	int have_any_span = 0;
! 	
! 	while (1)
! 	{
! 		if (i == m_cue_entries.end())
! 		{
! 			if (!have_any_span && !in)
! 				break;
! 			out = length;
! 		} else {
! 			if (i->what == 0) /* in */
! 			{
! 				in = i++->where;
! 				continue;
! 			} else if (i->what == 1) /* out */
! 				out = i++->where;
! 			else /* mark (2) or last play position (3) */
! 			{
! 				i++;
! 				continue;
! 			}
! 		}
! 		
! 		if (in < 0)
! 			in = 0;
! 		if (out < 0)
! 			out = 0;
! 		if (in > length)
! 			in = length;
! 		if (out > length)
! 			out = length;
! 		
! 		if (in < out)
! 		{
! 			have_any_span = 1;
! 			m_cue->addSourceSpan(in, out);
! 			in = out = 0;
! 		}
! 		
! 		in = length;
! 		
! 		if (i == m_cue_entries.end())
! 			break;
! 	}
! 	m_cue->commitSpans();
! }
! 
! RESULT eDVBServicePlay::enableSubtitles(eWidget *parent, ePyObject tuple)
! {
! 	if (m_subtitle_widget)
! 		disableSubtitles(parent);
! 
! 	ePyObject entry;
! 	int tuplesize = PyTuple_Size(tuple);
! 	int type = 0;
! 
! 	if (!PyTuple_Check(tuple))
! 		goto error_out;
! 
! 	if (tuplesize < 1)
! 		goto error_out;
! 
! 	entry = PyTuple_GET_ITEM(tuple, 0);
! 
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 
! 	type = PyInt_AsLong(entry);
! 
! 	if (type == 1)  // teletext subtitles
! 	{
! 		int page, magazine, pid;
! 		if (tuplesize < 4)
! 			goto error_out;
! 
! 		if (!m_teletext_parser)
! 		{
! 			eDebug("enable teletext subtitles.. no parser !!!");
! 			return -1;
! 		}
! 
! 		entry = PyTuple_GET_ITEM(tuple, 1);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		pid = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 2);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		page = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 3);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		magazine = PyInt_AsLong(entry);
! 
! 		m_subtitle_widget = new eSubtitleWidget(parent);
! 		m_subtitle_widget->resize(parent->size()); /* full size */
! 		m_teletext_parser->setPageAndMagazine(page, magazine);
! 		if (m_dvb_service)
! 			m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE,((pid&0xFFFF)<<16)|((page&0xFF)<<8)|(magazine&0xFF));
! 	}
! 	else if (type == 0)
! 	{
! 		int pid = 0, composition_page_id = 0, ancillary_page_id = 0;
! 		if (!m_subtitle_parser)
! 		{
! 			eDebug("enable dvb subtitles.. no parser !!!");
! 			return -1;
! 		}
! 		if (tuplesize < 4)
! 			goto error_out;
! 
! 		entry = PyTuple_GET_ITEM(tuple, 1);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		pid = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 2);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		composition_page_id = PyInt_AsLong(entry);
! 
! 		entry = PyTuple_GET_ITEM(tuple, 3);
! 		if (!PyInt_Check(entry))
! 			goto error_out;
! 		ancillary_page_id = PyInt_AsLong(entry);
! 
! 		m_subtitle_widget = new eSubtitleWidget(parent);
! 		m_subtitle_widget->resize(parent->size()); /* full size */
! 		m_subtitle_parser->start(pid, composition_page_id, ancillary_page_id);
! 		if (m_dvb_service)
! 			m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE, ((pid&0xFFFF)<<16)|((composition_page_id&0xFF)<<8)|(ancillary_page_id&0xFF));
! 	}
! 	else
! 		goto error_out;
! 	return 0;
! error_out:
! 	eDebug("enableSubtitles needs a tuple as 2nd argument!\n"
! 		"for teletext subtitles (0, pid, teletext_page, teletext_magazine)\n"
! 		"for dvb subtitles (1, pid, composition_page_id, ancillary_page_id)");
! 	return -1;
! }
! 
! RESULT eDVBServicePlay::disableSubtitles(eWidget *parent)
! {
! 	delete m_subtitle_widget;
! 	m_subtitle_widget = 0;
! 	if (m_subtitle_parser)
! 	{
! 		m_subtitle_parser->stop();
! 		m_dvb_subtitle_pages.clear();
! 	}
! 	if (m_teletext_parser)
! 	{
! 		m_teletext_parser->setPageAndMagazine(-1, -1);
! 		m_subtitle_pages.clear();
! 	}
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cSUBTITLE, -1);
! 	return 0;
! }
! 
! PyObject *eDVBServicePlay::getCachedSubtitle()
! {
! 	if (m_dvb_service)
! 	{
! 		int tmp = m_dvb_service->getCacheEntry(eDVBService::cSUBTITLE);
! 		if (tmp != -1)
! 		{
! 			unsigned int data = (unsigned int)tmp;
! 			int pid = (data&0xFFFF0000)>>16;
! 			ePyObject tuple = PyTuple_New(4);
! 			eDVBServicePMTHandler::program program;
! 			eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 			if (!h.getProgramInfo(program))
! 			{
! 				if (program.textPid==pid) // teletext
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1)); // type teletext
! 				else
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0)); // type dvb
! 				PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(pid)); // pid
! 				PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong((data&0xFF00)>>8)); // composition_page / page
! 				PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(data&0xFF)); // ancillary_page / magazine
! 				return tuple;
! 			}
! 		}
! 	}
! 	Py_RETURN_NONE;
! }
! 
! PyObject *eDVBServicePlay::getSubtitleList()
! {
! 	if (!m_teletext_parser)
! 		Py_RETURN_NONE;
! 	
! 	ePyObject l = PyList_New(0);
! 	std::set<int> added_ttx_pages;
! 
! 	std::set<eDVBServicePMTHandler::subtitleStream> &subs =
! 		m_teletext_parser->m_found_subtitle_pages;
! 
! 	eDVBServicePMTHandler &h = m_timeshift_active ? m_service_handler_timeshift : m_service_handler;
! 	eDVBServicePMTHandler::program program;
! 	if (h.getProgramInfo(program))
! 		eDebug("getting program info failed.");
! 	else
! 	{
! 		for (std::vector<eDVBServicePMTHandler::subtitleStream>::iterator it(program.subtitleStreams.begin());
! 			it != program.subtitleStreams.end(); ++it)
! 		{
! 			switch(it->subtitling_type)
! 			{
! 				case 0x01: // ebu teletext subtitles
! 				{
! 					int page_number = it->teletext_page_number & 0xFF;
! 					int magazine_number = it->teletext_magazine_number & 7;
! 					int hash = magazine_number << 8 | page_number;
! 					if (added_ttx_pages.find(hash) == added_ttx_pages.end())
! 					{
! 						ePyObject tuple = PyTuple_New(5);
! 						PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1));
! 						PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 						PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(page_number));
! 						PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(magazine_number));
! 						PyTuple_SET_ITEM(tuple, 4, PyString_FromString(it->language_code.c_str()));
! 						PyList_Append(l, tuple);
! 						Py_DECREF(tuple);
! 						added_ttx_pages.insert(hash);
! 					}
! 					break;
! 				}
! 				case 0x10 ... 0x13:
! 				case 0x20 ... 0x23: // dvb subtitles
! 				{
! 					ePyObject tuple = PyTuple_New(5);
! 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0));
! 					PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 					PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(it->composition_page_id));
! 					PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(it->ancillary_page_id));
! 					PyTuple_SET_ITEM(tuple, 4, PyString_FromString(it->language_code.c_str()));
! 					PyList_Insert(l, 0, tuple);
! 					Py_DECREF(tuple);
! 					break;
! 				}
! 			}
! 		}
! 	}
! 
! 	for (std::set<eDVBServicePMTHandler::subtitleStream>::iterator it(subs.begin());
! 		it != subs.end(); ++it)
! 	{
! 		int page_number = it->teletext_page_number & 0xFF;
! 		int magazine_number = it->teletext_magazine_number & 7;
! 		int hash = magazine_number << 8 | page_number;
! 		if (added_ttx_pages.find(hash) == added_ttx_pages.end())
! 		{
! 			ePyObject tuple = PyTuple_New(5);
! 			PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(1));
! 			PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(it->pid));
! 			PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(page_number));
! 			PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(magazine_number));
! 			PyTuple_SET_ITEM(tuple, 4, PyString_FromString("und"));  // undetermined
! 			PyList_Append(l, tuple);
! 			Py_DECREF(tuple);
! 		}
! 	}
! 
! 	return l;
! }
! 
! void eDVBServicePlay::newSubtitlePage(const eDVBTeletextSubtitlePage &page)
! {
! 	if (m_subtitle_widget)
! 	{
! 		pts_t pos = 0;
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 		eDebug("got new subtitle page %lld %lld %d", pos, page.m_pts, page.m_have_pts);
! 		m_subtitle_pages.push_back(page);
! 		checkSubtitleTiming();
! 	}
! }
! 
! void eDVBServicePlay::checkSubtitleTiming()
! {
! 	eDebug("checkSubtitleTiming");
! 	if (!m_subtitle_widget)
! 		return;
! 	while (1)
! 	{
! 		enum { TELETEXT, DVB } type;
! 		eDVBTeletextSubtitlePage page;
! 		eDVBSubtitlePage dvb_page;
! 		pts_t show_time;
! 		if (!m_subtitle_pages.empty())
! 		{
! 			page = m_subtitle_pages.front();
! 			type = TELETEXT;
! 			show_time = page.m_pts;
! 		}
! 		else if (!m_dvb_subtitle_pages.empty())
! 		{
! 			dvb_page = m_dvb_subtitle_pages.front();
! 			type = DVB;
! 			show_time = dvb_page.m_show_time;
! 		}
! 		else
! 			return;
! 	
! 		pts_t pos = 0;
! 	
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 
! 		eDebug("%lld %lld", pos, show_time);
! 		int diff = show_time - pos;
! 		if (type == TELETEXT && !page.m_have_pts)
! 		{
! 			eDebug("ttx subtitle page without pts... immediate show");
! 			diff = 0;
! 		}
! 		if (diff < 0)
! 		{
! 			eDebug("[late (%d ms)]", -diff / 90);
! 			diff = 0;
! 		}
! 		if (abs(diff) > 1800000)
! 		{
! 			eDebug("[invalid]... immediate show!");
! 			diff = 0;
! 		}
! 		if ((diff/90)<20)
! 		{
! 			if (type == TELETEXT)
! 			{
! 				eDebug("display teletext subtitle page %lld", show_time);
! 				m_subtitle_widget->setPage(page);
! 				m_subtitle_pages.pop_front();
! 			}
! 			else
! 			{
! 				eDebug("display dvb subtitle Page %lld", show_time);
! 				m_subtitle_widget->setPage(dvb_page);
! 				m_dvb_subtitle_pages.pop_front();
! 			}
! 		} else
! 		{
! 			eDebug("start subtitle delay %d", diff / 90);
! 			m_subtitle_sync_timer->start(diff / 90, 1);
! 			break;
! 		}
! 	}
! }
! 
! void eDVBServicePlay::newDVBSubtitlePage(const eDVBSubtitlePage &p)
! {
! 	if (m_subtitle_widget)
! 	{
! 		pts_t pos = 0;
! 		//if (m_decoder)
! 		//	m_decoder->getPTS(0, pos);
! 		xineLib->getPTS(pos);
! 		eDebug("got new subtitle page %lld %lld", pos, p.m_show_time);
! 		m_dvb_subtitle_pages.push_back(p);
! 		checkSubtitleTiming();
! 	}
! }
! 
! int eDVBServicePlay::getAC3Delay()
! {
! 	if (m_dvb_service)
! 		return m_dvb_service->getCacheEntry(eDVBService::cAC3DELAY);
! 	else if (m_decoder)
! 		return m_decoder->getAC3Delay();
! 	else
! 		return 0;
! }
! 
! int eDVBServicePlay::getPCMDelay()
! {
! 	if (m_dvb_service)
! 		return m_dvb_service->getCacheEntry(eDVBService::cPCMDELAY);
! 	else if (m_decoder)
! 		return m_decoder->getPCMDelay();
! 	else
! 		return 0;
! }
! 
! void eDVBServicePlay::setAC3Delay(int delay)
! {
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cAC3DELAY, delay ? delay : -1);
! 	if (m_decoder) {
! 		std::string config_delay;
! 		int config_delay_int = 0;
! 		if(ePythonConfigQuery::getConfigValue("config.av.generalAC3delay", config_delay) == 0)
! 			config_delay_int = atoi(config_delay.c_str());
! 		m_decoder->setAC3Delay(delay + config_delay_int);
! 	}
! }
! 
! void eDVBServicePlay::setPCMDelay(int delay)
! {
! 	if (m_dvb_service)
! 		m_dvb_service->setCacheEntry(eDVBService::cPCMDELAY, delay ? delay : -1);
! 	if (m_decoder) {
! 		std::string config_delay;
! 		int config_delay_int = 0;
! 		if(ePythonConfigQuery::getConfigValue("config.av.generalPCMdelay", config_delay) == 0)
! 			config_delay_int = atoi(config_delay.c_str());
! 		else
! 			config_delay_int = 0;
! 		m_decoder->setPCMDelay(delay + config_delay_int);
! 	}
! }
! 
! void eDVBServicePlay::video_event(struct iTSMPEGDecoder::videoEvent event)
! {
! 	switch(event.type) {
! 		case iTSMPEGDecoder::videoEvent::eventSizeChanged:
! 			m_event((iPlayableService*)this, evVideoSizeChanged);
! 			break;
! 		case iTSMPEGDecoder::videoEvent::eventFrameRateChanged:
! 			m_event((iPlayableService*)this, evVideoFramerateChanged);
! 			break;
! 		case iTSMPEGDecoder::videoEvent::eventProgressiveChanged:
! 			m_event((iPlayableService*)this, evVideoProgressiveChanged);
! 			break;
! 		default:
! 			break;
! 	}
! }
! 
! RESULT eDVBServicePlay::stream(ePtr<iStreamableService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! PyObject *eDVBServicePlay::getStreamingData()
! {
! 	eDVBServicePMTHandler::program program;
! 	if (m_service_handler.getProgramInfo(program))
! 	{
! 		Py_RETURN_NONE;
! 	}
! 
! 	ePyObject r = program.createPythonObject();
! 	ePtr<iDVBDemux> demux;
! 	if (!m_service_handler.getDataDemux(demux))
! 	{
! 		uint8_t demux_id;
! 		if (!demux->getCADemuxID(demux_id))
! 			PutToDict(r, "demux", demux_id);
! 	}
! 
! 	return r;
! }
! 
! 
! DEFINE_REF(eDVBServicePlay)
! 
! PyObject *eDVBService::getInfoObject(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sTransponderData:
! 		return eStaticServiceDVBInformation().getInfoObject(ref, w);
! 	default:
! 		break;
! 	}
! 	return iStaticServiceInformation::getInfoObject(ref, w);
! }
! 
! eAutoInitPtr<eServiceFactoryDVB> init_eServiceFactoryDVB(eAutoInitNumbers::service+1, "eServiceFactoryDVB");
diff -crB Enigma2PC/lib/service/servicemp3.cpp Enigma2PC_orig/lib/service/servicemp3.cpp
*** Enigma2PC/lib/service/servicemp3.cpp	2011-11-20 21:56:11.260830302 +0400
--- Enigma2PC_orig/lib/service/servicemp3.cpp	2011-11-20 03:56:00.000000000 +0400
***************
*** 1,1964 ****
! 	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
! 	/* it's currently hardcoded to use a big-endian alsasink as sink. */
! #include <lib/base/ebase.h>
! #include <lib/base/eerror.h>
! #include <lib/base/init_num.h>
! #include <lib/base/init.h>
! #include <lib/base/nconfig.h>
! #include <lib/base/object.h>
! #include <lib/dvb/decoder.h>
! #include <lib/components/file_eraser.h>
! #include <lib/gui/esubtitle.h>
! #include <lib/service/servicemp3.h>
! #include <lib/service/service.h>
! #include <lib/gdi/gpixmap.h>
! 
! #include <string>
! 
! #include <gst/gst.h>
! #include <gst/pbutils/missing-plugins.h>
! #include <sys/stat.h>
! 
! #define HTTP_TIMEOUT 10
! 
! // eServiceFactoryMP3
! 
! eServiceFactoryMP3::eServiceFactoryMP3()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 	{
! 		std::list<std::string> extensions;
! 		extensions.push_back("mp2");
! 		extensions.push_back("mp3");
! 		extensions.push_back("ogg");
! 		extensions.push_back("mpg");
! 		extensions.push_back("vob");
! 		extensions.push_back("wav");
! 		extensions.push_back("wave");
! 		extensions.push_back("m4v");
! 		extensions.push_back("mkv");
! 		extensions.push_back("avi");
! 		extensions.push_back("divx");
! 		extensions.push_back("dat");
! 		extensions.push_back("flac");
! 		extensions.push_back("mp4");
! 		extensions.push_back("mov");
! 		extensions.push_back("m4a");
! 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
! 	}
! 
! 	m_service_info = new eStaticServiceMP3Info();
! }
! 
! eServiceFactoryMP3::~eServiceFactoryMP3()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 		sc->removeServiceFactory(eServiceFactoryMP3::id);
! }
! 
! DEFINE_REF(eServiceFactoryMP3)
! 
! 	// iServiceHandler
! RESULT eServiceFactoryMP3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
! {
! 		// check resources...
! 	ptr = new eServiceMP3(ref);
! 	return 0;
! }
! 
! RESULT eServiceFactoryMP3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
! {
! 	ptr=0;
! 	return -1;
! }
! 
! RESULT eServiceFactoryMP3::list(const eServiceReference &, ePtr<iListableService> &ptr)
! {
! 	ptr=0;
! 	return -1;
! }
! 
! RESULT eServiceFactoryMP3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
! {
! 	ptr = m_service_info;
! 	return 0;
! }
! 
! class eMP3ServiceOfflineOperations: public iServiceOfflineOperations
! {
! 	DECLARE_REF(eMP3ServiceOfflineOperations);
! 	eServiceReference m_ref;
! public:
! 	eMP3ServiceOfflineOperations(const eServiceReference &ref);
! 	
! 	RESULT deleteFromDisk(int simulate);
! 	RESULT getListOfFilenames(std::list<std::string> &);
! 	RESULT reindex();
! };
! 
! DEFINE_REF(eMP3ServiceOfflineOperations);
! 
! eMP3ServiceOfflineOperations::eMP3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
! {
! }
! 
! RESULT eMP3ServiceOfflineOperations::deleteFromDisk(int simulate)
! {
! 	if (simulate)
! 		return 0;
! 	else
! 	{
! 		std::list<std::string> res;
! 		if (getListOfFilenames(res))
! 			return -1;
! 		
! 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
! 		if (!eraser)
! 			eDebug("FATAL !! can't get background file eraser");
! 		
! 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
! 		{
! 			eDebug("Removing %s...", i->c_str());
! 			if (eraser)
! 				eraser->erase(i->c_str());
! 			else
! 				::unlink(i->c_str());
! 		}
! 		
! 		return 0;
! 	}
! }
! 
! RESULT eMP3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
! {
! 	res.clear();
! 	res.push_back(m_ref.path);
! 	return 0;
! }
! 
! RESULT eMP3ServiceOfflineOperations::reindex()
! {
! 	return -1;
! }
! 
! 
! RESULT eServiceFactoryMP3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
! {
! 	ptr = new eMP3ServiceOfflineOperations(ref);
! 	return 0;
! }
! 
! // eStaticServiceMP3Info
! 
! 
! // eStaticServiceMP3Info is seperated from eServiceMP3 to give information
! // about unopened files.
! 
! // probably eServiceMP3 should use this class as well, and eStaticServiceMP3Info
! // should have a database backend where ID3-files etc. are cached.
! // this would allow listing the mp3 database based on certain filters.
! 
! DEFINE_REF(eStaticServiceMP3Info)
! 
! eStaticServiceMP3Info::eStaticServiceMP3Info()
! {
! }
! 
! RESULT eStaticServiceMP3Info::getName(const eServiceReference &ref, std::string &name)
! {
! 	if ( ref.name.length() )
! 		name = ref.name;
! 	else
! 	{
! 		size_t last = ref.path.rfind('/');
! 		if (last != std::string::npos)
! 			name = ref.path.substr(last+1);
! 		else
! 			name = ref.path;
! 	}
! 	return 0;
! }
! 
! int eStaticServiceMP3Info::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! int eStaticServiceMP3Info::getInfo(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sTimeCreate:
! 	{
! 		struct stat s;
! 		if(stat(ref.path.c_str(), &s) == 0)
! 		{
! 		  return s.st_mtime;
! 		}
! 		return iServiceInformation::resNA;
! 	}
! 	default: break;
! 	}
! 	return iServiceInformation::resNA;
! }
!  
! 
! // eServiceMP3
! int eServiceMP3::ac3_delay,
!     eServiceMP3::pcm_delay;
! 
! eServiceMP3::eServiceMP3(eServiceReference ref)
! 	:m_ref(ref), m_pump(eApp, 1)
! {
! 	m_seekTimeout = eTimer::create(eApp);
! 	m_subtitle_sync_timer = eTimer::create(eApp);
! 	m_streamingsrc_timeout = 0;
! 	m_stream_tags = 0;
! 	m_currentAudioStream = -1;
! 	m_currentSubtitleStream = 0;
! 	m_subtitle_widget = 0;
! 	m_currentTrickRatio = 0;
! 	m_subs_to_pull = 0;
! 	m_buffer_size = 1*1024*1024;
! 	m_prev_decoder_time = -1;
! 	m_decoder_time_valid_state = 0;
! 	m_errorInfo.missing_codec = "";
! 
! 	CONNECT(m_seekTimeout->timeout, eServiceMP3::seekTimeoutCB);
! 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
! 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
! 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
! 
! 	m_state = stIdle;
! 	eDebug("eServiceMP3::construct!");
! 
! 	const char *filename = m_ref.path.c_str();
! 	const char *ext = strrchr(filename, '.');
! 	if (!ext)
! 		ext = filename;
! 
! 	m_sourceinfo.is_video = FALSE;
! 	m_sourceinfo.audiotype = atUnknown;
! 	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
! 	{
! 		m_sourceinfo.containertype = ctMPEGPS;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	else if ( strcasecmp(ext, ".ts") == 0 )
! 	{
! 		m_sourceinfo.containertype = ctMPEGTS;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	else if ( strcasecmp(ext, ".mkv") == 0 )
! 	{
! 		m_sourceinfo.containertype = ctMKV;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	else if ( strcasecmp(ext, ".avi") == 0 || strcasecmp(ext, ".divx") == 0)
! 	{
! 		m_sourceinfo.containertype = ctAVI;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	else if ( strcasecmp(ext, ".mp4") == 0 || strcasecmp(ext, ".mov") == 0 || strcasecmp(ext, ".m4v") == 0)
! 	{
! 		m_sourceinfo.containertype = ctMP4;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	else if ( strcasecmp(ext, ".m4a") == 0 )
! 	{
! 		m_sourceinfo.containertype = ctMP4;
! 		m_sourceinfo.audiotype = atAAC;
! 	}
! 	else if ( strcasecmp(ext, ".mp3") == 0 )
! 		m_sourceinfo.audiotype = atMP3;
! 	else if ( (strncmp(filename, "/autofs/", 8) || strncmp(filename+strlen(filename)-13, "/track-", 7) || strcasecmp(ext, ".wav")) == 0 )
! 		m_sourceinfo.containertype = ctCDA;
! 	if ( strcasecmp(ext, ".dat") == 0 )
! 	{
! 		m_sourceinfo.containertype = ctVCD;
! 		m_sourceinfo.is_video = TRUE;
! 	}
! 	if ( strstr(filename, "://") )
! 		m_sourceinfo.is_streaming = TRUE;
! 
! 	gchar *uri;
! 
! 	if ( m_sourceinfo.is_streaming )
! 	{
! 		uri = g_strdup_printf ("%s", filename);
! 		m_streamingsrc_timeout = eTimer::create(eApp);;
! 		CONNECT(m_streamingsrc_timeout->timeout, eServiceMP3::sourceTimeout);
! 
! 		std::string config_str;
! 		if( ePythonConfigQuery::getConfigValue("config.mediaplayer.useAlternateUserAgent", config_str) == 0 )
! 		{
! 			if ( config_str == "True" )
! 				ePythonConfigQuery::getConfigValue("config.mediaplayer.alternateUserAgent", m_useragent);
! 		}
! 		if ( m_useragent.length() == 0 )
! 			m_useragent = "Dream Multimedia Dreambox Enigma2 Mediaplayer";
! 	}
! 	else if ( m_sourceinfo.containertype == ctCDA )
! 	{
! 		int i_track = atoi(filename+18);
! 		uri = g_strdup_printf ("cdda://%i", i_track);
! 	}
! 	else if ( m_sourceinfo.containertype == ctVCD )
! 	{
! 		int fd = open(filename,O_RDONLY);
! 		char tmp[128*1024];
! 		int ret = read(fd, tmp, 128*1024);
! 		close(fd);
! 		if ( ret == -1 ) // this is a "REAL" VCD
! 			uri = g_strdup_printf ("vcd://");
! 		else
! 			uri = g_filename_to_uri(filename, NULL, NULL);
! 	}
! 	else
! 
! 		uri = g_filename_to_uri(filename, NULL, NULL);
! 
! 	eDebug("eServiceMP3::playbin2 uri=%s", uri);
! 
! 	m_gst_playbin = gst_element_factory_make("playbin2", "playbin");
! 	if (!m_gst_playbin)
! 		m_errorInfo.error_message = "failed to create GStreamer pipeline!\n";
! 
! 	g_object_set (G_OBJECT (m_gst_playbin), "uri", uri, NULL);
! 
! 	int flags = 0x47; // ( GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_TEXT );
! 	g_object_set (G_OBJECT (m_gst_playbin), "flags", flags, NULL);
! 
! 	g_free(uri);
! 
! 	GstElement *subsink = gst_element_factory_make("appsink", "subtitle_sink");
! 	if (!subsink)
! 		eDebug("eServiceMP3::sorry, can't play: missing gst-plugin-appsink");
! 	else
! 	{
! 		m_subs_to_pull_handler_id = g_signal_connect (subsink, "new-buffer", G_CALLBACK (gstCBsubtitleAvail), this);
! 		g_object_set (G_OBJECT (subsink), "caps", gst_caps_from_string("text/plain; text/x-plain; text/x-pango-markup; video/x-dvd-subpicture; subpicture/x-pgs"), NULL);
! 		g_object_set (G_OBJECT (m_gst_playbin), "text-sink", subsink, NULL);
! 		
! 	}
! 
! 	if ( m_gst_playbin )
! 	{
! 		gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), gstBusSyncHandler, this);
! 		char srt_filename[strlen(filename)+1];
! 		strncpy(srt_filename,filename,strlen(filename)-3);
! 		srt_filename[strlen(filename)-3]='\0';
! 		strcat(srt_filename, "srt");
! 		struct stat buffer;
! 		if (stat(srt_filename, &buffer) == 0)
! 		{
! 			eDebug("eServiceMP3::subtitle uri: %s", g_filename_to_uri(srt_filename, NULL, NULL));
! 			g_object_set (G_OBJECT (m_gst_playbin), "suburi", g_filename_to_uri(srt_filename, NULL, NULL), NULL);
! 		}
! 		if ( m_sourceinfo.is_streaming )
! 		{
! 			g_signal_connect (G_OBJECT (m_gst_playbin), "notify::source", G_CALLBACK (gstHTTPSourceSetAgent), this);
! 		}
! 	} else
! 	{
! 		m_event((iPlayableService*)this, evUser+12);
! 
! 		if (m_gst_playbin)
! 			gst_object_unref(GST_OBJECT(m_gst_playbin));
! 
! 		eDebug("eServiceMP3::sorry, can't play: %s",m_errorInfo.error_message.c_str());
! 		m_gst_playbin = 0;
! 	}
! 
! 	setBufferSize(m_buffer_size);
! }
! 
! eServiceMP3::~eServiceMP3()
! {
! 	// disconnect subtitle callback
! 	GstElement *appsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
! 
! 	if (appsink)
! 	{
! 		g_signal_handler_disconnect (appsink, m_subs_to_pull_handler_id);
! 		gst_object_unref(appsink);
! 	}
! 
! 	delete m_subtitle_widget;
! 
! 	// disconnect sync handler callback
! 	gst_bus_set_sync_handler(gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin)), NULL, NULL);
! 
! 	if (m_state == stRunning)
! 		stop();
! 
! 	if (m_stream_tags)
! 		gst_tag_list_free(m_stream_tags);
! 	
! 	if (m_gst_playbin)
! 	{
! 		gst_object_unref (GST_OBJECT (m_gst_playbin));
! 		eDebug("eServiceMP3::destruct!");
! 	}
! }
! 
! DEFINE_REF(eServiceMP3);
! 
! RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
! {
! 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
! 	return 0;
! }
! 
! RESULT eServiceMP3::start()
! {
! 	ASSERT(m_state == stIdle);
! 
! 	m_state = stRunning;
! 	if (m_gst_playbin)
! 	{
! 		eDebug("eServiceMP3::starting pipeline");
! 		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
! 	}
! 
! 	m_event(this, evStart);
! 
! 	return 0;
! }
! 
! void eServiceMP3::sourceTimeout()
! {
! 	eDebug("eServiceMP3::http source timeout! issuing eof...");
! 	m_event((iPlayableService*)this, evEOF);
! }
! 
! RESULT eServiceMP3::stop()
! {
! 	ASSERT(m_state != stIdle);
! 
! 	if (m_state == stStopped)
! 		return -1;
! 	
! 	//GST_DEBUG_BIN_TO_DOT_FILE(GST_BIN(m_gst_playbin),GST_DEBUG_GRAPH_SHOW_ALL,"e2-playbin");
! 
! 	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
! 	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
! 	m_state = stStopped;
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::setTarget(int target)
! {
! 	return -1;
! }
! 
! RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
! {
! 	ptr=this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::setSlowMotion(int ratio)
! {
! 	if (!ratio)
! 		return 0;
! 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1/(float)ratio);
! 	return trickSeek(1/(float)ratio);
! }
! 
! RESULT eServiceMP3::setFastForward(int ratio)
! {
! 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
! 	return trickSeek(ratio);
! }
! 
! void eServiceMP3::seekTimeoutCB()
! {
! 	pts_t ppos, len;
! 	getPlayPosition(ppos);
! 	getLength(len);
! 	ppos += 90000*m_currentTrickRatio;
! 	
! 	if (ppos < 0)
! 	{
! 		ppos = 0;
! 		m_seekTimeout->stop();
! 	}
! 	if (ppos > len)
! 	{
! 		ppos = 0;
! 		stop();
! 		m_seekTimeout->stop();
! 		return;
! 	}
! 	seekTo(ppos);
! }
! 
! 		// iPausableService
! RESULT eServiceMP3::pause()
! {
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return -1;
! 
! 	gst_element_set_state(m_gst_playbin, GST_STATE_PAUSED);
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::unpause()
! {
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return -1;
! 
! 	gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
! 
! 	return 0;
! }
! 
! 	/* iSeekableService */
! RESULT eServiceMP3::seek(ePtr<iSeekableService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::getLength(pts_t &pts)
! {
! 	if (!m_gst_playbin)
! 		return -1;
! 
! 	if (m_state != stRunning)
! 		return -1;
! 
! 	GstFormat fmt = GST_FORMAT_TIME;
! 	gint64 len;
! 	
! 	if (!gst_element_query_duration(m_gst_playbin, &fmt, &len))
! 		return -1;
! 		/* len is in nanoseconds. we have 90 000 pts per second. */
! 	
! 	pts = len / 11111;
! 	return 0;
! }
! 
! RESULT eServiceMP3::seekToImpl(pts_t to)
! {
! 		/* convert pts to nanoseconds */
! 	gint64 time_nanoseconds = to * 11111LL;
! 	if (!gst_element_seek (m_gst_playbin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
! 		GST_SEEK_TYPE_SET, time_nanoseconds,
! 		GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))
! 	{
! 		eDebug("eServiceMP3::seekTo failed");
! 		return -1;
! 	}
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::seekTo(pts_t to)
! {
! 	RESULT ret = -1;
! 
! 	if (m_gst_playbin) {
! 		eSingleLocker l(m_subs_to_pull_lock); // this is needed to dont handle incomming subtitles during seek!
! 		if (!(ret = seekToImpl(to)))
! 		{
! 			m_subtitle_pages.clear();
! 			m_prev_decoder_time = -1;
! 			m_decoder_time_valid_state = 0;
! 			m_subs_to_pull = 0;
! 		}
! 	}
! 
! 	return ret;
! }
! 
! 
! RESULT eServiceMP3::trickSeek(gdouble ratio)
! {
! 	if (!m_gst_playbin)
! 		return -1;
! 	if (!ratio)
! 		return seekRelative(0, 0);
! 
! 	GstEvent *s_event;
! 	int flags;
! 	flags = GST_SEEK_FLAG_NONE;
! 	flags |= GST_SEEK_FLAG_FLUSH;
! // 	flags |= GstSeekFlags (GST_SEEK_FLAG_ACCURATE);
! 	flags |= GST_SEEK_FLAG_KEY_UNIT;
! // 	flags |= GstSeekFlags (GST_SEEK_FLAG_SEGMENT);
! // 	flags |= GstSeekFlags (GST_SEEK_FLAG_SKIP);
! 
! 	GstFormat fmt = GST_FORMAT_TIME;
! 	gint64 pos, len;
! 	gst_element_query_duration(m_gst_playbin, &fmt, &len);
! 	gst_element_query_position(m_gst_playbin, &fmt, &pos);
! 
! 	if ( ratio >= 0 )
! 	{
! 		s_event = gst_event_new_seek (ratio, GST_FORMAT_TIME, (GstSeekFlags)flags, GST_SEEK_TYPE_SET, pos, GST_SEEK_TYPE_SET, len);
! 
! 		eDebug("eServiceMP3::trickSeek with rate %lf to %" GST_TIME_FORMAT " ", ratio, GST_TIME_ARGS (pos));
! 	}
! 	else
! 	{
! 		s_event = gst_event_new_seek (ratio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_SKIP|GST_SEEK_FLAG_FLUSH), GST_SEEK_TYPE_NONE, -1, GST_SEEK_TYPE_NONE, -1);
! 	}
! 
! 	if (!gst_element_send_event ( GST_ELEMENT (m_gst_playbin), s_event))
! 	{
! 		eDebug("eServiceMP3::trickSeek failed");
! 		return -1;
! 	}
! 
! 	return 0;
! }
! 
! 
! RESULT eServiceMP3::seekRelative(int direction, pts_t to)
! {
! 	if (!m_gst_playbin)
! 		return -1;
! 
! 	pts_t ppos;
! 	getPlayPosition(ppos);
! 	ppos += to * direction;
! 	if (ppos < 0)
! 		ppos = 0;
! 	seekTo(ppos);
! 	
! 	return 0;
! }
! 
! RESULT eServiceMP3::getPlayPosition(pts_t &pts)
! {
! 	GstFormat fmt = GST_FORMAT_TIME;
! 	gint64 pos;
! 	GstElement *sink;
! 	pts = 0;
! 
! 	if (!m_gst_playbin)
! 		return -1;
! 	if (m_state != stRunning)
! 		return -1;
! 
! 	g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 
! 	if (!sink)
! 		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 	if (!sink)
! 		return -1;
! 
! 	gchar *name = gst_element_get_name(sink);
! 	gboolean use_get_decoder_time = strstr(name, "dvbaudiosink") || strstr(name, "dvbvideosink");
! 	g_free(name);
! 
! 	if (use_get_decoder_time)
! 		g_signal_emit_by_name(sink, "get-decoder-time", &pos);
! 
! 	gst_object_unref(sink);
! 
! 	if (!use_get_decoder_time && !gst_element_query_position(m_gst_playbin, &fmt, &pos)) {
! 		eDebug("gst_element_query_position failed in getPlayPosition");
! 		return -1;
! 	}
! 
! 	/* pos is in nanoseconds. we have 90 000 pts per second. */
! 	pts = pos / 11111;
! // 	eDebug("gst_element_query_position %lld pts (%lld ms)", pts, pos/1000000);
! 	return 0;
! }
! 
! RESULT eServiceMP3::setTrickmode(int trick)
! {
! 		/* trickmode is not yet supported by our dvbmediasinks. */
! 	return -1;
! }
! 
! RESULT eServiceMP3::isCurrentlySeekable()
! {
! 	int ret = 3; // seeking and fast/slow winding possible
! 	GstElement *sink;
! 
! 	if (!m_gst_playbin)
! 		return 0;
! 	if (m_state != stRunning)
! 		return 0;
! 
! 	g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 	// disable fast winding yet when a dvbvideosink or dvbaudiosink is used
! 	// for this we must do some changes on different places.. (gstreamer.. our sinks.. enigma2)
! 	if (sink) {
! 		ret &= ~2; // only seeking possible
! 		gst_object_unref(sink);
! 	}
! 	else {
! 		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 		if (sink) {
! 			ret &= ~2; // only seeking possible
! 			gst_object_unref(sink);
! 		}
! 	}
! 
! 	return ret;
! }
! 
! RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
! {
! 	i = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::getName(std::string &name)
! {
! 	std::string title = m_ref.getName();
! 	if (title.empty())
! 	{
! 		name = m_ref.path;
! 		size_t n = name.rfind('/');
! 		if (n != std::string::npos)
! 			name = name.substr(n + 1);
! 	}
! 	else
! 		name = title;
! 	return 0;
! }
! 
! int eServiceMP3::getInfo(int w)
! {
! 	const gchar *tag = 0;
! 
! 	switch (w)
! 	{
! 	case sServiceref: return m_ref;
! 	case sVideoHeight: return m_height;
! 	case sVideoWidth: return m_width;
! 	case sFrameRate: return m_framerate;
! 	case sProgressive: return m_progressive;
! 	case sAspect: return m_aspect;
! 	case sTagTitle:
! 	case sTagArtist:
! 	case sTagAlbum:
! 	case sTagTitleSortname:
! 	case sTagArtistSortname:
! 	case sTagAlbumSortname:
! 	case sTagDate:
! 	case sTagComposer:
! 	case sTagGenre:
! 	case sTagComment:
! 	case sTagExtendedComment:
! 	case sTagLocation:
! 	case sTagHomepage:
! 	case sTagDescription:
! 	case sTagVersion:
! 	case sTagISRC:
! 	case sTagOrganization:
! 	case sTagCopyright:
! 	case sTagCopyrightURI:
! 	case sTagContact:
! 	case sTagLicense:
! 	case sTagLicenseURI:
! 	case sTagCodec:
! 	case sTagAudioCodec:
! 	case sTagVideoCodec:
! 	case sTagEncoder:
! 	case sTagLanguageCode:
! 	case sTagKeywords:
! 	case sTagChannelMode:
! 	case sUser+12:
! 		return resIsString;
! 	case sTagTrackGain:
! 	case sTagTrackPeak:
! 	case sTagAlbumGain:
! 	case sTagAlbumPeak:
! 	case sTagReferenceLevel:
! 	case sTagBeatsPerMinute:
! 	case sTagImage:
! 	case sTagPreviewImage:
! 	case sTagAttachment:
! 		return resIsPyObject;
! 	case sTagTrackNumber:
! 		tag = GST_TAG_TRACK_NUMBER;
! 		break;
! 	case sTagTrackCount:
! 		tag = GST_TAG_TRACK_COUNT;
! 		break;
! 	case sTagAlbumVolumeNumber:
! 		tag = GST_TAG_ALBUM_VOLUME_NUMBER;
! 		break;
! 	case sTagAlbumVolumeCount:
! 		tag = GST_TAG_ALBUM_VOLUME_COUNT;
! 		break;
! 	case sTagBitrate:
! 		tag = GST_TAG_BITRATE;
! 		break;
! 	case sTagNominalBitrate:
! 		tag = GST_TAG_NOMINAL_BITRATE;
! 		break;
! 	case sTagMinimumBitrate:
! 		tag = GST_TAG_MINIMUM_BITRATE;
! 		break;
! 	case sTagMaximumBitrate:
! 		tag = GST_TAG_MAXIMUM_BITRATE;
! 		break;
! 	case sTagSerial:
! 		tag = GST_TAG_SERIAL;
! 		break;
! 	case sTagEncoderVersion:
! 		tag = GST_TAG_ENCODER_VERSION;
! 		break;
! 	case sTagCRC:
! 		tag = "has-crc";
! 		break;
! 	default:
! 		return resNA;
! 	}
! 
! 	if (!m_stream_tags || !tag)
! 		return 0;
! 	
! 	guint value;
! 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
! 		return (int) value;
! 
! 	return 0;
! }
! 
! std::string eServiceMP3::getInfoString(int w)
! {
! 	if ( !m_stream_tags && w < sUser && w > 26 )
! 		return "";
! 	const gchar *tag = 0;
! 	switch (w)
! 	{
! 	case sTagTitle:
! 		tag = GST_TAG_TITLE;
! 		break;
! 	case sTagArtist:
! 		tag = GST_TAG_ARTIST;
! 		break;
! 	case sTagAlbum:
! 		tag = GST_TAG_ALBUM;
! 		break;
! 	case sTagTitleSortname:
! 		tag = GST_TAG_TITLE_SORTNAME;
! 		break;
! 	case sTagArtistSortname:
! 		tag = GST_TAG_ARTIST_SORTNAME;
! 		break;
! 	case sTagAlbumSortname:
! 		tag = GST_TAG_ALBUM_SORTNAME;
! 		break;
! 	case sTagDate:
! 		GDate *date;
! 		if (gst_tag_list_get_date(m_stream_tags, GST_TAG_DATE, &date))
! 		{
! 			gchar res[5];
!  			g_date_strftime (res, sizeof(res), "%Y-%M-%D", date); 
! 			return (std::string)res;
! 		}
! 		break;
! 	case sTagComposer:
! 		tag = GST_TAG_COMPOSER;
! 		break;
! 	case sTagGenre:
! 		tag = GST_TAG_GENRE;
! 		break;
! 	case sTagComment:
! 		tag = GST_TAG_COMMENT;
! 		break;
! 	case sTagExtendedComment:
! 		tag = GST_TAG_EXTENDED_COMMENT;
! 		break;
! 	case sTagLocation:
! 		tag = GST_TAG_LOCATION;
! 		break;
! 	case sTagHomepage:
! 		tag = GST_TAG_HOMEPAGE;
! 		break;
! 	case sTagDescription:
! 		tag = GST_TAG_DESCRIPTION;
! 		break;
! 	case sTagVersion:
! 		tag = GST_TAG_VERSION;
! 		break;
! 	case sTagISRC:
! 		tag = GST_TAG_ISRC;
! 		break;
! 	case sTagOrganization:
! 		tag = GST_TAG_ORGANIZATION;
! 		break;
! 	case sTagCopyright:
! 		tag = GST_TAG_COPYRIGHT;
! 		break;
! 	case sTagCopyrightURI:
! 		tag = GST_TAG_COPYRIGHT_URI;
! 		break;
! 	case sTagContact:
! 		tag = GST_TAG_CONTACT;
! 		break;
! 	case sTagLicense:
! 		tag = GST_TAG_LICENSE;
! 		break;
! 	case sTagLicenseURI:
! 		tag = GST_TAG_LICENSE_URI;
! 		break;
! 	case sTagCodec:
! 		tag = GST_TAG_CODEC;
! 		break;
! 	case sTagAudioCodec:
! 		tag = GST_TAG_AUDIO_CODEC;
! 		break;
! 	case sTagVideoCodec:
! 		tag = GST_TAG_VIDEO_CODEC;
! 		break;
! 	case sTagEncoder:
! 		tag = GST_TAG_ENCODER;
! 		break;
! 	case sTagLanguageCode:
! 		tag = GST_TAG_LANGUAGE_CODE;
! 		break;
! 	case sTagKeywords:
! 		tag = GST_TAG_KEYWORDS;
! 		break;
! 	case sTagChannelMode:
! 		tag = "channel-mode";
! 		break;
! 	case sUser+12:
! 		return m_errorInfo.error_message;
! 	default:
! 		return "";
! 	}
! 	if ( !tag )
! 		return "";
! 	gchar *value;
! 	if (gst_tag_list_get_string(m_stream_tags, tag, &value))
! 	{
! 		std::string res = value;
! 		g_free(value);
! 		return res;
! 	}
! 	return "";
! }
! 
! PyObject *eServiceMP3::getInfoObject(int w)
! {
! 	const gchar *tag = 0;
! 	bool isBuffer = false;
! 	switch (w)
! 	{
! 		case sTagTrackGain:
! 			tag = GST_TAG_TRACK_GAIN;
! 			break;
! 		case sTagTrackPeak:
! 			tag = GST_TAG_TRACK_PEAK;
! 			break;
! 		case sTagAlbumGain:
! 			tag = GST_TAG_ALBUM_GAIN;
! 			break;
! 		case sTagAlbumPeak:
! 			tag = GST_TAG_ALBUM_PEAK;
! 			break;
! 		case sTagReferenceLevel:
! 			tag = GST_TAG_REFERENCE_LEVEL;
! 			break;
! 		case sTagBeatsPerMinute:
! 			tag = GST_TAG_BEATS_PER_MINUTE;
! 			break;
! 		case sTagImage:
! 			tag = GST_TAG_IMAGE;
! 			isBuffer = true;
! 			break;
! 		case sTagPreviewImage:
! 			tag = GST_TAG_PREVIEW_IMAGE;
! 			isBuffer = true;
! 			break;
! 		case sTagAttachment:
! 			tag = GST_TAG_ATTACHMENT;
! 			isBuffer = true;
! 			break;
! 		default:
! 			break;
! 	}
! 
! 	if ( isBuffer )
! 	{
! 		const GValue *gv_buffer = gst_tag_list_get_value_index(m_stream_tags, tag, 0);
! 		if ( gv_buffer )
! 		{
! 			GstBuffer *buffer;
! 			buffer = gst_value_get_buffer (gv_buffer);
! 			return PyBuffer_FromMemory(GST_BUFFER_DATA(buffer), GST_BUFFER_SIZE(buffer));
! 		}
! 	}
! 	else
! 	{
! 		gdouble value = 0.0;
! 		gst_tag_list_get_double(m_stream_tags, tag, &value);
! 		return PyFloat_FromDouble(value);
! 	}
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::subtitle(ePtr<iSubtitleOutput> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioDelay(ePtr<iAudioDelay> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! int eServiceMP3::getNumberOfTracks()
! {
!  	return m_audioStreams.size();
! }
! 
! int eServiceMP3::getCurrentTrack()
! {
! 	if (m_currentAudioStream == -1)
! 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
! 	return m_currentAudioStream;
! }
! 
! RESULT eServiceMP3::selectTrack(unsigned int i)
! {
! 	pts_t ppos;
! 	getPlayPosition(ppos);
! 	ppos -= 90000;
! 	if (ppos < 0)
! 		ppos = 0;
! 
! 	int ret = selectAudioStream(i);
! 	if (!ret) {
! 		/* flush */
! 		seekTo(ppos);
! 	}
! 
! 	return ret;
! }
! 
! int eServiceMP3::selectAudioStream(int i)
! {
! 	int current_audio;
! 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
! 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
! 	if ( current_audio == i )
! 	{
! 		eDebug ("eServiceMP3::switched to audio stream %i", current_audio);
! 		m_currentAudioStream = i;
! 		return 0;
! 	}
! 	return -1;
! }
! 
! int eServiceMP3::getCurrentChannel()
! {
! 	return STEREO;
! }
! 
! RESULT eServiceMP3::selectChannel(int i)
! {
! 	eDebug("eServiceMP3::selectChannel(%i)",i);
! 	return 0;
! }
! 
! RESULT eServiceMP3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
! {
!  	if (i >= m_audioStreams.size())
! 		return -2;
! 		info.m_description = m_audioStreams[i].codec;
! /*	if (m_audioStreams[i].type == atMPEG)
! 		info.m_description = "MPEG";
! 	else if (m_audioStreams[i].type == atMP3)
! 		info.m_description = "MP3";
! 	else if (m_audioStreams[i].type == atAC3)
! 		info.m_description = "AC3";
! 	else if (m_audioStreams[i].type == atAAC)
! 		info.m_description = "AAC";
! 	else if (m_audioStreams[i].type == atDTS)
! 		info.m_description = "DTS";
! 	else if (m_audioStreams[i].type == atPCM)
! 		info.m_description = "PCM";
! 	else if (m_audioStreams[i].type == atOGG)
! 		info.m_description = "OGG";
! 	else if (m_audioStreams[i].type == atFLAC)
! 		info.m_description = "FLAC";
! 	else
! 		info.m_description = "???";*/
! 	if (info.m_language.empty())
! 		info.m_language = m_audioStreams[i].language_code;
! 	return 0;
! }
! 
! subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
! {
! 	subtype_t type = stUnknown;
! 	GstCaps* caps = gst_pad_get_negotiated_caps(pad);
! 
! 	if ( caps )
! 	{
! 		GstStructure* str = gst_caps_get_structure(caps, 0);
! 		const gchar *g_type = gst_structure_get_name(str);
! 		eDebug("getSubtitleType::subtitle probe caps type=%s", g_type);
! 
! 		if ( !strcmp(g_type, "video/x-dvd-subpicture") )
! 			type = stVOB;
! 		else if ( !strcmp(g_type, "text/x-pango-markup") )
! 			type = stSSA;
! 		else if ( !strcmp(g_type, "text/plain") )
! 			type = stPlainText;
! 		else if ( !strcmp(g_type, "subpicture/x-pgs") )
! 			type = stPGS;
! 		else
! 			eDebug("getSubtitleType::unsupported subtitle caps %s (%s)", g_type, g_codec);
! 	}
! 	else if ( g_codec )
! 	{
! 		eDebug("getSubtitleType::subtitle probe codec tag=%s", g_codec);
! 		if ( !strcmp(g_codec, "VOB") )
! 			type = stVOB;
! 		else if ( !strcmp(g_codec, "SubStation Alpha") || !strcmp(g_codec, "SSA") )
! 			type = stSSA;
! 		else if ( !strcmp(g_codec, "ASS") )
! 			type = stASS;
! 		else if ( !strcmp(g_codec, "UTF-8 plain text") )
! 			type = stPlainText;
! 		else
! 			eDebug("getSubtitleType::unsupported subtitle codec %s", g_codec);
! 	}
! 	else
! 		eDebug("getSubtitleType::unidentifiable subtitle stream!");
! 
! 	return type;
! }
! 
! void eServiceMP3::gstBusCall(GstBus *bus, GstMessage *msg)
! {
! 	if (!msg)
! 		return;
! 	gchar *sourceName;
! 	GstObject *source;
! 	source = GST_MESSAGE_SRC(msg);
! 	if (!GST_IS_OBJECT(source))
! 		return;
! 	sourceName = gst_object_get_name(source);
! #if 0
! 	gchar *string;
! 	if (gst_message_get_structure(msg))
! 		string = gst_structure_to_string(gst_message_get_structure(msg));
! 	else
! 		string = g_strdup(GST_MESSAGE_TYPE_NAME(msg));
! 	eDebug("eTsRemoteSource::gst_message from %s: %s", sourceName, string);
! 	g_free(string);
! #endif
! 	switch (GST_MESSAGE_TYPE (msg))
! 	{
! 		case GST_MESSAGE_EOS:
! 			m_event((iPlayableService*)this, evEOF);
! 			break;
! 		case GST_MESSAGE_STATE_CHANGED:
! 		{
! 			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
! 				break;
! 
! 			GstState old_state, new_state;
! 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
! 		
! 			if(old_state == new_state)
! 				break;
! 	
! 			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
! 	
! 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
! 	
! 			switch(transition)
! 			{
! 				case GST_STATE_CHANGE_NULL_TO_READY:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_READY_TO_PAUSED:
! 				{
! 					GstElement *appsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
!  					if (appsink)
!  					{
!  						g_object_set (G_OBJECT (appsink), "max-buffers", 2, NULL);
!  						g_object_set (G_OBJECT (appsink), "sync", FALSE, NULL);
!  						g_object_set (G_OBJECT (appsink), "emit-signals", TRUE, NULL);
!  						eDebug("eServiceMP3::appsink properties set!");
!  						gst_object_unref(appsink);
!  					}
! 					setAC3Delay(ac3_delay);
! 					setPCMDelay(pcm_delay);
! 				}	break;
! 				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
! 				{
! 					if ( m_sourceinfo.is_streaming && m_streamingsrc_timeout )
! 						m_streamingsrc_timeout->stop();
! 				}	break;
! 				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_PAUSED_TO_READY:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_READY_TO_NULL:
! 				{
! 				}	break;
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_ERROR:
! 		{
! 			gchar *debug;
! 			GError *err;
! 			gst_message_parse_error (msg, &err, &debug);
! 			g_free (debug);
! 			eWarning("Gstreamer error: %s (%i) from %s", err->message, err->code, sourceName );
! 			if ( err->domain == GST_STREAM_ERROR )
! 			{
! 				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
! 				{
! 					if ( g_strrstr(sourceName, "videosink") )
! 						m_event((iPlayableService*)this, evUser+11);
! 					else if ( g_strrstr(sourceName, "audiosink") )
! 						m_event((iPlayableService*)this, evUser+10);
! 				}
! 			}
! 			g_error_free(err);
! 			break;
! 		}
! 		case GST_MESSAGE_INFO:
! 		{
! 			gchar *debug;
! 			GError *inf;
! 	
! 			gst_message_parse_info (msg, &inf, &debug);
! 			g_free (debug);
! 			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
! 			{
! 				if ( g_strrstr(sourceName, "videosink") )
! 					m_event((iPlayableService*)this, evUser+14);
! 			}
! 			g_error_free(inf);
! 			break;
! 		}
! 		case GST_MESSAGE_TAG:
! 		{
! 			GstTagList *tags, *result;
! 			gst_message_parse_tag(msg, &tags);
! 	
! 			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
! 			if (result)
! 			{
! 				if (m_stream_tags)
! 					gst_tag_list_free(m_stream_tags);
! 				m_stream_tags = result;
! 			}
! 	
! 			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
! 			if ( gv_image )
! 			{
! 				GstBuffer *buf_image;
! 				buf_image = gst_value_get_buffer (gv_image);
! 				int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
! 				int ret = write(fd, GST_BUFFER_DATA(buf_image), GST_BUFFER_SIZE(buf_image));
! 				close(fd);
! 				eDebug("eServiceMP3::/tmp/.id3coverart %d bytes written ", ret);
! 				m_event((iPlayableService*)this, evUser+13);
! 			}
! 			gst_tag_list_free(tags);
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 			break;
! 		}
! 		case GST_MESSAGE_ASYNC_DONE:
! 		{
! 			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
! 				break;
! 
! 			GstTagList *tags;
! 			gint i, active_idx, n_video = 0, n_audio = 0, n_text = 0;
! 
! 			g_object_get (m_gst_playbin, "n-video", &n_video, NULL);
! 			g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
! 			g_object_get (m_gst_playbin, "n-text", &n_text, NULL);
! 
! 			eDebug("eServiceMP3::async-done - %d video, %d audio, %d subtitle", n_video, n_audio, n_text);
! 
! 			if ( n_video + n_audio <= 0 )
! 				stop();
! 
! 			active_idx = 0;
! 
! 			m_audioStreams.clear();
! 			m_subtitleStreams.clear();
! 
! 			for (i = 0; i < n_audio; i++)
! 			{
! 				audioStream audio;
! 				gchar *g_codec, *g_lang;
! 				GstPad* pad = 0;
! 				g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
! 				GstCaps* caps = gst_pad_get_negotiated_caps(pad);
! 				if (!caps)
! 					continue;
! 				GstStructure* str = gst_caps_get_structure(caps, 0);
! 				const gchar *g_type = gst_structure_get_name(str);
! 				audio.type = gstCheckAudioPad(str);
! 				g_codec = g_strdup(g_type);
! 				g_lang = g_strdup_printf ("und");
! 				g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
! 				if ( tags && gst_is_tag_list(tags) )
! 				{
! 					gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec);
! 					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 					gst_tag_list_free(tags);
! 				}
! 				audio.language_code = std::string(g_lang);
! 				audio.codec = std::string(g_codec);
! 				eDebug("eServiceMP3::audio stream=%i codec=%s language=%s", i, g_codec, g_lang);
! 				m_audioStreams.push_back(audio);
! 				g_free (g_lang);
! 				g_free (g_codec);
! 				gst_caps_unref(caps);
! 			}
! 
! 			for (i = 0; i < n_text; i++)
! 			{
! 				gchar *g_codec = NULL, *g_lang = NULL;
! 				g_signal_emit_by_name (m_gst_playbin, "get-text-tags", i, &tags);
! 				subtitleStream subs;
! //				int ret;
! 
! 				g_lang = g_strdup_printf ("und");
! 				if ( tags && gst_is_tag_list(tags) )
! 				{
! 					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 					gst_tag_list_get_string(tags, GST_TAG_SUBTITLE_CODEC, &g_codec);
! 					gst_tag_list_free(tags);
! 				}
! 
! 				subs.language_code = std::string(g_lang);
! 				eDebug("eServiceMP3::subtitle stream=%i language=%s codec=%s", i, g_lang, g_codec);
! 				
! 				GstPad* pad = 0;
! 				g_signal_emit_by_name (m_gst_playbin, "get-text-pad", i, &pad);
! 				if ( pad )
! 					g_signal_connect (G_OBJECT (pad), "notify::caps", G_CALLBACK (gstTextpadHasCAPS), this);
! 				subs.type = getSubtitleType(pad, g_codec);
! 
! 				m_subtitleStreams.push_back(subs);
! 				g_free (g_lang);
! 			}
! 			m_event((iPlayableService*)this, evUpdatedEventInfo);
! 
! 			if ( m_errorInfo.missing_codec != "" )
! 			{
! 				if ( m_errorInfo.missing_codec.find("video/") == 0 || ( m_errorInfo.missing_codec.find("audio/") == 0 && getNumberOfTracks() == 0 ) )
! 					m_event((iPlayableService*)this, evUser+12);
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_ELEMENT:
! 		{
! 			if (const GstStructure *msgstruct = gst_message_get_structure(msg))
! 			{
! 				if ( gst_is_missing_plugin_message(msg) )
! 				{
! 					GstCaps *caps;
! 					gst_structure_get ((GstStructure*)msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL); 
! 					std::string codec = (const char*) gst_caps_to_string(caps);
! 					gchar *description = gst_missing_plugin_message_get_description(msg);
! 					if ( description )
! 					{
! 						eDebug("eServiceMP3::m_errorInfo.missing_codec = %s", codec.c_str());
! 						m_errorInfo.error_message = "GStreamer plugin " + (std::string)description + " not available!\n";
! 						m_errorInfo.missing_codec = codec.substr(0,(codec.find_first_of(',')));
! 						g_free(description);
! 					}
! 					gst_caps_unref(caps);
! 				}
! 				else
! 				{
! 					const gchar *eventname = gst_structure_get_name(msgstruct);
! 					if ( eventname )
! 					{
! 						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
! 							gst_structure_get_int (msgstruct, "width", &m_width);
! 							gst_structure_get_int (msgstruct, "height", &m_height);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoSizeChanged);
! 						}
! 						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoFramerateChanged);
! 						}
! 						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoProgressiveChanged);
! 						}
! 					}
! 				}
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_BUFFERING:
! 		{
! 			GstBufferingMode mode;
! 			gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
! 			gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
! 			m_event((iPlayableService*)this, evBuffering);
! 			break;
! 		}
! 		case GST_MESSAGE_STREAM_STATUS:
! 		{
! 			GstStreamStatusType type;
! 			GstElement *owner;
! 			gst_message_parse_stream_status (msg, &type, &owner);
! 			if ( type == GST_STREAM_STATUS_TYPE_CREATE && m_sourceinfo.is_streaming )
! 			{
! 				if ( GST_IS_PAD(source) )
! 					owner = gst_pad_get_parent_element(GST_PAD(source));
! 				else if ( GST_IS_ELEMENT(source) )
! 					owner = GST_ELEMENT(source);
! 				else
! 					owner = 0;
! 				if ( owner )
! 				{
! 					GstElementFactory *factory = gst_element_get_factory(GST_ELEMENT(owner));
! 					const gchar *name = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
! 					if (!strcmp(name, "souphttpsrc"))
! 					{
! 						m_streamingsrc_timeout->start(HTTP_TIMEOUT*1000, true);
! 						g_object_set (G_OBJECT (owner), "timeout", HTTP_TIMEOUT, NULL);
! 						eDebug("eServiceMP3::GST_STREAM_STATUS_TYPE_CREATE -> setting timeout on %s to %is", name, HTTP_TIMEOUT);
! 					}
! 					
! 				}
! 				if ( GST_IS_PAD(source) )
! 					gst_object_unref(owner);
! 			}
! 			break;
! 		}
! 		default:
! 			break;
! 	}
! 	g_free (sourceName);
! }
! 
! GstBusSyncReply eServiceMP3::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
! {
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 	_this->m_pump.send(Message(1));
! 		/* wake */
! 	return GST_BUS_PASS;
! }
! 
! void eServiceMP3::gstHTTPSourceSetAgent(GObject *object, GParamSpec *unused, gpointer user_data)
! {
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 	GstElement *source;
! 	g_object_get(_this->m_gst_playbin, "source", &source, NULL);
! 	g_object_set (G_OBJECT (source), "user-agent", _this->m_useragent.c_str(), NULL);
! 	gst_object_unref(source);
! }
! 
! audiotype_t eServiceMP3::gstCheckAudioPad(GstStructure* structure)
! {
! 	if (!structure)
! 		return atUnknown;
! 
! 	if ( gst_structure_has_name (structure, "audio/mpeg"))
! 	{
! 		gint mpegversion, layer = -1;
! 		if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
! 			return atUnknown;
! 
! 		switch (mpegversion) {
! 			case 1:
! 				{
! 					gst_structure_get_int (structure, "layer", &layer);
! 					if ( layer == 3 )
! 						return atMP3;
! 					else
! 						return atMPEG;
! 					break;
! 				}
! 			case 2:
! 				return atAAC;
! 			case 4:
! 				return atAAC;
! 			default:
! 				return atUnknown;
! 		}
! 	}
! 
! 	else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
! 		return atAC3;
! 	else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
! 		return atDTS;
! 	else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
! 		return atPCM;
! 
! 	return atUnknown;
! }
! 
! void eServiceMP3::gstPoll(const Message &msg)
! {
! 	if (msg.type == 1)
! 	{
! 		GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin));
! 		GstMessage *message;
! 		while ((message = gst_bus_pop(bus)))
! 		{
! 			gstBusCall(bus, message);
! 			gst_message_unref (message);
! 		}
! 	}
! 	else if (msg.type == 2)
! 		pullSubtitle();
! 	else if (msg.type == 3)
! 		gstTextpadHasCAPS_synced(msg.d.pad);
! 	else
! 		eDebug("gstPoll unhandled Message %d\n", msg.type);
! }
! 
! eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
! 
! void eServiceMP3::gstCBsubtitleAvail(GstElement *appsink, gpointer user_data)
! {
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;	
! 	eSingleLocker l(_this->m_subs_to_pull_lock);
! 	++_this->m_subs_to_pull;
! 	_this->m_pump.send(Message(2));
! }
! 
! void eServiceMP3::gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data)
! {
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 
! 	gst_object_ref (pad);
! 
! 	_this->m_pump.send(Message(3, pad));
! }
! 
! // after messagepump
! void eServiceMP3::gstTextpadHasCAPS_synced(GstPad *pad)
! {
! 	GstCaps *caps;
! 
! 	g_object_get (G_OBJECT (pad), "caps", &caps, NULL);
! 
! 	eDebug("gstTextpadHasCAPS:: signal::caps = %s", gst_caps_to_string(caps));
! 
! 	if (caps)
! 	{
! 		subtitleStream subs;
! 
! //		eDebug("gstGhostpadHasCAPS_synced %p %d", pad, m_subtitleStreams.size());
! 
! 		if (!m_subtitleStreams.empty())
! 			subs = m_subtitleStreams[m_currentSubtitleStream];
! 		else {
! 			subs.type = stUnknown;
! 			subs.pad = pad;
! 		}
! 
! 		if ( subs.type == stUnknown )
! 		{
! 			GstTagList *tags;
! //			eDebug("gstGhostpadHasCAPS::m_subtitleStreams[%i].type == stUnknown...", m_currentSubtitleStream);
! 
! 			gchar *g_lang;
! 			g_signal_emit_by_name (m_gst_playbin, "get-text-tags", m_currentSubtitleStream, &tags);
! 
! 			g_lang = g_strdup_printf ("und");
! 			if ( tags && gst_is_tag_list(tags) )
! 				gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 
! 			subs.language_code = std::string(g_lang);
! 			subs.type = getSubtitleType(pad);
! 
! 			if (!m_subtitleStreams.empty())
! 				m_subtitleStreams[m_currentSubtitleStream] = subs;
! 			else
! 				m_subtitleStreams.push_back(subs);
! 
! 			g_free (g_lang);
! 		}
! 
! //		eDebug("gstGhostpadHasCAPS:: m_gst_prev_subtitle_caps=%s equal=%i",gst_caps_to_string(m_gst_prev_subtitle_caps),gst_caps_is_equal(m_gst_prev_subtitle_caps, caps));
! 
! 		gst_caps_unref (caps);
! 	}
! 
! 	gst_object_unref (pad);
! }
! 
! void eServiceMP3::pullSubtitle()
! {
! 	GstElement *sink;
! 	g_object_get (G_OBJECT (m_gst_playbin), "text-sink", &sink, NULL);
! 	
! 	if (sink)
! 	{
! 		while (m_subs_to_pull && m_subtitle_pages.size() < 2)
! 		{
! 			GstBuffer *buffer;
! 			{
! 				eSingleLocker l(m_subs_to_pull_lock);
! 				--m_subs_to_pull;
! 				g_signal_emit_by_name (sink, "pull-buffer", &buffer);
! 			}
! 			if (buffer)
! 			{
! 				gint64 buf_pos = GST_BUFFER_TIMESTAMP(buffer);
! 				gint64 duration_ns = GST_BUFFER_DURATION(buffer);
! 				size_t len = GST_BUFFER_SIZE(buffer);
! 				eDebug("pullSubtitle m_subtitleStreams[m_currentSubtitleStream].type=%i",m_subtitleStreams[m_currentSubtitleStream].type);
! 				
! 				if ( m_subtitleStreams[m_currentSubtitleStream].type )
! 				{
! 					if ( m_subtitleStreams[m_currentSubtitleStream].type < stVOB )
! 					{
! 						unsigned char line[len+1];
! 						SubtitlePage page;
! 						memcpy(line, GST_BUFFER_DATA(buffer), len);
! 						line[len] = 0;
! 						eDebug("got new text subtitle @ buf_pos = %lld ns (in pts=%lld): '%s' ", buf_pos, buf_pos/11111, line);
! 						gRGB rgbcol(0xD0,0xD0,0xD0);
! 						page.type = SubtitlePage::Pango;
! 						page.pango_page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)line));
! 						page.pango_page.m_show_pts = buf_pos / 11111L;
! 						page.pango_page.m_timeout = duration_ns / 1000000;
! 						m_subtitle_pages.push_back(page);
! 						if (m_subtitle_pages.size()==1)
! 							pushSubtitles();
! 					}
! 					else
! 					{
! 						eDebug("unsupported subpicture... ignoring");
! 					}
! 				}
! 				gst_buffer_unref(buffer);
! 			}
! 		}
! 		gst_object_unref(sink);
! 	}
! 	else
! 		eDebug("no subtitle sink!");
! }
! 
! void eServiceMP3::pushSubtitles()
! {
! 	while ( !m_subtitle_pages.empty() )
! 	{
! 		SubtitlePage &frontpage = m_subtitle_pages.front();
! 		pts_t running_pts;
! 		gint64 diff_ms = 0;
! 		gint64 show_pts = 0;
! 
! 		getPlayPosition(running_pts);
! 
! 		if (m_decoder_time_valid_state < 4) {
! 			++m_decoder_time_valid_state;
! 			if (m_prev_decoder_time == running_pts)
! 				m_decoder_time_valid_state = 0;
! 			if (m_decoder_time_valid_state < 4) {
! //				if (m_decoder_time_valid_state)
! //					eDebug("%d: decoder time not valid! prev %lld, now %lld\n", m_decoder_time_valid_state, m_prev_decoder_time/90, running_pts/90);
! //				else
! //					eDebug("%d: decoder time not valid! now %lld\n", m_decoder_time_valid_state, running_pts/90);
! 				m_subtitle_sync_timer->start(25, true);
! 				m_prev_decoder_time = running_pts;
! 				break;
! 			}
! 		}
! 
! 		if (frontpage.type == SubtitlePage::Pango)
! 			show_pts = frontpage.pango_page.m_show_pts;
! 
! 		diff_ms = ( show_pts - running_pts ) / 90;
! 		eDebug("check subtitle: decoder: %lld, show_pts: %lld, diff: %lld ms", running_pts/90, show_pts/90, diff_ms);
! 
! 		if ( diff_ms < -100 )
! 		{
! 			eDebug("subtitle too late... drop");
! 			m_subtitle_pages.pop_front();
! 		}
! 		else if ( diff_ms > 20 )
! 		{
! 			eDebug("start timer");
! 			m_subtitle_sync_timer->start(diff_ms, true);
! 			break;
! 		}
! 		else // immediate show
! 		{
! 			if ( m_subtitle_widget )
! 			{
! 				eDebug("show!\n");
! 				if ( frontpage.type == SubtitlePage::Pango)
! 					m_subtitle_widget->setPage(frontpage.pango_page);
! 				m_subtitle_widget->show();
! 			}
! 			m_subtitle_pages.pop_front();
! 		}
! 	}
! 	if (m_subtitle_pages.empty())
! 		pullSubtitle();
! }
! 
! 
! RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
! {
! 	eDebug ("eServiceMP3::enableSubtitles m_currentSubtitleStream=%i this=%p",m_currentSubtitleStream, this);
! 	ePyObject entry;
! 	int tuplesize = PyTuple_Size(tuple);
! 	int pid, type;
! 	gint text_pid = 0;
! 	eSingleLocker l(m_subs_to_pull_lock);
! 
! // 	GstPad *pad = 0;
! // 	g_signal_emit_by_name (m_gst_playbin, "get-text-pad", m_currentSubtitleStream, &pad);
! // 	gst_element_get_static_pad(m_gst_subtitlebin, "sink");
! // 	gulong subprobe_handler_id = gst_pad_add_buffer_probe (pad, G_CALLBACK (gstCBsubtitleDrop), NULL);
! 
! 	if (!PyTuple_Check(tuple))
! 		goto error_out;
! 	if (tuplesize < 1)
! 		goto error_out;
! 	entry = PyTuple_GET_ITEM(tuple, 1);
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 	pid = PyInt_AsLong(entry);
! 	entry = PyTuple_GET_ITEM(tuple, 2);
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 	type = PyInt_AsLong(entry);
! 
! 	if (m_currentSubtitleStream != pid)
! 	{
! 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", pid, NULL);
! 		eDebug ("eServiceMP3::enableSubtitles g_object_set current-text = %i", pid);
! 		m_currentSubtitleStream = pid;
! 		m_subs_to_pull = 0;
! 		m_prev_decoder_time = -1;
! 		m_subtitle_pages.clear();
! 	}
! 
! 	m_subtitle_widget = 0;
! 	m_subtitle_widget = new eSubtitleWidget(parent);
! 	m_subtitle_widget->resize(parent->size()); /* full size */
! 
! 	g_object_get (G_OBJECT (m_gst_playbin), "current-text", &text_pid, NULL);
! 
! 	eDebug ("eServiceMP3::switched to subtitle stream %i", text_pid);
! // 	gst_pad_remove_buffer_probe (pad, subprobe_handler_id);
! 
! 	m_event((iPlayableService*)this, evUpdatedInfo);
! 
! 	return 0;
! 
! error_out:
! 	eDebug("eServiceMP3::enableSubtitles needs a tuple as 2nd argument!\n"
! 		"for gst subtitles (2, subtitle_stream_count, subtitle_type)");
! 	return -1;
! }
! 
! RESULT eServiceMP3::disableSubtitles(eWidget *parent)
! {
! 	eDebug("eServiceMP3::disableSubtitles");
! 	m_subtitle_pages.clear();
! 	delete m_subtitle_widget;
! 	m_subtitle_widget = 0;
! 	return 0;
! }
! 
! PyObject *eServiceMP3::getCachedSubtitle()
! {
! // 	eDebug("eServiceMP3::getCachedSubtitle");
! 	Py_RETURN_NONE;
! }
! 
! PyObject *eServiceMP3::getSubtitleList()
! {
! // 	eDebug("eServiceMP3::getSubtitleList");
! 	ePyObject l = PyList_New(0);
! 	int stream_idx = 0;
! 	
! 	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
! 	{
! 		subtype_t type = IterSubtitleStream->type;
! 		switch(type)
! 		{
! 		case stUnknown:
! 		case stVOB:
! 		case stPGS:
! 			break;
! 		default:
! 		{
! 			ePyObject tuple = PyTuple_New(5);
! //			eDebug("eServiceMP3::getSubtitleList idx=%i type=%i, code=%s", stream_idx, int(type), (IterSubtitleStream->language_code).c_str());
! 			PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(2));
! 			PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(stream_idx));
! 			PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(int(type)));
! 			PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(0));
! 			PyTuple_SET_ITEM(tuple, 4, PyString_FromString((IterSubtitleStream->language_code).c_str()));
! 			PyList_Append(l, tuple);
! 			Py_DECREF(tuple);
! 		}
! 		}
! 		stream_idx++;
! 	}
! 	eDebug("eServiceMP3::getSubtitleList finished");
! 	return l;
! }
! 
! RESULT eServiceMP3::streamed(ePtr<iStreamedService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! PyObject *eServiceMP3::getBufferCharge()
! {
! 	ePyObject tuple = PyTuple_New(5);
! 	PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(m_bufferInfo.bufferPercent));
! 	PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(m_bufferInfo.avgInRate));
! 	PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(m_bufferInfo.avgOutRate));
! 	PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(m_bufferInfo.bufferingLeft));
! 	PyTuple_SET_ITEM(tuple, 4, PyInt_FromLong(m_buffer_size));
! 	return tuple;
! }
! 
! int eServiceMP3::setBufferSize(int size)
! {
! 	m_buffer_size = size;
! 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
! 	return 0;
! }
! 
! int eServiceMP3::getAC3Delay()
! {
! 	return ac3_delay;
! }
! 
! int eServiceMP3::getPCMDelay()
! {
! 	return pcm_delay;
! }
! 
! void eServiceMP3::setAC3Delay(int delay)
! {
! 	ac3_delay = delay;
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return;
! 	else
! 	{
! 		GstElement *sink;
! 		int config_delay_int = delay;
! 		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			std::string config_delay;
! 			if(ePythonConfigQuery::getConfigValue("config.av.generalAC3delay", config_delay) == 0)
! 				config_delay_int += atoi(config_delay.c_str());
! 			gst_object_unref(sink);
! 		}
! 		else
! 		{
! 			eDebug("dont apply ac3 delay when no video is running!");
! 			config_delay_int = 0;
! 		}
! 
! 		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			gchar *name = gst_element_get_name(sink);
! 			if (strstr(name, "dvbaudiosink"))
! 				eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
! 			g_free(name);
! 			gst_object_unref(sink);
! 		}
! 	}
! }
! 
! void eServiceMP3::setPCMDelay(int delay)
! {
! 	pcm_delay = delay;
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return;
! 	else
! 	{
! 		GstElement *sink;
! 		int config_delay_int = delay;
! 		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			std::string config_delay;
! 			if(ePythonConfigQuery::getConfigValue("config.av.generalPCMdelay", config_delay) == 0)
! 				config_delay_int += atoi(config_delay.c_str());
! 			gst_object_unref(sink);
! 		}
! 		else
! 		{
! 			eDebug("dont apply pcm delay when no video is running!");
! 			config_delay_int = 0;
! 		}
! 
! 		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			gchar *name = gst_element_get_name(sink);
! 			if (strstr(name, "dvbaudiosink"))
! 				eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
! 			else
! 			{
! 				// this is realy untested..and not used yet
! 				gint64 offset = config_delay_int;
! 				offset *= 1000000; // milli to nano
! 				g_object_set (G_OBJECT (m_gst_playbin), "ts-offset", offset, NULL);
! 			}
! 			g_free(name);
! 			gst_object_unref(sink);
! 		}
! 	}
! }
! 
--- 1,1520 ----
! 	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
! 	/* it's currently hardcoded to use a big-endian alsasink as sink. */
! #include <lib/base/ebase.h>
! #include <lib/base/eerror.h>
! #include <lib/base/init_num.h>
! #include <lib/base/init.h>
! #include <lib/base/nconfig.h>
! #include <lib/base/object.h>
! #include <lib/dvb/decoder.h>
! #include <lib/components/file_eraser.h>
! #include <lib/gui/esubtitle.h>
! #include <lib/service/servicemp3.h>
! #include <lib/service/service.h>
! #include <lib/gdi/gpixmap.h>
! 
! #include <string>
! 
! //#include <gst/gst.h>
! //#include <gst/pbutils/missing-plugins.h>
! //#include <sys/stat.h>
! 
! #define HTTP_TIMEOUT 10
! 
! // eServiceFactoryMP3
! 
! eServiceFactoryMP3::eServiceFactoryMP3()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 	{
! 		std::list<std::string> extensions;
! 		extensions.push_back("mp2");
! 		extensions.push_back("mp3");
! 		extensions.push_back("ogg");
! 		extensions.push_back("mpg");
! 		extensions.push_back("vob");
! 		extensions.push_back("wav");
! 		extensions.push_back("wave");
! 		extensions.push_back("m4v");
! 		extensions.push_back("mkv");
! 		extensions.push_back("avi");
! 		extensions.push_back("divx");
! 		extensions.push_back("dat");
! 		extensions.push_back("flac");
! 		extensions.push_back("mp4");
! 		extensions.push_back("mov");
! 		extensions.push_back("m4a");
! 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
! 	}
! 
! 	m_service_info = new eStaticServiceMP3Info();
! }
! 
! eServiceFactoryMP3::~eServiceFactoryMP3()
! {
! 	ePtr<eServiceCenter> sc;
! 	
! 	eServiceCenter::getPrivInstance(sc);
! 	if (sc)
! 		sc->removeServiceFactory(eServiceFactoryMP3::id);
! }
! 
! DEFINE_REF(eServiceFactoryMP3)
! 
! 	// iServiceHandler
! RESULT eServiceFactoryMP3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
! {
! 		// check resources...
! 	ptr = new eServiceMP3(ref);
! 	return 0;
! }
! 
! RESULT eServiceFactoryMP3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
! {
! 	ptr=0;
! 	return -1;
! }
! 
! RESULT eServiceFactoryMP3::list(const eServiceReference &, ePtr<iListableService> &ptr)
! {
! 	ptr=0;
! 	return -1;
! }
! 
! RESULT eServiceFactoryMP3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
! {
! 	ptr = m_service_info;
! 	return 0;
! }
! 
! class eMP3ServiceOfflineOperations: public iServiceOfflineOperations
! {
! 	DECLARE_REF(eMP3ServiceOfflineOperations);
! 	eServiceReference m_ref;
! public:
! 	eMP3ServiceOfflineOperations(const eServiceReference &ref);
! 	
! 	RESULT deleteFromDisk(int simulate);
! 	RESULT getListOfFilenames(std::list<std::string> &);
! 	RESULT reindex();
! };
! 
! DEFINE_REF(eMP3ServiceOfflineOperations);
! 
! eMP3ServiceOfflineOperations::eMP3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
! {
! }
! 
! RESULT eMP3ServiceOfflineOperations::deleteFromDisk(int simulate)
! {
! 	if (simulate)
! 		return 0;
! 	else
! 	{
! 		std::list<std::string> res;
! 		if (getListOfFilenames(res))
! 			return -1;
! 		
! 		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
! 		if (!eraser)
! 			eDebug("FATAL !! can't get background file eraser");
! 		
! 		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
! 		{
! 			eDebug("Removing %s...", i->c_str());
! 			if (eraser)
! 				eraser->erase(i->c_str());
! 			else
! 				::unlink(i->c_str());
! 		}
! 		
! 		return 0;
! 	}
! }
! 
! RESULT eMP3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
! {
! 	res.clear();
! 	res.push_back(m_ref.path);
! 	return 0;
! }
! 
! RESULT eMP3ServiceOfflineOperations::reindex()
! {
! 	return -1;
! }
! 
! 
! RESULT eServiceFactoryMP3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
! {
! 	ptr = new eMP3ServiceOfflineOperations(ref);
! 	return 0;
! }
! 
! // eStaticServiceMP3Info
! 
! 
! // eStaticServiceMP3Info is seperated from eServiceMP3 to give information
! // about unopened files.
! 
! // probably eServiceMP3 should use this class as well, and eStaticServiceMP3Info
! // should have a database backend where ID3-files etc. are cached.
! // this would allow listing the mp3 database based on certain filters.
! 
! DEFINE_REF(eStaticServiceMP3Info)
! 
! eStaticServiceMP3Info::eStaticServiceMP3Info()
! {
! }
! 
! RESULT eStaticServiceMP3Info::getName(const eServiceReference &ref, std::string &name)
! {
! 	if ( ref.name.length() )
! 		name = ref.name;
! 	else
! 	{
! 		size_t last = ref.path.rfind('/');
! 		if (last != std::string::npos)
! 			name = ref.path.substr(last+1);
! 		else
! 			name = ref.path;
! 	}
! 	return 0;
! }
! 
! int eStaticServiceMP3Info::getLength(const eServiceReference &ref)
! {
! 	return -1;
! }
! 
! int eStaticServiceMP3Info::getInfo(const eServiceReference &ref, int w)
! {
! 	switch (w)
! 	{
! 	case iServiceInformation::sTimeCreate:
! 	{
! 		struct stat s;
! 		if(stat(ref.path.c_str(), &s) == 0)
! 		{
! 		  return s.st_mtime;
! 		}
! 		return iServiceInformation::resNA;
! 	}
! 	default: break;
! 	}
! 	return iServiceInformation::resNA;
! }
!  
! 
! // eServiceMP3
! int eServiceMP3::ac3_delay,
!     eServiceMP3::pcm_delay;
! 
! eServiceMP3::eServiceMP3(eServiceReference ref)
! 	:m_ref(ref), m_pump(eApp, 1)
! {
! printf("Sira=1\n");
! cXineLib *xineLib = cXineLib::getInstance();
! //xineLib->stopVideo();
! 	m_state = stIdle;
! 	eDebug("eServiceMP3::construct!");
! 
! 	const char *filename = m_ref.path.c_str();
! 	//const char *ext = strrchr(filename, '.');
! char myfile[255];
! sprintf(myfile,"%s",filename);
! 
! 	ASSERT(m_state == stIdle);
! 	xineLib->FilmVideo(myfile);
! 
! 	m_state = stRunning;
! 	
! 	m_event(this, evStart);
! 	return ;
! }
! 
! eServiceMP3::~eServiceMP3()
! {printf("Sira=2\n");
! 	if (m_state == stRunning)
! 		stop();
! }
! 
! DEFINE_REF(eServiceMP3);
! 
! RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
! {
! 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
! 	return 0;
! }
! 
! RESULT eServiceMP3::start()
! {
! printf("Sira=3\n");
! 
! 	//ASSERT(m_state == stIdle);
! 
! 	m_state = stRunning;
! 	m_event(this, evStart);
! 
! 	return 0;
! }
! 
! void eServiceMP3::sourceTimeout()
! {
! 	eDebug("eServiceMP3::http source timeout! issuing eof...");
! 	m_event((iPlayableService*)this, evEOF);
! }
! 
! RESULT eServiceMP3::stop()
! {printf("Sira=4\n");
! 	ASSERT(m_state != stIdle);
! 
! 	if (m_state == stStopped)
! 		return -1;
! 
! 	m_state = stStopped;
!    cXineLib *xineLib = cXineLib::getInstance();
!     xineLib->stopVideo();
! 	return 0;
! }
! 
! RESULT eServiceMP3::setTarget(int target)
! {
! 	return -1;
! }
! 
! RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
! {printf("Sira=104\n");
! 	ptr=this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::setSlowMotion(int ratio)
! {printf("Sira=102\n");
! 	if (!ratio)
! 		return 0;
! 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1/(float)ratio);
! 	return trickSeek(1/(float)ratio);
! }
! 
! RESULT eServiceMP3::setFastForward(int ratio)
! {printf("Sira=101\n");
! 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
! 	return trickSeek(ratio);
! }
! 
! void eServiceMP3::seekTimeoutCB()
! {printf("Sira=100\n");
! 	pts_t ppos, len;
! 	getPlayPosition(ppos);
! 	getLength(len);
! 	ppos += 90000*m_currentTrickRatio;
! 	
! 	if (ppos < 0)
! 	{
! 		ppos = 0;
! 		m_seekTimeout->stop();
! 	}
! 	if (ppos > len)
! 	{
! 		ppos = 0;
! 		stop();
! 		m_seekTimeout->stop();
! 		return;
! 	}
! 	seekTo(ppos);
! }
! 
! 		// iPausableService
! RESULT eServiceMP3::pause()
! {
! 	if (m_state != stRunning)
! 		return -1;
! 
! 	cXineLib *xineLib = cXineLib::getInstance();
!     xineLib->VideoPause();
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::unpause()
! {printf("Sira=91\n");
! 
! 	if (m_state != stRunning)
! 		return -1;
! 
! 	cXineLib *xineLib = cXineLib::getInstance();
!     xineLib->VideoResume();
! 
! 	return 0;
! }
! 
! 	/* iSeekableService */
! RESULT eServiceMP3::seek(ePtr<iSeekableService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::getLength(pts_t &pts)
! {
! 	if (m_state != stRunning)
! 		return -1;
! 		
! cXineLib *xineLib = cXineLib::getInstance();
! xineLib->VideoPosisyon();
! pts=xineLib->Vlength*90;
! return 0;
! }
! 
! RESULT eServiceMP3::seekToImpl(pts_t to)
! {printf("Sira=8\n");
! 	return 0;
! }
! 
! RESULT eServiceMP3::seekTo(pts_t to)
! {
! printf("Sira=9\n");
! RESULT ret = 0;
! 
! 	return ret;
! }
! 
! 
! RESULT eServiceMP3::trickSeek(int ratio)
! {
! printf("Sira=11----Ratio=%d\n",ratio);
! 
! cXineLib *xineLib = cXineLib::getInstance();
! xineLib->VideoIleriF();
! 
! 	//if (!ratio) return seekRelative(0, 0);
! 	
! 	
! 	return 0;
! }
! 
! 
! RESULT eServiceMP3::seekRelative(int direction, pts_t to)
! {
! eDebug("eDVBServicePlay::seekRelative: jump %d, %lld", direction, to);
! 
! cXineLib *xineLib = cXineLib::getInstance();
! xineLib->VideoGeriT(to/90*direction);
! 
! 	return 0;
! }
! 
! RESULT eServiceMP3::getPlayPosition(pts_t &pts)
! {
! 
! if (m_state != stRunning)
! 		return -1;
! 
! cXineLib *xineLib = cXineLib::getInstance();
! xineLib->VideoPosisyon();
! pts=xineLib->Vpos*90;
! return 0;
! }
! 
! RESULT eServiceMP3::setTrickmode(int trick)
! {printf("Sira=11-1\n");
! 		/* trickmode is not yet supported by our dvbmediasinks. */
! 	return -1;
! }
! 
! RESULT eServiceMP3::isCurrentlySeekable()
! {
! printf("Sira=13\n");
! if (m_state != stRunning)
! 		return 0;
! 
! 	int ret = 3; // seeking and fast/slow winding possible
! 	return ret;
! }
! 
! RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
! {
! 	i = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::getName(std::string &name)
! {
! 	std::string title = m_ref.getName();
! 	if (title.empty())
! 	{
! 		name = m_ref.path;
! 		size_t n = name.rfind('/');
! 		if (n != std::string::npos)
! 			name = name.substr(n + 1);
! 	}
! 	else
! 		name = title;
! 	return 0;
! }
! 
! int eServiceMP3::getInfo(int w)
! {
! printf("Sira=15\n");
! 
! 	const gchar *tag = 0;
! 
! 	switch (w)
! 	{
! 	case sServiceref: return m_ref;
! 	case sVideoHeight: return m_height;
! 	case sVideoWidth: return m_width;
! 	case sFrameRate: return m_framerate;
! 	case sProgressive: return m_progressive;
! 	case sAspect: return m_aspect;
! 	case sTagTitle:
! 	case sTagArtist:
! 	case sTagAlbum:
! 	case sTagTitleSortname:
! 	case sTagArtistSortname:
! 	case sTagAlbumSortname:
! 	case sTagDate:
! 	case sTagComposer:
! 	case sTagGenre:
! 	case sTagComment:
! 	case sTagExtendedComment:
! 	case sTagLocation:
! 	case sTagHomepage:
! 	case sTagDescription:
! 	case sTagVersion:
! 	case sTagISRC:
! 	case sTagOrganization:
! 	case sTagCopyright:
! 	case sTagCopyrightURI:
! 	case sTagContact:
! 	case sTagLicense:
! 	case sTagLicenseURI:
! 	case sTagCodec:
! 	case sTagAudioCodec:
! 	case sTagVideoCodec:
! 	case sTagEncoder:
! 	case sTagLanguageCode:
! 	case sTagKeywords:
! 	case sTagChannelMode:
! 	case sUser+12:
! 		return resIsString;
! 	case sTagTrackGain:
! 	case sTagTrackPeak:
! 	case sTagAlbumGain:
! 	case sTagAlbumPeak:
! 	case sTagReferenceLevel:
! 	case sTagBeatsPerMinute:
! 	case sTagImage:
! 	case sTagPreviewImage:
! 	case sTagAttachment:
! 		return resIsPyObject;
! 	case sTagCRC:
! 		tag = "has-crc";
! 		break;
! 	default:
! 		return resNA;
! 	}
! 
! 	if (!m_stream_tags || !tag)
! 		return 0;
! 		
! 	return 0;
! }
! 
! std::string eServiceMP3::getInfoString(int w)
! {
! printf("Sira=16\n");
! 
! 	return "";
! }
! 
! PyObject *eServiceMP3::getInfoObject(int w)
! {
!   printf("Sira=17\n");
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::subtitle(ePtr<iSubtitleOutput> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! RESULT eServiceMP3::audioDelay(ePtr<iAudioDelay> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! int eServiceMP3::getNumberOfTracks()
! {
!  	return m_audioStreams.size();
! }
! 
! int eServiceMP3::getCurrentTrack()
! {/*
! 	if (m_currentAudioStream == -1)
! 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
! 	return m_currentAudioStream;*/
! }
! 
! RESULT eServiceMP3::selectTrack(unsigned int i)
! {
! 	pts_t ppos;
! 	getPlayPosition(ppos);
! 	ppos -= 90000;
! 	if (ppos < 0)
! 		ppos = 0;
! 
! 	int ret = selectAudioStream(i);
! 	if (!ret) {
! 		/* flush */
! 		seekTo(ppos);
! 	}
! 
! 	return ret;
! }
! 
! int eServiceMP3::selectAudioStream(int i)
! {
! printf("Sira=18\n");
! /*
! 	int current_audio;
! 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
! 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
! 	if ( current_audio == i )
! 	{
! 		eDebug ("eServiceMP3::switched to audio stream %i", current_audio);
! 		m_currentAudioStream = i;
! 		return 0;
! 	}
! 	return -1;*/
! }
! 
! int eServiceMP3::getCurrentChannel()
! {
! 	return STEREO;
! }
! 
! RESULT eServiceMP3::selectChannel(int i)
! {
! 	eDebug("eServiceMP3::selectChannel(%i)",i);
! 	return 0;
! }
! 
! RESULT eServiceMP3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
! {printf("Sira=19\n");
!  	if (i >= m_audioStreams.size())
! 		return -2;
! 		info.m_description = m_audioStreams[i].codec;
! /*	if (m_audioStreams[i].type == atMPEG)
! 		info.m_description = "MPEG";
! 	else if (m_audioStreams[i].type == atMP3)
! 		info.m_description = "MP3";
! 	else if (m_audioStreams[i].type == atAC3)
! 		info.m_description = "AC3";
! 	else if (m_audioStreams[i].type == atAAC)
! 		info.m_description = "AAC";
! 	else if (m_audioStreams[i].type == atDTS)
! 		info.m_description = "DTS";
! 	else if (m_audioStreams[i].type == atPCM)
! 		info.m_description = "PCM";
! 	else if (m_audioStreams[i].type == atOGG)
! 		info.m_description = "OGG";
! 	else if (m_audioStreams[i].type == atFLAC)
! 		info.m_description = "FLAC";
! 	else
! 		info.m_description = "???";*/
! 	if (info.m_language.empty())
! 		info.m_language = m_audioStreams[i].language_code;
! 	return 0;
! }
! 
! subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
! {
! printf("Sira=20\n");
! /*
! 	subtype_t type = stUnknown;
! 	GstCaps* caps = gst_pad_get_negotiated_caps(pad);
! 
! 	if ( caps )
! 	{
! 		GstStructure* str = gst_caps_get_structure(caps, 0);
! 		const gchar *g_type = gst_structure_get_name(str);
! 		eDebug("getSubtitleType::subtitle probe caps type=%s", g_type);
! 
! 		if ( !strcmp(g_type, "video/x-dvd-subpicture") )
! 			type = stVOB;
! 		else if ( !strcmp(g_type, "text/x-pango-markup") )
! 			type = stSSA;
! 		else if ( !strcmp(g_type, "text/plain") )
! 			type = stPlainText;
! 		else if ( !strcmp(g_type, "subpicture/x-pgs") )
! 			type = stPGS;
! 		else
! 			eDebug("getSubtitleType::unsupported subtitle caps %s (%s)", g_type, g_codec);
! 	}
! 	else if ( g_codec )
! 	{
! 		eDebug("getSubtitleType::subtitle probe codec tag=%s", g_codec);
! 		if ( !strcmp(g_codec, "VOB") )
! 			type = stVOB;
! 		else if ( !strcmp(g_codec, "SubStation Alpha") || !strcmp(g_codec, "SSA") )
! 			type = stSSA;
! 		else if ( !strcmp(g_codec, "ASS") )
! 			type = stASS;
! 		else if ( !strcmp(g_codec, "UTF-8 plain text") )
! 			type = stPlainText;
! 		else
! 			eDebug("getSubtitleType::unsupported subtitle codec %s", g_codec);
! 	}
! 	else
! 		eDebug("getSubtitleType::unidentifiable subtitle stream!");
! 
! 	return type;*/
! }
! 
! void eServiceMP3::gstBusCall(GstBus *bus, GstMessage *msg)
! {
! printf("Sira=21\n");
! /*
! 	if (!msg)
! 		return;
! 	gchar *sourceName;
! 	GstObject *source;
! 	source = GST_MESSAGE_SRC(msg);
! 	if (!GST_IS_OBJECT(source))
! 		return;
! 	sourceName = gst_object_get_name(source);
! #if 0
! 	gchar *string;
! 	if (gst_message_get_structure(msg))
! 		string = gst_structure_to_string(gst_message_get_structure(msg));
! 	else
! 		string = g_strdup(GST_MESSAGE_TYPE_NAME(msg));
! 	eDebug("eTsRemoteSource::gst_message from %s: %s", sourceName, string);
! 	g_free(string);
! #endif
! 	switch (GST_MESSAGE_TYPE (msg))
! 	{
! 		case GST_MESSAGE_EOS:
! 			m_event((iPlayableService*)this, evEOF);
! 			break;
! 		case GST_MESSAGE_STATE_CHANGED:
! 		{
! 			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
! 				break;
! 
! 			GstState old_state, new_state;
! 			gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
! 		
! 			if(old_state == new_state)
! 				break;
! 	
! 			eDebug("eServiceMP3::state transition %s -> %s", gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
! 	
! 			GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
! 	
! 			switch(transition)
! 			{
! 				case GST_STATE_CHANGE_NULL_TO_READY:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_READY_TO_PAUSED:
! 				{
! 					GstElement *appsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
!  					if (appsink)
!  					{
!  						g_object_set (G_OBJECT (appsink), "max-buffers", 2, NULL);
!  						g_object_set (G_OBJECT (appsink), "sync", FALSE, NULL);
!  						g_object_set (G_OBJECT (appsink), "emit-signals", TRUE, NULL);
!  						eDebug("eServiceMP3::appsink properties set!");
!  						gst_object_unref(appsink);
!  					}
! 					setAC3Delay(ac3_delay);
! 					setPCMDelay(pcm_delay);
! 				}	break;
! 				case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
! 				{
! 					if ( m_sourceinfo.is_streaming && m_streamingsrc_timeout )
! 						m_streamingsrc_timeout->stop();
! 				}	break;
! 				case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_PAUSED_TO_READY:
! 				{
! 				}	break;
! 				case GST_STATE_CHANGE_READY_TO_NULL:
! 				{
! 				}	break;
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_ERROR:
! 		{
! 			gchar *debug;
! 			GError *err;
! 			gst_message_parse_error (msg, &err, &debug);
! 			g_free (debug);
! 			eWarning("Gstreamer error: %s (%i) from %s", err->message, err->code, sourceName );
! 			if ( err->domain == GST_STREAM_ERROR )
! 			{
! 				if ( err->code == GST_STREAM_ERROR_CODEC_NOT_FOUND )
! 				{
! 					if ( g_strrstr(sourceName, "videosink") )
! 						m_event((iPlayableService*)this, evUser+11);
! 					else if ( g_strrstr(sourceName, "audiosink") )
! 						m_event((iPlayableService*)this, evUser+10);
! 				}
! 			}
! 			g_error_free(err);
! 			break;
! 		}
! 		case GST_MESSAGE_INFO:
! 		{
! 			gchar *debug;
! 			GError *inf;
! 	
! 			gst_message_parse_info (msg, &inf, &debug);
! 			g_free (debug);
! 			if ( inf->domain == GST_STREAM_ERROR && inf->code == GST_STREAM_ERROR_DECODE )
! 			{
! 				if ( g_strrstr(sourceName, "videosink") )
! 					m_event((iPlayableService*)this, evUser+14);
! 			}
! 			g_error_free(inf);
! 			break;
! 		}
! 		case GST_MESSAGE_TAG:
! 		{
! 			GstTagList *tags, *result;
! 			gst_message_parse_tag(msg, &tags);
! 	
! 			result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
! 			if (result)
! 			{
! 				if (m_stream_tags)
! 					gst_tag_list_free(m_stream_tags);
! 				m_stream_tags = result;
! 			}
! 	
! 			const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
! 			if ( gv_image )
! 			{
! 				GstBuffer *buf_image;
! 				buf_image = gst_value_get_buffer (gv_image);
! 				int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
! 				int ret = write(fd, GST_BUFFER_DATA(buf_image), GST_BUFFER_SIZE(buf_image));
! 				close(fd);
! 				eDebug("eServiceMP3::/tmp/.id3coverart %d bytes written ", ret);
! 				m_event((iPlayableService*)this, evUser+13);
! 			}
! 			gst_tag_list_free(tags);
! 			m_event((iPlayableService*)this, evUpdatedInfo);
! 			break;
! 		}
! 		case GST_MESSAGE_ASYNC_DONE:
! 		{
! 			if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_gst_playbin))
! 				break;
! 
! 			GstTagList *tags;
! 			gint i, active_idx, n_video = 0, n_audio = 0, n_text = 0;
! 
! 			g_object_get (m_gst_playbin, "n-video", &n_video, NULL);
! 			g_object_get (m_gst_playbin, "n-audio", &n_audio, NULL);
! 			g_object_get (m_gst_playbin, "n-text", &n_text, NULL);
! 
! 			eDebug("eServiceMP3::async-done - %d video, %d audio, %d subtitle", n_video, n_audio, n_text);
! 
! 			if ( n_video + n_audio <= 0 )
! 				stop();
! 
! 			active_idx = 0;
! 
! 			m_audioStreams.clear();
! 			m_subtitleStreams.clear();
! 
! 			for (i = 0; i < n_audio; i++)
! 			{
! 				audioStream audio;
! 				gchar *g_codec, *g_lang;
! 				GstPad* pad = 0;
! 				g_signal_emit_by_name (m_gst_playbin, "get-audio-pad", i, &pad);
! 				GstCaps* caps = gst_pad_get_negotiated_caps(pad);
! 				if (!caps)
! 					continue;
! 				GstStructure* str = gst_caps_get_structure(caps, 0);
! 				const gchar *g_type = gst_structure_get_name(str);
! 				audio.type = gstCheckAudioPad(str);
! 				g_codec = g_strdup(g_type);
! 				g_lang = g_strdup_printf ("und");
! 				g_signal_emit_by_name (m_gst_playbin, "get-audio-tags", i, &tags);
! 				if ( tags && gst_is_tag_list(tags) )
! 				{
! 					gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec);
! 					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 					gst_tag_list_free(tags);
! 				}
! 				audio.language_code = std::string(g_lang);
! 				audio.codec = std::string(g_codec);
! 				eDebug("eServiceMP3::audio stream=%i codec=%s language=%s", i, g_codec, g_lang);
! 				m_audioStreams.push_back(audio);
! 				g_free (g_lang);
! 				g_free (g_codec);
! 				gst_caps_unref(caps);
! 			}
! 
! 			for (i = 0; i < n_text; i++)
! 			{
! 				gchar *g_codec = NULL, *g_lang = NULL;
! 				g_signal_emit_by_name (m_gst_playbin, "get-text-tags", i, &tags);
! 				subtitleStream subs;
! //				int ret;
! 
! 				g_lang = g_strdup_printf ("und");
! 				if ( tags && gst_is_tag_list(tags) )
! 				{
! 					gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 					gst_tag_list_get_string(tags, GST_TAG_SUBTITLE_CODEC, &g_codec);
! 					gst_tag_list_free(tags);
! 				}
! 
! 				subs.language_code = std::string(g_lang);
! 				eDebug("eServiceMP3::subtitle stream=%i language=%s codec=%s", i, g_lang, g_codec);
! 				
! 				GstPad* pad = 0;
! 				g_signal_emit_by_name (m_gst_playbin, "get-text-pad", i, &pad);
! 				if ( pad )
! 					g_signal_connect (G_OBJECT (pad), "notify::caps", G_CALLBACK (gstTextpadHasCAPS), this);
! 				subs.type = getSubtitleType(pad, g_codec);
! 
! 				m_subtitleStreams.push_back(subs);
! 				g_free (g_lang);
! 			}
! 			m_event((iPlayableService*)this, evUpdatedEventInfo);
! 
! 			if ( m_errorInfo.missing_codec != "" )
! 			{
! 				if ( m_errorInfo.missing_codec.find("video/") == 0 || ( m_errorInfo.missing_codec.find("audio/") == 0 && getNumberOfTracks() == 0 ) )
! 					m_event((iPlayableService*)this, evUser+12);
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_ELEMENT:
! 		{
! 			if (const GstStructure *msgstruct = gst_message_get_structure(msg))
! 			{
! 				if ( gst_is_missing_plugin_message(msg) )
! 				{
! 					GstCaps *caps;
! 					gst_structure_get ((GstStructure*)msgstruct, "detail", GST_TYPE_CAPS, &caps, NULL); 
! 					std::string codec = (const char*) gst_caps_to_string(caps);
! 					gchar *description = gst_missing_plugin_message_get_description(msg);
! 					if ( description )
! 					{
! 						eDebug("eServiceMP3::m_errorInfo.missing_codec = %s", codec.c_str());
! 						m_errorInfo.error_message = "GStreamer plugin " + (std::string)description + " not available!\n";
! 						m_errorInfo.missing_codec = codec.substr(0,(codec.find_first_of(',')));
! 						g_free(description);
! 					}
! 					gst_caps_unref(caps);
! 				}
! 				else
! 				{
! 					const gchar *eventname = gst_structure_get_name(msgstruct);
! 					if ( eventname )
! 					{
! 						if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "aspect_ratio", &m_aspect);
! 							gst_structure_get_int (msgstruct, "width", &m_width);
! 							gst_structure_get_int (msgstruct, "height", &m_height);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoSizeChanged);
! 						}
! 						else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "frame_rate", &m_framerate);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoFramerateChanged);
! 						}
! 						else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
! 						{
! 							gst_structure_get_int (msgstruct, "progressive", &m_progressive);
! 							if (strstr(eventname, "Changed"))
! 								m_event((iPlayableService*)this, evVideoProgressiveChanged);
! 						}
! 					}
! 				}
! 			}
! 			break;
! 		}
! 		case GST_MESSAGE_BUFFERING:
! 		{
! 			GstBufferingMode mode;
! 			gst_message_parse_buffering(msg, &(m_bufferInfo.bufferPercent));
! 			gst_message_parse_buffering_stats(msg, &mode, &(m_bufferInfo.avgInRate), &(m_bufferInfo.avgOutRate), &(m_bufferInfo.bufferingLeft));
! 			m_event((iPlayableService*)this, evBuffering);
! 			break;
! 		}
! 		case GST_MESSAGE_STREAM_STATUS:
! 		{
! 			GstStreamStatusType type;
! 			GstElement *owner;
! 			gst_message_parse_stream_status (msg, &type, &owner);
! 			if ( type == GST_STREAM_STATUS_TYPE_CREATE && m_sourceinfo.is_streaming )
! 			{
! 				if ( GST_IS_PAD(source) )
! 					owner = gst_pad_get_parent_element(GST_PAD(source));
! 				else if ( GST_IS_ELEMENT(source) )
! 					owner = GST_ELEMENT(source);
! 				else
! 					owner = 0;
! 				if ( owner )
! 				{
! 					GstElementFactory *factory = gst_element_get_factory(GST_ELEMENT(owner));
! 					const gchar *name = gst_plugin_feature_get_name(GST_PLUGIN_FEATURE(factory));
! 					if (!strcmp(name, "souphttpsrc"))
! 					{
! 						m_streamingsrc_timeout->start(HTTP_TIMEOUT*1000, true);
! 						g_object_set (G_OBJECT (owner), "timeout", HTTP_TIMEOUT, NULL);
! 						eDebug("eServiceMP3::GST_STREAM_STATUS_TYPE_CREATE -> setting timeout on %s to %is", name, HTTP_TIMEOUT);
! 					}
! 					
! 				}
! 				if ( GST_IS_PAD(source) )
! 					gst_object_unref(owner);
! 			}
! 			break;
! 		}
! 		default:
! 			break;
! 	}
! 	g_free (sourceName);*/
! }
! 
! GstBusSyncReply eServiceMP3::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
! {
! printf("Sira=22\n");
! /*
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 	_this->m_pump.send(Message(1));
! 		/* wake 
! 	return GST_BUS_PASS;*/
! }
! 
! void eServiceMP3::gstHTTPSourceSetAgent(GObject *object, GParamSpec *unused, gpointer user_data)
! {
! printf("Sira=23\n");
! /*
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 	GstElement *source;
! 	g_object_get(_this->m_gst_playbin, "source", &source, NULL);
! 	g_object_set (G_OBJECT (source), "user-agent", _this->m_useragent.c_str(), NULL);
! 	gst_object_unref(source);*/
! }
! 
! audiotype_t eServiceMP3::gstCheckAudioPad(GstStructure* structure)
! {
! printf("Sira=24\n");
! /*
! 	if (!structure)
! 		return atUnknown;
! 
! 	if ( gst_structure_has_name (structure, "audio/mpeg"))
! 	{
! 		gint mpegversion, layer = -1;
! 		if (!gst_structure_get_int (structure, "mpegversion", &mpegversion))
! 			return atUnknown;
! 
! 		switch (mpegversion) {
! 			case 1:
! 				{
! 					gst_structure_get_int (structure, "layer", &layer);
! 					if ( layer == 3 )
! 						return atMP3;
! 					else
! 						return atMPEG;
! 					break;
! 				}
! 			case 2:
! 				return atAAC;
! 			case 4:
! 				return atAAC;
! 			default:
! 				return atUnknown;
! 		}
! 	}
! 
! 	else if ( gst_structure_has_name (structure, "audio/x-ac3") || gst_structure_has_name (structure, "audio/ac3") )
! 		return atAC3;
! 	else if ( gst_structure_has_name (structure, "audio/x-dts") || gst_structure_has_name (structure, "audio/dts") )
! 		return atDTS;
! 	else if ( gst_structure_has_name (structure, "audio/x-raw-int") )
! 		return atPCM;
! 
! 	return atUnknown;*/
! }
! 
! void eServiceMP3::gstPoll(const Message &msg)
! {
! 
! printf("Sira=25\n");
! /*
! 	if (msg.type == 1)
! 	{
! 		GstBus *bus = gst_pipeline_get_bus (GST_PIPELINE (m_gst_playbin));
! 		GstMessage *message;
! 		while ((message = gst_bus_pop(bus)))
! 		{
! 			gstBusCall(bus, message);
! 			gst_message_unref (message);
! 		}
! 	}
! 	else if (msg.type == 2)
! 		pullSubtitle();
! 	else if (msg.type == 3)
! 		gstTextpadHasCAPS_synced(msg.d.pad);
! 	else
! 		eDebug("gstPoll unhandled Message %d\n", msg.type);*/
! }
! 
! eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
! 
! void eServiceMP3::gstCBsubtitleAvail(GstElement *appsink, gpointer user_data)
! {
! printf("Sira=26\n");
! /*
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;	
! 	eSingleLocker l(_this->m_subs_to_pull_lock);
! 	++_this->m_subs_to_pull;
! 	_this->m_pump.send(Message(2));*/
! }
! 
! void eServiceMP3::gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data)
! {
! printf("Sira=27\n");
! /*
! 	eServiceMP3 *_this = (eServiceMP3*)user_data;
! 
! 	gst_object_ref (pad);
! 
! 	_this->m_pump.send(Message(3, pad));*/
! }
! 
! // after messagepump
! void eServiceMP3::gstTextpadHasCAPS_synced(GstPad *pad)
! {
! printf("Sira=28\n");
! /*
! 	GstCaps *caps;
! 
! 	g_object_get (G_OBJECT (pad), "caps", &caps, NULL);
! 
! 	eDebug("gstTextpadHasCAPS:: signal::caps = %s", gst_caps_to_string(caps));
! 
! 	if (caps)
! 	{
! 		subtitleStream subs;
! 
! //		eDebug("gstGhostpadHasCAPS_synced %p %d", pad, m_subtitleStreams.size());
! 
! 		if (!m_subtitleStreams.empty())
! 			subs = m_subtitleStreams[m_currentSubtitleStream];
! 		else {
! 			subs.type = stUnknown;
! 			subs.pad = pad;
! 		}
! 
! 		if ( subs.type == stUnknown )
! 		{
! 			GstTagList *tags;
! //			eDebug("gstGhostpadHasCAPS::m_subtitleStreams[%i].type == stUnknown...", m_currentSubtitleStream);
! 
! 			gchar *g_lang;
! 			g_signal_emit_by_name (m_gst_playbin, "get-text-tags", m_currentSubtitleStream, &tags);
! 
! 			g_lang = g_strdup_printf ("und");
! 			if ( tags && gst_is_tag_list(tags) )
! 				gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
! 
! 			subs.language_code = std::string(g_lang);
! 			subs.type = getSubtitleType(pad);
! 
! 			if (!m_subtitleStreams.empty())
! 				m_subtitleStreams[m_currentSubtitleStream] = subs;
! 			else
! 				m_subtitleStreams.push_back(subs);
! 
! 			g_free (g_lang);
! 		}
! 
! //		eDebug("gstGhostpadHasCAPS:: m_gst_prev_subtitle_caps=%s equal=%i",gst_caps_to_string(m_gst_prev_subtitle_caps),gst_caps_is_equal(m_gst_prev_subtitle_caps, caps));
! 
! 		gst_caps_unref (caps);
! 	}
! 
! 	gst_object_unref (pad);*/
! }
! 
! void eServiceMP3::pullSubtitle()
! {
! printf("Sira=29\n");
! /*
! 	GstElement *sink;
! 	g_object_get (G_OBJECT (m_gst_playbin), "text-sink", &sink, NULL);
! 	
! 	if (sink)
! 	{
! 		while (m_subs_to_pull && m_subtitle_pages.size() < 2)
! 		{
! 			GstBuffer *buffer;
! 			{
! 				eSingleLocker l(m_subs_to_pull_lock);
! 				--m_subs_to_pull;
! 				g_signal_emit_by_name (sink, "pull-buffer", &buffer);
! 			}
! 			if (buffer)
! 			{
! 				gint64 buf_pos = GST_BUFFER_TIMESTAMP(buffer);
! 				gint64 duration_ns = GST_BUFFER_DURATION(buffer);
! 				size_t len = GST_BUFFER_SIZE(buffer);
! 				eDebug("pullSubtitle m_subtitleStreams[m_currentSubtitleStream].type=%i",m_subtitleStreams[m_currentSubtitleStream].type);
! 				
! 				if ( m_subtitleStreams[m_currentSubtitleStream].type )
! 				{
! 					if ( m_subtitleStreams[m_currentSubtitleStream].type < stVOB )
! 					{
! 						unsigned char line[len+1];
! 						SubtitlePage page;
! 						memcpy(line, GST_BUFFER_DATA(buffer), len);
! 						line[len] = 0;
! 						eDebug("got new text subtitle @ buf_pos = %lld ns (in pts=%lld): '%s' ", buf_pos, buf_pos/11111, line);
! 						gRGB rgbcol(0xD0,0xD0,0xD0);
! 						page.type = SubtitlePage::Pango;
! 						page.pango_page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)line));
! 						page.pango_page.m_show_pts = buf_pos / 11111L;
! 						page.pango_page.m_timeout = duration_ns / 1000000;
! 						m_subtitle_pages.push_back(page);
! 						if (m_subtitle_pages.size()==1)
! 							pushSubtitles();
! 					}
! 					else
! 					{
! 						eDebug("unsupported subpicture... ignoring");
! 					}
! 				}
! 				gst_buffer_unref(buffer);
! 			}
! 		}
! 		gst_object_unref(sink);
! 	}
! 	else
! 		eDebug("no subtitle sink!");
! }
! 
! void eServiceMP3::pushSubtitles()
! {
! 	while ( !m_subtitle_pages.empty() )
! 	{
! 		SubtitlePage &frontpage = m_subtitle_pages.front();
! 		pts_t running_pts;
! 		gint64 diff_ms = 0;
! 		gint64 show_pts = 0;
! 
! 		getPlayPosition(running_pts);
! 
! 		if (m_decoder_time_valid_state < 4) {
! 			++m_decoder_time_valid_state;
! 			if (m_prev_decoder_time == running_pts)
! 				m_decoder_time_valid_state = 0;
! 			if (m_decoder_time_valid_state < 4) {
! //				if (m_decoder_time_valid_state)
! //					eDebug("%d: decoder time not valid! prev %lld, now %lld\n", m_decoder_time_valid_state, m_prev_decoder_time/90, running_pts/90);
! //				else
! //					eDebug("%d: decoder time not valid! now %lld\n", m_decoder_time_valid_state, running_pts/90);
! 				m_subtitle_sync_timer->start(25, true);
! 				m_prev_decoder_time = running_pts;
! 				break;
! 			}
! 		}
! 
! 		if (frontpage.type == SubtitlePage::Pango)
! 			show_pts = frontpage.pango_page.m_show_pts;
! 
! 		diff_ms = ( show_pts - running_pts ) / 90;
! 		eDebug("check subtitle: decoder: %lld, show_pts: %lld, diff: %lld ms", running_pts/90, show_pts/90, diff_ms);
! 
! 		if ( diff_ms < -100 )
! 		{
! 			eDebug("subtitle too late... drop");
! 			m_subtitle_pages.pop_front();
! 		}
! 		else if ( diff_ms > 20 )
! 		{
! 			eDebug("start timer");
! 			m_subtitle_sync_timer->start(diff_ms, true);
! 			break;
! 		}
! 		else // immediate show
! 		{
! 			if ( m_subtitle_widget )
! 			{
! 				eDebug("show!\n");
! 				if ( frontpage.type == SubtitlePage::Pango)
! 					m_subtitle_widget->setPage(frontpage.pango_page);
! 				m_subtitle_widget->show();
! 			}
! 			m_subtitle_pages.pop_front();
! 		}
! 	}
! 	if (m_subtitle_pages.empty())
! 		pullSubtitle();*/
! }
! 
! 
! RESULT eServiceMP3::enableSubtitles(eWidget *parent, ePyObject tuple)
! {
! printf("Sira=30\n");
! /*
! 	eDebug ("eServiceMP3::enableSubtitles m_currentSubtitleStream=%i this=%p",m_currentSubtitleStream, this);
! 	ePyObject entry;
! 	int tuplesize = PyTuple_Size(tuple);
! 	int pid, type;
! 	gint text_pid = 0;
! 	eSingleLocker l(m_subs_to_pull_lock);
! 
! // 	GstPad *pad = 0;
! // 	g_signal_emit_by_name (m_gst_playbin, "get-text-pad", m_currentSubtitleStream, &pad);
! // 	gst_element_get_static_pad(m_gst_subtitlebin, "sink");
! // 	gulong subprobe_handler_id = gst_pad_add_buffer_probe (pad, G_CALLBACK (gstCBsubtitleDrop), NULL);
! 
! 	if (!PyTuple_Check(tuple))
! 		goto error_out;
! 	if (tuplesize < 1)
! 		goto error_out;
! 	entry = PyTuple_GET_ITEM(tuple, 1);
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 	pid = PyInt_AsLong(entry);
! 	entry = PyTuple_GET_ITEM(tuple, 2);
! 	if (!PyInt_Check(entry))
! 		goto error_out;
! 	type = PyInt_AsLong(entry);
! 
! 	if (m_currentSubtitleStream != pid)
! 	{
! 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", pid, NULL);
! 		eDebug ("eServiceMP3::enableSubtitles g_object_set current-text = %i", pid);
! 		m_currentSubtitleStream = pid;
! 		m_subs_to_pull = 0;
! 		m_prev_decoder_time = -1;
! 		m_subtitle_pages.clear();
! 	}
! 
! 	m_subtitle_widget = 0;
! 	m_subtitle_widget = new eSubtitleWidget(parent);
! 	m_subtitle_widget->resize(parent->size()); /* full size 
! 
! 	g_object_get (G_OBJECT (m_gst_playbin), "current-text", &text_pid, NULL);
! 
! 	eDebug ("eServiceMP3::switched to subtitle stream %i", text_pid);
! // 	gst_pad_remove_buffer_probe (pad, subprobe_handler_id);
! 
! 	m_event((iPlayableService*)this, evUpdatedInfo);
! 
! 	return 0;
! 
! error_out:
! 	eDebug("eServiceMP3::enableSubtitles needs a tuple as 2nd argument!\n"
! 		"for gst subtitles (2, subtitle_stream_count, subtitle_type)");
! 	return -1;*/
! }
! 
! RESULT eServiceMP3::disableSubtitles(eWidget *parent)
! {
! 	eDebug("eServiceMP3::disableSubtitles");
! 	m_subtitle_pages.clear();
! 	delete m_subtitle_widget;
! 	m_subtitle_widget = 0;
! 	return 0;
! }
! 
! PyObject *eServiceMP3::getCachedSubtitle()
! {
! // 	eDebug("eServiceMP3::getCachedSubtitle");
! 	Py_RETURN_NONE;
! }
! 
! PyObject *eServiceMP3::getSubtitleList()
! {printf("Sira=31\n");
! // 	eDebug("eServiceMP3::getSubtitleList");
! 	ePyObject l = PyList_New(0);
! 	int stream_idx = 0;
! 	
! 	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
! 	{
! 		subtype_t type = IterSubtitleStream->type;
! 		switch(type)
! 		{
! 		case stUnknown:
! 		case stVOB:
! 		case stPGS:
! 			break;
! 		default:
! 		{
! 			ePyObject tuple = PyTuple_New(5);
! //			eDebug("eServiceMP3::getSubtitleList idx=%i type=%i, code=%s", stream_idx, int(type), (IterSubtitleStream->language_code).c_str());
! 			PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(2));
! 			PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(stream_idx));
! 			PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(int(type)));
! 			PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(0));
! 			PyTuple_SET_ITEM(tuple, 4, PyString_FromString((IterSubtitleStream->language_code).c_str()));
! 			PyList_Append(l, tuple);
! 			Py_DECREF(tuple);
! 		}
! 		}
! 		stream_idx++;
! 	}
! 	eDebug("eServiceMP3::getSubtitleList finished");
! 	return l;
! }
! 
! RESULT eServiceMP3::streamed(ePtr<iStreamedService> &ptr)
! {
! 	ptr = this;
! 	return 0;
! }
! 
! PyObject *eServiceMP3::getBufferCharge()
! {
! 	ePyObject tuple = PyTuple_New(5);
! 	PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(m_bufferInfo.bufferPercent));
! 	PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(m_bufferInfo.avgInRate));
! 	PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(m_bufferInfo.avgOutRate));
! 	PyTuple_SET_ITEM(tuple, 3, PyInt_FromLong(m_bufferInfo.bufferingLeft));
! 	PyTuple_SET_ITEM(tuple, 4, PyInt_FromLong(m_buffer_size));
! 	return tuple;
! }
! 
! int eServiceMP3::setBufferSize(int size)
! {
! 	m_buffer_size = size;
! 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
! 	return 0;
! }
! 
! int eServiceMP3::getAC3Delay()
! {
! 	return ac3_delay;
! }
! 
! int eServiceMP3::getPCMDelay()
! {
! 	return pcm_delay;
! }
! 
! void eServiceMP3::setAC3Delay(int delay)
! {
! 
! printf("Sira=32\n");
! /*
! 	ac3_delay = delay;
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return;
! 	else
! 	{
! 		GstElement *sink;
! 		int config_delay_int = delay;
! 		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			std::string config_delay;
! 			if(ePythonConfigQuery::getConfigValue("config.av.generalAC3delay", config_delay) == 0)
! 				config_delay_int += atoi(config_delay.c_str());
! 			gst_object_unref(sink);
! 		}
! 		else
! 		{
! 			eDebug("dont apply ac3 delay when no video is running!");
! 			config_delay_int = 0;
! 		}
! 
! 		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			gchar *name = gst_element_get_name(sink);
! 			if (strstr(name, "dvbaudiosink"))
! 				eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
! 			g_free(name);
! 			gst_object_unref(sink);
! 		}
! 	}*/
! }
! 
! void eServiceMP3::setPCMDelay(int delay)
! {
! printf("Sira=33\n");
! /*
! 	pcm_delay = delay;
! 	if (!m_gst_playbin || m_state != stRunning)
! 		return;
! 	else
! 	{
! 		GstElement *sink;
! 		int config_delay_int = delay;
! 		g_object_get (G_OBJECT (m_gst_playbin), "video-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			std::string config_delay;
! 			if(ePythonConfigQuery::getConfigValue("config.av.generalPCMdelay", config_delay) == 0)
! 				config_delay_int += atoi(config_delay.c_str());
! 			gst_object_unref(sink);
! 		}
! 		else
! 		{
! 			eDebug("dont apply pcm delay when no video is running!");
! 			config_delay_int = 0;
! 		}
! 
! 		g_object_get (G_OBJECT (m_gst_playbin), "audio-sink", &sink, NULL);
! 
! 		if (sink)
! 		{
! 			gchar *name = gst_element_get_name(sink);
! 			if (strstr(name, "dvbaudiosink"))
! 				eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
! 			else
! 			{
! 				// this is realy untested..and not used yet
! 				gint64 offset = config_delay_int;
! 				offset *= 1000000; // milli to nano
! 				g_object_set (G_OBJECT (m_gst_playbin), "ts-offset", offset, NULL);
! 			}
! 			g_free(name);
! 			gst_object_unref(sink);
! 		}
! 	}*/
! }
! 
diff -crB Enigma2PC/lib/service/servicemp3.h Enigma2PC_orig/lib/service/servicemp3.h
*** Enigma2PC/lib/service/servicemp3.h	2011-11-20 21:56:11.260830302 +0400
--- Enigma2PC_orig/lib/service/servicemp3.h	2011-11-20 03:13:00.000000000 +0400
***************
*** 1,270 ****
! #ifndef __servicemp3_h
! #define __servicemp3_h
! 
! #include <lib/base/message.h>
! #include <lib/service/iservice.h>
! #include <lib/dvb/pmt.h>
! #include <lib/dvb/subtitle.h>
! #include <lib/dvb/teletext.h>
! #include <gst/gst.h>
! /* for subtitles */
! #include <lib/gui/esubtitle.h>
! 
! class eStaticServiceMP3Info;
! 
! class eSubtitleWidget;
! 
! class eServiceFactoryMP3: public iServiceHandler
! {
! 	DECLARE_REF(eServiceFactoryMP3);
! public:
! 	eServiceFactoryMP3();
! 	virtual ~eServiceFactoryMP3();
! 	enum { id = 0x1001 };
! 
! 		// iServiceHandler
! 	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
! 	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
! 	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
! 	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
! 	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
! private:
! 	ePtr<eStaticServiceMP3Info> m_service_info;
! };
! 
! class eStaticServiceMP3Info: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceMP3Info);
! 	friend class eServiceFactoryMP3;
! 	eStaticServiceMP3Info();
! public:
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	int getInfo(const eServiceReference &ref, int w);
! };
! 
! typedef struct _GstElement GstElement;
! 
! typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC } audiotype_t;
! typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
! typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA } containertype_t;
! 
! class eServiceMP3: public iPlayableService, public iPauseableService,
! 	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
! 	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object
! {
! 	DECLARE_REF(eServiceMP3);
! public:
! 	virtual ~eServiceMP3();
! 
! 		// iPlayableService
! 	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
! 	RESULT start();
! 	RESULT stop();
! 	RESULT setTarget(int target);
! 	
! 	RESULT pause(ePtr<iPauseableService> &ptr);
! 	RESULT setSlowMotion(int ratio);
! 	RESULT setFastForward(int ratio);
! 
! 	RESULT seek(ePtr<iSeekableService> &ptr);
! 	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
! 	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
! 	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
! 	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
! 
! 		// not implemented (yet)
! 	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
! 	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
! 	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
! 	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
! 
! 	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
! 	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
! 	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
! 
! 		// iPausableService
! 	RESULT pause();
! 	RESULT unpause();
! 	
! 	RESULT info(ePtr<iServiceInformation>&);
! 	
! 		// iSeekableService
! 	RESULT getLength(pts_t &SWIG_OUTPUT);
! 	RESULT seekTo(pts_t to);
! 	RESULT seekRelative(int direction, pts_t to);
! 	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
! 	RESULT setTrickmode(int trick);
! 	RESULT isCurrentlySeekable();
! 
! 		// iServiceInformation
! 	RESULT getName(std::string &name);
! 	int getInfo(int w);
! 	std::string getInfoString(int w);
! 	PyObject *getInfoObject(int w);
! 
! 		// iAudioTrackSelection	
! 	int getNumberOfTracks();
! 	RESULT selectTrack(unsigned int i);
! 	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
! 	int getCurrentTrack();
! 
! 		// iAudioChannelSelection	
! 	int getCurrentChannel();
! 	RESULT selectChannel(int i);
! 
! 		// iSubtitleOutput
! 	RESULT enableSubtitles(eWidget *parent, SWIG_PYOBJECT(ePyObject) entry);
! 	RESULT disableSubtitles(eWidget *parent);
! 	PyObject *getSubtitleList();
! 	PyObject *getCachedSubtitle();
! 
! 		// iStreamedService
! 	RESULT streamed(ePtr<iStreamedService> &ptr);
! 	PyObject *getBufferCharge();
! 	int setBufferSize(int size);
! 
! 		// iAudioDelay
! 	int getAC3Delay();
! 	int getPCMDelay();
! 	void setAC3Delay(int);
! 	void setPCMDelay(int);
! 
! 	struct audioStream
! 	{
! 		GstPad* pad;
! 		audiotype_t type;
! 		std::string language_code; /* iso-639, if available. */
! 		std::string codec; /* clear text codec description */
! 		audioStream()
! 			:pad(0), type(atUnknown)
! 		{
! 		}
! 	};
! 	struct subtitleStream
! 	{
! 		GstPad* pad;
! 		subtype_t type;
! 		std::string language_code; /* iso-639, if available. */
! 		subtitleStream()
! 			:pad(0)
! 		{
! 		}
! 	};
! 	struct sourceStream
! 	{
! 		audiotype_t audiotype;
! 		containertype_t containertype;
! 		bool is_video;
! 		bool is_streaming;
! 		sourceStream()
! 			:audiotype(atUnknown), containertype(ctNone), is_video(FALSE), is_streaming(FALSE)
! 		{
! 		}
! 	};
! 	struct bufferInfo
! 	{
! 		int bufferPercent;
! 		int avgInRate;
! 		int avgOutRate;
! 		int64_t bufferingLeft;
! 		bufferInfo()
! 			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
! 		{
! 		}
! 	};
! 	struct errorInfo
! 	{
! 		std::string error_message;
! 		std::string missing_codec;
! 	};
! 
! private:
! 	static int pcm_delay;
! 	static int ac3_delay;
! 	int m_currentAudioStream;
! 	int m_currentSubtitleStream;
! 	int selectAudioStream(int i);
! 	std::vector<audioStream> m_audioStreams;
! 	std::vector<subtitleStream> m_subtitleStreams;
! 	eSubtitleWidget *m_subtitle_widget;
! 	int m_currentTrickRatio;
! 	ePtr<eTimer> m_seekTimeout;
! 	void seekTimeoutCB();
! 	friend class eServiceFactoryMP3;
! 	eServiceReference m_ref;
! 	int m_buffer_size;
! 	bufferInfo m_bufferInfo;
! 	errorInfo m_errorInfo;
! 	eServiceMP3(eServiceReference ref);
! 	Signal2<void,iPlayableService*,int> m_event;
! 	enum
! 	{
! 		stIdle, stRunning, stStopped,
!         };
!         int m_state;
!         GstElement *m_gst_playbin;
!         GstTagList *m_stream_tags;
! 
!         struct Message
!         {
!                 Message()
!                         :type(-1)
!                 {}
!                 Message(int type)
!                         :type(type)
!                 {}
!                 Message(int type, GstPad *pad)
!                         :type(type)
!                 {
!                         d.pad=pad;
!                 }
! 
!                 int type;
!                 union {
!                         GstPad *pad; // for msg type 3
!                 } d;
!         };
! 
!         eFixedMessagePump<Message> m_pump;
! 
!         audiotype_t gstCheckAudioPad(GstStructure* structure);
!         void gstBusCall(GstBus *bus, GstMessage *msg);
!         static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data);
! 	static void gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data);
! 	void gstTextpadHasCAPS_synced(GstPad *pad);
!         static void gstCBsubtitleAvail(GstElement *element, gpointer user_data);
!         GstPad* gstCreateSubtitleSink(eServiceMP3* _this, subtype_t type);
! 	void gstPoll(const Message&);
!         static void gstHTTPSourceSetAgent(GObject *source, GParamSpec *unused, gpointer user_data);
! 
! 	struct SubtitlePage
! 	{
! 		enum { Unknown, Pango, Vob } type;
! 		ePangoSubtitlePage pango_page;
! 		eVobSubtitlePage vob_page;
! 	};
! 
!         std::list<SubtitlePage> m_subtitle_pages;
!         ePtr<eTimer> m_subtitle_sync_timer;
!         
!         ePtr<eTimer> m_streamingsrc_timeout;
!         pts_t m_prev_decoder_time;
!         int m_decoder_time_valid_state;
! 
!         void pushSubtitles();
!         void pullSubtitle();
!         void sourceTimeout();
!         int m_subs_to_pull;
!         sourceStream m_sourceinfo;
! 	eSingleLock m_subs_to_pull_lock;
! 	gulong m_subs_to_pull_handler_id;
! 
! 	RESULT seekToImpl(pts_t to);
! 
! 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
! 	std::string m_useragent;
! 	RESULT trickSeek(gdouble ratio);
! };
! 
! #endif
--- 1,270 ----
! #ifndef __servicemp3_h
! #define __servicemp3_h
! 
! #include <lib/base/message.h>
! #include <lib/service/iservice.h>
! #include <lib/dvb/pmt.h>
! #include <lib/dvb/subtitle.h>
! #include <lib/dvb/teletext.h>
! #include <gst/gst.h>
! /* for subtitles */
! #include <lib/gui/esubtitle.h>
! 
! class eStaticServiceMP3Info;
! 
! class eSubtitleWidget;
! 
! class eServiceFactoryMP3: public iServiceHandler
! {
! 	DECLARE_REF(eServiceFactoryMP3);
! public:
! 	eServiceFactoryMP3();
! 	virtual ~eServiceFactoryMP3();
! 	enum { id = 0x1001 };
! 
! 		// iServiceHandler
! 	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
! 	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
! 	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
! 	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
! 	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
! private:
! 	ePtr<eStaticServiceMP3Info> m_service_info;
! };
! 
! class eStaticServiceMP3Info: public iStaticServiceInformation
! {
! 	DECLARE_REF(eStaticServiceMP3Info);
! 	friend class eServiceFactoryMP3;
! 	eStaticServiceMP3Info();
! public:
! 	RESULT getName(const eServiceReference &ref, std::string &name);
! 	int getLength(const eServiceReference &ref);
! 	int getInfo(const eServiceReference &ref, int w);
! };
! 
! typedef struct _GstElement GstElement;
! 
! typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC } audiotype_t;
! typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
! typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA } containertype_t;
! 
! class eServiceMP3: public iPlayableService, public iPauseableService,
! 	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
! 	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object
! {
! 	DECLARE_REF(eServiceMP3);
! public:
! 	virtual ~eServiceMP3();
! 
! 		// iPlayableService
! 	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
! 	RESULT start();
! 	RESULT stop();
! 	RESULT setTarget(int target);
! 	
! 	RESULT pause(ePtr<iPauseableService> &ptr);
! 	RESULT setSlowMotion(int ratio);
! 	RESULT setFastForward(int ratio);
! 
! 	RESULT seek(ePtr<iSeekableService> &ptr);
! 	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
! 	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
! 	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
! 	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
! 
! 		// not implemented (yet)
! 	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
! 	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
! 	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
! 	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
! 
! 	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
! 	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
! 	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
! 
! 		// iPausableService
! 	RESULT pause();
! 	RESULT unpause();
! 	
! 	RESULT info(ePtr<iServiceInformation>&);
! 	
! 		// iSeekableService
! 	RESULT getLength(pts_t &SWIG_OUTPUT);
! 	RESULT seekTo(pts_t to);
! 	RESULT seekRelative(int direction, pts_t to);
! 	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
! 	RESULT setTrickmode(int trick);
! 	RESULT isCurrentlySeekable();
! 
! 		// iServiceInformation
! 	RESULT getName(std::string &name);
! 	int getInfo(int w);
! 	std::string getInfoString(int w);
! 	PyObject *getInfoObject(int w);
! 
! 		// iAudioTrackSelection	
! 	int getNumberOfTracks();
! 	RESULT selectTrack(unsigned int i);
! 	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
! 	int getCurrentTrack();
! 
! 		// iAudioChannelSelection	
! 	int getCurrentChannel();
! 	RESULT selectChannel(int i);
! 
! 		// iSubtitleOutput
! 	RESULT enableSubtitles(eWidget *parent, SWIG_PYOBJECT(ePyObject) entry);
! 	RESULT disableSubtitles(eWidget *parent);
! 	PyObject *getSubtitleList();
! 	PyObject *getCachedSubtitle();
! 
! 		// iStreamedService
! 	RESULT streamed(ePtr<iStreamedService> &ptr);
! 	PyObject *getBufferCharge();
! 	int setBufferSize(int size);
! 
! 		// iAudioDelay
! 	int getAC3Delay();
! 	int getPCMDelay();
! 	void setAC3Delay(int);
! 	void setPCMDelay(int);
! 
! 	struct audioStream
! 	{
! 		GstPad* pad;
! 		audiotype_t type;
! 		std::string language_code; /* iso-639, if available. */
! 		std::string codec; /* clear text codec description */
! 		audioStream()
! 			:pad(0), type(atUnknown)
! 		{
! 		}
! 	};
! 	struct subtitleStream
! 	{
! 		GstPad* pad;
! 		subtype_t type;
! 		std::string language_code; /* iso-639, if available. */
! 		subtitleStream()
! 			:pad(0)
! 		{
! 		}
! 	};
! 	struct sourceStream
! 	{
! 		audiotype_t audiotype;
! 		containertype_t containertype;
! 		bool is_video;
! 		bool is_streaming;
! 		sourceStream()
! 			:audiotype(atUnknown), containertype(ctNone), is_video(FALSE), is_streaming(FALSE)
! 		{
! 		}
! 	};
! 	struct bufferInfo
! 	{
! 		int bufferPercent;
! 		int avgInRate;
! 		int avgOutRate;
! 		int64_t bufferingLeft;
! 		bufferInfo()
! 			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
! 		{
! 		}
! 	};
! 	struct errorInfo
! 	{
! 		std::string error_message;
! 		std::string missing_codec;
! 	};
! 
! private:
! 	static int pcm_delay;
! 	static int ac3_delay;
! 	int m_currentAudioStream;
! 	int m_currentSubtitleStream;
! 	int selectAudioStream(int i);
! 	std::vector<audioStream> m_audioStreams;
! 	std::vector<subtitleStream> m_subtitleStreams;
! 	eSubtitleWidget *m_subtitle_widget;
! 	int m_currentTrickRatio;
! 	ePtr<eTimer> m_seekTimeout;
! 	void seekTimeoutCB();
! 	friend class eServiceFactoryMP3;
! 	eServiceReference m_ref;
! 	int m_buffer_size;
! 	bufferInfo m_bufferInfo;
! 	errorInfo m_errorInfo;
! 	eServiceMP3(eServiceReference ref);
! 	Signal2<void,iPlayableService*,int> m_event;
! 	enum
! 	{
! 		stIdle, stRunning, stStopped,
!         };
!         int m_state;
!         GstElement *m_gst_playbin;
!         GstTagList *m_stream_tags;
! 
!         struct Message
!         {
!                 Message()
!                         :type(-1)
!                 {}
!                 Message(int type)
!                         :type(type)
!                 {}
!                 Message(int type, GstPad *pad)
!                         :type(type)
!                 {
!                         d.pad=pad;
!                 }
! 
!                 int type;
!                 union {
!                         GstPad *pad; // for msg type 3
!                 } d;
!         };
! 
!         eFixedMessagePump<Message> m_pump;
! 
!         audiotype_t gstCheckAudioPad(GstStructure* structure);
!         void gstBusCall(GstBus *bus, GstMessage *msg);
!         static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data);
! 	static void gstTextpadHasCAPS(GstPad *pad, GParamSpec * unused, gpointer user_data);
! 	void gstTextpadHasCAPS_synced(GstPad *pad);
!         static void gstCBsubtitleAvail(GstElement *element, gpointer user_data);
!         GstPad* gstCreateSubtitleSink(eServiceMP3* _this, subtype_t type);
! 	void gstPoll(const Message&);
!         static void gstHTTPSourceSetAgent(GObject *source, GParamSpec *unused, gpointer user_data);
! 
! 	struct SubtitlePage
! 	{
! 		enum { Unknown, Pango, Vob } type;
! 		ePangoSubtitlePage pango_page;
! 		eVobSubtitlePage vob_page;
! 	};
! 
!         std::list<SubtitlePage> m_subtitle_pages;
!         ePtr<eTimer> m_subtitle_sync_timer;
!         
!         ePtr<eTimer> m_streamingsrc_timeout;
!         pts_t m_prev_decoder_time;
!         int m_decoder_time_valid_state;
! 
!         void pushSubtitles();
!         void pullSubtitle();
!         void sourceTimeout();
!         int m_subs_to_pull;
!         sourceStream m_sourceinfo;
! 	eSingleLock m_subs_to_pull_lock;
! 	gulong m_subs_to_pull_handler_id;
! 
! 	RESULT seekToImpl(pts_t to);
! 
! 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
! 	std::string m_useragent;
! 	RESULT trickSeek(int ratio);
! };
! 
! #endif
Only in Enigma2PC_orig: rollback_lirc_support.diff
