Index: src/EveLayout.cpp
===================================================================
--- src/EveLayout.cpp	(revisjon 1072)
+++ src/EveLayout.cpp	(arbeidskopi)
@@ -1813,7 +1813,7 @@
 #endif
 
             m_evaluator.evaluate(view_params.m_parameters);
-            adobe::dictionary_t parameters(move(m_evaluator.back().cast<adobe::dictionary_t>()));
+            adobe::dictionary_t parameters(adobe::move(m_evaluator.back().cast<adobe::dictionary_t>()));
             m_evaluator.pop_back();
 
 #if INSTRUMENT_WINDOW_CREATION
Index: GG/adobe/vector.hpp
===================================================================
--- GG/adobe/vector.hpp	(revisjon 1072)
+++ GG/adobe/vector.hpp	(arbeidskopi)
@@ -324,7 +324,7 @@
 template <typename T, typename A>
 template <typename I> // I models InputIterator
 void vector<T, A>::move_append(I f, I l, std::input_iterator_tag)
-{ while (f != l) { push_back(move(*f)); ++f; } }
+{ while (f != l) { push_back(adobe::move(*f)); ++f; } }
     
 template <typename T, typename A>
 template <typename I> // I models ForwardIterator
@@ -343,7 +343,7 @@
     size_type n(std::distance(f, l));
     
         if (remaining() < n) reserve((adobe::max)(size() + n, 2 * size()));
-    set_finish(uninitialized_move(f, l, end()));
+    set_finish(adobe::uninitialized_move(f, l, end()));
 }
     
 template <typename T, typename A>
@@ -412,13 +412,13 @@
         if (n < after) {
             move_append(last - n, last);
             move_backward(p, last - n, last);
-            move(f, l, p);
+            adobe::move(f, l, p);
         } else {
             I m = f;
             std::advance(m, after);
             move_append(m, l);
             move_append(p, last);
-            move(f, m, p);
+            adobe::move(f, m, p);
         }
     }
     return begin() + before + n;
@@ -430,7 +430,7 @@
     if (capacity() < n) {
         vector tmp;
         tmp.header_m = allocate(get_allocator(), n);
-        tmp.header_m->finish() = uninitialized_move(begin(), end(), tmp.end());
+        tmp.header_m->finish() = adobe::uninitialized_move(begin(), end(), tmp.end());
         swap(tmp);
     }
 }
@@ -469,7 +469,7 @@
 template <typename T, typename A>
 typename vector<T, A>::iterator vector<T, A>::erase(iterator f, iterator l)
 {
-    iterator i = move(l, end(), f);
+    iterator i = adobe::move(l, end(), f);
     for (iterator b(i), e(end()); b != e; ++b) {
         b->~value_type();
     }
Index: GG/adobe/any_regular.hpp
===================================================================
--- GG/adobe/any_regular.hpp	(revisjon 1072)
+++ GG/adobe/any_regular.hpp	(arbeidskopi)
@@ -220,7 +220,7 @@
     
     template <typename U>
     explicit any_regular_model_local(U x, typename move_sink<U, T>::type = 0)
-        : interface_type(vtable_s), object_m(move(x)) { }
+        : interface_type(vtable_s), object_m(adobe::move(x)) { }
         
     static const any_regular_model_local& self(const interface_type& x)
     { return static_cast<const any_regular_model_local&>(x); }
@@ -238,7 +238,7 @@
     { return ::new(storage) any_regular_model_local(self(x).object_m); }
     
     static interface_type* move_clone(interface_type& x, void* storage)
-    { return ::new(storage) any_regular_model_local(move(self(x).object_m)); }
+    { return ::new(storage) any_regular_model_local(adobe::move(self(x).object_m)); }
     
     static void assign(interface_type& x, const interface_type& y)
     { self(x).object_m = self(y).object_m; }
@@ -552,7 +552,7 @@
     
     template <typename T>
     explicit any_regular_t(T x, typename move_sink<T>::type = 0) : data_ptr_m(&data_m[0])
-    { ::new (storage()) typename traits<T>::model_type(move(x)); }
+    { ::new (storage()) typename traits<T>::model_type(adobe::move(x)); }
     
     /*!@}*/
     
@@ -613,7 +613,7 @@
     any_regular_t& assign(T x, typename move_sink<T>::type = 0)
     { 
         object().destruct();
-        ::new (storage()) typename traits<T>::model_type(move(x));
+        ::new (storage()) typename traits<T>::model_type(adobe::move(x));
         return *this;
     }
     
Index: GG/adobe/utility/pair.hpp
===================================================================
--- GG/adobe/utility/pair.hpp	(revisjon 1072)
+++ GG/adobe/utility/pair.hpp	(arbeidskopi)
@@ -79,11 +79,11 @@
     
     pair() : first(), second() { }
     
-    pair(move_from<pair> x) : first(move(x.source.first)), second(move(x.source.second)) { }
+    pair(move_from<pair> x) : first(adobe::move(x.source.first)), second(adobe::move(x.source.second)) { }
     
-    pair& operator=(pair x) { first = move(x.first); second = move(x.second); return *this; }
+    pair& operator=(pair x) { first = adobe::move(x.first); second = adobe::move(x.second); return *this; }
     
-    pair(T1 x, T2 y) : first(move(x)), second(move(y)) { }
+    pair(T1 x, T2 y) : first(adobe::move(x)), second(adobe::move(y)) { }
     
     template <typename U1, typename U2>
     pair(const pair<U1, U2>& p) : first(p.first), second(p.second) { }
@@ -107,7 +107,7 @@
 //! \ingroup asl_pair
 template <typename T1, typename T2>
 inline pair<T1, T2> make_pair(T1 x, T2 y)
-{ return pair<T1, T2>(move(x), move(y)); }
+{ return pair<T1, T2>(adobe::move(x), adobe::move(y)); }
 
 /*************************************************************************************************/
 
Index: GG/adobe/array.hpp
===================================================================
--- GG/adobe/array.hpp	(revisjon 1072)
+++ GG/adobe/array.hpp	(arbeidskopi)
@@ -30,10 +30,10 @@
 
 template <typename T> // T models Regular
 inline void push_back(array_t& v, T x, typename move_sink<T>::type = 0)
-{ v.push_back(any_regular_t(move(x))); }
+{ v.push_back(any_regular_t(adobe::move(x))); }
 
 inline void push_back(array_t& v, any_regular_t x)
-{ v.push_back(move(x)); }
+{ v.push_back(adobe::move(x)); }
 
 /**************************************************************************************************/
 
Index: GG/adobe/adam.hpp
===================================================================
--- GG/adobe/adam.hpp	(revisjon 1072)
+++ GG/adobe/adam.hpp	(arbeidskopi)
@@ -528,7 +528,7 @@
     relation_t(name_t n, line_position_t p, array_t e) :
         name_m(n),
         position_m(p),
-        expression_m(move(e))
+        expression_m(adobe::move(e))
     { }
     
     friend void swap(relation_t& x, relation_t& y)
@@ -541,7 +541,7 @@
     relation_t(move_from<relation_t> x) :
         name_m(x.source.name_m),
         position_m(x.source.position_m),
-        expression_m(move(x.source.expression_m))
+        expression_m(adobe::move(x.source.expression_m))
     { }
     
     relation_t& operator=(relation_t x) 
Index: GG/adobe/move.hpp
===================================================================
--- GG/adobe/move.hpp	(revisjon 1072)
+++ GG/adobe/move.hpp	(arbeidskopi)
@@ -396,7 +396,7 @@
 O move(I f, I l, O result)
 {
     while (f != l) {
-        *result = move(*f);
+        *result = adobe::move(*f);
         ++f; ++result;
     }
     return result;
@@ -411,7 +411,7 @@
 */
 template <typename I, // I models InputRange
           typename O> // O models OutputIterator
-inline O move(I& in, O out) { return move(boost::begin(in), boost::end(in), out); }
+inline O move(I& in, O out) { return adobe::move(boost::begin(in), boost::end(in), out); }
 
 /*************************************************************************************************/
  
@@ -426,7 +426,7 @@
 {
     while (f != l) {
         --l; --result;
-        *result = move(*l);
+        *result = adobe::move(*l);
     }
     return result;
 }
@@ -462,7 +462,7 @@
     explicit back_move_iterator(C& x) : container_m(&x) { }
     
     back_move_iterator& operator=(typename C::value_type x)
-    { container_m->push_back(move(x)); return *this; }
+    { container_m->push_back(adobe::move(x)); return *this; }
     
     back_move_iterator& operator*() { return *this; }
     back_move_iterator& operator++() { return *this; }
@@ -490,7 +490,7 @@
 template <typename T, typename U> // T models Regular
 inline void move_construct(T* p, U& x, typename move_sink<U, T>::type = 0)
 {
-    ::new(static_cast<void*>(p)) T(move(x));
+    ::new(static_cast<void*>(p)) T(adobe::move(x));
 }
 
 /*************************************************************************************************/
@@ -519,7 +519,7 @@
         typename move_sink<typename std::iterator_traits<I>::value_type>::type = 0)
 {
     while (f != l) {
-        move_construct(&*r, *f);
+        adobe::move_construct(&*r, *f);
         ++f; ++r;
     }
     return r;
Index: GG/adobe/string.hpp
===================================================================
--- GG/adobe/string.hpp	(revisjon 1072)
+++ GG/adobe/string.hpp	(arbeidskopi)
@@ -257,7 +257,7 @@
     /*!
         Move constructor.
     */
-    string_t(move_from<string_t> x) : storage_m(move(x.source.storage_m)) { }
+    string_t(move_from<string_t> x) : storage_m(adobe::move(x.source.storage_m)) { }
 
         /*!
                 Constructs a string_t from a regular C string (including string literals).
@@ -300,7 +300,7 @@
                 Assignment operator.
          */
 
-        string_t& operator=(string_t s) { storage_m = move(s.storage_m); return *this; }
+        string_t& operator=(string_t s) { storage_m = adobe::move(s.storage_m); return *this; }
 
         /*!
                 Conversion operator to std::string.
@@ -464,9 +464,9 @@
         Anything that can be concatenated using string_t::operator+=
         may also be concatenated to a string_t using operator+.
  */
-inline string_t operator+(string_t s1, const string_t& s2)     { return move(s1 += s2); }
-inline string_t operator+(string_t s1, const std::string& s2)  { return move(s1 += s2); }
-inline string_t operator+(string_t s1, const char* s2)         { return move(s1 += s2); }
+inline string_t operator+(string_t s1, const string_t& s2)     { return adobe::move(s1 += s2); }
+inline string_t operator+(string_t s1, const std::string& s2)  { return adobe::move(s1 += s2); }
+inline string_t operator+(string_t s1, const char* s2)         { return adobe::move(s1 += s2); }
 
 /*************************************************************************************************/
 
@@ -559,7 +559,7 @@
     /*!
         Move constructor.
          */
-    string16_t(move_from<string16_t> x) : storage_m(move(x.source.storage_m)) { }
+    string16_t(move_from<string16_t> x) : storage_m(adobe::move(x.source.storage_m)) { }
 
         /*!
                 Constructs a string16_t from a null-terminated sequence of 16-bit elements.
@@ -595,7 +595,7 @@
                 Assignment operator.
          */
         string16_t& operator=(string16_t s)
-                { storage_m = move(s.storage_m); return *this; }
+                { storage_m = adobe::move(s.storage_m); return *this; }
         
         /*!
                 Returns const pointer to a null-terminated sequence of 16-bit elements, identical to
@@ -734,8 +734,8 @@
         may also be concatenated to a string16_t using operator+.
  */
 
-inline string16_t operator+(string16_t s1, const string16_t& s2)      { return move(s1 += s2); }
-inline string16_t operator+(string16_t s1, const boost::uint16_t* s2) { return move(s1 += s2); }
+inline string16_t operator+(string16_t s1, const string16_t& s2)      { return adobe::move(s1 += s2); }
+inline string16_t operator+(string16_t s1, const boost::uint16_t* s2) { return adobe::move(s1 += s2); }
 
 //!@}
 
Index: GG/adobe/closed_hash.hpp
===================================================================
--- GG/adobe/closed_hash.hpp	(revisjon 1072)
+++ GG/adobe/closed_hash.hpp	(arbeidskopi)
@@ -448,7 +448,7 @@
     
     template <typename I> // I models ForwardIterator
     void move_insert(I first, I last)
-    { while (first != last) { insert(move(*first)); ++first; } }
+    { while (first != last) { insert(adobe::move(*first)); ++first; } }
     
     /*
         NOTE (sparent): If there is not enough space for one element we will reserve the space
@@ -480,12 +480,12 @@
             {
             iterator found = find(node, key_function()(x));
             if (found != end()) {
-                *found = move(x);
+                *found = adobe::move(x);
                 return std::make_pair(found, false);
             }
             
             iterator free(begin_free());
-            insert_raw(free, move(x), state_misplaced);
+            insert_raw(free, adobe::move(x), state_misplaced);
             unsafe::splice_node_range(node, free, free);
             node = free;
             }
@@ -493,7 +493,7 @@
         case state_misplaced:
             {
             iterator free(begin_free());
-            insert_raw(free, move(*node), state_misplaced);
+            insert_raw(free, adobe::move(*node), state_misplaced);
             
             unsafe::set_next(boost::prior(node), free);
             unsafe::set_next(free, boost::next(node));
@@ -503,7 +503,7 @@
             // fall through
         default: // state_free
             {
-            insert_raw(node, move(x), state_home);
+            insert_raw(node, adobe::move(x), state_home);
             unsafe::splice_node_range(end(), node, node);
             }
         }
@@ -520,7 +520,7 @@
     template <typename U>
     iterator insert(iterator, U x, typename move_sink<U, value_type>::type = 0)
     {
-        return insert(move(x)).first;
+        return insert(adobe::move(x)).first;
     }
     
     ~closed_hash_set()
