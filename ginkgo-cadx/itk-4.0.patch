diff -Nur ginkgocadx-3.1.0.498.20.orig/src/cadxcore/commands/comandoexportacion.cpp ginkgocadx-3.1.0.498.20/src/cadxcore/commands/comandoexportacion.cpp
--- ginkgocadx-3.1.0.498.20.orig/src/cadxcore/commands/comandoexportacion.cpp	2012-12-14 00:23:16.000000000 +1100
+++ ginkgocadx-3.1.0.498.20/src/cadxcore/commands/comandoexportacion.cpp	2012-12-27 16:41:35.939160807 +1100
@@ -41,7 +41,6 @@
 
 #include <itkExceptionObject.h>
 #include <itkImage.h>
-#include <itkOrientedImage.h>
 #include <itkRGBPixel.h>
 #include <itkGDCMImageIO.h>
 #include <itkJPEGImageIO.h>
diff -Nur ginkgocadx-3.1.0.498.20.orig/src/cadxcore/commands/thumbnailscommand.cpp ginkgocadx-3.1.0.498.20/src/cadxcore/commands/thumbnailscommand.cpp
--- ginkgocadx-3.1.0.498.20.orig/src/cadxcore/commands/thumbnailscommand.cpp	2012-12-14 00:23:16.000000000 +1100
+++ ginkgocadx-3.1.0.498.20/src/cadxcore/commands/thumbnailscommand.cpp	2012-12-27 16:41:27.471471788 +1100
@@ -51,7 +51,6 @@
 
 #include <itkExceptionObject.h>
 #include <itkImage.h>
-#include <itkOrientedImage.h>
 #include <itkRGBPixel.h>
 #include <itkGDCMImageIO.h>
 #include <itkImageFileReader.h>
diff -Nur ginkgocadx-3.1.0.498.20.orig/src/cadxcore/main/controllers/streaming/streamingloader.cpp ginkgocadx-3.1.0.498.20/src/cadxcore/main/controllers/streaming/streamingloader.cpp
--- ginkgocadx-3.1.0.498.20.orig/src/cadxcore/main/controllers/streaming/streamingloader.cpp	2012-12-14 00:23:31.000000000 +1100
+++ ginkgocadx-3.1.0.498.20/src/cadxcore/main/controllers/streaming/streamingloader.cpp	2012-12-27 16:41:14.274670052 +1100
@@ -45,7 +45,6 @@
 #include <vtkImageDataStreamer.h>
 
 #include <itkImage.h>
-#include <itkOrientedImage.h>
 #include <itkCommand.h>
 #include <itkMetaDataObject.h>
 
@@ -273,7 +272,7 @@
 							case ImageIO::UCHAR:
 								{
 									typedef unsigned char TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -283,7 +282,7 @@
 							case ImageIO::CHAR:
 								{
 									typedef char TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -293,7 +292,7 @@
 							case ImageIO::USHORT:
 								{
 									typedef unsigned short TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -303,7 +302,7 @@
 							case ImageIO::SHORT:
 								{
 									typedef short TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -313,7 +312,7 @@
 							case ImageIO::UINT:
 								{
 									typedef unsigned int TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -323,7 +322,7 @@
 							case ImageIO::INT:
 								{
 									typedef int TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -333,7 +332,7 @@
 							case ImageIO::ULONG:
 								{
 									typedef unsigned long TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -343,7 +342,7 @@
 							case ImageIO::LONG:
 								{
 									typedef long TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -353,7 +352,7 @@
 							case ImageIO::FLOAT:
 								{
 									typedef float TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -362,7 +361,7 @@
 							case ImageIO::DOUBLE:
 								{
 									typedef double TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -384,7 +383,7 @@
 								{
 									typedef unsigned char TypedComponentType;
 									typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -395,7 +394,7 @@
 								{
 									typedef char TypedComponentType;
 									typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 									pTypedReader->SetFileName(fichero);
@@ -406,7 +405,7 @@
 							{
 								typedef unsigned short TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -417,7 +416,7 @@
 							{
 								typedef short TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -428,7 +427,7 @@
 							{
 								typedef unsigned int TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -439,7 +438,7 @@
 							{
 								typedef int TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -450,7 +449,7 @@
 							{
 								typedef long TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -461,7 +460,7 @@
 							{
 								typedef unsigned long TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -472,7 +471,7 @@
 							{
 								typedef float TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -483,7 +482,7 @@
 							{
 								typedef double TypedComponentType;
 								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
-								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
 								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
 								pTypedReader->SetFileName(fichero);
@@ -670,7 +669,7 @@
 		m_pOutput->RemoveAllInputs();
 
 		typedef unsigned short TypedPixelType;
-		typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+		typedef itk::Image<TypedPixelType, 3 > TypedImageType;
 		typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
 		
 		TypedImageType::Pointer img = TypedImageType::New();
diff -Nur ginkgocadx-3.1.0.498.20.orig/src/cadxcore/main/controllers/streaming/streamingloader.cpp.orig ginkgocadx-3.1.0.498.20/src/cadxcore/main/controllers/streaming/streamingloader.cpp.orig
--- ginkgocadx-3.1.0.498.20.orig/src/cadxcore/main/controllers/streaming/streamingloader.cpp.orig	1970-01-01 10:00:00.000000000 +1000
+++ ginkgocadx-3.1.0.498.20/src/cadxcore/main/controllers/streaming/streamingloader.cpp.orig	2012-12-14 00:23:31.000000000 +1100
@@ -0,0 +1,1166 @@
+/*
+ *  
+ *  $Id: streamingloader.cpp $
+ *  Ginkgo CADx Project
+ *
+ *  Copyright 2008-12 MetaEmotion S.L. All rights reserved.
+ *  http://ginkgo-cadx.com
+ *
+ *  This file is licensed under LGPL v3 license.
+ *  See License.txt for details
+ *
+ *
+ */
+//#define _GINKGO_TRACE
+
+#include <wx/filename.h>
+#include <wx/file.h>
+#include <wx/thread.h>
+
+#include <api/globals.h>
+
+#include <api/icommand.h>
+#include <api/dicom/idicommanager.h>
+#include <api/controllers/icommandscontroller.h>
+#include <api/imodelointegracion.h>
+#include <api/internationalization/internationalization.h>
+#include <api/utils/iginkgomatrix4x4.h>
+
+#include <commands/comandocarga.h>
+
+#include <main/entorno.h>
+
+#include <main/controllers/controladorlog.h>
+#include <main/controllers/controladoreventos.h>
+#include <main/controllers/controladorvistas.h>
+#include <main/controllers/pacscontroller.h>
+
+#include "streamingloader.h"
+
+#ifdef __DEPRECATED
+#undef __DEPRECATED
+#endif
+
+#include <vtkImageData.h>
+#include <vtkImageDataStreamer.h>
+
+#include <itkImage.h>
+#include <itkOrientedImage.h>
+#include <itkCommand.h>
+#include <itkMetaDataObject.h>
+
+#include <itkImageFileReader.h>
+#include <itkGDCMSeriesFileNames.h>
+#include <itkVectorResampleImageFilter.h>
+#include <itk/itkImageToVTKImageFilter.h>
+#include <itkMetaDataDictionary.h>
+#include <vtkAlgorithmOutput.h>
+#include <vtkImageChangeInformation.h>
+
+//#include <gdcmFilename.h>
+//#include <gdcmSystem.h>
+//#include <gdcmDirectory.h>
+//#include <gdcmTrace.h>
+//#include <gdcmVersion.h>
+//#define DEBUG_PRINT_DIR_COSINES
+
+class CargaItkProgressCallback : public itk::Command
+{
+public:
+	typedef CargaItkProgressCallback         Self;
+	typedef itk::Command                     Superclass;
+
+	typedef itk::SmartPointer<Self>          Pointer;
+	typedef itk::SmartPointer<const Self>    ConstPointer;
+
+	itkTypeMacro (CargaItkProgressCallback, itk::Command);
+	itkNewMacro (Self);
+
+	/** Standard Command virtual methods */
+	void Execute(itk::Object *caller, const itk::EventObject &event){
+		itk::ProcessObject* po = dynamic_cast<itk::ProcessObject*>(caller);
+		if( !po )
+			return;
+
+		if( typeid(event) == typeid ( itk::ProgressEvent)  )
+		{
+			try {
+				if(!m_stop){
+					if (m_pComando) {
+						if (!m_pComando->NotificarProgreso(po->GetProgress(),m_texto))
+						{
+							po->SetAbortGenerateData(true);
+						}
+					}
+				}
+			}
+			catch(std::exception& /*ex*/){
+				po->SetAbortGenerateData(true);
+				return;
+			}
+		}
+	}
+
+	void Execute(const itk::Object *caller, const itk::EventObject &event){
+		itk::ProcessObject* po = dynamic_cast<itk::ProcessObject*>( const_cast<itk::Object*>(caller));
+
+		if( !po ) return;
+
+		if( typeid(event) == typeid ( itk::ProgressEvent)  )
+		{
+			try{
+				if(!m_stop){
+					if (m_pComando) {
+						if (!m_pComando->NotificarProgreso(po->GetProgress(),m_texto))
+						{
+							po->SetAbortGenerateData(true);
+						}
+					}
+				}
+			}catch(std::exception& /*ex*/){
+				po->SetAbortGenerateData(true);
+				return;
+			}
+		}
+	}
+
+	void SetCommand (GNC::GCS::IComando* cmd)
+	{
+		m_pComando = cmd;
+	}
+
+	void SetTexto  (std::string str)
+	{
+		m_texto = str;
+	}
+
+protected:
+	CargaItkProgressCallback(){
+		m_pComando = NULL;
+		m_stop=false;
+	}
+
+	~CargaItkProgressCallback(){
+		m_pComando = NULL;
+	}
+
+private:
+	GNC::GCS::IComando* m_pComando;
+	std::string m_texto;
+	bool m_stop;
+};
+
+
+
+GNC::StreamingLoader::StreamingLoader(): DirectionCosines(GNC::GCS::IGinkgoMatrix4x4::New())
+{
+
+	//gdcm::ImageHelper::SetForceRescaleInterceptSlope(true);
+	//gdcm::ImageHelper::SetForcePixelSpacing(true);
+
+	m_GantryTilt = 0.0;
+	m_SignalFile = false;
+	m_IO = ImageIO::New();
+	m_IO->SetLoadPrivateTags(false);
+	//Esto da leaks no activar
+	//m_IO->SetLoadSequences(false);
+	//
+	m_IO->SetUseStreamedReading(true);
+	m_IO->SetMaxSizeLoadEntry(1024); // No permitir cargar campos de mas de 1K
+	m_pOutput = vtkSmartPointer<vtkImageChangeInformation>::New();
+	//m_pOutput->SetNumberOfStreamDivisions(1);
+
+	m_CurrentNumberOfComponents = 0;
+	m_CurrentComponentType      = ImageIO::UNKNOWNCOMPONENTTYPE;
+	m_CurrentPixelType          = ImageIO::UNKNOWNPIXELTYPE;
+	m_CurrentDimensions[0] = 0;
+	m_CurrentDimensions[1] = 0;
+	m_CurrentDimensions[2] = 0;
+	DirectionCosines->Identity();
+	for (int i = 0; i < 3; i++) {
+		m_Spacing[i] = 0.0;
+		m_Origin[i] = 0.0;
+	}
+	
+}
+
+GNC::StreamingLoader::~StreamingLoader()
+{
+}
+
+void GNC::StreamingLoader::SetInput(const std::string& fichero)
+{
+
+	GNC::GCS::ILocker(this);
+
+	m_SignalFile = false;
+
+	if (m_CurrentFile == fichero) {
+		return;
+	}
+
+	try {
+		m_CurrentFile = fichero;
+		m_IO->SetFileName(fichero);
+
+		//correct a bug because this dictionary doesn't clear between consecutive loads
+		itk::MetaDataDictionary newDict;
+		m_IO->SetMetaDataDictionary(newDict);
+		//
+		m_IO->ReadImageInformation();
+
+		//std::string tagkey;
+		//std::string GantryTilt;
+
+		//itk::MetaDataDictionary & dict = m_IO->GetMetaDataDictionary();
+		//tagkey = "0018|1120";
+		//if( itk::ExposeMetaData<std::string>(dict, tagkey, GantryTilt ) )
+		//{
+		//	//std::cout << "Gantry Tilt = " << m_GantryTilt << std::endl;
+		//}
+		//// Check if the gantry tilt is within an acceptable range
+		//double gantryTiltThreshold = 0.01;
+
+		//std::stringstream sstr;
+		//sstr.str( GantryTilt );
+		//sstr >> m_GantryTilt;
+
+		//if( fabs(m_GantryTilt) > gantryTiltThreshold )
+		//{
+		//	//std::cout << "Unacceptable gantry tilt" << std::endl;
+		//}
+
+		{
+			#if defined(DEBUG_PRINT_DIR_COSINES)
+			std::cout << "Dir. Cosines: " << std::endl;
+			#endif
+			for (int di = 0; di < 3; di++)
+			{
+
+				const std::vector<double> dir = m_IO->GetDirection(di);
+				int l = 0;
+				for (std::vector<double>::const_iterator it = dir.begin(); it != dir.end() && l < 3; ++it, l++) {
+					#if defined(DEBUG_PRINT_DIR_COSINES)
+					if (!l == 0) {
+						std::cout << "," << *it;
+					}
+					else {
+						std::cout << *it;
+					}
+					#endif
+					DirectionCosines->SetElement(l, di, (*it));
+				}
+				#if defined(DEBUG_PRINT_DIR_COSINES)
+				std::cout << std::endl;
+				#endif
+
+			}
+			for (int i=0; i < 3; i++) {
+				m_Spacing[i] = m_IO->GetSpacing(i);
+				m_Origin[i]  = m_IO->GetOrigin(i);
+			}
+		}
+
+		if (m_CurrentNumberOfComponents != m_IO->GetNumberOfComponents() || m_CurrentComponentType != m_IO->GetComponentType() || m_CurrentPixelType != m_IO->GetPixelType() || m_CurrentDimensions[0] != m_IO->GetDimensions(0) || m_CurrentDimensions[1] != m_IO->GetDimensions(1) || m_CurrentDimensions[2] != m_IO->GetDimensions(2) )
+		{
+			RecomponerPipeline();
+		}
+		else {
+			switch(m_IO->GetNumberOfComponents()) {
+				case 1:
+					{
+						switch(m_IO->GetComponentType()) {
+							case ImageIO::UCHAR:
+								{
+									typedef unsigned char TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::CHAR:
+								{
+									typedef char TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::USHORT:
+								{
+									typedef unsigned short TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::SHORT:
+								{
+									typedef short TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::UINT:
+								{
+									typedef unsigned int TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::INT:
+								{
+									typedef int TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::ULONG:
+								{
+									typedef unsigned long TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::LONG:
+								{
+									typedef long TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::FLOAT:
+								{
+									typedef float TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+								}
+								break;
+							case ImageIO::DOUBLE:
+								{
+									typedef double TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::UNKNOWNCOMPONENTTYPE:
+							default:
+								m_SignalFile = true;
+								LOG_ERROR("StreamingLoader", "Tipo de componente (pixeltype) no soportado en imagenes de 1 componente")
+								break;
+						}
+					}
+					break;
+				case 3:
+					{
+						switch(m_IO->GetComponentType()) {
+							case ImageIO::UCHAR:
+								{
+									typedef unsigned char TypedComponentType;
+									typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::CHAR:
+								{
+									typedef char TypedComponentType;
+									typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+									typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+									typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+									TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+									pTypedReader->SetFileName(fichero);
+
+								}
+								break;
+							case ImageIO::USHORT:
+							{
+								typedef unsigned short TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::SHORT:
+							{
+								typedef short TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::UINT:
+							{
+								typedef unsigned int TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::INT:
+							{
+								typedef int TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::LONG:
+							{
+								typedef long TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::ULONG:
+							{
+								typedef unsigned long TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::FLOAT:
+							{
+								typedef float TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::DOUBLE:
+							{
+								typedef double TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								TypedReaderType* pTypedReader = static_cast<TypedReaderType*>(m_pReader.GetPointer());
+								pTypedReader->SetFileName(fichero);
+								
+							}
+								break;
+							case ImageIO::UNKNOWNCOMPONENTTYPE:
+							default:
+								m_SignalFile = true;
+								LOG_ERROR("StreamingLoader", "Tipo de componente (pixeltype) no soportado en imagenes de 3 componentes")
+								break;
+						}
+					}
+					break;
+				default:
+					m_SignalFile = true;
+					LOG_ERROR("StreamingLoader", "Numero de componentes no soportado")
+					break;
+			}
+
+			m_pReader->Modified();
+			m_pPipelineJoiner->Modified();
+			m_pOutput->Modified();
+		}
+	}
+	catch (GNC::GCS::ControladorCargaException&)
+	{
+		m_SignalFile = true;
+		if (m_pReader) {
+			m_pReader->ResetPipeline();
+		}
+		throw;
+	}
+	catch (itk::ExceptionObject& ex)
+	{
+		if (m_pReader) {
+			m_pReader->ResetPipeline();
+		}
+
+		m_SignalFile = true;
+		
+		// Try to read as signal
+		GIL::DICOM::IDICOMManager* m = GIL::DICOM::PACSController::Instance()->CrearInstanciaDeDICOMManager();
+		m->CargarFichero(m_CurrentFile);
+		std::string modality;
+		m->GetTag(0x0008, 0x0060, modality);
+		//TODO: Mantener esta lectura del dataset.
+		GIL::DICOM::PACSController::Instance()->LiberarInstanciaDeDICOMManager(m);
+
+		if (modality == "ECG" || modality == "HD")
+		{
+			DirectionCosines->Identity();
+			RecomponerPipeline();
+			return;
+		}
+		else {
+			throw GNC::GCS::ControladorCargaException( _Std("Error reading the study: ") + ex.GetDescription(), "ControladorCarga/CargaMultidimensional");
+		}
+	}
+	catch (...)
+	{
+		if (m_pReader) {
+			m_pReader->ResetPipeline();
+		}
+		throw GNC::GCS::ControladorCargaException( _Std("Internal error reading the study, unknown format "), "ControladorCarga/CargaMultidimensional");
+	}
+}
+
+void GNC::StreamingLoader::Update()
+{
+	m_pOutput->Update();
+}
+
+void GNC::StreamingLoader::UpdateInformation()
+{
+	m_pOutput->UpdateInformation();
+}
+
+void GNC::StreamingLoader::SetCustomOrientation(GNC::GCS::Vector3D&, GNC::GCS::Vector3D&, GNC::GCS::Vector3D&, double&)
+{
+
+}
+		
+
+vtkSmartPointer<vtkAlgorithmOutput> GNC::StreamingLoader::GetOutputPort()
+{
+	vtkSmartPointer<vtkAlgorithmOutput> out (m_pOutput->GetOutputPort());
+	return out;
+}
+
+void GNC::StreamingLoader::GetOutputCopy(vtkSmartPointer<vtkImageData>& output)
+{
+	GNC::GCS::ILocker((GNC::GCS::IStreamingLoader*)this);
+	output = vtkSmartPointer<vtkImageData>::New();
+	m_pOutput->Update();
+	output->DeepCopy(m_pOutput->GetOutput());
+
+}
+
+void GNC::StreamingLoader::GetDimensions(int dimensions[3])
+{
+	for (int i = 0; i < 3; i++)
+		dimensions[i] = m_CurrentDimensions[i];
+}
+
+void GNC::StreamingLoader::GetOutputDimensions(int currentDimensions[3])
+{
+	for (int i = 0; i<3; ++i)
+	{
+		currentDimensions[i] = m_CurrentDimensions[i];
+	}
+}
+
+bool GNC::StreamingLoader::GetDefaultWindowLevel(double &window, double &level)
+{
+	std::string windowTag, levelTag;
+	bool ok = m_IO->GetValueFromTag("0028|1050", levelTag) && m_IO->GetValueFromTag("0028|1051", windowTag);
+	if (ok) {
+		{
+			std::istringstream istr(levelTag);
+			istr >> level;	
+		}
+		{
+			std::istringstream istr(windowTag);
+			istr >> window;	
+		}		
+	}
+	return ok;	
+}
+
+const GNC::GCS::Ptr<GNC::GCS::IGinkgoMatrix4x4> GNC::StreamingLoader::GetDirection()
+{
+	return DirectionCosines;
+}
+
+void GNC::StreamingLoader::GetOrigin(double origin[3])
+{
+	for (int i = 0; i < 3; i++)
+		origin[i] = m_Origin[i];
+}
+
+void GNC::StreamingLoader::GetSpacing(double spacing[3])
+{
+	for (int i = 0; i < 3; i++)
+		spacing[i] = m_Spacing[i];
+}
+
+void GNC::StreamingLoader::SetOutputSpacing(double spacing[3])
+{
+	m_pOutput->SetOutputSpacing(spacing);
+}
+
+void GNC::StreamingLoader::SetOutputOrigin(double origin[3])
+{
+	m_pOutput->SetOutputOrigin(origin);
+}
+
+void GNC::StreamingLoader::GetOutputOrigin(double origin[3])
+{
+	m_pOutput->GetOutputOrigin(origin);
+}
+
+void GNC::StreamingLoader::GetOutputSpacing(double spacing[3])
+{
+	m_pOutput->GetOutputSpacing(spacing);
+}
+
+int GNC::StreamingLoader::GetCurrentSliceIndex()
+{
+	return 0;
+}
+
+void GNC::StreamingLoader::RecomponerPipeline()
+{
+	if (m_SignalFile) {
+		m_CurrentNumberOfComponents = 0;
+		m_CurrentComponentType      = ImageIO::UNKNOWNCOMPONENTTYPE;
+		m_CurrentPixelType          = ImageIO::SCALAR;
+		m_CurrentDimensions[0]      = 800;
+		m_CurrentDimensions[1]      = 800;
+		m_CurrentDimensions[2]      = 1;
+		m_pReader = NULL;
+		m_pPipelineJoiner = NULL;
+		m_pOutput->RemoveAllInputs();
+
+		typedef unsigned short TypedPixelType;
+		typedef itk::OrientedImage<TypedPixelType, 3 > TypedImageType;
+		typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+		
+		TypedImageType::Pointer img = TypedImageType::New();
+		TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+	
+		m_pPipelineJoiner = joiner;
+		joiner->SetInput(img);
+		
+		TypedImageType::SizeType size;
+		TypedImageType::IndexType index;
+		size[0] = 800;
+		size[1] = 800;
+		size[2] = 1;
+		index[0] = index[1] = index[2] = 0;
+		TypedImageType::RegionType region;
+		region.SetSize(size);
+		region.SetIndex(index);
+		img->SetRegions(region);
+		img->Allocate();
+		img->FillBuffer(0);
+
+		m_Origin[0] = m_Origin[1] = m_Origin[2] = 0.0;
+		m_Spacing[0] = m_Spacing[1] = m_Spacing[2] = 1.0;
+
+		m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+		m_pOutput->SetOutputOrigin(m_Origin);
+		m_pOutput->SetOutputSpacing(m_Spacing);
+	}
+	else {
+		m_CurrentNumberOfComponents = m_IO->GetNumberOfComponents();
+		m_CurrentComponentType      = m_IO->GetComponentType();
+		m_CurrentPixelType          = m_IO->GetPixelType();
+		m_CurrentDimensions[0]      = m_IO->GetDimensions(0);
+		m_CurrentDimensions[1]      = m_IO->GetDimensions(1);
+		m_CurrentDimensions[2]      = m_IO->GetDimensions(2);
+		m_pReader         = NULL;
+		m_pPipelineJoiner = NULL;
+
+		//m_pOutput->AbortExecuteOn();
+		m_pOutput->RemoveAllInputs();
+
+		ImageIO::Pointer pIO = ImageIO::New();
+		pIO->SetLoadPrivateTags(false);
+		//Esto da leaks no activar
+		//pIO->SetLoadSequences(false);
+		pIO->SetUseStreamedReading(true);
+		pIO->SetMaxSizeLoadEntry(1024); // No permitir cargar campos de mas de 1K
+		switch(m_IO->GetNumberOfComponents()) {
+			case 1:
+				{
+					switch(m_IO->GetComponentType()) {
+						case ImageIO::UCHAR:
+							{
+								typedef unsigned char TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+
+							}
+							break;
+						case ImageIO::CHAR:
+							{
+								typedef char TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::USHORT:
+							{
+								typedef unsigned short TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+
+							}
+							break;
+						case ImageIO::SHORT:
+							{
+								typedef short TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+
+							}
+							break;
+						case ImageIO::UINT:
+							{
+								typedef unsigned int TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::INT:
+							{
+								typedef int TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::ULONG:
+							{
+								typedef unsigned long TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+
+							}
+							break;
+						case ImageIO::LONG:
+							{
+								typedef long TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::FLOAT:
+							{
+								typedef float TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::DOUBLE:
+							{
+								typedef double TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::UNKNOWNCOMPONENTTYPE:
+						default:
+							throw GNC::GCS::ControladorCargaException( _Std("Error reading the study: unsupported pixel format"), "ControladorCarga/CargaMultidimensiona(1 componente)");
+					}
+				}
+				break;
+			case 3:
+				{
+					switch(m_IO->GetComponentType()) {
+						case ImageIO::UCHAR:
+							{
+								typedef unsigned char TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							}
+							break;
+						case ImageIO::CHAR:
+							{
+								//std::cout << "RGB c" << std::endl;
+								typedef unsigned char TypedComponentType;
+								typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+								typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+								typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+								typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+
+								TypedReaderType::Pointer reader = TypedReaderType::New();
+								TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+
+								m_pReader = reader;
+								m_pPipelineJoiner = joiner;
+
+								joiner->SetInput(reader->GetOutput());
+
+								reader->SetImageIO(pIO);
+								reader->SetFileName(m_CurrentFile);
+								reader->SetUseStreaming(true);
+								m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+								//reader->GetOutput()->ReleaseDataFlagOn();
+							}
+							break;
+						case ImageIO::USHORT:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef unsigned short TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::SHORT:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef short TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::UINT:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef unsigned int TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::INT:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef int TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::FLOAT:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef float TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::DOUBLE:
+						{
+							//std::cout << "RGB c" << std::endl;
+							typedef double TypedComponentType;
+							typedef itk::RGBPixel<TypedComponentType> TypedPixelType;
+							typedef itk::Image<TypedPixelType, 3 > TypedImageType;
+							typedef itk::ImageFileReader<TypedImageType> TypedReaderType;
+							typedef itk::ImageToVTKImageFilter<TypedImageType> TypedJoinerType;
+							
+							TypedReaderType::Pointer reader = TypedReaderType::New();
+							TypedJoinerType::Pointer joiner = TypedJoinerType::New();
+							
+							m_pReader = reader;
+							m_pPipelineJoiner = joiner;
+							
+							joiner->SetInput(reader->GetOutput());
+							
+							reader->SetImageIO(pIO);
+							reader->SetFileName(m_CurrentFile);
+							reader->SetUseStreaming(true);
+							m_pOutput->SetInputConnection(joiner->GetImporter()->GetOutputPort());
+							//reader->GetOutput()->ReleaseDataFlagOn();
+						}
+							break;
+						case ImageIO::UNKNOWNCOMPONENTTYPE:
+						default:
+							throw GNC::GCS::ControladorCargaException( _Std("Error reading the study: unsupported pixel format"), "ControladorCarga/CargaMultidimensional(3 componentes)");
+
+					}
+				}
+				break;
+			default:
+				{
+					throw GNC::GCS::ControladorCargaException( _Std("Error reading the study: unsupported pixel format"), "ControladorCarga/CargaMultidimensional");
+				}
+		}
+	}
+	if (m_pReader.IsNotNull() && m_pPipelineJoiner.IsNotNull()) {
+		m_pReader->Modified();
+		m_pPipelineJoiner->Modified();
+	}
+	m_pOutput->Modified();
+}
