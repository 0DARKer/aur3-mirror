From 8f184b8a78e51061e70c827fd4d9b528cade6a69 Mon Sep 17 00:00:00 2001
From: wbagdon <wbagdon@gmail.com>
Date: Sun, 11 Mar 2012 00:46:32 -0500
Subject: [PATCH 1/3] support for libpng15

---
 xbmc/lib/cximage-6.0/CxImage/ximapng.cpp | 407 ++++++++++++++++++++++---------
 1 file changed, 295 insertions(+), 112 deletions(-)

diff --git a/xbmc/lib/cximage-6.0/CxImage/ximapng.cpp b/xbmc/lib/cximage-6.0/CxImage/ximapng.cpp
index 8c75440..5a4df71 100644
--- a/xbmc/lib/cximage-6.0/CxImage/ximapng.cpp
+++ b/xbmc/lib/cximage-6.0/CxImage/ximapng.cpp
@@ -15,7 +15,12 @@
 void CxImagePNG::ima_png_error(png_struct *png_ptr, char *message)
 {
 	strcpy(info.szLastError,message);
+
+#if PNG_LIBPNG_VER > 10399
+	longjmp(png_jmpbuf(png_ptr),1);
+#else
 	longjmp(png_ptr->jmpbuf, 1);
+#endif
 }
 ////////////////////////////////////////////////////////////////////////////////
 #if CXIMAGE_SUPPORT_DECODE
@@ -62,7 +67,11 @@ bool CxImagePNG::Decode(CxFile *hFile)
     /* Set error handling if you are using the setjmp/longjmp method (this is
     * the normal method of doing things with libpng).  REQUIRED unless you
     * set up your own error handlers in the png_create_read_struct() earlier. */
+#if PNG_LIBPNG_VER > 10399
+	if (setjmp(png_jmpbuf(png_ptr))) {
+#else
 	if (setjmp(png_ptr->jmpbuf)) {
+#endif
 		/* Free all of the memory associated with the png_ptr and info_ptr */
 		delete [] row_pointers;
 		png_destroy_read_struct(&png_ptr, &info_ptr, (png_infopp)NULL);
@@ -70,129 +79,183 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	// use custom I/O functions
-    png_set_read_fn(png_ptr, hFile, /*(png_rw_ptr)*/user_read_data);
+    	png_set_read_fn(png_ptr, hFile, /*(png_rw_ptr)*/user_read_data);
 	png_set_error_fn(png_ptr,info.szLastError,/*(png_error_ptr)*/user_error_fn,NULL);
 
 	/* read the file information */
 	png_read_info(png_ptr, info_ptr);
 
+	png_uint_32 width, height;
+	int bit_depth, color_type, interlace_type, compression_type, filter_type;
+
+#if PNG_LIBPNG_VER > 10399
+	png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type, 
+			&interlace_type, &compression_type, &filter_type);
+#else
+	width=info_ptr->width;
+	height=info_ptr->height;
+	bit_depth=info_ptr->bit_depth;
+	color_type=info_ptr->color_type;
+	interlace_type=info_ptr->interlace_type;
+	compression_type=info_ptr->compression_type;
+	filter_type=info_ptr->filter_type;
+#endif
 	if (info.nEscape == -1){
-		head.biWidth = info_ptr->width;
-		head.biHeight= info_ptr->height;
+		head.biWidth = width;
+		head.biHeight= height;
 		info.dwType = CXIMAGE_FORMAT_PNG;
+#if PNG_LIBPNG_VER > 10399
+		longjmp(png_jmpbuf(png_ptr),1);
+#else
 		longjmp(png_ptr->jmpbuf, 1);
+#endif
 	}
 
+
 	/* calculate new number of channels */
 	int channels=0;
-	switch(info_ptr->color_type){
-	case PNG_COLOR_TYPE_GRAY:
-	case PNG_COLOR_TYPE_PALETTE:
-		channels = 1;
-		break;
-	case PNG_COLOR_TYPE_GRAY_ALPHA:
-		channels = 2;
-		break;
-	case PNG_COLOR_TYPE_RGB:
-		channels = 3;
-		break;
-	case PNG_COLOR_TYPE_RGB_ALPHA:
-		channels = 4;
-		break;
-	default:
-		strcpy(info.szLastError,"unknown PNG color type");
-		longjmp(png_ptr->jmpbuf, 1);
+
+	switch(color_type){
+		case PNG_COLOR_TYPE_GRAY:
+		case PNG_COLOR_TYPE_PALETTE:
+			channels = 1;
+			break;
+		case PNG_COLOR_TYPE_GRAY_ALPHA:
+			channels = 2;
+			break;
+		case PNG_COLOR_TYPE_RGB:
+			channels = 3;
+			break;
+		case PNG_COLOR_TYPE_RGB_ALPHA:
+			channels = 4;
+			break;
+		default:
+			strcpy(info.szLastError,"unknown PNG color type");
+#if PNG_LIBPNG_VER > 10399
+			longjmp(png_jmpbuf(png_ptr),1);
+#else
+			longjmp(png_ptr->jmpbuf, 1);
+#endif
 	}
 
 	//find the right pixel depth used for cximage
+#if PNG_LIBPNG_VER > 10399
+	int pixel_depth = bit_depth * png_get_channels(png_ptr, info_ptr);
+#else
 	int pixel_depth = info_ptr->pixel_depth;
-	if (channels == 1 && pixel_depth>8) pixel_depth=8;
-	if (channels == 2) pixel_depth=8;
-	if (channels >= 3) pixel_depth=24;
+#endif
+	if ((channels == 1 && pixel_depth>8) || channels == 2) 
+		pixel_depth=8;	
+	else if (channels >= 3) 
+		pixel_depth=24;
 
-	if (!Create(info_ptr->width, info_ptr->height, pixel_depth, CXIMAGE_FORMAT_PNG)){
-		longjmp(png_ptr->jmpbuf, 1);
+	if (!Create(width, height, pixel_depth, CXIMAGE_FORMAT_PNG)){
+#if PNG_LIBPNG_VER > 10399
+			longjmp(png_jmpbuf(png_ptr),1);
+#else
+			longjmp(png_ptr->jmpbuf, 1);
+#endif
 	}
 
 	/* get metrics */
-	switch (info_ptr->phys_unit_type)
+
+	png_uint_32 x_pixels_per_unit, y_pixels_per_unit;
+	int phys_unit_type, num_palette, num_trans, has_trans_data;
+	png_colorp palette;
+	png_bytep trans_alpha;
+	png_color_16p trans_color;		
+
+#if PNG_LIBPNG_VER > 10399
+	png_get_pHYs(png_ptr, info_ptr, &x_pixels_per_unit, &y_pixels_per_unit, &phys_unit_type);
+	png_get_PLTE(png_ptr, info_ptr, &palette, &num_palette);	
+#else
+	x_pixels_per_unit = info_ptr->x_pixels_per_unit;
+	y_pixels_per_unit = info_ptr->y_pixels_per_unit;
+	phys_unit_type = info_ptr->phys_unit_type;
+	num_palette = info_ptr->num_palette;
+	palette = info_ptr->palette;
+#endif
+
+	has_trans_data = png_get_tRNS(png_ptr,info_ptr, &trans_alpha, &num_trans, &trans_color);
+
+
+
+	switch (phys_unit_type)
 	{
-	case PNG_RESOLUTION_UNKNOWN:
-		SetXDPI(info_ptr->x_pixels_per_unit);
-		SetYDPI(info_ptr->y_pixels_per_unit);
-		break;
-	case PNG_RESOLUTION_METER:
-		SetXDPI((long)floor(info_ptr->x_pixels_per_unit * 254.0 / 10000.0 + 0.5));
-		SetYDPI((long)floor(info_ptr->y_pixels_per_unit * 254.0 / 10000.0 + 0.5));
+		case PNG_RESOLUTION_UNKNOWN:
+			SetXDPI(x_pixels_per_unit);
+			SetYDPI(y_pixels_per_unit);
+			break;
+		case PNG_RESOLUTION_METER:
+			SetXDPI((long)floor(x_pixels_per_unit * 254.0 / 10000.0 + 0.5));
+			SetYDPI((long)floor(y_pixels_per_unit * 254.0 / 10000.0 + 0.5));
 		break;
 	}
 
-	if (info_ptr->num_palette>0){
-		SetPalette((rgb_color*)info_ptr->palette,info_ptr->num_palette);
-		SetClrImportant(info_ptr->num_palette);
-	} else if (info_ptr->bit_depth ==2) { //<DP> needed for 2 bpp grayscale PNGs
+	if (num_palette>0){
+		SetPalette((rgb_color*)palette, num_palette);
+		SetClrImportant(num_palette);
+	} else if (bit_depth ==2) { //<DP> needed for 2 bpp grayscale PNGs
 		SetPaletteColor(0,0,0,0);
 		SetPaletteColor(1,85,85,85);
 		SetPaletteColor(2,170,170,170);
 		SetPaletteColor(3,255,255,255);
 	} else SetGrayPalette(); //<DP> needed for grayscale PNGs
-	
-	int nshift = max(0,(info_ptr->bit_depth>>3)-1)<<3;
 
-	if (info_ptr->num_trans!=0){ //palette transparency
-		if (info_ptr->num_trans==1){
-			if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE){
+	int nshift = max(0,(bit_depth>>3)-1)<<3;
+
+	//palette transparency
+	if (num_trans==1){
+		if (color_type == PNG_COLOR_TYPE_PALETTE){
 #if PNG_LIBPNG_VER > 10399
-				info.nBkgndIndex = info_ptr->trans_color.index;
+			info.nBkgndIndex = trans_color->index;
 #else
-				info.nBkgndIndex = info_ptr->trans_values.index;
+			info.nBkgndIndex = info_ptr->trans_values.index;
 #endif
-			} else{
+		} else {
 #if PNG_LIBPNG_VER > 10399
-				info.nBkgndIndex = info_ptr->trans_color.gray>>nshift;
+			info.nBkgndIndex = trans_color->gray>>nshift;
 #else
-				info.nBkgndIndex = info_ptr->trans_values.gray>>nshift;
+			info.nBkgndIndex = info_ptr->trans_values.gray>>nshift;
 #endif
-			}
 		}
-		if (info_ptr->num_trans>1){
-			RGBQUAD* pal=GetPalette();
-			if (pal){
-				DWORD ip;
-				for (ip=0;ip<min(head.biClrUsed,(unsigned long)info_ptr->num_trans);ip++)
+	}		
+	else if (num_trans>1){
+		RGBQUAD* pal=GetPalette();
+
+		if (pal){
+			DWORD ip;
+			for (ip=0;ip<min(head.biClrUsed,(unsigned long)num_trans);ip++)
 #if PNG_LIBPNG_VER > 10399
-					pal[ip].rgbReserved=info_ptr->trans_alpha[ip];
+				pal[ip].rgbReserved=trans_alpha[ip];
 #else
-					pal[ip].rgbReserved=info_ptr->trans[ip];
+				pal[ip].rgbReserved=info_ptr->trans[ip];
 #endif
-				for (ip=info_ptr->num_trans;ip<head.biClrUsed;ip++){
-					pal[ip].rgbReserved=255;
-				}
-				info.bAlphaPaletteEnabled=true;
+			for (ip=num_trans;ip<head.biClrUsed;ip++){
+				pal[ip].rgbReserved=255;
 			}
+
+			info.bAlphaPaletteEnabled=true;
 		}
 	}
 
-	if (channels == 3){ //check RGB binary transparency
-		png_bytep trans;
-		int num_trans;
-		png_color_16 *image_background;
-		if (png_get_tRNS(png_ptr, info_ptr, &trans, &num_trans, &image_background)){
+
+	if (channels == 3 && has_trans_data){ //check RGB binary transparency			
 #if PNG_LIBPNG_VER > 10399
-			info.nBkgndColor.rgbRed   = (BYTE)(info_ptr->trans_color.red>>nshift);
-			info.nBkgndColor.rgbGreen = (BYTE)(info_ptr->trans_color.green>>nshift);
-			info.nBkgndColor.rgbBlue  = (BYTE)(info_ptr->trans_color.blue>>nshift);
+		info.nBkgndColor.rgbRed   = (BYTE)(trans_color->red>>nshift);
+		info.nBkgndColor.rgbGreen = (BYTE)(trans_color->green>>nshift);
+		info.nBkgndColor.rgbBlue  = (BYTE)(trans_color->blue>>nshift);
 #else
-			info.nBkgndColor.rgbRed   = (BYTE)(info_ptr->trans_values.red>>nshift);
-			info.nBkgndColor.rgbGreen = (BYTE)(info_ptr->trans_values.green>>nshift);
-			info.nBkgndColor.rgbBlue  = (BYTE)(info_ptr->trans_values.blue>>nshift);
+		info.nBkgndColor.rgbRed   = (BYTE)(info_ptr->trans_values.red>>nshift);
+		info.nBkgndColor.rgbGreen = (BYTE)(info_ptr->trans_values.green>>nshift);
+		info.nBkgndColor.rgbBlue  = (BYTE)(info_ptr->trans_values.blue>>nshift);
 #endif
-			info.nBkgndColor.rgbReserved = 0;
-			info.nBkgndIndex = 0;
-		}
+		info.nBkgndColor.rgbReserved = 0;
+		info.nBkgndIndex = 0;	
 	}
 
 	int alpha_present = (channels - 1) % 2;
+
 	if (alpha_present){
 #if CXIMAGE_SUPPORT_ALPHA	// <vho>
 		AlphaCreate();
@@ -202,15 +265,24 @@ bool CxImagePNG::Decode(CxFile *hFile)
 	}
 
 	// <vho> - flip the RGB pixels to BGR (or RGBA to BGRA)
-	if (info_ptr->color_type & PNG_COLOR_MASK_COLOR){
+	if (color_type & PNG_COLOR_MASK_COLOR){
 		png_set_bgr(png_ptr);
 	}
 
 	// <vho> - handle cancel
-	if (info.nEscape) longjmp(png_ptr->jmpbuf, 1);
+	if (info.nEscape) 
+#if PNG_LIBPNG_VER > 10399
+			longjmp(png_jmpbuf(png_ptr),1);
+#else
+			longjmp(png_ptr->jmpbuf, 1);
+#endif
 
 	// row_bytes is the width x number of channels x (bit-depth / 8)
+#if PNG_LIBPNG_VER > 10399
+	row_pointers = new BYTE[png_get_rowbytes(png_ptr,info_ptr) + 8];
+#else
 	row_pointers = new BYTE[info_ptr->rowbytes + 8];
+#endif
 
 	// turn on interlace handling
 	int number_passes = png_set_interlace_handling(png_ptr);
@@ -221,8 +293,13 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		SetCodecOption(0);
 	}
 
-	int chan_offset = info_ptr->bit_depth >> 3;
+	int chan_offset = bit_depth >> 3;
+
+#if PNG_LIBPNG_VER > 10399
+	int pixel_offset = (bit_depth * png_get_channels(png_ptr,info_ptr)) >> 3;
+#else	
 	int pixel_offset = info_ptr->pixel_depth >> 3;
+#endif
 
 	for (int pass=0; pass < number_passes; pass++) {
 		iter.Upset();
@@ -230,7 +307,12 @@ bool CxImagePNG::Decode(CxFile *hFile)
 		do	{
 
 			// <vho> - handle cancel
-			if (info.nEscape) longjmp(png_ptr->jmpbuf, 1);
+			if (info.nEscape)
+#if PNG_LIBPNG_VER > 10399
+				longjmp(png_jmpbuf(png_ptr),1);
+#else
+				longjmp(png_ptr->jmpbuf, 1);
+#endif
 
 #if CXIMAGE_SUPPORT_ALPHA	// <vho>
 			if (AlphaIsValid()) {
@@ -241,7 +323,7 @@ bool CxImagePNG::Decode(CxFile *hFile)
 				BYTE* prow= iter.GetRow(ay);
 
 				//recover data from previous scan
-				if (info_ptr->interlace_type && pass>0 && pass!=7){
+				if (interlace_type && pass>0 && pass!=7){
 					for(ax=0;ax<head.biWidth;ax++){
 						long px = ax * pixel_offset;
 						if (channels == 2){
@@ -278,10 +360,15 @@ bool CxImagePNG::Decode(CxFile *hFile)
 #endif // CXIMAGE_SUPPORT_ALPHA		// vho
 			{
 				//recover data from previous scan
-				if (info_ptr->interlace_type && pass>0){
+				if (interlace_type && pass>0){
+#if PNG_LIBPNG_VER > 10399				
+
+					iter.GetRow(row_pointers, png_get_rowbytes(png_ptr,info_ptr));
+#else				
 					iter.GetRow(row_pointers, info_ptr->rowbytes);
+#endif				
 					//re-expand buffer for images with bit depth > 8
-					if (info_ptr->bit_depth > 8){
+					if (bit_depth > 8){
 						for(long ax=(head.biWidth*channels-1);ax>=0;ax--)
 							row_pointers[ax*chan_offset] = row_pointers[ax];
 					}
@@ -291,15 +378,19 @@ bool CxImagePNG::Decode(CxFile *hFile)
 				png_read_row(png_ptr, row_pointers, NULL);
 
 				//shrink 16 bit depth images down to 8 bits
-				if (info_ptr->bit_depth > 8){
+				if (bit_depth > 8){
 					for(long ax=0;ax<(head.biWidth*channels);ax++)
 						row_pointers[ax] = row_pointers[ax*chan_offset];
 				}
 
 				//copy the pixels
+#if PNG_LIBPNG_VER > 10399
+				iter.SetRow(row_pointers, png_get_rowbytes(png_ptr,info_ptr));
+#else
 				iter.SetRow(row_pointers, info_ptr->rowbytes);
+#endif
 				//<DP> expand 2 bpp images only in the last pass
-				if (info_ptr->bit_depth==2 && pass==(number_passes-1))
+				if (bit_depth==2 && pass==(number_passes-1))
 					expand2to4bpp(iter.GetRow());
 
 				//go on
@@ -361,19 +452,35 @@ bool CxImagePNG::Encode(CxFile *hFile)
    /* Set error handling.  REQUIRED if you aren't supplying your own
     * error hadnling functions in the png_create_write_struct() call.
     */
+#if PNG_LIBPNG_VER > 10399
+	if (setjmp(png_jmpbuf(png_ptr))){
+#else
 	if (setjmp(png_ptr->jmpbuf)){
 		/* If we get here, we had a problem reading the file */
-		if (info_ptr->palette) free(info_ptr->palette);
-		png_destroy_write_struct(&png_ptr,  (png_infopp)&info_ptr);
+		if (info_ptr->palette)
+			free(info_ptr->palette);		
+#endif
+		png_destroy_write_struct(&png_ptr, (png_infopp)&info_ptr);
 		cx_throw("Error saving PNG file");
 	}
             
-	/* set up the output control */
-	//png_init_io(png_ptr, hFile);
-
 	// use custom I/O functions
-    png_set_write_fn(png_ptr,hFile,/*(png_rw_ptr)*/user_write_data,/*(png_flush_ptr)*/user_flush_data);
+    	png_set_write_fn(png_ptr,hFile,/*(png_rw_ptr)*/user_write_data,/*(png_flush_ptr)*/user_flush_data);
 
+	png_uint_32 width, height;
+	int bit_depth, color_type, interlace_type, compression_type, filter_type;
+	png_byte channels, pixel_depth;
+
+
+#if PNG_LIBPNG_VER > 10399
+	width = GetWidth();
+	height = GetHeight();
+	pixel_depth = (BYTE)GetBpp();
+	channels = (GetBpp()>8) ? (BYTE)3: (BYTE)1;
+	bit_depth = (BYTE)(GetBpp()/channels);
+	compression_type = PNG_COMPRESSION_TYPE_DEFAULT;
+	filter_type = PNG_FILTER_TYPE_DEFAULT;
+#else
 	/* set the file information here */
 	info_ptr->width = GetWidth();
 	info_ptr->height = GetHeight();
@@ -382,13 +489,23 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	info_ptr->bit_depth = (BYTE)(GetBpp()/info_ptr->channels);
 	info_ptr->compression_type = info_ptr->filter_type = 0;
 	info_ptr->valid = 0;
+#endif
+
 
 	switch(GetCodecOption(CXIMAGE_FORMAT_PNG)){
-	case 1:
-		info_ptr->interlace_type = PNG_INTERLACE_ADAM7;
+		case 1:
+#if PNG_LIBPNG_VER > 10399
+			interlace_type = PNG_INTERLACE_ADAM7;	
+#else
+			info_ptr->interlace_type = PNG_INTERLACE_ADAM7;	
+#endif
 		break;
-	default:
-		info_ptr->interlace_type = PNG_INTERLACE_NONE;
+		default:
+#if PNG_LIBPNG_VER > 10399
+			interlace_type = PNG_INTERLACE_NONE;
+#else
+			info_ptr->interlace_type = PNG_INTERLACE_NONE;
+#endif
 	}
 
 	/* set compression level */
@@ -398,19 +515,38 @@ bool CxImagePNG::Encode(CxFile *hFile)
 
 	if (GetNumColors()){
 		if (bGrayScale){
+#if PNG_LIBPNG_VER > 10399
+			color_type = PNG_COLOR_TYPE_GRAY;
+#else
 			info_ptr->color_type = PNG_COLOR_TYPE_GRAY;
+#endif
 		} else {
+#if PNG_LIBPNG_VER > 10399
+			color_type = PNG_COLOR_TYPE_PALETTE;
+#else
 			info_ptr->color_type = PNG_COLOR_TYPE_PALETTE;
+#endif
 		}
 	} else {
+#if PNG_LIBPNG_VER > 10399
+		color_type = PNG_COLOR_TYPE_RGB;
+#else
 		info_ptr->color_type = PNG_COLOR_TYPE_RGB;
+#endif
 	}
 #if CXIMAGE_SUPPORT_ALPHA
-	if (AlphaIsValid()){
+	if (AlphaIsValid()){		
+#if PNG_LIBPNG_VER > 10399
+		color_type |= PNG_COLOR_MASK_ALPHA;
+		channels++;
+		bit_depth = 8;
+		pixel_depth += 8;
+#else
 		info_ptr->color_type |= PNG_COLOR_MASK_ALPHA;
 		info_ptr->channels++;
 		info_ptr->bit_depth = 8;
 		info_ptr->pixel_depth += 8;
+#endif
 	}
 #endif
 
@@ -427,22 +563,26 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	/* set metrics */
 	png_set_pHYs(png_ptr, info_ptr, head.biXPelsPerMeter, head.biYPelsPerMeter, PNG_RESOLUTION_METER);
 
+#if PNG_LIBPNG_VER > 10399
+	png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type, interlace_type, 
+			compression_type, filter_type);
+#else
 	png_set_IHDR(png_ptr, info_ptr, info_ptr->width, info_ptr->height, info_ptr->bit_depth,
 				info_ptr->color_type, info_ptr->interlace_type,
 				PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+#endif
 
 	//<DP> simple transparency
 	if (info.nBkgndIndex >= 0){
-		info_ptr->num_trans = 1;
-		info_ptr->valid |= PNG_INFO_tRNS;
 #if PNG_LIBPNG_VER > 10399
-		info_ptr->trans_alpha = trans;
-		info_ptr->trans_color.index = (BYTE)info.nBkgndIndex;
-		info_ptr->trans_color.red   = tc.rgbRed;
-		info_ptr->trans_color.green = tc.rgbGreen;
-		info_ptr->trans_color.blue  = tc.rgbBlue;
-		info_ptr->trans_color.gray  = info_ptr->trans_color.index;
+		png_color_16 trans_color;
+		trans_color.gray = trans_color.index = (BYTE)info.nBkgndIndex;
+		trans_color.red = tc.rgbRed;
+		trans_color.green = tc.rgbGreen;
+		trans_color.blue = tc.rgbBlue;
 #else
+		info_ptr->num_trans = 1;
+		info_ptr->valid |= PNG_INFO_tRNS;
 		info_ptr->trans = trans;
 		info_ptr->trans_values.index = (BYTE)info.nBkgndIndex;
 		info_ptr->trans_values.red   = tc.rgbRed;
@@ -454,34 +594,57 @@ bool CxImagePNG::Encode(CxFile *hFile)
 		// the transparency indexes start from 0 for non grayscale palette
 		if (!bGrayScale && head.biClrUsed && info.nBkgndIndex)
 			SwapIndex(0,(BYTE)info.nBkgndIndex);
+
+#if PNG_LIBPNG_VER > 10399
+		png_set_tRNS(png_ptr, info_ptr,(png_bytep)trans,1 , &trans_color);
+#endif
 	}
 
+#if PNG_LIBPNG_VER > 10399
+	png_colorp palette;
+#endif
+
 	/* set the palette if there is one */
 	if (GetPalette()){
+
+		int nc = GetClrImportant();
+
+		if (nc==0) 
+			nc = GetNumColors();
+
+#if PNG_LIBPNG_VER > 10399
+		palette = new png_color[nc];
+
+		for (int i=0; i<nc; i++)
+			GetPaletteColor(i, &palette[i].red, &palette[i].green, &palette[i].blue);
+
+		png_set_PLTE(png_ptr,info_ptr,palette,nc);	
+#else
 		if (!bGrayScale){
 			info_ptr->valid |= PNG_INFO_PLTE;
 		}
 
-		int nc = GetClrImportant();
-		if (nc==0) nc = GetNumColors();
+		info_ptr->palette = new png_color[nc];
+		info_ptr->num_palette = (png_uint_16) nc;
+
+		for (int i=0; i<nc; i++)
+			GetPaletteColor(i, &info_ptr->palette[i].red, &info_ptr->palette[i].green, &info_ptr->palette[i].blue);
+#endif
+
 
 		if (info.bAlphaPaletteEnabled){
 			for(WORD ip=0; ip<nc;ip++)
 				trans[ip]=GetPaletteColor((BYTE)ip).rgbReserved;
-			info_ptr->num_trans = (WORD)nc;
-			info_ptr->valid |= PNG_INFO_tRNS;
+
 #if PNG_LIBPNG_VER > 10399
-			info_ptr->trans_alpha = trans;
+			png_set_tRNS(png_ptr,info_ptr,(png_bytep)trans,nc,NULL);
 #else
+			info_ptr->num_trans = (WORD)nc;
+			info_ptr->valid |= PNG_INFO_tRNS;
 			info_ptr->trans = trans;
 #endif
 		}
 
-		// copy the palette colors
-		info_ptr->palette = new png_color[nc];
-		info_ptr->num_palette = (png_uint_16) nc;
-		for (int i=0; i<nc; i++)
-			GetPaletteColor(i, &info_ptr->palette[i].red, &info_ptr->palette[i].green, &info_ptr->palette[i].blue);
 	}  
 
 #if CXIMAGE_SUPPORT_ALPHA	// <vho>
@@ -495,8 +658,13 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	}	}	}
 #endif // CXIMAGE_SUPPORT_ALPHA	// <vho>
 
+#if PNG_LIBPNG_VER > 10399
+	int row_size = max(info.dwEffWidth, (width * channels * bit_depth / 8));
+#else
 	int row_size = max(info.dwEffWidth, info_ptr->width*info_ptr->channels*(info_ptr->bit_depth/8));
 	info_ptr->rowbytes = row_size;
+#endif
+
 	BYTE *row_pointers = new BYTE[row_size];
 
 	/* write the file information */
@@ -514,7 +682,11 @@ bool CxImagePNG::Encode(CxFile *hFile)
 			if (AlphaIsValid()){
 				for (long ax=head.biWidth-1; ax>=0;ax--){
 					c = BlindGetPixelColor(ax,ay);
+#if PNG_LIBPNG_VER > 10399
+					int px = ax * channels;
+#else
 					int px = ax * info_ptr->channels;
+#endif
 					if (!bGrayScale){
 						row_pointers[px++]=c.rgbRed;
 						row_pointers[px++]=c.rgbGreen;
@@ -529,8 +701,13 @@ bool CxImagePNG::Encode(CxFile *hFile)
 #endif //CXIMAGE_SUPPORT_ALPHA	// <vho>
 			{
 				iter.GetRow(row_pointers, row_size);
+#if PNG_LIBPNG_VER > 10399
+				if (color_type == PNG_COLOR_TYPE_RGB) //HACK BY OP
+#else
 				if (info_ptr->color_type == PNG_COLOR_TYPE_RGB) //HACK BY OP
+#endif
 					RGBtoBGR(row_pointers, row_size);
+
 				png_write_row(png_ptr, row_pointers);
 			}
 		} while(iter.PrevRow());
@@ -546,10 +723,16 @@ bool CxImagePNG::Encode(CxFile *hFile)
 	png_write_end(png_ptr, info_ptr);
 
 	/* if you malloced the palette, free it here */
+#if PNG_LIBPNG_VER > 10399
+	if (palette)
+		delete [] (palette);
+#else
 	if (info_ptr->palette){
 		delete [] (info_ptr->palette);
 		info_ptr->palette = NULL;
 	}
+#endif
+
 
 	/* clean up after the write, and free any memory allocated */
 	png_destroy_write_struct(&png_ptr, (png_infopp)&info_ptr);
@@ -564,4 +747,4 @@ bool CxImagePNG::Encode(CxFile *hFile)
 ////////////////////////////////////////////////////////////////////////////////
 #endif // CXIMAGE_SUPPORT_ENCODE
 ////////////////////////////////////////////////////////////////////////////////
-#endif // CXIMAGE_SUPPORT_PNG
+#endif // CXIMAGE_SUPPORT_PNG
\ No newline at end of file
-- 
1.7.11.4

