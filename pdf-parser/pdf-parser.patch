--- pdf-parser.py	2010-01-10 00:56:08.000000000 -0500
+++ pdf-parser.py	2012-11-25 12:04:03.451942549 -0500
@@ -1,11 +1,9 @@
-#!/usr/bin/python
+#!/usr/bin/python2
 
 __description__ = 'pdf-parser, use it to parse a PDF document'
 __author__ = 'Didier Stevens'
 __version__ = '0.3.7'
 __date__ = '2010/01/09'
-__minimum_python_version__ = (2, 5, 1)
-__maximum_python_version__ = (2, 6, 2)
 
 """
 Source code put in public domain by Didier Stevens, no Copyright
@@ -13,32 +11,32 @@
 Use at your own risk
 
 History:
-  2008/05/02: continue
-  2008/05/03: continue
-  2008/06/02: streams
-  2008/10/19: refactor, grep & extract functionality
-  2008/10/20: reference
-  2008/10/21: cleanup
-  2008/11/12: V0.3 dictionary parser
-  2008/11/13: option elements
-  2008/11/14: continue
-  2009/05/05: added /ASCIIHexDecode support (thanks Justin Prosco)
-  2009/05/11: V0.3.1 updated usage, added --verbose and --extract
-  2009/07/16: V0.3.2 Added Canonicalize (thanks Justin Prosco)
-  2009/07/18: bugfix EqualCanonical
-  2009/07/24: V0.3.3 Added --hash option
-  2009/07/25: EqualCanonical for option --type, added option --nocanonicalizedoutput
-  2009/07/28: V0.3.4 Added ASCII85Decode support
-  2009/08/01: V0.3.5 Updated ASCIIHexDecode to support whitespace obfuscation
-  2009/08/30: V0.3.6 TestPythonVersion
-  2010/01/08: V0.3.7 Added RLE and LZW support (thanks pARODY); added dump option
-  2010/01/09: Fixed parsing of incomplete startxref
+2008/05/02: continue
+2008/05/03: continue
+2008/06/02: streams
+2008/10/19: refactor, grep & extract functionality
+2008/10/20: reference
+2008/10/21: cleanup
+2008/11/12: V0.3 dictionary parser
+2008/11/13: option elements
+2008/11/14: continue
+2009/05/05: added /ASCIIHexDecode support (thanks Justin Prosco)
+2009/05/11: V0.3.1 updated usage, added --verbose and --extract
+2009/07/16: V0.3.2 Added Canonicalize (thanks Justin Prosco)
+2009/07/18: bugfix EqualCanonical
+2009/07/24: V0.3.3 Added --hash option
+2009/07/25: EqualCanonical for option --type, added option --nocanonicalizedoutput
+2009/07/28: V0.3.4 Added ASCII85Decode support
+2009/08/01: V0.3.5 Updated ASCIIHexDecode to support whitespace obfuscation
+2009/08/30: V0.3.6 TestPythonVersion
+2010/01/08: V0.3.7 Added RLE and LZW support (thanks pARODY); added dump option
+2010/01/09: Fixed parsing of incomplete startxref
 
 Todo:
-  - handle printf todo
-  - check 'real raw' option
-  - fix PrettyPrint
-  - support for JS hex string EC61C64349DB8D88AF0523C4C06E0F4D.pdf.vir
+- handle printf todo
+- check 'real raw' option
+- fix PrettyPrint
+- support for JS hex string EC61C64349DB8D88AF0523C4C06E0F4D.pdf.vir
 
 """
 
@@ -596,26 +594,26 @@
 
 # http://code.google.com/p/pdfminerr/source/browse/trunk/pdfminer/pdfminer/ascii85.py
 def ASCII85Decode(data):
-  import struct
-  n = b = 0
-  out = ''
-  for c in data:
-    if '!' <= c and c <= 'u':
-      n += 1
-      b = b*85+(ord(c)-33)
-      if n == 5:
-        out += struct.pack('>L',b)
-        n = b = 0
-    elif c == 'z':
-      assert n == 0
-      out += '\0\0\0\0'
-    elif c == '~':
-      if n:
-        for _ in range(5-n):
-          b = b*85+84
-        out += struct.pack('>L',b)[:n-1]
-      break
-  return out
+    import struct
+    n = b = 0
+    out = ''
+    for c in data:
+        if '!' <= c and c <= 'u':
+            n += 1
+            b = b * 85 + (ord(c) - 33)
+            if n == 5:
+                out += struct.pack('>L',b)
+                n = b = 0
+	elif c == 'z':
+            assert n == 0
+            out += '\0\0\0\0'
+        elif c == '~':
+            if n:
+                for _ in range(5 - n):
+                    b = b * 85 + 84
+                out += struct.pack('>L',b)[:n - 1]
+            break
+    return out
 
 def ASCIIHexDecode(data):
     return binascii.unhexlify(''.join([c for c in data if c not in ' \t\n\r']).rstrip('>'))
@@ -875,24 +873,5 @@
             for key in names:
                 print ' %s %d: %s' % (key, len(dicObjectTypes[key]), ', '.join(map(lambda x: '%d' % x, dicObjectTypes[key])))
 
-def TestPythonVersion(enforceMaximumVersion=False, enforceMinimumVersion=False):
-    if sys.version_info[0:3] > __maximum_python_version__:
-        if enforceMaximumVersion:
-            print 'This program does not work with this version of Python (%d.%d.%d)' % sys.version_info[0:3]
-            print 'Please use Python version %d.%d.%d' % __maximum_python_version__
-            sys.exit()
-        else:
-            print 'This program has not been tested with this version of Python (%d.%d.%d)' % sys.version_info[0:3]
-            print 'Should you encounter problems, please use Python version %d.%d.%d' % __maximum_python_version__
-    if sys.version_info[0:3] < __minimum_python_version__:
-        if enforceMinimumVersion:
-            print 'This program does not work with this version of Python (%d.%d.%d)' % sys.version_info[0:3]
-            print 'Please use Python version %d.%d.%d' % __maximum_python_version__
-            sys.exit()
-        else:
-            print 'This program has not been tested with this version of Python (%d.%d.%d)' % sys.version_info[0:3]
-            print 'Should you encounter problems, please use Python version %d.%d.%d' % __maximum_python_version__
-
 if __name__ == '__main__':
-    TestPythonVersion(enforceMaximumVersion=True)
     Main()
