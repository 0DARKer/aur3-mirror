diff --git a/highlyadvanced-46212061793a/highlyadvanced-46212061793a/VBA/Util.cpp b/highlyadvanced-new/highlyadvanced-46212061793a/VBA/Util.cpp
index 7af8fd2..839c0a1 100644
--- a/highlyadvanced-46212061793a/highlyadvanced-46212061793a/VBA/Util.cpp
+++ b/highlyadvanced-new/highlyadvanced-46212061793a/VBA/Util.cpp
@@ -917,7 +917,7 @@ bool utilIsGSF(const char * file)
   
 
   if(strlen(file) > 4) {
-    char *p = strrchr(file,'.');
+    const char *p = strrchr(file,'.');
 
 	if(p != NULL) {
 	  if(_stricmp(p, ".gsf") == 0)
@@ -934,7 +934,7 @@ bool utilIsGBAImage(const char * file)
 {
   cpuIsMultiBoot = false;
   if(strlen(file) > 4) {
-    char * p = strrchr(file,'.');
+    const char * p = strrchr(file,'.');
 
     if(p != NULL) {
       //if(_stricmp(p, ".gba") == 0)
diff --git a/highlyadvanced-46212061793a/highlyadvanced-46212061793a/plugin.c b/highlyadvanced-new/highlyadvanced-46212061793a/plugin.c
index 05c6b28..d667386 100644
--- a/highlyadvanced-46212061793a/highlyadvanced-46212061793a/plugin.c
+++ b/highlyadvanced-new/highlyadvanced-46212061793a/plugin.c
@@ -7,26 +7,24 @@
  *
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <libgen.h>
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
-
-#include <glib.h>
-
-#include <gtk/gtk.h>
-
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <string.h>
+//#include <unistd.h>
+//#include <fcntl.h>
+//#include <signal.h>
+//#include <libgen.h>
+//#include <sys/types.h>
+//#include <sys/time.h>
+//#include <time.h>
+
+//#include <glib.h>
+
+//#include <gtk/gtk.h>
+
+#include <audacious/misc.h>
 #include <audacious/plugin.h>
-#include <audacious/tuple.h>
-#include <audacious/output.h>
-#include <audacious/util.h>
-#include <audacious/vfs.h>
+#include <libaudcore/tuple_formatter.h>
 
 #include "VBA/psftag.h"
 #include "gsf.h"
@@ -59,11 +57,11 @@ extern char soundQuality;
 double decode_pos_ms; // current decoding position, in milliseconds
 int seek_needed; // if != -1, it is the point that the decode thread should seek to, in ms.
 
-extern InputPlugin gsf_ip;
+gboolean stop_flag = FALSE;
 
 static gchar *lastfn;
 
-gboolean gsf_play_loop(gpointer data);
+gboolean gsf_play_loop(const gchar *filename);
 GThread *gsf_emulthread;
 
 static int g_must_exit = 0;
@@ -71,7 +69,7 @@ static int g_must_exit = 0;
 int LengthFromString(const char * timestring);
 int VolumeFromString(const char * volumestring);
 
-static int gsf_is_our_fd(gchar *filename, VFSFile *file)
+static int gsf_is_our_fd(const gchar *filename, VFSFile *file)
 {
         gchar magic[4], *tmps;
 
@@ -85,7 +83,7 @@ static int gsf_is_our_fd(gchar *filename, VFSFile *file)
                         return 0;
         }
 
-	aud_vfs_fread(magic,1,4,file);
+	vfs_fread(magic,1,4,file);
 
 	if (!memcmp(magic,"PSF\"",4))
 		return 1;
@@ -93,16 +91,13 @@ static int gsf_is_our_fd(gchar *filename, VFSFile *file)
         return 0;
 }
 
-static void gsf_play(InputPlayback *playback);
+static gboolean gsf_play(InputPlayback * data, const gchar * filename, VFSFile * file, gint start_time, gint stop_time, gboolean pause);
 
 static void gsf_stop(InputPlayback *playback)
 {
-	playback->playing = 0;
-	playback->eof = TRUE;
-
-	g_thread_join(gsf_emulthread);
-
-	playback->output->close_audio();
+	stop_flag = TRUE;
+	
+	playback->output->abort_write ();
 
 	if (lastfn != NULL)
 	{
@@ -111,7 +106,7 @@ static void gsf_stop(InputPlayback *playback)
 	}
 }
 
-static Tuple *gsf_get_song_tuple(gchar *filename)
+Tuple *gsf_get_song_tuple(const gchar *filename, VFSFile *file)
 {
 	char tag[50001];
 	char tmp_str[256];
@@ -122,92 +117,83 @@ static Tuple *gsf_get_song_tuple(gchar *filename)
 
 	Tuple *ti;
 
-	ti = aud_tuple_new_from_filename(fn);
+	ti = tuple_new_from_filename(fn);
 
 	psftag_readfromfile((void*)tag, fn);
 
 	if (!psftag_getvar(tag, "title", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_TITLE, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_TITLE, NULL, tmp_str);
 	}
 		
 	if (!psftag_getvar(tag, "artist", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_ARTIST, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_ARTIST, NULL, tmp_str);
 	}
 		
 	if (!psftag_getvar(tag, "game", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_ALBUM, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_ALBUM, NULL, tmp_str);
 	}
 		
 	if (!psftag_getvar(tag, "year", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_DATE, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_DATE, NULL, tmp_str);
 	}
 
 	if (!psftag_getvar(tag, "copyright", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_COPYRIGHT, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_COPYRIGHT, NULL, tmp_str);
 	}
 		
 	if (!psftag_getvar(tag, "gsfby", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, -1, "gsfby", tmp_str);
+		tuple_associate_string(ti, -1, "gsfby", tmp_str);
 	}
 		
 	if (!psftag_getvar(tag, "tagger", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, -1, "tagger", tmp_str);
+		tuple_associate_string(ti, -1, "tagger", tmp_str);
 	}
 		
 	if (!psftag_raw_getvar(tag, "length", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_int(ti, FIELD_LENGTH, NULL, LengthFromString(tmp_str) + FadeLength);
+		tuple_associate_int(ti, FIELD_LENGTH, NULL, LengthFromString(tmp_str) + FadeLength);
 	}
 
 	if (!psftag_getvar(tag, "comment", tmp_str, sizeof(tmp_str)-1)) {
-		aud_tuple_associate_string(ti, FIELD_COMMENT, NULL, tmp_str);
+		tuple_associate_string(ti, FIELD_COMMENT, NULL, tmp_str);
 	}
 
-	aud_tuple_associate_string(ti, FIELD_CODEC, NULL, "GameBoy Advanced Audio (GSF)");
-	aud_tuple_associate_string(ti, FIELD_QUALITY, NULL, "sequenced");
+	tuple_associate_string(ti, FIELD_CODEC, NULL, "GameBoy Advanced Audio (GSF)");
+	tuple_associate_string(ti, FIELD_QUALITY, NULL, "sequenced");
 
 	g_free(f);
 
 	return ti;
 }
 
-static void gsf_pause(InputPlayback *playback, short p)
+static void gsf_pause(InputPlayback *playback, gboolean pause)
 {
-	playback->output->pause(p);
+	if (!stop_flag)
+		playback->output->pause(pause);
 }
 
 static void gsf_seek(InputPlayback *playback, gint time)
 {
-	seek_needed = time * 1000;
+	seek_needed = time;
 }
+static const gchar *gsf_fmts[] = { "gsf", "minigsf", NULL };
 
-static void gsf_about(void)
-{
-	audacious_info_dialog("About Highly Advanced for Audacious",
-			"Highly Advanced for Audacious\nversion: " VERSION_STR "\n\nAudacious plugin: (C) 2006-2007 William Pitcock <nenolod -at- atheme.org>\n\n"
-			"Built from the Highly Advanced emulation core, version " HA_VERSION_STR, "OK", FALSE, NULL, NULL);
-}
-
-static gchar *gsf_fmts[] = { "gsf", "minigsf", NULL };
-
-InputPlugin gsf_ip =
-{
-        .description = "Highly Advanced for Audacious",
-        .about = gsf_about,
-        .play_file = gsf_play,
+AUD_INPUT_PLUGIN
+(
+        .name = "Highly Advanced for Audacious",
+        .play = gsf_play,
         .stop = gsf_stop,
         .pause = gsf_pause,
-        .seek = gsf_seek,
-        .get_song_tuple = gsf_get_song_tuple,
+        .mseek = gsf_seek,
+        .probe_for_tuple = gsf_get_song_tuple,
         .is_our_file_from_vfs = gsf_is_our_fd,
-	.vfs_extensions = gsf_fmts,
-};
+        .extensions = gsf_fmts,
+)
 
 static InputPlayback *_playback = NULL;
 
 void end_of_track(void)
 {
-	_playback->playing = FALSE;
-	_playback->eof = TRUE;
+	stop_flag = TRUE;
 }
 	
 void writeSound(void)
@@ -218,18 +204,17 @@ void writeSound(void)
 
 	decode_pos_ms += (ret/(2*sndNumChannels) * 1000) / (float)sndSamplesPerSec;
 
-	_playback->pass_audio(_playback, FMT_S16_LE, sndNumChannels, soundBufferLen, soundFinalWave, &_playback->playing);
+	_playback->output->write_audio (soundFinalWave, soundBufferLen);
 
 	if (--countdown == 0)
 	{
-		_playback->set_params(_playback, _playback->title, _playback->length, cpupercent * 1000, 44100, 2);
 		countdown = 20;
 	}
 
 	/* is seek request complete? (-2) */
 	if (seek_needed == -2)
 	{
-		_playback->output->flush(decode_pos_ms);
+		_playback->output->flush(seek_needed);
 		seek_needed = -1;
 	}
 
@@ -244,7 +229,7 @@ void writeSound(void)
 	}
 }
 
-static void gsf_play(InputPlayback *playback)
+static gboolean gsf_play(InputPlayback * playback, const gchar * filename, VFSFile * file, gint start_time, gint stop_time, gboolean pause)
 {
 	int r, tmp, fi, random=0;
 	char Buffer[1024];
@@ -262,25 +247,19 @@ static void gsf_play(InputPlayback *playback)
 	TrailingSilence=1000;
 	playforever=0;
 
-	playback->playing = 1;
-	playback->eof = FALSE;
-
 	_playback = playback;
-	gsf_emulthread = g_thread_self();
-	playback->set_pb_ready(playback);
-	gsf_play_loop(playback);
+	return gsf_play_loop(filename);
 }
 
-gboolean gsf_play_loop(gpointer data)
+gboolean gsf_play_loop(const gchar * filename)
 {
 	int r;
-	InputPlayback *playback = (InputPlayback *) data;
 	gchar *f, *fn;
 
-	f = g_filename_from_uri(playback->filename, NULL, NULL);
-	fn = f ? f : playback->filename;
+	f = g_filename_from_uri(filename, NULL, NULL);
+	fn = f ? f : filename;
 
-	Tuple *ti = gsf_get_song_tuple(fn);
+	Tuple *ti = gsf_get_song_tuple(filename, NULL);
 	
 	r = GSFRun(fn);
 	if (!r)
@@ -288,35 +267,27 @@ gboolean gsf_play_loop(gpointer data)
 
 	lastfn = g_strdup(fn);
 
-	int i = playback->output->open_audio(FMT_S16_LE, sndSamplesPerSec, sndNumChannels);
-
-	gchar *title = aud_tuple_formatter_make_title_string(ti, aud_get_gentitle_format());
-	gint length = aud_tuple_get_int(ti, FIELD_LENGTH, NULL);
+	_playback->output->open_audio(FMT_S16_LE, sndSamplesPerSec, sndNumChannels);
 
-	playback->set_params(playback, title, length, 0, 44100, 2);
+	gchar *title = tuple_formatter_make_title_string(ti, aud_get_gentitle_format());
+	gint length = tuple_get_int(ti, FIELD_LENGTH, NULL);
 
-	playback->playing = 1;
-	playback->eof = FALSE;
+	_playback->set_params(_playback, sndSamplesPerSec*2*2*8, sndSamplesPerSec, sndNumChannels);
 
 	decode_pos_ms = 0;
 	seek_needed = -1;
 	TrailingSilence=1000;
 
-	while(playback->playing && playback->eof == FALSE)
-		EmulationLoop();
-
-	GSFClose();
-
-	playback->output->buffer_free();
-	playback->output->buffer_free();
-	while (playback->output->buffer_playing())
-		g_usleep(10000);
+	stop_flag = FALSE;
+	_playback->set_pb_ready(_playback);
 
-	playback->output->close_audio();
+	while(! stop_flag)
+	  EmulationLoop();
 
-	playback->playing = 0;
-	playback->eof = TRUE;
+	GSFClose();
 
+	stop_flag = TRUE;
+	_playback->output->close_audio();
 	g_free(lastfn);
 	lastfn = NULL;
 
@@ -324,11 +295,3 @@ gboolean gsf_play_loop(gpointer data)
 
 	return 0;
 }
-
-InputPlugin *get_iplugin_info(void)
-{
-	return &gsf_ip;
-}
-
-InputPlugin *gsf_iplist[] = { &gsf_ip, NULL };
-SIMPLE_INPUT_PLUGIN(gsf, gsf_iplist);
