diff --git a/CMakeTests/FindOculusSDK.cmake b/CMakeTests/FindOculusSDK.cmake
index afd00d2..c5695dc 100644
--- a/CMakeTests/FindOculusSDK.cmake
+++ b/CMakeTests/FindOculusSDK.cmake
@@ -10,16 +10,20 @@ if (NOT OCULUSSDK_FOUND)
 	find_path(OCULUSSDK_INCLUDE_DIR NAMES OVR.h
 		PATHS
 		/usr/include/ovr-0.4.3/LibOVR/Include
+		/usr/include/ovr-0.4.4/LibOVR/Include
 		/usr/include
 		/usr/local/include/ovr-0.4.3/LibOVR/Include
+		/usr/local/include/ovr-0.4.4/LibOVR/Include
 		/usr/local/include
 	)
 
 	find_path(OCULUSSDK_SRC_DIR NAMES OVR_CAPI_GL.h
 		PATHS
 		/usr/include/ovr-0.4.3/LibOVR/Src
+		/usr/include/ovr-0.4.4/LibOVR/Src
 		/usr/include
 		/usr/local/include/ovr-0.4.3/LibOVR/Src
+		/usr/local/include/ovr-0.4.4/LibOVR/Src
 		/usr/local/include
 	)
 
diff --git a/Source/Core/Core/Core.cpp b/Source/Core/Core/Core.cpp
index 6c4c018..5d4fe50 100644
--- a/Source/Core/Core/Core.cpp
+++ b/Source/Core/Core/Core.cpp
@@ -764,6 +764,7 @@ bool ShouldSkipFrame(int skipped)
 // in order to keep up 75 FPS
 bool ShouldAddTimewarpFrame()
 {
+#if 0
 	if (s_is_stopping)
 		return false;
 	static u32 timewarp_count = 0;
@@ -791,6 +792,7 @@ bool ShouldAddTimewarpFrame()
 		s_vr_timer.Update();
 		Common::AtomicStore(g_drawn_vr, 0);
 	}
+#endif
 	return false;
 }
 
diff --git a/Source/Core/DolphinWX/ConfigVR.cpp b/Source/Core/DolphinWX/ConfigVR.cpp
index 7da7313..9161c2a 100644
--- a/Source/Core/DolphinWX/ConfigVR.cpp
+++ b/Source/Core/DolphinWX/ConfigVR.cpp
@@ -109,8 +109,9 @@ void CConfigVR::CreateGUIControls()
 			SettingNumber *const spin_scale = CreateNumber(page_vr, vconfig.fScale,
 				wxGetTranslation(scale_desc), 0.001f, 100.0f, 0.01f);
 			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Scale:"));
+			
+			spin_scale->SetToolTip(wxGetTranslation(scale_desc));
 			label->SetToolTip(wxGetTranslation(scale_desc));
-
 			szr_vr->Add(label, 1, wxALIGN_CENTER_VERTICAL, 0);
 			szr_vr->Add(spin_scale);
 		}
@@ -120,6 +121,7 @@ void CConfigVR::CreateGUIControls()
 				wxGetTranslation(lean_desc), -180.0f, 180.0f, 1.0f);
 			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Lean back angle:"));
 
+			spin_lean->SetToolTip(wxGetTranslation(lean_desc));
 			label->SetToolTip(wxGetTranslation(lean_desc));
 			szr_vr->Add(label, 1, wxALIGN_CENTER_VERTICAL, 0);
 			szr_vr->Add(spin_lean);
@@ -136,24 +138,26 @@ void CConfigVR::CreateGUIControls()
 		}
 		// Synchronous Timewarp extra frames per frame
 		{
-			U32Setting *num = new U32Setting(page_vr, _("Min exta frames:"), vconfig.iMinExtraFrames, 0, 89);
-			RegisterControl(num, lean_desc);
-			num->SetValue(vconfig.iMinExtraFrames);
-			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Min exta frames:"));
+			U32Setting* spin_extra_frames = new U32Setting(page_vr, _("Extra Timewarped Frames:"), vconfig.iExtraFrames, 0, 4);
+			RegisterControl(spin_extra_frames, extraframes_desc);
+			spin_extra_frames->SetToolTip(extraframes_desc);
+			spin_extra_frames->SetValue(vconfig.iExtraFrames);
+			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Extra Timewarped Frames:"));
 
-			label->SetToolTip(wxGetTranslation(lean_desc));
+			label->SetToolTip(wxGetTranslation(extraframes_desc));
 			szr_vr->Add(label, 1, wxALIGN_CENTER_VERTICAL, 0);
-			szr_vr->Add(num);
+			szr_vr->Add(spin_extra_frames);
 		}
 		{
-			U32Setting *num = new U32Setting(page_vr, _("Max exta frames:"), vconfig.iMaxExtraFrames, 0, 89);
-			RegisterControl(num, lean_desc);
-			num->SetValue(vconfig.iMaxExtraFrames);
-			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Max exta frames:"));
+			SettingNumber* const spin_timewarp_tweak = CreateNumber(page_vr, vconfig.fTimeWarpTweak, _("Timewarp VSync Tweak:"), -1.0f, 1.0f, 0.0001f);
+			RegisterControl(spin_timewarp_tweak, timewarptweak_desc);
+			spin_timewarp_tweak->SetToolTip(timewarptweak_desc);
+			spin_timewarp_tweak->SetValue(vconfig.fTimeWarpTweak);
+			wxStaticText *label = new wxStaticText(page_vr, wxID_ANY, _("Timewarp VSync Tweak:"));
 
-			label->SetToolTip(wxGetTranslation(lean_desc));
+			label->SetToolTip(wxGetTranslation(timewarptweak_desc));
 			szr_vr->Add(label, 1, wxALIGN_CENTER_VERTICAL, 0);
-			szr_vr->Add(num);
+			szr_vr->Add(spin_timewarp_tweak);
 		}
 
 		szr_vr->Add(CreateCheckBox(page_vr, _("Enable VR"), wxGetTranslation(enablevr_desc), vconfig.bEnableVR));
@@ -505,14 +509,9 @@ SettingRadioButton* CConfigVR::CreateRadioButton(wxWindow* parent, const wxStrin
 
 SettingNumber* CConfigVR::CreateNumber(wxWindow* parent, float &setting, const wxString& description, float min, float max, float inc, long style)
 {
-	//TODO: Find why it won't compile on Linux here
-#ifdef _WIN32
 	SettingNumber* const sn = new SettingNumber(parent, wxString(), setting, min, max, inc, style);
 	RegisterControl(sn, description);
 	return sn;
-#else
-	return nullptr;
-#endif
 }
 
 /* Use this to register descriptions for controls which have NOT been created using the Create* functions from above */
diff --git a/Source/Core/DolphinWX/Frame.cpp b/Source/Core/DolphinWX/Frame.cpp
index 273e92c..140cea6 100644
--- a/Source/Core/DolphinWX/Frame.cpp
+++ b/Source/Core/DolphinWX/Frame.cpp
@@ -1216,17 +1216,17 @@ void CFrame::OnKeyDown(wxKeyEvent& event)
 			else if (IsHotkey(event, HK_FREELOOK_RESET_SPEED))
 				SConfig::GetInstance().m_LocalCoreStartupParameter.fFreeLookSensitivity = 1.0f;
 			else if (IsHotkey(event, HK_FREELOOK_UP))
-				VertexShaderManager::TranslateView(0.0f, 0.0f, -freeLookSpeed);
+				VertexShaderManager::TranslateView(0.0f, -(freeLookSpeed / 2) * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), (-freeLookSpeed / 2) * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 			else if (IsHotkey(event, HK_FREELOOK_DOWN))
-				VertexShaderManager::TranslateView(0.0f, 0.0f, freeLookSpeed);
+				VertexShaderManager::TranslateView(0.0f, (freeLookSpeed / 2) * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), (freeLookSpeed / 2) * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 			else if (IsHotkey(event, HK_FREELOOK_LEFT))
 				VertexShaderManager::TranslateView(freeLookSpeed, 0.0f);
 			else if (IsHotkey(event, HK_FREELOOK_RIGHT))
 				VertexShaderManager::TranslateView(-freeLookSpeed, 0.0f);
 			else if (IsHotkey(event, HK_FREELOOK_ZOOM_IN))
-				VertexShaderManager::TranslateView(0.0f, freeLookSpeed);
+				VertexShaderManager::TranslateView(0.0f, freeLookSpeed * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), -freeLookSpeed * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 			else if (IsHotkey(event, HK_FREELOOK_ZOOM_OUT))
-				VertexShaderManager::TranslateView(0.0f, -freeLookSpeed);
+				VertexShaderManager::TranslateView(0.0f, -freeLookSpeed * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), freeLookSpeed * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 			else if (IsHotkey(event, HK_FREELOOK_RESET))
 			{
 				VertexShaderManager::ResetView();
diff --git a/Source/Core/DolphinWX/VideoConfigDiag.cpp b/Source/Core/DolphinWX/VideoConfigDiag.cpp
index 40fbeb5..fce45ca 100644
--- a/Source/Core/DolphinWX/VideoConfigDiag.cpp
+++ b/Source/Core/DolphinWX/VideoConfigDiag.cpp
@@ -761,3 +761,6 @@ void VideoConfigDiag::CreateDescriptionArea(wxPanel* const page, wxBoxSizer* con
 	// Store description text object for later lookup
 	desc_texts.insert(std::pair<wxWindow*,wxStaticText*>(page, desc_text));
 }
+
+template class FloatSetting<float>;
+template class FloatSetting<double>;
diff --git a/Source/Core/DolphinWX/VideoConfigDiag.h b/Source/Core/DolphinWX/VideoConfigDiag.h
index 03eb565..043573a 100644
--- a/Source/Core/DolphinWX/VideoConfigDiag.h
+++ b/Source/Core/DolphinWX/VideoConfigDiag.h
@@ -282,6 +282,8 @@ static wxString async_desc = wxTRANSLATE("Render head rotation updates in a sepa
 static wxString temp_desc = wxTRANSLATE("Game specific VR option, in metres or degrees");
 static wxString scale_desc = wxTRANSLATE("(Don't change this until the game's Units Per Metre setting is already lifesize!)\n\nScale multiplier for all VR worlds.\n1x = lifesize, 2x = Giant size\n0.5x = Child size, 0.17x = Barbie doll size, 0.02x = Lego size\n\nIf unsure, use 1.00.");
 static wxString lean_desc = wxTRANSLATE("How many degrees leaning back should count as vertical.\n0 = sitting/standing, 45 = reclining\n90 = playing lying on your back, -90 = on your front\n\nIf unsure, use 0.");
+static wxString extraframes_desc = wxTRANSLATE("How many extra frames to timewarp.  Set to 0 for 60fps games, 1 for 30fps games, 2 for 20fps games and the framelimiter to your Rift's refresh rate.  For 25fps PAL games, set to 2 and set the frame limiter to 60 (assuming the Rift's refresh rate is set to 75hz).  If unsure, use 0.");
+static wxString timewarptweak_desc = wxTRANSLATE("How long before the expected Vsync the timewarped frame should be injected. Ideally this value should zero, but some configurations may benefit from an earlier injection.  Only used if 'Extra Timewarped Frames' is non-zero. If unsure, set this to 0.");
 static wxString enablevr_desc = wxTRANSLATE("Enable Virtual Reality (if your HMD was detected when you started Dolphin).\n\nIf unsure, leave this checked.");
 static wxString player_desc = wxTRANSLATE("During split-screen games, which player is wearing the Oculus Rift?\nPlayer 1 is top left, player 2 is top right, player 3 is bottom left, player 4 is bottom right.\nThe player in the Rift will only see their player's view.\n\nIf unsure, say Player 1.");
 static wxString lowpersistence_desc = wxTRANSLATE("Use low persistence on DK2 to reduce motion blur when turning your head.\n\nIf unsure, leave this checked.");
diff --git a/Source/Core/InputCommon/HotkeysXInput.cpp b/Source/Core/InputCommon/HotkeysXInput.cpp
index 42d7300..be2e6a9 100644
--- a/Source/Core/InputCommon/HotkeysXInput.cpp
+++ b/Source/Core/InputCommon/HotkeysXInput.cpp
@@ -149,19 +149,19 @@ namespace HotkeysXInput
 		}
 		if (IsVRSettingsXInput(XInput_State, VR_CAMERA_FORWARD))
 		{
-			VertexShaderManager::TranslateView(0.0f, freeLookSpeed);
+			VertexShaderManager::TranslateView(0.0f, freeLookSpeed * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), -freeLookSpeed * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 		}
 		else if (IsVRSettingsXInput(XInput_State, VR_CAMERA_BACKWARD)) 
 		{
-			VertexShaderManager::TranslateView(0.0f, -freeLookSpeed);
+			VertexShaderManager::TranslateView(0.0f, -freeLookSpeed * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), freeLookSpeed * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 		}
 		if (IsVRSettingsXInput(XInput_State, VR_CAMERA_UP)) 
 		{
-			VertexShaderManager::TranslateView(0.0f, 0.0f, -freeLookSpeed / 2);
+			VertexShaderManager::TranslateView(0.0f, -(freeLookSpeed / 2) * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), (-freeLookSpeed / 2) * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 		}
 		else if (IsVRSettingsXInput(XInput_State, VR_CAMERA_DOWN)) 
 		{
-			VertexShaderManager::TranslateView(0.0f, 0.0f, freeLookSpeed / 2);
+			VertexShaderManager::TranslateView(0.0f, (freeLookSpeed / 2) * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)), (freeLookSpeed / 2) * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 		}
 		if (IsVRSettingsXInput(XInput_State, VR_CAMERA_LEFT)) 
 		{
diff --git a/Source/Core/VideoBackends/D3D/Render.cpp b/Source/Core/VideoBackends/D3D/Render.cpp
index 7dcb759..a103210 100644
--- a/Source/Core/VideoBackends/D3D/Render.cpp
+++ b/Source/Core/VideoBackends/D3D/Render.cpp
@@ -257,7 +257,7 @@ Renderer::~Renderer()
 
 		// Let OVR do distortion rendering, Present and flush/sync.
 		ovrHmd_EndFrame(hmd, g_eye_poses, &FramebufferManager::m_eye_texture[0].Texture);
-		Core::ShouldAddTimewarpFrame();
+		//Core::ShouldAddTimewarpFrame();
 	}
 #endif
 	g_first_rift_frame = true;
@@ -761,13 +761,13 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 	{
 		if (!g_ActiveConfig.bAsynchronousTimewarp)
 		{
-			g_rift_frame_timing = ovrHmd_BeginFrame(hmd, 0);
+			g_rift_frame_timing = ovrHmd_BeginFrame(hmd, ++g_ovr_frameindex);
 #ifdef OCULUSSDK042
 			g_eye_poses[ovrEye_Left] = ovrHmd_GetEyePose(hmd, ovrEye_Left);
 			g_eye_poses[ovrEye_Right] = ovrHmd_GetEyePose(hmd, ovrEye_Right);
 #else
-			g_eye_poses[ovrEye_Left] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Left);
-			g_eye_poses[ovrEye_Right] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Right);
+			ovrVector3f useHmdToEyeViewOffset[2] = { g_eye_render_desc[0].HmdToEyeViewOffset, g_eye_render_desc[1].HmdToEyeViewOffset };
+			ovrHmd_GetEyePoses(hmd, g_ovr_frameindex, useHmdToEyeViewOffset, g_eye_poses, nullptr);
 #endif
 		}
 		g_first_rift_frame = false;
@@ -935,16 +935,12 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 
 			// Let OVR do distortion rendering, Present and flush/sync.
 			ovrHmd_EndFrame(hmd, g_eye_poses, &FramebufferManager::m_eye_texture[0].Texture);
-			while (Core::ShouldAddTimewarpFrame())
+
+			// If 30fps loop once, if 20fps (Zelda: OoT for instance) loop twice.
+			for (int i = 0; i < (int)g_ActiveConfig.iExtraFrames; ++i)
 			{
-				auto frameTime = ovrHmd_BeginFrame(hmd, g_ovr_frameindex++);
-				if (0 == frameTime.TimewarpPointSeconds) {
-					ovr_WaitTillTime(frameTime.TimewarpPointSeconds - 0.002);
-				}
-				else {
-					ovr_WaitTillTime(frameTime.NextFrameSeconds - 0.008);
-				}
-				ovrHmd_EndFrame(hmd, g_eye_poses, &FramebufferManager::m_eye_texture[0].Texture);
+				ovrFrameTiming frameTime = ovrHmd_BeginFrame(hmd, g_ovr_frameindex++);
+				ovr_WaitTillTime(frameTime.NextFrameSeconds - g_ActiveConfig.fTimeWarpTweak);
 			}
 		}
 		else
@@ -1139,7 +1135,7 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 #ifdef HAVE_OCULUSSDK
 	if (g_has_rift && g_ActiveConfig.bEnableVR && !g_ActiveConfig.bAsynchronousTimewarp)
 	{
-		g_rift_frame_timing = ovrHmd_BeginFrame(hmd, 0);
+		g_rift_frame_timing = ovrHmd_BeginFrame(hmd, ++g_ovr_frameindex);
 	}
 #endif
 
diff --git a/Source/Core/VideoBackends/OGL/FramebufferManager.cpp b/Source/Core/VideoBackends/OGL/FramebufferManager.cpp
index 9ca3b1b..cc7378d 100644
--- a/Source/Core/VideoBackends/OGL/FramebufferManager.cpp
+++ b/Source/Core/VideoBackends/OGL/FramebufferManager.cpp
@@ -6,6 +6,8 @@
 #include "VideoBackends/OGL/GLInterface/WGL.h"
 
 #include "VideoCommon/VR920.h"
+#else
+#include "VideoBackends/OGL/GLInterface/GLX.h"
 #endif
 
 #include "Common/CommonFuncs.h"
@@ -617,7 +619,7 @@ void FramebufferManager::ConfigureRift()
 #endif
 #else
 	cfg.OGL.Disp = glXGetCurrentDisplay();
-	cfg.OGL.Win = glXGetCurrentDrawable();
+	//cfg.OGL.Win = glXGetCurrentDrawable();
 #endif
 	int caps = 0;
 	if (g_Config.bChromatic)
diff --git a/Source/Core/VideoBackends/OGL/Render.cpp b/Source/Core/VideoBackends/OGL/Render.cpp
index a74c0fb..6414257 100644
--- a/Source/Core/VideoBackends/OGL/Render.cpp
+++ b/Source/Core/VideoBackends/OGL/Render.cpp
@@ -1545,7 +1545,7 @@ static void DumpFrame(const std::vector<u8>& data, int w, int h)
 void Renderer::AsyncTimewarpDraw()
 {
 #ifdef HAVE_OCULUSSDK
-	auto frameTime = ovrHmd_BeginFrame(hmd, g_ovr_frameindex++);
+	auto frameTime = ovrHmd_BeginFrame(hmd, ++g_ovr_frameindex);
 	g_ovr_lock.unlock();
 
 	if (0 == frameTime.TimewarpPointSeconds) {
@@ -1717,8 +1717,8 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 			g_eye_poses[ovrEye_Left] = ovrHmd_GetEyePose(hmd, ovrEye_Left);
 			g_eye_poses[ovrEye_Right] = ovrHmd_GetEyePose(hmd, ovrEye_Right);
 #else
-			g_eye_poses[ovrEye_Left] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Left);
-			g_eye_poses[ovrEye_Right] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Right);
+			ovrVector3f useHmdToEyeViewOffset[2] = { g_eye_render_desc[0].HmdToEyeViewOffset, g_eye_render_desc[1].HmdToEyeViewOffset };
+			ovrHmd_GetEyePoses(hmd, g_ovr_frameindex, useHmdToEyeViewOffset, g_eye_poses, nullptr);
 #endif
 		}
 		g_first_rift_frame = false;
@@ -1843,15 +1843,12 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 			glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
 			glBindBuffer(GL_ARRAY_BUFFER, 0);
 			ovrHmd_EndFrame(hmd, g_eye_poses, &FramebufferManager::m_eye_texture[0].Texture);
-			while (Core::ShouldAddTimewarpFrame())
+			for (int i = 0; i < (int)g_ActiveConfig.iExtraFrames; ++i)
 			{
-				auto frameTime = ovrHmd_BeginFrame(hmd, g_ovr_frameindex++);
-				if (0 == frameTime.TimewarpPointSeconds) {
-					ovr_WaitTillTime(frameTime.TimewarpPointSeconds - 0.002);
-				}
-				else {
-					ovr_WaitTillTime(frameTime.NextFrameSeconds - 0.008);
-				}
+				ovrFrameTiming frameTime = ovrHmd_BeginFrame(hmd, ++g_ovr_frameindex);
+
+				ovr_WaitTillTime(frameTime.NextFrameSeconds - g_ActiveConfig.fTimeWarpTweak);
+
 				ovrHmd_EndFrame(hmd, g_eye_poses, &FramebufferManager::m_eye_texture[0].Texture);
 			}
 
@@ -2152,6 +2149,10 @@ void Renderer::SwapImpl(u32 xfbAddr, u32 fbWidth, u32 fbStride, u32 fbHeight, co
 		{
 			FramebufferManager::ConfigureRift();
 		}
+
+		//To do: Probably not the right place for these.  Why do they update for D3D automatically, but not for OpenGL?
+		g_ActiveConfig.iExtraFrames = g_Config.iExtraFrames;
+		g_ActiveConfig.fTimeWarpTweak = g_Config.fTimeWarpTweak;
 	}
 #endif
 
diff --git a/Source/Core/VideoCommon/VR.cpp b/Source/Core/VideoCommon/VR.cpp
index 977ed2a..0508753 100644
--- a/Source/Core/VideoCommon/VR.cpp
+++ b/Source/Core/VideoCommon/VR.cpp
@@ -15,6 +15,7 @@
 #include "Common/Common.h"
 #include "Common/MathUtil.h"
 #include "Core/ConfigManager.h"
+#include "VideoCommon/VideoConfig.h"
 #include "VideoCommon/VR.h"
 
 void ClearDebugProj();
@@ -154,15 +155,15 @@ void ReadHmdOrientation(float *roll, float *pitch, float *yaw, float *x, float *
 	if (g_has_rift && hmd)
 	{
 		// we can only call GetEyePose between BeginFrame and EndFrame
-		g_ovr_lock.lock();
 #ifdef OCULUSSDK042
+		g_ovr_lock.lock();
 		g_eye_poses[ovrEye_Left] = ovrHmd_GetEyePose(hmd, ovrEye_Left);
 		g_eye_poses[ovrEye_Right] = ovrHmd_GetEyePose(hmd, ovrEye_Right);
+		g_ovr_lock.unlock();
 #else
-		g_eye_poses[ovrEye_Left] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Left);
-		g_eye_poses[ovrEye_Right] = ovrHmd_GetHmdPosePerEye(hmd, ovrEye_Right);
+		ovrVector3f useHmdToEyeViewOffset[2] = { g_eye_render_desc[0].HmdToEyeViewOffset, g_eye_render_desc[1].HmdToEyeViewOffset };
+		ovrHmd_GetEyePoses(hmd, g_ovr_frameindex, useHmdToEyeViewOffset, g_eye_poses, nullptr);
 #endif
-		g_ovr_lock.unlock();
 		//ovrTrackingState ss = ovrHmd_GetTrackingState(hmd, g_rift_frame_timing.ScanoutMidpointSeconds);
 		//if (ss.StatusFlags & (ovrStatus_OrientationTracked | ovrStatus_PositionTracked))
 		{
@@ -174,8 +175,8 @@ void ReadHmdOrientation(float *roll, float *pitch, float *yaw, float *x, float *
 			*pitch = -RADIANS_TO_DEGREES(p); // should be degrees down
 			*yaw = -RADIANS_TO_DEGREES(ya);   // should be degrees right
 			*x = pose.Translation.x;
-			*y = pose.Translation.y;
-			*z = pose.Translation.z;
+			*y = (pose.Translation.y * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch))) - (pose.Translation.z * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
+			*z = (pose.Translation.z * cos(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch))) + (pose.Translation.y * sin(DEGREES_TO_RADIANS(g_ActiveConfig.fCameraPitch)));
 		}
 	}
 	else
diff --git a/Source/Core/VideoCommon/VR.h b/Source/Core/VideoCommon/VR.h
index 7f0a32a..ee38936 100644
--- a/Source/Core/VideoCommon/VR.h
+++ b/Source/Core/VideoCommon/VR.h
@@ -9,8 +9,9 @@ const float DEFAULT_VR_UNITS_PER_METRE = 1.0f, DEFAULT_VR_HUD_DISTANCE = 1.5f, D
 	DEFAULT_VR_HUD_3D_CLOSER = 0.5f,
 	DEFAULT_VR_CAMERA_FORWARD = 0.0f, DEFAULT_VR_CAMERA_PITCH = 0.0f, DEFAULT_VR_AIM_DISTANCE = 7.0f, 
 	DEFAULT_VR_SCREEN_HEIGHT = 2.0f, DEFAULT_VR_SCREEN_DISTANCE = 1.5f, DEFAULT_VR_SCREEN_THICKNESS = 0.5f, 
-	DEFAULT_VR_SCREEN_UP = 0.0f, DEFAULT_VR_SCREEN_RIGHT = 0.0f, DEFAULT_VR_SCREEN_PITCH = 0.0f;
-const int DEFAULT_VR_MIN_EXTRA_FRAMES = 0, DEFAULT_VR_MAX_EXTRA_FRAMES = 2;
+	DEFAULT_VR_SCREEN_UP = 0.0f, DEFAULT_VR_SCREEN_RIGHT = 0.0f, DEFAULT_VR_SCREEN_PITCH = 0.0f,
+	DEFAULT_VR_TIMEWARP_TWEAK = 0;
+const int DEFAULT_VR_EXTRA_FRAMES = 0;
 
 #ifdef HAVE_OCULUSSDK
 #include "OVR_Version.h"
diff --git a/Source/Core/VideoCommon/VideoConfig.cpp b/Source/Core/VideoCommon/VideoConfig.cpp
index d1d3a83..ba3c635 100644
--- a/Source/Core/VideoCommon/VideoConfig.cpp
+++ b/Source/Core/VideoCommon/VideoConfig.cpp
@@ -63,8 +63,8 @@ VideoConfig::VideoConfig()
 	bOverdrive = true;
 	bHqDistortion = false;
 	iVRPlayer = 0;
-	iMinExtraFrames = DEFAULT_VR_MIN_EXTRA_FRAMES;
-	iMaxExtraFrames = DEFAULT_VR_MAX_EXTRA_FRAMES;
+	fTimeWarpTweak = DEFAULT_VR_TIMEWARP_TWEAK;
+	iExtraFrames = DEFAULT_VR_EXTRA_FRAMES;
 
 	fUnitsPerMetre = DEFAULT_VR_UNITS_PER_METRE;
 	// in metres
@@ -180,8 +180,8 @@ void VideoConfig::LoadVR(const std::string& ini_file)
 	vr->Get("Overdrive", &bOverdrive, true);
 	vr->Get("HQDistortion", &bHqDistortion, false);
 	vr->Get("Player", &iVRPlayer, 0);
-	vr->Get("MinExtraFrames", &iMinExtraFrames, DEFAULT_VR_MIN_EXTRA_FRAMES);
-	vr->Get("MaxExtraFrames", &iMaxExtraFrames, DEFAULT_VR_MAX_EXTRA_FRAMES);
+	vr->Get("TimewarpTweak", &fTimeWarpTweak, DEFAULT_VR_TIMEWARP_TWEAK);
+	vr->Get("NumExtraFrames", &iExtraFrames, DEFAULT_VR_EXTRA_FRAMES);
 }
 
 
@@ -449,8 +449,8 @@ void VideoConfig::SaveVR(const std::string& ini_file)
 	vr->Set("Overdrive", bOverdrive);
 	vr->Set("HQDistortion", bHqDistortion);
 	vr->Set("Player", iVRPlayer);
-	vr->Set("MinExtraFrames", iMinExtraFrames);
-	vr->Set("MaxExtraFrames", iMaxExtraFrames);
+	vr->Set("TimewarpTweak", fTimeWarpTweak);
+	vr->Set("NumExtraFrames", iExtraFrames);
 
 	iniFile.Save(ini_file);
 }
diff --git a/Source/Core/VideoCommon/VideoConfig.h b/Source/Core/VideoCommon/VideoConfig.h
index f11ad19..9ccbcf2 100644
--- a/Source/Core/VideoCommon/VideoConfig.h
+++ b/Source/Core/VideoCommon/VideoConfig.h
@@ -139,8 +139,8 @@ struct VideoConfig final
 	bool bOverdrive;
 	bool bHqDistortion;
 	int iVRPlayer;
-	u32 iMinExtraFrames;
-	u32 iMaxExtraFrames;
+	float fTimeWarpTweak;
+	u32 iExtraFrames;
 
 	// VR
 	float fUnitsPerMetre;
