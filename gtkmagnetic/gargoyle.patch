diff -Nur Generic/defs.h Generic.garg/defs.h
--- Generic/defs.h	2008-08-12 19:56:48.000000000 +0200
+++ Generic.garg/defs.h	2011-10-20 05:38:40.000000000 +0200
@@ -21,7 +21,7 @@
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program; if not, write to the Free Software
-*     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 \****************************************************************************/
 
@@ -35,12 +35,34 @@
 *       correct number of bits on your system !!!
 \*****************************************************************************/
 
-typedef unsigned char  type8;
-typedef signed   char  type8s;
-typedef unsigned short type16;
-typedef signed   short type16s;
-typedef unsigned long  type32;
-typedef signed   long  type32s;
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+typedef signed char   type8s;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if SHRT_MAX==0x7fff
+typedef unsigned short type16;
+typedef signed   short type16s;
+#elif INT_MAX==0x7fff
+typedef unsigned int type16;
+typedef signed   int type16s;
+#else
+#error "Can't find a 16-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+typedef signed   int type32s;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+typedef signed   long type32s;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
 
 /****************************************************************************\
 * Compile time switches 
diff -Nur Generic/emu.c Generic.garg/emu.c
--- Generic/emu.c	2008-08-21 07:10:40.000000000 +0200
+++ Generic.garg/emu.c	2011-10-04 11:35:14.000000000 +0200
@@ -21,7 +21,7 @@
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program; if not, write to the Free Software
-*     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 * History:
 *
@@ -824,7 +824,7 @@
 				if ((hints != 0) && (hint_contents != 0))
 				{
 					/* Read number of blocks */
-					fread(&buf, 1, 2, hnt_fp);
+					if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 					blkcnt = read_w2(buf);
 #ifdef LOGHNT
 					out2("Blocks: %d\n",blkcnt);
@@ -836,7 +836,7 @@
 						out2("\nBlock No. %d\n",i);
 #endif
 						/* Read number of elements */
-						fread(&buf, 1, 2, hnt_fp);
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 						elcnt = read_w2(buf);
 #ifdef LOGHNT
 						out2("Elements: %d\n",elcnt);
@@ -844,7 +844,7 @@
 						hints[i].elcount = elcnt;
 
 						/* Read node type */
-						fread(&buf, 1, 2, hnt_fp);
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 						ntype = read_w2(buf);
 #ifdef LOGHNT
 						if (ntype == 1)
@@ -859,9 +859,9 @@
 #endif
 						for (j = 0; j < elcnt; j++)
 						{
-							fread(&buf, 1, 2, hnt_fp);
+							if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 							elsize = read_w2(buf);
-							fread(hint_contents+conidx, 1, elsize, hnt_fp);
+							if (fread(hint_contents+conidx, 1, elsize, hnt_fp) != elsize && !feof(hnt_fp)) return 0;
 							hint_contents[conidx+elsize-1] = '\0';
 #ifdef LOGHNT
 							out2("%s\n",hint_contents+conidx);
@@ -877,7 +877,7 @@
 #endif
 							for (j = 0; j < elcnt; j++)
 							{
-								fread(&buf, 1, 2, hnt_fp);
+								if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 								hints[i].links[j] = read_w2(buf);
 #ifdef LOGHNT
 								out2("%d\n",hints[i].links[j]);
@@ -886,7 +886,7 @@
 						}
 
 						/* Read the parent block */
-						fread(&buf, 1, 2, hnt_fp);
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
 						hints[i].parent = read_w2(buf);
 #ifdef LOGHNT
 						out2("Parent: %d\n",hints[i].parent);
diff -Nur Generic/gfxlink2.c Generic.garg/gfxlink2.c
--- Generic/gfxlink2.c	2010-10-25 17:32:11.000000000 +0200
+++ Generic.garg/gfxlink2.c	2011-06-07 22:21:27.000000000 +0200
@@ -6,7 +6,6 @@
     Written by David Kinder.
 */
 
-#include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
diff -Nur Generic/gfxlink.c Generic.garg/gfxlink.c
--- Generic/gfxlink.c	1998-01-09 21:35:42.000000000 +0100
+++ Generic.garg/gfxlink.c	2011-06-07 22:21:27.000000000 +0200
@@ -61,9 +61,29 @@
 #define DIRSEP "/"
 #endif
 
-typedef unsigned char type8;
-typedef unsigned short type16;
-typedef unsigned long int type32;
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if SHRT_MAX==0x7fff
+typedef unsigned short type16;
+#elif INT_MAX==0x7fff
+typedef unsigned int type16;
+#else
+#error "Can't find a 16-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
 
 int fdi, fdo_temp, fdo_gfx;
 char infilemask[FILENAMELENGTH];
diff -Nur Generic/main.c Generic.garg/main.c
--- Generic/main.c	2010-10-25 17:32:25.000000000 +0200
+++ Generic.garg/main.c	2011-10-04 11:35:14.000000000 +0200
@@ -21,7 +21,7 @@
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program; if not, write to the Free Software
-*     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111, USA.
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 *
 *     Simple ANSI interface main.c
 *
@@ -36,7 +36,7 @@
 #define WIDTH 78
 
 type8 buffer[80], xpos = 0, bufpos = 0, log_on = 0, ms_gfx_enabled, filename[256];
-FILE *logfile1 = 0, *logfile2 = 0;
+FILE *log1 = 0, *log2 = 0;
 
 type8 ms_load_file(type8s *name, type8 *ptr, type16 size)
 {
@@ -88,23 +88,23 @@
 
 void script_write(type8 c)
 {
-	if (log_on == 2 && fputc(c,logfile1) == EOF)
+	if (log_on == 2 && fputc(c,log1) == EOF)
 	{
 		printf("[Problem with script file - closing]\n");
-		fclose(logfile1);
+		fclose(log1);
 		log_on = 0;
 	}
 }
 
 void transcript_write(type8 c)
 {
-	if (logfile2 && c == 0x08 && ftell(logfile2) > 0)
-		fseek(logfile2,-1,SEEK_CUR);
-	else if (logfile2 && fputc(c,logfile2) == EOF)
+	if (log2 && c == 0x08 && ftell(log2) > 0)
+		fseek(log2,-1,SEEK_CUR);
+	else if (log2 && fputc(c,log2) == EOF)
 	{
 		printf("[Problem with transcript file - closing]\n");
-		fclose(logfile2);
-		logfile2 = 0;
+		fclose(log2);
+		log2 = 0;
 	}
 }
 
@@ -187,11 +187,11 @@
 			if (log_on == 1)
 			{
 				/* Reading from logfile */
-				if ((c = fgetc(logfile1)) == EOF)
+				if ((c = fgetc(log1)) == EOF)
 				{
 					/* End of log? - turn off */
 					log_on = 0;
-					fclose(logfile1);
+					fclose(log1);
 					c = getchar();
 				}
 				else printf("%c",c); /* print the char as well */
@@ -211,7 +211,7 @@
 					{
 						printf("[Closing script file]\n");
 						log_on = 0;
-						fclose(logfile1);
+						fclose(log1);
 					}
 					else if (!strcmp(buf,"undo"))
 						c = 0;
@@ -311,17 +311,17 @@
 					slimit = 655360;
 				break;
 			case 't':
-				if (!(logfile2 = fopen(&argv[i][2],"w")))
+				if (!(log2 = fopen(&argv[i][2],"w")))
 					printf("Failed to open \"%s\" for writing.\n",&argv[i][2]);
 				break; 
 			case 'r':
-				if (logfile1 = fopen(&argv[i][2],"r"))
+				if (log1 = fopen(&argv[i][2],"r"))
 					log_on = 1;
 				else
 					printf("Failed to open \"%s\" for reading.\n",&argv[i][2]);
 				break;
 			case 'w':
-				if (logfile1 = fopen(&argv[i][2],"w"))
+				if (log1 = fopen(&argv[i][2],"w"))
 					log_on = 2;
 				else
 					printf("Failed to open \"%s\" for writing.\n",&argv[i][2]);
@@ -374,9 +374,9 @@
 	}
 	ms_freemem();
 	if (log_on)
-		fclose(logfile1);
-	if (logfile2)
-		fclose(logfile2);
+		fclose(log1);
+	if (log2)
+		fclose(log2);
 	printf("\nExiting.\n");
 	return 0;
 }
diff -Nur Generic/passwd.c Generic.garg/passwd.c
--- Generic/passwd.c	2000-12-06 23:33:06.000000000 +0100
+++ Generic.garg/passwd.c	2011-06-07 22:21:27.000000000 +0200
@@ -1,61 +1,73 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <ctype.h>
-
-typedef unsigned char  type8;
-typedef unsigned long   type32;
-
-type8 obfuscate(type8 c) {
-	static type8 state;
-	type8	       i;
-
-	if (!c) state=0;
-	else {
-		state^=c;
-		for (i=0;i<13;i++) {
-			if ((state & 1) ^ ((state>>1) & 1)) state|=0x80;
-			else state&=0x7f;
-			state>>=1;
-		}
-	}
-	return state;
-}
-
-int main(int argc, char **argv) {
-
-	type8 tmp,name[128],result[128],pad[]="MAGNETICSCR";
-	type32 i,j;
-
-	if (argc!=2) {
-		printf("Usage: %s string\n",argv[0]);
-		exit(1);
-	}
-
-	for (i=j=0;i<strlen(argv[1]);i++) {
-		if (argv[1][i]!=0x20) name[j++]=toupper(argv[1][i]);
-	}
-	name[j]=0;
-
-	tmp=name[strlen(name)-1];
-	if ((tmp=='#') || (tmp==']')) name[strlen(name)-1]=0;
-
-	if (strlen(name)<12) {
-		for (i=strlen(name),j=0;i<12;i++,j++) name[i]=pad[j];
-		name[i]=0;
-	}
-
-	obfuscate(0);
-	i=j=0;
-	while (name[i]) {
-		tmp=obfuscate(name[i++]);
-		if (name[i]) tmp+=obfuscate(name[i++]);
-		tmp&=0x1f;
-		if (tmp<26) tmp+='A';
-		else tmp+=0x16;
-		result[j++]=tmp;
-	}
-	result[j]=0;
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
+type8 obfuscate(type8 c) {
+	static type8 state;
+	type8	       i;
+
+	if (!c) state=0;
+	else {
+		state^=c;
+		for (i=0;i<13;i++) {
+			if ((state & 1) ^ ((state>>1) & 1)) state|=0x80;
+			else state&=0x7f;
+			state>>=1;
+		}
+	}
+	return state;
+}
+
+int main(int argc, char **argv) {
+
+	type8 tmp,name[128],result[128],pad[]="MAGNETICSCR";
+	type32 i,j;
+
+	if (argc!=2) {
+		printf("Usage: %s string\n",argv[0]);
+		exit(1);
+	}
+
+	for (i=j=0;i<strlen(argv[1]);i++) {
+		if (argv[1][i]!=0x20) name[j++]=toupper(argv[1][i]);
+	}
+	name[j]=0;
+
+	tmp=name[strlen(name)-1];
+	if ((tmp=='#') || (tmp==']')) name[strlen(name)-1]=0;
+
+	if (strlen(name)<12) {
+		for (i=strlen(name),j=0;i<12;i++,j++) name[i]=pad[j];
+		name[i]=0;
+	}
+
+	obfuscate(0);
+	i=j=0;
+	while (name[i]) {
+		tmp=obfuscate(name[i++]);
+		if (name[i]) tmp+=obfuscate(name[i++]);
+		tmp&=0x1f;
+		if (tmp<26) tmp+='A';
+		else tmp+=0x16;
+		result[j++]=tmp;
+	}
+	result[j]=0;
 	printf("The password for \"%s\" is: %s\n",argv[1],result);
-	return 0;
-}
+	return 0;
+}
diff -Nur Generic/sndlink.c Generic.garg/sndlink.c
--- Generic/sndlink.c	2009-06-06 18:22:59.000000000 +0200
+++ Generic.garg/sndlink.c	2011-06-07 22:21:27.000000000 +0200
@@ -7,7 +7,6 @@
 
 	v1.1 added option for tempo patching
 	v1.2 fixed tempo patching
-	v1.3 remove garbage bytes at end of original data
 */
 
 #include <stdio.h>
@@ -39,7 +38,6 @@
 FILE* OutputFile = NULL;
 unsigned long OutOffset = 0;
 int tempopatch=0;
-int garbagefix=0;
 
 void WriteLong(unsigned char* p, unsigned long v)
 {
@@ -204,7 +202,7 @@
 
 void WriteSndFile(int Index)
 {
-	unsigned long offset, length, j = 0;
+	unsigned long offset, length;
 	unsigned short tsize;
 	int game = -1;
 
@@ -214,21 +212,6 @@
 				length = BUFFER_SIZE;
 			ReadFile(Buffer1,&offset,length);
 
-			// Remove garbage bytes if present
-			if (garbagefix)
-			{
-				while ((j <= length-1) && !(Buffer1[j]==0xFF && Buffer1[j+1]==0x2F && Buffer1[j+2]==0x00))
-				{
-					j++;
-				}
-				if (j+3 != length)
-				{
-					SndFiles[Index].Length = j+3;
-					length=j+3;
-				}
-			}
-
-
 			// Tempo patching
 			if (tempopatch)
 			{
@@ -356,25 +339,14 @@
 
 int main(int argc, char** argv)
 {
-	if (argc == 2 || 
-		((argc == 3 && ((strcmp(argv[1],"-p")==0) || strcmp(argv[1],"-r")==0))) ||
-		((argc == 4 && ((strcmp(argv[1],"-p")==0) && strcmp(argv[2],"-r")==0))))
+	if (argc == 2 || (argc == 3 && strcmp(argv[1],"-p")==0))
 	{
 		if (argc==2)
 		   OpenFile(argv[1]);
-		else if (argc==2)
-		{
-			if (strcmp(argv[1],"-p")==0)
-				tempopatch = 1;
-			if (strcmp(argv[1],"-r")==0)
-				garbagefix = 1;
-			OpenFile(argv[2]);
-		}
 		else
 		{
 			tempopatch = 1;
-			garbagefix = 1;
-			OpenFile(argv[3]);
+			OpenFile(argv[2]);
 		}
 		FindResourceNames();
 		WriteSndHeader1();
@@ -385,18 +357,17 @@
 	}
 	else
 	{
-		printf("SndLink v1.3 by Stefan Meier.\n\n"
+		printf("SndLink v1.2 by Stefan Meier.\n\n"
 		       "Extractor for the music scores in Magnetic Scrolls' Wonderland\n"
 		       "Amiga, Atari ST, PC versions.\n\n"
-			   "Usage: SndLink [-p] [-r] all.rsc\n\n"
+			   "Usage: SndLink [-p] all.rsc\n\n"
 		       "\"all.rsc\" is taken from an installed game. Depending on your\n"
 			   "game version, the resource file might be split into several files\n"
 			   "named e.g. all.1, all.2,... or TWO,THREE,FOUR...\n"
 		       "Before running the extractor, you need to merge these parts into\n"
 			   "one file, e.g. with the DOS command copy /B ONE+TWO+THREE+... all.rsc\n"
 		       "If the extraction is successfull, the file wonder.snd is created\n\n"
-			   "The optional -p switch adds tempo data to the music score\n"
-			   "The optional -r switch removes garbage bytes from the PC versions");
+			   "The optional -p switch adds tempo data to the music score");
 	}
 	return 0;
 }
diff -Nur Generic/.svn/all-wcprops Generic.garg/.svn/all-wcprops
--- Generic/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/all-wcprops	2011-10-04 11:35:14.000000000 +0200
@@ -0,0 +1,89 @@
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/564/trunk/terps/magnetic/Generic
+END
+xtract64.c
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/68/trunk/terps/magnetic/Generic/xtract64.c
+END
+tech.txt
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/tech.txt
+END
+hintlink.c
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/hintlink.c
+END
+myth.c
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/myth.c
+END
+passwd.c
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/68/trunk/terps/magnetic/Generic/passwd.c
+END
+sndlink.c
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/sndlink.c
+END
+gfxlink.c
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/68/trunk/terps/magnetic/Generic/gfxlink.c
+END
+main.c
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/564/trunk/terps/magnetic/Generic/main.c
+END
+gfxlink2.c
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/gfxlink2.c
+END
+emu.c
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/564/trunk/terps/magnetic/Generic/emu.c
+END
+defs.h
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/564/trunk/terps/magnetic/Generic/defs.h
+END
+xtractpc.c
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/xtractpc.c
+END
+xtractmw.c
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/xtractmw.c
+END
+games.txt
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/55/trunk/terps/magnetic/Generic/games.txt
+END
diff -Nur Generic/.svn/entries Generic.garg/.svn/entries
--- Generic/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/entries	2011-10-20 05:35:25.000000000 +0200
@@ -0,0 +1,504 @@
+10
+
+dir
+577
+http://garglk.googlecode.com/svn/trunk/terps/magnetic/Generic
+http://garglk.googlecode.com/svn
+
+
+
+2011-10-03T23:52:09.234283Z
+564
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+be9d5a54-a115-11dd-a9c7-49dec45ca499
+
+xtract64.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+d60c520647f2ba9d6a8ec3ea4f213562
+2008-11-04T00:03:51.978053Z
+68
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9151
+
+tech.txt
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+2b825964216d9237814e8f0f88efed33
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1906
+
+hintlink.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+c72c634a05ee8d2b1a710aa5c12d1eae
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+4630
+
+myth.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+2502ec7f9ff6a58ec1a29246f6e0dea6
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+2363
+
+passwd.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+1371915209b841d0b5a424f30b25b8dc
+2008-11-04T00:03:51.978053Z
+68
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+1410
+
+sndlink.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+a5d123aa6d78691d44a6cf3d8c71f362
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9082
+
+gfxlink.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+87548e32f7712077e1b817fe084cfbaa
+2008-11-04T00:03:51.978053Z
+68
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+7293
+
+main.c
+file
+
+
+
+
+2011-10-04T09:35:14.900450Z
+fe23a6b25fa98234559b5d5a62dda9e7
+2011-10-03T23:52:09.234283Z
+564
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8058
+
+gfxlink2.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+55a1433f4ffdefd70cb5174a83c562b1
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+10151
+
+emu.c
+file
+
+
+
+
+2011-10-04T09:35:14.900450Z
+8adf26e8e0de24fdf4f5944cbf38dcbc
+2011-10-03T23:52:09.234283Z
+564
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+92362
+
+defs.h
+file
+
+
+
+
+2011-10-04T09:35:14.901450Z
+821c2629ddf8272a139e32e317e1b3b5
+2011-10-03T23:52:09.234283Z
+564
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+20039
+
+xtractpc.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+19ef49a391f9cce62f79f53067626b73
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+9103
+
+xtractmw.c
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+ccc4f8ea998ad4c6ac998eca056a0f85
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+8996
+
+games.txt
+file
+
+
+
+
+2011-06-07T20:21:27.117483Z
+1ee8584251657a0304c480576d69662b
+2008-10-30T23:18:20.791158Z
+48
+bcressey
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+3091
+
diff -Nur Generic/.svn/text-base/defs.h.svn-base Generic.garg/.svn/text-base/defs.h.svn-base
--- Generic/.svn/text-base/defs.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/defs.h.svn-base	2011-10-04 11:35:14.000000000 +0200
@@ -0,0 +1,498 @@
+/****************************************************************************\
+*
+* Magnetic - Magnetic Scrolls Interpreter.
+*
+* Written by Niclas Karlsson <nkarlsso@abo.fi>,
+*            David Kinder <davidk.kinder@virgin.net>,
+*            Stefan Meier <Stefan.Meier@if-legends.org> and
+*            Paul David Doherty <pdd@if-legends.org>
+*
+* Copyright (C) 1997-2008  Niclas Karlsson
+*
+*     This program is free software; you can redistribute it and/or modify
+*     it under the terms of the GNU General Public License as published by
+*     the Free Software Foundation; either version 2 of the License, or
+*     (at your option) any later version.
+*
+*     This program is distributed in the hope that it will be useful,
+*     but WITHOUT ANY WARRANTY; without even the implied warranty of
+*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*     GNU General Public License for more details.
+*
+*     You should have received a copy of the GNU General Public License
+*     along with this program; if not, write to the Free Software
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+\****************************************************************************/
+
+#ifndef MAGNETIC_DEFS_H
+#define MAGNETIC_DEFS_H
+
+/*****************************************************************************\
+* Type definitions for Magnetic 
+*
+* Note: When running into trouble please ensure that these types have the 
+*       correct number of bits on your system !!!
+\*****************************************************************************/
+
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+typedef signed char   type8s;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if SHRT_MAX==0x7fff
+typedef unsigned short type16;
+typedef signed   short type16s;
+#elif INT_MAX==0x7fff
+typedef unsigned int type16;
+typedef signed   int type16s;
+#else
+#error "Can't find a 16-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+typedef signed   int type32s;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+typedef signed   long type32s;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
+/****************************************************************************\
+* Compile time switches 
+\****************************************************************************/
+
+/* Switch:  SAVEMEM
+   Purpose: Magnetic loads a complete graphics file into memory by default.
+            Setting this switch you tell Magnetic to load images on request
+            (saving memory, wasting load time)
+
+#define SAVEMEM
+*/
+
+/* Switch:  NO_ANIMATION
+   Purpose: By default Magnetic plays animated graphics.
+            Setting this switch to ignore animations, Magnetic shows the
+            static parts of the images anyway!
+
+#define NO_ANIMATION
+*/
+
+/****************************************************************************\
+* Abstract functions
+*
+* Note: These functions MUST be implemented by each port of Magnetic! 
+\****************************************************************************/
+
+/****************************************************************************\
+* Function: ms_load_file
+*
+* Purpose: Load a save game file and restore game
+*
+* Parameters:   type8s* name            zero terminated string of filename
+*                                       typed by player
+*               type8*  ptr             pointer to data to save
+*               type16 size             number of bytes to save
+*
+* Result: 0 is successful
+*
+* Note: You probably want to put in a file requester!
+\****************************************************************************/
+
+type8 ms_load_file(type8s * name, type8 * ptr, type16 size);
+
+/****************************************************************************\
+* Function: ms_save_file
+*
+* Purpose: Save the current game to file
+*
+* Parameters:   type8s* name            zero terminated string of filename
+*                                       typed by player
+*               type8*  ptr             pointer to data to save
+*               type16  size            number of bytes to save
+*
+* Result: 0 is successful
+*
+* Note: You probably want to put in a file requester!
+\****************************************************************************/
+
+type8 ms_save_file(type8s * name, type8 * ptr, type16 size);
+
+/****************************************************************************\
+* Function: ms_statuschar
+*
+* Purpose: Output a single character to the status bar
+*
+* Parameters:   type8   c               character to be printed
+*
+* Note: All characters are printed as provided except for:
+*       0x0A resets the x position to zero
+*       0x09 moves the cursor to the right half of the bar, ie 'width-11'
+\****************************************************************************/
+
+void ms_statuschar(type8 c);
+
+/****************************************************************************\
+* Function: ms_putchar
+*
+* Purpose: Output a single character to the game/text windows
+*
+* Parameters:   type8   c               character to be printed
+*
+* Note: It is highly recommended to buffer the output, see also ms_flush()
+\****************************************************************************/
+
+void ms_putchar(type8 c);
+
+/****************************************************************************\
+* Function: ms_flush
+*
+* Purpose: Flush the output buffer (if applicable)
+*
+* Note: see also ms_putchar
+\****************************************************************************/
+
+void ms_flush(void);
+
+/****************************************************************************\
+* Function: ms_getchar
+*
+* Purpose: Read user input, buffered
+*
+* Parameters:   type8   trans           if not 0, translate any #undo
+*                                       input to a return code of 0
+*
+* Return: One character
+*
+* Note: The first time it is called a string should be read and then given
+*       back one byte at a time (ie. one for each call) until a '\n' is
+*       reached (which will be the last byte sent back before it all restarts)
+*       Returning a zero means 'undo' and the rest of the line must then be
+*       ignored.
+*       Returning 1 means that the opcode should return immediately. This is
+*       needed to prevent possible corruption of the game's memory in
+*       interpreters which allow a new game to be loaded without restarting.
+\****************************************************************************/
+
+type8 ms_getchar(type8 trans);
+
+/****************************************************************************\
+* Function: ms_showpic
+*
+* Purpose: Displays or hides a picture
+*
+* Parameter:    type32  c       number of image to be displayed
+*               type8   mode    mode == 0 means gfx off,
+*                               mode == 1 gfx on thumbnails,
+*                               mode == 2 gfx on normal.
+*
+* Note: For retrieving the raw data of a picture call ms_extract (see below)
+\****************************************************************************/
+
+void ms_showpic(type32 c, type8 mode);
+
+/****************************************************************************\
+* Function: ms_fatal
+*
+* Purpose: Handle fatal interpreter error
+*
+* Parameter:    type8s* txt     message
+\****************************************************************************/
+
+void ms_fatal(type8s * txt);
+
+/****************************************************************************\
+* Magnetic core functions
+*
+* Note: These functions SHOULD be used somewhere in your port! 
+\****************************************************************************/
+
+/****************************************************************************\
+* Function: ms_extract
+*
+* Purpose: Extract a picture and return a pointer to a raw bitmap
+*
+* Parameters:   type32  c               number of the picture
+*               type16* w               width of picture
+*               type16* h               height pf picture
+*               type16* pal             array for the palette (16 colours)
+*               type8*  is_anim         1 if animated picture, otherwise 0
+*                                       OR null (!)
+*
+* Return: Pointer to bitmap data if successful, otherwise null (also if gfx
+*         are disabled!)
+*
+* Note: All pictures have 16 colours and the palette entries use 3-bit RGB
+*       encoded as 00000RRR0GGG0BBB, that is, bits 0-2 give the blue
+*       component, bits 4-6 the green and bits 8-10 the red. The bitmap is
+*       one byte per pixel, with each byte giving the pixel's index into the
+*       palette. The data is given starting from the upper left corner. The
+*       image buffer is reused when the next picture is requested, so take
+*       care! More information on animated pictures are below!
+\****************************************************************************/
+
+type8 *ms_extract(type32 c, type16 * w, type16 * h, type16 * pal, type8 * is_anim);
+
+/****************************************************************************\
+* Magnetic animated pictures support
+*
+* Note: Some of the pictures for Wonderland and the Collection Volume 1 games
+* are animations. To detect these, pass a pointer to a type8 as the is_anim
+* argument to ms_extract().
+*
+* There are two types of animated images, however almost all images are type1.
+* A type1 image consists of four main elements:
+* 1) A static picture which is loaded straight at the beginning 
+* 2) A set of frames with a mask. These frames are just "small pictures", which
+*    are coded like the normal static pictures. The image mask determines
+*    how the frame is removed after it has been displayed. A mask is exactly
+*    1/8 the size of the image and holds 1 bit per pixel, saying "remove pixel"
+*    or leave pixel set when frame gets removed. It might be a good idea to check
+*    your system documentation for masking operations as your system might be
+*    able to use this mask data directly.
+* 3) Positioning tables. These hold animation sequences consisting of commands
+*    like "Draw frame 12 at (123,456)"
+* 4) A playback script, which determines how to use the positioning tables.
+*    These scripts are handled inside Magnetic, so no need to worry about.
+*    However, details can be found in the ms_animate() function.
+*
+* A type2 image is like a type1 image, but it does not have a static
+* picture, nor does it have frame masking. It just consists of frames.
+*
+* How to support animations?
+* After getting is_anim == 1 you should call ms_animate() immediately, and at
+* regular intervals until ms_animate() returns 0. An appropriate interval
+* between calls is about 100 milliseconds.
+* Each call to ms_animate() will fill in the arguments with the address
+* and size of an array of ms_position structures (see below), each of
+* which holds an an animation frame number and x and y co-ordinates. To
+* display the animation, decode all the animation frames (discussed below)
+* from a single call to ms_animate() and display each one over the main picture.
+* If your port does not support animations, define NO_ANIMATION.
+\****************************************************************************/
+
+struct ms_position
+{
+  type16s x, y;
+  type16s number;
+};
+
+/****************************************************************************\
+* Function: ms_animate
+*
+* Purpose: Generate the next frame of an animation
+*
+* Parameters:   ms_position**   positions  array of ms_position structs
+*               type16*         count      size of array
+*
+* Return: 1 if animation continues, 0 if animation is finfished
+*
+* Note: The positions array holds size ms_positions structures. BEFORE calling
+*       ms_animate again, retrieve the frames for all the ms_positions
+*       structures with ms_get_anim_frame and display each one on the static
+*       main picture.  
+\****************************************************************************/
+
+type8 ms_animate(struct ms_position ** positions, type16 * count);
+
+/****************************************************************************\
+* Function: ms_get_anim_frame
+*
+* Purpose: Extracts the bitmap data of a single animation frame
+*
+* Parameters:   type16s   number        number of frame (see ms_position struct)
+*               type16*   width         width of frame
+*               type16*   height        height of frame
+*               type8**   mask          pointer to masking data, might be NULL
+*
+* Return: 1 if animation continues, 0 if animation is finfished
+*
+* Note: The format of the frame is identical to the main pictures' returned by
+*       ms_extract. The mask has one-bit-per-pixel, determing how to handle the
+*       removal of the frame.
+\****************************************************************************/
+
+type8 * ms_get_anim_frame(type16s number, type16 * width, type16 * height, type8 ** mask);
+
+/****************************************************************************\
+* Function: ms_anim_is_repeating
+*
+* Purpose: Detects whether an animation is repeating
+*
+* Return: True if repeating
+\****************************************************************************/
+
+type8 ms_anim_is_repeating(void);
+
+/****************************************************************************\
+* Magnetic Windows hint support
+* 
+* The windowed Magnetic Scolls games included online hints. To add support 
+* for the hints to your magnetic port, you should implement the ms_showhints
+* function. It retrieves a pointer to an array of ms_hint structs
+* The root element is always hints[0]. The elcount determines the number
+* of items in this topic. You probably want to display those in some kind
+* of list interface. The content pointer points to the actual description of
+* the items, separated by '\0' terminators. The nodetype is 1 if the items are
+* "folders" and 2 if the items are hints. Hints should be displayed one after
+* another. For "folder" items, the links array holds the index of the hint in
+* the array which is to be displayed on selection. One hint block has exactly
+* one type. The parent element determines the "back" target.
+\****************************************************************************/
+#define MAX_HITEMS 25
+
+struct ms_hint
+{
+  type16  elcount;
+  type16  nodetype;
+  type8 * content;
+  type16  links[MAX_HITEMS];
+  type16  parent;
+};
+
+/****************************************************************************\
+* Function: ms_showhints
+* Purpose: Show the player a hint
+*
+* Parameters:   ms_hint* hints          pointer to array of ms_hint structs
+*
+* Return: 0 on error, 1 on success
+\****************************************************************************/
+
+type8 ms_showhints(struct ms_hint * hints);
+
+/****************************************************************************\
+* Magnetic Windows sound support
+* 
+* Wonderland contains music scores that are played when entering specific
+* locations in the game. The music data are actually MIDI events and can be
+* played through normal MIDI devices. The original game plays the MIDI score
+* until the end, even if the location is changed while playing. The playback
+* tempo is not included with the MIDI data. The ms_sndextract function
+* returns a recommended tempo, however depending on the MIDI implementation
+* and operating system, you might need to adapt it.
+\****************************************************************************/
+
+/****************************************************************************\
+* Function: ms_playmusic
+*
+* Purpose: Plays (or stops playing) a MIDI music score.
+*
+* Parameter:    type8 * midi_data       the MIDI data to play
+*               type32  length          the length of the MIDI data
+*               type16  tempo           the suggested tempo for playing
+*
+* Note: If midi_data is NULL, all that should happen is that any currently
+* playing music is stopped.
+* Note: The data returned contain a complete MIDI file header, so if pure
+*       memory processing is not applicable you can write the data to a
+*       temporary file and use external players or libraries.
+\****************************************************************************/
+
+void ms_playmusic(type8 * midi_data, type32 length, type16 tempo);
+
+/****************************************************************************\
+* Function: ms_init
+*
+* Purpose: Loads the interpreter with a game
+*
+* Parameters:   type8s* name            filename of story file
+*               type8s* gfxname         filename of graphics file (optional)
+*               type8s* hntname         filename of hints file (optional)
+*               type8s* sndname         filename of music file (optional)
+*
+* Return:       0 = failure
+*               1 = success (without graphics or graphics failed)
+*               2 = success (with graphics)
+*
+* Note: You must call this function before starting the ms_rungame loop
+\****************************************************************************/
+
+type8 ms_init(type8s * name, type8s * gfxname, type8s * hntname, type8s * sndname);
+
+/****************************************************************************\
+* Function: ms_rungame
+*
+* Purpose: Executes an interpreter instruction
+*
+* Return: True if successful
+*
+* Note: You must call this function in a loop like this:
+*       while (running) {running=ms_rungame();}
+\****************************************************************************/
+
+type8 ms_rungame(void);
+
+/****************************************************************************\
+* Function: ms_freemen
+*
+* Purpose: Frees all allocated ressources
+\****************************************************************************/
+
+void ms_freemem(void);
+
+/****************************************************************************\
+* Function: ms_seed
+*
+* Purpose: Initializes the interpreter's random number generator with
+*          the given seed
+*
+* Parameter:    type32  seed    seed
+\****************************************************************************/
+
+void ms_seed(type32 seed);
+
+/****************************************************************************\
+* Function: ms_is_running
+*
+* Purpose: Detects if game is running
+*
+* Return: True, if game is currently running
+\****************************************************************************/
+
+type8 ms_is_running(void);
+
+/****************************************************************************\
+* Function: ms_is_magwin
+*
+* Purpose: Detects Magnetic Windows games (Wonderland, Collection)
+*
+* Return: True, if Magnetic Windows game
+\****************************************************************************/
+
+type8 ms_is_magwin(void);
+
+/****************************************************************************\
+* Function: ms_stop
+*
+* Purpose: Stops further processing of opcodes
+\****************************************************************************/
+
+void ms_stop(void);
+
+/****************************************************************************\
+* Function: ms_status
+*
+* Purpose: Dumps interperetr state to stderr, ie. registers
+\****************************************************************************/
+
+void ms_status(void);
+
+/****************************************************************************\
+* Function: ms_count
+*
+* Purpose: Returns the number of executed intructions
+*
+* Return:  Instruction count
+\****************************************************************************/
+
+type32 ms_count(void);
+
+#endif /* MAGNETIC_DEFS_H */
+
diff -Nur Generic/.svn/text-base/emu.c.svn-base Generic.garg/.svn/text-base/emu.c.svn-base
--- Generic/.svn/text-base/emu.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/emu.c.svn-base	2011-10-04 11:35:14.000000000 +0200
@@ -0,0 +1,4314 @@
+/****************************************************************************\
+*
+* Magnetic - Magnetic Scrolls Interpreter.
+*
+* Written by Niclas Karlsson <nkarlsso@abo.fi>,
+*            David Kinder <davidk.kinder@virgin.net>,
+*            Stefan Meier <Stefan.Meier@if-legends.org> and
+*            Paul David Doherty <pdd@if-legends.org>
+*
+* Copyright (C) 1997-2008  Niclas Karlsson
+*
+*     This program is free software; you can redistribute it and/or modify
+*     it under the terms of the GNU General Public License as published by
+*     the Free Software Foundation; either version 2 of the License, or
+*     (at your option) any later version.
+*
+*     This program is distributed in the hope that it will be useful,
+*     but WITHOUT ANY WARRANTY; without even the implied warranty of
+*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*     GNU General Public License for more details.
+*
+*     You should have received a copy of the GNU General Public License
+*     along with this program; if not, write to the Free Software
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+* History:
+*
+* 0.1  123096 : Making the 68000 emulation work. Converting C64 6510 code to
+*     -010297   C isn't all that much fun. Don't mention the word "BUG".
+*
+* 0.2  010397 : Debugging, debugging, debugging... Probably quite a lot left
+*               as well. Haven't tried it out in practice yet.
+*
+* 0.3  010497 : String decoding now works. Trying out on the real thing - more
+*               bugs, modest success. Implementing some very specialized
+*               instructions. 0xA0FF gives the word nightmare a whole new
+*               meaning.
+*
+* 0.4  010597 : Getting better... More specialized instructions coming up. The
+*               output routines are up and running as well. Occasional
+*               emulation bugs still show up due to my MS-style program
+*               developing techniques ;-) First playable version [The Pawn].
+*
+* 0.5  010697 : Trying out with Jinxter. Sigh... Back to reverse engineering
+*               (10+ new instructions, separate dictionary and two string
+*               banks - these guys sure had some space problems).
+*
+* 0.6  010997 : Guild of Thieves seems to work now as well. Jinxter still has
+*               a small problem with the parsing (I know of _one_ different
+*               reaction) - probably due to the not-so-nice dict_lookup2().
+*               Load/Save implemented.
+*
+* 0.7  011097 : The last (major) bug is now fixed (an 8-bit variable instead
+*               of a 16-bit one messed up the adjectives). Small cleanup.
+*
+* 0.8  011397 : Now also runs Fish and Corruption. Small status-bar fix.
+*
+* 0.9  011497 : New single-file format. Improved user friendliness.
+*
+* 0.91 011597 : More cleaning. Random number range fixed. Other minor bugfixes.
+*
+* 0.92 011897 : Major dict_lookup() overhaul. Minor cleanups. <= 64K memory
+*               blocks. Seems like the file format wasn't that great after all
+*               (most suitable for one big block).
+*
+* 0.93 012097 : New file format. Fast restarts (no loading). UNDO implemented.
+*               Subtle but fatal bug in Write_string() removed [Corruption].
+*
+* 0.94 012397 : Emulation bug (rotations) fixed. Prng slightly improved, or
+*               at least changed. :-) Admode $xx(PC,[A|D]x) implemented.
+*
+* 0.95 012597 : Another one bites the dust - bit operations with register
+*               source were broken. __MSDOS__ ifdef inserted (changes by
+*               David Kinder). Error reporting improved (initiative by
+*               Paul David Doherty).
+*
+* 0.96 012697 : No flag changes after MOVE xx,Ax (version>1) - Duhh...
+*
+* 0.97 020497 : Small output handling bug (0x7E-handling) for version>=3
+*
+* 0.98 040497 : Pain, agony... Another bit operation bug spotted and removed.
+*               A difference between version 0 and the rest (MOVEM.W) caused
+*               problems with Myth. Also, findproperties behaved badly with
+*               bit 14 set (version 3 only?). dict_lookup() didn't recognise
+*               composite words properly.
+*
+* 0.99 041697 : ADDQ/SUBQ xx,Ax doesn't set flags for (version>=3) [corruption]
+*               Small dict_lookup() fix (must be checked thoroughly once more).
+*               Difference between versions in findproperties caused problems
+*               with Jinxter. [light match/unicorn]. Integrated gfx-handling.
+*
+* 0.9A 050397 : = instead of == caused problems. Sign error in do_findprop()
+*               Stupid A0F1 quirk removed. SAVEMEM flag added.
+*
+* 0.9B 050997 : Small ms_showpic() modification.
+*
+* 0.9C 051297 : Fixes for running Magnetic Windows games.
+*
+* 0.9D 080297 : Minor improvements to save some memory. Bug fix: Last picture
+*               couldn't be extracted when SAVEMEM was set. Use time() to get
+*               initial random seed.
+*
+* 1.0  082897 : First public release.
+*
+* 2.0  081599 : [DK] Fixed Wonderland bug: ADDA and SUBA don't change
+*               the condition codes.
+*               [DK] Changed the A0EF line A opcode to do nothing, rather
+*               than exit the interpreter. This opcode is used by the
+*               PRINTER command available in some games.
+*
+* 2.0  082799 : [DK] Merged in Stefan Jokisch's MS-DOS changes.
+*             : [DK] Changed MS-DOS ifdefs to also depend on __BORLANDC__.
+*
+* 2.0  092699 : [DK] ADDA and SUBA always operate on the entire address
+*             : register, rather than using the opcode size.
+*
+* 2.0  101699 : [DK] Changed handling of string buffer to cope with
+*             : MS-DOS limitations.
+*
+* 2.0  102399 : [DK] Fixed spurious capitalization and leading white
+*               space problems.
+*
+* 2.0  102499 : [DK] Hopefully fixed problem in dict_lookup() with
+*               dictionary words ending with a space character.
+*
+* 2.0  102699 : [SM] Added code to line_a DF for displaying pictures
+*               in version 4 games. Also modified line_a E1 (readline)
+*               for additional security check to avoid false DF actions
+*
+* 2.0  102799 : [SM] Changed line_a DF for game locations where the
+*               picture request is not the first DF after keyboard input.
+*
+* 2.0  102999 : [SM] Another slight modification of DF for Collection games
+*               compatibility
+*
+* 2.0  103099 : [DK] Fixed "#undo" for version 4 games.
+*
+* 2.0  110299 : [SM] One more fix to DF code for image indexing
+*
+* 2.0  110799 : [DK] Disabled calls to ms_statuschar() for version 4 games.
+*               Disabled printing of spurious '@' characters to the status
+*               bar (Spectrum Pawn 2.3)
+*
+* 2.0  110999 : [DK] Added an extra allowed return code to ms_getchar()
+*               of 1, which means that the calling opcode should be
+*               terminated immediately. This is needed to prevent possible
+*               corruption of the game's memory in interpreters which
+*               allow a new game to be loaded without restarting
+*               (e.g. the Windows version).
+*
+* 2.0  112099 : [DK] Allowed all games to have a code segment greater than
+*               65536 bytes. This is needed for Acorn Jinxter 1.3 to run.
+*
+* 2.0  112199 : [NK] Fixed dictionary code for Guild of Thieves 1.3.
+*
+* 2.0  112199 : [PDD] Made whether or not a game has a separate dictionary
+*               independant of the version number.
+*
+* 2.0  121399 : [DK] Changed fix for spurious capitalization to apply to
+*               all game versions.
+*
+* 2.0  011500 : [DK] Added support for a new graphics format for the
+*               Magnetic Windows games.
+*
+* 2.0  012900 : [DK] Fixed a bug in ms_extract2 and tidied up ms_showpic
+*               and ms_extract.
+*
+* 2.0  020500 : [DK] For v4, ms_showpic() is only called if pic_index > 0.
+*
+* 2.0  021100 : [DK] Updated #define for MSDOS to include lfopen().
+*
+* 2.0  022700 : [DK] A0E3 appears to be used to turn windows on and off.
+*               If it is called with d1 == 0 then graphics are turned off.
+*               [DK] Fixed a problem with v4 graphics not showing after
+*               loading a new .mag file into the interpreter.
+*
+* 2.0  040900 : [DK] Completely changed the graphics format for v4 games.
+*
+* 2.0  041500 : [DK] ms_get_anim_frame() now returns a masking flag.
+*
+* 2.0  041700 : [SM] ms_get_anim_frame() now returns the frame mask. One bug
+*               removed that messed up the frame sequence.
+*
+* 2.0  042200 : [DK] More animation work.
+*
+* 2.0  050400 : [SM] Even more animation work.
+*
+* 2.0  050500 : [SM] Oh no, more animation work.
+*
+* 2.0  050700 : [DK] A little tidying up.
+*
+* 2.0  060300 : [DK] More tidying and adding type casts to prevent
+*               compiler warnings.
+*
+* 2.0  061800 : [DK] Merged in Stefan's latest animation changes.
+*
+* 2.0  070900 : [DK] Figured out what the final argument to the animation
+*               command 0x01 means, with the result that nearly all the
+*               animations in Wonderland play correctly.
+*
+* 2.0  072300 : [DK] Added an extra check to A0E3 to stop graphics being
+*               accidentally turned off in the Collection Vol. 1 games.
+*               Added animation command 0x00 (stop) for Corruption.
+*
+* 2.0  080600 : [SM] Minor change to A0DF code for preventing mysterious
+*               crash in MW-Fish!
+*
+* 2.0  081700 : [SM] Adjusted lower code offsets for A0DF, now the missing 
+*               Wonderland image comes up correctly.
+*
+* 2.0  081700 : [SM] Changed 03 animation command to act as "repeat comannd"
+*               with Collection games and "Stop" for Wonderland.
+*
+* 2.0  081700 : [SM] Changes to the 0x05 animation command for "outpal"
+*               picture.
+*
+* 2.0  082800 : [DK] Added ms_anim_is_repeating(), plus a few more minor
+*               corrections.
+*
+* 2.0  092300 : [DK] Added a workaround for problems with Wonderland's
+*               "catter" animation.
+*
+* 2.1  032002 : [SM] Added support for Magnetic Windows' online hints.
+*
+* 2.1  040202 : [SM] Added small A0DF workaround for non-supported functions.
+*
+* 2.1  042002 : [DK] Reset hint variables in ms_freemem().
+*
+* 2.2  020303 : [DK] Cleaned up hint code.
+*
+* 2.2  022303 : [DK] Added fallback hint support if ms_showhints() returns 0.
+*               [DK] Added argument to ms_getchar() to indicate if #undo
+*               should be translated.
+*
+* 2.2  022503 : [DK] Memory for hints is only allocated when needed.
+*
+* 2.2  031203 : [DK] Reduced the memory used for hints to about 45k, which
+*               seems to be small enough for MS-DOS.
+*
+* 2.3  080722 : [SM] Added support for Wonderland music scores. The scores 
+*               are identified by the accompanying picture name.
+*
+* 2.3  080723 : [SM] Added #sound control command to toggle sound support 
+*               on interpreter level
+*
+* 2.3  080725 : [SM] Added isSoundEnabled to check sound status on game level
+*
+* 2.3  080804 : [SM] line_A DF code completely rewritten. SoundEnabled,
+*               basetable and gfx_table removed 
+*
+* 2.3  080811 : [DK] Changed prototype for ms_sndextract and removed
+*               memory leaks.
+*
+* 2.3  080811 : [SM] line_A DF rewrite broke hints support. Fixed.
+*
+* 2.3  080812 : [DK] Changed prototype for ms_playmusic and removed the
+*               need for ms_sndextract as an externally visible function.
+*
+\****************************************************************************/
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <time.h>
+#include "defs.h"
+
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+
+#include <alloc.h>
+
+#define fread(p,s,n,f) lfread(p,s,n,f)
+#define fopen(f,m)     lfopen(f,m)
+#define malloc(s)      farmalloc(s)
+#define free(p)        farfree(p)
+
+extern long lfread(void far *, long, long, FILE far *);
+extern FILE far * lfopen(const char far *, const char far *);
+
+#endif
+
+type32 dreg[8], areg[8], i_count, string_size, rseed = 0, pc, arg1i, mem_size;
+type16 properties, fl_sub, fl_tab, fl_size, fp_tab, fp_size;
+type8 zflag, nflag, cflag, vflag, byte1, byte2, regnr, admode, opsize;
+type8 *arg1, *arg2, is_reversible, running = 0, tmparg[4] = {0, 0, 0, 0};
+type8 lastchar = 0, version = 0, sd = 0;
+type8 *decode_table, *restart = 0, *code = 0, *string = 0, *string2 = 0;
+type8 *string3 = 0, *dict = 0;
+type8 quick_flag = 0, gfx_ver = 0, *gfx_buf = 0, *gfx_data = 0;
+type8 *gfx2_hdr = 0, *gfx2_buf = 0;
+type8s *gfx2_name = 0;
+type16 gfx2_hsize = 0;
+FILE *gfx_fp = 0;
+type8 *snd_buf = 0, *snd_hdr = 0;
+type16 snd_hsize = 0;
+FILE *snd_fp = 0;
+
+const type8s undo_ok[] = "\n[Previous turn undone.]";
+const type8s undo_fail[] = "\n[You can't \"undo\" what hasn't been done!]";
+type32 undo_regs[2][18], undo_pc, undo_size;
+type8 *undo[2] = {0, 0}, undo_stat[2] = {0, 0};
+type16 gfxtable = 0, table_dist = 0;
+type16 v4_id = 0, next_table = 1;
+
+struct picture
+{
+	type8 * data;
+	type32 data_size;
+	type16 width;
+	type16 height;
+	type16 wbytes;
+	type16 plane_step;
+	type8 * mask;
+};
+
+#ifndef NO_ANIMATION
+
+struct lookup
+{
+	type16s flag;
+	type16s count;
+};
+
+#define MAX_POSITIONS 20
+#define MAX_ANIMS 200
+#define MAX_FRAMES 20
+
+struct picture anim_frame_table[MAX_ANIMS];
+type16 pos_table_size = 0;
+type16 pos_table_count[MAX_POSITIONS];
+struct ms_position pos_table[MAX_POSITIONS][MAX_ANIMS];
+type8 * command_table = 0;
+type16s command_index = -1;
+struct lookup anim_table[MAX_POSITIONS];
+type16s pos_table_index = -1;
+type16s pos_table_max = -1;
+struct ms_position pos_array[MAX_FRAMES];
+type8 anim_repeat = 0;
+
+#endif
+
+/* Hint support */
+#define MAX_HINTS 260
+#define MAX_HCONTENTS 30000
+struct ms_hint* hints = 0;
+type8* hint_contents = 0;
+const type8s no_hints[] = "[Hints are not available.]\n";
+const type8s not_supported[] = "[This function is not supported.]\n";
+
+#if defined(LOGEMU) || defined(LOGGFX) || defined(LOGHNT)
+FILE *dbg_log;
+#ifndef LOG_FILE
+#error LOG_FILE must be defined to be the name of the log file.
+#endif
+#endif
+
+/* prototypes */
+type32 read_reg(int, int);
+void write_reg(int, int, type32);
+
+#define MAX_STRING_SIZE  0xFF00
+#define MAX_PICTURE_SIZE 0xC800
+#define MAX_MUSIC_SIZE   0x4E20
+
+#ifdef LOGEMU
+void out(char *format,...)
+{
+	va_list a;
+
+	va_start(a, format);
+	vfprintf(dbg_log, format, a);
+	va_end(a);
+}
+#endif
+#if defined(LOGGFX) || defined(LOGHNT)
+void out2(char *format,...)
+{
+	va_list a;
+
+	va_start(a, format);
+	vfprintf(dbg_log, format, a);
+	va_end(a);
+	fflush(dbg_log);
+}
+#endif
+
+/* Convert virtual pointer to effective pointer */
+type8 *effective(type32 ptr)
+{
+	if ((version < 4) && (mem_size == 0x10000))
+		return &(code[ptr & 0xffff]);
+	if (ptr >= mem_size)
+	{
+		ms_fatal("Outside memory experience");
+		return code;
+	}
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+	return (type8 *) (((type8 huge *) code) + ptr);
+#else
+	return &(code[ptr]);
+#endif
+}
+
+type32 read_l(type8 * ptr)
+{
+	return (type32) ((type32) ptr[0] << 24 | (type32) ptr[1] << 16 | (type32) ptr[2] << 8 | (type32) ptr[3]);
+}
+
+type16 read_w(type8 * ptr)
+{
+	return (type16) (ptr[0] << 8 | ptr[1]);
+}
+
+void write_l(type8 * ptr, type32 val)
+{
+	ptr[3] = (type8) val;
+	val >>= 8;
+	ptr[2] = (type8) val;
+	val >>= 8;
+	ptr[1] = (type8) val;
+	val >>= 8;
+	ptr[0] = (type8) val;
+}
+
+void write_w(type8 * ptr, type16 val)
+{
+	ptr[1] = (type8) val;
+	val >>= 8;
+	ptr[0] = (type8) val;
+}
+
+type32 read_l2(type8 * ptr)
+{
+	return ((type32) ptr[1] << 24 | (type32) ptr[0] << 16 | (type32) ptr[3] << 8 | (type32) ptr[2]);
+}
+
+type16 read_w2(type8 * ptr)
+{
+	return (type16) (ptr[1] << 8 | ptr[0]);
+}
+
+/* Standard rand - for equal cross-platform behaviour */
+
+void ms_seed(type32 seed)
+{
+	rseed = seed;
+}
+
+type32 rand_emu(void)
+{
+	rseed = 1103515245L * rseed + 12345L;
+	return rseed & 0x7fffffffL;
+}
+
+void ms_freemem(void)
+{
+	if (code)
+		free(code);
+	if (string)
+		free(string);
+	if (string2)
+		free(string2);
+	if (string3)
+		free(string3);
+	if (dict)
+		free(dict);
+	if (undo[0])
+		free(undo[0]);
+	if (undo[1])
+		free(undo[1]);
+	if (restart)
+		free(restart);
+	code = string = string2 = string3 = dict = undo[0] = undo[1] = restart = 0;
+	if (gfx_data)
+		free(gfx_data);
+	if (gfx_buf)
+		free(gfx_buf);
+	if (gfx2_hdr)
+		free(gfx2_hdr);
+	if (gfx2_buf)
+		free(gfx2_buf);
+	if (gfx_fp)
+		fclose(gfx_fp);
+	gfx_data = gfx_buf = gfx2_hdr = gfx2_buf = 0;
+	gfx2_name = 0;
+	gfx_fp = 0;
+	gfx_ver = 0;
+	gfxtable = table_dist = 0;
+#ifndef NO_ANIMATION
+	pos_table_size = 0;
+	command_index = 0;
+	anim_repeat = 0;
+	pos_table_index = -1;
+	pos_table_max = -1;
+#endif
+	lastchar = 0;
+	if (hints)
+		free(hints);
+	if (hint_contents)
+		free(hint_contents);
+	hints = 0;
+	hint_contents = 0;
+	if (snd_hdr)
+		free(snd_hdr);
+	if (snd_buf)
+		free(snd_buf);
+	snd_hdr = 0;
+	snd_hsize = 0;
+	snd_buf = 0;
+}
+
+type8 ms_is_running(void)
+{
+	return running;
+}
+
+type8 ms_is_magwin(void)
+{
+	return (version == 4) ? 1 : 0;
+}
+
+void ms_stop(void)
+{
+	running = 0;
+}
+
+type8 init_gfx1(type8* header)
+{
+#ifdef SAVEMEM
+	type32 i;
+#endif
+
+	if (!(gfx_buf = malloc(MAX_PICTURE_SIZE)))
+	{
+		fclose(gfx_fp);
+		gfx_fp = 0;
+		return 1;
+	}
+#ifdef SAVEMEM
+	if (!(gfx_data = malloc(128)))
+	{
+#else
+	if (!(gfx_data = malloc(read_l(header + 4) - 8)))
+	{
+#endif
+		free(gfx_buf);
+		fclose(gfx_fp);
+		gfx_buf = 0;
+		gfx_fp = 0;
+		return 1;
+	}
+#ifdef SAVEMEM
+	if (!fread(gfx_data, 128, 1, gfx_fp))
+	{
+#else
+	if (!fread(gfx_data, read_l(header + 4) - 8, 1, gfx_fp))
+	{
+#endif
+		free(gfx_data);
+		free(gfx_buf);
+		fclose(gfx_fp);
+		gfx_data = gfx_buf = 0;
+		gfx_fp = 0;
+		return 1;
+	}
+
+#ifdef SAVEMEM
+	for (i = 0; i < 128; i += 4)
+		if (!read_l(gfx_data + i))
+			write_l(gfx_data + i, read_l(header + 4));
+#else
+	fclose(gfx_fp);
+	gfx_fp = 0;
+#endif
+
+	gfx_ver = 1;
+	return 2;
+}
+
+type8 init_gfx2(type8* header)
+{
+	if (!(gfx_buf = malloc(MAX_PICTURE_SIZE)))
+	{
+		fclose(gfx_fp);
+		gfx_fp = 0;
+		return 1;
+	}
+
+	gfx2_hsize = read_w(header + 4);
+	if (!(gfx2_hdr = malloc(gfx2_hsize)))
+	{
+		free(gfx_buf);
+		fclose(gfx_fp);
+		gfx_buf = 0;
+		gfx_fp = 0;
+		return 1;
+	}
+
+	fseek(gfx_fp, 6, SEEK_SET);
+	if (!fread(gfx2_hdr, gfx2_hsize, 1, gfx_fp))
+	{
+		free(gfx_buf);
+		free(gfx2_hdr);
+		fclose(gfx_fp);
+		gfx_buf = 0;
+		gfx2_hdr = 0;
+		gfx_fp = 0;
+		return 1;
+	}
+
+	gfx_ver = 2;
+	return 2;
+}
+
+type8 init_snd(type8* header)
+{
+	if (!(snd_buf = malloc(MAX_MUSIC_SIZE)))
+	{
+		fclose(snd_fp);
+		snd_fp = 0;
+		return 1;
+	}
+
+	snd_hsize = read_w(header + 4);
+	if (!(snd_hdr = malloc(snd_hsize)))
+	{
+		free(snd_buf);
+		fclose(snd_fp);
+		snd_buf = 0;
+		snd_fp = 0;
+		return 1;
+	}
+
+	fseek(snd_fp, 6, SEEK_SET);
+	if (!fread(snd_hdr, snd_hsize, 1, snd_fp))
+	{
+		free(snd_buf);
+		free(snd_hdr);
+		fclose(snd_fp);
+		snd_buf = 0;
+		snd_hdr = 0;
+		snd_fp = 0;
+		return 1;
+	}
+
+	return 2;
+}
+
+/* zero all registers and flags and load the game */
+
+type8 ms_init(type8s * name, type8s * gfxname, type8s * hntname, type8s * sndname)
+{
+	FILE *fp;
+	type8 header[42], header2[8],header3[4];
+	type32 i, dict_size, string2_size, code_size, dec;
+
+#if defined(LOGEMU) || defined(LOGGFX) || defined(LOGHNT)
+	dbg_log = fopen(LOG_FILE, "wt");
+#endif
+	ms_stop();
+	if (!name)
+	{
+		if (!restart)
+			return 0;
+		else
+		{
+			memcpy(code, restart, undo_size);
+			undo_stat[0] = undo_stat[1] = 0;
+			ms_showpic(0, 0);
+		}
+	}
+	else
+	{
+		undo_stat[0] = undo_stat[1] = 0;
+		ms_seed(time(0));
+		if (!(fp = fopen(name, "rb")))
+			return 0;
+		if ((fread(header, 1, 42, fp) != 42) || (read_l(header) != 0x4d615363))
+		{
+			fclose(fp);
+			return 0;
+		}
+		if (read_l(header + 8) != 42)
+		{
+			fclose(fp);
+			return 0;
+		}
+		ms_freemem();
+		version = header[13];
+		code_size = read_l(header + 14);
+		string_size = read_l(header + 18);
+		string2_size = read_l(header + 22);
+		dict_size = read_l(header + 26);
+		undo_size = read_l(header + 34);
+		undo_pc = read_l(header + 38);
+
+		if ((version < 4) && (code_size < 65536))
+			mem_size = 65536;
+		else
+			mem_size = code_size;
+
+		/* Some C libraries don't like malloc(0), so make
+		   sure that undo_size is always positive. */
+		if (undo_size == 0)
+			undo_size = 8;
+
+		sd = (type8)((dict_size != 0L) ? 1 : 0); /* if (sd) => separate dict */ 
+
+		if (!(code = malloc(mem_size)) || !(string2 = malloc(string2_size)) ||
+				!(restart = malloc(undo_size)) || (sd && 
+				!(dict = malloc(dict_size)))) 
+		{
+			ms_freemem();
+			fclose(fp);
+			return 0;
+		}
+		if (string_size > MAX_STRING_SIZE)
+		{
+			if (!(string = malloc(MAX_STRING_SIZE)) ||
+			    !(string3 = malloc(string_size - MAX_STRING_SIZE)))
+			{
+				ms_freemem();
+				fclose(fp);
+				return 0;
+			}
+		}
+		else
+		{
+			if (!(string = malloc(string_size)))
+			{
+				ms_freemem();
+				fclose(fp);
+				return 0;
+			}
+		}
+		if (!(undo[0] = malloc(undo_size)) || !(undo[1] = malloc(undo_size)))
+		{
+			ms_freemem();
+			fclose(fp);
+			return 0;
+		}
+		if (fread(code, 1, code_size, fp) != code_size)
+		{
+			ms_freemem();
+			fclose(fp);
+			return 0;
+		}
+		memcpy(restart, code, undo_size);	/* fast restarts */
+		if (string_size > MAX_STRING_SIZE)
+		{
+			if (fread(string, 1, MAX_STRING_SIZE, fp) != MAX_STRING_SIZE)
+			{
+				ms_freemem();
+				fclose(fp);
+				return 0;
+			}
+			if (fread(string3, 1, string_size - MAX_STRING_SIZE, fp) != string_size - MAX_STRING_SIZE)
+			{
+				ms_freemem();
+				fclose(fp);
+				return 0;
+			}
+		}
+		else
+		{
+			if (fread(string, 1, string_size, fp) != string_size)
+			{
+				ms_freemem();
+				fclose(fp);
+				return 0;
+			}
+		}
+		if (fread(string2, 1, string2_size, fp) != string2_size)
+		{
+			ms_freemem();
+			fclose(fp);
+			return 0;
+		}
+		if (sd && fread(dict, 1, dict_size, fp) != dict_size) 
+		{
+			ms_freemem();
+			fclose(fp);
+			return 0;
+		}
+		dec = read_l(header + 30);
+		if (dec >= string_size)
+			decode_table = string2 + dec - string_size;
+		else
+		{
+			if (dec >= MAX_STRING_SIZE)
+				decode_table = string3 + dec - MAX_STRING_SIZE;
+			else
+				decode_table = string + dec;
+		}
+		fclose(fp);
+	}
+
+	for (i = 0; i < 8; i++)
+		dreg[i] = areg[i] = 0;
+	write_reg(8 + 7, 2, 0xfffe);	/* Stack-pointer, -2 due to MS-DOS segments */
+	pc = 0;
+	zflag = nflag = cflag = vflag = 0;
+	i_count = 0;
+	running = 1;
+
+	if (!name)
+		return (type8) (gfx_buf ? 2 : 1);	/* Restarted */
+
+	if (version == 4)
+	{
+		/* Try loading a hint file */
+		FILE *hnt_fp;
+		if (hntname && (hnt_fp = fopen(hntname, "rb")))
+		{
+			if ((fread(&header3, 1, 4, hnt_fp) == 4) && (read_l(header3) == 0x4D614874))
+			{
+				type8 buf[8];
+				type16 i,j,blkcnt,elcnt,ntype,elsize,conidx;
+
+				/* Allocate memory for hints */
+				hints = malloc(MAX_HINTS * sizeof(struct ms_hint));
+				hint_contents = malloc(MAX_HCONTENTS);
+				if ((hints != 0) && (hint_contents != 0))
+				{
+					/* Read number of blocks */
+					if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+					blkcnt = read_w2(buf);
+#ifdef LOGHNT
+					out2("Blocks: %d\n",blkcnt);
+#endif
+					conidx = 0;
+					for (i = 0; i < blkcnt; i++)
+					{
+#ifdef LOGHNT
+						out2("\nBlock No. %d\n",i);
+#endif
+						/* Read number of elements */
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+						elcnt = read_w2(buf);
+#ifdef LOGHNT
+						out2("Elements: %d\n",elcnt);
+#endif
+						hints[i].elcount = elcnt;
+
+						/* Read node type */
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+						ntype = read_w2(buf);
+#ifdef LOGHNT
+						if (ntype == 1)
+							out2("Type: Node\n");
+						else
+							out2("Type: Leaf\n");
+#endif
+						hints[i].nodetype = ntype;
+						hints[i].content = hint_contents+conidx;
+#ifdef LOGHNT
+						out2("Elements:\n");
+#endif
+						for (j = 0; j < elcnt; j++)
+						{
+							if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+							elsize = read_w2(buf);
+							if (fread(hint_contents+conidx, 1, elsize, hnt_fp) != elsize && !feof(hnt_fp)) return 0;
+							hint_contents[conidx+elsize-1] = '\0';
+#ifdef LOGHNT
+							out2("%s\n",hint_contents+conidx);
+#endif
+							conidx += elsize;
+						}
+
+						/* Do we need a jump table? */
+						if (ntype == 1)
+						{
+#ifdef LOGHNT
+							out2("Jump to block:\n");
+#endif
+							for (j = 0; j < elcnt; j++)
+							{
+								if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+								hints[i].links[j] = read_w2(buf);
+#ifdef LOGHNT
+								out2("%d\n",hints[i].links[j]);
+#endif
+							}
+						}
+
+						/* Read the parent block */
+						if (fread(&buf, 1, 2, hnt_fp) != 2 && !feof(hnt_fp)) return 0;
+						hints[i].parent = read_w2(buf);
+#ifdef LOGHNT
+						out2("Parent: %d\n",hints[i].parent);
+#endif
+					}
+				}
+				else
+				{
+					if (hints)
+						free(hints);
+					if (hint_contents)
+						free(hint_contents);
+					hints = 0;
+					hint_contents = 0;
+				}
+			}
+			fclose(hnt_fp);
+		}
+
+		/* Try loading a music file */
+		if (sndname && (snd_fp = fopen(sndname, "rb")))
+		{
+			if (fread(&header2, 1, 8, snd_fp) != 8)
+			{
+				fclose(snd_fp);
+				snd_fp = 0;
+			}
+			else
+			{
+				if (read_l(header2) == 0x4D615364) /* MaSd */
+				{
+					init_snd(header2);
+#ifdef LOGSND
+					out2("Sound file loaded.\n");
+#endif
+				}
+			}
+		}
+	}
+
+	if (!gfxname || !(gfx_fp = fopen(gfxname, "rb")))
+		return 1;
+	if (fread(&header2, 1, 8, gfx_fp) != 8)
+	{
+		fclose(gfx_fp);
+		gfx_fp = 0;
+		return 1;
+	}
+
+	if (version < 4 && read_l(header2) == 0x4D615069) /* MaPi */
+		return init_gfx1(header2);
+	else if (version == 4 && read_l(header2) == 0x4D615032) /* MaP2 */
+		return init_gfx2(header2);
+	fclose(gfx_fp);
+	gfx_fp = 0;
+	return 1;
+}
+
+type8 is_blank(type16 line, type16 width)
+{
+	type32s i;
+
+	for (i = line * width; i < (line + 1) * width; i++)
+		if (gfx_buf[i])
+			return 0;
+	return 1;
+}
+
+type8 *ms_extract1(type8 pic, type16 * w, type16 * h, type16 * pal)
+{
+	type8 *decode_table, *data, bit, val, *buffer;
+	type16 tablesize, count;
+	type32 i, j, datasize, upsize, offset;
+
+	offset = read_l(gfx_data + 4 * pic);
+#ifdef SAVEMEM
+	if (fseek(gfx_fp, offset, SEEK_SET) < 0)
+		return 0;
+	datasize = read_l(gfx_data + 4 * (pic + 1)) - offset;
+	if (!(buffer = malloc(datasize)))
+		return 0;
+	if (fread(buffer, 1, datasize, gfx_fp) != datasize)
+		return 0;
+#else
+	buffer = gfx_data + offset - 8;
+#endif
+
+	for (i = 0; i < 16; i++)
+		pal[i] = read_w(buffer + 0x1c + 2 * i);
+	w[0] = (type16)(read_w(buffer + 4) - read_w(buffer + 2));
+	h[0] = read_w(buffer + 6);
+
+	tablesize = read_w(buffer + 0x3c);
+	datasize = read_l(buffer + 0x3e);
+	decode_table = buffer + 0x42;
+	data = decode_table + tablesize * 2 + 2;
+	upsize = h[0] * w[0];
+
+	for (i = 0, j = 0, count = 0, val = 0, bit = 7; i < upsize; i++, count--)
+	{
+		if (!count)
+		{
+			count = tablesize;
+			while (count < 0x80)
+			{
+				if (data[j] & (1 << bit))
+					count = decode_table[2 * count];
+				else
+					count = decode_table[2 * count + 1];
+				if (!bit)
+					j++;
+				bit = (type8)(bit ? bit - 1 : 7);
+			}
+			count &= 0x7f;
+			if (count >= 0x10)
+				count -= 0x10;
+			else
+			{
+				val = (type8)count;
+				count = 1;
+			}
+		}
+		gfx_buf[i] = val;
+	}
+	for (j = w[0]; j < upsize; j++)
+		gfx_buf[j] ^= gfx_buf[j - w[0]];
+
+#ifdef SAVEMEM
+	free(buffer);
+#endif
+	for (; h[0] > 0 && is_blank((type16)(h[0] - 1), w[0]); h[0]--);
+	for (i = 0; h[0] > 0 && is_blank((type16)i, w[0]); h[0]--, i++);
+	return gfx_buf + i * w[0];
+}
+
+type16s find_name_in_header(type8s * name, type8 upper)
+{
+	type16s header_pos = 0;
+	type8s pic_name[8];
+	type8 i;
+
+	for (i = 0; i < 8; i++)
+		pic_name[i] = 0;
+	strncpy(pic_name,name,6);
+	if (upper)
+	{
+		for (i = 0; i < 8; i++)
+			pic_name[i] = (type8s)toupper(pic_name[i]);
+	}
+
+	while (header_pos < gfx2_hsize)
+	{
+		type8s* hname = (type8s*)(gfx2_hdr + header_pos);
+		if (strncmp(hname,pic_name,6) == 0)
+			return header_pos;
+		header_pos += 16;
+	}
+	return -1;
+}
+
+void extract_frame(struct picture * pic)
+{
+	type32 i, x, y, bit_x, mask, ywb, yw, value, values[4];
+
+	if (pic->width * pic->height > MAX_PICTURE_SIZE)
+	{
+		ms_fatal("picture too large");
+		return;
+	}
+
+	for (y = 0; y < pic->height; y++)
+	{
+		ywb = y * pic->wbytes;
+		yw = y * pic->width;
+
+		for (x = 0; x < pic->width; x++)
+		{
+			if ((x % 8) == 0)
+			{
+				for (i = 0; i < 4; i++)
+					values[i] = pic->data[ywb + (x / 8) + (pic->plane_step * i)];
+			}
+
+			bit_x = 7 - (x & 7);
+			mask = 1 << bit_x;
+			value = ((values[0] & mask) >> bit_x) << 0|
+			        ((values[1] & mask) >> bit_x) << 1|
+			        ((values[2] & mask) >> bit_x) << 2|
+			        ((values[3] & mask) >> bit_x) << 3;
+			value &= 15;
+
+			gfx_buf[yw + x] = (type8)value;
+		}
+	}
+}
+
+type8 *ms_extract2(type8s * name, type16 * w, type16 * h, type16 * pal, type8 * is_anim)
+{
+	struct picture main_pic;
+	type32 offset = 0, length = 0, i;
+	type16s header_pos = -1;
+#ifndef NO_ANIMATION
+	type8* anim_data;
+	type32 j;
+#endif
+
+	if (is_anim != 0)
+		*is_anim = 0;
+	gfx2_name = name;
+
+#ifndef NO_ANIMATION
+	pos_table_size = 0;
+#endif
+
+#ifdef NO_ANIMATION
+	/* Find the uppercase (no animation) version of the picture first. */
+	header_pos = find_name_in_header(name,1);
+#endif
+	if (header_pos < 0)
+		header_pos = find_name_in_header(name,0);
+	if (header_pos < 0)
+		return 0;
+
+	offset = read_l(gfx2_hdr + header_pos + 8);
+	length = read_l(gfx2_hdr + header_pos + 12);
+
+	if (offset != 0)
+	{
+		if (gfx2_buf)
+		{
+			free(gfx2_buf);
+			gfx2_buf = 0;
+		}
+
+		gfx2_buf = malloc(length);
+		if (!gfx2_buf)
+			return 0;
+
+		if (fseek(gfx_fp, offset, SEEK_SET) < 0)
+		{
+			free(gfx2_buf);
+			gfx2_buf = 0;
+			return 0;
+		}
+
+		if (!fread(gfx2_buf, length, 1, gfx_fp))
+		{
+			free(gfx2_buf);
+			gfx2_buf = 0;
+			return 0;
+		}
+
+		for (i = 0; i < 16; i++)
+			pal[i] = read_w2(gfx2_buf + 4 + (2 * i));
+
+		main_pic.data = gfx2_buf + 48;
+		main_pic.data_size = read_l2(gfx2_buf + 38);
+		main_pic.width = read_w2(gfx2_buf + 42);
+		main_pic.height = read_w2(gfx2_buf + 44);
+		main_pic.wbytes = (type16)(main_pic.data_size / main_pic.height);
+		main_pic.plane_step = (type16)(main_pic.wbytes / 4);
+		main_pic.mask = (type8*)0;
+		extract_frame(&main_pic);
+
+		*w = main_pic.width;
+		*h = main_pic.height;
+
+#ifndef NO_ANIMATION
+		/* Check for an animation */
+		anim_data = gfx2_buf + 48 + main_pic.data_size;
+		if ((anim_data[0] != 0xD0) || (anim_data[1] != 0x5E))
+		{
+			type8 *current;
+			type16 frame_count, command_count;
+			type16 value1, value2;
+
+			if (is_anim != 0)
+				*is_anim = 1;
+
+			current = anim_data + 6;
+			frame_count = read_w2(anim_data + 2);
+			if (frame_count > MAX_ANIMS)
+			{
+				ms_fatal("animation frame array too short");
+				return 0;
+			}
+
+			/* Loop through each animation frame */
+			for (i = 0; i < frame_count; i++)
+			{
+				anim_frame_table[i].data = current + 10;
+				anim_frame_table[i].data_size = read_l2(current);
+				anim_frame_table[i].width = read_w2(current + 4);
+				anim_frame_table[i].height = read_w2(current + 6);
+				anim_frame_table[i].wbytes = (type16)(anim_frame_table[i].data_size / anim_frame_table[i].height);
+				anim_frame_table[i].plane_step = (type16)(anim_frame_table[i].wbytes / 4);
+				anim_frame_table[i].mask = (type8*)0;
+
+				current += anim_frame_table[i].data_size + 12;
+				value1 = read_w2(current - 2);
+				value2 = read_w2(current);
+
+				/* Get the mask */
+				if ((value1 == anim_frame_table[i].width) && (value2 == anim_frame_table[i].height))
+				{
+					type16 skip;
+
+					anim_frame_table[i].mask = (type8*)(current + 4);
+					skip = read_w2(current + 2);
+					current += skip + 6;
+				}
+			}
+
+			/* Get the positioning tables */
+			pos_table_size = read_w2(current - 2);
+			if (pos_table_size > MAX_POSITIONS)
+			{
+				ms_fatal("animation position array too short");
+				return 0;
+			}
+
+#ifdef LOGGFX_EXT
+			out2("POSITION TABLE DUMP\n");
+#endif
+			for (i = 0; i < pos_table_size; i++)
+			{
+				pos_table_count[i] = read_w2(current + 2);
+				current += 4;
+
+				if (pos_table_count[i] > MAX_ANIMS)
+				{
+					ms_fatal("animation position array too short");
+					return 0;
+				}
+
+				for (j = 0; j < pos_table_count[i]; j++)
+				{
+					pos_table[i][j].x = read_w2(current);
+					pos_table[i][j].y = read_w2(current + 2);
+					pos_table[i][j].number = read_w2(current + 4) - 1;
+					current += 8;
+#ifdef LOGGFX_EXT
+					out2("Position entry: Table: %d  Entry: %d  X: %d Y: %d Frame: %d\n",
+						i,j,pos_table[i][j].x,pos_table[i][j].y,pos_table[i][j].number);
+#endif
+				}
+			}
+
+			/* Get the command sequence table */
+			command_count = read_w2(current);
+			command_table = current + 2;
+
+			for (i = 0; i < MAX_POSITIONS; i++)
+			{
+				anim_table[i].flag = -1;
+				anim_table[i].count = -1;
+			}
+			command_index = 0;
+			anim_repeat = 0;
+			pos_table_index = -1;
+			pos_table_max = -1;
+		}
+#endif
+		return gfx_buf;
+	}
+	return 0;
+}
+
+type8 *ms_extract(type32 pic, type16 * w, type16 * h, type16 * pal, type8 * is_anim)
+{
+	if (is_anim)
+		*is_anim = 0;
+
+	if (gfx_buf)
+	{
+		switch (gfx_ver)
+		{
+		case 1:
+			return ms_extract1((type8)pic,w,h,pal);
+		case 2:
+			return ms_extract2((type8s*)(code + pic),w,h,pal,is_anim);
+		}
+	}
+	return 0;
+}
+
+type8 ms_animate(struct ms_position ** positions, type16 * count)
+{
+#ifndef NO_ANIMATION
+	type8 got_anim = 0;
+	type16 i, j, ttable;
+
+	if ((gfx_buf == 0) || (gfx2_buf == 0) || (gfx_ver != 2))
+		return 0;
+	if ((pos_table_size == 0) || (command_index < 0))
+		return 0;
+
+	*count = 0;
+	*positions = (struct ms_position*)0;
+
+	while (got_anim == 0)
+	{
+		if (pos_table_max >= 0)
+		{
+			if (pos_table_index < pos_table_max)
+			{
+				for (i = 0; i < pos_table_size; i++)
+				{
+					if (anim_table[i].flag > -1)
+					{
+						if (*count >= MAX_FRAMES)
+						{
+							ms_fatal("returned animation array too short");
+							return 0;
+						}
+
+						pos_array[*count] = pos_table[i][anim_table[i].flag];
+#ifdef LOGGFX_EXT
+						out2("Adding frame %d to buffer\n",pos_array[*count].number);
+#endif
+						(*count)++;
+
+						if (anim_table[i].flag < (pos_table_count[i]-1))
+							anim_table[i].flag++;
+						if (anim_table[i].count > 0)
+							anim_table[i].count--;
+						else
+							anim_table[i].flag = -1;
+					}
+				}
+				if (*count > 0)
+				{
+					*positions = pos_array;
+					got_anim = 1;
+				}
+				pos_table_index++;
+			}
+		}
+
+		if (got_anim == 0)
+		{
+			type8 command = command_table[command_index];
+			command_index++;
+
+			pos_table_max = -1;
+			pos_table_index = -1;
+
+			switch (command)
+			{
+			case 0x00:
+				command_index = -1;
+				return 0;
+			case 0x01:
+#ifdef LOGGFX_EXT
+				out2("Load Frame Table: %d  Start at: %d  Count: %d\n",
+					command_table[command_index],command_table[command_index+1],
+					command_table[command_index+2]);
+#endif
+				ttable = command_table[command_index];
+				command_index++;
+
+				if (ttable-1 >= MAX_POSITIONS)
+				{
+					ms_fatal("animation table too short");
+					return 0;
+				}
+
+				anim_table[ttable-1].flag = (type16s)(command_table[command_index]-1);
+				command_index++;
+				anim_table[ttable-1].count = (type16s)(command_table[command_index]-1);
+				command_index++;
+
+				/* Workaround for Wonderland "catter" animation */
+				if (v4_id == 0)
+				{
+					if (strcmp(gfx2_name,"catter") == 0)
+					{
+						if (command_index == 96)
+							anim_table[ttable-1].count = 9;
+						if (command_index == 108)
+							anim_table[ttable-1].flag = -1;
+						if (command_index == 156)
+							anim_table[ttable-1].flag = -1;
+					}
+				}
+				break;
+			case 0x02:
+#ifdef LOGGFX_EXT
+				out2("Animate: %d\n", command_table[command_index]);
+#endif
+				pos_table_max = command_table[command_index];
+				pos_table_index = 0;
+				command_index++;
+				break;
+			case 0x03:
+#ifdef LOGGFX_EXT
+				out2("Stop/Repeat Param: %d\n", command_table[command_index]);
+				command_index = -1;
+				return 0;
+#else
+				if (v4_id == 0)
+				{
+					command_index = -1;
+					return 0;
+				}
+				else
+				{
+					command_index = 0;
+					anim_repeat = 1;
+					pos_table_index = -1;
+					pos_table_max = -1;
+					for (j = 0; j < MAX_POSITIONS; j++)
+					{
+						anim_table[j].flag = -1;
+						anim_table[j].count = -1;
+					}
+				}
+				break;
+#endif
+			case 0x04:
+#ifdef LOGGFX_EXT
+				out2("Unknown Command: %d Prop1: %d  Prop2: %d WARNING:not parsed\n", command,
+					command_table[command_index],command_table[command_index+1]);
+#endif
+				command_index += 3;
+				return 0;
+			case 0x05:
+				ttable = next_table;
+				command_index++;
+
+				anim_table[ttable-1].flag = 0;
+				anim_table[ttable-1].count = command_table[command_index];
+
+				pos_table_max = command_table[command_index];
+				pos_table_index = 0;
+				command_index++;
+				command_index++;
+				next_table++;
+				break;
+			default:
+				ms_fatal("unknown animation command");
+				command_index = -1;
+				return 0;
+			}
+		}
+	}
+#ifdef LOGGFX_EXT
+	out2("ms_animate() returning %d frames\n",*count);
+#endif
+	return got_anim;
+#else
+	return 0;
+#endif
+}
+
+type8 * ms_get_anim_frame(type16s number, type16 * width, type16 * height, type8 ** mask)
+{
+#ifndef NO_ANIMATION
+	if (number >= 0)
+	{
+		extract_frame(anim_frame_table + number);
+		*width = anim_frame_table[number].width;
+		*height = anim_frame_table[number].height;
+		*mask = anim_frame_table[number].mask;
+		return gfx_buf;
+	}
+#endif
+	return 0;
+}
+
+type8 ms_anim_is_repeating(void)
+{
+#ifndef NO_ANIMATION
+	return anim_repeat;
+#else
+	return 0;
+#endif
+}
+
+type16s find_name_in_sndheader(type8s * name)
+{
+	type16s header_pos = 0;
+
+	while (header_pos < snd_hsize)
+	{
+		type8s* hname = (type8s*)(snd_hdr + header_pos);
+		if (strcmp(hname,name) == 0)
+			return header_pos;
+		header_pos += 18;
+	}
+	return -1;
+}
+
+type8 *sound_extract(type8s * name, type32 * length, type16 * tempo)
+{
+	type32 offset = 0;
+	type16s header_pos = -1;
+
+	if (header_pos < 0)
+		header_pos = find_name_in_sndheader(name);
+	if (header_pos < 0)
+		return 0;
+
+	*tempo = read_w(snd_hdr + header_pos + 8);
+	offset = read_l(snd_hdr + header_pos + 10);
+	*length = read_l(snd_hdr + header_pos + 14);
+
+	if (offset != 0)
+	{
+		if (!snd_buf)
+			return 0;
+		if (fseek(snd_fp, offset, SEEK_SET) < 0)
+			return 0;
+		if (!fread(snd_buf, (int)(*length), 1, snd_fp))
+			return 0;
+		return snd_buf;
+	}
+	return 0;
+}
+
+void save_undo(void)
+{
+	type8 *tmp, i;
+	type32 tmp32;
+
+	tmp = undo[0];	/* swap buffers */
+	undo[0] = undo[1];
+	undo[1] = tmp;
+
+	for (i = 0; i < 18; i++)
+	{
+		tmp32 = undo_regs[0][i];
+		undo_regs[0][i] = undo_regs[1][i];
+		undo_regs[1][i] = tmp32;
+	}
+
+	memcpy(undo[1], code, undo_size);
+	for (i = 0; i < 8; i++)
+	{
+		undo_regs[1][i] = dreg[i];
+		undo_regs[1][8 + i] = areg[i];
+	}
+	undo_regs[1][16] = i_count;
+	undo_regs[1][17] = pc;	/* status flags intentionally omitted */
+
+	undo_stat[0] = undo_stat[1];
+	undo_stat[1] = 1;
+}
+
+type8 ms_undo(void)
+{
+	type8 i;
+
+	ms_flush();
+	if (!undo_stat[0])
+		return 0;
+
+	undo_stat[0] = undo_stat[1] = 0;
+	memcpy(code, undo[0], undo_size);
+	for (i = 0; i < 8; i++)
+	{
+		dreg[i] = undo_regs[0][i];
+		areg[i] = undo_regs[0][8 + i];
+	}
+	i_count = undo_regs[0][16];
+	pc = undo_regs[0][17];	/* status flags intentionally omitted */
+	return 1;
+}
+
+#ifdef LOGEMU
+void log_status(void)
+{
+	int j;
+
+	fprintf(dbg_log, "\nD0:");
+	for (j = 0; j < 8; j++)
+		fprintf(dbg_log, " %8.8x", read_reg(j, 3));
+	fprintf(dbg_log, "\nA0:");
+	for (j = 0; j < 8; j++)
+		fprintf(dbg_log, " %8.8x", read_reg(8 + j, 3));
+	fprintf(dbg_log, "\nPC=%5.5x (%8.8x) ZCNV=%d%d%d%d - %d instructions\n\n",
+		pc, code, zflag & 1, cflag & 1, nflag & 1, vflag & 1, i_count);
+}
+#endif
+
+void ms_status(void)
+{
+	int j;
+
+	fprintf(stderr, "D0:");
+	for (j = 0; j < 8; j++)
+		fprintf(stderr, " %8.8lx", (long) read_reg(j, 3));
+	fprintf(stderr, "\nA0:");
+	for (j = 0; j < 8; j++)
+		fprintf(stderr, " %8.8lx", (long) read_reg(8 + j, 3));
+	fprintf(stderr, "\nPC=%5.5lx ZCNV=%d%d%d%d - %ld instructions\n",
+		(long) pc, zflag & 1, cflag & 1, nflag & 1, vflag & 1, (long) i_count);
+}
+
+type32 ms_count(void)
+{
+	return i_count;
+}
+
+/* align register pointer for word/byte accesses */
+
+type8 *reg_align(type8 * ptr, type8 size)
+{
+	if (size == 1)
+		ptr += 2;
+	if (size == 0)
+		ptr += 3;
+	return ptr;
+}
+
+type32 read_reg(int i, int s)
+{
+	type8 *ptr;
+
+	if (i > 15)
+	{
+		ms_fatal("invalid register in read_reg");
+		return 0;
+	}
+	if (i < 8)
+		ptr = (type8 *) & dreg[i];
+	else
+		ptr = (type8 *) & areg[i - 8];
+
+	switch (s)
+	{
+	case 0:
+		return reg_align(ptr, 0)[0];
+	case 1:
+		return read_w(reg_align(ptr, 1));
+	default:
+		return read_l(ptr);
+	}
+}
+
+void write_reg(int i, int s, type32 val)
+{
+	type8 *ptr;
+
+	if (i > 15)
+	{
+		ms_fatal("invalid register in write_reg");
+		return;
+	}
+	if (i < 8)
+		ptr = (type8 *) & dreg[i];
+	else
+		ptr = (type8 *) & areg[i - 8];
+
+	switch (s)
+	{
+	case 0:
+		reg_align(ptr, 0)[0] = (type8)val;
+		break;
+	case 1:
+		write_w(reg_align(ptr, 1), (type16)val);
+		break;
+	default:
+		write_l(ptr, val);
+		break;
+	}
+}
+
+/* [35c4] */
+
+void char_out(type8 c)
+{
+	static type8 big = 0, period = 0, pipe = 0;
+
+	if (c == 0xff)
+	{
+		big = 1;
+		return;
+	}
+	c &= 0x7f;
+	if (read_reg(3, 0))
+	{
+		if (c == 0x5f || c == 0x40)
+			c = 0x20;
+		if ((c >= 'a') && (c <= 'z'))
+			c &= 0xdf;
+		if (version < 4)
+			ms_statuschar(c);
+		return;
+	}
+	if (c == 0x5e)
+		c = 0x0a;
+	if (c == 0x40)
+	{
+		if (read_reg(2, 0))
+			return;
+		else
+			c = 0x73;
+	}
+	if (version < 3 && c == 0x7e)
+	{
+		lastchar = 0x7e;
+		c = 0x0a;
+	}
+	if (((c > 0x40) && (c < 0x5b)) || ((c > 0x60) && (c < 0x7b)))
+	{
+		if (big)
+		{
+			c &= 0xdf;
+			big = 0;
+		}
+		if (period)
+			char_out(0x20);
+	}
+	period = 0;
+	if (version < 4)
+	{
+		if ((c == 0x2e) || (c == 0x3f) || (c == 0x21) || (c == 0x0a))
+			big = 1;
+		else if (c == 0x22)
+			big = 0;
+	}
+	else
+	{
+		if ((c == 0x20) && (lastchar == 0x0a))
+			return;
+		if ((c == 0x2e) || (c == 0x3f) || (c == 0x21) || (c == 0x0a))
+			big = 1;
+		else if (c == 0x22)
+			big = 0;
+	}
+	if (((c == 0x20) || (c == 0x0a)) && (c == lastchar))
+		return;
+	if (version < 3)
+	{
+		if (pipe)
+		{
+			pipe = 0;
+			return;
+		}
+		if (c == 0x7c)
+		{
+			pipe = 1;
+			return;
+		}
+	}
+	else
+	{
+		if (c == 0x7e)
+		{
+			c = 0x0a;
+			if (lastchar != 0x0a)
+				char_out(0x0a);
+		}
+	}
+	lastchar = c;
+	if (c == 0x5f)
+		c = 0x20;
+	if ((c == 0x2e) || (c == 0x2c) || (c == 0x3b) || (c == 0x3a) || (c == 0x21) || (c == 0x3f))
+		period = 1;
+	ms_putchar(c);
+}
+
+
+/* extract addressing mode information [1c6f] */
+
+void set_info(type8 b)
+{
+	regnr = (type8)(b & 0x07);
+	admode = (type8)((b >> 3) & 0x07);
+	opsize = (type8)(b >> 6);
+}
+
+/* read a word and increase pc */
+
+void read_word(void)
+{
+	type8 *epc;
+
+	epc = effective(pc);
+	byte1 = epc[0];
+	byte2 = epc[1];
+	pc += 2;
+}
+
+/* get addressing mode and set arg1 [1c84] */
+
+void set_arg1(void)
+{
+	type8 tmp[2], l1c;
+
+	is_reversible = 1;
+	switch (admode)
+	{
+	case 0:
+		arg1 = reg_align((type8 *) & dreg[regnr], opsize);	/* Dx */
+		is_reversible = 0;
+#ifdef LOGEMU
+		out(" d%.1d", regnr);
+#endif
+		break;
+	case 1:
+		arg1 = reg_align((type8 *) & areg[regnr], opsize);	/* Ax */
+		is_reversible = 0;
+#ifdef LOGEMU
+		out(" a%.1d", regnr);
+#endif
+		break;
+	case 2:
+		arg1i = read_reg(8 + regnr, 2);		/* (Ax) */
+#ifdef LOGEMU
+		out(" (a%.1d)", regnr);
+#endif
+		break;
+	case 3:
+		arg1i = read_reg(8 + regnr, 2);		/* (Ax)+ */
+		write_reg(8 + regnr, 2, read_reg(8 + regnr, 2) + (1 << opsize));
+#ifdef LOGEMU
+		out(" (a%.1d)+", regnr);
+#endif
+		break;
+	case 4:
+		write_reg(8 + regnr, 2, read_reg(8 + regnr, 2) - (1 << opsize));
+		arg1i = read_reg(8 + regnr, 2);		/* -(Ax) */
+#ifdef LOGEMU
+		out(" -(a%.1d)", regnr);
+#endif
+		break;
+	case 5:
+		{
+			type16s i = (type16s) read_w(effective(pc));
+			arg1i = read_reg(8 + regnr, 2) + i;
+			pc += 2;	/* offset.w(Ax) */
+#ifdef LOGEMU
+			out(" %X(a%.1d)", i, regnr);
+#endif
+		}
+		break;
+	case 6:
+		tmp[0] = byte1;
+		tmp[1] = byte2;
+		read_word();	/* offset.b(Ax, Dx/Ax) [1d1c] */
+#ifdef LOGEMU
+		out(" %.2X(a%.1d,", (int) byte2, regnr);
+#endif
+		arg1i = read_reg(regnr + 8, 2) + (type8s) byte2;
+#ifdef LOGEMU
+		if ((byte1 >> 4) > 8)
+			out("a%.1d", (byte1 >> 4) - 8);
+		else
+			out("d%.1d", byte1 >> 4);
+#endif
+		if (byte1 & 0x08)
+		{
+#ifdef LOGEMU
+			out(".l)");
+#endif
+			arg1i += (type32s) read_reg((byte1 >> 4), 2);
+		}
+		else
+		{
+#ifdef LOGEMU
+			out(".w)");
+#endif
+			arg1i += (type16s) read_reg((byte1 >> 4), 1);
+		}
+		byte1 = tmp[0];
+		byte2 = tmp[1];
+		break;
+	case 7:		/* specials */
+		switch (regnr)
+		{
+		case 0:
+			arg1i = read_w(effective(pc));	/* $xxxx.W */
+			pc += 2;
+#ifdef LOGEMU
+			out(" %.4X.w", arg1i);
+#endif
+			break;
+		case 1:
+			arg1i = read_l(effective(pc));	/* $xxxx */
+			pc += 4;
+#ifdef LOGEMU
+			out(" %.4X", arg1i);
+#endif
+			break;
+		case 2:
+			arg1i = (type16s) read_w(effective(pc)) + pc;	/* $xxxx(PC) */
+			pc += 2;
+#ifdef LOGEMU
+			out(" %.4X(pc)", arg1i);
+#endif
+			break;
+		case 3:
+			l1c = effective(pc)[0];		/* $xx(PC,A/Dx) */
+#ifdef LOGEMU
+			out(" ???2", arg1i);
+#endif
+			if (l1c & 0x08)
+				arg1i = pc + (type32s) read_reg((l1c >> 4), 2);
+			else
+				arg1i = pc + (type16s) read_reg((l1c >> 4), 1);
+			l1c = effective(pc)[1];
+			pc += 2;
+			arg1i += (type8s) l1c;
+			break;
+		case 4:
+			arg1i = pc;	/* #$xxxx */
+			if (opsize == 0)
+				arg1i += 1;
+			pc += 2;
+			if (opsize == 2)
+				pc += 2;
+#ifdef LOGEMU
+			out(" #%.4X", arg1i);
+#endif
+			break;
+		}
+		break;
+	}
+	if (is_reversible)
+		arg1 = effective(arg1i);
+}
+
+/* get addressing mode and set arg2 [1bc5] */
+
+void set_arg2_nosize(int use_dx, type8 b)
+{
+	if (use_dx)
+		arg2 = (type8 *) dreg;
+	else
+		arg2 = (type8 *) areg;
+	arg2 += (b & 0x0e) << 1;
+}
+
+void set_arg2(int use_dx, type8 b)
+{
+	set_arg2_nosize(use_dx, b);
+	arg2 = reg_align(arg2, opsize);
+}
+
+/* [1b9e] */
+
+void swap_args(void)
+{
+	type8 *tmp;
+
+	tmp = arg1;
+	arg1 = arg2;
+	arg2 = tmp;
+}
+
+/* [1cdc] */
+
+void push(type32 c)
+{
+	write_reg(15, 2, read_reg(15, 2) - 4);
+	write_l(effective(read_reg(15, 2)), c);
+}
+
+/* [1cd1] */
+
+type32 pop(void)
+{
+	type32 c;
+
+	c = read_l(effective(read_reg(15, 2)));
+	write_reg(15, 2, read_reg(15, 2) + 4);
+	return c;
+}
+
+/* check addressing mode and get argument [2e85] */
+
+void get_arg(void)
+{
+#ifdef LOGEMU
+	out(" %.4X", pc);
+#endif
+	set_info(byte2);
+	arg2 = effective(pc);
+	pc += 2;
+	if (opsize == 2)
+		pc += 2;
+	if (opsize == 0)
+		arg2 += 1;
+	set_arg1();
+}
+
+void set_flags(void)
+{
+	type16 i;
+	type32 j;
+
+	zflag = nflag = 0;
+	switch (opsize)
+	{
+	case 0:
+		if (arg1[0] > 127)
+			nflag = 0xff;
+		if (arg1[0] == 0)
+			zflag = 0xff;
+		break;
+	case 1:
+		i = read_w(arg1);
+		if (i == 0)
+			zflag = 0xff;
+		if ((i >> 15) > 0)
+			nflag = 0xff;
+		break;
+	case 2:
+		j = read_l(arg1);
+		if (j == 0)
+			zflag = 0xff;
+		if ((j >> 31) > 0)
+			nflag = 0xff;
+		break;
+	}
+}
+
+/* [263a] */
+
+int condition(type8 b)
+{
+	switch (b & 0x0f)
+	{
+	case 0:
+		return 0xff;
+	case 1:
+		return 0x00;
+	case 2:
+		return (zflag | cflag) ^ 0xff;
+	case 3:
+		return (zflag | cflag);
+	case 4:
+		return cflag ^ 0xff;
+	case 5:
+		return cflag;
+	case 6:
+		return zflag ^ 0xff;
+	case 7:
+		return zflag;
+	case 8:
+		return vflag ^ 0xff;
+	case 9:
+		return vflag;
+	case 10:
+	case 12:
+		return nflag ^ 0xff;
+	case 11:
+	case 13:
+		return nflag;
+	case 14:
+		return (zflag | nflag) ^ 0xff;
+	case 15:
+		return (zflag | nflag);
+	}
+	return 0x00;
+}
+
+/* [26dc] */
+
+void branch(type8 b)
+{
+	if (b == 0)
+		pc += (type16s) read_w(effective(pc));
+	else
+		pc += (type8s) b;
+#ifdef LOGEMU
+	out(" %.4X", pc);
+#endif
+}
+
+/* [2869] */
+
+void do_add(type8 adda)
+{
+	if (adda)
+	{
+		if (opsize == 0)
+			write_l(arg1, read_l(arg1) + (type8s) arg2[0]);
+		if (opsize == 1)
+			write_l(arg1, read_l(arg1) + (type16s) read_w(arg2));
+		if (opsize == 2)
+			write_l(arg1, read_l(arg1) + (type32s) read_l(arg2));
+	}
+	else
+	{
+		cflag = 0;
+		if (opsize == 0)
+		{
+			arg1[0] += arg2[0];
+			if (arg2[0] > arg1[0])
+				cflag = 0xff;
+		}
+		if (opsize == 1)
+		{
+			write_w(arg1, (type16)(read_w(arg1) + read_w(arg2)));
+			if (read_w(arg2) > read_w(arg1))
+				cflag = 0xff;
+		}
+		if (opsize == 2)
+		{
+			write_l(arg1, read_l(arg1) + read_l(arg2));
+			if (read_l(arg2) > read_l(arg1))
+				cflag = 0xff;
+		}
+		if (version < 3 || !quick_flag)
+		{
+			/* Corruption onwards */
+			vflag = 0;
+			set_flags();
+		}
+	}
+}
+
+/* [2923] */
+
+void do_sub(type8 suba)
+{
+	if (suba)
+	{
+		if (opsize == 0)
+			write_l(arg1, read_l(arg1) - (type8s) arg2[0]);
+		if (opsize == 1)
+			write_l(arg1, read_l(arg1) - (type16s) read_w(arg2));
+		if (opsize == 2)
+			write_l(arg1, read_l(arg1) - (type32s) read_l(arg2));
+	}
+	else
+	{
+		cflag = 0;
+		if (opsize == 0)
+		{
+			if (arg2[0] > arg1[0])
+				cflag = 0xff;
+			arg1[0] -= arg2[0];
+		}
+		if (opsize == 1)
+		{
+			if (read_w(arg2) > read_w(arg1))
+				cflag = 0xff;
+			write_w(arg1, (type16)(read_w(arg1) - read_w(arg2)));
+		}
+		if (opsize == 2)
+		{
+			if (read_l(arg2) > read_l(arg1))
+				cflag = 0xff;
+			write_l(arg1, read_l(arg1) - read_l(arg2));
+		}
+		if (version < 3 || !quick_flag)
+		{
+			/* Corruption onwards */
+			vflag = 0;
+			set_flags();
+		}
+	}
+}
+
+/* [283b] */
+
+void do_eor(void)
+{
+	if (opsize == 0)
+		arg1[0] ^= arg2[0];
+	if (opsize == 1)
+		write_w(arg1, (type16)(read_w(arg1) ^ read_w(arg2)));
+	if (opsize == 2)
+		write_l(arg1, read_l(arg1) ^ read_l(arg2));
+	cflag = vflag = 0;
+	set_flags();
+}
+
+/* [280d] */
+
+void do_and(void)
+{
+	if (opsize == 0)
+		arg1[0] &= arg2[0];
+	if (opsize == 1)
+		write_w(arg1, (type16)(read_w(arg1) & read_w(arg2)));
+	if (opsize == 2)
+		write_l(arg1, read_l(arg1) & read_l(arg2));
+	cflag = vflag = 0;
+	set_flags();
+}
+
+/* [27df] */
+
+void do_or(void)
+{
+	if (opsize == 0)
+		arg1[0] |= arg2[0];
+	if (opsize == 1)
+		write_w(arg1, (type16)(read_w(arg1) | read_w(arg2)));
+	if (opsize == 2)
+		write_l(arg1, read_l(arg1) | read_l(arg2));
+	cflag = vflag = 0;
+	set_flags();	/* [1c2b] */
+}
+
+/* [289f] */
+
+void do_cmp(void)
+{
+	type8 *tmp;
+
+	tmp = arg1;
+	tmparg[0] = arg1[0];
+	tmparg[1] = arg1[1];
+	tmparg[2] = arg1[2];
+	tmparg[3] = arg1[3];
+	arg1 = tmparg;
+	quick_flag = 0;
+	do_sub(0);
+	arg1 = tmp;
+}
+
+/* [2973] */
+
+void do_move(void)
+{
+
+	if (opsize == 0)
+		arg1[0] = arg2[0];
+	if (opsize == 1)
+		write_w(arg1, read_w(arg2));
+	if (opsize == 2)
+		write_l(arg1, read_l(arg2));
+	if (version < 2 || admode != 1)
+	{
+		/* Jinxter: no flags if destination Ax */
+		cflag = vflag = 0;
+		set_flags();
+	}
+}
+
+type8 do_btst(type8 a)
+{
+	a &= admode ? 0x7 : 0x1f;
+	while (admode == 0 && a >= 8)
+	{
+		a -= 8;
+		arg1 -= 1;
+	}
+	zflag = 0;
+	if ((arg1[0] & (1 << a)) == 0)
+		zflag = 0xff;
+	return a;
+}
+
+/* bit operation entry point [307c] */
+
+void do_bop(type8 b, type8 a)
+{
+#ifdef LOGEMU
+	out("bop (%.2x,%.2x) ", (int) b, (int) a);
+#endif
+	b = b & 0xc0;
+	a = do_btst(a);
+#ifdef LOGEMU
+	if (b == 0x00)
+		out("no bop???");
+#endif
+	if (b == 0x40)
+	{
+		arg1[0] ^= (1 << a);	/* bchg */
+#ifdef LOGEMU
+		out("bchg");
+#endif
+	}
+	if (b == 0x80)
+	{
+		arg1[0] &= ((1 << a) ^ 0xff);	/* bclr */
+#ifdef LOGEMU
+		out("bclr");
+#endif
+	}
+	if (b == 0xc0)
+	{
+		arg1[0] |= (1 << a);	/* bset */
+#ifdef LOGEMU
+		out("bset");
+#endif
+	}
+}
+
+void check_btst(void)
+{
+#ifdef LOGEMU
+	out("btst");
+#endif
+	set_info((type8)(byte2 & 0x3f));
+	set_arg1();
+	set_arg2(1, byte1);
+	do_bop(byte2, arg2[0]);
+}
+
+void check_lea(void)
+{
+#ifdef LOGEMU
+	out("lea");
+#endif
+	if ((byte2 & 0xc0) == 0xc0)
+	{
+		set_info(byte2);
+		opsize = 2;
+		set_arg1();
+		set_arg2(0, byte1);
+		write_w(arg2, 0);
+		if (is_reversible)
+			write_l(arg2, arg1i);
+		else
+			ms_fatal("illegal addressing mode for LEA");
+	}
+	else
+	{
+		ms_fatal("unimplemented instruction CHK");
+	}
+}
+
+/* [33cc] */
+
+void check_movem(void)
+{
+	type8 l1c;
+
+#ifdef LOGEMU
+	out("movem");
+#endif
+	set_info((type8)(byte2 - 0x40));
+	read_word();
+	for (l1c = 0; l1c < 8; l1c++)
+	{
+		if (byte2 & 1 << l1c)
+		{
+			set_arg1();
+			if (opsize == 2)
+				write_l(arg1, read_reg(15 - l1c, 2));
+			if (opsize == 1)
+				write_w(arg1, (type16)read_reg(15 - l1c, 1));
+		}
+	}
+	for (l1c = 0; l1c < 8; l1c++)
+	{
+		if (byte1 & 1 << l1c)
+		{
+			set_arg1();
+			if (opsize == 2)
+				write_l(arg1, read_reg(7 - l1c, 2));
+			if (opsize == 1)
+				write_w(arg1, (type16)read_reg(7 - l1c, 1));
+		}
+	}
+}
+
+/* [3357] */
+
+void check_movem2(void)
+{
+	type8 l1c;
+
+#ifdef LOGEMU
+	out("movem (2)");
+#endif
+	set_info((type8)(byte2 - 0x40));
+	read_word();
+	for (l1c = 0; l1c < 8; l1c++)
+	{
+		if (byte2 & 1 << l1c)
+		{
+			set_arg1();
+			if (opsize == 2)
+				write_reg(l1c, 2, read_l(arg1));
+			if (opsize == 1)
+				write_reg(l1c, 1, read_w(arg1));
+		}
+	}
+	for (l1c = 0; l1c < 8; l1c++)
+	{
+		if (byte1 & 1 << l1c)
+		{
+			set_arg1();
+			if (opsize == 2)
+				write_reg(8 + l1c, 2, read_l(arg1));
+			if (opsize == 1)
+				write_reg(8 + l1c, 1, read_w(arg1));
+		}
+	}
+}
+
+/* [30e4] in Jinxter, ~540 lines of 6510 spaghetti-code */
+/* The mother of all bugs, but hey - no gotos used :-) */
+
+void dict_lookup(void)
+{
+	type16 dtab, doff, output, output_bak, bank, word, output2;
+	type16 tmp16, i, obj_adj, adjlist, adjlist_bak;
+	type8 c, c2, c3, flag, matchlen, longest, flag2;
+	type8 restart = 0, accept = 0;
+
+/*
+   dtab=A5.W                    ;dict_table offset <L22>
+   output=output_bak=A2.W       ;output <L24>
+   A5.W=A6.W                    ;input word
+   doff=A3.W                    ;lookup offset (doff) <L1C>
+   adjlist=A0.W ;adjlist <L1E>
+ */
+
+	dtab = (type16)read_reg(8 + 5, 1);	/* used by version>0 */
+	output = (type16)read_reg(8 + 2, 1);
+	write_reg(8 + 5, 1, read_reg(8 + 6, 1));
+	doff = (type16)read_reg(8 + 3, 1);
+	adjlist = (type16)read_reg(8 + 0, 1);
+
+	bank = (type16)read_reg(6, 0);	/* l2d */
+	flag = 0;		/* l2c */
+	word = 0;		/* l26 */
+	matchlen = 0;		/* l2e */
+	longest = 0;		/* 30e2 */
+	write_reg(0, 1, 0);	/* apostroph */
+
+	while ((c = sd ? dict[doff] : effective(doff)[0]) != 0x81)
+	{
+		if (c >= 0x80)
+		{
+			if (c == 0x82)
+			{
+				flag = matchlen = 0;
+				word = 0;
+				write_reg(8 + 6, 1, read_reg(8 + 5, 1));
+				bank++;
+				doff++;
+				continue;
+			}
+			c3 = c;
+			c &= 0x5f;
+			c2 = effective(read_reg(8 + 6, 1))[0] & 0x5f;
+			if (c2 == c)
+			{
+				write_reg(8 + 6, 1, read_reg(8 + 6, 1) + 1);
+				c = effective(read_reg(8 + 6, 1))[0];
+				if ((!c) || (c == 0x20) || (c == 0x27) || (!version && (matchlen > 6)))
+				{
+					if (c == 0x27)
+					{
+						write_reg(8 + 6, 1, read_reg(8 + 6, 1) + 1);
+						write_reg(0, 1, 0x200 + effective(read_reg(8 + 6, 1))[0]);
+					}
+					if ((version < 4) || (c3 != 0xa0))
+						accept = 1;
+				}
+				else
+					restart = 1;
+			}
+			else if (!version && matchlen > 6 && !c2)
+				accept = 1;
+			else
+				restart = 1;
+		}
+		else
+		{
+			c &= 0x5f;
+			c2 = effective(read_reg(8 + 6, 1))[0] & 0x5f;
+			if ((c2 == c && c) || (version && !c2 && (c == 0x5f)))
+			{
+				if (version && !c2 && (c == 0x5f))
+					flag = 0x80;
+				matchlen++;
+				write_reg(8 + 6, 1, read_reg(8 + 6, 1) + 1);
+				doff++;
+			}
+			else if (!version && matchlen > 6 && !c2)
+				accept = 1;
+			else
+				restart = 1;
+		}
+		if (accept)
+		{
+			effective(read_reg(8 + 2, 1))[0] = (version) ? flag : 0;
+			effective(read_reg(8 + 2, 1))[1] = (type8)bank;
+			write_w(effective(read_reg(8 + 2, 1) + 2), word);
+			write_reg(8 + 2, 1, read_reg(8 + 2, 1) + 4);
+			if (matchlen >= longest)
+				longest = matchlen;
+			restart = 1;
+			accept = 0;
+		}
+		if (restart)
+		{
+			write_reg(8 + 6, 1, read_reg(8 + 5, 1));
+			flag = matchlen = 0;
+			word++;
+			if (sd)
+				while (dict[doff++] < 0x80);
+			else
+				while (effective(doff++)[0] < 0x80);
+			restart = 0;
+		}
+	}
+	write_w(effective(read_reg(8 + 2, 1)), 0xffff);
+
+	if (version)
+	{
+		/* version > 0 */
+		output_bak = output;	/* check synonyms */
+		while ((c = effective(output)[1]) != 0xff)
+		{
+			if (c == 0x0b)
+			{
+				if (sd)
+					tmp16 = read_w(&dict[dtab + read_w(effective(output + 2)) * 2]);
+				else
+					tmp16 = read_w(effective(dtab + read_w(effective(output + 2)) * 2));
+				effective(output)[1] = tmp16 & 0x1f;
+				write_w(effective(output + 2), (type16)(tmp16 >> 5));
+			}
+			output += 4;
+		}
+		output = output_bak;
+	}
+
+/* l22 = output2,     l1e = adjlist, l20 = obj_adj, l26 = word, l2f = c2 */
+/* l1c = adjlist_bak, 333C = i,      l2d = bank,    l2c = flag, l30e3 = flag2 */
+
+	write_reg(1, 1, 0);	/* D1.W=0  [32B5] */
+	flag2 = 0;
+	output_bak = output;
+	output2 = output;
+	while ((bank = effective(output2)[1]) != 0xff)
+	{
+		obj_adj = (type16)read_reg(8 + 1, 1);	/* A1.W - obj_adj, ie. adjs for this word */
+		write_reg(1, 0, 0);	/* D1.B=0 */
+		flag = effective(output2)[0];	/* flag */
+		word = read_w(effective(output2 + 2));	/* wordnumber */
+		output2 += 4;	/* next match */
+		if ((read_w(effective(obj_adj))) && (bank == 6))
+		{
+			/* Any adjectives? */
+			if ((i = word) != 0)
+			{
+				/* Find list of valid adjs */
+				do
+				{
+					while (effective(adjlist++)[0]);
+				}
+				while (--i > 0);
+			}
+			adjlist_bak = adjlist;
+			do
+			{
+				adjlist = adjlist_bak;
+				c2 = effective(obj_adj)[1];	/* given adjective */
+				if ((tmp16 = read_w(effective(obj_adj))) != 0)
+				{
+					obj_adj += 2;
+					while ((c = effective(adjlist++)[0]) && (c - 3 != c2));
+					if (c - 3 != c2)
+						write_reg(1, 0, 1);	/* invalid adjective */
+				}
+			}
+			while (tmp16 && !read_reg(1, 0));
+			adjlist = (type16)read_reg(8 + 0, 1);
+		}
+		if (!read_reg(1, 0))
+		{
+			/* invalid_flag */
+			flag2 |= flag;
+			effective(output)[0] = flag2;
+			effective(output)[1] = (type8)bank;
+			write_w(effective(output + 2), word);
+			output += 4;
+		}
+	}
+	write_reg(8 + 2, 1, output);
+	output = output_bak;
+
+	if (flag2 & 0x80)
+	{
+		tmp16 = output;
+		output -= 4;
+		do
+		{
+			output += 4;
+			c = effective(output)[0];
+		}
+		while (!(c & 0x80));
+		write_l(effective(tmp16), read_l(effective(output)) & 0x7fffffff);
+		write_reg(8 + 2, 2, tmp16 + 4);
+		if (longest > 1)
+		{
+			write_reg(8 + 5, 1, read_reg(8 + 5, 1) + longest - 2);
+		}
+	}
+	write_reg(8 + 6, 1, read_reg(8 + 5, 1) + 1);
+}
+
+/* A0=findproperties(D0) [2b86], properties_ptr=[2b78] A0FE */
+
+void do_findprop(void)
+{
+	type16 tmp;
+
+	if ((version > 2) && ((read_reg(0, 1) & 0x3fff) > fp_size))
+	{
+		tmp = (type16)(((fp_size - (read_reg(0, 1) & 0x3fff)) ^ 0xffff) << 1);
+		tmp += fp_tab;
+		tmp = read_w(effective(tmp));
+	}
+	else
+	{
+		if (version < 2)
+			write_reg(0, 2, read_reg(0, 2) & 0x7fff);
+		else
+			write_reg(0, 1, read_reg(0, 1) & 0x7fff);
+		tmp = (type16)read_reg(0, 1);
+	}
+	tmp &= 0x3fff;
+	write_reg(8 + 0, 2, tmp * 14 + properties);
+}
+
+void write_string(void)
+{
+	static type32 offset_bak;
+	static type8 mask_bak;
+	type8 c, b, mask;
+	type16 ptr;
+	type32 offset;
+
+	if (!cflag)
+	{
+		/* new string */
+		ptr = (type16)read_reg(0, 1);
+		if (!ptr)
+			offset = 0;
+		else
+		{
+			offset = read_w(&decode_table[0x100 + 2 * ptr]);
+			if (read_w(&decode_table[0x100]))
+			{
+				if (ptr >= read_w(&decode_table[0x100]))
+					offset += string_size;
+			}
+		}
+		mask = 1;
+	}
+	else
+	{
+		offset = offset_bak;
+		mask = mask_bak;
+	}
+	do
+	{
+		c = 0;
+		while (c < 0x80)
+		{
+			if (offset >= string_size)
+				b = string2[offset - string_size];
+			else
+			{
+				if (offset >= MAX_STRING_SIZE)
+					b = string3[offset - MAX_STRING_SIZE];
+				else
+					b = string[offset];
+			}
+			if (b & mask)
+				c = decode_table[0x80 + c];
+			else
+				c = decode_table[c];
+			mask <<= 1;
+			if (!mask)
+			{
+				mask = 1;
+				offset++;
+			}
+		}
+		c &= 0x7f;
+		if (c && ((c != 0x40) || (lastchar != 0x20)))
+			char_out(c);
+	}
+	while (c && ((c != 0x40) || (lastchar != 0x20)));
+	cflag = c ? 0xff : 0;
+	if (c)
+	{
+		offset_bak = offset;
+		mask_bak = mask;
+	}
+}
+
+void output_number(type16 number)
+{
+	type16 tens = number / 10;
+
+	if (tens > 0)
+		ms_putchar('0'+tens);
+	number -= (tens*10);
+	ms_putchar('0'+number);
+}
+
+type16 output_text(const type8* text)
+{
+	type16 i;
+
+	for (i = 0; text[i] != 0; i++)
+		ms_putchar(text[i]);
+	return i;
+}
+
+type16s hint_input(void)
+{
+	type8 c1, c2, c3;
+
+	output_text(">>");
+	ms_flush();
+
+	do
+	{
+		c1 = ms_getchar(0);
+	}
+	while (c1 == '\n');
+	if (c1 == 1)
+		return -1; /* New game loaded, abort hints */
+
+	c2 = ms_getchar(0);
+	if (c2 == 1)
+		return -1;
+
+	/* Get and discard any remaining characters */
+	c3 = c2;
+	while (c3 != '\n')
+	{
+		c3 = ms_getchar(0);
+		if (c3 == 1)
+			return -1;
+	}
+	ms_putchar('\n');
+
+	if ((c1 >= '0') && (c1 <= '9'))
+	{
+		type16 number = c1 - '0';
+		if ((c2 >= '0') && (c2 <= '9'))
+		{
+			number *= 10;
+			number += c2 - '0';
+		}
+		return number;
+	}
+
+	if ((c1 >= 'A') && (c1 <= 'Z'))
+		c1 = 'a' + (c1 - 'A');
+	if ((c1 >= 'a') && (c1 <= 'z'))
+	{
+		switch (c1)
+		{
+		case 'e':
+			return -2; /* End hints */
+		case 'n':
+			return -3; /* Next hint */
+		case 'p':
+			return -4; /* Show parent hint list */
+		}
+	}
+	return 0;
+}
+
+type16 show_hints_text(struct ms_hint* hints, type16 index)
+{
+	type16 i = 0, j = 0;
+	type16s input;
+	struct ms_hint* hint = hints+index;
+
+	while (1)
+	{
+		switch (hint->nodetype)
+		{
+
+		case 1: /* folders */
+			output_text("Hint categories:\n");
+			for (i = 0, j = 0; i < hint->elcount; i++)
+			{
+				output_number(i+1);
+				output_text(". ");
+				j += output_text(hint->content+j)+1;
+				ms_putchar('\n');
+			}
+			output_text("Enter hint category number, ");
+			if (hint->parent != 0xffff)
+				output_text("P for the parent hint menu, ");
+			output_text("or E to end hints.\n");
+
+			input = hint_input();
+			switch (input)
+			{
+			case -1: /* A new game is being loaded */
+				return 1;
+			case -2: /* End hints */
+				return 1;
+			case -4: /* Show parent hint list */
+				if (hint->parent != 0xffff)
+					return 0;
+			default:
+				if ((input > 0) && (input <= hint->elcount))
+				{
+					if (show_hints_text(hints,hint->links[input-1]) == 1)
+						return 1;
+				}
+				break;
+			}
+			break;
+
+		case 2: /* hints */
+			if (i < hint->elcount)
+			{
+				output_number(i+1);
+				output_text(". ");
+				j += output_text(hint->content+j)+1;
+
+				if (i == hint->elcount-1)
+				{
+					output_text("\nNo more hints.\n");
+					return 0; /* Last hint */
+				}
+				else
+				{
+					output_text("\nEnter N for the next hint, ");
+					output_text("P for the parent hint menu, ");
+					output_text("or E to end hints.\n");
+				}
+
+				input = hint_input();
+				switch (input)
+				{
+				case -1: /* A new game is being loaded */
+					return 1;
+				case -2: /* End hints */
+					return 1;
+				case -3:
+					i++;
+					break;
+				case -4: /* Show parent hint list */
+					return 0;
+				}
+			}
+			else
+				return 0;
+			break;
+		}
+	}
+	return 0;
+}
+
+void do_line_a(void)
+{
+	type8 l1c;
+	type8s *str;
+	type16 ptr, ptr2, tmp16, dtype;
+	type32 a1reg, tmp32;
+
+#ifdef LOGGFX
+/*
+	if (((byte2-0xdd) == 4) || ((byte2-0xdd) == 13))
+		out2("--> %d\n",byte2-0xdd);
+	else
+		out2("LINE A %d\n",byte2-0xdd);
+ */
+#endif
+	if ((byte2 < 0xdd) || (version < 4 && byte2 < 0xe4) || (version < 2 && byte2 < 0xed))
+	{
+		ms_flush();	/* flush output-buffer */
+		rand_emu();	/* Increase game randomness */
+		l1c = ms_getchar(1);	/* 0 means UNDO */
+		if (l1c == 1)
+			return;
+		if (l1c)
+			write_reg(1, 2, l1c);	/* d1=getkey() */
+		else
+		{
+			if ((l1c = ms_undo()) != 0)
+				output_text(undo_ok);
+			else
+				output_text(undo_fail);
+			if (!l1c)
+				write_reg(1, 2, '\n');
+		}
+	}
+	else
+		switch (byte2 - 0xdd)
+		{
+
+		case 0:	/* A0DD - Won't probably be needed at all */
+			break;
+
+		case 1:	/* A0DE */
+			write_reg(1, 0, 1);	/* Should remove the manual check */
+			break;
+
+		case 2:	/* A0DF */
+			a1reg = (type32)read_reg(9,2);
+			dtype = (code+a1reg+2)[0];
+
+			switch (dtype)
+			{
+			case 7: /* Picture */
+#ifdef LOGGFX
+				out2("PICTURE IS %s\n", code + a1reg + 3);
+#endif
+				/* gfx mode = normal, df is not called if graphics are off */
+				ms_showpic(a1reg + 3, 2);
+				break;
+
+			case 10: /* Open window commands */
+				switch ((code+a1reg+3)[0])
+				{
+				case 4: /* Help/Hints */
+					if (hints != 0)
+					{
+						if (ms_showhints(hints) == 0)
+							show_hints_text(hints,0);
+					}
+					else
+						output_text(no_hints);
+					break;
+				case 0: /* Carried items */
+				case 1: /* Room items */
+				case 2: /* Map */
+				case 3: /* Compass */
+					output_text(not_supported);
+					break;
+				}
+				break;
+
+			case 13: /* Music */
+				switch ((code+a1reg+3)[0])
+				{
+				case 0: /* stop music */
+					ms_playmusic(0,0,0);
+					break;
+				default: /* play music */
+#ifdef LOGSND
+					out2("MUSIC IS %s\n", code + a1reg + 3);
+#endif
+					{
+						type32 length = 0;
+						type16 tempo = 0;
+						type8* midi = sound_extract(code + a1reg + 3,&length,&tempo);
+						if (midi != NULL)
+							ms_playmusic(midi,length,tempo);
+					}
+					break;
+				}
+				break;
+			}
+			break;
+
+		case 3:	/* A0E0 */
+			/* printf("A0E0 stubbed\n"); */
+			break;
+
+		case 4:	/* A0E1 Read from keyboard to (A1), status in D1 (0 for ok) */
+			ms_flush();
+			rand_emu();
+			tmp32 = read_reg(8 + 1, 2);
+			str = (type8s*)effective(tmp32);
+			tmp16 = 0;
+			do
+			{
+				if (!(l1c = ms_getchar(1)))
+				{
+					if ((l1c = ms_undo()) != 0)
+						output_text(undo_ok);
+					else
+						output_text(undo_fail);
+					if (!l1c)
+					{
+						tmp16 = 0;
+						str[tmp16++] = '\n';
+						l1c = '\n';
+						output_text("\n>");
+					}
+					else
+					{
+						ms_putchar('\n');
+						return;
+					}
+				}
+				else
+				{
+					if (l1c == 1)
+						return;
+					str[tmp16++] = l1c;
+#ifdef LOGGFX
+					out2("%c",l1c);
+#endif
+				}
+			}
+			while (l1c != '\n' && tmp16 < 256);
+			write_reg(8 + 1, 2, tmp32 + tmp16 - 1);
+			if (tmp16 != 256 && tmp16 != 1)
+				write_reg(1, 1, 0);
+			else
+				write_reg(1, 1, 1);
+			break;
+
+		case 5:	/* A0E2 */
+			/* printf("A0E2 stubbed\n"); */
+			break;
+
+		case 6:	/* A0E3 */
+			if (read_reg(1, 2) == 0)
+			{
+				if ((version < 4) || (read_reg(6, 2) == 0))
+					ms_showpic(0, 0);
+			}
+			/* printf("\nMoves: %u\n",read_reg(0,1)); */
+			break;
+
+		case 7:	/* A0E4 sp+=4, RTS */
+			write_reg(8 + 7, 1, read_reg(8 + 7, 1) + 4);
+			pc = pop();
+			break;
+
+		case 8:	/* A0E5 set z, RTS */
+		case 9:	/* A0E6 clear z, RTS */
+			pc = pop();
+			zflag = (byte2 == 0xe5) ? 0xff : 0;
+			break;
+
+		case 10: /* A0E7 set z */
+			zflag = 0xff;
+			break;
+
+		case 11: /* A0E8 clear z */
+			zflag = 0;
+			break;
+
+		case 12: /* A0E9 [3083 - j] */
+			ptr = (type16)read_reg(8 + 0, 1);
+			ptr2 = (type16)read_reg(8 + 1, 1);
+			do
+			{
+				l1c = dict[ptr2++];
+				effective(ptr++)[0] = l1c;
+			}
+			while ((l1c & 0x80) == 0);
+			write_reg(8 + 0, 1, ptr);
+			write_reg(8 + 1, 1, ptr2);
+			break;
+
+		case 13: /* A0EA A1=write_dictword(A1,D1=output_mode) */
+			ptr = (type16)read_reg(8 + 1, 1);
+			tmp32 = read_reg(3, 0);
+			write_reg(3, 0, read_reg(1, 0));
+			do
+			{
+				l1c = dict[ptr++];
+				char_out(l1c);
+			}
+			while (l1c < 0x80);
+			write_reg(8 + 1, 1, ptr);
+			write_reg(3, 0, tmp32);
+			break;
+
+		case 14: /* A0EB [3037 - j] */
+			dict[read_reg(8 + 1, 1)] = (type8)read_reg(1, 0);
+			break;
+
+		case 15: /* A0EC */
+			write_reg(1, 0, dict[read_reg(8 + 1, 1)]);
+			break;
+
+		case 16:
+			ms_stop();	/* infinite loop A0ED */
+			break;
+		case 17:
+			if (!ms_init(0, 0, 0, 0))
+				ms_stop();	/* restart game ie. pc, sp etc. A0EE */
+			break;
+		case 18:	/* printer A0EF */
+			break;
+		case 19:
+			ms_showpic(read_reg(0, 0), (type8)read_reg(1, 0));	/* Do_picture(D0) A0F0 */
+			break;
+		case 20:
+			ptr = (type16)read_reg(8 + 1, 1);	/* A1=nth_string(A1,D0) A0F1 */
+			tmp32 = read_reg(0, 1);
+			while (tmp32-- > 0)
+			{
+				while (effective(ptr++)[0]);
+			}
+			write_reg(8 + 1, 1, ptr);
+			break;
+
+		case 21: /* [2a43] A0F2 */
+			cflag = 0;
+			write_reg(0, 1, read_reg(2, 1));
+			do_findprop();
+			ptr = (type16)read_reg(8 + 0, 1);
+			while (read_reg(2, 1) > 0)
+			{
+				if (read_w(effective(ptr + 12)) & 0x3fff)
+				{
+					cflag = 0xff;
+					break;
+				}
+				if (read_reg(2, 1) == (read_reg(4, 1) & 0x7fff))
+				{
+					cflag = 0xff;
+					break;
+				}
+				ptr -= 0x0e;
+				write_reg(2, 1, read_reg(2, 1) - 1);
+			}
+			break;
+
+		case 22:
+			char_out((type8)read_reg(1, 0));	/* A0F3 */
+			break;
+
+		case 23: /* D7=Save_(filename A0) D1 bytes starting from A1  A0F4 */
+			str = (version < 4) ? (type8s*)effective(read_reg(8 + 0, 1)) : 0;
+			write_reg(7, 0, ms_save_file(str, effective(read_reg(8 + 1, 1)),
+				(type16)read_reg(1, 1)));
+			break;
+
+		case 24: /* D7=Load_(filename A0) D1 bytes starting from A1  A0F5 */
+			str = (version < 4) ? (type8s*)effective(read_reg(8 + 0, 1)) : 0;
+			write_reg(7, 0, ms_load_file(str, effective(read_reg(8 + 1, 1)),
+				(type16)read_reg(1, 1)));
+			break;
+
+		case 25: /* D1=Random(0..D1-1) [3748] A0F6 */
+			l1c = (type8)read_reg(1, 0);
+			write_reg(1, 1, rand_emu() % (l1c ? l1c : 1));
+			break;
+
+		case 26: /* D0=Random(0..255) [3742] A0F7 */
+			tmp16 = (type16)rand_emu();
+			write_reg(0, 0, tmp16 + (tmp16 >> 8));
+			break;
+
+		case 27: /* write string [D0] [2999] A0F8 */
+			write_string();
+			break;
+
+		case 28: /* Z,D0=Get_inventory_item(D0) [2a9e] A0F9 */
+			zflag = 0;
+			ptr = (type16)read_reg(0, 1);
+			do
+			{
+				write_reg(0, 1, ptr);
+				do
+				{
+					do_findprop();
+					ptr2 = (type16)read_reg(8 + 0, 1);	/* object properties */
+					if ((effective(ptr2)[5]) & 1)
+						break;	/* is_described or so */
+					l1c = effective(ptr2)[6];	/* some_flags */
+					tmp16 = read_w(effective(ptr2 + 8));	/* parent_object */
+					if (!l1c)
+					{
+						/* ordinary object? */
+						if (!tmp16)
+							zflag = 0xff;	/* return if parent()=player */
+						break;	/* otherwise try next */
+					}
+					if (l1c & 0xcc)
+						break;	/* skip worn, bodypart, room, hidden */
+					if (tmp16 == 0)
+					{
+						/* return if parent()=player? */
+						zflag = 0xff;
+						break;
+					}
+					write_reg(0, 1, tmp16);	/* else look at parent() */
+				}
+				while (1);
+				ptr--;
+			}
+			while ((!zflag) && ptr);
+			write_reg(0, 1, ptr + 1);
+			break;
+
+		case 29: /* [2b18] A0FA */
+			ptr = (type16)read_reg(8, 1);
+			do
+			{
+				if (read_reg(5, 0))
+				{
+					l1c = ((type32)((read_w(effective(ptr)) & 0x3fff)) == read_reg(2, 1));
+				}
+				else
+				{
+					l1c = (effective(ptr)[0] == read_reg(2, 0));
+				}
+				if (read_reg(3, 1) == read_reg(4, 1))
+				{
+					cflag = 0;
+					write_reg(8, 1, ptr);
+				}
+				else
+				{
+					write_reg(3, 1, read_reg(3, 1) + 1);
+					ptr += 0x0e;
+					if (l1c)
+					{
+						cflag = 0xff;
+						write_reg(8, 1, ptr);
+					}
+				}
+			}
+			while ((!l1c) && (read_reg(3, 1) != read_reg(4, 1)));
+			break;
+
+		case 30: /* [2bd1] A0FB */
+			ptr = (type16)read_reg(8 + 1, 1);
+			do
+			{
+				if (dict)
+					while (dict[ptr++] < 0x80);
+				else
+					while (effective(ptr++)[0] < 0x80);
+				write_reg(2, 1, read_reg(2, 1) - 1);
+			}
+			while (read_reg(2, 1));
+			write_reg(8 + 1, 1, ptr);
+			break;
+
+		case 31: /* [2c3b] A0FC */
+			ptr = (type16)read_reg(8 + 0, 1);
+			ptr2 = (type16)read_reg(8 + 1, 1);
+			do
+			{
+				if (dict)
+					while (dict[ptr++] < 0x80);
+				else
+					while (effective(ptr++)[0] < 0x80);
+				while (effective(ptr2++)[0]);
+				write_reg(0, 1, read_reg(0, 1) - 1);
+			}
+			while (read_reg(0, 1));
+			write_reg(8 + 0, 1, ptr);
+			write_reg(8 + 1, 1, ptr2);
+			break;
+
+		case 32: /* Set properties pointer from A0 [2b7b] A0FD */
+			properties = (type16)read_reg(8 + 0, 1);
+			if (version > 0)
+				fl_sub = (type16)read_reg(8 + 3, 1);
+			if (version > 1)
+			{
+				fl_tab = (type16)read_reg(8 + 5, 1);
+				fl_size = (type16)read_reg(7, 1) + 1;
+				/* A3 [routine], A5 [table] and D7 [table-size] */
+			}
+			if (version > 2)
+			{
+				fp_tab = (type16)read_reg(8 + 6, 1);
+				fp_size = (type16)read_reg(6, 1);
+			}
+			break;
+
+		case 33: /* A0FE */
+			do_findprop();
+			break;
+
+		case 34: /* Dictionary_lookup A0FF */
+			dict_lookup();
+			break;
+		}
+}
+
+/* emulate an instruction [1b7e] */
+
+type8 ms_rungame(void)
+{
+	type8 l1c;
+	type16 ptr;
+	type32 tmp32;
+#ifdef LOGEMU
+	static int stat = 0;
+#endif
+
+	if (!running)
+		return running;
+	if (pc == undo_pc)
+		save_undo();
+
+#ifdef LOGEMU
+	if (pc == 0x0000)
+		stat = 0;
+	if (stat)
+	{
+		log_status();
+		fflush(dbg_log);
+	}
+
+	fprintf(dbg_log, "%.8X: ", pc);
+#endif
+	i_count++;
+	read_word();
+	switch (byte1 >> 1)
+	{
+
+/* 00-0F */
+	case 0x00:
+		if (byte1 == 0x00)
+		{
+			if (byte2 == 0x3c || byte2 == 0x7c)
+			{
+				/* OR immediate to CCR (30D9) */
+				read_word();
+#ifdef LOGEMU
+				out("or_ccr #%.2x", byte2);
+#endif
+				if (byte2 & 0x01)
+					cflag = 0xff;
+				if (byte2 & 0x02)
+					vflag = 0xff;
+				if (byte2 & 0x04)
+					zflag = 0xff;
+				if (byte2 & 0x08)
+					nflag = 0xff;
+			}
+			else
+			{
+				/* OR [27df] */
+#ifdef LOGEMU
+				out("or");
+#endif
+				get_arg();
+				do_or();
+			}
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x01:
+		if (byte1 == 0x02)
+		{
+			if (byte2 == 0x3c || byte2 == 0x7c)
+			{
+				/* AND immediate to CCR */
+				read_word();
+#ifdef LOGEMU
+				out("and_ccr #%.2x", byte2);
+#endif
+				if (!(byte2 & 0x01))
+					cflag = 0;
+				if (!(byte2 & 0x02))
+					vflag = 0;
+				if (!(byte2 & 0x04))
+					zflag = 0;
+				if (!(byte2 & 0x08))
+					nflag = 0;
+			}
+			else
+			{
+				/* AND */
+#ifdef LOGEMU
+				out("and");
+#endif
+				get_arg();
+				do_and();
+			}
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x02:
+		if (byte1 == 0x04)
+		{
+			/* SUB */
+#ifdef LOGEMU
+			out("sub");
+#endif
+			get_arg();
+			do_sub(0);
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x03:
+		if (byte1 == 0x06)
+		{
+			/* ADD */
+#ifdef LOGEMU
+			out("addi");
+#endif
+			get_arg();
+			do_add(0);
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x04:
+		if (byte1 == 0x08)
+		{
+			/* bit operations (immediate) */
+			set_info((type8)(byte2 & 0x3f));
+			l1c = (effective(pc))[1];
+			pc += 2;
+			set_arg1();
+			do_bop(byte2, l1c);
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x05:
+		if (byte1 == 0x0a)
+		{
+			if (byte2 == 0x3c || byte2 == 0x7c)
+			{
+				/* EOR immediate to CCR */
+				read_word();
+#ifdef LOGEMU
+				out("eor_ccr #%.2X", byte2);
+#endif
+				if (byte2 & 0x01)
+					cflag ^= 0xff;
+				if (byte2 & 0x02)
+					vflag ^= 0xff;
+				if (byte2 & 0x04)
+					zflag ^= 0xff;
+				if (byte2 & 0x08)
+					nflag ^= 0xff;
+			}
+			else
+			{
+				/* EOR */
+#ifdef LOGEMU
+				out("eor");
+#endif
+				get_arg();
+				do_eor();
+			}
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x06:
+		if (byte1 == 0x0c)
+		{
+			/* CMP */
+#ifdef LOGEMU
+			out("cmp");
+#endif
+			get_arg();
+			do_cmp();
+		}
+		else
+			check_btst();
+		break;
+
+	case 0x07:
+		check_btst();
+		break;
+
+/* 10-1F [3327] MOVE.B */
+	case 0x08: case 0x09: case 0x0a: case 0x0b:
+	case 0x0c: case 0x0d: case 0x0e: case 0x0f:
+
+#ifdef LOGEMU
+		out("move.b");
+#endif
+		set_info((type8)(byte2 & 0x3f));
+		set_arg1();
+		swap_args();
+		l1c = (byte1 >> 1 & 0x07) | (byte2 >> 3 & 0x18) | (byte1 << 5 & 0x20);
+		set_info(l1c);
+		set_arg1();
+		do_move();
+		break;
+
+/* 20-2F [32d1] MOVE.L */
+	case 0x10: case 0x11: case 0x12: case 0x13:
+	case 0x14: case 0x15: case 0x16: case 0x17:
+
+#ifdef LOGEMU
+		out("move.l");
+#endif
+		set_info((type8)((byte2 & 0x3f) | 0x80));
+		set_arg1();
+		swap_args();
+		l1c = (byte1 >> 1 & 0x07) | (byte2 >> 3 & 0x18) | (byte1 << 5 & 0x20);
+		set_info((type8)(l1c | 0x80));
+		set_arg1();
+		do_move();
+		break;
+
+/* 30-3F [3327] MOVE.W */
+	case 0x18: case 0x19: case 0x1a: case 0x1b:
+	case 0x1c: case 0x1d: case 0x1e: case 0x1f:
+
+#ifdef LOGEMU
+		out("move.w");
+#endif
+		set_info((type8)((byte2 & 0x3f) | 0x40));
+		set_arg1();
+		swap_args();
+		l1c = (byte1 >> 1 & 0x07) | (byte2 >> 3 & 0x18) | (byte1 << 5 & 0x20);
+		set_info((type8)(l1c | 0x40));
+		set_arg1();
+		do_move();
+		break;
+
+/* 40-4F various commands */
+
+	case 0x20:
+		if (byte1 == 0x40)
+		{
+			/* [31d5] */
+			ms_fatal("unimplemented instructions NEGX and MOVE SR,xx");
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x21:
+		if (byte1 == 0x42)
+		{
+			/* [3188] */
+			if ((byte2 & 0xc0) == 0xc0)
+			{
+				ms_fatal("unimplemented instruction MOVE CCR,xx");
+			}
+			else
+			{
+				/* CLR */
+#ifdef LOGEMU
+				out("clr");
+#endif
+				set_info(byte2);
+				set_arg1();
+				if (opsize == 0)
+					arg1[0] = 0;
+				if (opsize == 1)
+					write_w(arg1, 0);
+				if (opsize == 2)
+					write_l(arg1, 0);
+				nflag = cflag = 0;
+				zflag = 0xff;
+			}
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x22:
+		if (byte1 == 0x44)
+		{
+			/* [31a0] */
+			if ((byte2 & 0xc0) == 0xc0)
+			{
+				/* MOVE to CCR */
+#ifdef LOGEMU
+				out("move_ccr");
+#endif
+				zflag = nflag = cflag = vflag = 0;
+				set_info((type8)(byte2 & 0x7f));
+				set_arg1();
+				byte2 = arg1[1];
+				if (byte2 & 0x01)
+					cflag = 0xff;
+				if (byte2 & 0x02)
+					vflag = 0xff;
+				if (byte2 & 0x04)
+					zflag = 0xff;
+				if (byte2 & 0x08)
+					nflag = 0xff;
+			}
+			else
+			{
+#ifdef LOGEMU
+				out("neg");
+#endif
+				set_info(byte2);	/* NEG */
+				set_arg1();
+				cflag = 0xff;
+				if (opsize == 0)
+				{
+					arg1[0] = (-arg1[0]);
+					cflag = arg1[0] ? 0xff : 0;
+				}
+				if (opsize == 1)
+				{
+					write_w(arg1, (type16)(-1 * read_w(arg1)));
+					cflag = read_w(arg1) ? 0xff : 0;
+				}
+				if (opsize == 2)
+				{
+					write_l(arg1, -1 * read_l(arg1));
+					cflag = read_l(arg1) ? 0xff : 0;
+				}
+				vflag = 0;
+				set_flags();
+			}
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x23:
+		if (byte1 == 0x46)
+		{
+			if ((byte2 & 0xc0) == 0xc0)
+			{
+				ms_fatal("unimplemented instruction MOVE xx,SR");
+			}
+			else
+			{
+#ifdef LOGEMU
+				out("not");
+#endif
+				set_info(byte2);	/* NOT */
+				set_arg1();
+				tmparg[0] = tmparg[1] = tmparg[2] = tmparg[3] = 0xff;
+				arg2 = tmparg;
+				do_eor();
+			}
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x24:
+		if (byte1 == 0x48)
+		{
+			if ((byte2 & 0xf8) == 0x40)
+			{
+#ifdef LOGEMU
+				out("swap");
+#endif
+				opsize = 2;	/* SWAP */
+				admode = 0;
+				regnr = byte2 & 0x07;
+				set_arg1();
+				tmp32 = read_w(arg1);
+				write_w(arg1, read_w(arg1 + 2));
+				write_w(arg1 + 2, (type16)tmp32);
+				set_flags();
+			}
+			else if ((byte2 & 0xf8) == 0x80)
+			{
+#ifdef LOGEMU
+				out("ext.w");
+#endif
+				opsize = 1;	/* EXT.W */
+				admode = 0;
+				regnr = byte2 & 0x07;
+				set_arg1();
+				if (arg1[1] > 0x7f)
+					arg1[0] = 0xff;
+				else
+					arg1[0] = 0;
+				set_flags();
+			}
+			else if ((byte2 & 0xf8) == 0xc0)
+			{
+#ifdef LOGEMU
+				out("ext.l");
+#endif
+				opsize = 2;	/* EXT.L */
+				admode = 0;
+				regnr = byte2 & 0x07;
+				set_arg1();
+				if (read_w(arg1 + 2) > 0x7fff)
+					write_w(arg1, 0xffff);
+				else
+					write_w(arg1, 0);
+				set_flags();
+			}
+			else if ((byte2 & 0xc0) == 0x40)
+			{
+#ifdef LOGEMU
+				out("pea");
+#endif
+				set_info((type8)((byte2 & 0x3f) | 0x80));	/* PEA */
+				set_arg1();
+				if (is_reversible)
+					push(arg1i);
+				else
+					ms_fatal("illegal addressing mode for PEA");
+			}
+			else
+			{
+				check_movem();	/* MOVEM */
+			}
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x25:
+		if (byte1 == 0x4a)
+		{
+			/* [3219] TST */
+			if ((byte2 & 0xc0) == 0xc0)
+			{
+				ms_fatal("unimplemented instruction TAS");
+			}
+			else
+			{
+#ifdef LOGEMU
+				out("tst");
+#endif
+				set_info(byte2);
+				set_arg1();
+				cflag = vflag = 0;
+				set_flags();
+			}
+		}
+		else
+			check_lea();
+		break;
+
+	case 0x26:
+		if (byte1 == 0x4c)
+			check_movem2();		/* [3350] MOVEM.L (Ax)+,A/Dx */
+		else
+			check_lea();	/* LEA */
+		break;
+
+	case 0x27:
+		if (byte1 == 0x4e)
+		{
+			/* [3290] */
+			if (byte2 == 0x75)
+			{
+				/* RTS */
+#ifdef LOGEMU
+				out("rts\n");
+#endif
+				pc = pop();
+			}
+			else if (byte2 == 0x71)
+			{
+				/* NOP */
+#ifdef LOGEMU
+				out("nop");
+#endif
+			}
+			else if ((byte2 & 0xc0) == 0xc0)
+			{
+				/* indir JMP */
+#ifdef LOGEMU
+				out("jmp");
+#endif
+				set_info((type8)(byte2 | 0xc0));
+				set_arg1();
+				if (is_reversible)
+					pc = arg1i;
+				else
+					ms_fatal("illegal addressing mode for JMP");
+			}
+			else if ((byte2 & 0xc0) == 0x80)
+			{
+#ifdef LOGEMU
+				out("jsr");
+#endif
+				set_info((type8)(byte2 | 0xc0));		/* indir JSR */
+				set_arg1();
+				push(pc);
+				if (is_reversible)
+					pc = arg1i;
+				else
+					ms_fatal("illegal addressing mode for JSR");
+			}
+			else
+			{
+				ms_fatal("unimplemented instructions 0x4EXX");
+			}
+		}
+		else
+			check_lea();	/* LEA */
+		break;
+
+/* 50-5F [2ed5] ADDQ/SUBQ/Scc/DBcc */
+	case 0x28: case 0x29: case 0x2a: case 0x2b:
+	case 0x2c: case 0x2d: case 0x2e: case 0x2f:
+
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			set_info((type8)(byte2 & 0x3f));
+			set_arg1();
+			if (admode == 1)
+			{
+				/* DBcc */
+#ifdef LOGEMU
+				out("dbcc");
+#endif
+				if (condition(byte1) == 0)
+				{
+					arg1 = (arg1 - (type8 *) areg) + (type8 *) dreg - 1;
+					write_w(arg1, (type16)(read_w(arg1) - 1));
+					if (read_w(arg1) != 0xffff)
+						branch(0);
+					else
+						pc += 2;
+				}
+				else
+					pc += 2;
+			}
+			else
+			{
+				/* Scc */
+#ifdef LOGEMU
+				out("scc");
+#endif
+				arg1[0] = condition(byte1) ? 0xff : 0;
+			}
+		}
+		else
+		{
+			set_info(byte2);
+			set_arg1();
+			quick_flag = (admode == 1) ? 0xff : 0;
+			l1c = byte1 >> 1 & 0x07;
+			tmparg[0] = tmparg[1] = tmparg[2] = 0;
+			tmparg[3] = l1c ? l1c : 8;
+			arg2 = reg_align(tmparg, opsize);
+			{
+#ifdef LOGEMU
+				type32s outnum = 0;
+				switch (opsize)
+				{
+				case 0:
+					outnum = (type8s) arg2[0];
+					break;
+				case 1:
+					outnum = (type16s) read_w(arg2);
+					break;
+				case 2:
+					outnum = (type32s) read_l(arg2);
+					break;
+				}
+#endif
+				if ((byte1 & 0x01) == 1)
+				{
+#ifdef LOGEMU
+					out("subq #%.8X", outnum);
+#endif
+					do_sub(0);	/* SUBQ */
+				}
+				else
+				{
+#ifdef LOGEMU
+					out("addq #%.8X", outnum);
+#endif
+					do_add(0);	/* ADDQ */
+				}
+			}
+		}
+		break;
+
+/* 60-6F [26ba] Bcc */
+
+	case 0x30:
+		if (byte1 == 0x61)
+		{
+			/* BRA, BSR */
+#ifdef LOGEMU
+			out("bsr");
+#endif
+			if (byte2 == 0)
+				push(pc + 2);
+			else
+				push(pc);
+		}
+#ifdef LOGEMU
+		else
+			out("bra");
+#endif
+		if ((byte1 == 0x60) && (byte2 == 0xfe))
+		{
+			ms_flush();	/* flush stdout */
+			ms_stop();	/* infinite loop - just exit */
+		}
+		branch(byte2);
+		break;
+
+	case 0x31: case 0x32: case 0x33: case 0x34:
+	case 0x35: case 0x36: case 0x37:
+
+		if (condition(byte1) == 0)
+		{
+#ifdef LOGEMU
+			out("beq.s");
+#endif
+			if (byte2 == 0)
+				pc += 2;
+		}
+		else
+		{
+#ifdef LOGEMU
+			out("bra");
+#endif
+			branch(byte2);
+		}
+		break;
+
+/* 70-7F [260a] MOVEQ */
+	case 0x38: case 0x39: case 0x3a: case 0x3b:
+	case 0x3c: case 0x3d: case 0x3e: case 0x3f:
+
+#ifdef LOGEMU
+		out("moveq");
+#endif
+		arg1 = (type8 *) & dreg[byte1 >> 1 & 0x07];
+		if (byte2 > 127)
+			nflag = arg1[0] = arg1[1] = arg1[2] = 0xff;
+		else
+			nflag = arg1[0] = arg1[1] = arg1[2] = 0;
+		arg1[3] = byte2;
+		zflag = byte2 ? 0 : 0xff;
+		break;
+
+/* 80-8F [2f36] */
+	case 0x40: case 0x41: case 0x42: case 0x43:
+	case 0x44: case 0x45: case 0x46: case 0x47:
+
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			ms_fatal("unimplemented instructions DIVS and DIVU");
+		}
+		else if (((byte2 & 0xf0) == 0) && ((byte1 & 0x01) != 0))
+		{
+			ms_fatal("unimplemented instruction SBCD");
+		}
+		else
+		{
+#ifdef LOGEMU
+			out("or?");
+#endif
+			set_info(byte2);
+			set_arg1();
+			set_arg2(1, byte1);
+			if ((byte1 & 0x01) == 0)
+				swap_args();
+			do_or();
+		}
+		break;
+
+/* 90-9F [3005] SUB */
+	case 0x48: case 0x49: case 0x4a: case 0x4b:
+	case 0x4c: case 0x4d: case 0x4e: case 0x4f:
+
+#ifdef LOGEMU
+		out("sub");
+#endif
+		quick_flag = 0;
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			if ((byte1 & 0x01) == 1)
+				set_info((type8)(byte2 & 0xbf));
+			else
+				set_info((type8)(byte2 & 0x7f));
+			set_arg1();
+			set_arg2_nosize(0, byte1);
+			swap_args();
+			do_sub(1);
+		}
+		else
+		{
+			set_info(byte2);
+			set_arg1();
+			set_arg2(1, byte1);
+			if ((byte1 & 0x01) == 0)
+				swap_args();
+			do_sub(0);
+		}
+		break;
+
+/* A0-AF various special commands [LINE_A] */
+
+	case 0x50: case 0x56: case 0x57:		/* [2521] */
+		do_line_a();
+#ifdef LOGEMU
+		out("LINE_A A0%.2X", byte2);
+#endif
+		break;
+
+	case 0x51:
+#ifdef LOGEMU
+		out("rts\n");
+#endif
+		pc = pop();	/* RTS */
+		break;
+
+	case 0x52:
+#ifdef LOGEMU
+		out("bsr");
+#endif
+		if (byte2 == 0)
+			push(pc + 2);	/* BSR */
+		else
+			push(pc);
+		branch(byte2);
+		break;
+
+	case 0x53:
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			/* TST [321d] */
+			ms_fatal("unimplemented instructions LINE_A #$6C0-#$6FF");
+		}
+		else
+		{
+#ifdef LOGEMU
+			out("tst");
+#endif
+			set_info(byte2);
+			set_arg1();
+			cflag = vflag = 0;
+			set_flags();
+		}
+		break;
+
+	case 0x54:
+		check_movem();
+		break;
+
+	case 0x55:
+		check_movem2();
+		break;
+
+/* B0-BF [2fe4] */
+	case 0x58: case 0x59: case 0x5a: case 0x5b:
+	case 0x5c: case 0x5d: case 0x5e: case 0x5f:
+
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+#ifdef LOGEMU
+			out("cmp");
+#endif
+			if ((byte1 & 0x01) == 1)
+				set_info((type8)(byte2 & 0xbf));
+			else
+				set_info((type8)(byte2 & 0x7f));
+			set_arg1();
+			set_arg2(0, byte1);
+			swap_args();
+			do_cmp();	/* CMP */
+		}
+		else
+		{
+			if ((byte1 & 0x01) == 0)
+			{
+#ifdef LOGEMU
+				out("cmp");
+#endif
+				set_info(byte2);
+				set_arg1();
+				set_arg2(1, byte1);
+				swap_args();
+				do_cmp();	/* CMP */
+			}
+			else
+			{
+#ifdef LOGEMU
+				out("eor");
+#endif
+				set_info(byte2);
+				set_arg1();
+				set_arg2(1, byte1);
+				do_eor();	/* EOR */
+			}
+		}
+		break;
+
+/* C0-CF [2f52] EXG, AND */
+	case 0x60: case 0x61: case 0x62: case 0x63:
+	case 0x64: case 0x65: case 0x66: case 0x67:
+
+		if ((byte1 & 0x01) == 0)
+		{
+			if ((byte2 & 0xc0) == 0xc0)
+			{
+				ms_fatal("unimplemented instruction MULU");
+			}
+			else
+			{
+				/* AND */
+#ifdef LOGEMU
+				out("and");
+#endif
+				set_info(byte2);
+				set_arg1();
+				set_arg2(1, byte1);
+				if ((byte1 & 0x01) == 0)
+					swap_args();
+				do_and();
+			}
+		}
+		else
+		{
+			if ((byte2 & 0xf8) == 0x40)
+			{
+#ifdef LOGEMU
+				out("exg (dx)");
+#endif
+				opsize = 2;	/* EXG Dx,Dx */
+				set_arg2(1, (type8)(byte2 << 1));
+				swap_args();
+				set_arg2(1, byte1);
+				tmp32 = read_l(arg1);
+				write_l(arg1, read_l(arg2));
+				write_l(arg2, tmp32);
+			}
+			else if ((byte2 & 0xf8) == 0x48)
+			{
+				opsize = 2;	/* EXG Ax,Ax */
+#ifdef LOGEMU
+				out("exg (ax)");
+#endif
+				set_arg2(0, (type8)(byte2 << 1));
+				swap_args();
+				set_arg2(0, byte1);
+				tmp32 = read_l(arg1);
+				write_l(arg1, read_l(arg2));
+				write_l(arg2, tmp32);
+			}
+			else if ((byte2 & 0xf8) == 0x88)
+			{
+				opsize = 2;	/* EXG Dx,Ax */
+#ifdef LOGEMU
+				out("exg (dx,ax)");
+#endif
+				set_arg2(0, (type8)(byte2 << 1));
+				swap_args();
+				set_arg2(1, byte1);
+				tmp32 = read_l(arg1);
+				write_l(arg1, read_l(arg2));
+				write_l(arg2, tmp32);
+			}
+			else
+			{
+				if ((byte2 & 0xc0) == 0xc0)
+				{
+					ms_fatal("unimplemented instruction MULS");
+				}
+				else
+				{
+					set_info(byte2);
+					set_arg1();
+					set_arg2(1, byte1);
+					if ((byte1 & 0x01) == 0)
+						swap_args();
+					do_and();
+				}
+			}
+		}
+		break;
+
+/* D0-DF [2fc8] ADD */
+	case 0x68: case 0x69: case 0x6a: case 0x6b:
+	case 0x6c: case 0x6d: case 0x6e: case 0x6f:
+
+#ifdef LOGEMU
+		out("add");
+#endif
+		quick_flag = 0;
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			if ((byte1 & 0x01) == 1)
+				set_info((type8)(byte2 & 0xbf));
+			else
+				set_info((type8)(byte2 & 0x7f));
+			set_arg1();
+			set_arg2_nosize(0, byte1);
+			swap_args();
+			do_add(1);
+		}
+		else
+		{
+			set_info(byte2);
+			set_arg1();
+			set_arg2(1, byte1);
+			if ((byte1 & 0x01) == 0)
+				swap_args();
+			do_add(0);
+		}
+		break;
+
+/* E0-EF [3479] LSR ASL ROR ROL */
+	case 0x70: case 0x71: case 0x72: case 0x73:
+	case 0x74: case 0x75: case 0x76: case 0x77:
+
+#ifdef LOGEMU
+		out("lsr,asl,ror,rol");
+#endif
+		if ((byte2 & 0xc0) == 0xc0)
+		{
+			set_info((type8)(byte2 & 0xbf));		/* OP Dx */
+			set_arg1();
+			l1c = 1;	/* steps=1 */
+			byte2 = (byte1 >> 1) & 0x03;
+		}
+		else
+		{
+			set_info((type8)(byte2 & 0xc7));
+			set_arg1();
+			if ((byte2 & 0x20) == 0)
+			{
+				/* immediate */
+				l1c = (byte1 >> 1) & 0x07;
+				if (l1c == 0)
+					l1c = 8;
+			}
+			else
+			{
+				l1c = (type8)read_reg(byte1 >> 1 & 0x07, 0);
+			}
+			byte2 = (byte2 >> 3) & 0x03;
+		}
+		if ((byte1 & 0x01) == 0)
+		{
+			/* right */
+			while (l1c-- > 0)
+			{
+				if (opsize == 0)
+				{
+					cflag = arg1[0] & 0x01 ? 0xff : 0;
+					arg1[0] >>= 1;
+					if (cflag && (byte2 == 3))
+						arg1[0] |= 0x80;
+				}
+				if (opsize == 1)
+				{
+					cflag = read_w(arg1) & 0x01 ? 0xff : 0;
+					write_w(arg1, (type16)(read_w(arg1) >> 1));
+					if (cflag && (byte2 == 3))
+						write_w(arg1, (type16)(read_w(arg1) | ((type16) 1 << 15)));
+				}
+				if (opsize == 2)
+				{
+					cflag = read_l(arg1) & 0x01 ? 0xff : 0;
+					write_l(arg1, read_l(arg1) >> 1);
+					if (cflag && (byte2 == 3))
+						write_l(arg1, read_l(arg1) | ((type32) 1 << 31));
+				}
+			}
+		}
+		else
+		{
+			/* left */
+			while (l1c-- > 0)
+			{
+				if (opsize == 0)
+				{
+					cflag = arg1[0] & 0x80 ? 0xff : 0;	/* [3527] */
+					arg1[0] <<= 1;
+					if (cflag && (byte2 == 3))
+						arg1[0] |= 0x01;
+				}
+				if (opsize == 1)
+				{
+					cflag = read_w(arg1) & ((type16) 1 << 15) ? 0xff : 0;
+					write_w(arg1, (type16)(read_w(arg1) << 1));
+					if (cflag && (byte2 == 3))
+						write_w(arg1, (type16)(read_w(arg1) | 0x01));
+				}
+				if (opsize == 2)
+				{
+					cflag = read_l(arg1) & ((type32) 1 << 31) ? 0xff : 0;
+					write_l(arg1, read_l(arg1) << 1);
+					if (cflag && (byte2 == 3))
+						write_l(arg1, read_l(arg1) | 0x01);
+				}
+			}
+		}
+		set_flags();
+		break;
+
+/* F0-FF [24f3] LINE_F */
+	case 0x78: case 0x79: case 0x7a: case 0x7b:
+	case 0x7c: case 0x7d: case 0x7e: case 0x7f:
+
+		if (version == 0)
+		{
+			/* hardcoded jump */
+			char_out(l1c = (type8)read_reg(1, 0));
+		}
+		else if (version == 1)
+		{
+			/* single programmable shortcut */
+			push(pc);
+			pc = fl_sub;
+		}
+		else
+		{
+			/* programmable shortcuts from table */
+#ifdef LOGEMU
+			out("LINK: %.2X,%.2X", byte1, byte2);
+#endif
+			ptr = (byte1 & 7) << 8 | byte2;
+			if (ptr >= fl_size)
+			{
+				if ((byte1 & 8) == 0)
+					push(pc);
+				ptr = byte1 << 8 | byte2 | 0x0800;
+				ptr = fl_tab + 2 * (ptr ^ 0xffff);
+				pc = (type32) ptr + (type16s) read_w(effective(ptr));
+			}
+			else
+			{
+				push(pc);
+				pc = fl_sub;
+			}
+		}
+		break;
+
+	default:
+		ms_fatal("Constants aren't and variables don't");
+		break;
+	}
+#ifdef LOGEMU
+	fprintf(dbg_log, "\n");
+#endif
+	return running;
+}
diff -Nur Generic/.svn/text-base/games.txt.svn-base Generic.garg/.svn/text-base/games.txt.svn-base
--- Generic/.svn/text-base/games.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/games.txt.svn-base	2011-06-07 22:21:27.000000000 +0200
@@ -0,0 +1,67 @@
+
+Undo size values should go into the 4 bytes in the header (start of the file)
+beginning at 0x22. Undo PC values should go into the 4 bytes in the header
+beginning at 0x26.
+
+The patches column lists an offset from the start of the file and the new values
+for bytes from that offset. To get the offset from the start of the code section,
+subtract 0x2A. Patches are for copy protection unless noted otherwise.
+
+Game		Ver.	System		Undo size	Undo PC		Patches
+
+Corruption	1.11	Amstrad CPC	0x00002100	0x0000427E
+Corruption	1.11	Archimedes	0x00002100	0x000043A0
+Corruption	1.11	DOS		0x00002100	0x000043A0
+Corruption	1.11	Commodore 64	0x00002100	0x00004336
+Corruption	1.11	Spectrum +3	0x00002100	0x00004222
+Corruption	1.12	Archimedes	0x00002100	0x00004350
+Corruption	1.12	DOS (MagWin)	0x00002500	0x00006624
+
+Fish		1.02	DOS		0x00002300	0x00003FA0	0x00003A8E 4E 71
+Fish		1.03	Spectrum +3	0x00002400	0x00004364	0x000002A6 4E 71
+Fish		1.07	Commodore 64	0x00002300	0x00003F72	0x00003A6C 4E 71
+Fish		1.08	Archimedes	0x00002200	0x00003F9C	0x00003A8E 4E 71
+Fish		1.10	DOS (MagWin)	0x00002A00	0x0000583A
+
+Guild		1.0	Amstrad CPC	0x00005000	0x00006C30	0x00006BD6 4E 71
+Guild		1.0	Commodore 64	0x00005000	0x00006CAC	0x00006C52 4E 71
+									0x0000C042 4B FE (CD96 version)
+									0x0000DA08 3F 06 4E 71 (CD96 version)
+									0x0000DB7C 4B FE (CD96 version)
+Guild		1.1	DOS		0x00005000	0x00006D5C	0x00006D02 4E 71
+Guild		1.3	Archimedes	0x00003300	0x0000698A	0x00004D08 4E 71
+Guild		1.3	Spectrum +3	0x00003200	0x00006772
+Guild		1.3	DOS (MagWin)	0x00003400	0x00006528
+
+Jinxter		1.05	Commodore 64	0x00002B00	0x0000488C	0x00004310 4E 71
+									0x0000D212 58 (crash)
+Jinxter		1.05	DOS		0x00002C00	0x00004A08	0x00004484 4E 71
+									0x0000D29E 58 (crash)
+Jinxter		1.05	Spectrum +3	0x00002C00	0x0000487A	0x000042FE 4E 71
+									0x0000D0D4 58 (crash)
+Jinxter		1.10	DOS		0x00002C00	0x00004A56	0x000044CC 4E 71
+									0x0000D28A 58 (crash)
+Jinxter		1.22	Amstrad CPC	0x00002B00	0x00004924	0x000043A2 4E 71
+									0x0000D234 58 (crash)
+Jinxter		1.30	Archimedes	0x00002C00	0x00004960	0x0000D35A 58 (crash)
+
+Myth		1.0	Commodore 64	0x00001600	0x00003940	0x00003080 60
+									0x00003172 60 (alt protection fix)
+									0x00003177 11 (alt protection fix)
+Myth		1.0	DOS		0x00001500	0x00003A0A	0x0000314A 60
+
+Pawn		2.3	Amstrad CPC	0x00003600	0x000042CC	0x00003FBA 4E 71
+Pawn		2.3	Archimedes	0x00003600	0x00004420	0x000040F6 4E 71
+Pawn		2.3	Commodore 64	0x00003600	0x00003FB0	0x00003DE6 4E 71
+									0x00003628 00 (some Internet versions)
+									0x00003728 00 (some Internet versions)
+									0x00003828 00 (some Internet versions)
+									0x0000F9E0 86 (some Internet versions)
+									0x00017928 68 4B 8B E0 1E (Kronos' note)
+Pawn		2.3	DOS		0x00003600	0x00004420	0x000040F6 4E 71
+Pawn		2.3	Spectrum 128	0x00003900	0x000042E4	0x00005126 4E 71
+Pawn		2.4	Spectrum +3	0x00003900	0x000042F4	0x0000514E 4E 71
+
+Wonderland	1.21	DOS (MagWin)	0x00003900	0x000075F2	0x000067A2 4E 75
+Wonderland	1.27	Archimedes	0x00003900	0x000075F8	0x000067A6 4E 75
+
diff -Nur Generic/.svn/text-base/gfxlink2.c.svn-base Generic.garg/.svn/text-base/gfxlink2.c.svn-base
--- Generic/.svn/text-base/gfxlink2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/gfxlink2.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,446 @@
+
+/*
+    GfxLink2.c
+    Extracter for Magnetic Scrolls pictures (Wonderland
+    and the MS Collection Volume 1), Amiga versions.
+    Written by David Kinder.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+extern unsigned _stklen = 0x1000;
+#include <alloc.h>
+#define malloc farmalloc
+#define free farfree
+#endif
+
+#define BUFFER_SIZE 32UL*1024UL
+
+#define MS_WONDERLAND 1
+#define MS_COLLECTION 2
+
+struct OutputGfxFile
+{
+	char Name[8];
+	unsigned char Offset[4];
+	unsigned char Length[4];
+};
+
+struct GfxFile
+{
+	char Name[8];
+	unsigned long Offset;
+	unsigned long Length;
+};
+
+int Game = 0;
+struct GfxFile* GfxFiles = NULL;
+int GfxFileCount = 0;
+int GfxSubCount[3] = { 0, 0, 0 };
+unsigned char* Buffer1 = NULL;
+FILE* InputFile = NULL;
+FILE* OutputFile[3] = { NULL, NULL, NULL };
+unsigned long OutOffset[3] = { 0, 0, 0 };
+
+void WriteLong(unsigned char* p, unsigned long v)
+{
+	p[3] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[2] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+void WriteShort(unsigned char* p, unsigned short v)
+{
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+unsigned long ReadLong(unsigned char *ptr)
+{
+	return ((unsigned long)ptr[1]) << 24 |
+	       ((unsigned long)ptr[0]) << 16 |
+	       ((unsigned long)ptr[3]) <<  8 |
+	       ((unsigned long)ptr[2]);
+}
+
+unsigned short ReadShort(unsigned char *ptr)
+{
+	return (unsigned short)(ptr[1]<<8 | ptr[0]);
+}
+
+void CleanUp(void)
+{
+	int i;
+
+	if (InputFile)
+		fclose(InputFile);
+	for (i = 0; i < 3; i++)
+	{
+		if (OutputFile[i])
+			fclose(OutputFile[i]);
+	}
+	if (GfxFiles)
+		free(GfxFiles);
+	if (Buffer1)
+		free(Buffer1);
+}
+
+void Error(const unsigned char *pError)
+{
+	fprintf(stderr,"Fatal Error: %s\n",pError);
+	CleanUp();
+	exit(1);
+}
+
+unsigned long ReadFile(unsigned char* buf, unsigned long* offset, unsigned long sz)
+{
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+	unsigned long n = 0xF000, i, j = 0;
+
+	fseek(InputFile,*offset,SEEK_SET);
+	for (i = 0; i < sz; i += n)
+	{
+		if (sz-i < 0xF000)
+			n = sz - i;
+		j += fread(buf+i,1,n,InputFile);
+	}
+	*offset += sz;
+	return j;
+#else
+	fseek(InputFile,*offset,SEEK_SET);
+	*offset += sz;
+	return fread(buf,1,sz,InputFile);
+#endif
+}
+
+unsigned long WriteFile(unsigned char* buf, unsigned long sz, int file)
+{
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+	unsigned long n = 0xF000, i, j = 0;
+
+	for (i = 0; i < sz; i += n)
+	{
+		if (sz-i < 0xF000)
+			n = sz - i;
+		j += fwrite(buf+i,1,n,OutputFile[file]);
+	}
+	return j;
+#else
+	return fwrite(buf,1,sz,OutputFile[file]);
+#endif
+}
+
+void OpenFile(const char* pszName)
+{
+	unsigned char buffer[4];
+	unsigned long offset = 0;
+	unsigned long id = 0;
+
+	if ((InputFile = fopen(pszName,"rb")) == NULL)
+		Error("Cannot open resource file");
+
+	ReadFile(buffer,&offset,4);
+	id = ReadLong(buffer);
+	switch (id)
+	{
+	case 0xA34F0026:
+		Game = MS_WONDERLAND;
+		printf("Wonderland detected\n");
+		break;
+	case 0x7D140021:
+		Game = MS_COLLECTION;
+		printf("Collection Volume 1 detected\n");
+		break;
+	default:
+		Error("Game not recognised");
+		break;
+	}
+}
+
+void FindResourceNames(void)
+{
+	unsigned char buffer[32];
+	unsigned long offset = 0;
+	int count, i = 0;
+
+	ReadFile(buffer,&offset,4);
+	offset = ((long)buffer[0] <<  0) |
+	         ((long)buffer[1] <<  8) |
+	         ((long)buffer[2] << 16) |
+	         ((long)buffer[3] << 24);
+	ReadFile(buffer,&offset,2);
+	count = ((int)buffer[0] << 0) |
+	        ((int)buffer[1] << 8);
+
+	GfxFiles = calloc(count,sizeof(struct GfxFile));
+
+	for (i = 0; i < count; i++)
+	{
+		char name[8];
+		unsigned long o, l;
+		unsigned int n;
+		int j;
+
+		ReadFile(buffer,&offset,18);
+		o = ((long)buffer[2] <<  0) |
+		    ((long)buffer[3] <<  8) |
+		    ((long)buffer[4] << 16) |
+		    ((long)buffer[5] << 24);
+		l = ((long)buffer[6] <<  0) |
+		    ((long)buffer[7] <<  8) |
+		    ((long)buffer[8] << 16) |
+		    ((long)buffer[9] << 24);
+		n = ((unsigned)buffer[16] << 0) |
+		    ((unsigned)buffer[17] << 8);
+
+		if (n == 11)
+		{
+			for (j = 0; (j < 6) && (buffer[10+j] != 0); j++)
+				name[j] = buffer[10+j];
+			name[j] = 0;
+
+			strcpy(GfxFiles[GfxFileCount].Name,name);
+			GfxFiles[GfxFileCount].Offset = o;
+			GfxFiles[GfxFileCount].Length = l;
+
+			/* Corrections for specific pictures */
+			if (Game == MS_WONDERLAND)
+			{
+				if (strcmp(name,"frog") == 0)
+					GfxFiles[GfxFileCount].Length += 128UL*1024UL;
+				else if (strcmp(name,"croque") == 0)
+					GfxFiles[GfxFileCount].Length += 128UL*1024UL;
+			}
+
+			GfxFileCount++;
+		}
+	}
+}
+
+void WriteGfxHeader1(void)
+{
+	struct OutputGfxFile out;
+	unsigned char zeros[2] = { 0,0 };
+	int i;
+
+	switch (Game)
+	{
+	case MS_WONDERLAND:
+		if ((OutputFile[0] = fopen("wonder.gfx","wb")) == NULL)
+			Error("Cannot open output file");
+
+		WriteFile("MaP2",4,0);
+		OutOffset[0] += 4;
+
+		WriteFile(zeros,2,0);
+		OutOffset[0] += 2;
+
+		memset(&out,0,sizeof(struct OutputGfxFile));
+		for (i = 0; i < GfxFileCount; i++)
+			WriteFile((unsigned char*)&out,sizeof(struct OutputGfxFile),0);
+		OutOffset[0] += (GfxFileCount * sizeof(struct OutputGfxFile));
+		break;
+	case MS_COLLECTION:
+		if ((OutputFile[0] = fopen("corrupt.gfx","wb")) == NULL)
+			Error("Cannot open output file");
+		if ((OutputFile[1] = fopen("fish.gfx","wb")) == NULL)
+			Error("Cannot open output file");
+		if ((OutputFile[2] = fopen("guild.gfx","wb")) == NULL)
+			Error("Cannot open output file");
+
+		for (i = 0; i < 3; i++)
+		{
+			WriteFile("MaP2",4,i);
+			OutOffset[i] += 4;
+
+			WriteFile(zeros,2,i);
+			OutOffset[i] += 2;
+		}
+
+		memset(&out,0,sizeof(struct OutputGfxFile));
+		for (i = 0; i < GfxFileCount; i++)
+		{
+			int game = -1;
+
+			if (tolower(GfxFiles[i].Name[0]) == 'c')
+				game = 0;
+			else if (tolower(GfxFiles[i].Name[0]) == 'f')
+				game = 1;
+			else if (tolower(GfxFiles[i].Name[0]) == 'g')
+				game = 2;
+
+			if (game >= 0)
+			{
+				WriteFile((unsigned char*)&out,sizeof(struct OutputGfxFile),game);
+				OutOffset[game] += sizeof(struct OutputGfxFile);
+				GfxSubCount[game]++;
+			}
+		}
+		break;
+	}
+}
+
+void WriteGfxFile(int Index)
+{
+	unsigned long position = 0;
+	unsigned long offset, length, patch_offset[2];
+	unsigned char patch_bytes[2];
+	int game = -1, patch_count = 0, i;
+
+	switch (Game)
+	{
+	case MS_WONDERLAND:
+		game = 0;
+		if (strcmp(GfxFiles[Index].Name,"rablan") == 0)
+		{
+			patch_offset[0] = 0x1ED0;
+			patch_bytes[0] = 0xD0;
+			patch_offset[1] = 0x1ED1;
+			patch_bytes[1] = 0x5E;
+			patch_count = 2;
+		}
+		else if (strcmp(GfxFiles[Index].Name,"rbrige") == 0)
+		{
+			patch_offset[0] = 0x47E8;
+			patch_bytes[0] = 0x00;
+			patch_count = 1;
+		}
+		break;
+	case MS_COLLECTION:
+		if (tolower(GfxFiles[Index].Name[0]) == 'c')
+			game = 0;
+		else if (tolower(GfxFiles[Index].Name[0]) == 'f')
+			game = 1;
+		else if (tolower(GfxFiles[Index].Name[0]) == 'g')
+			game = 2;
+		break;
+	}	
+
+	if (game >= 0)
+	{
+		while (position < GfxFiles[Index].Length)
+		{
+			offset = GfxFiles[Index].Offset + position;
+			length = GfxFiles[Index].Length - position;
+			if (length > BUFFER_SIZE)
+				length = BUFFER_SIZE;
+			ReadFile(Buffer1,&offset,length);
+
+			for (i = 0; i < patch_count; i++)
+			{
+				if ((position <= patch_offset[i]) && (position + length > patch_offset[i]))
+					Buffer1[patch_offset[i] - position] = patch_bytes[i];
+			}
+
+			WriteFile(Buffer1,length,game);
+			position += length;
+		}
+	}
+}
+
+void WriteGfxFiles(void)
+{
+	int i;
+
+	Buffer1 = malloc(BUFFER_SIZE);
+	if (Buffer1 == NULL)
+		Error("Not enough memory");
+
+	for (i = 0; i < GfxFileCount; i++)
+		WriteGfxFile(i);
+}
+
+void WriteGfxHeader2(void)
+{
+	struct OutputGfxFile out;
+	unsigned char header_size[2];
+	int i, pos, game = -1;
+	int table[3] = { 0, 0, 0 };
+
+	switch (Game)
+	{
+	case MS_WONDERLAND:
+		fseek(OutputFile[0],4,SEEK_SET);
+		WriteShort(header_size,(unsigned short)(GfxFileCount * sizeof(struct OutputGfxFile)));
+		WriteFile(header_size,2,0);
+		break;
+	case MS_COLLECTION:
+		for (i = 0; i < 3; i++)
+		{
+			fseek(OutputFile[i],4,SEEK_SET);
+			WriteShort(header_size,(unsigned short)(GfxSubCount[i] * sizeof(struct OutputGfxFile)));
+			WriteFile(header_size,2,i);
+		}
+		break;
+	}
+
+	for (i = 0; i < GfxFileCount; i++)
+	{
+		switch (Game)
+		{
+		case MS_WONDERLAND:
+			game = 0;
+			break;
+		case MS_COLLECTION:
+			if (tolower(GfxFiles[i].Name[0]) == 'c')
+				game = 0;
+			else if (tolower(GfxFiles[i].Name[0]) == 'f')
+				game = 1;
+			else if (tolower(GfxFiles[i].Name[0]) == 'g')
+				game = 2;
+			break;
+		}	
+
+		if (game >= 0)
+		{
+			memset(&out,0,sizeof(struct OutputGfxFile));
+			strcpy(out.Name,GfxFiles[i].Name);
+			WriteLong(out.Offset,OutOffset[game]);
+			WriteLong(out.Length,GfxFiles[i].Length);
+
+			pos = 6 + (table[game] * sizeof(struct OutputGfxFile));
+			fseek(OutputFile[game],pos,SEEK_SET);
+			WriteFile((unsigned char*)&out,sizeof(struct OutputGfxFile),game);
+
+			OutOffset[game] += GfxFiles[i].Length;
+			table[game]++;
+		}
+	}
+}
+
+int main(int argc, char** argv)
+{
+	if (argc == 2)
+	{
+		OpenFile(argv[1]);
+		FindResourceNames();
+		WriteGfxHeader1();
+		WriteGfxFiles();
+		WriteGfxHeader2();
+		CleanUp();
+		printf("Graphics extracted successfully");
+	}
+	else
+	{
+		printf("GfxLink2 v1.0 by David Kinder.\n\n"
+		       "Extractor for the pictures in the Magnetic Windows versions of\n"
+		       "Magnetic Scrolls games (Wonderland and the MS Collection Volume 1),\n"
+		       "Amiga versions.\n\n"
+		       "Usage: GfxLink2 user.rsc\n\n"
+		       "\"user.rsc\" is taken from an Amiga Magnetic Scrolls installation\n"
+		       "in which the option to expand all the graphics files has been\n"
+		       "selected. For Wonderland there is only one output file\n"
+		       "(\"wonder.gfx\"), for the Collection there are three (\"corrupt.gfx\",\n"
+		       "\"fish.gfx\" and \"guild.gfx\").\n");
+	}
+	return 0;
+}
+
diff -Nur Generic/.svn/text-base/gfxlink.c.svn-base Generic.garg/.svn/text-base/gfxlink.c.svn-base
--- Generic/.svn/text-base/gfxlink.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/gfxlink.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,305 @@
+#define PRGNAME "gfxlink"
+#define PRGVERSION "1.5"
+
+/*
+   gfxlink.c
+
+   - combines Magnetic Scrolls picture files (Amiga format)
+     to gfxfile (compatible with the MAG interpreter)
+   - does not currently work with Collection & Wonderland pictures
+
+   Author: Paul David Doherty <h0142kdd@rz.hu-berlin.de>
+
+   v1.0:  12 Feb 1997
+   v1.1:  17 Apr 1997  Amigafied & cleverised
+   v1.2:  19 Apr 1997  itoa() replaced
+   v1.3:  22 Apr 1997  cleaned up; name changed to 'gfxlink'
+   v1.4:   8 May 1997  might even work under UNIX now
+   v1.5:  25 Nov 1997  UNIX fixes supplied by Robert Bihlmeyer
+ */
+
+#if defined(AZTEC_C) || defined(LATTICE)
+#define AMIGA
+#endif
+
+#define FILENAMELENGTH 256
+#define MAXPICTURES 35
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <ctype.h>
+#ifdef __TURBOC__
+#include <io.h>
+#include <sys\stat.h>
+#define S_IRUSR S_IREAD
+#define S_IWUSR S_IWRITE
+#endif
+#ifdef __GNUC__
+#include <sys/stat.h>
+#endif
+#ifndef S_IRUSR
+#define S_IRUSR 0400
+#define S_IWUSR 0200
+#endif
+
+#if defined(__TURBOC__) || defined(__GNUC__) && !defined(__unix__)
+#define O_SCRIVERE O_WRONLY|O_BINARY
+#define O_LEGGERE O_RDONLY|O_BINARY
+#else
+#define O_SCRIVERE O_WRONLY
+#define O_LEGGERE O_RDONLY
+#endif
+
+#define TRUE 1
+#define FALSE 0
+
+#ifdef __TURBOC__
+#define DIRSEP "\\"
+#else
+#define DIRSEP "/"
+#endif
+
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if SHRT_MAX==0x7fff
+typedef unsigned short type16;
+#elif INT_MAX==0x7fff
+typedef unsigned int type16;
+#else
+#error "Can't find a 16-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
+int fdi, fdo_temp, fdo_gfx;
+char infilemask[FILENAMELENGTH];
+char infile[FILENAMELENGTH];
+char gfxfile[FILENAMELENGTH];
+char picnum[5];
+
+#ifdef AMIGA
+#define TEMPFILE "ram:pics.tmp"
+#else
+#define TEMPFILE "pics.tmp"
+#endif
+
+char *magic = "MaPi";
+
+type8 inputbuf[256];
+type8 endfile_reached = FALSE;
+type8 offsetcounter = 1;
+type8 detected;
+type16 buflength;
+type32 offset[MAXPICTURES + 2];
+type32 addoffset;
+type32 partlength;
+type32 alllength;
+
+struct lookuptab
+  {
+    char *game;
+    char *filemask;
+    type16 par[10];
+  }
+lookup[] =
+{
+  "The Pawn", "Pawn",
+    1, 15, 17, 21, 23, 25, 27, 30, 32, 34,
+    "The Pawn", "pawn",
+    1, 15, 17, 21, 23, 25, 27, 30, 32, 34,
+    "The Pawn", "ThePawn/Pawn",
+    1, 15, 17, 21, 23, 25, 27, 30, 32, 34,
+    "The Guild of Thieves", "guild",
+    4, 32, 0, 0, 0, 0, 0, 0, 0, 0,
+    "The Guild of Thieves", "The Guild Of Thieves/guild",
+    4, 32, 0, 0, 0, 0, 0, 0, 0, 0,
+    "Jinxter", "j",
+    3, 30, 73, 73, 0, 0, 0, 0, 0, 0,
+    "Corruption", "c",
+    16, 37, 41, 41, 38, 40, 0, 0, 0, 0,
+    "Fish!", "f",
+    14, 40, 0, 0, 0, 0, 0, 0, 0, 0,
+    "Myth", "m",
+    16, 19, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+void
+write_32 (type32 numb)
+{
+  inputbuf[3] = numb & 0xff;
+  numb >>= 8;
+  inputbuf[2] = numb & 0xff;
+  numb >>= 8;
+  inputbuf[1] = numb & 0xff;
+  numb >>= 8;
+  inputbuf[0] = numb;
+  write (fdo_gfx, inputbuf, 4);
+}
+
+void
+ex (char *error)
+{
+  fprintf (stderr, PRGNAME ": %s\n", error);
+  close (fdi);
+  close (fdo_temp);
+  close (fdo_gfx);
+  remove (TEMPFILE);
+  exit (1);
+}
+
+void
+itoa_krns (type16 n, char s[])
+{
+  int k, l, m;
+  k = 0;
+  do
+    {
+      s[k++] = n % 10 + '0';
+    }
+  while ((n /= 10) > 0);
+  s[k] = '\0';
+  for (k = 0, l = strlen (s) - 1; k < l; k++, l--)
+    {
+      m = s[k];
+      s[k] = s[l];
+      s[l] = m;
+    }
+}
+
+void
+kick (type16 picnumber)
+{
+  itoa_krns (picnumber, picnum);
+  strcpy (infile, infilemask);
+  strcat (infile, picnum);
+
+  if ((fdi = open (infile, O_LEGGERE, 0)) == -1)
+    {
+      printf ("File not found: %s\n", infile);
+      ex ("picture file(s) missing; can't create gfxfile");
+    }
+  else
+    {
+      endfile_reached = FALSE;
+      partlength = 0;
+      while (endfile_reached == FALSE)
+	{
+	  buflength = read (fdi, inputbuf, 256);
+	  if (buflength != 256)
+	    endfile_reached = TRUE;
+	  write (fdo_temp, inputbuf, (int) buflength);
+	  partlength = partlength + buflength;
+	}
+      offset[offsetcounter] = offset[offsetcounter - 1] + partlength;
+      offsetcounter++;
+    }
+  close (fdi);
+}
+
+void
+usage (void)
+{
+  fprintf (stderr, PRGNAME " v" PRGVERSION ": ");
+  fprintf (stderr, "creates Magnetic Scrolls graphics file.\n");
+  fprintf (stderr, "(c) 1997 by Paul David Doherty <h0142kdd@rz.hu-berlin.de>\n\n");
+  fprintf (stderr, "Usage: " PRGNAME " [path] gfxfile\n");
+  fprintf (stderr, "  e.g. " PRGNAME " df0: pawn.gfx\n");
+  exit (1);
+}
+
+int
+main (int argc, char **argv)
+{
+  int i, j;
+
+  if ((argc < 2) || (argc > 3))
+    usage ();
+
+  strcpy (gfxfile, argv[(argc == 2) ? 1 : 2]);
+  if (argc == 3)
+    {
+      strcpy (infilemask, argv[1]);
+      if ((infilemask[strlen (infilemask) - 1] != ':')
+	  && (infilemask[strlen (infilemask) - 1] != '/')
+	  && (infilemask[strlen (infilemask) - 1] != '\\'))
+	strcat (infilemask, DIRSEP);
+    }
+
+/* detection */
+  for (i = 0; i < (sizeof (lookup) / sizeof (struct lookuptab)); i++)
+    {
+      itoa_krns (lookup[i].par[1], picnum);
+      strcpy (infile, infilemask);
+      strcat (infile, lookup[i].filemask);
+      strcat (infile, picnum);
+      if ((fdi = open (infile, O_LEGGERE, 0)) != -1)
+	break;
+    }
+  detected = i;
+  if (detected >= (sizeof (lookup) / sizeof (struct lookuptab)))
+      ex ("no picture files detected");
+  close (fdi);
+  printf ("Game detected: %s\n", lookup[detected].game);
+
+/* generation of temp file & offsets */
+  if ((fdo_temp = open (TEMPFILE,
+		  O_SCRIVERE | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)) == -1)
+    ex ("could not create temp file");
+
+  offset[0] = 0;
+  strcat (infilemask, lookup[detected].filemask);
+  for (i = 0; i <= 8; i = i + 2)
+    for (j = lookup[detected].par[i]; j <= lookup[detected].par[i + 1]; j++)
+      if (j != 0)
+	kick ((type16) j);
+  close (fdo_temp);
+  offsetcounter--;
+  printf ("Number of pictures: %d\n", offsetcounter);
+
+/* writing offsets into gfx file */
+  if ((fdo_gfx = open (gfxfile,
+		  O_SCRIVERE | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR)) == -1)
+    ex ("could not create output file");
+
+  addoffset = (((offsetcounter + 2) * 4) + strlen (magic));
+  for (i = 0; i < offsetcounter; i++)
+    offset[i] = offset[i] + addoffset;
+  alllength = offset[offsetcounter] + addoffset;
+  offset[offsetcounter] = 0;
+  write (fdo_gfx, magic, strlen (magic));
+  write_32 (alllength);
+  for (i = 0; i <= offsetcounter; i++)
+    write_32 (offset[i]);
+
+/* copying tempfile into gfx file */
+  if ((fdi = open (TEMPFILE, O_LEGGERE, 0)) == -1)
+    ex ("could not reopen temp file");
+
+  endfile_reached = FALSE;
+  while (endfile_reached == FALSE)
+    {
+      buflength = read (fdi, inputbuf, 256);
+      if (buflength != 256)
+	endfile_reached = TRUE;
+      write (fdo_gfx, inputbuf, (int) buflength);
+    }
+  close (fdi);
+  close (fdo_gfx);
+  if (remove (TEMPFILE) != 0)
+    ex ("couldn't delete temp file");
+  return 0;
+}
diff -Nur Generic/.svn/text-base/hintlink.c.svn-base Generic.garg/.svn/text-base/hintlink.c.svn-base
--- Generic/.svn/text-base/hintlink.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/hintlink.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,215 @@
+
+/*
+    hintlink.c
+    Extracter for Magnetic Scrolls hints (Wonderland
+    and the MS Collection Volume 1), Amiga versions.
+    Written by Stefan Meier.
+*/
+
+#include <io.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+extern unsigned _stklen = 0x1000;
+#include <alloc.h>
+#define malloc farmalloc
+#define free farfree
+#endif
+
+#define TXTBUFFER_SIZE 32UL*1024UL
+#define INDBUFFER_SIZE 8UL*1024UL
+
+int Game = 0;
+FILE* txtFile;
+FILE* indexFile;
+unsigned char* BufferTxt = NULL;
+unsigned char* BufferIndex = NULL;
+FILE* OutputFile = NULL;
+unsigned long OutOffset = 0;
+
+void WriteLong(unsigned char* p, unsigned long v)
+{
+	p[3] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[2] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+void WriteShort(unsigned char* p, unsigned short v)
+{
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+unsigned long ReadLong(unsigned char *ptr)
+{
+	return ((unsigned long)ptr[1]) << 24 |
+	       ((unsigned long)ptr[0]) << 16 |
+	       ((unsigned long)ptr[3]) <<  8 |
+	       ((unsigned long)ptr[2]);
+}
+
+unsigned short ReadShort(unsigned char *ptr)
+{
+	return (unsigned short)(ptr[1]<<8 | ptr[0]);
+}
+
+void CleanUp(void)
+{
+	if (txtFile)
+		fclose(txtFile);
+	if (indexFile)
+		fclose(indexFile);
+	if (OutputFile)
+		fclose(OutputFile);
+	if (BufferTxt)
+		free(BufferTxt);
+	if (BufferIndex)
+		free(BufferIndex);
+}
+
+void Error(const unsigned char *pError)
+{
+	fprintf(stderr,"Fatal Error: %s\n",pError);
+	CleanUp();
+	exit(1);
+}
+
+unsigned long ReadFile(FILE* target, unsigned char* buf,unsigned long sz)
+{
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+	unsigned long n = 0xF000, i, j = 0;
+
+	fseek(target,0,SEEK_SET);
+	for (i = 0; i < sz; i += n)
+	{
+		if (sz-i < 0xF000)
+			n = sz - i;
+		j += fread(buf+i,1,n,InputFile);
+	}
+	return j;
+#else
+	fseek(target,0,SEEK_SET);
+	return (unsigned long)fread(buf,sz,1,target);
+#endif
+}
+
+unsigned long WriteFile(unsigned char* buf, unsigned long sz)
+{
+#if defined(__MSDOS__) && defined(__BORLANDC__)
+	unsigned long n = 0xF000, i, j = 0;
+
+	for (i = 0; i < sz; i += n)
+	{
+		if (sz-i < 0xF000)
+			n = sz - i;
+		j += fwrite(buf+i,1,n,OutputFile);
+	}
+	return j;
+#else
+	return (unsigned long)fwrite(buf,1,sz,OutputFile);
+#endif
+}
+
+
+void WriteHintHeader(char * filename)
+{
+//	struct OutputHintFile out;
+
+	if ((OutputFile = fopen(filename,"wb")) == NULL)
+		Error("Cannot open output file");
+
+	WriteFile("MaHt",4);
+	OutOffset += 4;
+}
+
+void BuildAndWriteHints(void)
+{
+   char * iWalker;
+   unsigned int blkcount,elcnt,ityp,i,j,offset,tlength;
+   iWalker = BufferIndex;
+   blkcount = ReadShort(iWalker);
+   WriteFile(iWalker,2);
+   iWalker += 2;
+   for (i=0; i < blkcount; i++) {
+
+	  // number of elements in this block
+	  elcnt = ReadShort(iWalker);
+      WriteFile(iWalker,2);
+      iWalker += 2;
+      ityp = ReadShort(iWalker);
+      WriteFile(iWalker,2);
+      iWalker += 2;
+      for (j=0; j < elcnt; j++) {
+         offset = ReadShort(iWalker);
+		 iWalker += 2;
+   	     tlength = ReadShort( BufferTxt+offset );
+         WriteFile(BufferTxt+offset,2);
+		 WriteFile(BufferTxt+offset+2,tlength);
+   	  }
+      if (	ityp == 1 ) {
+		  WriteFile(iWalker, elcnt*2);
+		  iWalker += elcnt*2;
+   	  }
+	  WriteFile(iWalker, 2);
+	  iWalker += 2;
+   }
+   
+}
+
+void WriteHintFile(void)
+{
+	BufferTxt = malloc(TXTBUFFER_SIZE);
+	if (BufferTxt == NULL)
+		Error("Not enough memory");
+
+    // load Text file
+	ReadFile(txtFile,BufferTxt,TXTBUFFER_SIZE);
+
+	BufferIndex = malloc(INDBUFFER_SIZE);
+	if (BufferIndex == NULL)
+		Error("Not enough memory");
+
+    // load index file
+	ReadFile(indexFile,BufferIndex,INDBUFFER_SIZE);
+
+	BuildAndWriteHints();
+}
+
+void OpenFiles( char * iFile, char * tFile) {
+
+	if ((indexFile = fopen(iFile,"rb")) == NULL)
+		Error("Cannot open index file");
+
+	if ((txtFile = fopen(tFile,"rb")) == NULL)
+		Error("Cannot open txt file");
+}
+
+
+int main(int argc, char** argv)
+{
+	if (argc == 4)
+	{
+		OpenFiles(argv[1],argv[2]);
+		WriteHintHeader(argv[3]);
+		WriteHintFile();
+		CleanUp();
+		printf("Hints extracted successfully");
+	}
+	else
+	{
+		printf("HintLink v1.0 by Stefan Meier.\n\n"
+		       "Extractor for the hints in the Magnetic Windows versions of\n"
+		       "Magnetic Scrolls games (Wonderland and the MS Collection Volume 1).\n"
+		       "Usage: HintLink index text result\n\n");
+	}
+	return 0;
+}
+
diff -Nur Generic/.svn/text-base/main.c.svn-base Generic.garg/.svn/text-base/main.c.svn-base
--- Generic/.svn/text-base/main.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/main.c.svn-base	2011-10-04 11:35:14.000000000 +0200
@@ -0,0 +1,382 @@
+/****************************************************************************\
+*
+* Magnetic - Magnetic Scrolls Interpreter.
+*
+* Written by Niclas Karlsson <nkarlsso@abo.fi>,
+*            David Kinder <davidk.kinder@virgin.net>,
+*            Stefan Meier <Stefan.Meier@if-legends.org> and
+*            Paul David Doherty <pdd@if-legends.org>
+*
+* Copyright (C) 1997-2008  Niclas Karlsson
+*
+*     This program is free software; you can redistribute it and/or modify
+*     it under the terms of the GNU General Public License as published by
+*     the Free Software Foundation; either version 2 of the License, or
+*     (at your option) any later version.
+*
+*     This program is distributed in the hope that it will be useful,
+*     but WITHOUT ANY WARRANTY; without even the implied warranty of
+*     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*     GNU General Public License for more details.
+*
+*     You should have received a copy of the GNU General Public License
+*     along with this program; if not, write to the Free Software
+*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*     Simple ANSI interface main.c
+*
+\****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "defs.h"
+
+#define WIDTH 78
+
+type8 buffer[80], xpos = 0, bufpos = 0, log_on = 0, ms_gfx_enabled, filename[256];
+FILE *log1 = 0, *log2 = 0;
+
+type8 ms_load_file(type8s *name, type8 *ptr, type16 size)
+{
+	FILE *fh;
+	type8s *realname;
+
+	if (name)
+		realname = name;
+	else
+	{
+		do
+		{
+			printf("Filename: ");
+		}
+		while (!gets(filename));
+		realname = filename;
+	}
+	if (!(fh=fopen(realname,"rb")))
+		return 1;
+	if (fread(ptr,1,size,fh) != size)
+		return 1;
+	fclose(fh);
+	return 0;
+}
+
+type8 ms_save_file(type8s *name, type8 *ptr, type16 size)
+{
+	FILE *fh;
+	type8s *realname;
+
+	if (name)
+		realname = name;
+	else
+	{
+		do
+		{
+			printf("Filename: ");
+		}
+		while (!gets(filename));
+		realname = filename;
+	}
+	if (!(fh = fopen(realname,"wb")))
+		return 1;
+	if (fwrite(ptr,1,size,fh) != size)
+		return 1;
+	fclose(fh);
+	return 0;
+}
+
+void script_write(type8 c)
+{
+	if (log_on == 2 && fputc(c,log1) == EOF)
+	{
+		printf("[Problem with script file - closing]\n");
+		fclose(log1);
+		log_on = 0;
+	}
+}
+
+void transcript_write(type8 c)
+{
+	if (log2 && c == 0x08 && ftell(log2) > 0)
+		fseek(log2,-1,SEEK_CUR);
+	else if (log2 && fputc(c,log2) == EOF)
+	{
+		printf("[Problem with transcript file - closing]\n");
+		fclose(log2);
+		log2 = 0;
+	}
+}
+
+void ms_statuschar(type8 c)
+{
+	static type8 x=0;
+
+	if (c == 0x09)
+	{
+		while (x + 11 < WIDTH)
+		{
+			putchar(0x20);
+			x++;
+		}
+		return;
+	}
+	if (c == 0x0a)
+	{
+		x = 0;
+		putchar(0x0a);
+		return;
+	}
+	printf("\x1b[32m%c\x1b[31m",c);
+	x++;
+}
+
+void ms_flush(void)
+{
+	type8 j;
+
+	if (!bufpos)
+		return;
+	if (xpos + bufpos > WIDTH)
+	{
+		putchar(0x0a);
+		transcript_write(0x0a);
+		xpos = 0;
+	}
+	for (j = 0; j < bufpos; j++)
+	{
+		if (buffer[j] == 0x0a)
+			xpos = 0;
+		if (buffer[j] == 0x08)
+			xpos -= 2;
+		putchar(buffer[j]);
+		transcript_write(buffer[j]);
+		xpos++;
+	}
+	bufpos = 0;
+}
+
+void ms_putchar(type8 c)
+{
+/*
+	if (c == 0x08)
+	{
+		if (bufpos > 0)
+			bufpos--;
+		return;
+	}
+*/
+	buffer[bufpos++] = c;
+	if ((c == 0x20) || (c == 0x0a) || (bufpos >= 80))
+		ms_flush();
+}
+
+type8 ms_getchar(type8 trans)
+{
+	static type8 buf[256];
+	static type16 pos=0;
+	int c;
+	type8 i;
+
+	if (!pos)
+	{
+		/* Read new line? */
+		i = 0;
+		while (1)
+		{
+			if (log_on == 1)
+			{
+				/* Reading from logfile */
+				if ((c = fgetc(log1)) == EOF)
+				{
+					/* End of log? - turn off */
+					log_on = 0;
+					fclose(log1);
+					c = getchar();
+				}
+				else printf("%c",c); /* print the char as well */
+			}
+			else
+			{
+				c = getchar();
+				if (c == '#' && !i && trans)
+				{
+					/* Interpreter command? */
+					while ((c = getchar()) != '\n' && c != EOF && i < 255)
+						buf[i++] = c;
+					buf[i] = 0;
+					c = '\n'; /* => Prints new prompt */
+					i = 0;
+					if (!strcmp(buf,"logoff") && log_on == 2)
+					{
+						printf("[Closing script file]\n");
+						log_on = 0;
+						fclose(log1);
+					}
+					else if (!strcmp(buf,"undo"))
+						c = 0;
+					else
+						printf("[Nothing done]\n");
+				}
+			}
+			script_write((type8)c);
+			if (c != '\n')
+				transcript_write((type8)c);
+			if (c == '\n' || c == EOF || i == 255)
+				break;
+			buf[i++] = c;
+			if (!c)
+				break;
+		}
+		buf[i] = '\n';
+	}
+	if ((c = buf[pos++]) == '\n' || !c)
+		pos = 0;
+	return (type8)c;
+}
+
+void ms_showpic(type32 c,type8 mode)
+{
+/* Insert your favourite picture viewing code here
+   mode: 0 gfx off, 1 gfx on (thumbnails), 2 gfx on (normal) */
+
+/*
+	printf("Display picture [%d]\n",c);
+*/
+
+/* Small bitmap retrieving example */
+
+/*
+	{
+		type16 w, h, pal[16];
+		type8 *raw = 0, i;
+
+		raw = ms_extract(c,&w,&h,pal,0);
+		printf("\n\nExtract: [%d] %dx%d",c,w,h);
+		for (i = 0; i < 16; i++)
+			printf(", %3.3x",pal[i]);
+		printf("\n");
+		printf("Bitmap at: %8.8x\n",raw);
+	}
+*/
+}
+
+void ms_fatal(type8s *txt)
+{
+	fputs("\nFatal error: ",stderr);
+	fputs(txt,stderr);
+	fputs("\n",stderr);
+	ms_status();
+	exit(1);
+}
+
+type8 ms_showhints(struct ms_hint * hints)
+{
+	return 0;
+}
+
+void ms_playmusic(type8 * midi_data, type32 length, type16 tempo)
+{
+}
+
+main(int argc, char **argv)
+{
+	type8 running, i, *gamename = 0, *gfxname = 0, *hintname = 0;
+	type32 dlimit, slimit;
+
+	if (sizeof(type8) != 1 || sizeof(type16) != 2 || sizeof(type32) != 4)
+	{
+		fprintf(stderr,
+			"You have incorrect typesizes, please edit the typedefs and recompile\n"
+			"or proceed on your own risk...\n");
+		exit(1);
+	}
+	dlimit = slimit = 0xffffffff;
+	for (i = 1; i < argc; i++)
+	{
+		if (argv[i][0] == '-')
+		{
+			switch (tolower(argv[i][1]))
+			{
+			case 'd':
+				if (strlen(argv[i]) > 2)
+					dlimit = atoi(&argv[i][2]);
+				else
+					dlimit = 0;
+				break;
+			case 's':
+				if (strlen(argv[i])>2)
+					slimit = atoi(&argv[i][2]);
+				else
+					slimit = 655360;
+				break;
+			case 't':
+				if (!(log2 = fopen(&argv[i][2],"w")))
+					printf("Failed to open \"%s\" for writing.\n",&argv[i][2]);
+				break; 
+			case 'r':
+				if (log1 = fopen(&argv[i][2],"r"))
+					log_on = 1;
+				else
+					printf("Failed to open \"%s\" for reading.\n",&argv[i][2]);
+				break;
+			case 'w':
+				if (log1 = fopen(&argv[i][2],"w"))
+					log_on = 2;
+				else
+					printf("Failed to open \"%s\" for writing.\n",&argv[i][2]);
+				break;
+			default:
+				printf("Unknown option -%c, ignoring.\n",argv[i][1]);
+				break;
+			}
+		}
+		else if (!gamename)
+			gamename = argv[i];
+		else if (!gfxname)
+			gfxname = argv[i];
+		else if (!hintname)
+			hintname = argv[i];
+	}
+	if (!gamename)
+	{
+		printf("Magnetic 2.3 - a Magnetic Scrolls interpreter\n\n");
+		printf("Usage: %s [options] game [gfxfile] [hintfile]\n\n"
+			"Where the options are:\n"
+			" -dn    activate register dump (after n instructions)\n"
+			" -rname read script file\n"
+			" -sn    safety mode, exits automatically (after n instructions)\n"
+			" -tname write transcript file\n"
+			" -wname write script file\n\n"
+			"The interpreter commands are:\n"
+			" #undo   undo - don't use it near are_you_sure prompts\n"
+			" #logoff turn off script writing\n\n",argv[0]);
+		exit(1);
+	}
+
+	if (!(ms_gfx_enabled = ms_init(gamename,gfxname,hintname,0)))
+	{
+		printf("Couldn't start up game \"%s\".\n",gamename);
+		exit(1);
+	}
+	ms_gfx_enabled--;
+	running = 1;
+	while ((ms_count() < slimit) && running)
+	{
+		if (ms_count() >= dlimit)
+			ms_status();
+		running = ms_rungame();
+	}
+	if (ms_count() == slimit)
+	{
+		printf("\n\nSafety limit (%d) reached.\n",slimit);
+		ms_status();
+	}
+	ms_freemem();
+	if (log_on)
+		fclose(log1);
+	if (log2)
+		fclose(log2);
+	printf("\nExiting.\n");
+	return 0;
+}
diff -Nur Generic/.svn/text-base/myth.c.svn-base Generic.garg/.svn/text-base/myth.c.svn-base
--- Generic/.svn/text-base/myth.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/myth.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,127 @@
+/*
+ * Patches Myth C64 disk image
+ * Written by David Kinder, based on code by Niclas Karlsson
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define D64_SIZE (174848L)
+unsigned char image[D64_SIZE];
+
+void ungarble(unsigned char* block, signed long key)
+{
+	unsigned char d;
+	int i,j;
+
+	d = (unsigned char)((key & 0x07) ^ 0xFF);
+	if (d < 0xFF)
+	{
+		i = d;
+		j = d+1;
+		while (j < 0x100)
+			block[j++] ^= block[i];
+	}
+
+	i = 0xFF;
+	j = d-1;
+	while (j >= 0)
+		block[j--] ^= block[i--];
+
+	for (i = 0; i < 128; i++)
+	{
+		d = block[i];
+		block[i] = block[255-i];
+		block[255-i] = d;
+	}
+}
+
+void garble(unsigned char* block, int i1, int j1, int i2)
+{
+	unsigned char d;
+	int i,j;
+
+	for (i = 0; i < 128; i++)
+	{
+		d = block[i];
+		block[i] = block[255-i];
+		block[255-i] = d;
+	}
+
+	i = i1;
+	j = -1;
+	while (j < j1)
+		block[++j] ^= block[++i];
+
+	i = i2;
+	j = 0x100;
+	while (j > i2+1)
+		block[--j] ^= block[i];
+}
+
+/* This routine does the patching. */
+void fixDiskImage(int code)
+{
+	unsigned char* block = NULL;
+
+	switch (code)
+	{
+	case 0:
+		/* code[0x3056] = 0x60 */
+		block = image + 0x1600;
+		ungarble(block,0x27L);
+		block[0x56] = 0x60;
+		garble(block,0x07,0xF7,0xF8);
+		break;
+	case 1:
+		/* code[0x3148] = 0x60 */
+		/* code[0x314D] = 0x11 */
+		block = image + 0x1700;
+		ungarble(block,0x28L);
+		block[0x48] = 0x60;
+		block[0x4D] = 0x11;
+		garble(block,0x00,0xFE,0xFF);
+		break;
+	}
+}
+
+void readDiskImage(const char* filename)
+{
+	FILE* file = fopen(filename,"r+b");
+	if (file == NULL)
+		exit(1);
+	fread(image,1,D64_SIZE,file);
+}
+
+void writeDiskImage(const char* filename)
+{
+	FILE* file = fopen(filename,"w+b");
+	if (file == NULL)
+		exit(1);
+	fwrite(image,1,D64_SIZE,file);
+}
+
+int main(int argc, char** argv)
+{
+	if (argc == 4)
+	{
+		int code = -1;
+		if (sscanf(argv[3],"%d",&code) == 1)
+		{
+			if ((code >= 0) && (code <= 1))
+			{
+				readDiskImage(argv[1]);
+				fixDiskImage(code);
+				writeDiskImage(argv[2]);
+				printf("Myth patched.\n");
+				return 0;
+			}
+		}
+	}
+
+	printf("Removes password protection from Magnetic Scrolls' Myth.\n");
+	printf("Use: myth input.d64 output.d64 code\n");
+	printf("If code is 0, the password protection is completely removed.\n");
+	printf("If code is 1, any user name and password will be accepted.\n");
+	return 0;
+}
diff -Nur Generic/.svn/text-base/passwd.c.svn-base Generic.garg/.svn/text-base/passwd.c.svn-base
--- Generic/.svn/text-base/passwd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/passwd.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,73 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <limits.h>
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
+type8 obfuscate(type8 c) {
+	static type8 state;
+	type8	       i;
+
+	if (!c) state=0;
+	else {
+		state^=c;
+		for (i=0;i<13;i++) {
+			if ((state & 1) ^ ((state>>1) & 1)) state|=0x80;
+			else state&=0x7f;
+			state>>=1;
+		}
+	}
+	return state;
+}
+
+int main(int argc, char **argv) {
+
+	type8 tmp,name[128],result[128],pad[]="MAGNETICSCR";
+	type32 i,j;
+
+	if (argc!=2) {
+		printf("Usage: %s string\n",argv[0]);
+		exit(1);
+	}
+
+	for (i=j=0;i<strlen(argv[1]);i++) {
+		if (argv[1][i]!=0x20) name[j++]=toupper(argv[1][i]);
+	}
+	name[j]=0;
+
+	tmp=name[strlen(name)-1];
+	if ((tmp=='#') || (tmp==']')) name[strlen(name)-1]=0;
+
+	if (strlen(name)<12) {
+		for (i=strlen(name),j=0;i<12;i++,j++) name[i]=pad[j];
+		name[i]=0;
+	}
+
+	obfuscate(0);
+	i=j=0;
+	while (name[i]) {
+		tmp=obfuscate(name[i++]);
+		if (name[i]) tmp+=obfuscate(name[i++]);
+		tmp&=0x1f;
+		if (tmp<26) tmp+='A';
+		else tmp+=0x16;
+		result[j++]=tmp;
+	}
+	result[j]=0;
+	printf("The password for \"%s\" is: %s\n",argv[1],result);
+	return 0;
+}
diff -Nur Generic/.svn/text-base/sndlink.c.svn-base Generic.garg/.svn/text-base/sndlink.c.svn-base
--- Generic/.svn/text-base/sndlink.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/sndlink.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,374 @@
+
+/*
+    SndLink.c
+    Extracter for Wonderland music scores
+    Amiga, Atari ST and PC versions.
+    Written by Stefan Meier.
+
+	v1.1 added option for tempo patching
+	v1.2 fixed tempo patching
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define BUFFER_SIZE 64UL*1024UL
+
+struct OutputSndFile
+{
+	char Name[8];
+	unsigned char tempo[2];
+	unsigned char Offset[4];
+	unsigned char Length[4];
+};
+
+struct SndFile
+{
+	char Name[8];
+	unsigned long Offset;
+	unsigned long Length;
+};
+
+struct SndFile* SndFiles = NULL;
+int SndFileCount = 0;
+unsigned char* Buffer1 = NULL;
+unsigned char* Buffer2 = NULL;
+FILE* InputFile = NULL;
+FILE* OutputFile = NULL;
+unsigned long OutOffset = 0;
+int tempopatch=0;
+
+void WriteLong(unsigned char* p, unsigned long v)
+{
+	p[3] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[2] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+void WriteShort(unsigned char* p, unsigned short v)
+{
+	p[1] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[0] = (unsigned char)v;
+}
+
+void WriteShort2(unsigned char* p, unsigned short v)
+{
+	p[0] = (unsigned char)(v & 0xFF);
+	v >>= 8;
+	p[1] = (unsigned char)v;
+}
+
+unsigned long ReadLong(unsigned char *ptr)
+{
+	return ((unsigned long)ptr[1]) << 24 |
+	       ((unsigned long)ptr[0]) << 16 |
+	       ((unsigned long)ptr[3]) <<  8 |
+	       ((unsigned long)ptr[2]);
+}
+
+unsigned short ReadShort(unsigned char *ptr)
+{
+	return (unsigned short)(ptr[1]<<8 | ptr[0]);
+}
+
+unsigned short ReadShort2(unsigned char *ptr)
+{
+	return (unsigned short)(ptr[0]<<8 | ptr[1]);
+}
+
+void CleanUp(void)
+{
+	if (InputFile)
+		fclose(InputFile);
+	if (OutputFile)
+		fclose(OutputFile);
+	if (SndFiles)
+		free(SndFiles);
+	if (Buffer1)
+		free(Buffer1);
+}
+
+void Error(const unsigned char *pError)
+{
+	fprintf(stderr,"Fatal Error: %s\n",pError);
+	CleanUp();
+	exit(1);
+}
+
+unsigned long ReadFile(unsigned char* buf, unsigned long* offset, unsigned long sz)
+{
+	fseek(InputFile,*offset,SEEK_SET);
+	*offset += sz;
+	return fread(buf,1,sz,InputFile);
+}
+
+unsigned long WriteFile(unsigned char* buf, unsigned long sz)
+{
+	return fwrite(buf,1,sz,OutputFile);
+}
+
+void OpenFile(const char* pszName)
+{
+	unsigned char buffer[4];
+	unsigned long offset = 0;
+	unsigned long id = 0;
+
+	if ((InputFile = fopen(pszName,"rb")) == NULL)
+		Error("Cannot open resource file");
+
+	ReadFile(buffer,&offset,4);
+}
+
+void FindResourceNames(void)
+{
+	unsigned char buffer[32];
+	unsigned long offset = 0;
+	int count, i = 0;
+
+	ReadFile(buffer,&offset,4);
+	offset = ((long)buffer[0] <<  0) |
+	         ((long)buffer[1] <<  8) |
+	         ((long)buffer[2] << 16) |
+	         ((long)buffer[3] << 24);
+	ReadFile(buffer,&offset,2);
+	count = ((int)buffer[0] << 0) |
+	        ((int)buffer[1] << 8);
+
+	SndFiles = calloc(count,sizeof(struct SndFile));
+
+	for (i = 0; i < count; i++)
+	{
+		char name[8];
+		unsigned long o, l;
+		unsigned int n;
+		int j;
+
+		ReadFile(buffer,&offset,18);
+		o = ((long)buffer[2] <<  0) |
+		    ((long)buffer[3] <<  8) |
+		    ((long)buffer[4] << 16) |
+		    ((long)buffer[5] << 24);
+		l = ((long)buffer[6] <<  0) |
+		    ((long)buffer[7] <<  8) |
+		    ((long)buffer[8] << 16) |
+		    ((long)buffer[9] << 24);
+		n = ((unsigned)buffer[16] << 0) |
+		    ((unsigned)buffer[17] << 8);
+
+		if (n == 4)
+		{
+			for (j = 0; (j < 6) && (buffer[10+j] != 0); j++)
+				name[j] = buffer[10+j];
+			name[j] = 0;
+
+			if (name[0]=='t' && name[1]=='-')
+			{
+			   strcpy(SndFiles[SndFileCount].Name,name);
+			   SndFiles[SndFileCount].Offset = o;
+			   SndFiles[SndFileCount].Length = l;
+
+			   SndFileCount++;
+			}
+		}
+	}
+}
+
+void WriteSndHeader1(void)
+{
+	struct OutputSndFile out;
+	unsigned char zeros[2] = { 0,0 };
+	int i;
+
+		if ((OutputFile = fopen("wonder.snd","wb")) == NULL)
+			Error("Cannot open output file");
+
+		WriteFile("MaSd",4);
+		OutOffset += 4;
+
+		WriteFile(zeros,2);
+		OutOffset += 2;
+
+		memset(&out,0,sizeof(struct OutputSndFile));
+		for (i = 0; i < SndFileCount; i++)
+			WriteFile((unsigned char*)&out,sizeof(struct OutputSndFile));
+		OutOffset += (SndFileCount * sizeof(struct OutputSndFile));
+}
+
+void WriteSndFile(int Index)
+{
+	unsigned long offset, length;
+	unsigned short tsize;
+	int game = -1;
+
+			offset = SndFiles[Index].Offset;
+			length = SndFiles[Index].Length;
+			if (length > BUFFER_SIZE)
+				length = BUFFER_SIZE;
+			ReadFile(Buffer1,&offset,length);
+
+			// Tempo patching
+			if (tempopatch)
+			{
+				memset(Buffer2,0x00, BUFFER_SIZE);
+				SndFiles[Index].Length=SndFiles[Index].Length+7;
+                memcpy(Buffer2,Buffer1,0x19);
+				Buffer2[0x1A]=0x00;Buffer2[0x1B]=0xFF;Buffer2[0x1C]=0x51;Buffer2[0x1D]=0x03;
+				memcpy(Buffer2+0x19+7,Buffer1+0x19,length-0x19);
+				// Calculate new track size
+				tsize = ReadShort2(Buffer2+0x14);
+				WriteShort(Buffer2+0x14,tsize+7);
+				if (strncmp(SndFiles[Index].Name,"t-mus",5)==0)
+				{ // Music
+					// Tempo event 05 16 15 = 180
+					Buffer2[0x1E]=0x05;Buffer2[0x1F]=0x16;Buffer2[0x20]=0x15;
+				}
+				else if (strncmp(SndFiles[Index].Name,"t-cat",5)==0)
+				{ // Catter
+					// Tempo event 0A 2C 2A = 90
+					Buffer2[0x1E]=0x0A;Buffer2[0x1F]=0x2C;Buffer2[0x20]=0x2A;
+				}
+				else if (strncmp(SndFiles[Index].Name,"t-croq",6)==0)
+				{ // Croque
+					// Tempo event 07 A1 20 = 120
+					Buffer2[0x1E]=0x07;Buffer2[0x1F]=0xA1;Buffer2[0x20]=0x20;
+				}
+				else if (strncmp(SndFiles[Index].Name,"t-pal",5)==0)
+				{ // enthal
+					// Tempo event 07 A1 20 = 120
+					Buffer2[0x1E]=0x07;Buffer2[0x1F]=0xA1;Buffer2[0x20]=0x20;
+				}
+				else if (strncmp(SndFiles[Index].Name,"t-madt",6)==0)
+				{ // dormou
+					// Tempo event 07 A1 20 = 120
+					Buffer2[0x1E]=0x07;Buffer2[0x1F]=0xA1;Buffer2[0x20]=0x20;
+				}
+				else if (strncmp(SndFiles[Index].Name,"t-crt",5)==0)
+				{ // court
+					// Tempo event 09 27 C0 = 100
+					Buffer2[0x1E]=0x09;Buffer2[0x1F]=0x27;Buffer2[0x20]=0xC0;
+				}
+				WriteFile(Buffer2,length+7);
+			}
+			else
+			{
+				WriteFile(Buffer1,length);
+			}
+
+}
+
+void WriteSndFiles(void)
+{
+	int i;
+
+	Buffer1 = malloc(BUFFER_SIZE);
+	if (Buffer1 == NULL)
+		Error("Not enough memory");
+	if (tempopatch)
+	{
+		Buffer2 = malloc(BUFFER_SIZE);
+		if (Buffer2 == NULL)
+			Error("Not enough memory");
+	}
+
+	for (i = 0; i < SndFileCount; i++)
+		WriteSndFile(i);
+}
+
+void WriteSndHeader2(void)
+{
+	struct OutputSndFile out;
+	unsigned char header_size[2];
+	int i, pos, game = -1;
+	int table = 0;
+
+	fseek(OutputFile,4,SEEK_SET);
+	WriteShort(header_size,(unsigned short)(SndFileCount * sizeof(struct OutputSndFile)));
+	WriteFile(header_size,2);
+
+	for (i = 0; i < SndFileCount; i++)
+	{
+			memset(&out,0,sizeof(struct OutputSndFile));
+			strcpy(out.Name,SndFiles[i].Name);
+			if (strcmp(SndFiles[i].Name,"t-mus")==0)
+			{
+			   //strcpy(out.Name,"music");
+			   WriteShort(out.tempo,180);
+			}
+			else if (strcmp(SndFiles[i].Name,"t-cat")==0)
+			{
+			   //strcpy(out.Name,"catter");
+			   WriteShort(out.tempo,95);
+			}
+			else if (strcmp(SndFiles[i].Name,"t-croq")==0)
+			{
+			   //strcpy(out.Name,"croque");
+			   WriteShort(out.tempo,120);
+			}
+			else if (strcmp(SndFiles[i].Name,"t-crt")==0)
+			{
+			   //strcpy(out.Name,"court");
+			   WriteShort(out.tempo,100);
+			}
+			else if (strcmp(SndFiles[i].Name,"t-pal")==0)
+			{
+			   //strcpy(out.Name,"enthal");
+			   WriteShort(out.tempo,120);
+			}
+			else if (strcmp(SndFiles[i].Name,"t-madt")==0)
+			{
+			   //strcpy(out.Name,"dormou");
+			   WriteShort(out.tempo,120);
+			}
+			WriteLong(out.Offset,OutOffset);
+			WriteLong(out.Length,SndFiles[i].Length);
+
+			pos = 6 + (table * sizeof(struct OutputSndFile));
+			fseek(OutputFile,pos,SEEK_SET);
+			WriteFile((unsigned char*)&out,sizeof(struct OutputSndFile));
+
+			OutOffset += SndFiles[i].Length;
+			table++;
+	}
+}
+
+int main(int argc, char** argv)
+{
+	if (argc == 2 || (argc == 3 && strcmp(argv[1],"-p")==0))
+	{
+		if (argc==2)
+		   OpenFile(argv[1]);
+		else
+		{
+			tempopatch = 1;
+			OpenFile(argv[2]);
+		}
+		FindResourceNames();
+		WriteSndHeader1();
+		WriteSndFiles();
+		WriteSndHeader2();
+		CleanUp();
+		printf("Music extracted successfully");
+	}
+	else
+	{
+		printf("SndLink v1.2 by Stefan Meier.\n\n"
+		       "Extractor for the music scores in Magnetic Scrolls' Wonderland\n"
+		       "Amiga, Atari ST, PC versions.\n\n"
+			   "Usage: SndLink [-p] all.rsc\n\n"
+		       "\"all.rsc\" is taken from an installed game. Depending on your\n"
+			   "game version, the resource file might be split into several files\n"
+			   "named e.g. all.1, all.2,... or TWO,THREE,FOUR...\n"
+		       "Before running the extractor, you need to merge these parts into\n"
+			   "one file, e.g. with the DOS command copy /B ONE+TWO+THREE+... all.rsc\n"
+		       "If the extraction is successfull, the file wonder.snd is created\n\n"
+			   "The optional -p switch adds tempo data to the music score");
+	}
+	return 0;
+}
+
diff -Nur Generic/.svn/text-base/tech.txt.svn-base Generic.garg/.svn/text-base/tech.txt.svn-base
--- Generic/.svn/text-base/tech.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/tech.txt.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,53 @@
+
+Magnetic Internal Data Formats
+==============================
+
+Unless otherwise stated all words are big-endian. The datafile format
+is as follows:
+
+1) Game file (.mag)
+
+Offset Size Explanation
+-----------------------
+   0    4   Magic word 'MaSc'
+   4    4   Size of datafile
+   8    4   Size of header (42 in this version)
+  12    2   Game version:
+              0. Pawn
+              1. Guild of Thieves
+              2. Jinxter
+              3. Myth, Corruption, Fish!
+              4. Magnetic Windows versions
+  14    4   Size of code [1]
+  18    4   Size of string data ( <=65536 ) [2]
+  22    4   Size of string data part 2 (the rest) [3]
+  26    4   Size of dictionary [4]
+  30    4   String table offset ( <=[2]+[3] )
+  34    4   Offset in the code block up to which undo and restart
+            data is saved. This originally had a very clear meaning
+            as the C64 versions used read-only swapping from disk
+            after that offset. Other versions are somewhat less
+            obvious, but looking at the save-routines should help.
+  38    4   Undo offset, ie. the offset in the code block at which
+            data for the undo operation is saved, usually in the
+            beginning of the main loop. A zero value works just
+            nicely if you don't care about undo (which isn't
+            foolproof anyway).
+  42   [1]  Code data
+  ++   [2]  String data 1
+  ++   [3]  String data 2
+  ++   [4]  Dictionary data
+
+2) Graphics file (.gfx). This is basically just an encapsulation of
+   the original Amiga graphics files.
+
+Offset Size Explanation
+-----------------------
+   0    4   Magic word 'MaPi'
+   4    4   Size of datafile
+ 8+4*k  4   Offset to the k:th picture data
+
+The format of the individual pictures is somewhat obscure, but the
+details can be found in the routine ms_extract() in the source file
+emu.c.
+
diff -Nur Generic/.svn/text-base/xtract64.c.svn-base Generic.garg/.svn/text-base/xtract64.c.svn-base
--- Generic/.svn/text-base/xtract64.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/xtract64.c.svn-base	2011-06-07 22:21:26.000000000 +0200
@@ -0,0 +1,334 @@
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+
+#define size_d64 ((type32)(174848))
+#define NL ((type32) -1)
+
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
+#ifdef __MSDOS__
+typedef unsigned char huge * type8ptr;
+#include <alloc.h>
+#define malloc farmalloc
+#define free farfree
+#define memcpy _fmemcpy
+#else
+typedef unsigned char * type8ptr;
+#endif
+
+FILE *fpout=0, *fp[3];			/* Globals for easy cleanup */
+type8 dir[256], block[256], game1, game2;
+type8ptr out, tmpbuf;
+
+void cleanup(char *errormsg, type32 status) {
+	fprintf(stderr,errormsg);
+	if (fpout) fclose(fpout);
+	if (fp[1]) fclose(fp[1]);
+	if (fp[2]) fclose(fp[2]);
+	if (out) free(out);
+	if (tmpbuf) free(tmpbuf);
+	exit(status);
+}
+
+void write_l(type8ptr ptr, type32 val) {
+	ptr[3]=val & 0xff; val>>=8;
+	ptr[2]=val & 0xff; val>>=8;
+	ptr[1]=val & 0xff; val>>=8;
+	ptr[0]=val;
+}
+
+void write_w(type8ptr ptr, type32 val) {
+	ptr[1]=val & 0xff; val>>=8;
+	ptr[0]=val;
+}
+
+FILE *get_file(char *name, type8ptr game) {
+	FILE *fp;
+	type8 buf[512];
+	type32 id;
+
+	if (!(fp=fopen(name,"rb"))) cleanup("Couldn't open input file\n",1);
+	if (fread(buf,1,512,fp)!=512) cleanup("Wrong size or read error\n",1);
+
+	if	(buf[0]!='M' || buf[1]!='S')
+		cleanup("This isn't a disk image of a Magnetic Scrolls game.\n",1);
+
+	id=((type32)buf[491]<<24|(type32)buf[492]<<16|(type32)buf[493]<<8|(type32)buf[494]);
+	if (id==0x5041574e) {						/* PAWN */
+		printf("'The Pawn' detected\n");
+		*game=0;
+	} else if (id==0x53574147) {				/* SWAG */
+		printf("'Guild of Thieves' detected\n");
+		*game=1;
+	} else if (id==0x41525345) {				/* ARSE */
+		printf("'Jinxter' detected\n");
+		*game=2;
+	} else if (id==0x474c5547) {				/* GLUG */
+		printf("'Fish' detected\n");
+		*game=3;
+	} else if (id==0x434f4b45) {				/* COKE */
+		printf("'Corruption' detected\n");
+		*game=4;
+	} else if (id==0x474f4453) {				/* GODS */
+		printf("'Myth' detected\n");
+		*game=5;
+	} else cleanup("Nothing I can identify, yet.\n",1);
+	return fp;
+}
+
+void ungarble(type8ptr block, type32 init) {
+	type8 d;
+	static signed long number;
+	signed long i,j;
+
+	if (init) {
+		number=0;
+		return;
+	}
+	d=(number & 0x07) ^ 0xff;
+	if (d<0xff) {
+		i=d; j=d+1;
+		while (j<0x100) block[j++]^=block[i];
+	}
+	i=0xff; j=d-1;
+	while (j>=0) block[j--]^=block[i--];
+	for (i=0;i<128;i++) {
+		d=block[i];
+		block[i]=block[255-i];
+		block[255-i]=d;
+	}
+	number++;
+}
+
+type8ptr getblock(type32 file, type32 sector, type32 garble) {
+	type32 track;
+	type8 side;
+
+	static type32 pertrack[]={	00,21,21,21,21,21,21,21,21,21,
+					21,21,21,21,21,21,21,21,00,19,
+					19,19,19,19,19,18,18,18,18,18,
+					18,17,17,17,17,17 };
+
+	side=(type8)dir[4*file+3];
+	if (game1!=0 && game1!=5 && side!=0)
+		side=3-side;
+	if (sector>=(type32)dir[4*file+2]) return 0;
+
+	track=(type32)dir[4*file];
+	sector+=(type32)dir[4*file+1];
+	while (sector>=pertrack[track]) sector-=pertrack[track++];
+	while (--track>0) {
+		if (track==18) sector+=19;
+		else sector+=pertrack[track];
+	}
+	fseek(fp[side],sector*256,SEEK_SET);
+	if (fread(block,1,256,fp[side])!=256) cleanup("Wrong file size or read error",1);
+	if (garble) ungarble(block,0);
+	return block;
+}
+
+type32 runlength(type8ptr ptr) {
+	type32	end,i,j,k;
+
+	end=ptr[0]<<8 | ptr[1];
+	for (i=2,j=0;i<end;i++) {
+		if (ptr[i]) tmpbuf[j++]=ptr[i];
+		else {
+			i++;
+			for (k=0;k<ptr[i];k++) tmpbuf[j++]=0;
+		}
+	}
+	memcpy(ptr,tmpbuf,j);
+	return (j+255) & 0xffff00;
+}
+
+type32 dump_file(type32 file, type32 currpos, type32 garble, type32 rle) {
+	type8ptr ptr;
+	type8 side;
+	type32 i, len, outlen=0;
+
+	if (file==NL)
+		return 0;
+	side=(type8)dir[4*file+3];
+	if (game1!=0 && game1!=5 && side!=0)
+		side=3-side;
+	printf("Dumping file %2d from side %d (0=any)\n", (int) file, (int) side);
+	len=(type32)dir[4*file+2];
+	if (garble==1) ungarble(0,1);						/* initialize ungarbling */
+
+	for (i=0;i<len;i++) {
+		ptr=getblock(file,i,garble);
+		if (ptr) memcpy(&out[currpos+outlen],ptr,256);
+		outlen+=256;
+	}
+	if (rle) outlen=runlength(out+currpos);
+	return outlen;
+}
+
+type32 write_file(type8ptr buffer, type32 sz, FILE *fp) {
+#ifdef __MSDOS__
+	type32 n=0xf000,i,j=0;
+
+	for (i=0; i<sz; i+=n) {
+		if (sz-i < 0xf000)
+			n = sz-i;
+		j += fwrite(buffer+i,1,n,fp);
+	}
+	return j;
+#else
+	return fwrite(buffer,1,sz,fp);
+#endif
+}
+
+main(int argc, char **argv) {
+	type32 m1,m2,s1,s2,dc,sz,i,sum;
+	type32 info[6][9]={
+		{ 0, 35, 1, 2, 3, NL, 0x0b400, 0x3fb0, 0x09528f1 }, /* The Pawn */
+		{ 1, 34, 1, 2, 3, NL, 0x0f100, 0x6cac, 0x0c423d4 },	/* Guild of Thieves */
+		{ 2, 33, 1, 2, 3, 34, 0x13100, 0x488c, 0x0efc6bf },	/* Jinxter */
+		{ 3, 32, 1, 2, 3, 33, 0x14e00, 0x3f72, 0x0fd6a3d },	/* Fish */
+		{ 3, 31, 1, 2, 3, 32, 0x16100, 0x4336, 0x10405a7 },	/* Corruption */
+		{ 3,  4, 1, 2, 3,  5, 0x08b00, 0x3940, 0x08f0e4b }	/* Myth */
+	};
+	/* version, mem1, mem2, str1, str2, dict, decode_offset, undo_pc, checksum */
+
+	assert(sizeof(type8)==1);
+	assert(sizeof(type32)==4);
+
+	if (argc!=4) cleanup(
+		"Xtract64 v1.0 by Niclas Karlsson\n"
+		"\n"
+		"This is an utility to extract story files from C64 disk images of Magnetic\n"
+		"Scrolls games. The resulting story files can be run with with the Magnetic\n"
+		"interpreter by Niclas Karlsson.\n"
+		"\n"
+		"Usage: Xtract64 disk1.d64 disk2.d64 story.mag\n"
+		"\n"
+		"(disk2 can be anything when extracting Myth)\n",1);
+
+	if (!(out=(type8ptr)malloc(0x29800))) cleanup("Not enough memory\n",1);
+	if (!(tmpbuf=(type8ptr)malloc(0x8000))) cleanup("Not enough memory\n",1);
+
+	fp[1]=get_file(argv[1],&game1);
+	if (game1!=5)
+		fp[2]=get_file(argv[2],&game2);
+	fp[0]=fp[1];
+	printf ("\n");
+
+	if (fread(dir,1,256,fp[1])!=256) cleanup("Wrong file size or read error\n",1);
+
+	sz=42;
+	sz+=(m1=dump_file(info[game1][1],sz,1,info[game1][0]!=0));	/* main memory 1 */
+	sz+=(m2=dump_file(info[game1][2],sz,2,0));						/* main memory 2 */
+	sz+=(s1=dump_file(info[game1][3],sz,0,0));						/* strings 1 */
+	sz+=(s2=dump_file(info[game1][4],sz,0,0));						/* strings 2 */
+	sz+=(dc=dump_file(info[game1][5],sz,1,0));						/* dictionary */
+	printf("\n");
+
+	write_l(out+ 0,0x4D615363);			/* magic number MaSc */
+	write_l(out+ 4,sz);						/* file size */
+	write_l(out+ 8,42);						/* header size */
+	write_w(out+12,info[game1][0]);		/* version */
+	write_l(out+14,m1+m2);					/* main memory size */
+	write_l(out+18,s1);						/* string1 size */
+	write_l(out+22,s2);						/* string2 size */
+	write_l(out+26,dc);						/* dict size */
+	write_l(out+30,info[game1][6]);		/* decoding offset */
+	write_l(out+34,m1);						/* undo size */
+	write_l(out+38,info[game1][7]);		/* undo-pc */
+
+	if (game1==0 && out[0x17928]==0x3f) {
+		printf(
+			"The Pawn fix:\n"
+			"  C64 disks of this game contained five corrupt bytes that\n"
+			"  caused a misprint of Kronos' note. I'm correcting these bytes...\n"
+			"\n");
+		out[0x17928]=0x68;
+		out[0x17929]=0x4b;
+		out[0x1792a]=0x8b;
+		out[0x1792b]=0xe0;
+		out[0x1792c]=0x1e;
+	}
+	if (game1==0 && out[0x3628]==0xff) {
+		printf(
+			"The Pawn fix:\n"
+			"  Your disk image was probably taken from the Internet and\n"
+			"  contains four corrupt bytes. I'm fixing this...\n"
+			"\n");
+		out[0x3628]=0x00;
+		out[0x3728]=0x00;
+		out[0x3828]=0x00;
+		out[0xf9e0]=0x86;
+	}
+	if (game1==1 && out[0xc042]==0x29) {
+		printf(
+			"Guild of Thieves fix:\n"
+			"  Your disk image could be taken from the CD96. This version\n"
+			"  contains eight modified bytes. I'm restoring original values...\n"
+			"\n");
+		out[0xc042]=0x4b;
+		out[0xc043]=0xfe;
+		out[0xda08]=0x3f;
+		out[0xda09]=0x06;
+		out[0xda0a]=0x4e;
+		out[0xda0b]=0x71;
+		out[0xdb7c]=0x4b;
+		out[0xdb7d]=0xfe;
+	}
+	if (game1==2 && out[0xd212]==0x50) {
+		printf(
+			"Jinxter fix:\n"
+			"  This game has bug that makes the interpreter crash when\n"
+			"  objects are thrown at a certain window. I'm patching one byte...\n"
+			"\n");
+		out[0xd212]=0x58;
+	}
+
+	for (i=0,sum=0;i<sz;i++) sum+=out[i];
+	printf(
+		"Checksum is %s (actual %lx, should be %lx)\n\n",
+		(sum==info[game1][8])?"OK":"bad",
+		(long)sum,
+		(long)info[game1][8]);
+
+	if (game1!=4) {
+		char c;
+		printf("Shall I remove the password protection (y/n)? ");
+		c = getchar();
+		if (c=='y' || c=='Y') {
+			if (game1==0) {
+				out[0x3de6]=0x4e; out[0x3de7]=0x71; }
+			if (game1==1) {
+				out[0x6c52]=0x4e; out[0x6c53]=0x71; }
+			if (game1==2) {
+				out[0x4310]=0x4e; out[0x4311]=0x71; }
+			if (game1==3) {
+				out[0x3a6c]=0x4e; out[0x3a6d]=0x71; }
+			if (game1==5)
+				out[0x3080]=0x60;
+		}
+	} else printf("This game has no password protection.\n");
+	printf("\n");
+
+	if (!(fpout=fopen(argv[3],"wb"))) cleanup("Couldn't open output file\n",1);
+	if (write_file(out,sz,fpout)!=sz) cleanup("Write error\n",1);
+
+	cleanup("Operation successful\n",0);
+
+	return 0;
+}
diff -Nur Generic/.svn/text-base/xtractmw.c.svn-base Generic.garg/.svn/text-base/xtractmw.c.svn-base
--- Generic/.svn/text-base/xtractmw.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/xtractmw.c.svn-base	2011-06-07 22:21:27.000000000 +0200
@@ -0,0 +1,369 @@
+
+/*
+    XtractMW.c
+    Extracter for Magnetic Scrolls games (Wonderland
+    and the MS Collection Volume 1), MS-DOS versions.
+
+    Written by David Kinder, based on code
+    by Stefan Jokisch and Niclas Karlsson.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#define HEADER_SIZE 42
+#define MAX_FILES 10
+#define BUF_SIZE 1024
+#define NUMBER_GAMES 4
+
+FILE* FileHandles[MAX_FILES];
+FILE* OutputFile = NULL;
+long FileLengths[MAX_FILES];
+int FileCount = 0;
+unsigned char Buffer[BUF_SIZE];
+int Game = -1;
+int NextExtract = 0;
+int RemoveProtection = 0;
+
+struct GameInfo
+{
+  int TotalFiles;
+  const char* pDisplayName;
+  long Protection;
+
+  const char* pCodeName;
+  long CodeSize;
+  const char* pTextName;
+  long TextSize;
+  const char* pIndexName;
+  long IndexSize;
+  const char* pDictName;
+  long DictSize;
+
+  long StringSplit;
+  long UndoSize;
+  long UndoPC;
+};
+
+const struct GameInfo MSGames[4] =
+{
+  { 1031,"Wonderland 1.21 (MS-DOS)",0x06778,
+    "code",0x1523C,"text",0x13C2C,"index",0x103A,"wtab",0x2FA0,
+    0x10000,0x3900,0x75F2 },
+  { 383,"Corruption 1.12 (MS-DOS)",0xFFFFF,
+    "ccode",0x12560,"ctext",0x161C3,"cindex",0xF4C,"cwtab",0x1D88,
+    0x10000,0x2500,0x6624 },
+  { 466,"Guild of Thieves 1.3 (MS-DOS)",0xFFFFF,
+    "gcode",0x107F8,"gtext",0xF394,"gindex",0xDA0,"gwtab",0x2070,
+    0xE000,0x3400,0x6528 },
+  { 339,"Fish! 1.10 (MS-DOS)",0xFFFFF,
+    "fcode",0x124C4,"ftext",0x14E17,"findex",0xE48,"fwtab",0x2098,
+    0x10000,0x2A00,0x583A }
+};
+
+void writeLong(unsigned char* p, unsigned long v)
+{
+  p[3] = (unsigned char)(v & 0xFF);
+  v >>= 8;
+  p[2] = (unsigned char)(v & 0xFF);
+  v >>= 8;
+  p[1] = (unsigned char)(v & 0xFF);
+  v >>= 8;
+  p[0] = (unsigned char)v;
+}
+
+void writeWord(unsigned char* p, unsigned long v)
+{
+  p[1] = (unsigned char)(v & 0xFF);
+  v >>= 8;
+  p[0] = (unsigned char)v;
+}
+
+void Error(const unsigned char *pError)
+{
+   fprintf(stderr,"Fatal Error: %s\n",pError);
+   exit(1);
+}
+
+void OpenFiles(const unsigned char* pRdfName)
+{
+  FILE *fp;
+  int result;
+
+  if ((fp = fopen(pRdfName,"rt")) == NULL)
+    Error("Cannot open RDF file");
+
+  while ((result = fscanf(fp," %256s %ld\n",Buffer,FileLengths+FileCount)) == 2)
+  {
+    if (FileCount < MAX_FILES)
+    {
+      if ((FileHandles[FileCount++] = fopen(Buffer,"rb")) == NULL)
+        Error("Cannot open resource file");
+    }
+  }
+
+  fclose(fp);
+  if (result != EOF)
+    Error("Bad format RDF file");
+}
+
+void OpenOutputFile(const unsigned char* pMagName)
+{
+  unsigned char header[HEADER_SIZE];
+  long code, text1, text2, index, dict, decode, total;
+  long undo_size, undo_pc;
+
+  if ((OutputFile = fopen(pMagName,"wb")) == NULL)
+    Error("Cannot open output file");
+
+  /* Get all the buffer sizes. */
+
+  code = MSGames[Game].CodeSize;
+  decode = MSGames[Game].TextSize;
+  index = MSGames[Game].IndexSize;
+  dict = MSGames[Game].DictSize;
+  undo_size = MSGames[Game].UndoSize;
+  undo_pc = MSGames[Game].UndoPC;
+
+  text1 = MSGames[Game].StringSplit;
+  text2 = decode + index - text1;
+  total = HEADER_SIZE + code + decode + index + dict;
+
+  /* Set up the header. */
+
+  writeLong(header+ 0,0x4D615363);   /* Magic word */
+  writeLong(header+ 4,total);        /* Size of this file */
+  writeLong(header+ 8,42);           /* Size of this header */
+  writeWord(header+12,4);            /* Game version */
+  writeLong(header+14,code);         /* Size of code section */
+  writeLong(header+18,text1);        /* Size of first string section */
+  writeLong(header+22,text2);        /* Size of second string section */
+  writeLong(header+26,dict);         /* Size of dictionary */
+  writeLong(header+30,decode);       /* Offset to string decoding table */
+  writeLong(header+34,undo_size);    /* Undo size */
+  writeLong(header+38,undo_pc);      /* Undo offset */
+
+  /* Write out the header. */
+  fwrite(header,1,HEADER_SIZE,OutputFile);
+}
+
+void ReadFile(long *offset, unsigned int size)
+{
+  long l = 0;
+  unsigned int read = 0;
+  int i;
+
+  for (i = 0; (i < FileCount) && (read < size); i++)
+  {
+    if (l + FileLengths[i] > (long)(*offset + read))
+    {
+      unsigned int s = size - read;
+
+      fseek(FileHandles[i],*offset + read - l,SEEK_SET);
+      if ((long)(*offset + size) > l + FileLengths[i])
+        s = FileLengths[i] - ftell(FileHandles[i]);
+      fread(Buffer + read,s,1,FileHandles[i]);
+      read += s;
+    }
+    l += FileLengths[i];
+  }
+
+  if (read != size)
+    Error("Bad offset");
+  *offset += size;
+}
+
+void ExtractFile(long offset, long size, int unprotect)
+{
+  long read = 0;
+  long prot = MSGames[Game].Protection;
+
+  while (read < size)
+  {
+    long s = size - read;
+
+    if (s > BUF_SIZE)
+      s = BUF_SIZE;
+    ReadFile(&offset,(unsigned int)s);
+
+    /* Remove copy protection */
+    
+    if ((unprotect != 0) && (RemoveProtection != 0))
+    {
+      if ((prot >= read) && (prot < read + s))
+      {
+        Buffer[prot - read] = 0x4E;
+        printf("Removing copy protection...\n");
+      }
+      if ((prot + 1 >= read) && (prot + 1 < read + s))
+        Buffer[prot + 1- read] = 0x75;
+    }
+
+    fwrite(Buffer,s,1,OutputFile);
+    read += s;
+  }
+}
+
+void ExtractFiles(const char* pMagName)
+{
+  long offset = 0;
+  int count, i = 0;
+  long dict_l = 0, dict_o = 0;
+
+  /* Work out how many files are present. */
+
+  ReadFile(&offset,4);
+  offset = ((long)Buffer[0] <<  0) |
+           ((long)Buffer[1] <<  8) |
+           ((long)Buffer[2] << 16) |
+           ((long)Buffer[3] << 24);
+
+  ReadFile(&offset,2);
+  count = ((int)Buffer[0] << 0) |
+          ((int)Buffer[1] << 8);
+
+  /* Identify the game. */
+
+  while ((Game < 0) && (i < NUMBER_GAMES))
+  {
+    if (count == MSGames[i].TotalFiles)
+    {
+      Game = i;
+      break;
+    }
+    i++;
+  }
+
+  if (Game >= 0)
+  {
+    printf("Found %s\n",MSGames[Game].pDisplayName);
+    if (MSGames[Game].Protection != 0xFFFF)
+    {
+      RemoveProtection = 1;
+/*
+      char c;
+      printf("Remove the password protection (y/n)? ");
+      c = getchar();
+      if (c=='y' || c=='Y')
+        RemoveProtection = 1;
+*/
+    }
+    OpenOutputFile(pMagName);
+  }
+  else
+    Error("Game not recognised");
+
+  /* Loop through each file. */
+
+  for (i = 0; i < count; i++)
+  {
+    char name[13];
+    long o, l;
+    unsigned int n;
+    int j;
+
+    ReadFile(&offset,18);
+    o = ((long)Buffer[2] <<  0) |
+        ((long)Buffer[3] <<  8) |
+        ((long)Buffer[4] << 16) |
+        ((long)Buffer[5] << 24);
+    l = ((long)Buffer[6] <<  0) |
+        ((long)Buffer[7] <<  8) |
+        ((long)Buffer[8] << 16) |
+        ((long)Buffer[9] << 24);
+    n = ((unsigned)Buffer[16] << 0) |
+        ((unsigned)Buffer[17] << 8);
+
+    if (n == 4)
+    {
+      for (j = 0; (j < 6) && (Buffer[10+j] != 0); j++)
+        name[j] = Buffer[10+j];
+      name[j] = 0;
+
+      switch (NextExtract)
+      {
+      case 0:
+        if (strcmp(name,MSGames[Game].pCodeName) == 0)
+        {
+          printf("Extracting code...\n");
+          ExtractFile(o,l,1);
+          NextExtract++;
+        }
+        else if (strcmp(name,MSGames[Game].pDictName) == 0)
+        {
+          dict_o = o;
+          dict_l = l;
+        }
+        break;
+      case 1:
+        if (strcmp(name,MSGames[Game].pTextName) == 0)
+        {
+          printf("Extracting text...\n");
+          ExtractFile(o,l,0);
+          NextExtract++;
+        }
+        break;
+      case 2:
+        if (strcmp(name,MSGames[Game].pIndexName) == 0)
+        {
+          printf("Extracting index...\n");
+          ExtractFile(o,l,0);
+          NextExtract++;
+        }
+        break;
+      case 3:
+        if (strcmp(name,MSGames[Game].pDictName) == 0)
+        {
+          printf("Extracting dictionary...\n");
+          ExtractFile(o,l,0);
+          NextExtract++;
+        }
+        break;
+      }
+    }
+  }
+
+  /* Check if the dictionary occured out of sequence. */
+  if (NextExtract == 3)
+  {
+    if (dict_l > 0)
+    {
+      printf("Extracting dictionary...\n");
+      ExtractFile(dict_o,dict_l,0);
+      NextExtract++;
+    }
+  }
+}
+
+void CloseFiles(void)
+{
+  int i;
+  for (i = 0; i < FileCount; i++)
+    fclose(FileHandles[i]);
+  fclose(OutputFile);
+}
+
+int main(int argc, char** argv)
+{
+  if (argc == 3)
+  {
+    OpenFiles(argv[1]);
+    ExtractFiles(argv[2]);
+    CloseFiles();
+
+    /* Was all the data extracted? */
+    if (NextExtract != 4)
+      Error("Not enough game data found");
+    else
+      printf("Game extracted successfully");
+  }
+  else
+  {
+    printf("XtractMW v1.0 by David Kinder, Stefan Jokisch and Niclas Karlsson.\n\n"
+           "Extractor for the Magnetic Windows versions of Magnetic Scrolls\n"
+           "games (Wonderland and the MS Collection Volume 1), MS-DOS versions.\n\n"
+           "Usage: XtractMW game.rdf game.mag\n");
+  }
+  return 0;
+}
diff -Nur Generic/.svn/text-base/xtractpc.c.svn-base Generic.garg/.svn/text-base/xtractpc.c.svn-base
--- Generic/.svn/text-base/xtractpc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ Generic.garg/.svn/text-base/xtractpc.c.svn-base	2011-06-07 22:21:27.000000000 +0200
@@ -0,0 +1,386 @@
+
+/*
+    XtractPC.c
+    Extractor for the original MS-DOS versions of the
+    Magnetic Scrolls games.
+
+    Written by Niclas Karlsson and David Kinder.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined(__MSDOS__) || defined (_WIN32)
+#define SEP "\\"
+#else
+#define SEP "/"
+#endif
+
+#ifdef __MSDOS__
+typedef unsigned char huge* HugePtr;
+#include <alloc.h>
+#define malloc farmalloc
+#define free farfree
+#else
+typedef unsigned char* HugePtr;
+#endif
+
+struct GameInfo
+{
+  const char* Name;
+
+  const char* HeaderFileIndex;
+  unsigned char HeaderBytes[8];
+
+  int Version;
+  unsigned long UndoSize;
+  unsigned long UndoPC;
+  unsigned long CopyAddr1;
+  unsigned char CopyByte1;
+  unsigned long CopyAddr2;
+  unsigned char CopyByte2;
+
+  unsigned long PatchAddr;
+  unsigned char PatchByte;
+  const char* PatchMsg;
+};
+
+struct GameInfo Games[7] =
+{
+  "Corruption 1.11",
+  "0",{ 0x7A,0x02,0x01,0x05,0x03,0x04,0x06,0x08 },
+  3,0x2100,0x43A0,0x0000,0x00,0x0000,0x00,
+  0x0000,0x00,0,
+
+  "Fish 1.02",
+  "1",{ 0x7E,0x02,0x01,0x80,0x03,0x04,0x05,0x06 },
+  3,0x2300,0x3FA0,0x3A8E,0x4E,0x3A8F,0x71,
+  0x0000,0x00,0,
+
+  "Guild 1.1",
+  "1",{ 0x7E,0x02,0x01,0x05,0x03,0x04,0x80,0x06 },
+  1,0x5000,0x6D5C,0x6D02,0x4E,0x6D03,0x71,
+  0x0000,0x00,0,
+
+  "Jinxter 1.05",
+  "0",{ 0x7A,0x02,0x01,0x05,0x03,0x04,0x06,0x07 },
+  2,0x2C00,0x4A08,0x4484,0x4E,0x4485,0x71,
+  0xD29E,0x58,
+  "Jinxter fix:\n"
+  "  This game has bug that makes the interpreter crash when\n"
+  "  objects are thrown at a certain window. This is being patched...\n",
+
+  "Jinxter 1.10",
+  "0",{ 0x7A,0x02,0x01,0x05,0x03,0x04,0x06,0x09 },
+  2,0x2C00,0x4A56,0x44CC,0x4E,0x44CD,0x71,
+  0xD28A,0x58,
+  "Jinxter fix:\n"
+  "  This game has bug that makes the interpreter crash when\n"
+  "  objects are thrown at a certain window. This is being patched...\n",
+
+  "Myth 1.0",
+  "0",{ 0x78,0x02,0x01,0x05,0x03,0x04,0x06,0x07 },
+  3,0x1500,0x3A0A,0x314A,0x60,0x0000,0x00,
+  0x0000,0x00,0,
+
+  "Pawn 2.3",
+  "1",{ 0x7E,0x02,0x01,0x04,0x03,0x80,0x05,0x07 },
+  0,0x3600,0x4420,0x40F6,0x4E,0x40F7,0x71,
+  0x0000,0x00,0,
+};
+
+#define NUMBER_GAMES 7
+
+char Name[256];
+char* NameNumber = 0;
+FILE* InputFile = 0;
+FILE* OutputFile = 0;
+int GameIndex = -1;
+
+HugePtr Dictionary, Code, String1, String2;
+unsigned long DictionarySize = 0, CodeSize = 0;
+unsigned long String1Size = 0, String2Size = 0;
+unsigned char DecodeTable[256];
+
+void Error(const char* error)
+{
+  if (InputFile)
+    fclose(InputFile);
+  if (OutputFile)
+    fclose(OutputFile);
+  if (Dictionary)
+    free(Dictionary);
+  if (Code)
+    free(Code);
+  if (String1)
+    free(String1);
+  if (String2)
+    free(String2);
+
+  fprintf(stderr,"Fatal Error: %s\n",error);
+  exit(1);
+}
+
+unsigned long ReadFile(HugePtr buf, unsigned long sz, FILE *fp)
+{
+#ifdef __MSDOS__
+  unsigned long n = 0xF000, i, j = 0;
+
+  for (i = 0; i < sz; i += n)
+  {
+    if (sz-i < 0xF000)
+      n = sz - i;
+    j += fread(buf+i,1,n,fp);
+  }
+  return j;
+#else
+  return fread(buf,1,sz,fp);
+#endif
+}
+
+unsigned long WriteFile(HugePtr buf, unsigned long sz, FILE *fp)
+{
+#ifdef __MSDOS__
+  unsigned long n = 0xF000, i, j = 0;
+
+  for (i = 0; i < sz; i += n)
+  {
+    if (sz-i < 0xF000)
+      n = sz - i;
+    j += fwrite(buf+i,1,n,fp);
+  }
+  return j;
+#else
+  return fwrite(buf,1,sz,fp);
+#endif
+}
+
+void RecogniseGame(void)
+{
+  int i = 0;
+
+  while ((GameIndex == -1) && (i < NUMBER_GAMES))
+  {
+    strcpy(NameNumber,Games[i].HeaderFileIndex);
+
+    if (InputFile = fopen(Name,"rb"))
+    {
+      unsigned char header[8];
+      int j = 0;
+      int fail = 0;
+
+      fread(header,1,8,InputFile);
+      while (j < 8)
+      {
+        if (header[j] != Games[i].HeaderBytes[j])
+          fail = 1;
+        j++;
+      }
+
+      if (fail == 0)
+      {
+        GameIndex = i;
+        printf("Found %s\n",Games[GameIndex].Name);
+      }
+
+      fclose(InputFile);
+      InputFile = 0;
+    }
+    i++;
+  }
+
+  if (GameIndex == -1)
+    Error("Game not recognised");
+}
+
+unsigned char GetBits(int init)
+{
+  static unsigned char mask, c;
+  unsigned char b;
+
+  if (init)
+  {
+    mask = 0;
+    return 0;
+  }
+  for (b = 0; b < 0x80;)
+  {
+    b <<= 1;
+    mask >>= 1;
+    if (!mask)
+    {
+      mask = 0x80;
+      c = fgetc(InputFile);
+    }
+    if (!(c & mask))
+      b++;
+    b = DecodeTable[b];
+  }
+  return (unsigned char)(b & 0x3F);
+}
+
+unsigned long ReadAndUnpack(HugePtr* ptr, int unpack)
+{
+  unsigned char data[4];
+  HugePtr ptr2;
+  unsigned long size, loop = 0;
+  int table_size, i;
+
+  if ((InputFile = fopen(Name,"rb")) == 0)
+    Error("Couldn't open input file");
+
+  if (unpack)
+  {
+    GetBits(1);
+    table_size = fgetc(InputFile);
+    for (i = 0; i < table_size; i++)
+      DecodeTable[i] = fgetc(InputFile);
+
+    loop = (fgetc(InputFile) << 8) | fgetc(InputFile);
+    if ((ptr2 = (HugePtr)malloc(loop*3)) == 0)
+      Error("Not enough memory");
+
+    size = 0;
+    *ptr = ptr2;
+    while (loop--)
+    {
+      for (i = 0; i < 4; i++)
+        data[i] = GetBits(0);
+      for (i = 0; i < 3; i++)
+        ptr2[size++] = data[i] | ((data[3] << (2*i+2)) & 0xC0);
+    }
+  }
+  else
+  {
+    if (fseek(InputFile,0,SEEK_END) < 0)
+      Error("File error");
+    if ((size = ftell(InputFile)) < 0)
+      Error("File error");
+    rewind(InputFile);
+    ptr2 = malloc(size);
+    *ptr = ptr2;
+    if (ReadFile(ptr2,size,InputFile) != size)
+      Error("File error");
+  }
+
+  fclose(InputFile);
+  InputFile = 0;
+  return size;
+}
+
+void ExtractData(void)
+{
+  if (Games[GameIndex].Version > 1)
+  {
+    strcpy(NameNumber,"0");
+    DictionarySize = ReadAndUnpack(&Dictionary,1);
+  }
+  strcpy(NameNumber,"1");
+  CodeSize = ReadAndUnpack(&Code,1);
+  strcpy(NameNumber,"2");
+  String2Size = ReadAndUnpack(&String2,0);
+  strcpy(NameNumber,"3");
+  String1Size = ReadAndUnpack(&String1,0);
+}
+
+void DoPatches(void)
+{
+  if (Games[GameIndex].CopyAddr1 != 0x0000)
+  {
+    char c;
+
+    printf("Should the password protection be removed (y/n)? ");
+    c = getchar();
+    if (tolower(c) == 'y')
+    {
+      Code[Games[GameIndex].CopyAddr1 - 0x2A] = Games[GameIndex].CopyByte1;
+      if (Games[GameIndex].CopyAddr2 != 0x0000)
+        Code[Games[GameIndex].CopyAddr2 - 0x2A] = Games[GameIndex].CopyByte2;
+    }
+  }
+
+  if (Games[GameIndex].PatchAddr != 0x0000)
+  {
+    Code[Games[GameIndex].PatchAddr - 0x2A] = Games[GameIndex].PatchByte;
+    if (Games[GameIndex].PatchMsg != 0)
+      printf(Games[GameIndex].PatchMsg);
+  }
+}
+
+void WriteLong(HugePtr ptr, unsigned long value)
+{
+  ptr[3] = (unsigned char)(value & 0xFF);
+  value >>= 8;
+  ptr[2] = (unsigned char)(value & 0xFF);
+  value >>= 8;
+  ptr[1] = (unsigned char)(value & 0xFF);
+  value >>= 8;
+  ptr[0] = (unsigned char)value;
+}
+
+void WriteOutputFile(const char* output)
+{
+  unsigned char header[42];
+
+  WriteLong(header,0x4D615363);
+  WriteLong(header+4,
+    CodeSize + DictionarySize + String1Size + String2Size + 42);
+  WriteLong(header+8,42);
+  header[12] = 0;
+  header[13] = Games[GameIndex].Version;
+  WriteLong(header+14,CodeSize);
+  WriteLong(header+18,(String1Size < 0x10000) ? String1Size : 0x10000);
+  WriteLong(header+22,(String1Size < 0x10000) ?
+    String2Size : String1Size - 0x10000 + String2Size);
+  WriteLong(header+26,DictionarySize);
+  WriteLong(header+30,String1Size);
+  WriteLong(header+34,Games[GameIndex].UndoSize);
+  WriteLong(header+38,Games[GameIndex].UndoPC);
+
+  if ((OutputFile = fopen(output,"wb")) == 0)
+    Error("Couldn't open output file");
+
+  if (WriteFile(header,42,OutputFile) != 42)
+    Error("File error");
+  if (WriteFile(Code,CodeSize,OutputFile) != CodeSize)
+    Error("File error");
+  if (WriteFile(String1,String1Size,OutputFile) != String1Size)
+    Error("File error");
+  if (WriteFile(String2,String2Size,OutputFile) != String2Size)
+    Error("File error");
+  if (Games[GameIndex].Version > 1)
+  {
+    if (WriteFile(Dictionary,DictionarySize,OutputFile) != DictionarySize)
+      Error("File error");
+  }
+  fclose(OutputFile);
+  OutputFile = 0;
+}
+
+int main(int argc, char** argv)
+{
+  if (argc == 3)
+  {
+    strcpy(Name,argv[1]);
+    NameNumber = Name + strlen(Name);
+
+    RecogniseGame();
+    ExtractData();
+    DoPatches();
+    WriteOutputFile(argv[2]);
+    printf("Game extracted successfully");
+  }
+  else
+  {
+    printf("XtractPC v1.0 by Niclas Karlsson and David Kinder.\n"
+           "Extractor for the MS-DOS versions of Magnetic Scrolls games.\n\n"
+           "Usage: XtractPC game game.mag\n\n"
+           "where \"game\" is the full path to the data files, minus any trailing\n"
+           "numbers. For example, the data files for \"The Pawn\" are called \"pawn1\"\n"
+           "to \"pawn6\". If these files are in a directory \"Magnetic"SEP"ThePawn\", the\n"
+           "following use would be valid:\n\n"
+           "       XtractPC Magnetic"SEP"ThePawn"SEP"pawn Pawn.mag\n");
+  }
+  return 0;
+}
diff -Nur Generic/xtract64.c Generic.garg/xtract64.c
--- Generic/xtract64.c	2000-05-06 16:30:00.000000000 +0200
+++ Generic.garg/xtract64.c	2011-06-07 22:21:27.000000000 +0200
@@ -2,12 +2,25 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <limits.h>
 
 #define size_d64 ((type32)(174848))
 #define NL ((type32) -1)
 
-typedef unsigned char type8;
-typedef unsigned long type32;
+#if UCHAR_MAX==0xff
+typedef unsigned char type8;
+#else
+#error "Can't find an 8-bit integer type"
+#endif
+
+#if INT_MAX==0x7fffffff
+typedef unsigned int type32;
+#elif LONG_MAX==0x7fffffff
+typedef unsigned long type32;
+#else
+#error "Can't find a 32-bit integer type"
+#endif
+
 #ifdef __MSDOS__
 typedef unsigned char huge * type8ptr;
 #include <alloc.h>
diff -Nur Generic/xtractpc.c Generic.garg/xtractpc.c
--- Generic/xtractpc.c	2010-10-25 17:32:32.000000000 +0200
+++ Generic.garg/xtractpc.c	2011-06-07 22:21:27.000000000 +0200
@@ -7,7 +7,6 @@
     Written by Niclas Karlsson and David Kinder.
 */
 
-#include <ctype.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
