diff -Nur asciiportal1.2c/ap_draw.cpp asciiportal-mod/ap_draw.cpp
--- asciiportal1.2c/ap_draw.cpp	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/ap_draw.cpp	2011-05-01 16:09:12.272261416 +0200
@@ -22,12 +22,13 @@
 // The source links with SDL, PDCurses compiled for SDL rendering (PDCSDL)
 // and SDL mixer.
 
+#include <iostream>
 #include <cstdlib>
 #include <string>
 #include <vector>
 #include <cmath>
 #include <ctime>
-#include <limits>
+#include <climits>
 using namespace std;
 #include "asciiportal.h"
 #ifndef __NOSDL__
@@ -42,9 +43,9 @@
 #include "ap_play.h"
 #include "ap_draw.h"
 
-int CharData [MAXColors][5] = // File, Screen, Forground, background, A_BOLD
-{{' ', ' ',COLOR_WHITE, COLOR_BLACK, 0}, // NONE
- {'Q', 'E',COLOR_WHITE, COLOR_GREEN, 1}, // GOAL
+extern const int CharData [MAXColors][5] = // File, Screen, Forground, background, A_BOLD
+{{' ', ' ', COLOR_WHITE, COLOR_BLACK, 0}, // NONE
+ {'Q', 'E', COLOR_WHITE, COLOR_GREEN, 1}, // GOAL
  {'+', 254, COLOR_BLACK, COLOR_YELLOW, 0}, // LADDER
  {'#', 219, COLOR_WHITE, COLOR_BLACK, 0}, // NORMAL
  {'N', 219, COLOR_BLACK, COLOR_WHITE, 1}, // NONSTICK
@@ -61,8 +62,8 @@
  {'y', 9, COLOR_BLUE, COLOR_BLACK, 1}, // PORTAL1
  {'z', 9, COLOR_YELLOW, COLOR_BLACK, 1}, // PORTAL2
  {'A', 220, COLOR_BLACK, COLOR_RED, 1}, // SWITCH
- {0, 220, COLOR_BLACK, COLOR_GREEN, 1}, // SWITCHON
- {'a', 249, COLOR_BLACK, COLOR_BLUE, 0}, // DOOR
+ {0, 220 | A_PROTECT, COLOR_BLACK, COLOR_GREEN, 1}, // SWITCHON
+ {'a', 30, COLOR_BLACK, COLOR_BLUE, 0}, // DOOR
  {0, 254, COLOR_BLUE, COLOR_BLACK, 0}, // DOOR3,
  {0, 249, COLOR_BLUE, COLOR_BLACK, 0}, // DOOR2
  {0, 250, COLOR_BLUE, COLOR_BLACK, 0}, // DOOR1,
@@ -72,7 +73,7 @@
  {'1', ' ', COLOR_WHITE, COLOR_BLACK, 0}, // TEXTTRIGGER
  {0, 15, COLOR_YELLOW, COLOR_BLACK, 0}, // FLASH
  {0, 0, COLOR_WHITE, COLOR_BLACK, 0}, // MAXObj
- {0, 0, COLOR_BLACK, COLOR_GREEN, 0}, // PAUSE
+ {0, 0, COLOR_GREEN, COLOR_BLACK, 0}, // PAUSE
  {0, 0, COLOR_WHITE, COLOR_BLACK, 0}, // MENUDIM
  {0, 0, COLOR_YELLOW, COLOR_BLACK, 1}, // MENUSELECT
  {0, 0, COLOR_YELLOW, COLOR_BLUE, 1}, // HELPMENU
@@ -80,7 +81,8 @@
 };
 
 extern vector<vector<int> > map;
-extern vector <object> objs;
+extern ObjectManager objm;
+extern object aimobject;
 extern string lvlname;
 extern int ticks;
 
@@ -91,38 +93,39 @@
 int statustick;
 int scrolltick;
 
-int color_pair(int obj) {
-  int fore = CharData[obj][2];
-  int back = CharData[obj][3];
-  return (COLOR_PAIR ((8 * fore) + back) | (A_BOLD * CharData[obj][4]));
-}
-
-int obj_color_pair (int obj) {
-  int fore = CharData[objs[obj].type][2];
-  int back = CharData[objs[obj].type][3];
-  int b = CharData[objs[obj].type][4];
-
-  if (objs.size()) {
-    if (objs[obj].type == DOOR) {
-      if (objs[obj].d.x == 4) {
-        fore = objs[obj].d.y % 6 + 1;
-        if (fore >= COLOR_GREEN) fore++;
-      } else {
-        fore = CharData[DOOR1][2];
-        back = CharData[DOOR1][3];
-      }
-    }
-    if (objs[obj].type == FLASH) {
-      fore = objs[obj].d.y;
-    }
-    if (objs[obj].type == SWITCH) {
-      back = objs[obj].d.y % 6 + 1;
-      if (back >= COLOR_GREEN) back++;
+int color_pair(int objtype) {
+  int fore = CharData[objtype][2];
+  int back = CharData[objtype][3];
+  return (COLOR_PAIR ((8 * fore) + back) | (A_BOLD * CharData[objtype][4]));
+}
+
+int obj_color_pair (objiter obj) {
+  int fore = CharData[obj->type][2];
+  int back = CharData[obj->type][3];
+  int b = CharData[obj->type][4];
+
+  if (obj->type == DOOR) {
+    if (obj->d.x == 4) {
+      fore = obj->d.y % 6 + 1;
+      if (fore >= COLOR_GREEN) fore++;
+      if (obj->d.y == 12) fore = COLOR_GREEN;
+      if (fore == COLOR_BLUE) b = 1;
+    } else {
+      fore = CharData[DOOR1][2];
+      back = CharData[DOOR1][3];
     }
   }
+  if (obj->type == FLASH) {
+    fore = obj->d.y;
+  }
+  if (obj->type == SWITCH || obj->type == SWITCHON) {
+    back = obj->d.y % 6 + 1;
+    if (back >= COLOR_GREEN) back++;
+    if (obj->d.y == 12) back = COLOR_GREEN;
+  }
   if (map.size()) {
-    if ((objs[obj].type == PLAYER) || (objs[obj].type == BOULDER) || (objs[obj].type == FLASH)) {
-      int mapblock = map[objs[obj].coord.y][objs[obj].coord.x];
+    if ((obj->type == PLAYER) || (obj->type == BOULDER) || (obj->type == FLASH)) {
+      int mapblock = map[obj->coord.y][obj->coord.x];
       if ((mapblock != NONE) && (mapblock != NORMAL)) {
         back = CharData[mapblock][2];
         b = 0;
@@ -210,287 +213,305 @@
   scrolltick ++;
 }
 
-int findobj(XY coord) { // returns object number of hit object or num favoring portals
-  int val = 0;
-
-  for (unsigned int c = 1; c < objs.size(); c++) {
-    if ((objs[c].coord.x == coord.x) && (objs[c].coord.y == coord.y)) {
-      if (objs[c].type == TEXTTRIGGER) continue;
-      if (objs[c].type == DOOR) {
-        if ((objs[c].d.x > 0) && (!val)) val = c;
-      } else if (objs[c].type != NONE) val = c;
-      if ((objs[c].type == PORTAL1) || (objs[c].type == PORTAL2))
-        return val;
+inline objiter object_at (XY coord) {
+  objiter retval = objm.NULLOBJ;
+  objset *s = &(objm.objmap[coord.y][coord.x]);
+  for (objset::iterator it = s->begin(); it != s->end(); it++) {
+    switch ((*it)->type) {
+      case NONE:
+      case TEXTTRIGGER:
+        break;
+      case DOOR:
+        if ((*it)->d.x > 0 && retval == objm.NULLOBJ)
+          retval = *it;
+        break;
+      case PORTAL1:
+      case PORTAL2:
+        if (retval == objm.NULLOBJ)
+          retval = *it;
+        break;
+      default:
+        retval = *it;
+        break;
     }
   }
-  return val;
+  return retval;
 }
 
 int screenchar(int o) {
   return (CharData[o][1] | color_pair(o) | A_ALTCHARSET);
 }
 
-int obj_screenchar(int obj) {
+int obj_screenchar(objiter obj) {
   int objtype;
 
-  objtype = objs[obj].type;
+  objtype = obj->type;
   if (objtype == DOOR) {
-    switch (objs[obj].d.x) {
+    switch (obj->d.x) {
       case 3: objtype = DOOR3; break;
       case 2: objtype = DOOR2; break;
       case 1: objtype = DOOR1; break;
       case 0: objtype = NONE; break;
     }
+    if(objtype == DOOR && obj->d.y >= 6)
+      return (4 | obj_color_pair(obj) | A_ALTCHARSET);
   }
+  if (objtype == SWITCHON && obj->d.y >= 6) objtype = SWITCH;
+  else if (objtype == SWITCH && obj->d.y >= 6) objtype = SWITCHON;
   return (CharData[objtype][1] | obj_color_pair(obj) | A_ALTCHARSET);
 }
 
-void map_screen (int player, XY center, XY offset, int angle, vector<vector<int> >& screenmap, int r) {
-  while (angle > 360) angle -= 360;
-  while (angle < 0) angle += 360;
-
-  double sin_rot, cos_rot;
-  XY upperleft, screen, temp, neo, c;
-  XY porXY[2]; // gotta remember portal information.
-  int portals[2], porvisible[2];
+// Math library round() is slow for some reason, at least on my system.
+// This version is good enough for us.
+inline int qround (double x) {
+  return (x < 0) ? (x - 0.5) : (x + 0.5);
+}
+
+// Fast atan2 for the special case where (x,y) is an integer-valued unit vector.
+// Output is in degrees, not radians (duh).
+inline int qatan2 (int y, int x) {
+  return (x + y + 1) ? (x ? 0 : 90) : (x ? 180 : 270);
+}
+
+// greatest integer strictly less than the rational number a/b
+inline int div_lt (int a, int b) {
+  if (b > 0)
+    return ((a > 0) ? (a - 1) : (a - b)) / b;
+  else
+    return ((a < 0) ? (a + 1) : (a - b)) / b;
+}
+
+// least integer strictly greater than the rational number a/b
+inline int div_gt (int a, int b) {
+  if (b > 0)
+    return ((a < 0) ? (a + 1) : (a + b)) / b;
+  else
+    return ((a > 0) ? (a - 1) : (a + b)) / b;
+}
+
+// gets the dimensions of the space behind (type = 1) or in front of (type = 0) a portal
+// s = screen (type = 1) or map (type = 0) coords of portal
+// d = direction vector of portal
+inline void portal_space (XY& s, XY& d, int type, int& zmax, int& wmin, int& wmax) {
+  int xmax = type ? (COLS - 1)  : (map[0].size() - 1);
+  int ymax = type ? (LINES - 1) : (map.size() - 1);
+  int dir  = type ? 1 : -1;
+  switch (qatan2 (dir * d.y, dir * d.x)) {
+    case 0:
+      zmax = s.x;
+      wmin = s.y - ymax;
+      wmax = s.y;
+      break;
+    case 90:
+      zmax = s.y;
+      wmin = -s.x;
+      wmax = xmax - s.x;
+      break;
+    case 180:
+      zmax = xmax - s.x;
+      wmin = -s.y;
+      wmax = ymax - s.y;
+      break;
+    case 270:
+      zmax = ymax - s.y;
+      wmin = s.x - xmax;
+      wmax = s.x;
+      break;
+  }
+}
 
-  for (c.y = 0; c.y < (signed)screenmap.size(); c.y++)  // clear the old.
-    screenmap[c.y].clear();
+void map_screen (vector<vector<chtype> >& screenmap) {
+  XY upperleft, screenc;
   screenmap.clear();
-
-  if (r++ == 2) return;
-
-  upperleft.x = (int)objs[player].coord.x - (COLS / 2);
-  upperleft.y = (int)objs[player].coord.y - (LINES / 2);
-
-  sin_rot = sin((double)angle * M_PI / 180.0);
-  cos_rot = cos((double)angle * M_PI / 180.0);
-
-  portals[0] = portals[1] = 0;
-  porvisible[0] = porvisible[1] = 0;
-  for (int p = 1; p < (signed)objs.size(); p++) {  // find the portals
-    if (objs[p].type == PORTAL1) portals[0] = p;
-    if (objs[p].type == PORTAL2) portals[1] = p;
-  }
-
-  for (screen.y = 0; screen.y < LINES; screen.y++) {
-    vector<int> screenline(COLS, screenchar(NONSTICK));
-    for (screen.x = 0; screen.x < COLS; screen.x++) {
-      temp.x = upperleft.x + screen.x - center.x;
-      temp.y = upperleft.y + screen.y - center.y;
-      neo.x = round((double)temp.x * cos_rot - (double)temp.y * sin_rot);
-      neo.y = round((double)temp.x * sin_rot + (double)temp.y * cos_rot);
-      neo.x += offset.x; neo.y += offset.y;
-      if ((neo.x < (signed)map[0].size()) && (neo.x >= 0) && (neo.y < (signed)map.size()) && (neo.y >= 0)) {
-        int c_obj = findobj(neo);
-        if (objs[c_obj].type == PORTAL1) {
-          porXY[0].x = screen.x; porXY[0].y = screen.y;
-        }
-        if (objs[c_obj].type == PORTAL2) {
-          porXY[1].x = screen.x; porXY[1].y = screen.y;
-        }
-        int useobj = 0;
-        if (c_obj) {
-          useobj = 1;
-          if (objs[c_obj].type == PORTAL1) porvisible[0] = 1;
-          else if (objs[c_obj].type == PORTAL2) { porvisible[1] = 1; useobj = 2; }
-          if ((objs[c_obj].type == PORTAL1) || (objs[c_obj].type == PORTAL2)) {
-            // Hide portals facing away from player
-            if ((screen.x > COLS / 2) && (objs[c_obj].d.x > 0)) {
-              porvisible[useobj - 1] = 0;
-              useobj = 0;
-            }
-            if ((screen.x < COLS / 2) && (objs[c_obj].d.x < 0)) {
-              porvisible[useobj - 1] = 0;
-              useobj = 0;
-            }
-            if ((screen.y > LINES/ 2) && (objs[c_obj].d.y > 0)) {
-              porvisible[useobj - 1] = 0;
-              useobj = 0;
-            }
-            if ((screen.y < LINES/ 2) && (objs[c_obj].d.y < 0))  {
-              porvisible[useobj - 1] = 0;
-              useobj = 0;
-            }
-          }
-        }
-        if (useobj) {
-          screenline[screen.x] = obj_screenchar(c_obj);
-        } else screenline[screen.x] = screenchar(map[neo.y][neo.x]);
+  upperleft.x = objm.player->coord.x - (COLS/2);
+  upperleft.y = objm.player->coord.y - (LINES/2);
+  for (screenc.y = 0; screenc.y < LINES; screenc.y++) {
+    vector<chtype> screenline(COLS, screenchar(NONSTICK));
+    XY mapc;
+    mapc.y = upperleft.y + screenc.y;
+    if (mapc.y >= 0 && mapc.y < map.size()) {
+      int sxa = (upperleft.x < 0) ? -upperleft.x : 0;
+      int sxb = ((upperleft.x + COLS) > map[0].size()) ? (map[0].size() - upperleft.x) : COLS;
+      for (screenc.x = sxa; screenc.x < sxb; screenc.x++) {
+        mapc.x = upperleft.x + screenc.x;
+        objiter c_obj = object_at (mapc);
+        screenline[screenc.x] = (c_obj == objm.NULLOBJ) ? screenchar(map[mapc.y][mapc.x]) : obj_screenchar(c_obj);
       }
     }
     screenmap.push_back(screenline);
   }
 
-  if (portals[0] && portals[1]) { // look into portals
-    for (int p = 0; p < 2; p++) {
-      int check = objs[hitsobj(portals[p], objs[portals[p]].coord.y, objs[portals[p]].coord.x)].type;
-      if ((check != PORTAL1) && (check != PORTAL2)) { // fill portal with any object in the portals
-        if (porvisible[0])
-          screenmap[porXY[0].y][porXY[0].x] = screenchar(check);
-        if (porvisible[1])
-          screenmap[porXY[1].y][porXY[1].x] = screenchar(check);
-      }
-      if (porvisible[p]) {
-        vector<vector<int> > portalmap;
-        int porangle = 180 - round((atan2(objs[portals[p]].d.y,objs[portals[p]].d.x)
-          - atan2(objs[portals[(p+1)%2]].d.y,objs[portals[(p+1)%2]].d.x)) * 180.0 / M_PI);
-        map_screen (player, objs[portals[p]].coord, objs[portals[(p+1)%2]].coord, angle + porangle, portalmap, r);
-        if (portalmap.size()) {
-          double theta = (angle * M_PI / 180) + atan2(objs[portals[p]].d.y, objs[portals[p]].d.x);
-          double m = 1.0 / tan(theta);
-          if (m == numeric_limits<float>::infinity()) m = 8165889364191922.00; // to avoid infinite slope
-          float mxb = m * (double)porXY[p].x - porXY[p].y;
-          int greater = 0;
-          if ((angle > 90) && (angle < 270)) {
-            if (mxb < (m * (double)((COLS/2) + objs[portals[p]].d.x) - (LINES / 2) - objs[portals[p]].d.y))
-              greater = 1;
-          } else {
-            if (mxb > (m * (double)((COLS/2) + objs[portals[p]].d.x) - (LINES / 2) - objs[portals[p]].d.y))
-              greater = 1;
+  XY sight = { objm.player->coord.x + aimobject.d.x, objm.player->coord.y + aimobject.d.y };
+  if (object_at (sight) == objm.NULLOBJ) {
+    screenc.x = (COLS/2)  + aimobject.d.x;
+    screenc.y = (LINES/2) + aimobject.d.y;
+    if (screenmap[screenc.y][screenc.x] == screenchar(NONE))
+      screenmap[screenc.y][screenc.x] = 250 | color_pair(aimobject.type) | A_ALTCHARSET;
+    else
+      screenmap[screenc.y][screenc.x] = (screenmap[screenc.y][screenc.x] & ~A_COLOR) | color_pair(aimobject.type);
+  }
+
+  if (objm.portals[0] == objm.NULLOBJ || objm.portals[1] == objm.NULLOBJ)
+    return;
+
+  // look into portals
+  for (int i = 0; i < 2; i++) {
+    objiter u = objm.portals[i];
+    objiter v = objm.portals[i^1];
+    XY us = { u->coord.x - upperleft.x, u->coord.y - upperleft.y };
+    if (us.x < 0 || us.x >= COLS || us.y < 0 || us.y >= LINES)
+      continue;
+
+    // fill portal u with any object in portal v
+    objiter check = hitsobj(v, v->coord.y, v->coord.x);
+    if (check != v)
+      screenmap[us.y][us.x] = screenchar(check->type);
+
+    XY ud = u->d;
+    int a = ((COLS/2) - us.x) * -ud.y + ((LINES/2) - us.y) * ud.x;
+    int b = ((COLS/2) - us.x) *  ud.x + ((LINES/2) - us.y) * ud.y;
+
+    while (b > 0 || ((COLS/2) == us.x && (LINES/2) == us.y)) {
+      int zmax, wmin, wmax, vzmax, vwmin, vwmax;
+      portal_space (us, ud, 1, zmax, wmin, wmax);
+      portal_space (v->coord, v->d, 0, vzmax, vwmin, vwmax);
+      for (int z = 1; z <= zmax; z++) {
+        int w1 = b ? (-2 + div_gt ((a - 2) * z, b)) : wmin;
+        int w2 = b ? ( 2 + div_lt ((a + 2) * z, b)) : wmax;
+        if (w1 < wmin) w1 = wmin;
+        if (w2 > wmax) w2 = wmax;
+        XY screenc = { us.x - z * ud.x + w1 * ud.y, us.y - z * ud.y - w1 * ud.x };
+        XY mapc = { v->coord.x + z * v->d.x - w1 * v->d.y, v->coord.y + z * v->d.y + w1 * v->d.x };
+        for (int w = w1; w <= w2; w++) {
+          if (z<=vzmax && w>=vwmin && w<=vwmax) {
+            objiter c_obj = object_at (mapc);
+            screenmap[screenc.y][screenc.x] = (c_obj == objm.NULLOBJ) ? screenchar(map[mapc.y][mapc.x]) : obj_screenchar(c_obj);
           }
-          for (screen.y = 0; screen.y < (signed)portalmap.size(); screen.y++)
-            for (screen.x = 0; screen.x < (signed)portalmap[0].size(); screen.x++) {
-              if (greater) {
-                if ((m * (double)screen.x) - screen.y <= mxb)
-                  portalmap[screen.y][screen.x] = MAXWall;
-              } else {
-                if ((m * (double)screen.x) - screen.y >= mxb)
-                  portalmap[screen.y][screen.x] = MAXWall;
-              }
-            }
-          // cut out edges of wedges with linear algebra!
-          double m1, m2, mxb1, mxb2, denom;
+          else
+            screenmap[screenc.y][screenc.x] = screenchar(NONSTICK);
+          if (cheatview == 1 || animateportal == 2)
+            screenmap[screenc.y][screenc.x] = (screenmap[screenc.y][screenc.x] & ~A_COLOR) | color_pair(PORTAL1 + i);
+          screenc.x += ud.y;
+          screenc.y -= ud.x;
+          mapc.x -= v->d.y;
+          mapc.y += v->d.x;
+        }
+      }
 
-          if ((objs[player].coord.x != objs[portals[p]].coord.x)
-            || (objs[player].coord.y != objs[portals[p]].coord.y)) {
+#define COLORIZE(w,z) { \
+  XY screenc = { us.x - (z) * ud.x + (w) * ud.y, us.y - (z) * ud.y - (w) * ud.x }; \
+  if (screenmap[screenc.y][screenc.x] == screenchar(NONE)) screenmap[screenc.y][screenc.x] = screenchar(NONSTICK); \
+  screenmap[screenc.y][screenc.x] = (screenmap[screenc.y][screenc.x] & ~A_COLOR) | color_pair(PORTAL1 + i); \
+}
 
-            denom = objs[player].coord.x - (objs[portals[p]].coord.x + 2 * abs(objs[portals[p]].d.y));
-            if (abs(denom) < 0.0001) m1 = 8165889364191922.00;
-            else m1 = (objs[player].coord.y - (objs[portals[p]].coord.y - 2 * abs(objs[portals[p]].d.x))) / denom;
-            denom = objs[player].coord.x - (objs[portals[p]].coord.x - 2 * abs(objs[portals[p]].d.y));
-            if (abs(denom) < 0.0001) m2 = 8165889364191922.00;
-            else m2 = (objs[player].coord.y - (objs[portals[p]].coord.y + 2 * abs(objs[portals[p]].d.x))) / denom;
-
-            if (abs(m1 - m2) < 0.0001) continue;
-
-            int greater1, greater2;
-            mxb1 = m1 * (double)(COLS / 2) - LINES / 2;
-            mxb2 = m2 * (double)(COLS / 2) - LINES / 2;
-
-            if (mxb1 > (m1 * porXY[p].x - porXY[p].y)) greater1 = 1;
-            else greater1 = 0;
-            if (mxb2 > (m2 * porXY[p].x - porXY[p].y)) greater2 = 1;
-            else greater2 = 0;
-
-            for (screen.y = 0; screen.y < (signed)portalmap.size(); screen.y++)
-              for (screen.x = 0; screen.x < (signed)portalmap[0].size(); screen.x++) {
-                if (greater1 && greater2) {
-                  if ((mxb1 <= m1 * (double)screen.x - screen.y)
-                    || (mxb2 <= m2 * (double)screen.x - screen.y))
-                    portalmap[screen.y][screen.x] = MAXWall;
-                }
-                if (greater1 && !greater2) {
-                  if ((mxb1 <= m1 * (double)screen.x - screen.y)
-                    || (mxb2 >= m2 * (double)screen.x - screen.y))
-                    portalmap[screen.y][screen.x] = MAXWall;
-                }
-                if (!greater1 && greater2) {
-                  if ((mxb1 >= m1 * (double)screen.x - screen.y)
-                    || (mxb2 <= m2 * (double)screen.x - screen.y))
-                    portalmap[screen.y][screen.x] = MAXWall;
-                }
-                if (!greater1 && !greater2) {
-                  if ((mxb1 >= m1 * (double)screen.x - screen.y)
-                    || (mxb2 >= m2 * (double)screen.x - screen.y))
-                    portalmap[screen.y][screen.x] = MAXWall;
-                }
-              }
+      if (cheatview == 2 || animateportal == 1) {
+        if (b) {
+          if (abs(2-a) <= b) {
+            for (int z = 1; z <= zmax; z++) {
+              int w = -2 + div_gt ((a - 2) * z, b);
+              if (w >= wmin && w <= wmax) COLORIZE(w,z);
+            }
           }
-
-          for (screen.y = 0; screen.y < (signed)portalmap.size(); screen.y++)
-            for (screen.x = 0; screen.x < (signed)portalmap[0].size(); screen.x++) {
-              if (porvisible[0] && (screen.y == porXY[0].y) && (screen.x == porXY[0].x)) continue;
-              if (porvisible[1] && (screen.y == porXY[1].y) && (screen.x == porXY[1].x)) continue;
-              if (portalmap[screen.y][screen.x] == MAXWall) continue;
-              screenmap[screen.y][screen.x] = portalmap[screen.y][screen.x];
-              if (cheatview || animateportal) {
-                int edge = 0;
-                if ((cheatview == 1) || (animateportal == 2)) edge = 1;
-                if ((screen.y > 0) && (portalmap[screen.y - 1][screen.x] == MAXWall)) edge = 1;
-                if ((screen.y < LINES - 1) && (portalmap[screen.y + 1][screen.x] == MAXWall)) edge = 1;
-                if ((screen.x > 0) && (portalmap[screen.y][screen.x - 1] == MAXWall)) edge = 1;
-                if ((screen.x < COLS - 1) && (portalmap[screen.y][screen.x + 1] == MAXWall)) edge = 1;
-                if (edge) {
-                  if (screenmap[screen.y][screen.x] == screenchar(NONE))
-                    screenmap[screen.y][screen.x] = screenchar(NONSTICK) & 0x00ff | color_pair(PORTAL1 + p) | A_ALTCHARSET;
-                  else screenmap[screen.y][screen.x] = screenmap[screen.y][screen.x] & 0x00ff | color_pair(PORTAL1 + p) | A_ALTCHARSET;
-                }
-              }
+          else {
+            for (int w = wmin; w <= wmax; w++) {
+              int z = (a > 2) ? div_lt (b * (w + 2), a - 2) : div_gt (b * (w + 2), a - 2);
+              if (z >= 1 && z <= zmax) COLORIZE(w,z);
             }
-
-          for (c.y = 0; c.y < (signed)portalmap.size(); c.y++)  // clear the old.
-            portalmap[c.y].clear();
-          portalmap.clear();
+          }
+          if (abs(2+a) <= b) {
+            for (int z = 1; z <= zmax; z++) {
+              int w = 2 + div_lt ((a + 2) * z, b);
+              if (w >= wmin && w <= wmax) COLORIZE(w,z);
+            }
+          }
+          else {
+            for (int w = wmin; w <= wmax; w++) {
+              int z = (a < -2) ? div_lt (b * (w - 2), a + 2) : div_gt (b * (w - 2), a + 2);
+              if (z >= 1 && z <= zmax) COLORIZE(w,z);
+            }
+          }
+          if (-1 >= wmin) COLORIZE(-1,0);
+          if ( 1 <= wmax) COLORIZE( 1,0);
+        }
+        else {
+          for (int w = wmin; w <= wmax; w++)
+            if (w) COLORIZE(w,0);
         }
       }
-    }
-  }
-}
 
-void draw_screen_angle (int player, int angle) {
-  vector<vector<int> > screenmap;
-  XY screen;
-
-  fillscreen (' ');
+      int z = (u->coord.x - v->coord.x) *  v->d.x + (u->coord.y - v->coord.y) * v->d.y;
+      int w = (u->coord.x - v->coord.x) * -v->d.y + (u->coord.y - v->coord.y) * v->d.x;
+      if (z > zmax || w < wmin || w > wmax)
+        break;
+      if ((b*(w+2)-(a-2)*z) <= 0 || (b*(w-2)-(a+2)*z) >= 0)
+        break;
+
+      us.x -= z*ud.x - w*ud.y;
+      us.y -= z*ud.y + w*ud.x;
+      if (check != v)
+        screenmap[us.y][us.x] = screenchar(check->type);
+
+      XY temp = { -ud.x * v->d.x - ud.y * v->d.y, 
+                   ud.x * v->d.y - ud.y * v->d.x };
+      ud.x = temp.x * u->d.x - temp.y * u->d.y;
+      ud.y = temp.x * u->d.y + temp.y * u->d.x;
 
-  map_screen (player, objs[player].coord, objs[player].coord, angle, screenmap, 0);
-  for (screen.y = 0; screen.y < (signed)screenmap.size(); screen.y++)
-    for (screen.x = 0; screen.x < (signed)screenmap[0].size(); screen.x++) {
-      move(screen.y, screen.x);
-      int mapchar = screenmap[screen.y][screen.x];
-      addch(mapchar);
+      a = ((COLS/2) - us.x) * -ud.y + ((LINES/2) - us.y) * ud.x;
+      b = ((COLS/2) - us.x) *  ud.x + ((LINES/2) - us.y) * ud.y;
     }
+  }
+}
 
-  // drawing aiming sight
-  XY sight;
-  sight.x = objs[player].coord.x + objs[0].d.x;
-  sight.y = objs[player].coord.y + objs[0].d.y;
-  if (!findobj(sight)) {
-    screen.x = (COLS / 2) + objs[0].d.x;
-    screen.y = (LINES / 2)+ objs[0].d.y;
-    move (screen.y, screen.x);
-    attrset(color_pair(objs[0].type));
-    if (screenmap[screen.y][screen.x] == screenchar(NONE))
-      addch (250 | A_ALTCHARSET);
-    else {
-      int targetblock = screenmap[screen.y][screen.x] & 0x00ff;
-      addch (targetblock | A_ALTCHARSET);
+void draw_screen_angle (int angle, vector<vector<chtype> >& screenmap) {
+  if (angle) {
+    vector<chtype> blankline(COLS, screenchar(NONSTICK));
+    vector<vector<chtype> > angledmap(LINES, blankline);
+    double c = cos (angle * (M_PI / 180));
+    double s = sin (angle * (M_PI / 180));
+    int oy = LINES/2;
+    int ox = COLS/2;
+    for (int y = -oy; y < (LINES - oy); y++) {
+      for (int x = -ox; x < (COLS - ox); x++) {
+        int nx = qround (c*x - s*y) + ox;
+        int ny = qround (s*x + c*y) + oy;
+        if (nx >= 0 && nx < COLS && ny >= 0 && ny < LINES)
+          angledmap[y+oy][x+ox] = screenmap[ny][nx];
+      }
     }
+    for (int y = 0; y < LINES; y++)
+      mvaddchnstr(y, 0, &angledmap[y][0], COLS);
+  }
+  else {
+    for (int y = 0; y < LINES; y++)
+      mvaddchnstr(y, 0, &screenmap[y][0], COLS);
+    scrollmessage();
   }
-  mvaddch (LINES / 2, COLS / 2, obj_screenchar(player));
+
   if (animateportal) animateportal--;
   attrset(color_pair(NONE));
-  if (statustick > ticks) mvprintw(LINES - 1, 0, "%s", statusmsg.c_str());
-  if (lvlname.size() && (ticks < 200)) {
+  if (statustick > ticks)
+    mvprintw(LINES - 1, 0, "%s", statusmsg.c_str());
+  if (lvlname.size() && (ticks < 200))
     mvprintw(LINES - 1, COLS - lvlname.size(), "%s", lvlname.c_str());
-  }
-  scrollmessage();
   refresh();
 }
 
-void draw_screen (int player) {
-  draw_screen_angle (player, 0);
+void draw_screen () {
+  vector<vector<chtype> > screenmap;
+  map_screen (screenmap);
+  draw_screen_angle (0, screenmap);
 }
 
-void draw_rotate (int player, int num) { // num is the number of 90 degree rotations necessary;
+void draw_rotate (int num) { // num is the number of 90 degree rotations necessary;
   int step = 3;
   if (num > 2 || ((num == 2) && (rand() % 2)))
     step = -3;
 
+  vector<vector<chtype> > screenmap;
+  map_screen (screenmap);
   for (int angle = step + 90 * (4 - num); (angle > 0) && (angle < 360); angle += step) {
-    draw_screen_angle (player, angle);
-    napms(10);
+    draw_screen_angle (angle, screenmap);
+    napms(5);
   }
 }
 
@@ -504,6 +525,7 @@
 #else
   if (!def) {
     SDL_Init( SDL_INIT_EVERYTHING );
+    if (fullscreen) width = height = 0; // use current resolution
     pdc_screen = SDL_SetVideoMode(width, height, 32, SDL_SWSURFACE | (SDL_FULLSCREEN * fullscreen));
   }
 #endif
@@ -531,6 +553,6 @@
 void graphics_deinit () {
   endwin ();
 #ifndef __NOSDL__
-  SDL_Quit();
+//  SDL_Quit();
 #endif
 }
diff -Nur asciiportal1.2c/ap_draw.h asciiportal-mod/ap_draw.h
--- asciiportal1.2c/ap_draw.h	2011-05-01 16:09:12.275594732 +0200
+++ asciiportal-mod/ap_draw.h	2011-05-01 16:09:12.268928100 +0200
@@ -25,6 +25,9 @@
 #ifndef AP_DRAW_H_INCLUDED
 #define AP_DRAW_H_INCLUDED
 
+#include <curses.h>
+#include "ap_object.h"
+
 int color_pair(int);
 
 void fillscreen (int);
@@ -39,17 +42,15 @@
 
 void scrollmessage ();
 
-int findobj(XY);
-
 int screenchar(int);
 
-void map_screen (int, XY, XY, int, std::vector<std::vector<int> >&, int);
+void map_screen (std::vector<std::vector<chtype> >&);
 
-void draw_screen_angle (int player, int angle);
+void draw_screen_angle (int angle);
 
-void draw_rotate (int, int);
+void draw_rotate (int);
 
-void draw_screen (int);
+void draw_screen ();
 
 void graphics_init (int, int, int, int, std::string);
 
diff -Nur asciiportal1.2c/ap_input.cpp asciiportal-mod/ap_input.cpp
--- asciiportal1.2c/ap_input.cpp	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/ap_input.cpp	2011-05-01 16:09:12.272261416 +0200
@@ -45,7 +45,6 @@
 #include "ap_input.h"
 #include "menu.h"
 
-extern vector <object> objs;
 extern statstype levelstats;
 extern int level;
 extern int maxlevel;
@@ -512,6 +511,6 @@
   return hasevent;
 }
 
-int pauserun (int d) {
+void pauserun (int d) {
   delay = d;
 }
diff -Nur asciiportal1.2c/ap_input.h asciiportal-mod/ap_input.h
--- asciiportal1.2c/ap_input.h	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/ap_input.h	2011-05-01 16:09:12.268928100 +0200
@@ -33,6 +33,6 @@
 
 int pollevent ();
 
-int pauserun (int);
+void pauserun (int);
 
 #endif // AP_INPUT_H_INCLUDED
diff -Nur asciiportal1.2c/ap_object.cpp asciiportal-mod/ap_object.cpp
--- asciiportal1.2c/ap_object.cpp	1970-01-01 01:00:00.000000000 +0100
+++ asciiportal-mod/ap_object.cpp	2011-05-01 16:09:12.272261416 +0200
@@ -0,0 +1,138 @@
+#include <iostream>
+#include <stdio.h>
+#include "ap_object.h"
+
+using namespace std;
+
+void ObjectManager::addobj(object& obj) {
+  if (obj.coord.x < 0) obj.coord.x = 0;
+  if (obj.coord.y < 0) obj.coord.y = 0;
+  if (obj.coord.x >= mw) obj.coord.x = mw-1;
+  if (obj.coord.y >= mh) obj.coord.y = mh-1;
+  objs.push_back(obj);
+  objiter it = --objs.end();
+  switch (it->type) {
+    case SHOT1: shots[0] = it; break;
+    case SHOT2: shots[1] = it; break;
+  }
+  objmap[obj.coord.y][obj.coord.x].push_back(it);
+}
+
+objiter ObjectManager::delobj(objiter it) {
+  switch (it->type) {
+    case PLAYER:  player     = NULLOBJ; break;
+    case PORTAL1: portals[0] = NULLOBJ; break;
+    case PORTAL2: portals[1] = NULLOBJ; break;
+    case SHOT1:   shots[0]   = NULLOBJ; break;
+    case SHOT2:   shots[1]   = NULLOBJ; break;
+  }
+  objmap[it->coord.y][it->coord.x].remove(it);
+  return objs.erase(it);
+}
+
+void ObjectManager::moveobj(objiter it, int x, int y) {
+  if (x < 0) x = 0;
+  if (y < 0) y = 0;
+  if (x >= mw) x = mw-1;
+  if (y >= mh) y = mh-1;
+  objmap[it->coord.y][it->coord.x].remove(it);
+  objmap[y][x].push_back(it);
+  it->coord.y = y;
+  it->coord.x = x;
+}
+
+void ObjectManager::resetmap(int w, int h) {
+  mw = w;
+  mh = h;
+
+  NULLOBJ = objs.end();
+  player = portals[0] = portals[1] = shots[0] = shots[1] = NULLOBJ;
+
+  vector<objiter> a;
+  doors.assign(13, a);
+  switches.assign(13, a);
+  triggers.assign(9, a);
+  
+  objset s;
+  vector<objset> v(w, s);
+  objmap.assign(h, v);
+
+  for (objiter it = objs.begin(); it != objs.end(); it++) {
+    objmap[it->coord.y][it->coord.x].push_back(it);
+    switch (it->type) {
+      case PLAYER:  player     = it; break;
+      case PORTAL1: portals[0] = it; break;
+      case PORTAL2: portals[1] = it; break;
+      case DOOR:
+        doors[it->d.y].push_back(it); break;
+      case SWITCH:
+        switches[it->d.y].push_back(it); break;
+      case TEXTTRIGGER:
+        triggers[it->d.y].push_back(it); break;
+    }
+  }
+}
+
+void ObjectManager::killtriggers(int n) {
+  for (int i = 0; i < triggers[n].size(); i++) {
+    objiter it = triggers[n][i];
+    objmap[it->coord.y][it->coord.x].remove(it);
+    objs.erase(it);
+  }
+  triggers[n].clear();
+}
+
+int ObjectManager::verify() {
+#define FAIL(msg) { cout << msg << '\n'; return 0; }
+  int nmapobj = 0;
+  for (int y = 0; y < objmap.size(); y++)
+    for (int x = 0; x < objmap[y].size(); x++)
+      nmapobj += objmap[y][x].size();
+  if (nmapobj != objs.size()) FAIL("number of objects mismatch");
+
+  objiter pl, por[2], sht[2];
+  pl = por[0] = por[1] = sht[0] = sht[1] = NULLOBJ;
+  for (objiter it = objs.begin(); it != objs.end(); it++) {
+    switch (it->type) {
+      case PLAYER:  pl     = it; break;
+      case PORTAL1: por[0] = it; break;
+      case PORTAL2: por[1] = it; break;
+      case SHOT1:   sht[0] = it; break;
+      case SHOT2:   sht[1] = it; break;
+    }
+    int found = 0;
+    objset *s = &objmap[it->coord.y][it->coord.x];
+    for (objset::iterator sit = s->begin(); sit != s->end(); sit++)
+      if (*sit == it) found = 1;
+    if (!found) FAIL("object not found in objmap");
+  }
+  if (player != pl) {
+    cout << "player is " << ((player == NULLOBJ) ? "" : "not ") << "null\n";
+    cout << "but should be " << ((pl == NULLOBJ) ? "" : "not ") << "null\n";
+    FAIL("bad player ref");
+  }
+  if (portals[0] != por[0]) FAIL("bad portals[0] ref");
+  if (shots[0] != sht[0]) FAIL("bad shots[0] ref");
+  if (portals[1] != por[1]) FAIL("bad portals[1] ref");
+  if (shots[1] != sht[1]) FAIL("bad shots[1] ref");
+  return 1;
+}
+
+void ObjectManager::dump() {
+  printf ("\n========\nOBJECT LIST:\n");
+  for (objiter it = objs.begin(); it != objs.end(); it++)
+    printf ("  %d %d %d %d %d %d\n", it->coord.x, it->coord.y, it->type, it->tick, it->d.x, it->d.y);
+  printf ("\nOBJECT MAP:\n");
+  for (int y = 0; y < objmap.size(); y++) {
+    for (int x = 0; x < objmap[y].size(); x++) {
+      objset *s = &objmap[y][x];
+      if (s->size()) {
+        printf ("  at x=%d,y=%d:\n", x, y);
+        for (objset::iterator it = s->begin(); it != s->end(); it++) {
+          printf ("    %d %d %d %d %d %d\n", (*it)->coord.x, (*it)->coord.y, (*it)->type, (*it)->tick, (*it)->d.x, (*it)->d.y);
+          printf ("    addr of coord.x field = %p\n", (void *) &((*it)->coord.x)); 
+        }
+      }
+    }
+  }
+}
diff -Nur asciiportal1.2c/ap_object.h asciiportal-mod/ap_object.h
--- asciiportal1.2c/ap_object.h	1970-01-01 01:00:00.000000000 +0100
+++ asciiportal-mod/ap_object.h	2011-05-01 16:09:12.268928100 +0200
@@ -0,0 +1,41 @@
+#ifndef AP_OBJECT_H_INCLUDED
+#define AP_OBJECT_H_INCLUDED
+
+#include <vector>
+#include <list>
+#include "asciiportal.h"
+
+using namespace std;
+
+class object {
+  public:
+  XY coord;
+  int type, tick;
+  XY d;
+};
+
+typedef list<object>::iterator objiter;
+typedef list<objiter> objset;
+
+class ObjectManager {
+  public:
+  list<object> objs;
+  vector< vector<objset> > objmap;
+  objiter NULLOBJ;
+  objiter player;
+  objiter portals[2];
+  objiter shots[2];
+  vector< vector<objiter> > doors;
+  vector< vector<objiter> > switches;
+  vector< vector<objiter> > triggers;
+  int mw, mh;
+  void resetmap(int w, int h);
+  void addobj(object& obj);
+  objiter delobj(objiter it);
+  void moveobj(objiter it, int x, int y);
+  void killtriggers(int n);
+  int verify();
+  void dump();
+};
+
+#endif // AP_OBJECT_H_INCLUDED
diff -Nur asciiportal1.2c/ap_play.cpp asciiportal-mod/ap_play.cpp
--- asciiportal1.2c/ap_play.cpp	2011-05-01 16:09:12.282261363 +0200
+++ asciiportal-mod/ap_play.cpp	2011-05-01 16:09:12.275594732 +0200
@@ -27,7 +27,6 @@
 #include <iostream>
 #include <fstream>
 #include <string>
-#include <string>
 #include <vector>
 #include <ctime>
 #include <cmath>
@@ -43,6 +42,7 @@
 #include "ap_draw.h"
 #include "ap_input.h"
 #include "menu.h"
+#include "ap_object.h"
 
 const int beatspermove = 2;
 const int boulderbeats = 2;
@@ -61,13 +61,14 @@
 extern int animateportal;
 
 // from draw.cpp
-extern int CharData[MAXObjects][5];
+extern const int CharData[MAXObjects][5];
 extern int cheatview;
 
 #include <sys/time.h>
 
 vector<vector<int> > map;
-vector <object> objs;
+ObjectManager objm;
+object aimobject;
 string lvlname, texttrigger[9];
 int ticks = 0;
 int level, maxlevel;
@@ -82,7 +83,7 @@
   for (yy = 0; yy < 9; yy++)
     texttrigger[yy].clear();
   map.clear();
-  objs.clear();
+  objm.objs.clear();
   lvlname.clear();
   stopmessages ();
 
@@ -104,13 +105,11 @@
     return 0;
   }
 
-  object aimobject; // objs[0] will be reserved for aim data
   aimobject.coord.x = 1; // used to remember x
   aimobject.type = SHOT1;
   aimobject.tick = 0;
   aimobject.d.x = 1;
   aimobject.d.y = 0;
-  objs.push_back(aimobject);
 
   vector<int> blankline(rawmaps_maxwidth[lvl] + 2, NONSTICK); // one extra line to start
   map.push_back(blankline);
@@ -183,7 +182,7 @@
             }
             if (newobject.type == PLAYER) hasplayer++;
 
-            objs.push_back(newobject);
+            objm.objs.push_back(newobject);
           }
         }
       }
@@ -193,7 +192,9 @@
   }
   map.push_back(blankline);
 
-  if ((signed)objs.size() == 0) {
+  objm.resetmap(map[0].size(), map.size());
+
+  if (objm.objs.size() == 0) {
     mvprintw (LINES / 2 - 1, (COLS - 20) / 2, "Error in level %03d", lvl + 1);
     mvprintw (LINES / 2 , (COLS - 24) / 2,"Level contains no objects", lvl + 1);
     mvprintw (LINES / 2 + 1, (COLS - 11) / 2, "Press a key");
@@ -231,7 +232,7 @@
 }
 
 int hitswall(int yy, int xx) {
-  if ((yy < 0) || (yy > (signed)map.size()) || (xx < 0) || (xx > (signed)map[0].size()))
+  if ((yy < 0) || (yy >= map.size()) || (xx < 0) || (xx >= map[0].size()))
     return NONSTICK;
   switch (map[yy][xx]) {
     case NONE:
@@ -244,127 +245,128 @@
   return map[yy][xx];
 }
 
-int hitsobj(int num, int yy, int xx) { // returns object number of hit object or num
-  int val = num;
+objiter hitsobj(objiter it0, int yy, int xx) { // returns iterator to hit object, else it0
+  objiter val = it0;
 
-  for (int c = 1; c < (signed)objs.size(); c++) {
-    if ((objs[c].coord.x == xx) && (objs[c].coord.y == yy) && (c != num)) {
-      if ((objs[c].type == SHOT1) || (objs[c].type == SHOT2) || (objs[c].type == FLASH) || (objs[c].type == NONE)) {
-      } else {
-        if (objs[c].type == TEXTTRIGGER) {
-          if (val == num) val = c; // Texttriggers get lowest priority.
-          else continue;
-        }
-        if (objs[c].type == DOOR) {
-          if (objs[c].d.x > 0) val = c;
-        } else val = c;
-        if ((objs[c].type == PORTAL1) && (objs[c].type == PORTAL2)) // Portals get more priority
-          return val;
+  if (xx < 0 || xx >= objm.objmap[yy].size() || yy < 0 || yy >= objm.objmap.size())
+    return val;
+
+  objset *s = &(objm.objmap[yy][xx]);
+  for (objset::iterator it = s->begin(); it != s->end(); it++) {
+    if (*it != it0) {
+      switch ((*it)->type) {
+        case SHOT1:
+        case SHOT2:
+        case FLASH:
+        case NONE:
+          break;
+        case TEXTTRIGGER:
+          if (val == it0) val = *it; // Texttriggers get lowest priority.
+          break;
+        case DOOR:
+          if ((*it)->d.x > 0) val = *it;
+          break;
+        case PORTAL1:
+        case PORTAL2: // Portals get highest priority
+          return *it;
+          break;
+        default:
+          val = *it;
+          break;
       }
     }
   }
   return val;
 }
 
-int still_alive (int pl) {
-  if (pl < 0) return 0;
-  if ((objs[pl].type != PLAYER)) return 0;
-  if (objs[pl].coord.y > (signed)map.size()) return 0;
-
-  int underplayer = map[(int)objs[pl].coord.y][(int)objs[pl].coord.x];
-  if (underplayer == FFIELD) return 0;
-  if (underplayer == SPIKE) return 0;
-  int hitobject = objs[hitsobj(pl, objs[pl].coord.y, objs[pl].coord.x)].type;
+int still_alive () {
+  if (objm.player == objm.NULLOBJ || objm.player->coord.y > map.size()) return 0;
+
+  int underplayer = map[objm.player->coord.y][objm.player->coord.x];
+  if (underplayer == FFIELD || underplayer == SPIKE) return 0;
+
+  int hitobject = hitsobj(objm.player, objm.player->coord.y, objm.player->coord.x)->type;
   if (hitobject == BOULDER) return 0;
+
   return 1;
 }
 
-void fireportal (int por, int pl) {
+void fireportal (int por) {
 #ifndef __NOSOUND__
   play_sound(GUNSHOT);
 #endif
-  for (int c = 1; c < (signed)objs.size(); c++) {
-    if (objs[c].type == por) objs.erase(objs.begin() + c--);
+  if (objm.shots[por - SHOT1] != objm.NULLOBJ) {
+    objm.shots[por - SHOT1]->type = NONE;
+    objm.shots[por - SHOT1] = objm.NULLOBJ;
   }
   object newobject;
-  newobject.coord.x = objs[pl].coord.x + objs[0].d.x;
-  newobject.coord.y = objs[pl].coord.y + objs[0].d.y;
+  newobject.coord.x = objm.player->coord.x + aimobject.d.x;
+  newobject.coord.y = objm.player->coord.y + aimobject.d.y;
   newobject.type = por;
-  newobject.d.x = objs[0].d.x;
-  newobject.d.y = objs[0].d.y;
-  objs.push_back(newobject);
+  newobject.tick = 0;
+  newobject.d.x = aimobject.d.x;
+  newobject.d.y = aimobject.d.y;
+  objm.addobj(newobject);
 }
 
-
-
-int in_portal () { // Technically both portals are the same space.
-  int por1, por2;
-  por1 = por2 = 0;
-
-  for (int c = 1; c < (signed)objs.size(); c++) {
-    if (objs[c].type == PORTAL1) por1 = c;
-    if (objs[c].type == PORTAL2) por2 = c;
-  }
-  if (por1 && por2) {
-    int smacked = hitsobj(por1, objs[por1].coord.y, objs[por1].coord.x);
+objiter in_portal () { // Technically both portals are the same space.
+  objiter por1 = objm.portals[0];
+  objiter por2 = objm.portals[1];
+  if (por1 != objm.NULLOBJ && por2 != objm.NULLOBJ) {
+    objiter smacked = hitsobj(por1, por1->coord.y, por1->coord.x);
     if (por1 != smacked)
       return smacked;
-    smacked = hitsobj(por2, objs[por2].coord.y, objs[por2].coord.x);
+    smacked = hitsobj(por2, por2->coord.y, por2->coord.x);
     if (por2 != smacked)
       return smacked;
   }
-  return 0;
+  return objm.NULLOBJ;
 }
 
 int switch_in_portal() { // find what's in the portal and switch it to the other portal
-  int c_obj = in_portal();
-  if (c_obj) {
-    int por1, por2;
-    por1 = por2 = 0;
-
-    for (int c = 1; c < (signed)objs.size(); c++) {
-      if (objs[c].type == PORTAL1) por1 = c;
-      if (objs[c].type == PORTAL2) por2 = c;
-    }
-    if ((objs[c_obj].coord.x == objs[por2].coord.x) && (objs[c_obj].coord.y == objs[por2].coord.y)) {
-      int t = por2;
+  objiter c_obj = in_portal();
+  objiter por1 = objm.portals[0];
+  objiter por2 = objm.portals[1];
+
+  if (c_obj != objm.NULLOBJ) {
+    if ((c_obj->coord.x == por2->coord.x) && (c_obj->coord.y == por2->coord.y)) {
+      objiter t = por2;
       por2 = por1;
       por1 = t;
     } // por1 is from, por 2 is to.
 
-    if (objs[por1].d.x == 0) objs[c_obj].d.x = 0;
-    if (objs[por1].d.y == 0) objs[c_obj].d.y = 0; // only allow one direction vector through.
+    if (por1->d.x == 0) c_obj->d.x = 0;
+    if (por1->d.y == 0) c_obj->d.y = 0; // only allow one direction vector through.
 
-    objs[c_obj].coord.x = objs[por2].coord.x;
-    objs[c_obj].coord.y = objs[por2].coord.y; // move
+    objm.moveobj(c_obj, por2->coord.x, por2->coord.y);
 
     XY temp, control; // rotate d vector
     int rotation = 0;
-    control.x = -objs[por1].d.x; control.y = -objs[por1].d.y;
-    while (!((control.x == objs[por2].d.x) && (control.y == objs[por2].d.y))) {
+    control.x = -por1->d.x; control.y = -por1->d.y;
+    while (!((control.x == por2->d.x) && (control.y == por2->d.y))) {
       temp.x = control.x; temp.y = control.y;
       control.x = temp.y; control.y = -temp.x;
-      temp.x = objs[c_obj].d.x; temp.y = objs[c_obj].d.y;
-      objs[c_obj].d.x = temp.y; objs[c_obj].d.y = -temp.x;
+      temp.x = c_obj->d.x; temp.y = c_obj->d.y;
+      c_obj->d.x = temp.y; c_obj->d.y = -temp.x;
       rotation++;
     }
 
-    if (objs[c_obj].type == PLAYER) {
-      if (objs[0].d.x == -objs[por2].d.x) { // try to avoid flipflop scenarios due to aiming.
-        if (objs[0].d.y != 0) objs[0].d.x = 0;
-        else objs[0].d.x = -objs[0].d.x;
-      }
-      if (objs[0].d.y == -objs[por2].d.y) {
-        if (objs[0].d.x != 0) objs[0].d.y = 0;
-        else objs[0].d.y = -objs[0].d.y;
+    if (c_obj->type == PLAYER) {
+      if (aimobject.d.x == -por2->d.x) { // try to avoid flipflop scenarios due to aiming.
+        if (aimobject.d.y != 0) aimobject.d.x = 0;
+        else aimobject.d.x = -aimobject.d.x;
+      }
+      if (aimobject.d.y == -por2->d.y) {
+        if (aimobject.d.x != 0) aimobject.d.y = 0;
+        else aimobject.d.y = -aimobject.d.y;
       }
     }
 
-    if (objs[c_obj].d.x == 2 * sc(objs[c_obj].d.x))
-	    objs[c_obj].d.x = sc(objs[c_obj].d.x); // slow the slide for small drops
-	  if (objs[c_obj].d.y == -1) objs[c_obj].d.y = -2; // help out of holes.
-	  if ((objs[c_obj].type == PLAYER) && (objs[por2].d.y == -1) && (objs[c_obj].d.y == 0) && (objs[c_obj].d.x == 0)) objs[c_obj].d.y = -2;
-	  if (objs[c_obj].d.y < -2) objs[c_obj].d.y++;
+    if (c_obj->d.x == 2 * sc(c_obj->d.x))
+      c_obj->d.x = sc(c_obj->d.x); // slow the slide for small drops
+    if (c_obj->d.y == -1) c_obj->d.y = -2; // help out of holes.
+    if ((c_obj->type == PLAYER) && (por2->d.y == -1) && (c_obj->d.y == 0) && (c_obj->d.x == 0)) c_obj->d.y = -2;
+    if (c_obj->d.y < -2) c_obj->d.y++;
 
     return rotation;
   }
@@ -380,8 +382,8 @@
 int por_col (int yy, int xx) { // Collision speciffic to portal shots
   int col = map[yy][xx];
   if ((yy < 0) || (yy >= (signed)map.size())
-	|| (xx < 0) || (xx >= (signed)map[0].size()))
-	col = NONSTICK;
+  || (xx < 0) || (xx >= (signed)map[0].size()))
+  col = NONSTICK;
   else switch (map[yy][xx]) {
     case NONE:
     case GOAL:
@@ -394,9 +396,10 @@
     case PFIELD:
       col = NONSTICK;
   }
-  int colobj = hitsobj(0, yy, xx);
-  switch (objs[colobj].type) {
-    case DOOR : if (objs[colobj].d.x > 0) col = NONSTICK; break;
+  objiter colobj = hitsobj(objm.NULLOBJ, yy, xx);
+  if (colobj != objm.NULLOBJ)
+  switch (colobj->type) {
+    case DOOR : if (colobj->d.x > 0) col = NONSTICK; break;
     case DUPLICATOR :
     case PORTAL1:
     case PORTAL2:
@@ -405,62 +408,62 @@
   return col;
 }
 
-int will_hit (int c) {
-  int c_obj; // = hitsobj(c, objs[c].coord.y + d.y, objs[c].coord.x + d.x);
-  int c_wall; // = hitswall(objs[c].coord.y + d.y, objs[c].coord.x + d.x);
+int will_hit (objiter c) {
+  objiter c_obj; // = hitsobj(c, c->coord.y + d.y, c->coord.x + d.x);
+  int c_wall; // = hitswall(c->coord.y + d.y, c->coord.x + d.x);
   XY d;
 
-  if ((objs[c].type == BOULDER) && ((objs[c].d.y > 0) || (ticks % boulderbeats))) {
+  if ((c->type == BOULDER) && ((c->d.y > 0) || (ticks % boulderbeats)))
     d.x = 0;
-  } else d.x = sc(objs[c].d.x);
-  d.y = sc(objs[c].d.y);
+  else
+    d.x = sc(c->d.x);
+  d.y = sc(c->d.y);
 
-  c_obj = hitsobj(c, objs[c].coord.y + d.y, objs[c].coord.x + d.x);
-  c_wall = hitswall(objs[c].coord.y + d.y, objs[c].coord.x + d.x);
+  c_obj = hitsobj(c, c->coord.y + d.y, c->coord.x + d.x);
+  c_wall = hitswall(c->coord.y + d.y, c->coord.x + d.x);
 
-  if ((c_obj != c) && (objs[c_obj].type != NONE)) { // if hit object
-    int objtype = objs[c_obj].type;
+  if ((c_obj != c) && (c_obj->type != NONE)) { // if hit object
+    int objtype = c_obj->type;
 
     if (objtype == TEXTTRIGGER) {
-      if (objs[c].type == PLAYER) {
-        if (texttrigger[(signed)objs[c_obj].d.y].size()) {
-          startscrollmessage(texttrigger[objs[c_obj].d.y]);
+      if (c->type == PLAYER) {
+        if (texttrigger[c_obj->d.y].size()) {
+          startscrollmessage(texttrigger[c_obj->d.y]);
 #ifndef __NOSOUND__
           play_sound(VOICE + rand() % 10);
 #endif
         }
-        for (int z = 0; z < (signed)objs.size(); z++)
-          if ((objs[z].type == TEXTTRIGGER) && (objs[z].d.y == objs[c_obj].d.y))
-            objs[z].type = NONE;
+        objm.killtriggers(c_obj->d.y);
       }
-      if ((objs[c].type == SWITCH) || (objs[c].type == SWITCHON))
+      if ((c->type == SWITCH) || (c->type == SWITCHON))
         return objtype;
       return NONE;
     }
     if ((objtype == PORTAL1) || (objtype == PORTAL2)) { // if hit portal
-      if (((objs[c_obj].d.x != 0) && (objs[c_obj].d.x != d.x))
-        || ((objs[c_obj].d.y != 0) && (objs[c_obj].d.y != d.y))) { // only allow in if portal is right direction
-        int other = (objtype == PORTAL1) ? PORTAL2 : PORTAL1; // find the other portal
-        int other_por;
-        for (other_por = 1; (other_por < (signed)objs.size()) && (objs[other_por].type != other); other_por++) ;
-        if (other_por < (signed)objs.size()) { // Yes 2 portals present
-          if ((in_portal()) && (c != in_portal())) { // if something's in the other portal
-            c_obj = in_portal();
-            objtype = objs[c_obj].type;
-          } else objtype = NONE;
+      if (((c_obj->d.x != 0) && (c_obj->d.x != d.x))
+          || ((c_obj->d.y != 0) && (c_obj->d.y != d.y))) { // only allow in if portal is right direction
+        objiter other_por = objm.portals[(objtype == PORTAL1) ? 1 : 0]; // get the other portal
+        if (other_por != objm.NULLOBJ) { // Yes 2 portals present
+          objiter inp = in_portal();
+          if (inp != objm.objs.end() && c != inp) { // if something's in the other portal
+            c_obj = inp;
+            objtype = c_obj->type;
+          }
+          else objtype = NONE;
         }
-      } else objtype = c_wall;
+      }
+      else objtype = c_wall;
     }
 
-    if (((objs[c].type == PLAYER) || (objs[c].type == BOULDER)) && (objtype == BOX)) {
-      if (!objs[c].d.y) {
-        objs[c_obj].d.x += d.x;
-        if ((move_object (c_obj)) && (objs[c].type != BOULDER)) {
+    if (((c->type == PLAYER) || (c->type == BOULDER)) && (objtype == BOX)) {
+      if (!c->d.y) {
+        c_obj->d.x += d.x;
+        if ((move_object (c_obj)) && (c->type != BOULDER)) {
           objtype = NONE;
         }
       }
     }
-    if ((objs[c].type == PLAYER) && (objtype == BOULDER)) { // if player hit boulder
+    if ((c->type == PLAYER) && (objtype == BOULDER)) { // if player hit boulder
       if (d.y <= 0) {
 #ifndef __NOSOUND__
         play_sound (CRUSH);
@@ -468,20 +471,23 @@
 #ifndef __NOSOUND__
         play_sound (CRUSH);
 #endif
-        objs[c].type = NONE; //   kill player
+        objm.player = objm.NULLOBJ;
+        c->type = NONE; //   kill player
         return NONE;
       } else d.y = 0;
-    } else if ((objs[c].type == BOULDER) && (objtype == PLAYER)) { // if boulder hit player
+    } else if ((c->type == BOULDER) && (objtype == PLAYER)) { // if boulder hit player
 #ifndef __NOSOUND__
-	    play_sound (CRUSH);
+      play_sound (CRUSH);
 #endif
-      objs[c_obj].type = NONE;
+      objm.player = objm.NULLOBJ;
+      c_obj->type = NONE;
       return NONE;
     }
     return objtype;
   }
-  if ((objs[c].type == PLAYER) && (c_wall == SPIKE)) {
-    objs[c].type = NONE; //   kill player
+  if ((c->type == PLAYER) && (c_wall == SPIKE)) {
+    objm.player = objm.NULLOBJ;
+    c->type = NONE; //   kill player
 #ifndef __NOSOUND__
     play_sound (CRUSH);
 #endif
@@ -490,149 +496,154 @@
   return c_wall;
 }
 
-int applyd (int c) {
+int applyd (objiter c) {
   int dx, dy;
 
-  if ((objs[c].type == BOULDER) && ((objs[c].d.y != 0) || (ticks % boulderbeats))) {
+  if ((c->type == BOULDER) && ((c->d.y != 0) || (ticks % boulderbeats))) {
     dx = 0;
-  } else dx = sc(objs[c].d.x);
-  dy = sc(objs[c].d.y);
-  objs[c].coord.x += dx; objs[c].coord.y += dy;
-  if (objs[c].type != BOULDER) {
-    if (objs[c].d.x != 0) objs[c].d.x -= dx;
-  } else if ((objs[c].d.x < -1) || (objs[c].d.x > 1)) objs[c].d.x -= dx;
-  if (objs[c].d.y < 0) objs[c].d.y++;
-
-  if (objs[c].coord.y < 0) objs[c].coord.y = 0; //  bounds checking
-  if (objs[c].coord.x < 0) objs[c].coord.x = 0;
-  if (objs[c].coord.y >= (signed)map.size()) objs[c].coord.y = (signed)map.size() - 1;
-  if (objs[c].coord.x >= (signed)map[0].size()) objs[c].coord.x = (signed)map[0].size() - 1;
+  } else dx = sc(c->d.x);
+  dy = sc(c->d.y);
+  objm.moveobj(c, c->coord.x + dx, c->coord.y + dy);
+  if (c->type != BOULDER) {
+    if (c->d.x != 0) c->d.x -= dx;
+  } else if ((c->d.x < -1) || (c->d.x > 1)) c->d.x -= dx;
+  if (c->d.y < 0) c->d.y++;
 
   if (dx || dy) return 1;
   return 0;
 }
 
-int collapse_portals () {
+void collapse_portals () {
   int playsound = 0;
 
-  int in_por = in_portal();
-  if (in_por) {
-    int por1, por2;
-    for (int d = 1; d < (signed)objs.size(); d++) {
-      if (((objs[d].type == PORTAL1) || (objs[d].type == PORTAL2))
-        && (in_por == hitsobj(d, objs[d].coord.y, objs[d].coord.x)))
-        por1 = d;
-      else por2 = d;
-    }
-    objs[in_por].d.x += objs[por1].d.x; // push anything stuck in portal out.
-    objs[in_por].d.y += objs[por1].d.y; // before collapsing it.
-    objs[in_por].tick--; // make sure a move is possible.
+  objiter in_por = in_portal();
+  if (in_por != objm.NULLOBJ) {
+    objiter por1 = objm.portals[0];
+    objiter por2 = objm.portals[1];
+    if (in_por == hitsobj(por2, por2->coord.y, por2->coord.x)) { // FIXME: redundant, need to rework in_portal()
+      por1 = objm.portals[1];
+      por2 = objm.portals[0];
+    }
+    in_por->d.x += por1->d.x; // push anything stuck in portal out.
+    in_por->d.y += por1->d.y; // before collapsing it.
+    in_por->tick--; // make sure a move is possible.
     if (!move_object(in_por)) {
       switch_in_portal();
-      objs[in_por].d.x += objs[por2].d.x;
-      objs[in_por].d.y += objs[por2].d.y;
-      objs[in_por].tick--;
-      if (!move_object(in_por)) objs[in_por].type = FLASH;
+      in_por->d.x += por2->d.x;
+      in_por->d.y += por2->d.y;
+      in_por->tick--;
+      if (!move_object(in_por)) {
+        if (in_por->type == PLAYER)
+          objm.player = objm.NULLOBJ; // a unique way to die
+        in_por->type = FLASH;
+      }
     }
   }
 
-  for (int e = 1; e < (signed)objs.size(); e++)
-  if ((objs[e].type == PORTAL1) || (objs[e].type == PORTAL2)
-    || (objs[e].type == SHOT1) || (objs[e].type == SHOT2)) {
-    objs[e].d.y = CharData[objs[e].type][2];
-    objs[e].type = FLASH; // cancel all portals
-    playsound = 1;
+  // cancel all portals
+  for (int i = 0; i < 2; i++) {
+    if (objm.portals[i] != objm.NULLOBJ) {
+      objm.portals[i]->d.y = CharData[PORTAL1 + i][2];
+      objm.portals[i]->type = FLASH;
+      objm.portals[i] = objm.NULLOBJ;
+      playsound = 1;
+    }
+    if (objm.shots[i] != objm.NULLOBJ) {
+      objm.shots[i]->d.y = CharData[SHOT1 + i][2];
+      objm.shots[i]->type = FLASH;
+      objm.shots[i] = objm.NULLOBJ;
+      playsound = 1;
+    }
   }
+
 #ifndef __NOSOUND__
-  if (playsound == 1) play_sound (PORTALCOLLAPSE);
+  if (playsound) play_sound (PORTALCOLLAPSE);
 #endif
 }
 
-int move_object (int c) { // collision detection and movement.
-  int c_obj;
+int move_object (objiter c) { // collision detection and movement.
+  objiter c_obj;
 
-  if (objs[c].tick >= ticks) return 0;
-  objs[c].tick = ticks;
-  if (objs[c].type == BOX) objs[c].tick--;
+  if (c->tick >= ticks) return 0;
+  c->tick = ticks;
+  if (c->type == BOX) c->tick--;
 
-  c_obj = hitsobj(c, objs[c].coord.y, objs[c].coord.x);
-  if ((objs[c_obj].type == PORTAL1) || (objs[c_obj].type == PORTAL2)) { // if obj[c] is in portal
+  c_obj = hitsobj(c, c->coord.y, c->coord.x);
+  if ((c_obj->type == PORTAL1) || (c_obj->type == PORTAL2)) { // if obj[c] is in portal
     int needswitch = 0;
-    if ((objs[c].d.x) && (sc(objs[c].d.x) == -objs[c_obj].d.x)) needswitch = 1;
-    if ((objs[c].d.y) && (sc(objs[c].d.y) == -objs[c_obj].d.y)) needswitch = 1;
-    if (objs[c].type == PLAYER) {
-      if ((objs[0].d.x) && (sc(objs[0].d.x) == -objs[c_obj].d.x)) needswitch = 1;
-      if ((objs[0].d.y) && (sc(objs[0].d.y) == -objs[c_obj].d.y)) needswitch = 1;
+    if ((c->d.x) && (sc(c->d.x) == -c_obj->d.x)) needswitch = 1;
+    if ((c->d.y) && (sc(c->d.y) == -c_obj->d.y)) needswitch = 1;
+    if (c->type == PLAYER) {
+      if ((aimobject.d.x) && (sc(aimobject.d.x) == -c_obj->d.x)) needswitch = 1;
+      if ((aimobject.d.y) && (sc(aimobject.d.y) == -c_obj->d.y)) needswitch = 1;
     }
 
     if (needswitch) { // if facing the right way
       int rotations = switch_in_portal();
-      c_obj = hitsobj(c, objs[c].coord.y, objs[c].coord.x);
-      if (objs[c].type == PLAYER) {
+      c_obj = hitsobj(c, c->coord.y, c->coord.x);
+      if (c->type == PLAYER) {
 #ifndef __NOSOUND__
         play_sound(THROUGH);
 #endif
-        draw_rotate(c, rotations);
+        draw_rotate(rotations);
       }
     }
   } // And that's how portals should work.
 
   XY oldd;
 
-  oldd.x = objs[c].d.x; oldd.y = objs[c].d.y;
+  oldd.x = c->d.x; oldd.y = c->d.y;
   if (will_hit(c) == NONE) return applyd(c);
-  objs[c].d.y = 0;
+  c->d.y = 0;
   if (will_hit(c) == NONE) return applyd(c); // try without dy
-  if ((objs[c].type == PLAYER) && (objs[c].d.x)) {
-    objs[c].d.y = -1; // step up;
+  if ((c->type == PLAYER) && (c->d.x)) {
+    c->d.y = -1; // step up;
 
-    int porcheck = hitsobj(c, objs[c].coord.y, objs[c].coord.x);
-    if ((objs[porcheck].type == PORTAL1) || (objs[porcheck].type == PORTAL2)) {
-      if (objs[porcheck].d.y == 1) {
+    objiter porcheck = hitsobj(c, c->coord.y, c->coord.x);
+    if ((porcheck->type == PORTAL1) || (porcheck->type == PORTAL2)) {
+      if (porcheck->d.y == 1) {
         int rotations = switch_in_portal();
-        c_obj = hitsobj(c, objs[c].coord.y, objs[c].coord.x);
+        c_obj = hitsobj(c, c->coord.y, c->coord.x);
 #ifndef __NOSOUND__
         play_sound(THROUGH);
 #endif
-        draw_rotate(c, rotations);
+        draw_rotate(rotations);
       }
     }
     if (will_hit(c) == NONE) return applyd(c);
-    objs[c].d.y = 0;
+    c->d.y = 0;
   }
-  objs[c].d.y = oldd.y;
-  if (objs[c].type == BOULDER) {
-    objs[c].d.x = -sc(oldd.x);
-  } else objs[c].d.x = 0;
+  c->d.y = oldd.y;
+  if (c->type == BOULDER) {
+    c->d.x = -sc(oldd.x);
+  } else c->d.x = 0;
   if (will_hit(c) == NONE) return applyd(c); // try without dx
-  objs[c].d.y = 0;
+  c->d.y = 0;
   return 0; // didn't move
 }
 
-int physics () { // returns the index of the player so we don't have to search for this 3 times.
-  int playerindex = 0;
+int physics () {
   int por = 0;
 
-  for (int c = 1; c < (signed)objs.size(); c++) {
-
+  for (objiter c = objm.objs.begin(); c != objm.objs.end(); c++) {
     por = 0;
-    switch (objs[c].type) { // Every tick movements (like gravity)
+    switch (c->type) { // Every tick movements (like gravity)
       case NONE: break;
       case DUPLICATOR:
-        if (objs[c].d.y > 0) objs[c].d.y--;
+        if (c->d.y > 0) c->d.y--;
         else {
-          int dupe = hitsobj(c, objs[c].coord.y - 1, objs[c].coord.x);
-          if ((c != dupe) && (objs[dupe].type != PLAYER)
-            && (c == hitsobj(c, objs[c].coord.y + 1, objs[c].coord.x))) {
+          objiter dupe = hitsobj(c, c->coord.y - 1, c->coord.x);
+          if ((c != dupe) && (dupe->type == BOX || dupe->type == BOULDER)
+            && (c == hitsobj(c, c->coord.y + 1, c->coord.x))) {
             object newobject;
-            newobject.coord.x = objs[c].coord.x;
-            newobject.coord.y = objs[c].coord.y;
-            newobject.type = objs[dupe].type;
-            newobject.tick = objs[dupe].tick;
-            newobject.d.x = objs[dupe].d.x;
+            newobject.coord.x = c->coord.x;
+            newobject.coord.y = c->coord.y;
+            newobject.type = dupe->type;
+            newobject.tick = dupe->tick;
+            newobject.d.x = dupe->d.x;
             newobject.d.y = 0;
-            objs.push_back(newobject);
-            objs[c].d.y = beatsperdupe;
+            objm.addobj(newobject);
+            c->d.y = beatsperdupe;
 #ifndef __NOSOUND__
             if (newobject.type == BOX) play_sound (DUPLICATE);
 #endif
@@ -643,39 +654,38 @@
       case SWITCH:
       case SWITCHON: {
         int playsound = 0;
-        int colobj = hitsobj(c, objs[c].coord.y - 1, objs[c].coord.x);
+        objiter colobj = hitsobj(c, c->coord.y - 1, c->coord.x);
         if (c != colobj) {
-          if (objs[c].type == SWITCH) {
-            objs[c].type = SWITCHON;
-            if ((objs[colobj].type == PLAYER) || (objs[colobj].type == BOX)) playsound = 2;
+          if (c->type == SWITCH) {
+            c->type = SWITCHON;
+            if ((colobj->type == PLAYER) || (colobj->type == BOX)) playsound = 2;
           }
           int otheropen = 0;
-          for (int s = 1; s < (signed)objs.size(); s++)
-            if ((objs[s].type == SWITCH) && (objs[s].d.y == objs[c].d.y))
+          for (int i = 0; i < objm.switches[c->d.y].size(); i++)
+            if (objm.switches[c->d.y][i]->type == SWITCH)
               otheropen = 1;
           if (!otheropen) // open the doors
-            for (int d = 1; d < (signed)objs.size(); d++) {
-              if ((objs[d].type == DOOR) && (objs[d].d.y == objs[c].d.y)) {
-                if (((objs[colobj].type == PLAYER) || (objs[colobj].type == BOX)) && (objs[d].d.x == 4)) playsound = 1;
-                if (--objs[d].d.x < 0) objs[d].d.x = 0;
-              }
+            for (int i = 0; i < objm.doors[c->d.y].size(); i++) {
+              objiter d = objm.doors[c->d.y][i];
+              if (((colobj->type == PLAYER) || (colobj->type == BOX)) && (d->d.x == 4)) playsound = 1;
+              if (--d->d.x < 0) d->d.x = 0;
             }
 #ifndef __NOSOUND__
           if (playsound == 1) play_sound(DOOROPEN);
           if (playsound == 2) play_sound(SWITCHHIT);
 #endif
         } else {
-          objs[c].type = SWITCH;
-          for (int d = 1; d < (signed)objs.size(); d++) {
-            if ((objs[d].type == DOOR) && (objs[d].d.y == objs[c].d.y))
-              if (objs[c].d.y >= 6) { // if it's a momentary switch
-                if (d == hitsobj(d, objs[d].coord.y, objs[d].coord.x)) { // and there's nothing in the door
-                  if (objs[d].d.x == 0) playsound = 1;
-                  if (++objs[d].d.x > 4) objs[d].d.x = 4; // close the door
-                }
-              } else if (objs[d].d.x < 4) // else finish opening the door.
-                if (--objs[d].d.x < 0) objs[d].d.x = 0;
-            }
+          c->type = SWITCH;
+          for (int i = 0; i < objm.doors[c->d.y].size(); i++) {
+            objiter d = objm.doors[c->d.y][i];
+            if (c->d.y >= 6) { // if it's a momentary switch
+              if (d == hitsobj(d, d->coord.y, d->coord.x)) { // and there's nothing in the door
+                if (d->d.x == 0) playsound = 1;
+                if (++d->d.x > 4) d->d.x = 4; // close the door
+              }
+            } else if (d->d.x < 4) // else finish opening the door.
+              if (--d->d.x < 0) d->d.x = 0;
+          }
 #ifndef __NOSOUND__
           if (playsound == 1) play_sound(DOORCLOSE);
 #endif
@@ -695,148 +705,150 @@
         por = 1;
       case SHOT1: // gravityless
         for (int z = 0; z < portalspeed; z++) {
-		      int col = por_col(objs[c].coord.y, objs[c].coord.x);
+          int col = por_col(c->coord.y, c->coord.x);
           if (col) {
             if (col == NONSTICK) {
-              objs[c].d.y = CharData[objs[c].type][2];
-              objs[c].type = FLASH;
+              c->d.y = CharData[c->type][2];
+              objm.shots[c->type - SHOT1] = objm.NULLOBJ;
+              c->type = FLASH;
 #ifndef __NOSOUND__
               play_sound (PORTALFAIL);
 #endif
               z = portalspeed; continue;
             }
             // Calculate portal normal.
-            int east = por_col(objs[c].coord.y, objs[c].coord.x + 1);
-            if (objs[hitsobj(c,objs[c].coord.y, objs[c].coord.x + 1)].type == DOOR) east = NONE;
+            int east = por_col(c->coord.y, c->coord.x + 1);
+            if (hitsobj(c,c->coord.y, c->coord.x + 1)->type == DOOR) east = NONE;
 
-            int west = por_col(objs[c].coord.y, objs[c].coord.x - 1);
-            if (objs[hitsobj(c,objs[c].coord.y, objs[c].coord.x - 1)].type == DOOR) west = NONE;
+            int west = por_col(c->coord.y, c->coord.x - 1);
+            if (hitsobj(c,c->coord.y, c->coord.x - 1)->type == DOOR) west = NONE;
 
-            int north= por_col(objs[c].coord.y - 1, objs[c].coord.x);
-            if (objs[hitsobj(c,objs[c].coord.y - 1, objs[c].coord.x)].type == DOOR) north = NONE;
+            int north= por_col(c->coord.y - 1, c->coord.x);
+            if (hitsobj(c,c->coord.y - 1, c->coord.x)->type == DOOR) north = NONE;
 
-            int south= por_col(objs[c].coord.y + 1, objs[c].coord.x);
-            if (objs[hitsobj(c,objs[c].coord.y + 1, objs[c].coord.x)].type == DOOR) south = NONE;
+            int south= por_col(c->coord.y + 1, c->coord.x);
+            if (hitsobj(c,c->coord.y + 1, c->coord.x)->type == DOOR) south = NONE;
 
-            int yback= por_col(objs[c].coord.y - objs[c].d.y, objs[c].coord.x);
-            if (map[objs[c].coord.y - objs[c].d.y][objs[c].coord.x] == FFIELD) yback = NONSTICK;
+            int yback= por_col(c->coord.y - c->d.y, c->coord.x);
+            if (map[c->coord.y - c->d.y][c->coord.x] == FFIELD) yback = NONSTICK;
 
-            int xback= por_col(objs[c].coord.y, objs[c].coord.x - objs[c].d.x);
-            if (map[objs[c].coord.y][objs[c].coord.x - objs[c].d.x] == FFIELD) xback = NONSTICK;
+            int xback= por_col(c->coord.y, c->coord.x - c->d.x);
+            if (map[c->coord.y][c->coord.x - c->d.x] == FFIELD) xback = NONSTICK;
 
             if (east && west && yback == NONE) {
-              objs[c].d.x = 0; objs[c].d.y = -objs[c].d.y;
+              c->d.x = 0; c->d.y = -c->d.y;
             } else if (south && north && xback == NONE) {
-              objs[c].d.y = 0; objs[c].d.x = -objs[c].d.x;
+              c->d.y = 0; c->d.x = -c->d.x;
             } else {
 #ifndef __NOSOUND__
               play_sound (PORTALFAIL);
 #endif
-              objs[c].d.y = CharData[objs[c].type][2];
-              objs[c].type = FLASH;
+              c->d.y = CharData[c->type][2];
+              objm.shots[c->type - SHOT1] = objm.NULLOBJ;
+              c->type = FLASH;
               z = portalspeed; continue;
             }
-            for (int d = 1; d < (signed)objs.size(); d++) {
-              if ((c != d) && (objs[d].type == (PORTAL1 + por))) {
-                int in_por = hitsobj(d, objs[d].coord.y, objs[d].coord.x);
-                if ((in_por != d) && (objs[in_por].type != PORTAL1) && (objs[in_por].type != PORTAL2)){
-                  objs[in_por].d.x += objs[d].d.x; // push anything stuck in portal out.
-                  objs[in_por].d.y += objs[d].d.y; // before collapsing it.
-                  if (!move_object(in_por)) {
-                    switch_in_portal();
-                  }
+            if (objm.portals[por] != objm.NULLOBJ) {
+              objiter d = objm.portals[por];
+              objiter in_por = hitsobj(d, d->coord.y, d->coord.x);
+              if ((in_por != d) && (in_por->type != PORTAL1) && (in_por->type != PORTAL2)){
+                in_por->d.x += d->d.x; // push anything stuck in portal out.
+                in_por->d.y += d->d.y; // before collapsing it. FIXME: similar code elsewhere-- remove the redundancy
+                if (!move_object(in_por)) {
+                  switch_in_portal();
                 }
-                objs[d].d.y = CharData[objs[d].type][2];
-                objs[d].type = FLASH;
               }
+              d->d.y = CharData[d->type][2];
+              d->type = FLASH;
             }
             levelstats.numportals++;
             animateportal = 2;
 #ifndef __NOSOUND__
-		        play_sound (PORTALCREATE);
+            play_sound (PORTALCREATE);
 #endif
-            objs[c].type = PORTAL1 + por;
-            objs[0].type = SHOT1 + ((por + 1) % 2);
+            objm.shots[c->type - SHOT1] = objm.NULLOBJ;
+            objm.portals[por] = c;
+            c->type = PORTAL1 + por;
+            aimobject.type = SHOT1 + ((por + 1) % 2);
             z = portalspeed;
           } else {
-            objs[c].coord.y += objs[c].d.y;
-            objs[c].coord.x += objs[c].d.x;
+            objm.moveobj(c, c->coord.x + c->d.x, c->coord.y + c->d.y);
           }
         }
         continue;
       case PLAYER: // gravity
-        if (move_player(c) < 0) return -1;
-        playerindex = c;
-        if (map[objs[c].coord.y + 1][objs[c].coord.x + objs[c].d.x] == LADDER) break;
-        if (map[objs[c].coord.y + 1][objs[c].coord.x] == LADDER) break;
-        if (map[objs[c].coord.y][objs[c].coord.x] == LADDER) break;
-        if (map[objs[c].coord.y + sc(objs[c].d.y)][objs[c].coord.x + sc(objs[c].d.x)] == LADDER) break;
+        if (move_player() < 0) return -1;
+        if (map[c->coord.y + 1][c->coord.x + c->d.x] == LADDER) break;
+        if (map[c->coord.y + 1][c->coord.x] == LADDER) break;
+        if (map[c->coord.y][c->coord.x] == LADDER) break;
+        if (map[c->coord.y + sc(c->d.y)][c->coord.x + sc(c->d.x)] == LADDER) break;
       case BOULDER: {
-        if ((map[objs[c].coord.y + 1][objs[c].coord.x] == LADDER) && (rand() < RAND_MAX / 2)) break;
+        if ((map[c->coord.y + 1][c->coord.x] == LADDER) && (rand() < RAND_MAX / 2)) break;
       }
       case BOX:
-        if ((objs[c].d.x > 2) || (objs[c].d.x < -2) || (objs[c].d.y < -2)) break; // fling!
-        if (++objs[c].d.y > maxfling) objs[c].d.y = maxfling;
+        if ((c->d.x > 2) || (c->d.x < -2) || (c->d.y < -2)) break; // fling!
+        if (++(c->d.y) > maxfling) c->d.y = maxfling;
       default:
         break;
     } // End every tick movements.
 
     if (!(ticks % beatspermove)) { // X-axis automovements
-      switch (objs[c].type) {
+      switch (c->type) {
         case BOULDER:
-          if (objs[c].d.x == 0) objs[c].d.x = (rand() < RAND_MAX / 2) ? 1 : -1;
+          if (c->d.x == 0) c->d.x = (rand() < RAND_MAX / 2) ? 1 : -1;
           break;
         case PLAYER:
         case BOX:
-          switch (map[objs[c].coord.y + 1][objs[c].coord.x]) {
+          switch (map[c->coord.y + 1][c->coord.x]) {
             case LTREAD:
-			  if (objs[c].d.x == 0) objs[c].d.x --;
-			  break;
+        if (c->d.x == 0) c->d.x --;
+        break;
             case RTREAD:
-			  if (objs[c].d.x == 0) objs[c].d.x ++;
-			  break;
+        if (c->d.x == 0) c->d.x ++;
+        break;
           }
           break;
       }
     }
     move_object(c);
 
-    switch (objs[c].type) { // kill objects / clean up
+    switch (c->type) { // kill objects / clean up
       case PLAYER:
-        if (map[objs[c].coord.y][objs[c].coord.x] == LADDER) {
-          objs[c].d.y = 0;
-          objs[c].d.x = 0;
+        if (map[c->coord.y][c->coord.x] == LADDER) {
+          c->d.y = 0;
+          c->d.x = 0;
         }
       case BOULDER:
       case BOX: {
-        switch (map[objs[c].coord.y][objs[c].coord.x]) {
+        switch (map[c->coord.y][c->coord.x]) {
           case PFIELD: {
-            int playsound = 0;
-            if (objs[c].type == PLAYER) {
+            if (c->type == PLAYER) {
               collapse_portals();
             } else {
 #ifndef __NOSOUND__
-			        play_sound (SIZZLE);
+              play_sound (SIZZLE);
 #endif
-              objs[c].d.y = COLOR_WHITE;
-              objs[c].type = FLASH;
+              c->d.y = COLOR_WHITE;
+              c->type = FLASH;
             }
             break;
           }
           case XFIELD:
 #ifndef __NOSOUND__
-		        play_sound (SIZZLE);
+            play_sound (SIZZLE);
 #endif
-            objs[c].d.y = COLOR_WHITE;
-            objs[c].type = FLASH;
+            c->d.y = COLOR_WHITE;
+            if (c->type == PLAYER)
+              objm.player = objm.NULLOBJ;
+            c->type = FLASH;
         }
       }
     }
   }
-  return playerindex;
+  return 0;
 }
 
-int move_player (int pl) {
+int move_player () {
   int input;
   XY d;
 
@@ -846,41 +858,45 @@
     return 1;
   }
   switch (input) {
-    case '1' : objs[0].d.y =  1; objs[0].d.x = -1; break;
-    case '2' : objs[0].d.y =  1; objs[0].d.x =  0; break;
-    case '3' : objs[0].d.y =  1; objs[0].d.x =  1; break;
-    case '4' : objs[0].d.y =  0; objs[0].d.x = -1; break;
-    case '6' : objs[0].d.y =  0; objs[0].d.x =  1; break;
-    case '7' : objs[0].d.y = -1; objs[0].d.x = -1; break;
-    case '8' : objs[0].d.y = -1; objs[0].d.x =  0; break;
-    case '9' : objs[0].d.y = -1; objs[0].d.x =  1; break;
+    case '1' : aimobject.d.y =  1; aimobject.d.x = -1; break;
+    case '2' : aimobject.d.y =  1; aimobject.d.x =  0; break;
+    case '3' : aimobject.d.y =  1; aimobject.d.x =  1; break;
+    case '4' : aimobject.d.y =  0; aimobject.d.x = -1; break;
+    case '6' : aimobject.d.y =  0; aimobject.d.x =  1; break;
+    case '7' : aimobject.d.y = -1; aimobject.d.x = -1; break;
+    case '8' : aimobject.d.y = -1; aimobject.d.x =  0; break;
+    case '9' : aimobject.d.y = -1; aimobject.d.x =  1; break;
     case '0' :
     case 'Z' :
-    case 'z' : objs[0].type = SHOT1; fireportal(objs[0].type, pl); break;
+    case 'z' : aimobject.type = SHOT1; fireportal(aimobject.type); break;
     case '.' :
     case 'X' :
-    case 'x' : objs[0].type = SHOT2; fireportal(objs[0].type, pl); break;
+    case 'x' : aimobject.type = SHOT2; fireportal(aimobject.type); break;
     case 'C' :
     case 'c' : collapse_portals (); break;
     case '5' :
     case '\n':
     case ' ' :
-      fireportal(objs[0].type, pl);
+      fireportal(aimobject.type);
       break;
     case '?' : help_menu (); break;
     case 27 : // ASCII for escape
     case KEY_F(1) :
     case 'P' :
     case 'p' : {
-      int pause=pause_menu(pl);
+      int pause = pause_menu();
       switch (pause) {
         case 0 : break; // Resume
-        case 1 : objs[pl].type = NONE; break; // Restart
+        case 1 :
+          objm.player->type = NONE;
+          objm.player = objm.NULLOBJ;
+          break; // Restart
         case 2 : {
           int newlvl = select_level (maxlevel, level); // Select Level
           if (newlvl != level) {
             level = newlvl;
-            objs[pl].type = NONE;
+            objm.player->type = NONE;
+            objm.player = objm.NULLOBJ;
             ticks = 0;
             levelstats.clear();
             levelstats.numdeaths --; // Correct since death is the tool for this one.
@@ -910,7 +926,7 @@
     case '-' :
     case '[' :
       gamespeed --;
-      if (gamespeed > maxspeed) gamespeed = maxspeed - 1;
+      if (gamespeed >= maxspeed) gamespeed = maxspeed - 1;
       else if (gamespeed < 1) gamespeed = 1;
       else switch (gamespeed) {
         case 1 : statusmessage ("Very slow speed"); break;
@@ -934,59 +950,59 @@
     case 'd' :
     case 'D' :
     case KEY_RIGHT :
-      if (objs[0].d.x == 1) {
-        if (objs[pl].d.x <= 0) objs[pl].d.x ++;
+      if (aimobject.d.x == 1) {
+        if (objm.player->d.x <= 0) objm.player->d.x ++;
         levelstats.numsteps++;
       } else {
-        objs[0].coord.x = objs[0].d.x = 1;
+        aimobject.coord.x = aimobject.d.x = 1;
       }
-      objs[0].d.y = 0;
+      aimobject.d.y = 0;
       break;
     case 'a' :
     case 'A' :
     case KEY_LEFT :
-      if (objs[0].d.x == -1) {
-        if (objs[pl].d.x >= 0) objs[pl].d.x --;
+      if (aimobject.d.x == -1) {
+        if (objm.player->d.x >= 0) objm.player->d.x --;
         levelstats.numsteps++;
       } else {
-        objs[0].coord.x = objs[0].d.x = -1;
+        aimobject.coord.x = aimobject.d.x = -1;
       }
-      objs[0].d.y = 0;
+      aimobject.d.y = 0;
       break;
     case 'w' :
     case 'W' :
     case KEY_UP :
-      if ((map[objs[pl].coord.y][objs[pl].coord.x] == LADDER)
-      && ((!hitswall(objs[pl].coord.y - 1, objs[pl].coord.x) || (objs[hitsobj(pl, objs[pl].coord.y - 1, objs[pl].coord.x)].type == PORTAL1) || (objs[hitsobj(pl, objs[pl].coord.y - 1, objs[pl].coord.x)].type == PORTAL2))))
+      if ((map[objm.player->coord.y][objm.player->coord.x] == LADDER)
+      && ((!hitswall(objm.player->coord.y - 1, objm.player->coord.x) || (hitsobj(objm.player, objm.player->coord.y - 1, objm.player->coord.x)->type == PORTAL1) || (hitsobj(objm.player, objm.player->coord.y - 1, objm.player->coord.x)->type == PORTAL2))))
       {
-        if (objs[pl].d.y >= 0) objs[pl].d.y --;
+        if (objm.player->d.y >= 0) objm.player->d.y --;
         levelstats.numsteps++;
-      } else if ((objs[0].d.x == 0) && (objs[0].d.y > 0)) {
-        objs[0].d.x = objs[0].coord.x;
+      } else if ((aimobject.d.x == 0) && (aimobject.d.y > 0)) {
+        aimobject.d.x = aimobject.coord.x;
       } else {
-        objs[0].d.y--;
-        if (objs[0].d.y < -1) {
-          objs[0].d.y = -1;
-          objs[0].d.x = 0;
+        aimobject.d.y--;
+        if (aimobject.d.y < -1) {
+          aimobject.d.y = -1;
+          aimobject.d.x = 0;
         }
       }
       break;
     case 's' :
     case 'S' :
     case KEY_DOWN :
-      if (((map[(int)objs[pl].coord.y][(int)objs[pl].coord.x] == LADDER)
-      || (map[(int)objs[pl].coord.y + 1][(int)objs[pl].coord.x] == LADDER))
-      && ((!hitswall(objs[pl].coord.y + 1, objs[pl].coord.x) || (objs[hitsobj(pl, objs[pl].coord.y + 1, objs[pl].coord.x)].type == PORTAL1) || (objs[hitsobj(pl, objs[pl].coord.y + 1, objs[pl].coord.x)].type == PORTAL2))))
+      if (((map[objm.player->coord.y][objm.player->coord.x] == LADDER)
+      || (map[objm.player->coord.y + 1][objm.player->coord.x] == LADDER))
+      && ((!hitswall(objm.player->coord.y + 1, objm.player->coord.x) || (hitsobj(objm.player, objm.player->coord.y + 1, objm.player->coord.x)->type == PORTAL1) || (hitsobj(objm.player, objm.player->coord.y + 1, objm.player->coord.x)->type == PORTAL2))))
       {
-        objs[pl].d.y ++;
+        objm.player->d.y ++;
         levelstats.numsteps++;
-      } else if ((objs[0].d.x == 0) && (objs[0].d.y < 0)) {
-        objs[0].d.x = objs[0].coord.x;
+      } else if ((aimobject.d.x == 0) && (aimobject.d.y < 0)) {
+        aimobject.d.x = aimobject.coord.x;
       } else {
-        objs[0].d.y++;
-        if (objs[0].d.y > 1) {
-          objs[0].d.y = 1;
-          objs[0].d.x = 0;
+        aimobject.d.y++;
+        if (aimobject.d.y > 1) {
+          aimobject.d.y = 1;
+          aimobject.d.x = 0;
         }
       }
       break;
@@ -996,7 +1012,6 @@
 }
 
 int play (string mappack) {
-  int player = -1;
   unsigned long long int start, stop;
   double seconds;
 
@@ -1040,18 +1055,26 @@
   ticks = 0;
   levelstats.clear();
   while (level < (signed)rawmaps.size()) {
-    for (int c = 0; c < (signed)objs.size(); c++) // clean up NONEs.
-      if (objs[c].type == NONE)
-        objs.erase(objs.begin() + c--);
-      else if (objs[c].type == FLASH)
-        objs[c].type = NONE;
+    for (objiter c = objm.objs.begin(); c != objm.objs.end(); ) { // clean up NONEs.
+      if (c->type == FLASH) {
+        c->type = NONE;
+        c++;
+      }
+      else if (c->type == NONE) c = objm.delobj(c);
+      else c++;
+    }
 
     start = get_microseconds();
-    player = physics ();
-    if (player == -1) return 0;
-    if (still_alive(player)) {
-      draw_screen (player);
-      if (map[objs[player].coord.y][objs[player].coord.x] == GOAL) {
+/*
+    if (!objm.verify()) {
+      cout << "object manager state is inconsistent!\n";
+      return 0;
+    }
+*/
+    if (physics () < 0) return 0;
+    if (still_alive()) {
+      draw_screen ();
+      if (map[objm.player->coord.y][objm.player->coord.x] == GOAL) {
 #ifndef __NOSOUND__
         play_sound(WIN);
 #endif
@@ -1077,19 +1100,19 @@
         levelstats.clear();
       } else {
         stop = get_microseconds();
-		    seconds = ((double)stop - (double)start)/1000000.0;
-		    if (gamespeed > 0) {
+        seconds = ((double)stop - (double)start)/1000000.0;
+        if (gamespeed > 0) {
           if (seconds < (1.0 / beatspersecond[gamespeed]))
             restms (((1.0 / beatspersecond[gamespeed]) - seconds) * 1000);
           ticks++;
-		    } else {
-		      while (!pollevent()) {
-		        restms (150);
-		        draw_screen(player);
-		        refresh();
-		      }
-		      ticks++;
-		    }
+        } else {
+          while (!pollevent()) {
+            restms (150);
+            draw_screen();
+            refresh();
+          }
+          ticks++;
+        }
       }
     } else {
 #ifndef __NOSOUND__
@@ -1103,7 +1126,7 @@
       restms(150);
       while ((level < (signed)rawmaps.size()) && !setup_level(level, mappack)) level ++;
       flushinput();
-      draw_screen (player);
+//      draw_screen (player);
     }
   }
   roll_credits(mappack);
diff -Nur asciiportal1.2c/ap_play.h asciiportal-mod/ap_play.h
--- asciiportal1.2c/ap_play.h	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/ap_play.h	2011-05-01 16:09:12.268928100 +0200
@@ -25,23 +25,25 @@
 #ifndef AP_PLAY_H_INCLUDED
 #define AP_PLAY_H_INCLUDED
 
+#include "ap_object.h"
+
 int setup_level (int, std::string);
 
 int hitswall(int, int);
 
-int hitsobj(int, int, int);
+objiter hitsobj(objiter, int, int);
 
-int still_alive (int);
+int still_alive ();
 
-void fireportal (int, int);
+void fireportal (int);
 
 int sc (int x);
 
-int move_object (int);
+int move_object (objiter);
 
 int physics ();
 
-int move_player (int);
+int move_player ();
 
 int play (std::string);
 
diff -Nur asciiportal1.2c/asciiportal.h asciiportal-mod/asciiportal.h
--- asciiportal1.2c/asciiportal.h	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/asciiportal.h	2011-05-01 16:09:12.272261416 +0200
@@ -48,13 +48,6 @@
   int x; int y;
 };
 
-class object {
-  public:
-  XY coord;
-  int type, tick;
-  XY d;
-};
-
 class statstype {
   public:
   int numportals;
diff -Nur asciiportal1.2c/main.cpp asciiportal-mod/main.cpp
--- asciiportal1.2c/main.cpp	2011-05-01 16:09:12.282261363 +0200
+++ asciiportal-mod/main.cpp	2011-05-01 16:09:12.275594732 +0200
@@ -167,5 +167,5 @@
 
   graphics_deinit();
   cout << "Thank you for playing ASCIIpOrtal\n";
-  return 0;
+  _exit(0);
 }
diff -Nur asciiportal1.2c/menu.cpp asciiportal-mod/menu.cpp
--- asciiportal1.2c/menu.cpp	2011-05-01 16:09:12.282261363 +0200
+++ asciiportal-mod/menu.cpp	2011-05-01 16:09:12.275594732 +0200
@@ -40,11 +40,10 @@
 #include "ap_draw.h"
 #include "ap_input.h"
 
-#define PAUSE 200
+// #define PAUSE 200 // Achtung: conflicts with enum GameObjs in asciiportal.h. Not used anymore anyhow.
 
 using namespace std;
-extern vector <object> objs;
-extern int CharData[MAXColors][5];
+extern const int CharData[MAXColors][5];
 
 int chartoscreen(char o) {
   for (int c = 0; c < MAXObjects; c++)
@@ -170,15 +169,15 @@
   w += 5;
 
   while (1) {
-    fillsquare(LINES - 2 - items.size() * 2, 1 + s.x, items.size() * 2 + 1, w);
+    fillsquare(LINES - 2 - items.size() * 2, 1, items.size() * 2 + 1, w);
     for (int i = 0; i < (signed)items.size(); i++) {
       if (i != selection) attrset (color_pair(MENUDIM));
       else attrset (color_pair(MENUSELECT));
       mvprintw (LINES - 2 * (items.size() - i) - 1, 1, " %d) %s ", i + 1, items[i].c_str());
     }
     refresh ();
-    restms(1); // don't know why the menu doesn't want to show up without this. Ah well.
-    do {input = getinput();} while (input == ERR);
+//    restms(1); // don't know why the menu doesn't want to show up without this. Ah well.
+    do { restms(10); input = getinput(); } while (input == ERR);
     if ((input >= '1') && (input < '1' + (signed)items.size())) selection = input - '1';
     flushinput();
     switch (input) {
@@ -316,7 +315,7 @@
   return opt;
 }
 
-int pause_menu (int player) {
+int pause_menu () {
   vector<string> options;
   int yy;
 
@@ -327,7 +326,7 @@
   options.push_back("QUIT");
 
   for (yy = 0; yy < LINES; yy++)
-    mvchgat (yy, 0, -1, A_BOLD, CharData[PAUSE][2] + 8 * CharData[PAUSE][3], NULL);
+    mvchgat (yy, 0, -1, A_BOLD, 8 * CharData[PAUSE][2] + CharData[PAUSE][3], NULL);
   return menu(options, 0);
 }
 
@@ -486,7 +485,7 @@
 
 string select_mapset () {
   string mapset;
-  int inchar = 0;
+//  int inchar = 0;
 
   pauserun(1);
   attrset(color_pair(HELPMENU));
diff -Nur asciiportal1.2c/menu.h asciiportal-mod/menu.h
--- asciiportal1.2c/menu.h	2011-05-01 16:09:12.278928048 +0200
+++ asciiportal-mod/menu.h	2011-05-01 16:09:12.272261416 +0200
@@ -33,7 +33,7 @@
 
 int main_menu (std::string);
 
-int pause_menu (int);
+int pause_menu ();
 
 int select_level (int, int);
 
