diff --git a/src/Makefile.am b/src/Makefile.am
index 0296b3c..3f48745 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1048,7 +1048,8 @@ librtp_la_LIBADD = $(AM_LIBADD) libpulsecore-@PA_MAJORMINOR@.la libpulsecommon-@
 
 libraop_la_SOURCES = \
         modules/raop/raop_client.c modules/raop/raop_client.h \
-        modules/raop/base64.c modules/raop/base64.h
+        modules/raop/base64.c modules/raop/base64.h \
+        modules/raop/raop_packet_buffer.h modules/raop/raop_packet_buffer.c
 libraop_la_CFLAGS = $(AM_CFLAGS) $(OPENSSL_CFLAGS) -I$(top_srcdir)/src/modules/rtp
 libraop_la_LDFLAGS = $(AM_LDFLAGS) -avoid-version
 libraop_la_LIBADD = $(AM_LIBADD) $(OPENSSL_LIBS) libpulsecore-@PA_MAJORMINOR@.la librtp.la libpulsecommon-@PA_MAJORMINOR@.la libpulse.la
diff --git a/src/modules/raop/base64.c b/src/modules/raop/base64.c
index 37e4762..91b76ae 100644
--- a/src/modules/raop/base64.c
+++ b/src/modules/raop/base64.c
@@ -19,10 +19,10 @@
   USA.
 ***/
 
-/*
+/***
   This file was originally inspired by a file developed by
-    Kungliga Tekniska H�gskolan
-*/
+  Kungliga Tekniska Høgskolan.
+***/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
@@ -39,11 +39,17 @@ static const char base64_chars[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
 static int pos(char c) {
-    if (c >= 'A' && c <= 'Z') return c - 'A' + 0;
-    if (c >= 'a' && c <= 'z') return c - 'a' + 26;
-    if (c >= '0' && c <= '9') return c - '0' + 52;
-    if (c == '+') return 62;
-    if (c == '/') return 63;
+    if (c >= 'A' && c <= 'Z')
+        return c - 'A' + 0;
+    if (c >= 'a' && c <= 'z')
+        return c - 'a' + 26;
+    if (c >= '0' && c <= '9')
+        return c - '0' + 52;
+    if (c == '+')
+        return 62;
+    if (c == '/')
+        return 63;
+
     return -1;
 }
 
@@ -75,8 +81,10 @@ int pa_base64_encode(const void *data, int size, char **str) {
             p[2] = '=';
         p += 4;
     }
+
     *p = 0;
     *str = s;
+
     return strlen(s);
 }
 
@@ -86,6 +94,7 @@ static unsigned int token_decode(const char *token) {
     int i;
     unsigned int val = 0;
     int marker = 0;
+
     if (strlen(token) < 4)
         return DECODE_ERROR;
     for (i = 0; i < 4; i++) {
@@ -101,8 +110,10 @@ static unsigned int token_decode(const char *token) {
             val += lpos;
         }
     }
+
     if (marker > 2)
         return DECODE_ERROR;
+
     return (marker << 24) | val;
 }
 
@@ -122,5 +133,6 @@ int pa_base64_decode(const char *str, void *data) {
         if (marker < 1)
             *q++ = val & 0xff;
     }
+
     return q - (unsigned char *) data;
 }
diff --git a/src/modules/raop/base64.h b/src/modules/raop/base64.h
index 7a973b6..05194a0 100644
--- a/src/modules/raop/base64.h
+++ b/src/modules/raop/base64.h
@@ -23,10 +23,10 @@
   USA.
 ***/
 
-/*
+/***
   This file was originally inspired by a file developed by
-    Kungliga Tekniska Høgskolan
-*/
+  Kungliga Tekniska Høgskolan.
+***/
 
 int pa_base64_encode(const void *data, int size, char **str);
 int pa_base64_decode(const char *str, void *data);
diff --git a/src/modules/raop/module-raop-discover.c b/src/modules/raop/module-raop-discover.c
index fda5e29..2732ff1 100644
--- a/src/modules/raop/module-raop-discover.c
+++ b/src/modules/raop/module-raop-discover.c
@@ -54,6 +54,17 @@ PA_MODULE_LOAD_ONCE(true);
 
 #define SERVICE_TYPE_SINK "_raop._tcp"
 
+struct userdata {
+    pa_core *core;
+    pa_module *module;
+
+    AvahiPoll *avahi_poll;
+    AvahiClient *client;
+    AvahiServiceBrowser *sink_browser;
+
+    pa_hashmap *tunnels;
+};
+
 static const char* const valid_modargs[] = {
     NULL
 };
@@ -65,16 +76,6 @@ struct tunnel {
     uint32_t module_index;
 };
 
-struct userdata {
-    pa_core *core;
-    pa_module *module;
-    AvahiPoll *avahi_poll;
-    AvahiClient *client;
-    AvahiServiceBrowser *sink_browser;
-
-    pa_hashmap *tunnels;
-};
-
 static unsigned tunnel_hash(const void *p) {
     const struct tunnel *t = p;
 
@@ -104,11 +105,11 @@ static int tunnel_compare(const void *a, const void *b) {
     return 0;
 }
 
-static struct tunnel *tunnel_new(
+static struct tunnel* tunnel_new(
         AvahiIfIndex interface, AvahiProtocol protocol,
         const char *name, const char *type, const char *domain) {
-
     struct tunnel *t;
+
     t = pa_xnew(struct tunnel, 1);
     t->interface = interface;
     t->protocol = protocol;
@@ -116,6 +117,7 @@ static struct tunnel *tunnel_new(
     t->type = pa_xstrdup(type);
     t->domain = pa_xstrdup(domain);
     t->module_index = PA_IDXSET_INVALID;
+
     return t;
 }
 
@@ -136,88 +138,167 @@ static void resolver_cb(
         AvahiStringList *txt,
         AvahiLookupResultFlags flags,
         void *userdata) {
-
     struct userdata *u = userdata;
     struct tunnel *tnl;
+    char *nicename, *dname, *vname, *args;
+    char *tp = NULL, *et = NULL, *cn = NULL;
+    char *ch = NULL, *ss = NULL, *sr = NULL;
+    char *t = NULL;
+    char at[AVAHI_ADDRESS_STR_MAX];
+    AvahiStringList *l;
+    pa_module *m;
 
     pa_assert(u);
 
     tnl = tunnel_new(interface, protocol, name, type, domain);
 
-    if (event != AVAHI_RESOLVER_FOUND)
+    if (event != AVAHI_RESOLVER_FOUND) {
         pa_log("Resolving of '%s' failed: %s", name, avahi_strerror(avahi_client_errno(u->client)));
-    else {
-        char *device = NULL, *nicename, *dname, *vname, *args;
-        char at[AVAHI_ADDRESS_STR_MAX];
-        AvahiStringList *l;
-        pa_module *m;
-
-        if ((nicename = strstr(name, "@"))) {
-            ++nicename;
-            if (strlen(nicename) > 0) {
-                pa_log_debug("Found RAOP: %s", nicename);
-                nicename = pa_escape(nicename, "\"'");
-            } else
-                nicename = NULL;
-        }
+        goto  finish;
+    }
 
-        for (l = txt; l; l = l->next) {
-            char *key, *value;
-            pa_assert_se(avahi_string_list_get_pair(l, &key, &value, NULL) == 0);
+    if ((nicename = strstr(name, "@"))) {
+        ++nicename;
+        if (strlen(nicename) > 0) {
+            pa_log_debug("Found RAOP: %s", nicename);
+            nicename = pa_escape(nicename, "\"'");
+        } else
+            nicename = NULL;
+    }
 
-            pa_log_debug("Found key: '%s' with value: '%s'", key, value);
-            if (pa_streq(key, "device")) {
-                pa_xfree(device);
-                device = value;
-                value = NULL;
-            }
-            avahi_free(key);
-            avahi_free(value);
+    for (l = txt; l; l = l->next) {
+        char *key, *value;
+        pa_assert_se(avahi_string_list_get_pair(l, &key, &value, NULL) == 0);
+
+        pa_log_debug("Found key: '%s' with value: '%s'", key, value);
+
+        if (pa_streq(key, "tp")) {
+            /* Transport protocol:
+             *  - TCP = only TCP,
+             *  - UDP = only UDP,
+             *  - TCP,UDP = both supported (UDP should be prefered) */
+             if (pa_str_in_list(value, ",", "UDP"))
+                 tp = strdup("UDP");
+            else if (pa_str_in_list(value, ",", "TCP"))
+                tp = strdup("TCP");
+            else
+                tp = strdup(value);
+        } else if (pa_streq(key, "et")) {
+            /* Supported encryption types:
+             *  - 0 = none,
+             *  - 1 = RSA,
+             *  - 2 = FairPlay,
+             *  - 3 = MFiSAP,
+             *  - 4 = FairPlay SAPv2.5. */
+             if (pa_str_in_list(value, ",", "1"))
+                 et = strdup("RSA");
+             else
+                 et = strdup("none");
+        } else if (pa_streq(key, "cn")) {
+            /* Suported audio codecs:
+             *  - 0 = PCM,
+             *  - 1 = ALAC,
+             *  - 2 = AAC,
+             *  - 3 = AAC ELD. */
+            cn = strdup("PCM");
+        } else if (pa_streq(key, "md")) {
+            /* Supported metadata types:
+             *  - 0 = text,
+             *  - 1 = artwork,
+             *  - 2 = progress. */
+        } else if (pa_streq(key, "pw")) {
+            /* Requires password ? (true/false) */
+        } else if (pa_streq(key, "ch")) {
+            /* Number of channels */
+            ch = value;
+            value = NULL;
+        } else if (pa_streq(key, "ss")) {
+            /* Sample size */
+            ss = value;
+            value = NULL;
+        } else if (pa_streq(key, "sr")) {
+            /* Sample rate */
+            sr = value;
+            value = NULL;
         }
 
-        if (device)
-            dname = pa_sprintf_malloc("raop.%s.%s", host_name, device);
-        else
-            dname = pa_sprintf_malloc("raop.%s", host_name);
+        avahi_free(key);
+        avahi_free(value);
+    }
 
-        if (!(vname = pa_namereg_make_valid_name(dname))) {
-            pa_log("Cannot construct valid device name from '%s'.", dname);
-            avahi_free(device);
-            pa_xfree(dname);
-            goto finish;
-        }
+    dname = pa_sprintf_malloc("raop_output.%s", host_name);
+    if (!(vname = pa_namereg_make_valid_name(dname))) {
+        pa_log("Cannot construct valid device name from '%s'.", dname);
         pa_xfree(dname);
+        goto finish;
+    }
 
-        if (nicename) {
-            args = pa_sprintf_malloc("server=[%s]:%u "
-                                     "sink_name=%s "
-                                     "sink_properties='device.description=\"%s\"'",
-                                     avahi_address_snprint(at, sizeof(at), a), port,
-                                     vname,
-                                     nicename);
-            pa_xfree(nicename);
-        } else {
-            args = pa_sprintf_malloc("server=[%s]:%u "
-                                     "sink_name=%s",
-                                     avahi_address_snprint(at, sizeof(at), a), port,
-                                     vname);
-        }
+    pa_xfree(dname);
+
+    if (nicename) {
+        args = pa_sprintf_malloc("server=[%s]:%u "
+                                 "sink_name=%s "
+                                 "sink_properties='device.description=\"%s\"'",
+                                 avahi_address_snprint(at, sizeof(at), a), port,
+                                 vname,
+                                 nicename);
+        pa_xfree(nicename);
+    } else {
+        args = pa_sprintf_malloc("server=[%s]:%u "
+                                 "sink_name=%s",
+                                 avahi_address_snprint(at, sizeof(at), a), port,
+                                 vname);
+    }
 
-        pa_log_debug("Loading module-raop-sink with arguments '%s'", args);
+    if (tp != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s protocol=%s", args, tp);
+        avahi_free(tp);
+        pa_xfree(t);
+    }
+    if (et != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s encryption=%s", args, et);
+        pa_xfree(et);
+        pa_xfree(t);
+    }
+    if (cn != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s codec=%s", args, cn);
+        pa_xfree(cn);
+        pa_xfree(t);
+    }
+    if (ch != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s channels=%s", args, ch);
+        avahi_free(ch);
+        pa_xfree(t);
+    }
+    if (ss != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s format=%s", args, ss);
+        avahi_free(ss);
+        pa_xfree(t);
+    }
+    if (sr != NULL) {
+        t = args;
+        args = pa_sprintf_malloc("%s rate=%s", args, sr);
+        avahi_free(sr);
+        pa_xfree(t);
+    }
 
-        if ((m = pa_module_load(u->core, "module-raop-sink", args))) {
-            tnl->module_index = m->index;
-            pa_hashmap_put(u->tunnels, tnl, tnl);
-            tnl = NULL;
-        }
+    pa_log_debug("Loading module-raop-sink with arguments '%s'", args);
 
-        pa_xfree(vname);
-        pa_xfree(args);
-        avahi_free(device);
+    if ((m = pa_module_load(u->core, "module-raop-sink", args))) {
+        tnl->module_index = m->index;
+        pa_hashmap_put(u->tunnels, tnl, tnl);
+        tnl = NULL;
     }
 
-finish:
+    pa_xfree(vname);
+    pa_xfree(args);
 
+finish:
     avahi_service_resolver_free(r);
 
     if (tnl)
@@ -231,7 +312,6 @@ static void browser_cb(
         const char *name, const char *type, const char *domain,
         AvahiLookupResultFlags flags,
         void *userdata) {
-
     struct userdata *u = userdata;
     struct tunnel *t;
 
@@ -250,7 +330,7 @@ static void browser_cb(
 
         /* We ignore the returned resolver object here, since the we don't
          * need to attach any special data to it, and we can still destroy
-         * it from the callback */
+         * it from the callback. */
 
     } else if (event == AVAHI_BROWSER_REMOVE) {
         struct tunnel *t2;
@@ -277,9 +357,7 @@ static void client_callback(AvahiClient *c, AvahiClientState state, void *userda
         case AVAHI_CLIENT_S_REGISTERING:
         case AVAHI_CLIENT_S_RUNNING:
         case AVAHI_CLIENT_S_COLLISION:
-
             if (!u->sink_browser) {
-
                 if (!(u->sink_browser = avahi_service_browser_new(
                               c,
                               AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC,
@@ -301,16 +379,16 @@ static void client_callback(AvahiClient *c, AvahiClientState state, void *userda
 
                 pa_log_debug("Avahi daemon disconnected.");
 
+                /* Try to reconnect. */
                 if (!(u->client = avahi_client_new(u->avahi_poll, AVAHI_CLIENT_NO_FAIL, client_callback, u, &error))) {
                     pa_log("avahi_client_new() failed: %s", avahi_strerror(error));
                     pa_module_unload_request(u->module, true);
                 }
             }
 
-            /* Fall through */
+            /* Fall through. */
 
         case AVAHI_CLIENT_CONNECTING:
-
             if (u->sink_browser) {
                 avahi_service_browser_free(u->sink_browser);
                 u->sink_browser = NULL;
@@ -318,12 +396,12 @@ static void client_callback(AvahiClient *c, AvahiClientState state, void *userda
 
             break;
 
-        default: ;
+        default:
+            break;
     }
 }
 
-int pa__init(pa_module*m) {
-
+int pa__init(pa_module *m) {
     struct userdata *u;
     pa_modargs *ma = NULL;
     int error;
@@ -360,8 +438,9 @@ fail:
     return -1;
 }
 
-void pa__done(pa_module*m) {
-    struct userdata*u;
+void pa__done(pa_module *m) {
+    struct userdata *u;
+
     pa_assert(m);
 
     if (!(u = m->userdata))
diff --git a/src/modules/raop/module-raop-sink.c b/src/modules/raop/module-raop-sink.c
index 2d08645..22d153b 100644
--- a/src/modules/raop/module-raop-sink.c
+++ b/src/modules/raop/module-raop-sink.c
@@ -68,12 +68,13 @@ PA_MODULE_USAGE(
         "sink_name=<name for the sink> "
         "sink_properties=<properties for the sink> "
         "server=<address>  "
+        "protocol=<transport protocol> "
+        "encryption=<encryption type> "
+        "codec=<audio codec> "
         "format=<sample format> "
         "rate=<sample rate> "
         "channels=<number of channels>");
 
-#define DEFAULT_SINK_NAME "raop"
-
 struct userdata {
     pa_core *core;
     pa_module *module;
@@ -84,6 +85,8 @@ struct userdata {
     pa_rtpoll_item *rtpoll_item;
     pa_thread *thread;
 
+    pa_raop_protocol_t protocol;
+
     pa_memchunk raw_memchunk;
     pa_memchunk encoded_memchunk;
 
@@ -99,7 +102,6 @@ struct userdata {
     int32_t rate;
 
     pa_smoother *smoother;
-    int fd;
 
     int64_t offset;
     int64_t encoding_overhead;
@@ -109,12 +111,26 @@ struct userdata {
     pa_raop_client *raop;
 
     size_t block_size;
+
+    /* Members only for the TCP protocol */
+    int tcp_fd;
+
+    /* Members only for the UDP protocol */
+    int udp_control_fd;
+    int udp_timing_fd;
+
+    /* For UDP thread wakeup clock calculation */
+    pa_usec_t udp_playback_start;
+    uint32_t  udp_sent_packets;
 };
 
 static const char* const valid_modargs[] = {
     "sink_name",
     "sink_properties",
     "server",
+    "protocol",
+    "encryption",
+    "codec",
     "format",
     "rate",
     "channels",
@@ -122,47 +138,59 @@ static const char* const valid_modargs[] = {
 };
 
 enum {
-    SINK_MESSAGE_PASS_SOCKET = PA_SINK_MESSAGE_MAX,
-    SINK_MESSAGE_RIP_SOCKET
+    SINK_MESSAGE_TCP_PASS_SOCKET = PA_SINK_MESSAGE_MAX,
+    SINK_MESSAGE_TCP_RIP_SOCKET,
+    SINK_MESSAGE_UDP_SETUP,
+    SINK_MESSAGE_UDP_RECORD,
+    SINK_MESSAGE_UDP_DISCONNECTED,
 };
 
-/* Forward declaration */
+/* Forward declarations: */
 static void sink_set_volume_cb(pa_sink *);
 
-static void on_connection(int fd, void*userdata) {
+static void tcp_on_connection(int fd, void *userdata) {
     int so_sndbuf = 0;
     socklen_t sl = sizeof(int);
     struct userdata *u = userdata;
     pa_assert(u);
 
-    pa_assert(u->fd < 0);
-    u->fd = fd;
+    pa_assert(u->tcp_fd < 0);
+    u->tcp_fd = fd;
 
-    if (getsockopt(u->fd, SOL_SOCKET, SO_SNDBUF, &so_sndbuf, &sl) < 0)
+    if (getsockopt(u->tcp_fd, SOL_SOCKET, SO_SNDBUF, &so_sndbuf, &sl) < 0)
         pa_log_warn("getsockopt(SO_SNDBUF) failed: %s", pa_cstrerror(errno));
     else {
         pa_log_debug("SO_SNDBUF is %zu.", (size_t) so_sndbuf);
         pa_sink_set_max_request(u->sink, PA_MAX((size_t) so_sndbuf, u->block_size));
     }
 
-    /* Set the initial volume */
+    /* Set the initial volume. */
     sink_set_volume_cb(u->sink);
 
     pa_log_debug("Connection authenticated, handing fd to IO thread...");
 
-    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_PASS_SOCKET, NULL, 0, NULL, NULL);
+    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_TCP_PASS_SOCKET, NULL, 0, NULL, NULL);
 }
 
-static void on_close(void*userdata) {
+static void tcp_on_close(void*userdata) {
     struct userdata *u = userdata;
     pa_assert(u);
 
     pa_log_debug("Connection closed, informing IO thread...");
 
-    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_RIP_SOCKET, NULL, 0, NULL, NULL);
+    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_TCP_RIP_SOCKET, NULL, 0, NULL, NULL);
+}
+
+static pa_usec_t sink_get_latency(const struct userdata *u) {
+    pa_usec_t w, r;
+
+    r = pa_smoother_get(u->smoother, pa_rtclock_now());
+    w = pa_bytes_to_usec((u->offset - u->encoding_overhead + (u->encoded_memchunk.length / u->encoding_ratio)), &u->sink->sample_spec);
+
+    return w > r ? w - r : 0;
 }
 
-static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+static int tcp_sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
     struct userdata *u = PA_SINK(o)->userdata;
 
     switch (code) {
@@ -176,9 +204,9 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
 
                     pa_smoother_pause(u->smoother, pa_rtclock_now());
 
-                    /* Issue a FLUSH if we are connected */
-                    if (u->fd >= 0) {
-                        pa_raop_flush(u->raop);
+                    /* Issue a FLUSH if we are connected. */
+                    if (u->tcp_fd >= 0) {
+                        pa_raop_client_flush(u->raop);
                     }
                     break;
 
@@ -189,11 +217,11 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
                         pa_smoother_resume(u->smoother, pa_rtclock_now(), true);
 
                         /* The connection can be closed when idle, so check to
-                           see if we need to reestablish it */
-                        if (u->fd < 0)
-                            pa_raop_connect(u->raop);
+                         * see if we need to reestablish it. */
+                        if (u->tcp_fd < 0)
+                            pa_raop_client_connect(u->raop);
                         else
-                            pa_raop_flush(u->raop);
+                            pa_raop_client_flush(u->raop);
                     }
 
                     break;
@@ -207,37 +235,32 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
             break;
 
         case PA_SINK_MESSAGE_GET_LATENCY: {
-            pa_usec_t w, r;
-
-            r = pa_smoother_get(u->smoother, pa_rtclock_now());
-            w = pa_bytes_to_usec((u->offset - u->encoding_overhead + (u->encoded_memchunk.length / u->encoding_ratio)), &u->sink->sample_spec);
-
-            *((pa_usec_t*) data) = w > r ? w - r : 0;
+            *((pa_usec_t*) data) = sink_get_latency(u);
             return 0;
         }
 
-        case SINK_MESSAGE_PASS_SOCKET: {
+        case SINK_MESSAGE_TCP_PASS_SOCKET: {
             struct pollfd *pollfd;
 
             pa_assert(!u->rtpoll_item);
 
             u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 1);
             pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
-            pollfd->fd = u->fd;
+            pollfd->fd = u->tcp_fd;
             pollfd->events = POLLOUT;
             /*pollfd->events = */pollfd->revents = 0;
 
             if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
-                /* Our stream has been suspended so we just flush it.... */
-                pa_raop_flush(u->raop);
+                /* Our stream has been suspended so we just flush it... */
+                pa_raop_client_flush(u->raop);
             }
             return 0;
         }
 
-        case SINK_MESSAGE_RIP_SOCKET: {
-            if (u->fd >= 0) {
-                pa_close(u->fd);
-                u->fd = -1;
+        case SINK_MESSAGE_TCP_RIP_SOCKET: {
+            if (u->tcp_fd >= 0) {
+                pa_close(u->tcp_fd);
+                u->tcp_fd = -1;
             } else
                 /* FIXME */
                 pa_log("We should not get to this state. Cannot rip socket if not connected.");
@@ -262,28 +285,167 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
     return pa_sink_process_msg(o, code, data, offset, chunk);
 }
 
+static void udp_start_wakeup_clock(struct userdata *u) {
+    pa_usec_t now = pa_rtclock_now();
+
+    u->udp_playback_start = now;
+    u->udp_sent_packets = 0;
+    pa_rtpoll_set_timer_absolute(u->rtpoll, now);
+}
+
+static pa_usec_t udp_next_wakeup_clock(struct userdata *u) {
+    pa_usec_t intvl = pa_bytes_to_usec(u->block_size * u->udp_sent_packets,
+                                       &u->sink->sample_spec);
+    /* FIXME: how long until (u->block_size * u->udp_sent_packets) wraps?? */
+
+    return u->udp_playback_start + intvl;
+}
+
+static int udp_sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
+    struct userdata *u = PA_SINK(o)->userdata;
+
+    switch (code) {
+        case PA_SINK_MESSAGE_SET_STATE:
+            switch ((pa_sink_state_t) PA_PTR_TO_UINT(data)) {
+                case PA_SINK_SUSPENDED:
+                    pa_assert(PA_SINK_IS_OPENED(u->sink->thread_info.state));
+                    pa_log_debug("RAOP: SUSPENDED");
+                    pa_smoother_pause(u->smoother, pa_rtclock_now());
+
+                    if (pa_raop_client_udp_is_alive(u->raop)) {
+                        /* Issue a TEARDOWN if we are still connected. */
+                        pa_raop_client_teardown(u->raop);
+                    }
+
+                    break;
+
+                case PA_SINK_IDLE:
+                    pa_log_debug("RAOP: IDLE");
+                    /* Issue a flush if we're comming from running state. */
+                    if (u->sink->thread_info.state == PA_SINK_RUNNING) {
+                        pa_rtpoll_set_timer_disabled(u->rtpoll);
+                        pa_raop_client_flush(u->raop);
+                    }
+
+                    break;
+
+                case PA_SINK_RUNNING:
+                    pa_log_debug("RAOP: RUNNING");
+
+                    pa_smoother_resume(u->smoother, pa_rtclock_now(), true);
+
+                    if (!pa_raop_client_udp_is_alive(u->raop)) {
+                        /* Connecting will trigger a RECORD and start steaming */
+                        pa_raop_client_connect(u->raop);
+                    } else if (!pa_raop_client_udp_can_stream(u->raop)) {
+                        /* RECORD alredy sent, simply start streaming */
+                        pa_raop_client_udp_stream(u->raop);
+                    }
+
+                    udp_start_wakeup_clock(u);
+
+                    break;
+
+                case PA_SINK_UNLINKED:
+                case PA_SINK_INIT:
+                case PA_SINK_INVALID_STATE:
+                    ;
+            }
+
+            break;
+
+        case PA_SINK_MESSAGE_GET_LATENCY: {
+            pa_usec_t r = 0;
+
+            if (pa_raop_client_udp_can_stream(u->raop))
+                r = sink_get_latency(u);
+
+            *((pa_usec_t*) data) = r;
+
+            return 0;
+        }
+
+        case SINK_MESSAGE_UDP_SETUP: {
+            struct pollfd *pollfd;
+
+            u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 2);
+            pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
+
+            pollfd->fd = u->udp_control_fd;
+            pollfd->events = POLLIN | POLLPRI;
+            pollfd->revents = 0;
+            pollfd++;
+            pollfd->fd = u->udp_timing_fd;
+            pollfd->events = POLLIN | POLLPRI;
+            pollfd->revents = 0;
+
+            return 0;
+        }
+
+        case SINK_MESSAGE_UDP_RECORD: {
+            udp_start_wakeup_clock(u);
+
+            if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
+                /* Our stream has been suspended so we just flush it... */
+                pa_rtpoll_set_timer_disabled(u->rtpoll);
+                pa_raop_client_flush(u->raop);
+            }
+
+            return 0;
+        }
+
+        case SINK_MESSAGE_UDP_DISCONNECTED: {
+            if (u->sink->thread_info.state == PA_SINK_SUSPENDED) {
+                pa_rtpoll_set_timer_disabled(u->rtpoll);
+                if (u->rtpoll_item)
+                    pa_rtpoll_item_free(u->rtpoll_item);
+                u->rtpoll_item = NULL;
+            } else {
+                /* Question: is this valid here: or should we do some sort of:
+                 * return pa_sink_process_msg(PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL); ?? */
+                pa_module_unload_request(u->module, true);
+            }
+
+            pa_close(u->udp_control_fd);
+            pa_close(u->udp_timing_fd);
+
+            u->udp_control_fd = -1;
+            u->udp_timing_fd = -1;
+
+            return 0;
+        }
+    }
+
+    return pa_sink_process_msg(o, code, data, offset, chunk);
+}
+
 static void sink_set_volume_cb(pa_sink *s) {
     struct userdata *u = s->userdata;
     pa_cvolume hw;
-    pa_volume_t v;
+    pa_volume_t v, v_orig;
     char t[PA_CVOLUME_SNPRINT_VERBOSE_MAX];
 
     pa_assert(u);
 
-    /* If we're muted we don't need to do anything */
+    /* If we're muted we don't need to do anything. */
     if (s->muted)
         return;
 
     /* Calculate the max volume of all channels.
-       We'll use this as our (single) volume on the APEX device and emulate
-       any variation in channel volumes in software */
+     * We'll use this as our (single) volume on the APEX device and emulate
+     * any variation in channel volumes in software. */
     v = pa_cvolume_max(&s->real_volume);
 
-    /* Create a pa_cvolume version of our single value */
+    v_orig = v;
+    v = pa_raop_client_adjust_volume(u->raop, v_orig);
+
+    pa_log_debug("Volume adjusted: orig=%u adjusted=%u", v_orig, v);
+
+    /* Create a pa_cvolume version of our single value. */
     pa_cvolume_set(&hw, s->sample_spec.channels, v);
 
-    /* Perform any software manipulation of the volume needed */
-    pa_sw_cvolume_divide(&s->soft_volume, &s->real_volume, &hw);
+    /* Set the real volume based on given original volume. */
+    pa_cvolume_set(&s->real_volume, s->sample_spec.channels, v_orig);
 
     pa_log_debug("Requested volume: %s", pa_cvolume_snprint_verbose(t, sizeof(t), &s->real_volume, &s->channel_map, false));
     pa_log_debug("Got hardware volume: %s", pa_cvolume_snprint_verbose(t, sizeof(t), &hw, &s->channel_map, false));
@@ -291,7 +453,7 @@ static void sink_set_volume_cb(pa_sink *s) {
                  pa_cvolume_snprint_verbose(t, sizeof(t), &s->soft_volume, &s->channel_map, true));
 
     /* Any necessary software volume manipulation is done so set
-       our hw volume (or v as a single value) on the device */
+     * our hw volume (or v as a single value) on the device. */
     pa_raop_client_set_volume(u->raop, v);
 }
 
@@ -307,8 +469,50 @@ static void sink_set_mute_cb(pa_sink *s) {
     }
 }
 
-static void thread_func(void *userdata) {
+static void udp_setup_cb(int control_fd, int timing_fd, void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(control_fd);
+    pa_assert(timing_fd);
+    pa_assert(u);
+
+    u->udp_control_fd = control_fd;
+    u->udp_timing_fd = timing_fd;
+
+    pa_log_debug("Connection authenticated, syncing with server...");
+
+    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_UDP_SETUP, NULL, 0, NULL, NULL);
+}
+
+static void udp_record_cb(void *userdata) {
     struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    /* Set the initial volume. */
+    sink_set_volume_cb(u->sink);
+
+    pa_log_debug("Synchronization done, pushing job to IO thread...");
+
+    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_UDP_RECORD, NULL, 0, NULL, NULL);
+}
+
+static void udp_disconnected_cb(void *userdata) {
+    struct userdata *u = userdata;
+
+    pa_assert(u);
+
+    /* This callback function is called from both STATE_TEARDOWN and
+       STATE_DISCONNECTED in raop_client.c */
+
+    pa_assert(u);
+
+    pa_log_debug("Connection closed, informing IO thread...");
+
+    pa_asyncmsgq_post(u->thread_mq.inq, PA_MSGOBJECT(u->sink), SINK_MESSAGE_UDP_DISCONNECTED, NULL, 0, NULL, NULL);
+}
+
+static void tcp_thread_func(struct userdata *u) {
     int write_type = 0;
     pa_memchunk silence;
     uint32_t silence_overhead = 0;
@@ -316,7 +520,7 @@ static void thread_func(void *userdata) {
 
     pa_assert(u);
 
-    pa_log_debug("Thread starting up");
+    pa_log_debug("TCP thread starting up");
 
     pa_thread_mq_install(&u->thread_mq);
 
@@ -335,7 +539,7 @@ static void thread_func(void *userdata) {
             struct pollfd *pollfd;
             pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
 
-            /* Render some data and write it to the fifo */
+            /* Render some data and write it to the fifo. */
             if (/*PA_SINK_IS_OPENED(u->sink->thread_info.state) && */pollfd->revents) {
                 pa_usec_t usec;
                 int64_t n;
@@ -366,29 +570,29 @@ static void thread_func(void *userdata) {
                         if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
                             size_t rl;
 
-                            /* We render real data */
+                            /* We render real data. */
                             if (u->raw_memchunk.length <= 0) {
                                 if (u->raw_memchunk.memblock)
                                     pa_memblock_unref(u->raw_memchunk.memblock);
                                 pa_memchunk_reset(&u->raw_memchunk);
 
-                                /* Grab unencoded data */
+                                /* Grab unencoded data. */
                                 pa_sink_render(u->sink, u->block_size, &u->raw_memchunk);
                             }
                             pa_assert(u->raw_memchunk.length > 0);
 
-                            /* Encode it */
+                            /* Encode it. */
                             rl = u->raw_memchunk.length;
                             u->encoding_overhead += u->next_encoding_overhead;
                             pa_raop_client_encode_sample(u->raop, &u->raw_memchunk, &u->encoded_memchunk);
                             u->next_encoding_overhead = (u->encoded_memchunk.length - (rl - u->raw_memchunk.length));
                             u->encoding_ratio = u->encoded_memchunk.length / (rl - u->raw_memchunk.length);
                         } else {
-                            /* We render some silence into our memchunk */
+                            /* We render some silence into our memchunk. */
                             memcpy(&u->encoded_memchunk, &silence, sizeof(pa_memchunk));
                             pa_memblock_ref(silence.memblock);
 
-                            /* Calculate/store some values to be used with the smoother */
+                            /* Calculate/store some values to be used with the smoother. */
                             u->next_encoding_overhead = silence_overhead;
                             u->encoding_ratio = silence_ratio;
                         }
@@ -396,7 +600,7 @@ static void thread_func(void *userdata) {
                     pa_assert(u->encoded_memchunk.length > 0);
 
                     p = pa_memblock_acquire(u->encoded_memchunk.memblock);
-                    l = pa_write(u->fd, (uint8_t*) p + u->encoded_memchunk.index, u->encoded_memchunk.length, &write_type);
+                    l = pa_write(u->tcp_fd, (uint8_t*) p + u->encoded_memchunk.index, u->encoded_memchunk.length, &write_type);
                     pa_memblock_release(u->encoded_memchunk.memblock);
 
                     pa_assert(l != 0);
@@ -407,8 +611,7 @@ static void thread_func(void *userdata) {
                             continue;
                         else if (errno == EAGAIN) {
 
-                            /* OK, we filled all socket buffers up
-                             * now. */
+                            /* OK, we filled all socket buffers up now. */
                             goto filled_up;
 
                         } else {
@@ -425,29 +628,28 @@ static void thread_func(void *userdata) {
                         pollfd->revents = 0;
 
                         if (u->encoded_memchunk.length > 0) {
-                            /* we've completely written the encoded data, so update our overhead */
+                            /* We've completely written the encoded data, so update our overhead. */
                             u->encoding_overhead += u->next_encoding_overhead;
 
                             /* OK, we wrote less that we asked for,
                              * hence we can assume that the socket
-                             * buffers are full now */
+                             * buffers are full now. */
                             goto filled_up;
                         }
                     }
                 }
 
             filled_up:
-
                 /* At this spot we know that the socket buffers are
                  * fully filled up. This is the best time to estimate
-                 * the playback position of the server */
+                 * the playback position of the server. */
 
                 n = u->offset - u->encoding_overhead;
 
 #ifdef SIOCOUTQ
                 {
                     int l;
-                    if (ioctl(u->fd, SIOCOUTQ, &l) >= 0 && l > 0)
+                    if (ioctl(u->tcp_fd, SIOCOUTQ, &l) >= 0 && l > 0)
                         n -= (l / u->encoding_ratio);
                 }
 #endif
@@ -462,7 +664,7 @@ static void thread_func(void *userdata) {
                 pa_smoother_put(u->smoother, pa_rtclock_now(), usec);
             }
 
-            /* Hmm, nothing to do. Let's sleep */
+            /* Hmm, nothing to do. Let's sleep... */
             pollfd->events = POLLOUT; /*PA_SINK_IS_OPENED(u->sink->thread_info.state)  ? POLLOUT : 0;*/
         }
 
@@ -484,7 +686,7 @@ static void thread_func(void *userdata) {
                 }
 
                 /* We expect this to happen on occasion if we are not sending data.
-                   It's perfectly natural and normal and natural */
+                 * It's perfectly natural and normal and natural. */
                 if (u->rtpoll_item)
                     pa_rtpoll_item_free(u->rtpoll_item);
                 u->rtpoll_item = NULL;
@@ -494,22 +696,146 @@ static void thread_func(void *userdata) {
 
 fail:
     /* If this was no regular exit from the loop we have to continue
-     * processing messages until we received PA_MESSAGE_SHUTDOWN */
+     * processing messages until we received PA_MESSAGE_SHUTDOWN. */
     pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
     pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
 
 finish:
     if (silence.memblock)
         pa_memblock_unref(silence.memblock);
-    pa_log_debug("Thread shutting down");
+    pa_log_debug("TCP thread shutting down");
 }
 
-int pa__init(pa_module*m) {
+static void udp_thread_func(struct userdata *u) {
+    pa_assert(u);
+
+    pa_log_debug("UDP thread starting up");
+
+    pa_thread_mq_install(&u->thread_mq);
+    pa_smoother_set_time_offset(u->smoother, pa_rtclock_now());
+
+    for (;;) {
+        pa_usec_t estimated;
+        int32_t overhead = 0;
+        ssize_t written = 0;
+        size_t length = 0;
+        int rv = 0;
+
+        if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
+            if (u->sink->thread_info.rewind_requested)
+                pa_sink_process_rewind(u->sink, 0);
+        }
+
+        /* Polling (audio data + control socket + timing socket). */
+        if ((rv = pa_rtpoll_run(u->rtpoll, true)) < 0)
+            goto fail;
+        else if (rv == 0)
+            goto finish;
+
+        if (!pa_rtpoll_timer_elapsed(u->rtpoll)) {
+            struct pollfd *pollfd;
+            uint8_t packet[32];
+            ssize_t read;
+
+            if (u->rtpoll_item) {
+                pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
+
+                /* Event on the control socket ?? */
+                if (pollfd->revents & POLLIN) {
+                    pollfd->revents = 0;
+                    pa_log_debug("Received control packet.");
+                    read = pa_read(pollfd->fd, packet, sizeof(packet), NULL);
+                    pa_raop_client_udp_handle_control_packet(u->raop, packet, read);
+                }
+
+                pollfd++;
+
+                /* Event on the timing port ?? */
+                if (pollfd->revents & POLLIN) {
+                    pollfd->revents = 0;
+                    pa_log_debug("Received timing packet.");
+                    read = pa_read(pollfd->fd, packet, sizeof(packet), NULL);
+                    pa_raop_client_udp_handle_timing_packet(u->raop, packet, read);
+                }
+            }
+
+            continue;
+        }
+
+        if (u->sink->thread_info.state != PA_SINK_RUNNING)
+            continue;
+        if (!pa_raop_client_udp_can_stream(u->raop))
+            continue;
+
+        if (u->encoded_memchunk.length <= 0) {
+            if (u->encoded_memchunk.memblock != NULL)
+                pa_memblock_unref(u->encoded_memchunk.memblock);
+
+            if (u->raw_memchunk.length <= 0) {
+                if (u->raw_memchunk.memblock)
+                    pa_memblock_unref(u->raw_memchunk.memblock);
+                pa_memchunk_reset(&u->raw_memchunk);
+
+                /* Grab unencoded audio data from PulseAudio. */
+                pa_sink_render_full(u->sink, u->block_size, &u->raw_memchunk);
+            }
+
+            pa_assert(u->raw_memchunk.length > 0);
+
+            length = u->raw_memchunk.length;
+            pa_raop_client_encode_sample(u->raop, &u->raw_memchunk, &u->encoded_memchunk);
+            u->encoding_ratio = (double) u->encoded_memchunk.length / (double) (length - u->raw_memchunk.length);
+            overhead = u->encoded_memchunk.length - (length - u->raw_memchunk.length);
+        }
+
+        pa_assert(u->encoded_memchunk.length > 0);
+
+        written = pa_raop_client_udp_send_audio_packet(u->raop,&u->encoded_memchunk);
+        if (written < 0) {
+            pa_log("Failed to send UDP packet: %s", pa_cstrerror(errno));
+            goto fail;
+        }
+
+        u->udp_sent_packets++;
+        /* Sleep until next packet transmission */
+        pa_rtpoll_set_timer_absolute(u->rtpoll, udp_next_wakeup_clock(u));
+
+        u->offset += written;
+        u->encoding_overhead += overhead;
+
+        estimated = pa_bytes_to_usec(u->offset - u->encoding_overhead, &u->sink->sample_spec);
+        pa_smoother_put(u->smoother, pa_rtclock_now(), estimated);
+    }
+
+fail:
+    /* If this was no regular exit, continue processing messages until PA_MESSAGE_SHUTDOWN. */
+    pa_asyncmsgq_post(u->thread_mq.outq, PA_MSGOBJECT(u->core), PA_CORE_MESSAGE_UNLOAD_MODULE, u->module, 0, NULL, NULL);
+    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
+
+finish:
+    pa_log_debug("UDP thread shutting down");
+}
+
+static void thread_func(void *userdata) {
+    struct userdata *u = userdata;
+
+    if (u->protocol == RAOP_TCP)
+        tcp_thread_func(u);
+    else if (u->protocol == RAOP_UDP)
+        udp_thread_func(u);
+    else
+        pa_assert(false);
+
+    return;
+}
+
+int pa__init(pa_module *m) {
     struct userdata *u = NULL;
     pa_sample_spec ss;
     pa_modargs *ma = NULL;
-    const char *server;
+    const char *server, *protocol, *encryption;
     pa_sink_new_data data;
+    char *t = NULL;
 
     pa_assert(m);
 
@@ -534,7 +860,7 @@ int pa__init(pa_module*m) {
     u->core = m->core;
     u->module = m;
     m->userdata = u;
-    u->fd = -1;
+    u->tcp_fd = -1;
     u->smoother = pa_smoother_new(
             PA_USEC_PER_SEC,
             PA_USEC_PER_SEC*2,
@@ -571,15 +897,32 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
+    /* This may be overwriten if sink_name is specified in module arguments. */
+    t = pa_sprintf_malloc("raop_client.%s", server);
+
+    protocol = pa_modargs_get_value(ma, "protocol", NULL);
+    if (protocol == NULL || pa_streq(protocol, "TCP")) {
+        /* Assume TCP by default */
+        u->protocol = RAOP_TCP;
+    }
+    else if (pa_streq(protocol, "UDP")) {
+        u->protocol = RAOP_UDP;
+    } else {
+        pa_log("Unsupported protocol argument given: %s", protocol);
+        goto fail;
+    }
+
     pa_sink_new_data_init(&data);
     data.driver = __FILE__;
     data.module = m;
-    pa_sink_new_data_set_name(&data, pa_modargs_get_value(ma, "sink_name", DEFAULT_SINK_NAME));
+    pa_sink_new_data_set_name(&data, pa_modargs_get_value(ma, "sink_name", t));
     pa_sink_new_data_set_sample_spec(&data, &ss);
     pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, server);
     pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "music");
     pa_proplist_setf(data.proplist, PA_PROP_DEVICE_DESCRIPTION, "RAOP sink '%s'", server);
 
+    /* RAOP discover module will eventually overwrite sink_name and others
+       (PA_UPDATE_REPLACE). */
     if (pa_modargs_get_proplist(ma, "sink_properties", data.proplist, PA_UPDATE_REPLACE) < 0) {
         pa_log("Invalid properties");
         pa_sink_new_data_done(&data);
@@ -587,6 +930,7 @@ int pa__init(pa_module*m) {
     }
 
     u->sink = pa_sink_new(m->core, &data, PA_SINK_LATENCY|PA_SINK_NETWORK);
+    pa_xfree(t); t = NULL;
     pa_sink_new_data_done(&data);
 
     if (!u->sink) {
@@ -594,7 +938,10 @@ int pa__init(pa_module*m) {
         goto fail;
     }
 
-    u->sink->parent.process_msg = sink_process_msg;
+    if (u->protocol == RAOP_TCP)
+        u->sink->parent.process_msg = tcp_sink_process_msg;
+    else
+        u->sink->parent.process_msg = udp_sink_process_msg;
     u->sink->userdata = u;
     pa_sink_set_set_volume_callback(u->sink, sink_set_volume_cb);
     pa_sink_set_set_mute_callback(u->sink, sink_set_mute_cb);
@@ -603,13 +950,27 @@ int pa__init(pa_module*m) {
     pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
     pa_sink_set_rtpoll(u->sink, u->rtpoll);
 
-    if (!(u->raop = pa_raop_client_new(u->core, server))) {
+    if (!(u->raop = pa_raop_client_new(u->core, server, u->protocol, ss))) {
         pa_log("Failed to connect to server.");
         goto fail;
     }
 
-    pa_raop_client_set_callback(u->raop, on_connection, u);
-    pa_raop_client_set_closed_callback(u->raop, on_close, u);
+    encryption = pa_modargs_get_value(ma, "encryption", NULL);
+    pa_raop_client_set_encryption(u->raop, !pa_streq(encryption, "none"));
+
+    pa_raop_client_tcp_set_callback(u->raop, tcp_on_connection, u);
+    pa_raop_client_tcp_set_closed_callback(u->raop, tcp_on_close, u);
+
+    if (u->protocol == RAOP_UDP) {
+        /* The number of frames per blocks is not negotiable... */
+        pa_raop_client_udp_get_blocks_size(u->raop, &u->block_size);
+        u->block_size *= pa_frame_size(&ss);
+        pa_sink_set_max_request(u->sink, u->block_size);
+
+        pa_raop_client_udp_set_setup_callback(u->raop, udp_setup_cb, u);
+        pa_raop_client_udp_set_record_callback(u->raop, udp_record_cb, u);
+        pa_raop_client_udp_set_disconnected_callback(u->raop, udp_disconnected_cb, u);
+    }
 
     if (!(u->thread = pa_thread_new("raop-sink", thread_func, u))) {
         pa_log("Failed to create thread.");
@@ -623,6 +984,8 @@ int pa__init(pa_module*m) {
     return 0;
 
 fail:
+    pa_xfree(t);
+
     if (ma)
         pa_modargs_free(ma);
 
@@ -640,7 +1003,7 @@ int pa__get_n_used(pa_module *m) {
     return pa_sink_linked_by(u->sink);
 }
 
-void pa__done(pa_module*m) {
+void pa__done(pa_module *m) {
     struct userdata *u;
     pa_assert(m);
 
@@ -681,8 +1044,8 @@ void pa__done(pa_module*m) {
     if (u->smoother)
         pa_smoother_free(u->smoother);
 
-    if (u->fd >= 0)
-        pa_close(u->fd);
+    if (u->tcp_fd >= 0)
+        pa_close(u->tcp_fd);
 
     pa_xfree(u);
 }
diff --git a/src/modules/raop/raop_client.c b/src/modules/raop/raop_client.c
index 98a9822..f1c912f 100644
--- a/src/modules/raop/raop_client.c
+++ b/src/modules/raop/raop_client.c
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
+#include <math.h>
 
 #ifdef HAVE_SYS_FILIO_H
 #include <sys/filio.h>
@@ -41,10 +42,13 @@
 #include <openssl/engine.h>
 
 #include <pulse/xmalloc.h>
+#include <pulse/timeval.h>
 
 #include <pulsecore/core-error.h>
+#include <pulsecore/core-rtclock.h>
 #include <pulsecore/core-util.h>
 #include <pulsecore/iochannel.h>
+#include <pulsecore/arpa-inet.h>
 #include <pulsecore/socket-util.h>
 #include <pulsecore/log.h>
 #include <pulsecore/parseaddr.h>
@@ -56,6 +60,8 @@
 #include "rtsp_client.h"
 #include "base64.h"
 
+#include "raop_packet_buffer.h"
+
 #define AES_CHUNKSIZE 16
 
 #define JACK_STATUS_DISCONNECTED 0
@@ -68,7 +74,21 @@
 #define VOLUME_MIN -144
 #define VOLUME_MAX 0
 
-#define RAOP_PORT 5000
+#define DEFAULT_RAOP_PORT 5000
+#define UDP_DEFAULT_AUDIO_PORT 6000
+#define UDP_DEFAULT_CONTROL_PORT 6001
+#define UDP_DEFAULT_TIMING_PORT 6002
+
+#define UDP_DEFAULT_PKT_BUF_SIZE 1000
+
+typedef enum {
+    UDP_PAYLOAD_TIMING_REQUEST = 0x52,
+    UDP_PAYLOAD_TIMING_RESPONSE = 0x53,
+    UDP_PAYLOAD_SYNCHRONIZATION = 0x54,
+    UDP_PAYLOAD_RETRANSMIT_REQUEST = 0x55,
+    UDP_PAYLOAD_RETRANSMIT_REPLY = 0x56,
+    UDP_PAYLOAD_AUDIO_DATA = 0x60
+} pa_raop_udp_payload_type;
 
 struct pa_raop_client {
     pa_core *core;
@@ -76,26 +96,97 @@ struct pa_raop_client {
     uint16_t port;
     char *sid;
     pa_rtsp_client *rtsp;
+    pa_raop_protocol_t protocol;
 
     uint8_t jack_type;
     uint8_t jack_status;
 
     /* Encryption Related bits */
+    int encryption; /* Enable encryption? */
     AES_KEY aes;
-    uint8_t aes_iv[AES_CHUNKSIZE]; /* initialization vector for aes-cbc */
-    uint8_t aes_nv[AES_CHUNKSIZE]; /* next vector for aes-cbc */
-    uint8_t aes_key[AES_CHUNKSIZE]; /* key for aes-cbc */
-
-    pa_socket_client *sc;
-    int fd;
+    uint8_t aes_iv[AES_CHUNKSIZE]; /* Initialization vector for aes-cbc */
+    uint8_t aes_nv[AES_CHUNKSIZE]; /* Next vector for aes-cbc */
+    uint8_t aes_key[AES_CHUNKSIZE]; /* Key for aes-cbc */
 
     uint16_t seq;
     uint32_t rtptime;
 
-    pa_raop_client_cb_t callback;
-    void* userdata;
-    pa_raop_client_closed_cb_t closed_callback;
-    void* closed_userdata;
+    /* Members only for the TCP protocol */
+    pa_socket_client *tcp_sc;
+    int tcp_fd;
+
+    pa_raop_client_cb_t tcp_callback;
+    void *tcp_userdata;
+    pa_raop_client_closed_cb_t tcp_closed_callback;
+    void *tcp_closed_userdata;
+
+    /* Members only for the UDP protocol */
+    uint16_t udp_my_control_port;
+    uint16_t udp_my_timing_port;
+    uint16_t udp_server_control_port;
+    uint16_t udp_server_timing_port;
+
+    int udp_stream_fd;
+    int udp_control_fd;
+    int udp_timing_fd;
+
+    uint32_t udp_ssrc;
+
+    bool is_recording;
+
+    bool udp_first_packet;
+    uint32_t udp_sync_interval;
+    uint32_t udp_sync_count;
+
+    pa_raop_client_setup_cb_t udp_setup_callback;
+    void *udp_setup_userdata;
+
+    pa_raop_client_record_cb_t udp_record_callback;
+    void *udp_record_userdata;
+
+    pa_raop_client_disconnected_cb_t udp_disconnected_callback;
+    void *udp_disconnected_userdata;
+
+    pa_raop_packet_buffer *packet_buffer;
+};
+
+/* Timming packet header (8x8):
+ *  [0]   RTP v2: 0x80,
+ *  [1]   Payload type: 0x53 | marker bit: 0x80,
+ *  [2,3] Sequence number: 0x0007,
+ *  [4,7] Timestamp: 0x00000000 (unused). */
+static const uint8_t udp_timming_header[8] = {
+    0x80, 0xd3, 0x00, 0x07,
+    0x00, 0x00, 0x00, 0x00
+};
+
+/* Sync packet header (8x8):
+ *  [0]   RTP v2: 0x80,
+ *  [1]   Payload type: 0x54 | marker bit: 0x80,
+ *  [2,3] Sequence number: 0x0007,
+ *  [4,7] Timestamp: 0x00000000 (to be set). */
+static const uint8_t udp_sync_header[8] = {
+    0x80, 0xd4, 0x00, 0x07,
+    0x00, 0x00, 0x00, 0x00
+};
+
+static const uint8_t tcp_audio_header[16] = {
+    0x24, 0x00, 0x00, 0x00,
+    0xF0, 0xFF, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,
+};
+
+/* Audio packet header (12x8):
+ *  [0]    RTP v2: 0x80,
+ *  [1]    Payload type: 0x60,
+ *  [2,3]  Sequence number: 0x0000 (to be set),
+ *  [4,7]  Timestamp: 0x00000000 (to be set),
+ *  [8,12] SSRC: 0x00000000 (to be set).*/
+static const uint8_t udp_audio_header[12] = {
+    0x80, 0x60, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00,
+    0x00, 0x00, 0x00, 0x00
 };
 
 /**
@@ -117,32 +208,32 @@ static inline void bit_writer(uint8_t **buffer, uint8_t *bit_pos, int *size, uin
     if (!*bit_pos)
         *size += 1;
 
-    /* Calc the number of bits left in the current byte of buffer */
+    /* Calc the number of bits left in the current byte of buffer. */
     bits_left = 7 - *bit_pos  + 1;
     /* Calc the overflow of bits in relation to how much space we have left... */
     bit_overflow = bits_left - data_bit_len;
     if (bit_overflow >= 0) {
-        /* We can fit the new data in our current byte */
-        /* As we write from MSB->LSB we need to left shift by the overflow amount */
+        /* We can fit the new data in our current byte.
+         * As we write from MSB->LSB we need to left shift by the overflow amount. */
         bit_data = data << bit_overflow;
         if (*bit_pos)
             **buffer |= bit_data;
         else
             **buffer = bit_data;
-        /* If our data fits exactly into the current byte, we need to increment our pointer */
+        /* If our data fits exactly into the current byte, we need to increment our pointer. */
         if (0 == bit_overflow) {
-            /* Do not increment size as it will be incremented on next call as bit_pos is zero */
+            /* Do not increment size as it will be incremented on next call as bit_pos is zero. */
             *buffer += 1;
             *bit_pos = 0;
         } else {
             *bit_pos += data_bit_len;
         }
     } else {
-        /* bit_overflow is negative, there for we will need a new byte from our buffer */
-        /* Firstly fill up what's left in the current byte */
+        /* bit_overflow is negative, there for we will need a new byte from our buffer
+         * Firstly fill up what's left in the current byte. */
         bit_data = data >> -bit_overflow;
         **buffer |= bit_data;
-        /* Increment our buffer pointer and size counter*/
+        /* Increment our buffer pointer and size counter. */
         *buffer += 1;
         *size += 1;
         **buffer = data << (8 + bit_overflow);
@@ -175,7 +266,7 @@ static int rsa_encrypt(uint8_t *text, int len, uint8_t *res) {
     return size;
 }
 
-static int aes_encrypt(pa_raop_client* c, uint8_t *data, int size) {
+static int aes_encrypt(pa_raop_client *c, uint8_t *data, int size) {
     uint8_t *buf;
     int i=0, j;
 
@@ -202,35 +293,348 @@ static inline void rtrimchar(char *str, char rc) {
     }
 }
 
-static void on_connection(pa_socket_client *sc, pa_iochannel *io, void *userdata) {
+static void tcp_on_connection(pa_socket_client *sc, pa_iochannel *io, void *userdata) {
     pa_raop_client *c = userdata;
 
     pa_assert(sc);
     pa_assert(c);
-    pa_assert(c->sc == sc);
-    pa_assert(c->fd < 0);
-    pa_assert(c->callback);
+    pa_assert(c->tcp_sc == sc);
+    pa_assert(c->tcp_fd < 0);
+    pa_assert(c->tcp_callback);
 
-    pa_socket_client_unref(c->sc);
-    c->sc = NULL;
+    pa_socket_client_unref(c->tcp_sc);
+    c->tcp_sc = NULL;
 
     if (!io) {
         pa_log("Connection failed: %s", pa_cstrerror(errno));
         return;
     }
 
-    c->fd = pa_iochannel_get_send_fd(io);
+    c->tcp_fd = pa_iochannel_get_send_fd(io);
 
     pa_iochannel_set_noclose(io, true);
     pa_iochannel_free(io);
 
-    pa_make_tcp_socket_low_delay(c->fd);
+    pa_make_tcp_socket_low_delay(c->tcp_fd);
 
     pa_log_debug("Connection established");
-    c->callback(c->fd, c->userdata);
+    c->tcp_callback(c->tcp_fd, c->tcp_userdata);
+}
+
+static inline uint64_t timeval_to_ntp(struct timeval *tv) {
+    uint64_t ntp = 0;
+
+    /* Converting micro seconds to a fraction. */
+    ntp = (uint64_t) tv->tv_usec * UINT32_MAX / PA_USEC_PER_SEC;
+    /* Moving reference from  1 Jan 1970 to 1 Jan 1900 (seconds). */
+    ntp |= (uint64_t) (tv->tv_sec + 0x83aa7e80) << 32;
+
+    return ntp;
+}
+
+static int connect_udp_socket(pa_raop_client *c, int fd, uint16_t port) {
+    struct sockaddr_in sa4;
+#ifdef HAVE_IPV6
+    struct sockaddr_in6 sa6;
+#endif
+    struct sockaddr *sa;
+    socklen_t salen;
+    sa_family_t af;
+
+    pa_zero(sa4);
+#ifdef HAVE_IPV6
+    pa_zero(sa6);
+#endif
+    if (inet_pton(AF_INET, c->host, &sa4.sin_addr) > 0) {
+        sa4.sin_family = af = AF_INET;
+        sa4.sin_port = htons(port);
+        sa = (struct sockaddr *) &sa4;
+        salen = sizeof(sa4);
+#ifdef HAVE_IPV6
+    } else if (inet_pton(AF_INET6, c->host, &sa6.sin6_addr) > 0) {
+        sa6.sin6_family = af = AF_INET6;
+        sa6.sin6_port = htons(port);
+        sa = (struct sockaddr *) &sa6;
+        salen = sizeof(sa6);
+#endif
+    } else {
+        pa_log("Invalid destination '%s'", c->host);
+        goto fail;
+    }
+
+    if (fd < 0 && (fd = pa_socket_cloexec(af, SOCK_DGRAM, 0)) < 0) {
+        pa_log("socket() failed: %s", pa_cstrerror(errno));
+        goto fail;
+    }
+
+    /* If the socket queue is full, let's drop packets */
+    pa_make_udp_socket_low_delay(fd);
+    pa_make_fd_nonblock(fd);
+
+    if (connect(fd, sa, salen) < 0) {
+        pa_log("connect() failed: %s", pa_cstrerror(errno));
+        goto fail;
+    }
+
+    pa_log_debug("Connected to %s on port %d (SOCK_DGRAM)", c->host, port);
+    return fd;
+
+fail:
+    if (fd >= 0)
+        pa_close(fd);
+
+    return -1;
+}
+
+static int open_bind_udp_socket(pa_raop_client *c, uint16_t *actual_port) {
+    int fd = -1;
+    uint16_t port;
+    struct sockaddr_in sa4;
+#ifdef HAVE_IPV6
+    struct sockaddr_in6 sa6;
+#endif
+    struct sockaddr *sa;
+    uint16_t *sa_port;
+    socklen_t salen;
+    sa_family_t af;
+    int one = 1;
+
+    pa_assert(actual_port);
+
+    port = *actual_port;
+
+    pa_zero(sa4);
+#ifdef HAVE_IPV6
+    pa_zero(sa6);
+#endif
+    if (inet_pton(AF_INET, pa_rtsp_localip(c->rtsp), &sa4.sin_addr) > 0) {
+        sa4.sin_family = af = AF_INET;
+        sa4.sin_port = htons(port);
+        sa = (struct sockaddr *) &sa4;
+        salen = sizeof(sa4);
+        sa_port = &sa4.sin_port;
+#ifdef HAVE_IPV6
+    } else if (inet_pton(AF_INET6, pa_rtsp_localip(c->rtsp), &sa6.sin6_addr) > 0) {
+        sa6.sin6_family = af = AF_INET6;
+        sa6.sin6_port = htons(port);
+        sa = (struct sockaddr *) &sa6;
+        salen = sizeof(sa6);
+        sa_port = &sa6.sin6_port;
+#endif
+    } else {
+        pa_log("Could not determine which address family to use");
+        goto fail;
+    }
+
+    pa_zero(sa4);
+#ifdef HAVE_IPV6
+    pa_zero(sa6);
+#endif
+
+    if ((fd = pa_socket_cloexec(af, SOCK_DGRAM, 0)) < 0) {
+        pa_log("socket() failed: %s", pa_cstrerror(errno));
+        goto fail;
+    }
+
+#ifdef SO_TIMESTAMP
+    if (setsockopt(fd, SOL_SOCKET, SO_TIMESTAMP, &one, sizeof(one)) < 0) {
+        pa_log("setsockopt(SO_TIMESTAMP) failed: %s", pa_cstrerror(errno));
+        goto fail;
+    }
+#else
+    pa_log("SO_TIMESTAMP unsupported on this platform");
+    goto fail;
+#endif
+
+    one = 1;
+    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one)) < 0) {
+        pa_log("setsockopt(SO_REUSEADDR) failed: %s", pa_cstrerror(errno));
+        goto fail;
+    }
+
+    do {
+        *sa_port = htons(port);
+
+        if (bind(fd, sa, salen) < 0 && errno != EADDRINUSE) {
+            pa_log("bind_socket() failed: %s", pa_cstrerror(errno));
+            goto fail;
+        }
+        break;
+    } while (++port > 0);
+
+    pa_log_debug("Socket bound to port %d (SOCK_DGRAM)", port);
+    *actual_port = port;
+
+    return fd;
+
+fail:
+    if (fd >= 0)
+        pa_close(fd);
+
+    return -1;
 }
 
-static void rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist* headers, void *userdata) {
+static int udp_send_timing_packet(pa_raop_client *c, const uint32_t data[6], uint64_t received) {
+    uint32_t packet[8];
+    struct timeval tv;
+    ssize_t written = 0;
+    uint64_t trs = 0;
+    int rv = 1;
+
+    memcpy(packet, udp_timming_header, sizeof(udp_timming_header));
+    /* Copying originate timestamp from the incoming request packet. */
+    packet[2] = data[4];
+    packet[3] = data[5];
+    /* Set the receive timestamp to reception time. */
+    packet[4] = htonl(received >> 32);
+    packet[5] = htonl(received & 0xffffffff);
+    /* Set the transmit timestamp to current time. */
+    trs = timeval_to_ntp(pa_rtclock_get(&tv));
+    packet[6] = htonl(trs >> 32);
+    packet[7] = htonl(trs & 0xffffffff);
+
+    written = pa_loop_write(c->udp_timing_fd, packet, sizeof(packet), NULL);
+    if (written == sizeof(packet))
+        rv = 0;
+
+    return rv;
+}
+
+static int udp_send_sync_packet(pa_raop_client *c, uint32_t stamp) {
+    const uint32_t delay = 88200;
+    uint32_t packet[5];
+    struct timeval tv;
+    ssize_t written = 0;
+    uint64_t trs = 0;
+    int rv = 1;
+
+    memcpy(packet, udp_sync_header, sizeof(udp_sync_header));
+    if (c->udp_first_packet)
+        packet[0] |= 0x10;
+    stamp -= delay;
+    packet[1] = htonl(stamp);
+    /* Set the transmited timestamp to current time. */
+    trs = timeval_to_ntp(pa_rtclock_get(&tv));
+    packet[2] = htonl(trs >> 32);
+    packet[3] = htonl(trs & 0xffffffff);
+    stamp += delay;
+    packet[4] = htonl(stamp);
+
+    written = pa_loop_write(c->udp_control_fd, packet, sizeof(packet), NULL);
+    if (written == sizeof(packet))
+        rv = 0;
+
+    return rv;
+}
+
+static void udp_build_audio_header(pa_raop_client *c, uint32_t *buffer, size_t size) {
+    pa_assert(size >= sizeof(udp_audio_header));
+
+    memcpy(buffer, udp_audio_header, sizeof(udp_audio_header));
+    if (c->udp_first_packet)
+        buffer[0] |= htonl((uint32_t) 0x80 << 16);
+    buffer[0] |= htonl((uint32_t) c->seq);
+    buffer[1] = htonl(c->rtptime);
+    buffer[2] = htonl(c->udp_ssrc);
+}
+
+/* Audio retransmission header:
+ * [0]    RTP v2: 0x80
+ * [1]    Payload type: 0x56 + 0x80 (marker == on)
+ * [2]    Unknown; seems always 0x01
+ * [3]    Unknown; seems some random number around 0x20~0x40
+ * [4,5]  Original RTP header htons(0x8060)
+ * [6,7]  Packet sequence number to be retransmitted
+ * [8,11] Original RTP timestamp on the lost packet */
+static void udp_build_retrans_header(uint32_t *buffer, size_t size, uint16_t seq_num) {
+    uint8_t x = 0x30; /* FIXME: what's this?? */
+
+    pa_assert(size >= sizeof(uint32_t) * 2);
+
+    buffer[0] = htonl((uint32_t) 0x80000000
+                      | ((uint32_t) UDP_PAYLOAD_RETRANSMIT_REPLY | 0x80) << 16
+                      | 0x0100
+                      | x);
+    buffer[1] = htonl((uint32_t) 0x80600000 | seq_num);
+}
+
+static ssize_t udp_send_audio_packet(pa_raop_client *c, bool retrans, uint8_t *buffer, size_t size) {
+    ssize_t length;
+    int fd = retrans ? c->udp_control_fd : c->udp_stream_fd;
+
+    length = pa_write(fd, buffer, size, NULL);
+    if (length < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
+        pa_log_debug("Discarding audio packet %d due to EAGAIN", c->seq);
+        length = size;
+    }
+    return length;
+}
+
+static void do_rtsp_announce(pa_raop_client *c) {
+    int i;
+    uint8_t rsakey[512];
+    char *key, *iv, *sac = NULL, *sdp;
+    uint16_t rand_data;
+    const char *ip;
+    char *url;
+
+    ip = pa_rtsp_localip(c->rtsp);
+    /* First of all set the url properly. */
+    url = pa_sprintf_malloc("rtsp://%s/%s", ip, c->sid);
+    pa_rtsp_set_url(c->rtsp, url);
+    pa_xfree(url);
+
+    /* Now encrypt our aes_public key to send to the device. */
+    i = rsa_encrypt(c->aes_key, AES_CHUNKSIZE, rsakey);
+    pa_base64_encode(rsakey, i, &key);
+    rtrimchar(key, '=');
+    pa_base64_encode(c->aes_iv, AES_CHUNKSIZE, &iv);
+    rtrimchar(iv, '=');
+
+    /* UDP protocol does not need "Apple-Challenge" at announce. */
+    if (c->protocol == RAOP_TCP) {
+        pa_random(&rand_data, sizeof(rand_data));
+        pa_base64_encode(&rand_data, AES_CHUNKSIZE, &sac);
+        rtrimchar(sac, '=');
+        pa_rtsp_add_header(c->rtsp, "Apple-Challenge", sac);
+    }
+
+    if (c->encryption)
+        sdp = pa_sprintf_malloc(
+            "v=0\r\n"
+            "o=iTunes %s 0 IN IP4 %s\r\n"
+            "s=iTunes\r\n"
+            "c=IN IP4 %s\r\n"
+            "t=0 0\r\n"
+            "m=audio 0 RTP/AVP 96\r\n"
+            "a=rtpmap:96 AppleLossless\r\n"
+            "a=fmtp:96 %d 0 16 40 10 14 2 255 0 0 44100\r\n"
+            "a=rsaaeskey:%s\r\n"
+            "a=aesiv:%s\r\n",
+            c->sid, ip, c->host,
+            c->protocol == RAOP_TCP ? 4096 : UDP_FRAMES_PER_PACKET,
+            key, iv);
+    else
+        sdp = pa_sprintf_malloc(
+            "v=0\r\n"
+            "o=iTunes %s 0 IN IP4 %s\r\n"
+            "s=iTunes\r\n"
+            "c=IN IP4 %s\r\n"
+            "t=0 0\r\n"
+            "m=audio 0 RTP/AVP 96\r\n"
+            "a=rtpmap:96 AppleLossless\r\n"
+            "a=fmtp:96 %d 0 16 40 10 14 2 255 0 0 44100\r\n",
+            c->sid, ip, c->host,
+            c->protocol == RAOP_TCP ? 4096 : UDP_FRAMES_PER_PACKET);
+
+    pa_rtsp_announce(c->rtsp, sdp);
+    pa_xfree(key);
+    pa_xfree(iv);
+    pa_xfree(sac);
+    pa_xfree(sdp);
+}
+
+static void tcp_rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist* headers, void *userdata) {
     pa_raop_client* c = userdata;
     pa_assert(c);
     pa_assert(rtsp);
@@ -238,55 +642,19 @@ static void rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist* he
 
     switch (state) {
         case STATE_CONNECT: {
-            int i;
-            uint8_t rsakey[512];
-            char *key, *iv, *sac, *sdp;
-            uint16_t rand_data;
-            const char *ip;
-            char *url;
-
             pa_log_debug("RAOP: CONNECTED");
-            ip = pa_rtsp_localip(c->rtsp);
-            /* First of all set the url properly */
-            url = pa_sprintf_malloc("rtsp://%s/%s", ip, c->sid);
-            pa_rtsp_set_url(c->rtsp, url);
-            pa_xfree(url);
-
-            /* Now encrypt our aes_public key to send to the device */
-            i = rsa_encrypt(c->aes_key, AES_CHUNKSIZE, rsakey);
-            pa_base64_encode(rsakey, i, &key);
-            rtrimchar(key, '=');
-            pa_base64_encode(c->aes_iv, AES_CHUNKSIZE, &iv);
-            rtrimchar(iv, '=');
-
-            pa_random(&rand_data, sizeof(rand_data));
-            pa_base64_encode(&rand_data, AES_CHUNKSIZE, &sac);
-            rtrimchar(sac, '=');
-            pa_rtsp_add_header(c->rtsp, "Apple-Challenge", sac);
-            sdp = pa_sprintf_malloc(
-                "v=0\r\n"
-                "o=iTunes %s 0 IN IP4 %s\r\n"
-                "s=iTunes\r\n"
-                "c=IN IP4 %s\r\n"
-                "t=0 0\r\n"
-                "m=audio 0 RTP/AVP 96\r\n"
-                "a=rtpmap:96 AppleLossless\r\n"
-                "a=fmtp:96 4096 0 16 40 10 14 2 255 0 0 44100\r\n"
-                "a=rsaaeskey:%s\r\n"
-                "a=aesiv:%s\r\n",
-                c->sid, ip, c->host, key, iv);
-            pa_rtsp_announce(c->rtsp, sdp);
-            pa_xfree(key);
-            pa_xfree(iv);
-            pa_xfree(sac);
-            pa_xfree(sdp);
+            do_rtsp_announce(c);
             break;
         }
 
+        case STATE_OPTIONS:
+            pa_log_debug("RAOP: OPTIONS");
+            break;
+
         case STATE_ANNOUNCE:
             pa_log_debug("RAOP: ANNOUNCED");
             pa_rtsp_remove_header(c->rtsp, "Apple-Challenge");
-            pa_rtsp_setup(c->rtsp);
+            pa_rtsp_setup(c->rtsp, NULL);
             break;
 
         case STATE_SETUP: {
@@ -323,11 +691,11 @@ static void rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist* he
             uint32_t port = pa_rtsp_serverport(c->rtsp);
             pa_log_debug("RAOP: RECORDED");
 
-            if (!(c->sc = pa_socket_client_new_string(c->core->mainloop, true, c->host, port))) {
+            if (!(c->tcp_sc = pa_socket_client_new_string(c->core->mainloop, true, c->host, port))) {
                 pa_log("failed to connect to server '%s:%d'", c->host, port);
                 return;
             }
-            pa_socket_client_set_callback(c->sc, on_connection, c);
+            pa_socket_client_set_callback(c->tcp_sc, tcp_on_connection, c);
             break;
         }
 
@@ -344,30 +712,339 @@ static void rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist* he
             break;
 
         case STATE_DISCONNECTED:
-            pa_assert(c->closed_callback);
+            pa_assert(c->tcp_closed_callback);
             pa_assert(c->rtsp);
 
             pa_log_debug("RTSP control channel closed");
             pa_rtsp_client_free(c->rtsp);
             c->rtsp = NULL;
-            if (c->fd > 0) {
+            if (c->tcp_fd > 0) {
                 /* We do not close the fd, we leave it to the closed callback to do that */
-                c->fd = -1;
+                c->tcp_fd = -1;
+            }
+            if (c->tcp_sc) {
+                pa_socket_client_unref(c->tcp_sc);
+                c->tcp_sc = NULL;
+            }
+            pa_xfree(c->sid);
+            c->sid = NULL;
+            c->tcp_closed_callback(c->tcp_closed_userdata);
+            break;
+    }
+}
+
+static void udp_rtsp_cb(pa_rtsp_client *rtsp, pa_rtsp_state state, pa_headerlist *headers, void *userdata) {
+    pa_raop_client *c = userdata;
+
+    pa_assert(c);
+    pa_assert(rtsp);
+    pa_assert(rtsp == c->rtsp);
+
+    switch (state) {
+        case STATE_CONNECT: {
+            uint16_t rand;
+            char *sac;
+
+            /* Set the Apple-Challenge key */
+            pa_random(&rand, sizeof(rand));
+            pa_base64_encode(&rand, AES_CHUNKSIZE, &sac);
+            rtrimchar(sac, '=');
+            pa_rtsp_add_header(c->rtsp, "Apple-Challenge", sac);
+
+            pa_rtsp_options(c->rtsp);
+
+            pa_xfree(sac);
+            break;
+        }
+
+        case STATE_OPTIONS: {
+            pa_log_debug("RAOP: OPTIONS");
+
+            pa_rtsp_remove_header(c->rtsp, "Apple-Challenge");
+            do_rtsp_announce(c);
+            break;
+        }
+
+        case STATE_ANNOUNCE: {
+            char *trs;
+
+            pa_assert(c->udp_control_fd < 0);
+            pa_assert(c->udp_timing_fd < 0);
+
+            c->udp_control_fd = open_bind_udp_socket(c, &c->udp_my_control_port);
+            if (c->udp_control_fd < 0)
+                goto error_announce;
+            c->udp_timing_fd  = open_bind_udp_socket(c, &c->udp_my_timing_port);
+            if (c->udp_timing_fd < 0)
+                goto error_announce;
+
+            trs = pa_sprintf_malloc("RTP/AVP/UDP;unicast;interleaved=0-1;mode=record;control_port=%d;timing_port=%d",
+                c->udp_my_control_port,
+                c->udp_my_timing_port);
+
+            pa_rtsp_setup(c->rtsp, trs);
+
+            pa_xfree(trs);
+            break;
+
+        error_announce:
+            if (c->udp_control_fd > 0) {
+                pa_close(c->udp_control_fd);
+                c->udp_control_fd = -1;
+            }
+            if (c->udp_timing_fd > 0) {
+                pa_close(c->udp_timing_fd);
+                c->udp_timing_fd = -1;
+            }
+
+            pa_rtsp_client_free(c->rtsp);
+            c->rtsp = NULL;
+
+            c->udp_my_control_port     = UDP_DEFAULT_CONTROL_PORT;
+            c->udp_server_control_port = UDP_DEFAULT_CONTROL_PORT;
+            c->udp_my_timing_port      = UDP_DEFAULT_TIMING_PORT;
+            c->udp_server_timing_port  = UDP_DEFAULT_TIMING_PORT;
+
+            pa_log_error("aborting RTSP announce, failed creating required sockets");
+        }
+
+        case STATE_SETUP: {
+            uint32_t stream_port = UDP_DEFAULT_AUDIO_PORT;
+            char *ajs, *trs, *token, *pc;
+            char delimiters[] = ";";
+            const char *token_state = NULL;
+            uint32_t port = 0;
+            int ret;
+
+            pa_log_debug("RAOP: SETUP");
+
+            ajs = pa_xstrdup(pa_headerlist_gets(headers, "Audio-Jack-Status"));
+            trs = pa_xstrdup(pa_headerlist_gets(headers, "Transport"));
+
+            if (ajs) {
+                c->jack_type = JACK_TYPE_ANALOG;
+                c->jack_status = JACK_STATUS_DISCONNECTED;
+
+                while ((token = pa_split(ajs, delimiters, &token_state))) {
+                    if ((pc = strstr(token, "="))) {
+                      *pc = 0;
+                      if (pa_streq(token, "type") && pa_streq(pc + 1, "digital"))
+                          c->jack_type = JACK_TYPE_DIGITAL;
+                    } else {
+                        if (pa_streq(token, "connected"))
+                            c->jack_status = JACK_STATUS_CONNECTED;
+                    }
+                    pa_xfree(token);
+                }
+
+            } else {
+                pa_log_warn("Audio-Jack-Status missing");
+            }
+
+            token_state = NULL;
+
+            if (trs) {
+                /* Now parse out the server port component of the response. */
+                while ((token = pa_split(trs, delimiters, &token_state))) {
+                    if ((pc = strstr(token, "="))) {
+                        *pc = 0;
+                        if (pa_streq(token, "control_port")) {
+                            port = 0;
+                            pa_atou(pc + 1, &port);
+                            c->udp_server_control_port = port;
+                        }
+                        if (pa_streq(token, "timing_port")) {
+                            port = 0;
+                            pa_atou(pc + 1, &port);
+                            c->udp_server_timing_port = port;
+                        }
+                        *pc = '=';
+                    }
+                    pa_xfree(token);
+                }
+            } else {
+                pa_log_warn("Transport missing");
+            }
+
+            pa_xfree(ajs);
+            pa_xfree(trs);
+
+            stream_port = pa_rtsp_serverport(c->rtsp);
+            if (stream_port == 0)
+                goto error;
+            if (c->udp_server_control_port == 0 || c->udp_server_timing_port == 0)
+                goto error;
+
+            pa_log_debug("Using server_port=%d, control_port=%d & timing_port=%d",
+                stream_port,
+                c->udp_server_control_port,
+                c->udp_server_timing_port);
+
+            pa_assert(c->udp_stream_fd < 0);
+            pa_assert(c->udp_control_fd >= 0);
+            pa_assert(c->udp_timing_fd >= 0);
+
+            c->udp_stream_fd = connect_udp_socket(c, -1, stream_port);
+            if (c->udp_stream_fd <= 0)
+                goto error;
+            ret = connect_udp_socket(c, c->udp_control_fd,
+                                     c->udp_server_control_port);
+            if (ret < 0)
+                goto error;
+            ret = connect_udp_socket(c, c->udp_timing_fd,
+                                     c->udp_server_timing_port);
+            if (ret < 0)
+                goto error;
+
+            c->udp_setup_callback(c->udp_control_fd, c->udp_timing_fd, c->udp_setup_userdata);
+            pa_rtsp_record(c->rtsp, &c->seq, &c->rtptime);
+
+            break;
+
+        error:
+            if (c->udp_stream_fd > 0) {
+                pa_close(c->udp_stream_fd);
+                c->udp_stream_fd = -1;
+            }
+            if (c->udp_control_fd > 0) {
+                pa_close(c->udp_control_fd);
+                c->udp_control_fd = -1;
+            }
+            if (c->udp_timing_fd > 0) {
+                pa_close(c->udp_timing_fd);
+                c->udp_timing_fd = -1;
+            }
+
+            pa_rtsp_client_free(c->rtsp);
+            c->rtsp = NULL;
+
+            c->udp_my_control_port     = UDP_DEFAULT_CONTROL_PORT;
+            c->udp_server_control_port = UDP_DEFAULT_CONTROL_PORT;
+            c->udp_my_timing_port      = UDP_DEFAULT_TIMING_PORT;
+            c->udp_server_timing_port  = UDP_DEFAULT_TIMING_PORT;
+
+            pa_log_error("aborting RTSP setup, failed creating required sockets");
+
+            break;
+        }
+
+        case STATE_RECORD: {
+            int32_t latency = 0;
+            uint32_t rand;
+            char *alt;
+
+            pa_log_debug("RAOP: RECORD");
+
+            alt = pa_xstrdup(pa_headerlist_gets(headers, "Audio-Latency"));
+            /* Generate a random synchronization source identifier from this session. */
+            pa_random(&rand, sizeof(rand));
+            c->udp_ssrc = rand;
+
+            if (alt)
+                pa_atoi(alt, &latency);
+
+            c->udp_first_packet = true;
+            c->udp_sync_count = 0;
+
+            c->is_recording = true;
+
+            c->udp_record_callback(c->udp_setup_userdata);
+
+            pa_xfree(alt);
+            break;
+        }
+
+        case STATE_SET_PARAMETER: {
+            pa_log_debug("RAOP: SET_PARAMETER");
+
+            break;
+        }
+
+        case STATE_FLUSH: {
+            pa_log_debug("RAOP: FLUSHED");
+
+            c->is_recording = false;
+
+            break;
+        }
+
+        case STATE_TEARDOWN: {
+            pa_log_debug("RAOP: TEARDOWN");
+            pa_assert(c->udp_disconnected_callback);
+            pa_assert(c->rtsp);
+
+            c->is_recording = false;
+
+            pa_rtsp_disconnect(c->rtsp);
+
+            if (c->udp_stream_fd > 0) {
+                pa_close(c->udp_stream_fd);
+                c->udp_stream_fd = -1;
             }
-            if (c->sc) {
-                pa_socket_client_unref(c->sc);
-                c->sc = NULL;
+
+            pa_log_debug("RTSP control channel closed (teardown)");
+
+            pa_raop_pb_clear(c->packet_buffer);
+
+            pa_rtsp_client_free(c->rtsp);
+            pa_xfree(c->sid);
+            c->rtsp = NULL;
+            c->sid = NULL;
+
+            /*
+              Callback for cleanup -- e.g. pollfd
+
+              Share the disconnected callback since TEARDOWN event
+              is essentially equivalent to DISCONNECTED.
+              In case some special treatment turns out to be required
+              for TEARDOWN in future, a new callback function may be
+              defined and used.
+            */
+            c->udp_disconnected_callback(c->udp_disconnected_userdata);
+
+            /* Control and timing fds are closed by udp_sink_process_msg,
+               after it disables poll */
+            c->udp_control_fd = -1;
+            c->udp_timing_fd = -1;
+
+            break;
+        }
+
+        case STATE_DISCONNECTED: {
+            pa_log_debug("RAOP: DISCONNECTED");
+            pa_assert(c->udp_disconnected_callback);
+            pa_assert(c->rtsp);
+
+            if (c->udp_stream_fd > 0) {
+                pa_close(c->udp_stream_fd);
+                c->udp_stream_fd = -1;
             }
+
+            pa_log_debug("RTSP control channel closed (disconnected)");
+
+            pa_raop_pb_clear(c->packet_buffer);
+
+            pa_rtsp_client_free(c->rtsp);
             pa_xfree(c->sid);
+            c->rtsp = NULL;
             c->sid = NULL;
-            c->closed_callback(c->closed_userdata);
+
+            c->udp_disconnected_callback(c->udp_disconnected_userdata);
+            /* Control and timing fds are closed by udp_sink_process_msg,
+               after it disables poll */
+            c->udp_control_fd = -1;
+            c->udp_timing_fd = -1;
+
             break;
+        }
     }
 }
 
-pa_raop_client* pa_raop_client_new(pa_core *core, const char* host) {
+pa_raop_client* pa_raop_client_new(pa_core *core, const char *host,
+                                   pa_raop_protocol_t protocol,
+                                   pa_sample_spec spec) {
     pa_parsed_address a;
-    pa_raop_client* c = pa_xnew0(pa_raop_client, 1);
+    pa_raop_client *c = pa_xnew0(pa_raop_client, 1);
 
     pa_assert(core);
     pa_assert(host);
@@ -376,24 +1053,45 @@ pa_raop_client* pa_raop_client_new(pa_core *core, const char* host) {
         return NULL;
 
     c->core = core;
-    c->fd = -1;
+    c->tcp_fd = -1;
+    c->protocol = protocol;
+    c->udp_stream_fd = -1;
+    c->udp_control_fd = -1;
+    c->udp_timing_fd = -1;
+
+    c->udp_my_control_port     = UDP_DEFAULT_CONTROL_PORT;
+    c->udp_server_control_port = UDP_DEFAULT_CONTROL_PORT;
+    c->udp_my_timing_port      = UDP_DEFAULT_TIMING_PORT;
+    c->udp_server_timing_port  = UDP_DEFAULT_TIMING_PORT;
 
     c->host = pa_xstrdup(a.path_or_host);
     if (a.port)
         c->port = a.port;
     else
-        c->port = RAOP_PORT;
+        c->port = DEFAULT_RAOP_PORT;
+
+    c->is_recording = false;
+
+    c->udp_first_packet = true;
+    /* Packet sync interval should be around 1s. */
+    c->udp_sync_interval = spec.rate / UDP_FRAMES_PER_PACKET;
+    c->udp_sync_count = 0;
+
+    if (c->protocol == RAOP_TCP) {
+        if (pa_raop_client_connect(c)) {
+            pa_raop_client_free(c);
+            return NULL;
+        }
+    } else
+        c->packet_buffer = pa_raop_pb_new(UDP_DEFAULT_PKT_BUF_SIZE);
 
-    if (pa_raop_connect(c)) {
-        pa_raop_client_free(c);
-        return NULL;
-    }
     return c;
 }
 
-void pa_raop_client_free(pa_raop_client* c) {
+void pa_raop_client_free(pa_raop_client *c) {
     pa_assert(c);
 
+    pa_raop_pb_delete(c->packet_buffer);
     if (c->rtsp)
         pa_rtsp_client_free(c->rtsp);
     if (c->sid)
@@ -402,7 +1100,7 @@ void pa_raop_client_free(pa_raop_client* c) {
     pa_xfree(c);
 }
 
-int pa_raop_connect(pa_raop_client* c) {
+int pa_raop_client_connect(pa_raop_client *c) {
     char *sci;
     struct {
         uint32_t a;
@@ -417,33 +1115,282 @@ int pa_raop_connect(pa_raop_client* c) {
         return 0;
     }
 
-    c->rtsp = pa_rtsp_client_new(c->core->mainloop, c->host, c->port, "iTunes/4.6 (Macintosh; U; PPC Mac OS X 10.3)");
+    if (c->protocol == RAOP_TCP)
+        c->rtsp = pa_rtsp_client_new(c->core->mainloop, c->host, c->port, "iTunes/4.6 (Macintosh; U; PPC Mac OS X 10.3)");
+    else
+        c->rtsp = pa_rtsp_client_new(c->core->mainloop, c->host, c->port, "iTunes/7.6.2 (Windows; N;)");
 
-    /* Initialise the AES encryption system */
+    /* Initialise the AES encryption system. */
     pa_random(c->aes_iv, sizeof(c->aes_iv));
     pa_random(c->aes_key, sizeof(c->aes_key));
     memcpy(c->aes_nv, c->aes_iv, sizeof(c->aes_nv));
     AES_set_encrypt_key(c->aes_key, 128, &c->aes);
 
-    /* Generate random instance id */
+    /* Generate random instance id. */
     pa_random(&rand_data, sizeof(rand_data));
     c->sid = pa_sprintf_malloc("%u", rand_data.a);
     sci = pa_sprintf_malloc("%08x%08x",rand_data.b, rand_data.c);
     pa_rtsp_add_header(c->rtsp, "Client-Instance", sci);
     pa_xfree(sci);
-    pa_rtsp_set_callback(c->rtsp, rtsp_cb, c);
+    if (c->protocol == RAOP_TCP)
+        pa_rtsp_set_callback(c->rtsp, tcp_rtsp_cb, c);
+    else
+        pa_rtsp_set_callback(c->rtsp, udp_rtsp_cb, c);
+
+    c->is_recording = false;
+
     return pa_rtsp_connect(c->rtsp);
 }
 
-int pa_raop_flush(pa_raop_client* c) {
+int pa_raop_client_flush(pa_raop_client *c) {
+    int rv = 0;
+
     pa_assert(c);
 
-    pa_rtsp_flush(c->rtsp, c->seq, c->rtptime);
-    return 0;
+    if (c->rtsp != NULL) {
+        rv = pa_rtsp_flush(c->rtsp, c->seq, c->rtptime);
+        c->udp_sync_count = 0;
+    }
+
+    return rv;
+}
+
+int pa_raop_client_teardown(pa_raop_client *c) {
+    int rv = 0;
+
+    pa_assert(c);
+
+    if (c->rtsp != NULL)
+        rv = pa_rtsp_teardown(c->rtsp);
+
+    return rv;
+}
+
+int pa_raop_client_udp_is_alive(pa_raop_client *c) {
+    int rv = 0;
+
+    pa_assert(c);
+
+    if (c->udp_stream_fd > 0)
+        rv = 1;
+
+    return rv;
+}
+
+int pa_raop_client_udp_can_stream(pa_raop_client *c) {
+    int rv = 0;
+
+    pa_assert(c);
+
+    if (c->is_recording && c->udp_stream_fd > 0)
+        rv = 1;
+
+    return rv;
 }
 
-int pa_raop_client_set_volume(pa_raop_client* c, pa_volume_t volume) {
-    int rv;
+int pa_raop_client_udp_stream(pa_raop_client *c) {
+    int rv = 0;
+
+    pa_assert(c);
+
+    if (c->rtsp != NULL && c->udp_stream_fd > 0) {
+        if (!c->is_recording) {
+            c->udp_first_packet = true;
+            c->udp_sync_count = 0;
+
+            c->is_recording = true;
+         }
+
+        rv = 1;
+    }
+
+    return rv;
+}
+
+int pa_raop_client_udp_handle_timing_packet(pa_raop_client *c, const uint8_t packet[], ssize_t size) {
+    const uint32_t * data = NULL;
+    uint8_t payload = 0;
+    struct timeval tv;
+    uint64_t rci = 0;
+    int rv = 0;
+
+    pa_assert(c);
+    pa_assert(packet);
+
+    /* Timing packets are 32 bytes long: 1 x 8 RTP header (no ssrc) + 3 x 8 NTP timestamps. */
+    if (size != 32 || packet[0] != 0x80)
+    {
+        pa_log_debug("Received an invalid timing packet.");
+        return 1;
+    }
+
+    data = (uint32_t *) (packet + sizeof(udp_timming_header));
+    rci = timeval_to_ntp(pa_rtclock_get(&tv));
+    /* The market bit is always set (see rfc3550 for packet structure) ! */
+    payload = packet[1] ^ 0x80;
+    switch (payload) {
+        case UDP_PAYLOAD_TIMING_REQUEST:
+            rv = udp_send_timing_packet(c, data, rci);
+            break;
+        case UDP_PAYLOAD_TIMING_RESPONSE:
+        default:
+            pa_log_debug("Got an unexpected payload type on timing channel !");
+            return 1;
+    }
+
+    return rv;
+}
+
+static int udp_resend_packets(pa_raop_client *c, uint16_t seq_num, uint16_t num_packets) {
+    int rv = -1;
+    uint8_t *data = NULL;
+    ssize_t len = 0;
+    int i = 0;
+
+    pa_assert(c);
+    pa_assert(num_packets > 0);
+    pa_assert(c->packet_buffer);
+
+    for (i = seq_num; i < seq_num + num_packets; i++) {
+        len = pa_raop_pb_read_packet(c->packet_buffer, i, (uint8_t **) &data);
+
+        if (len > 0) {
+            ssize_t r;
+
+            /* Obtained buffer has a header room for retransmission
+               header */
+            udp_build_retrans_header((uint32_t *) data, len, seq_num);
+            r = udp_send_audio_packet(c, true /* retrans */, data, len);
+            if (r == len)
+                rv = 0;
+            else
+                rv = -1;
+        } else
+            pa_log_debug("Packet not found in retrans buffer: %u", i);
+    }
+
+    return rv;
+}
+
+int pa_raop_client_udp_handle_control_packet(pa_raop_client *c, const uint8_t packet[], ssize_t size) {
+    uint8_t payload = 0;
+    int rv = 0;
+
+    uint16_t seq_num;
+    uint16_t num_packets;
+
+    pa_assert(c);
+    pa_assert(packet);
+
+    if ((size != 20 && size != 8) || packet[0] != 0x80)
+    {
+        pa_log_debug("Received an invalid control packet.");
+        return 1;
+    }
+
+    /* The market bit is always set (see rfc3550 for packet structure) ! */
+
+    payload = packet[1] ^ 0x80;
+    switch (payload) {
+        case UDP_PAYLOAD_RETRANSMIT_REQUEST:
+            pa_assert(size == 8);
+
+            /* Requested start sequence number */
+            seq_num = ((uint16_t) packet[4]) << 8;
+            seq_num |= (uint16_t) packet[5];
+            /* Number of requested packets starting at requested seq. number */
+            num_packets = (uint16_t) packet[6] << 8;
+            num_packets |= (uint16_t) packet[7];
+            pa_log_debug("Resending %d packets starting at %d", num_packets, seq_num);
+            rv = udp_resend_packets(c, seq_num, num_packets);
+            break;
+
+        case UDP_PAYLOAD_RETRANSMIT_REPLY:
+            pa_log_debug("Received a retransmit reply packet on control port (this should never happen)");
+            break;
+
+        default:
+            pa_log_debug("Got an unexpected payload type on control channel: %u !", payload);
+            return 1;
+    }
+
+    return rv;
+}
+
+int pa_raop_client_udp_get_blocks_size(pa_raop_client *c, size_t *size) {
+    int rv = 0;
+
+    pa_assert(c);
+    pa_assert(size);
+
+    *size = UDP_FRAMES_PER_PACKET;
+
+    return rv;
+}
+
+ssize_t pa_raop_client_udp_send_audio_packet(pa_raop_client *c, pa_memchunk *block) {
+    uint8_t *buf = NULL;
+    ssize_t len;
+
+    pa_assert(c);
+    pa_assert(block);
+
+    /* Sync RTP & NTP timestamp if required. */
+    if (c->udp_first_packet || c->udp_sync_count >= c->udp_sync_interval) {
+        udp_send_sync_packet(c, c->rtptime);
+        c->udp_sync_count = 0;
+    } else {
+        c->udp_sync_count++;
+    }
+
+    buf = pa_memblock_acquire(block->memblock);
+    pa_assert(buf);
+    pa_assert(block->length > 0);
+    udp_build_audio_header(c, (uint32_t *) (buf + block->index), block->length);
+    len = udp_send_audio_packet(c, false, buf + block->index, block->length);
+
+    /* Store packet for resending in the packet buffer */
+    pa_raop_pb_write_packet(c->packet_buffer, c->seq, buf + block->index,
+                            block->length);
+
+    c->seq++;
+
+    pa_memblock_release(block->memblock);
+
+    if (len > 0) {
+        pa_assert((size_t) len <= block->length);
+        /* UDP packet has to be sent at once, so it is meaningless to
+           preseve the partial data
+           FIXME: This won't happen at least in *NIX systems?? */
+        if (block->length > (size_t) len) {
+            pa_log_warn("Tried to send %zu bytes but managed to send %zu bytes", block->length, len);
+            len = block->length;
+        }
+        block->index += block->length;
+        block->length = 0;
+    }
+
+    if (c->udp_first_packet)
+        c->udp_first_packet = false;
+
+    return len;
+}
+
+/* Adjust volume so that it fits into VOLUME_DEF <= v <= 0 dB */
+pa_volume_t pa_raop_client_adjust_volume(pa_raop_client *c, pa_volume_t volume) {
+    double minv, maxv;
+
+    if (c->protocol != RAOP_UDP)
+        return volume;
+
+    maxv = pa_sw_volume_from_dB(0.0);
+    minv = maxv * pow(10.0, (double) VOLUME_DEF / 60.0);
+
+    return volume - volume * (minv / maxv) + minv;
+}
+
+int pa_raop_client_set_volume(pa_raop_client *c, pa_volume_t volume) {
+    int rv = 0;
     double db;
     char *param;
 
@@ -455,15 +1402,19 @@ int pa_raop_client_set_volume(pa_raop_client* c, pa_volume_t volume) {
     else if (db > VOLUME_MAX)
         db = VOLUME_MAX;
 
+    pa_log_debug("volume=%u db=%.6f", volume, db);
+
     param = pa_sprintf_malloc("volume: %0.6f\r\n",  db);
 
-    /* We just hit and hope, cannot wait for the callback */
-    rv = pa_rtsp_setparameter(c->rtsp, param);
+    /* We just hit and hope, cannot wait for the callback. */
+    if (c->rtsp != NULL && pa_rtsp_exec_ready(c->rtsp))
+        rv = pa_rtsp_setparameter(c->rtsp, param);
     pa_xfree(param);
+
     return rv;
 }
 
-int pa_raop_client_encode_sample(pa_raop_client* c, pa_memchunk* raw, pa_memchunk* encoded) {
+int pa_raop_client_encode_sample(pa_raop_client *c, pa_memchunk *raw, pa_memchunk *encoded) {
     uint16_t len;
     size_t bufmax;
     uint8_t *bp, bpos;
@@ -472,53 +1423,57 @@ int pa_raop_client_encode_sample(pa_raop_client* c, pa_memchunk* raw, pa_memchun
     uint8_t *b, *p;
     uint32_t bsize;
     size_t length;
-    static uint8_t header[] = {
-        0x24, 0x00, 0x00, 0x00,
-        0xF0, 0xFF, 0x00, 0x00,
-        0x00, 0x00, 0x00, 0x00,
-        0x00, 0x00, 0x00, 0x00,
-    };
-    int header_size = sizeof(header);
+    const uint8_t *header;
+    int header_size;
 
     pa_assert(c);
-    pa_assert(c->fd > 0);
     pa_assert(raw);
     pa_assert(raw->memblock);
     pa_assert(raw->length > 0);
     pa_assert(encoded);
 
+    if (c->protocol == RAOP_TCP) {
+        header = tcp_audio_header;
+        header_size = sizeof(tcp_audio_header);
+    } else {
+        header = udp_audio_header;
+        header_size = sizeof(udp_audio_header);
+    }
+
     /* We have to send 4 byte chunks */
     bsize = (int)(raw->length / 4);
     length = bsize * 4;
 
-    /* Leave 16 bytes extra to allow for the ALAC header which is about 55 bits */
+    /* Leave 16 bytes extra to allow for the ALAC header which is about 55 bits. */
     bufmax = length + header_size + 16;
     pa_memchunk_reset(encoded);
     encoded->memblock = pa_memblock_new(c->core->mempool, bufmax);
     b = pa_memblock_acquire(encoded->memblock);
     memcpy(b, header, header_size);
 
-    /* Now write the actual samples */
+    /* Now write the actual samples. */
     bp = b + header_size;
     size = bpos = 0;
     bit_writer(&bp,&bpos,&size,1,3); /* channel=1, stereo */
-    bit_writer(&bp,&bpos,&size,0,4); /* unknown */
-    bit_writer(&bp,&bpos,&size,0,8); /* unknown */
-    bit_writer(&bp,&bpos,&size,0,4); /* unknown */
-    bit_writer(&bp,&bpos,&size,1,1); /* hassize */
-    bit_writer(&bp,&bpos,&size,0,2); /* unused */
-    bit_writer(&bp,&bpos,&size,1,1); /* is-not-compressed */
-
-    /* size of data, integer, big endian */
+    bit_writer(&bp,&bpos,&size,0,4); /* Unknown */
+    bit_writer(&bp,&bpos,&size,0,8); /* Unknown */
+    bit_writer(&bp,&bpos,&size,0,4); /* Unknown */
+    bit_writer(&bp,&bpos,&size,1,1); /* Hassize */
+    bit_writer(&bp,&bpos,&size,0,2); /* Unused */
+    bit_writer(&bp,&bpos,&size,1,1); /* Is-not-compressed */
+
+    /* Size of data, integer, big endian. */
     bit_writer(&bp,&bpos,&size,(bsize>>24)&0xff,8);
     bit_writer(&bp,&bpos,&size,(bsize>>16)&0xff,8);
     bit_writer(&bp,&bpos,&size,(bsize>>8)&0xff,8);
     bit_writer(&bp,&bpos,&size,(bsize)&0xff,8);
 
-    ibp = p = pa_memblock_acquire(raw->memblock);
+    p = pa_memblock_acquire(raw->memblock);
+    p += raw->index;
+    ibp = p;
     maxibp = p + raw->length - 4;
     while (ibp <= maxibp) {
-        /* Byte swap stereo data */
+        /* Byte swap stereo data. */
         bit_writer(&bp,&bpos,&size,*(ibp+1),8);
         bit_writer(&bp,&bpos,&size,*(ibp+0),8);
         bit_writer(&bp,&bpos,&size,*(ibp+3),8);
@@ -527,33 +1482,64 @@ int pa_raop_client_encode_sample(pa_raop_client* c, pa_memchunk* raw, pa_memchun
         raw->index += 4;
         raw->length -= 4;
     }
+    if (c->protocol == RAOP_UDP)
+        c->rtptime += (ibp - p) / 4;
     pa_memblock_release(raw->memblock);
     encoded->length = header_size + size;
 
-    /* store the length (endian swapped: make this better) */
-    len = size + header_size - 4;
-    *(b + 2) = len >> 8;
-    *(b + 3) = len & 0xff;
+    if (c->protocol == RAOP_TCP) {
+        /* Store the length (endian swapped: make this better). */
+        len = size + header_size - 4;
+        *(b + 2) = len >> 8;
+        *(b + 3) = len & 0xff;
+    }
 
-    /* encrypt our data */
-    aes_encrypt(c, (b + header_size), size);
+    if (c->encryption) {
+        /* Encrypt our data. */
+        aes_encrypt(c, (b + header_size), size);
+    }
 
-    /* We're done with the chunk */
+    /* We're done with the chunk. */
     pa_memblock_release(encoded->memblock);
 
     return 0;
 }
 
-void pa_raop_client_set_callback(pa_raop_client* c, pa_raop_client_cb_t callback, void *userdata) {
+void pa_raop_client_tcp_set_callback(pa_raop_client *c, pa_raop_client_cb_t callback, void *userdata) {
+    pa_assert(c);
+
+    c->tcp_callback = callback;
+    c->tcp_userdata = userdata;
+}
+
+void pa_raop_client_tcp_set_closed_callback(pa_raop_client *c, pa_raop_client_closed_cb_t callback, void *userdata) {
+    pa_assert(c);
+
+    c->tcp_closed_callback = callback;
+    c->tcp_closed_userdata = userdata;
+}
+
+void pa_raop_client_set_encryption(pa_raop_client *c, int encryption) {
+    c->encryption = encryption;
+}
+
+void pa_raop_client_udp_set_setup_callback(pa_raop_client *c, pa_raop_client_setup_cb_t callback, void *userdata) {
+    pa_assert(c);
+
+    c->udp_setup_callback = callback;
+    c->udp_setup_userdata = userdata;
+}
+
+void pa_raop_client_udp_set_record_callback(pa_raop_client *c, pa_raop_client_record_cb_t callback, void *userdata) {
     pa_assert(c);
 
-    c->callback = callback;
-    c->userdata = userdata;
+    c->udp_record_callback = callback;
+    c->udp_record_userdata = userdata;
 }
 
-void pa_raop_client_set_closed_callback(pa_raop_client* c, pa_raop_client_closed_cb_t callback, void *userdata) {
+void pa_raop_client_udp_set_disconnected_callback(pa_raop_client *c, pa_raop_client_disconnected_cb_t callback, void *userdata) {
     pa_assert(c);
 
-    c->closed_callback = callback;
-    c->closed_userdata = userdata;
+    c->udp_disconnected_callback = callback;
+    c->udp_disconnected_userdata = userdata;
 }
diff --git a/src/modules/raop/raop_client.h b/src/modules/raop/raop_client.h
index ce81f39..ad752b2 100644
--- a/src/modules/raop/raop_client.h
+++ b/src/modules/raop/raop_client.h
@@ -21,24 +21,57 @@
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
   USA.
 ***/
+#include <pulse/sample.h>
+#include <pulse/volume.h>
 
 #include <pulsecore/core.h>
+#include <pulsecore/memchunk.h>
+
+#define UDP_FRAMES_PER_PACKET 352
+
+typedef enum pa_raop_protocol {
+    RAOP_TCP,
+    RAOP_UDP,
+} pa_raop_protocol_t;
 
 typedef struct pa_raop_client pa_raop_client;
 
-pa_raop_client* pa_raop_client_new(pa_core *core, const char* host);
-void pa_raop_client_free(pa_raop_client* c);
+pa_raop_client* pa_raop_client_new(pa_core *core, const char *host, pa_raop_protocol_t protocol, pa_sample_spec spec);
+void pa_raop_client_free(pa_raop_client *c);
+
+int pa_raop_client_connect(pa_raop_client *c);
+int pa_raop_client_flush(pa_raop_client *c);
+int pa_raop_client_teardown(pa_raop_client *c);
+
+int pa_raop_client_udp_is_alive(pa_raop_client *c);
+int pa_raop_client_udp_can_stream(pa_raop_client *c);
+int pa_raop_client_udp_stream(pa_raop_client *c);
 
-int pa_raop_connect(pa_raop_client* c);
-int pa_raop_flush(pa_raop_client* c);
+void pa_raop_client_set_encryption(pa_raop_client *c, int encryption);
+pa_volume_t pa_raop_client_adjust_volume(pa_raop_client *c, pa_volume_t volume);
+int pa_raop_client_set_volume(pa_raop_client *c, pa_volume_t volume);
+int pa_raop_client_encode_sample(pa_raop_client *c, pa_memchunk *raw, pa_memchunk *encoded);
 
-int pa_raop_client_set_volume(pa_raop_client* c, pa_volume_t volume);
-int pa_raop_client_encode_sample(pa_raop_client* c, pa_memchunk* raw, pa_memchunk* encoded);
+int pa_raop_client_udp_handle_timing_packet(pa_raop_client *c, const uint8_t packet
+[], ssize_t size);
+int pa_raop_client_udp_handle_control_packet(pa_raop_client *c, const uint8_t packet[], ssize_t size);
+int pa_raop_client_udp_get_blocks_size(pa_raop_client *c, size_t *size);
+ssize_t pa_raop_client_udp_send_audio_packet(pa_raop_client *c, pa_memchunk *block);
 
 typedef void (*pa_raop_client_cb_t)(int fd, void *userdata);
-void pa_raop_client_set_callback(pa_raop_client* c, pa_raop_client_cb_t callback, void *userdata);
+void pa_raop_client_tcp_set_callback(pa_raop_client *c, pa_raop_client_cb_t callback, void *userdata);
 
 typedef void (*pa_raop_client_closed_cb_t)(void *userdata);
-void pa_raop_client_set_closed_callback(pa_raop_client* c, pa_raop_client_closed_cb_t callback, void *userdata);
+void pa_raop_client_tcp_set_closed_callback(pa_raop_client *c, pa_raop_client_closed_cb_t callback, void *userdata);
+
+
+typedef void (*pa_raop_client_setup_cb_t)(int control_fd, int timing_fd, void *userdata);
+void pa_raop_client_udp_set_setup_callback(pa_raop_client *c, pa_raop_client_setup_cb_t callback, void *userdata);
+
+typedef void (*pa_raop_client_record_cb_t)(void *userdata);
+void pa_raop_client_udp_set_record_callback(pa_raop_client *c, pa_raop_client_record_cb_t callback, void *userdata);
+
+typedef void (*pa_raop_client_disconnected_cb_t)(void *userdata);
+void pa_raop_client_udp_set_disconnected_callback(pa_raop_client *c, pa_raop_client_disconnected_cb_t callback, void *userdata);
 
 #endif
diff --git a/src/modules/raop/raop_packet_buffer.c b/src/modules/raop/raop_packet_buffer.c
new file mode 100644
index 0000000..b8c1bc8
--- /dev/null
+++ b/src/modules/raop/raop_packet_buffer.c
@@ -0,0 +1,172 @@
+/***
+  Circular buffer for RTP audio packets with random access support
+  by RTP sequence number.
+
+  Copyright 2013 Matthias Wabersich, Hajime Fujita
+
+  This is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2.1 of the License,
+  or (at your option) any later version.
+
+  This is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+
+***/
+
+#include <stdlib.h>
+#include <limits.h>
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core-error.h>
+#include "raop_client.h"
+
+#include "raop_packet_buffer.h"
+
+/* FRAMES_PER_PACKET*2*2 + sizeof(udp_audio_header) + sizeof(ALAC header), unencoded */
+#define PACKET_SIZE_MAX (UDP_FRAMES_PER_PACKET*2*2 + 12 + 7)
+/* Header room for packet retransmission header */
+#define RETRANS_HEADER_ROOM 4
+
+/* Packet element */
+struct pa_raop_packet_element {
+    uint16_t  seq_num; /* RTP sequence number (in host byte order) */
+    ssize_t   length;  /* Actual packet length */
+    /* Packet data including RTP header */
+    uint8_t   data[PACKET_SIZE_MAX + RETRANS_HEADER_ROOM];
+};
+
+/* Buffer struct */
+struct pa_raop_packet_buffer {
+    size_t   size;          /* max number of packets in buffer */
+    size_t   start;         /* index of oldest packet */
+    size_t   count;         /* number of packets in buffer */
+    uint16_t first_seq_num; /* Sequence number of first packet in buffer */
+    uint16_t latest_seq_num; /* Debug purpose */
+    pa_raop_packet_element *packets; /* Packet element pointer */
+};
+
+pa_raop_packet_buffer *pa_raop_pb_new(size_t size) {
+    pa_raop_packet_buffer *pb = pa_xmalloc0(sizeof(*pb));
+
+    pb->size = size;
+    pb->packets = (pa_raop_packet_element *)
+        pa_xmalloc(size * sizeof(pa_raop_packet_element));
+
+    pa_raop_pb_clear(pb);
+
+    return pb;
+}
+
+void pa_raop_pb_clear(pa_raop_packet_buffer *pb) {
+    pb->start = 0;
+    pb->count = 0;
+    pb->first_seq_num = 0;
+    pb->latest_seq_num = 0;
+    memset(pb->packets, 0, pb->size * sizeof(pa_raop_packet_element));
+}
+
+void pa_raop_pb_delete(pa_raop_packet_buffer *pb) {
+    pa_xfree(pb->packets);
+    pa_xfree(pb);
+}
+
+static int pb_is_full(pa_raop_packet_buffer *pb) {
+    return pb->count == pb->size;
+}
+
+static int pb_is_empty(pa_raop_packet_buffer *pb) {
+    return pb->count == 0;
+}
+
+static pa_raop_packet_element *pb_prepare_write(pa_raop_packet_buffer *pb, uint16_t seq) {
+    size_t end = (pb->start + pb->count) % pb->size;
+    pa_raop_packet_element *packet;
+
+    /* Set first packet sequence number in buffer if buffer is empty */
+    if (pb_is_empty(pb))
+        pb->first_seq_num = seq;
+    else
+        pa_assert((uint16_t) (pb->latest_seq_num + 1) == seq);
+
+    packet = &pb->packets[end];
+
+    if (pb_is_full(pb)) {
+        pb->start = (pb->start + 1) % pb->size; /* full, overwrite */
+
+        /* Set first packet sequence number in buffer
+           to new start packet sequence number */
+        pb->first_seq_num = pb->packets[pb->start].seq_num;
+    } else
+        ++ pb->count;
+
+    pb->latest_seq_num = seq;
+
+    return packet;
+}
+
+/* Write packet data to packet buffer */
+void pa_raop_pb_write_packet(pa_raop_packet_buffer *pb, uint16_t seq_num, const uint8_t *packet_data, ssize_t packet_length) {
+    pa_raop_packet_element *packet;
+
+    pa_assert(pb);
+    pa_assert(packet_data);
+    pa_assert(packet_length <= PACKET_SIZE_MAX);
+
+    packet = pb_prepare_write(pb, seq_num);
+    packet->seq_num = seq_num;
+    packet->length = packet_length + RETRANS_HEADER_ROOM;
+
+    /* Insert RETRANS_HEADER_ROOM bytes in front of packet data,
+       for retransmission header */
+    memset(packet->data, 0, RETRANS_HEADER_ROOM);
+    memcpy(packet->data + RETRANS_HEADER_ROOM, packet_data, packet_length);
+}
+
+/* l < r?, considers wrapping */
+static bool seq_lt(uint16_t l, uint16_t r) {
+    return l - r > USHRT_MAX/2;
+}
+
+/* Random access to packet from buffer by sequence number for (re-)sending. */
+ssize_t pa_raop_pb_read_packet(pa_raop_packet_buffer *pb, uint16_t seq_num, uint8_t **packet_data) {
+    uint16_t index = 0; /* Index of requested packet */
+    pa_raop_packet_element *packet;
+
+    /* If the buffer is empty, there is no use in calculating indices */
+    if (pb_is_empty(pb))
+        return -1;
+
+    /* If the requested packet is too old (seq_num below first seq number
+       in buffer) or too young (seq_num greater than current seq number),
+       do nothing and return */
+    if (seq_lt(seq_num, pb->first_seq_num))
+        return -1;
+
+    index = (uint16_t) (seq_num - pb->first_seq_num);
+    if (index >= pb->count)
+        return -1;
+
+    /*  Index of the requested packet in the buffer is calculated
+        using the first sequence number stored in the buffer.
+        The offset (seq_num - first_seq_num) is used to access the array. */
+    packet = &pb->packets[(pb->start + index) % pb->size];
+
+    pa_assert(packet->data[RETRANS_HEADER_ROOM + 2] == (seq_num >> 8));
+    pa_assert(packet->data[RETRANS_HEADER_ROOM + 3] == (seq_num & 0xff));
+    pa_assert(packet_data);
+
+    *packet_data = packet->data;
+
+    return packet->length;
+}
diff --git a/src/modules/raop/raop_packet_buffer.h b/src/modules/raop/raop_packet_buffer.h
new file mode 100644
index 0000000..d8a08a0
--- /dev/null
+++ b/src/modules/raop/raop_packet_buffer.h
@@ -0,0 +1,42 @@
+#ifndef RAOP_PACKET_BUFFER_H_INCLUDED
+#define RAOP_PACKET_BUFFER_H_INCLUDED
+
+/***
+  Circular buffer for RTP audio packets with random access support
+  by RTP sequence number.
+
+  Copyright 2013 Matthias Wabersich, Hajime Fujita
+
+  This is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as published
+  by the Free Software Foundation; either version 2.1 of the License,
+  or (at your option) any later version.
+
+  This is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with PulseAudio; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+  USA.
+
+***/
+
+struct pa_raop_packet_element;
+typedef struct pa_raop_packet_element pa_raop_packet_element;
+
+struct pa_raop_packet_buffer;
+typedef struct pa_raop_packet_buffer pa_raop_packet_buffer;
+
+/* Allocates a new circular packet buffer
+   size: Maximum number of packets to store */
+pa_raop_packet_buffer *pa_raop_pb_new(size_t size);
+void pa_raop_pb_clear(pa_raop_packet_buffer *pb);
+void pa_raop_pb_delete(pa_raop_packet_buffer *pb);
+
+void pa_raop_pb_write_packet(pa_raop_packet_buffer *pb, uint16_t seq_num, const uint8_t *packet_data, ssize_t packet_length);
+ssize_t pa_raop_pb_read_packet(pa_raop_packet_buffer *pb, uint16_t seq_num, uint8_t **packet_data);
+
+#endif /* RAOP_PACKET_BUFFER_H_INCLUDED */
diff --git a/src/modules/rtp/rtsp_client.c b/src/modules/rtp/rtsp_client.c
index 6edb0e4..833fe7e 100644
--- a/src/modules/rtp/rtsp_client.c
+++ b/src/modules/rtp/rtsp_client.c
@@ -43,6 +43,7 @@
 #include <pulsecore/strbuf.h>
 #include <pulsecore/ioline.h>
 #include <pulsecore/arpa-inet.h>
+#include <pulsecore/random.h>
 
 #include "rtsp_client.h"
 
@@ -75,7 +76,7 @@ struct pa_rtsp_client {
     char *transport;
 };
 
-pa_rtsp_client* pa_rtsp_client_new(pa_mainloop_api *mainloop, const char* hostname, uint16_t port, const char* useragent) {
+pa_rtsp_client* pa_rtsp_client_new(pa_mainloop_api *mainloop, const char *hostname, uint16_t port, const char *useragent) {
     pa_rtsp_client *c;
 
     pa_assert(mainloop);
@@ -96,7 +97,7 @@ pa_rtsp_client* pa_rtsp_client_new(pa_mainloop_api *mainloop, const char* hostna
     return c;
 }
 
-void pa_rtsp_client_free(pa_rtsp_client* c) {
+void pa_rtsp_client_free(pa_rtsp_client *c) {
     pa_assert(c);
 
     if (c->sc)
@@ -201,7 +202,7 @@ static void line_callback(pa_ioline *line, const char *s, void *userdata) {
     }
     if (c->waiting) {
         pa_log_warn("Unexpected response: %s", s2);
-        goto exit;;
+        goto exit;
     }
     if (!strlen(s2)) {
         /* End of headers */
@@ -355,25 +356,25 @@ void pa_rtsp_disconnect(pa_rtsp_client *c) {
     c->ioline = NULL;
 }
 
-const char* pa_rtsp_localip(pa_rtsp_client* c) {
+const char* pa_rtsp_localip(pa_rtsp_client *c) {
     pa_assert(c);
 
     return c->localip;
 }
 
-uint32_t pa_rtsp_serverport(pa_rtsp_client* c) {
+uint32_t pa_rtsp_serverport(pa_rtsp_client *c) {
     pa_assert(c);
 
     return c->rtp_port;
 }
 
-void pa_rtsp_set_url(pa_rtsp_client* c, const char* url) {
+void pa_rtsp_set_url(pa_rtsp_client *c, const char *url) {
     pa_assert(c);
 
     c->url = pa_xstrdup(url);
 }
 
-void pa_rtsp_add_header(pa_rtsp_client *c, const char* key, const char* value) {
+void pa_rtsp_add_header(pa_rtsp_client *c, const char *key, const char *value) {
     pa_assert(c);
     pa_assert(key);
     pa_assert(value);
@@ -381,19 +382,25 @@ void pa_rtsp_add_header(pa_rtsp_client *c, const char* key, const char* value) {
     pa_headerlist_puts(c->headers, key, value);
 }
 
-void pa_rtsp_remove_header(pa_rtsp_client *c, const char* key) {
+void pa_rtsp_remove_header(pa_rtsp_client *c, const char *key) {
     pa_assert(c);
     pa_assert(key);
 
     pa_headerlist_remove(c->headers, key);
 }
 
-static int rtsp_exec(pa_rtsp_client* c, const char* cmd,
-                        const char* content_type, const char* content,
+bool pa_rtsp_exec_ready(const pa_rtsp_client *c) {
+    pa_assert(c);
+
+    return c->url != NULL && c->ioline != NULL;
+}
+
+static int rtsp_exec(pa_rtsp_client *c, const char *cmd,
+                        const char *content_type, const char *content,
                         int expect_response,
-                        pa_headerlist* headers) {
-    pa_strbuf* buf;
-    char* hdrs;
+                        pa_headerlist *headers) {
+    pa_strbuf *buf;
+    char *hdrs;
 
     pa_assert(c);
     pa_assert(c->url);
@@ -443,43 +450,69 @@ static int rtsp_exec(pa_rtsp_client* c, const char* cmd,
     return 0;
 }
 
-int pa_rtsp_announce(pa_rtsp_client *c, const char* sdp) {
+int pa_rtsp_options(pa_rtsp_client *c) {
+    char *url;
+    int rv;
+
+    pa_assert(c);
+
+    url = c->url;
+    c->state = STATE_OPTIONS;
+
+    c->url = (char *)"*";
+    rv = rtsp_exec(c, "OPTIONS", NULL, NULL, 0, NULL);
+
+    c->url = url;
+    return rv;
+}
+
+int pa_rtsp_announce(pa_rtsp_client *c, const char *sdp) {
+    int rv;
+
     pa_assert(c);
+
     if (!sdp)
         return -1;
 
     c->state = STATE_ANNOUNCE;
-    return rtsp_exec(c, "ANNOUNCE", "application/sdp", sdp, 1, NULL);
+    rv = rtsp_exec(c, "ANNOUNCE", "application/sdp", sdp, 1, NULL);
+
+    return rv;
 }
 
-int pa_rtsp_setup(pa_rtsp_client* c) {
-    pa_headerlist* headers;
+int pa_rtsp_setup(pa_rtsp_client *c, const char *transport) {
+    pa_headerlist *headers;
     int rv;
 
     pa_assert(c);
 
     headers = pa_headerlist_new();
-    pa_headerlist_puts(headers, "Transport", "RTP/AVP/TCP;unicast;interleaved=0-1;mode=record");
+    if (!transport)
+        pa_headerlist_puts(headers, "Transport", "RTP/AVP/TCP;unicast;interleaved=0-1;mode=record");
+    else
+        pa_headerlist_puts(headers, "Transport", transport);
 
     c->state = STATE_SETUP;
     rv = rtsp_exec(c, "SETUP", NULL, NULL, 1, headers);
+
     pa_headerlist_free(headers);
     return rv;
 }
 
-int pa_rtsp_record(pa_rtsp_client* c, uint16_t* seq, uint32_t* rtptime) {
-    pa_headerlist* headers;
-    int rv;
+int pa_rtsp_record(pa_rtsp_client *c, uint16_t *seq, uint32_t *rtptime) {
+    pa_headerlist *headers;
     char *info;
+    int rv;
 
     pa_assert(c);
+
     if (!c->session) {
         /* No session in progress */
         return -1;
     }
 
-    /* Todo: Generate these values randomly as per spec */
-    *seq = *rtptime = 0;
+    pa_random(seq, sizeof(*seq));
+    pa_random(rtptime, sizeof(*rtptime));
 
     headers = pa_headerlist_new();
     pa_headerlist_puts(headers, "Range", "npt=0-");
@@ -489,30 +522,40 @@ int pa_rtsp_record(pa_rtsp_client* c, uint16_t* seq, uint32_t* rtptime) {
 
     c->state = STATE_RECORD;
     rv = rtsp_exec(c, "RECORD", NULL, NULL, 1, headers);
+
     pa_headerlist_free(headers);
     return rv;
 }
 
 int pa_rtsp_teardown(pa_rtsp_client *c) {
+    int rv;
+
     pa_assert(c);
 
     c->state = STATE_TEARDOWN;
-    return rtsp_exec(c, "TEARDOWN", NULL, NULL, 0, NULL);
+    rv = rtsp_exec(c, "TEARDOWN", NULL, NULL, 0, NULL);
+
+    return rv;
 }
 
-int pa_rtsp_setparameter(pa_rtsp_client *c, const char* param) {
+int pa_rtsp_setparameter(pa_rtsp_client *c, const char *param) {
+    int rv;
+
     pa_assert(c);
+
     if (!param)
         return -1;
 
     c->state = STATE_SET_PARAMETER;
-    return rtsp_exec(c, "SET_PARAMETER", "text/parameters", param, 1, NULL);
+    rv = rtsp_exec(c, "SET_PARAMETER", "text/parameters", param, 1, NULL);
+
+    return rv;
 }
 
 int pa_rtsp_flush(pa_rtsp_client *c, uint16_t seq, uint32_t rtptime) {
     pa_headerlist* headers;
-    int rv;
     char *info;
+    int rv;
 
     pa_assert(c);
 
@@ -523,6 +566,7 @@ int pa_rtsp_flush(pa_rtsp_client *c, uint16_t seq, uint32_t rtptime) {
 
     c->state = STATE_FLUSH;
     rv = rtsp_exec(c, "FLUSH", NULL, NULL, 1, headers);
+
     pa_headerlist_free(headers);
     return rv;
 }
diff --git a/src/modules/rtp/rtsp_client.h b/src/modules/rtp/rtsp_client.h
index a56b932..ff51ed4 100644
--- a/src/modules/rtp/rtsp_client.h
+++ b/src/modules/rtp/rtsp_client.h
@@ -35,6 +35,7 @@
 typedef struct pa_rtsp_client pa_rtsp_client;
 typedef enum {
   STATE_CONNECT,
+  STATE_OPTIONS,
   STATE_ANNOUNCE,
   STATE_SETUP,
   STATE_RECORD,
@@ -43,29 +44,32 @@ typedef enum {
   STATE_SET_PARAMETER,
   STATE_DISCONNECTED
 } pa_rtsp_state;
-typedef void (*pa_rtsp_cb_t)(pa_rtsp_client *c, pa_rtsp_state state, pa_headerlist* hl, void *userdata);
+typedef void (*pa_rtsp_cb_t)(pa_rtsp_client *c, pa_rtsp_state state, pa_headerlist *hl, void *userdata);
 
-pa_rtsp_client* pa_rtsp_client_new(pa_mainloop_api *mainloop, const char* hostname, uint16_t port, const char* useragent);
-void pa_rtsp_client_free(pa_rtsp_client* c);
+pa_rtsp_client* pa_rtsp_client_new(pa_mainloop_api *mainloop, const char *hostname, uint16_t port, const char *useragent);
+void pa_rtsp_client_free(pa_rtsp_client *c);
 
-int pa_rtsp_connect(pa_rtsp_client* c);
+int pa_rtsp_connect(pa_rtsp_client *c);
 void pa_rtsp_set_callback(pa_rtsp_client *c, pa_rtsp_cb_t callback, void *userdata);
 
-void pa_rtsp_disconnect(pa_rtsp_client* c);
+void pa_rtsp_disconnect(pa_rtsp_client *c);
 
-const char* pa_rtsp_localip(pa_rtsp_client* c);
-uint32_t pa_rtsp_serverport(pa_rtsp_client* c);
-void pa_rtsp_set_url(pa_rtsp_client* c, const char* url);
-void pa_rtsp_add_header(pa_rtsp_client *c, const char* key, const char* value);
-void pa_rtsp_remove_header(pa_rtsp_client *c, const char* key);
+const char* pa_rtsp_localip(pa_rtsp_client *c);
+uint32_t pa_rtsp_serverport(pa_rtsp_client *c);
+void pa_rtsp_set_url(pa_rtsp_client *c, const char *url);
+void pa_rtsp_add_header(pa_rtsp_client *c, const char *key, const char *value);
+void pa_rtsp_remove_header(pa_rtsp_client *c, const char *key);
 
-int pa_rtsp_announce(pa_rtsp_client* c, const char* sdp);
+bool pa_rtsp_exec_ready(const pa_rtsp_client *c);
 
-int pa_rtsp_setup(pa_rtsp_client* c);
-int pa_rtsp_record(pa_rtsp_client* c, uint16_t* seq, uint32_t* rtptime);
-int pa_rtsp_teardown(pa_rtsp_client* c);
+int pa_rtsp_options(pa_rtsp_client *c);
+int pa_rtsp_announce(pa_rtsp_client *c, const char *sdp);
 
-int pa_rtsp_setparameter(pa_rtsp_client* c, const char* param);
-int pa_rtsp_flush(pa_rtsp_client* c, uint16_t seq, uint32_t rtptime);
+int pa_rtsp_setup(pa_rtsp_client *c, const char *transport);
+int pa_rtsp_record(pa_rtsp_client *c, uint16_t *seq, uint32_t *rtptime);
+int pa_rtsp_teardown(pa_rtsp_client *c);
+
+int pa_rtsp_setparameter(pa_rtsp_client *c, const char *param);
+int pa_rtsp_flush(pa_rtsp_client *c, uint16_t seq, uint32_t rtptime);
 
 #endif
diff --git a/src/pulsecore/core-util.c b/src/pulsecore/core-util.c
index e925918..854c918 100644
--- a/src/pulsecore/core-util.c
+++ b/src/pulsecore/core-util.c
@@ -2833,6 +2833,26 @@ bool pa_in_system_mode(void) {
     return !!atoi(e);
 }
 
+/* Checks a delimiters-separated list of words in haystack for needle */
+bool pa_str_in_list(const char *haystack, const char *delimiters, const char *needle) {
+    char *s;
+    const char *state = NULL;
+
+    if (!haystack || !needle)
+        return false;
+
+    while ((s = pa_split(haystack, delimiters, &state))) {
+        if (pa_streq(needle, s)) {
+            pa_xfree(s);
+            return true;
+        }
+
+        pa_xfree(s);
+    }
+
+    return false;
+}
+
 /* Checks a whitespace-separated list of words in haystack for needle */
 bool pa_str_in_list_spaces(const char *haystack, const char *needle) {
     char *s;
diff --git a/src/pulsecore/core-util.h b/src/pulsecore/core-util.h
index e117e9f..998df17 100644
--- a/src/pulsecore/core-util.h
+++ b/src/pulsecore/core-util.h
@@ -102,8 +102,8 @@ static inline const char *pa_strna(const char *x) {
     return x ? x : "n/a";
 }
 
-char *pa_split(const char *c, const char*delimiters, const char **state);
-const char *pa_split_in_place(const char *c, const char*delimiters, int *n, const char **state);
+char *pa_split(const char *c, const char *delimiters, const char **state);
+const char *pa_split_in_place(const char *c, const char *delimiters, int *n, const char **state);
 char *pa_split_spaces(const char *c, const char **state);
 
 char *pa_strip_nl(char *s);
@@ -217,6 +217,7 @@ static inline bool pa_safe_streq(const char *a, const char *b) {
 }
 
 bool pa_str_in_list_spaces(const char *needle, const char *haystack);
+bool pa_str_in_list(const char *haystack, const char *delimiters, const char *needle);
 
 char *pa_get_host_name_malloc(void);
 char *pa_get_user_name_malloc(void);
