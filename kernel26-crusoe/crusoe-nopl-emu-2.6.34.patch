diff -cr linux-2.6.34.orig/arch/x86/kernel/cpu/transmeta.c linux-2.6.34/arch/x86/kernel/cpu/transmeta.c
*** linux-2.6.34.orig/arch/x86/kernel/cpu/transmeta.c	2010-07-04 01:54:34.000000000 -0400
--- linux-2.6.34/arch/x86/kernel/cpu/transmeta.c	2010-07-04 02:15:52.000000000 -0400
***************
*** 96,101 ****
--- 96,103 ----
  	 */
  	randomize_va_space = 0;
  #endif
+ 	
+ 	boot_cpu_data.x86 = 6;
  }
  
  static const struct cpu_dev __cpuinitconst transmeta_cpu_dev = {
diff -cr linux-2.6.34.orig/arch/x86/kernel/entry_32.S linux-2.6.34/arch/x86/kernel/entry_32.S
*** linux-2.6.34.orig/arch/x86/kernel/entry_32.S	2010-07-04 01:54:35.000000000 -0400
--- linux-2.6.34/arch/x86/kernel/entry_32.S	2010-07-04 02:20:01.000000000 -0400
***************
*** 960,966 ****
  	RING0_INT_FRAME
  	pushl $0
  	CFI_ADJUST_CFA_OFFSET 4
! 	pushl $do_invalid_op
  	CFI_ADJUST_CFA_OFFSET 4
  	jmp error_code
  	CFI_ENDPROC
--- 960,966 ----
  	RING0_INT_FRAME
  	pushl $0
  	CFI_ADJUST_CFA_OFFSET 4
! 	pushl $do_nopl_emu
  	CFI_ADJUST_CFA_OFFSET 4
  	jmp error_code
  	CFI_ENDPROC
diff -cr linux-2.6.34.orig/arch/x86/kernel/Makefile linux-2.6.34/arch/x86/kernel/Makefile
*** linux-2.6.34.orig/arch/x86/kernel/Makefile	2010-07-04 01:54:34.000000000 -0400
--- linux-2.6.34/arch/x86/kernel/Makefile	2010-07-04 01:59:49.000000000 -0400
***************
*** 90,95 ****
--- 90,96 ----
  obj-$(CONFIG_APB_TIMER)		+= apb_timer.o
  
  obj-$(CONFIG_K8_NB)		+= k8.o
+ obj-$(CONFIG_MCRUSOE)		+= nopl_emu.o
  obj-$(CONFIG_DEBUG_RODATA_TEST)	+= test_rodata.o
  obj-$(CONFIG_DEBUG_NX_TEST)	+= test_nx.o
  
diff -cr linux-2.6.34.orig/arch/x86/Makefile_32.cpu linux-2.6.34/arch/x86/Makefile_32.cpu
*** linux-2.6.34.orig/arch/x86/Makefile_32.cpu	2010-07-04 01:54:34.000000000 -0400
--- linux-2.6.34/arch/x86/Makefile_32.cpu	2010-07-04 01:58:12.000000000 -0400
***************
*** 25,31 ****
  # They make zero difference whatsosever to performance at this time.
  cflags-$(CONFIG_MK7)		+= -march=athlon
  cflags-$(CONFIG_MK8)		+= $(call cc-option,-march=k8,-march=athlon)
! cflags-$(CONFIG_MCRUSOE)	+= -march=i686 $(align)-functions=0 $(align)-jumps=0 $(align)-loops=0
  cflags-$(CONFIG_MEFFICEON)	+= -march=i686 $(call tune,pentium3) $(align)-functions=0 $(align)-jumps=0 $(align)-loops=0
  cflags-$(CONFIG_MWINCHIPC6)	+= $(call cc-option,-march=winchip-c6,-march=i586)
  cflags-$(CONFIG_MWINCHIP3D)	+= $(call cc-option,-march=winchip2,-march=i586)
--- 25,31 ----
  # They make zero difference whatsosever to performance at this time.
  cflags-$(CONFIG_MK7)		+= -march=athlon
  cflags-$(CONFIG_MK8)		+= $(call cc-option,-march=k8,-march=athlon)
! cflags-$(CONFIG_MCRUSOE)	+= -march=i686
  cflags-$(CONFIG_MEFFICEON)	+= -march=i686 $(call tune,pentium3) $(align)-functions=0 $(align)-jumps=0 $(align)-loops=0
  cflags-$(CONFIG_MWINCHIPC6)	+= $(call cc-option,-march=winchip-c6,-march=i586)
  cflags-$(CONFIG_MWINCHIP3D)	+= $(call cc-option,-march=winchip2,-march=i586)
*** /dev/null	2010-07-01 00:53:52.350721259 -0400
--- linux-2.6.34/arch/x86/kernel/nopl_emu.c	2010-07-04 02:29:10.000000000 -0400
***************
*** 0 ****
--- 1,124 ----
+ /*
+  *  linux/arch/x86/kernel/nopl_emu.c
+  *
+  *  Copyright (C) 2002  Willy Tarreau
+  *  Copyright (C) 2010  Matteo Croce
+  */
+ 
+ #include <asm/processor.h>
+ #include <asm/traps.h>
+ 
+ /* This code can be used to allow the AMD Geode to hopefully correctly execute
+  * some code which was originally compiled for an i686, by emulating NOPL,
+  * the only missing i686 instruction in the CPU
+  *
+  * Willy Tarreau <willy@meta-x.org>
+  * Matteo Croce <technoboy85@gmail.com>
+  *
+  * This patch is being used in kernel26-crusoe in the Arch Linux AUR for the 
+  * Transmeta Crusoe CPU for it has the same problem.  I appreciate all the work 
+  * you have done in this you guys, you are truly talented!
+  *
+  * Max Pray a.k.a. Synthead <synthead@gmail.com>
+  */
+ 
+ static inline int do_1f(u8 *ip)
+ {
+        int length = 3;
+        switch (*ip) {
+        case 0x84:
+                if (!ip[5])
+                        length++;
+                else
+                        return 0;
+        case 0x80:
+                if (!ip[4] && !ip[3])
+                        length += 2;
+                else
+                        return 0;
+        case 0x44:
+                if (!ip[2])
+                        length++;
+                else
+                        return 0;
+        case 0x40:
+                if (!ip[1])
+                        length++;
+                else
+                        return 0;
+        case 0x00:
+                return length;
+        }
+        return 0;
+ }
+ 
+ static inline int do_0f(u8 *ip)
+ {
+        if (*ip == 0x1f)
+                return do_1f(ip + 1);
+        return 0;
+ }
+ 
+ static inline int do_66(u8 *ip)
+ {
+        if (*ip == 0x90)
+                return 2;
+        if (*ip == 0x0f) {
+                int res = do_0f(ip + 1);
+                if (res)
+                        return res + 1;
+                else
+                        return 0;
+        }
+        return 0;
+ }
+ 
+ static inline int do_start(u8 *ip)
+ {
+        if (*ip == 0x0f)
+                return do_0f(ip + 1);
+        if (*ip == 0x66)
+                return do_66(ip + 1);
+        return 0;
+ }
+ 
+ /* [do_nopl_emu] is called by exception 6 after an invalid opcode has been
+  * encountered. It will try to emulate it by doing nothing,
+  * and will send a SIGILL or SIGSEGV to the process if not possible.
+  * the NOPL can have variable length opcodes:
+ 
+ bytes number   opcode
+        2       66 90
+        3       0f 1f 00
+        4       0f 1f 40 00
+        5       0f 1f 44 00 00
+        6       66 0f 1f 44 00 00
+        7       0f 1f 80 00 00 00 00
+        8       0f 1f 84 00 00 00 00 00
+        9       66 0f 1f 84 00 00 00 00 00
+ */
+ void do_nopl_emu(struct pt_regs *regs, long error_code)
+ {
+        u8 *ip = (u8 *)instruction_pointer(regs);
+        int res = do_start(ip);
+ 
+        if (res) {
+                int i = 0;
+                do {
+                        ip += res;
+                        i++;
+                        res = do_start(ip);
+                } while(res);
+                regs->ip = (typeof(regs->ip))ip;
+        } else
+                do_invalid_op(regs, error_code);
+ }
+ 
+ /* The above was commented out because of this note:
+  *
+  * While syslog-ng has got a heavy cpu load an put more than 100 times per 
+  * seconds nopl notification in everything.log, kernel.log and messages.log,
+  * i removed the output (line 185) in the patch and everything is cool.
+  *
+  * http://notes.osuv.de/doku.php?id=geode#kernel_config
+  */
