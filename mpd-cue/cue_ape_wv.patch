diff -dNaur mpd-0.13.2/AUTHORS mpd-0.13.2.2/AUTHORS
--- mpd-0.13.2/AUTHORS	2007-05-27 02:12:11.000000000 +1100
+++ mpd-0.13.2.2/AUTHORS	2008-06-18 00:36:34.000000000 +1100
@@ -24,6 +24,9 @@
 Patrik Weiskircher <pat@icore.at>
 	Stored playlist commands
 
+A. Leo. <mb005z@yahoo.com>
+    Cue-sheets; ffmpeg/ape, wavpack plugins
+
 Former Developers
 -----------------
 tw-nym
diff -dNaur mpd-0.13.2/config.h.in mpd-0.13.2.2/config.h.in
--- mpd-0.13.2/config.h.in	2008-06-17 16:46:19.000000000 +1100
+++ mpd-0.13.2.2/config.h.in	2008-06-18 00:40:01.000000000 +1100
@@ -37,6 +37,9 @@
 /* Define if FAAD2 uses buflen in function calls */
 #undef HAVE_FAAD_BUFLEN_FUNCS
 
+/* Define to enable ffmpeg */
+#undef HAVE_FFMPEG
+
 /* Define for FLAC support */
 #undef HAVE_FLAC
 
@@ -145,9 +148,16 @@
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* Define to enable wavpack */
+#undef HAVE_WAVPACK
+
 /* Define to enable Zeroconf support */
 #undef HAVE_ZEROCONF
 
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
 /* Define to 1 if your C compiler doesn't accept -c and -o together. */
 #undef NO_MINUS_C_MINUS_O
 
@@ -190,6 +200,10 @@
 /* Version number of package */
 #undef VERSION
 
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-#undef WORDS_BIGENDIAN
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel and VAX). */
+#if defined __BIG_ENDIAN__
+# define WORDS_BIGENDIAN 1
+#elif ! defined __LITTLE_ENDIAN__
+# undef WORDS_BIGENDIAN
+#endif
diff -dNaur mpd-0.13.2/configure.ac mpd-0.13.2.2/configure.ac
--- mpd-0.13.2/configure.ac	2008-06-17 16:39:38.000000000 +1100
+++ mpd-0.13.2.2/configure.ac	2008-06-18 00:39:24.000000000 +1100
@@ -80,6 +80,10 @@
 AC_ARG_ENABLE(mpc,[  --disable-mpc           disable musepack (MPC) support (default: enable)],[enable_mpc=$enableval],[enable_mpc=yes])
 AC_ARG_ENABLE(id3,[  --disable-id3           disable id3 support (default: enable)],[enable_id3=$enableval],[enable_id3=yes])
 AC_ARG_ENABLE(lsr,[  --disable-lsr           disable libsamplerate support (default: enable)],[enable_lsr=$enableval],[enable_lsr=yes])
+AC_ARG_ENABLE(wavpack,[  --disable-wavpack   disable libwavpack support (default: enable)],[enable_wavpack=$enableval],[enable_wavpack=yes])
+AC_ARG_ENABLE(ffmpeg,[  --disable-ffmpeg     disable ffmpeg support (default: enable)],[enable_ffmpeg=$enableval],[enable_ffmpeg=yes])
+
+
 
 AC_ARG_WITH(tremor,[[  --with-tremor[=PFX]         Use Tremor(vorbisidec) integer Ogg-Vorbis decoder (with optional prefix)]], use_tremor=yes; test x$withval != xyes && tremor_prefix="$withval",)
 AC_ARG_WITH(tremor-libraries,[  --with-tremor-libraries=DIR Directory where Tremor library is installed (optional)], tremor_libraries="$withval", tremor_libraries="")
@@ -178,7 +182,7 @@
 fi
 
 if test x$enable_pulse = xyes || test x$enable_jack = xyes ||
-   test x$enable_lsr = xyes || test x$with_zeroconf != xno; then
+   test x$enable_lsr = xyes || test x$with_zeroconf != xno || x$enable_ffmpeg == xyes || x$enable_wavpack == xyes; then
 	PKG_PROG_PKG_CONFIG
 fi
 
@@ -541,6 +545,21 @@
 fi
 
 
+if test "$enable_ffmpeg" = "yes" ; then
+    # I'm not sure about the version
+	PKG_CHECK_MODULES([FFMPEG], [libavformat >= 51.0.0, libavcodec >= 51.0.0 ],
+                  [enable_ffmpeg=yes;AC_DEFINE([HAVE_FFMPEG], 1, [Define to enable ffmpeg])] MPD_LIBS="$MPD_LIBS $FFMPEG_LIBS" MPD_CFLAGS="$MPD_CFLAGS $FFMPEG_CFLAGS",
+	                  [enable_ffmpeg=no;AC_MSG_WARN([ffmpeg not found -- disabling])])
+    fi
+
+
+if test "$enable_wavpack" = "yes" ; then
+    # I mont sure about the version
+	PKG_CHECK_MODULES([WAVPACK], [wavpack >= 4.20.0],
+	                  [enable_wavpack=yes;AC_DEFINE([HAVE_WAVPACK], 1, [Define to enable wavpack])] MPD_LIBS="$MPD_LIBS $WAVPACK_LIBS" MPD_CFLAGS="$MPD_CFLAGS $WAVPACK_CFLAGS",
+	                  [enable_wavpack=no;AC_MSG_WARN([wavpack not found -- disabling])])
+fi
+
 if test x$enable_flac = xyes; then
 	AC_DEFINE(HAVE_FLAC,1,[Define for FLAC support])
 fi
@@ -549,7 +568,7 @@
 if test x$enable_oggflac = xyes; then
 	oldmpdcflags="$MPD_CFLAGS"
 	oldmpdlibs="$MPD_LIBS"
-	AM_PATH_LIBOGGFLAC(MPD_LIBS="$MPD_LIBS $LIBOGGFLAC_LIBS" MPD_CFLAGS="$MPD_CFLAGS $LIBOGGFLAC_CFLAGS",enable_oggflac=no)
+	#AM_PATH_LIBOGGFLAC(MPD_LIBS="$MPD_LIBS $LIBOGGFLAC_LIBS" MPD_CFLAGS="$MPD_CFLAGS $LIBOGGFLAC_CFLAGS",enable_oggflac=no)
 fi
 
 if test x$enable_oggflac = xyes; then
@@ -753,6 +772,18 @@
 	echo " MOD support ...................disabled"
 fi
 
+if test x$enable_wavpack = xyes; then
+    echo " WAVPACK support ...............enabled"
+else
+    echo " WAVPACK support ...............disabled"
+fi
+
+if test x$enable_ffmpeg = xyes; then
+    echo " ffmpeg/ape support ............enabled"
+else
+    echo " ffmpeg/ape support ............disabled"
+fi
+
 if
 	test x$enable_mp3 = xno &&
 	test x$enable_oggvorbis = xno &&
diff -dNaur mpd-0.13.2/src/Makefile.am mpd-0.13.2.2/src/Makefile.am
--- mpd-0.13.2/src/Makefile.am	2007-05-28 23:42:44.000000000 +1100
+++ mpd-0.13.2.2/src/Makefile.am	2008-06-18 00:30:45.000000000 +1100
@@ -22,7 +22,9 @@
 	inputPlugins/mod_plugin.c \
 	inputPlugins/mp3_plugin.c \
 	inputPlugins/mp4_plugin.c \
-	inputPlugins/mpc_plugin.c
+	inputPlugins/mpc_plugin.c \
+	inputPlugins/wv_plugin.c \
+	inputPlugins/ffmpeg_plugin.c
 
 
 mpd_headers = \
@@ -76,7 +78,8 @@
 	ioops.h \
 	zeroconf.h \
 	locate.h \
-	storedPlaylist.h
+	storedPlaylist.h \
+	cue.h
 
 
 mpd_SOURCES = \
@@ -128,7 +131,8 @@
 	utf8.c \
 	zeroconf.c \
 	locate.c \
-	storedPlaylist.c
+	storedPlaylist.c \
+	cue.c
 
 
 mpd_CFLAGS = $(MPD_CFLAGS)
diff -dNaur mpd-0.13.2/src/cue.c mpd-0.13.2.2/src/cue.c
--- mpd-0.13.2/src/cue.c	1970-01-01 10:00:00.000000000 +1000
+++ mpd-0.13.2.2/src/cue.c	2008-06-17 23:28:04.000000000 +1100
@@ -0,0 +1,471 @@
+/*
+ * Copyright (C) 2008 A.Leo <mb005z@yahoo.com>
+ * parser for a "cue-like" files.
+ * (Well, I wasn't feeling lucky (C) google during searching for a cue-docs.
+ * So I've opened some cue's and just tryed to guess)
+ */
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "cue.h"
+
+#define CUE_DELIMS " \t"
+
+
+/*
+ * FIXME: rewrite this
+ * ( error handling,
+ *   time hadling,
+ *   cue-format, .. )
+ */
+
+#define LOG(a...) /* empty */
+
+
+static char
+is_delim_(char c, const char* delim)
+{
+    while(*delim)
+        if( c == *delim++)
+            return 1;
+    return 0;
+}
+
+
+/* BROKEN */
+static char*
+cue_get_quoted_word_(char* str, char* delim, char* out_word, int* pos, int out_size)
+{
+    char q;
+    char* res = out_word;
+    int escape = 0;
+
+    while(*str && is_delim_(*str, delim))
+        ++str, ++(*pos);
+
+    if(*str == 0)
+    {
+        *res = 0;
+        return 0;
+    }
+
+    if(*str == '\"' || *str == '`' || *str == '\'')
+    {
+        q = *str++;
+
+        while(*str &&  (*str != (escape ? 0 : q) )  && --out_size > 0 )
+        {
+            *out_word = *str;
+            if(escape)
+            {
+                switch(*str)
+                {
+                    case 'n':
+                        *out_word = '\n';
+                        break;
+                    case 'r':
+                        *out_word = '\r';
+                        break;
+                    case 't':
+                        *out_word = '\t';
+                        break;
+                }
+                escape = 0;
+            }
+
+            /* XXX */
+            if(*out_word == '\\')
+                escape = 1;
+            else
+                ++out_word;
+            ++str;
+        }
+    }
+    else
+    {
+        while(*str && ++(*pos) && --out_size > 0 && !is_delim_(*str, delim))
+            *out_word++ = *str++;
+    }
+    return res;
+}
+
+
+static char*
+cue_get_quoted_word(char* str, char* out_word, int* pos, int out_size)
+{
+    return cue_get_quoted_word_(str, CUE_DELIMS, out_word, pos, out_size);
+}
+
+/* this modifies str */
+static char*
+cue_get_word_(char* str, const char* delim, int* pos)
+{
+    int p = *pos;
+    char* start;
+
+    str = str + p;
+
+    while(*str && is_delim_(*str, delim))
+        ++str,++p;
+    
+    start = str;
+
+    while(*str && ++p && !is_delim_(*str, delim))
+        ++str;
+
+    if(!*str)
+        return 0;
+
+    *str = 0;
+    *pos = p;
+
+    return start;
+}
+
+static char*
+cue_get_word(char* str, int* pos)
+{
+    return cue_get_word_(str, CUE_DELIMS, pos);
+}
+
+static char*
+cue_dequote_word(char* inword)
+{
+    static char res[1024];
+    int n;
+
+    n = 0;
+    memset(res, 0, sizeof(res));
+    if( cue_get_quoted_word(inword, res, &n, sizeof(res) - 1) )
+        return res;
+    else
+        return "ERROR";
+}
+
+static void
+cue_cpyline_(const char* in, char* out, int n)
+{
+    while(*in && --n > 0)
+    {
+        *out = *in;
+
+        if(*out == '\n')
+        {
+            *out = 0;
+            break;
+        }
+        ++out;
+        ++in;
+    }
+    *out = 0;
+}
+
+
+
+static int
+cue_parse_track_time(const char* t)
+{
+    int a, b, c;
+    char sa[32], sb[32], sc[32];
+
+    if( 3 != sscanf(t, "%31[0-9]:%31[0-9]:%31[0-9]", sa, sb, sc) )
+        return -1;
+
+    a = strtol(sa, NULL, 10);
+    b = strtol(sb, NULL, 10);
+    c = strtol(sc, NULL, 10);
+
+    int r = a*60*1000 + b*1000 + c*1000/75;
+
+    return r;
+}
+
+static cue_track_t*
+new_cue_track(void)
+{
+    return (void*)calloc(1, sizeof(cue_track_t));
+}
+
+
+static void
+cue_free(char** item)
+{
+    if(*item)
+    {
+        free(*item);
+        *item = 0;
+    }
+}
+
+
+void
+cue_free_track(cue_track_t* cue)
+{
+    cue_free(&cue->desc.title);
+    cue_free(&cue->desc.performer);
+    cue_free(&cue->desc.genre);
+    cue_free(&cue->desc.date);
+    cue_free(&cue->desc.discid);
+    cue_free(&cue->desc.comment);
+    cue_free(&cue->desc.file);
+    cue_free(&cue->desc.album);
+    cue_free(&cue->desc.track);
+    cue_free(&cue->desc.catalog);
+    free(cue);
+}
+
+
+cue_track_t*
+cue_new_track(cue_desc_t* base)
+{
+    cue_track_t* res = (cue_track_t*)calloc(1, sizeof(*res));
+#define cue_new_track_copy_field(f) \
+    if(base->f) res->desc.f = strdup(base->f);
+#if 1    
+    cue_new_track_copy_field(title)
+    cue_new_track_copy_field(performer)
+    cue_new_track_copy_field(genre)
+    cue_new_track_copy_field(date)
+    cue_new_track_copy_field(discid)
+    cue_new_track_copy_field(comment)
+    cue_new_track_copy_field(album)
+    cue_new_track_copy_field(file)
+    cue_new_track_copy_field(track)
+    cue_new_track_copy_field(catalog)
+#endif
+#undef cue_new_track_copy_field
+    return res;
+}
+
+
+cue_track_t**
+cue_parse_from_string(const char* lines, int* n)
+{
+    int mx = 32;
+    int curr_track_n = 0;
+    int pos;
+    int len;
+    char b[4096];
+    int in_global_space = 1;
+
+    cue_track_t* base = new_cue_track();;
+    cue_track_t* curr_track = base;
+
+    cue_track_t** res = (cue_track_t**)calloc(mx, sizeof(*res));
+
+    pos = 0;
+    len = strlen(lines);
+
+    while( pos < len )
+    {
+        int local_pos;
+        char* kw;
+        char* val;
+        char v[1024] = {0};
+
+        local_pos = 0;
+        cue_cpyline_(lines + pos, b, sizeof(b) - 1);
+        pos += strlen(b) + 1;
+
+        kw = cue_get_word(b, &local_pos);
+
+        if( !kw )
+            continue;
+
+        /* leading/trailing spaces */
+        val = local_pos + b;
+        strncpy(v, val, sizeof(val)-1);
+
+        if(!strcmp("FILE", kw))
+        {
+            cue_free(&curr_track->desc.file);
+            curr_track->desc.file = strdup(cue_get_quoted_word(val, v, &local_pos, sizeof(v) - 1 ));
+            continue;
+        }
+        else if(!strcmp("CATALOG", kw))
+        {
+            cue_free(&curr_track->desc.catalog);
+            curr_track->desc.catalog = strdup(cue_dequote_word(val));
+            continue;
+        }
+        else if(!strcmp("PERFORMER", kw))
+        {
+            cue_free(&curr_track->desc.performer);
+            curr_track->desc.performer = strdup(cue_dequote_word(val));
+            continue;
+        }
+        else if(!strcmp("TITLE", kw))
+        {
+            if(in_global_space)
+            {
+                cue_free(&curr_track->desc.album);
+                curr_track->desc.album = strdup(cue_dequote_word(val));
+            }
+            else
+            {
+                cue_free(&curr_track->desc.title);
+                curr_track->desc.title = strdup(cue_dequote_word(val));
+            }
+            continue;
+        }
+        else if(!strcmp("TRACK", kw))
+        {
+            char* track_num;
+
+            in_global_space = 0;
+
+            track_num = cue_get_word(b, &local_pos);
+
+            if(!track_num || strcmp((local_pos + b), "AUDIO"))
+            {
+                LOG("dunno what to do with %s track type\n", local_pos + b);
+                continue;
+            }
+
+            if( curr_track_n >= mx-2 )
+                res = (cue_track_t**)realloc(res, (mx*=2) * sizeof(*res));
+
+            curr_track = res[curr_track_n++] = cue_new_track(&curr_track->desc);
+            curr_track->desc.track = strdup(track_num);
+
+            continue;
+        }
+        else if(!strcmp("INDEX", kw))
+        {
+            char* id;
+            int idx_time;
+
+            if(in_global_space)
+            {
+                LOG( "misplaced index keyword\n");
+                continue;
+            }
+
+            id = cue_get_word(b, &local_pos);
+
+            if(!id)
+                continue;
+
+            idx_time = cue_parse_track_time(b + local_pos);
+
+            if(idx_time == -1 )
+                continue;
+
+            if(!strcmp("01", id))
+            {
+                curr_track->start_time =
+                    curr_track->index_1 = idx_time;
+
+                if(curr_track_n > 1 )
+                    res[curr_track_n-2]->end_time = idx_time;
+
+                continue;
+            }
+            else if(!strcmp("00", id))
+            {
+
+                curr_track->index_0 = idx_time;
+                continue;
+            }
+            else LOG( "uknown index: %s\n", id);
+        }
+        else if(!strcmp(kw, "REM"))
+        {
+            char* type;
+            char* val;
+
+            type = cue_get_word(b, &local_pos);
+
+            if(! type)
+                continue; 
+
+            /* fixme: skip leading spaces */
+            val = local_pos + b;
+
+            if(!strcmp("COMMENT", type))
+            {
+                cue_free(&curr_track->desc.comment);
+                curr_track->desc.comment = strdup(val);
+            }
+            else if(!strcmp("GENRE", type))
+            {
+                cue_free(&curr_track->desc.genre);
+                curr_track->desc.genre = strdup(val);
+            }
+            else if(!strcmp("DISCID", type))
+            {
+                cue_free(&curr_track->desc.discid);
+                curr_track->desc.discid = strdup(val);
+            }
+            else if(!strcmp("DATE", type))  
+            {
+                cue_free(&curr_track->desc.date);
+                curr_track->desc.date = strdup(val);
+            }
+            else LOG("unknown rem type %s:%s\n", type, val);
+        } else LOG("unknown field %s\n", kw);
+    }
+
+    cue_free_track(base);
+    *n = curr_track_n;
+    return res;
+}
+
+
+/* XXX ugly */
+cue_track_t**
+cue_parse_from_file(const char* file_name, int* n)
+{
+    int sz = 120000;
+    char* b = calloc(sz, sizeof(*b));
+    int i, j, r;
+    cue_track_t** res;
+
+    int fd = open(file_name, O_RDONLY);
+
+    if( fd == -1 )
+    {
+        perror("open");
+        free(b);
+        return 0;
+    }
+
+    r = read(fd, b, sz);
+
+    if( r == -1 )
+    {
+        perror("read");
+        close(fd);
+        free(b);
+        return 0;
+    }
+    close(fd);
+
+    for( j = i = 0; i < r; i++ )
+    {
+        if(b[i] != '\r')
+            b[j++] = b[i];
+    }
+
+    res = cue_parse_from_string(b, n);
+
+    free(b);
+
+    return res;
+}
+
+
+void
+cue_free_tracks(cue_track_t** tracks, int num)
+{
+    int i;
+
+    for(i = 0; i < num; i++ )
+        cue_free_track(tracks[i]);
+
+    free(tracks);
+}
+
diff -dNaur mpd-0.13.2/src/cue.h mpd-0.13.2.2/src/cue.h
--- mpd-0.13.2/src/cue.h	1970-01-01 10:00:00.000000000 +1000
+++ mpd-0.13.2.2/src/cue.h	2008-06-17 22:30:43.000000000 +1100
@@ -0,0 +1,37 @@
+#ifndef CUE_H_
+#define CUE_H_ 1
+
+typedef struct cue_desc
+{
+    char *performer;
+    char *title;
+    char *track;
+    char *genre;
+    char *date;
+    char *discid;
+    char *comment;
+    char *album;
+    char *file;
+    char *catalog;
+} cue_desc_t;
+
+typedef struct cue_track
+{
+    /* cue_desc_t global_desc; */
+    cue_desc_t desc;
+    int index_0;
+    int index_1;
+    int start_time;
+    int end_time;
+} cue_track_t;
+
+
+void cue_free_track (cue_track_t * cue);
+cue_track_t *cue_new_track (cue_desc_t * base);
+cue_track_t **cue_parse_from_string (const char *lines, int *n);
+cue_track_t **cue_parse_from_file(const char *lines, int *n);
+void cue_free_tracks (cue_track_t ** tracks, int num);
+
+
+
+#endif
diff -dNaur mpd-0.13.2/src/decode.c mpd-0.13.2.2/src/decode.c
--- mpd-0.13.2/src/decode.c	2008-01-27 08:16:46.000000000 +1000
+++ mpd-0.13.2.2/src/decode.c	2008-06-18 00:31:48.000000000 +1100
@@ -66,6 +66,68 @@
 	}
 }
 
+static void fetchUrlRangeInfo(DecoderControl* dc, PlayerControl* pc)
+{   
+    const char* s;
+    int startms = -1,
+        stopms = -1,
+        rangems = 0;
+
+    s = url_get_param(pc->utf8url, "startms");
+
+    if( s )
+        startms = atoi(s);
+
+    s = url_get_param(pc->utf8url, "stopms");
+
+    if( s )
+        stopms = atoi(s); 
+
+    if( startms != -1 && stopms != -1 && startms < stopms  )
+    {
+        rangems = stopms - startms;
+        dc->rangems = rangems;
+        dc->stopms = stopms;
+        dc->startms = startms;
+        dc->totalTime = rangems/1000.f;
+    }
+    else
+    {
+        dc->startms = stopms = -1;
+        dc->rangems = 0;
+    }
+}
+
+static void advanceTime( DecoderControl* dc, PlayerControl* pc)
+{
+    fetchUrlRangeInfo(dc, pc);
+
+    if(dc->rangems > 0 )
+        pc->fileTime = pc->totalTime = dc->rangems/1000.f;
+
+}
+
+
+static void  checkUrlForRange( DecoderControl* dc,
+        PlayerControl* pc)
+{
+    advanceTime(dc, pc);
+
+    if(pc->seek)
+    {
+        dc->seek = 1;
+        dc->seekWhere = pc->seekWhere + dc->startms/1000.f;
+        pc->elapsedTime = pc->seekWhere;
+        pc->seek = 0;
+    }
+    else if(!dc->seek)
+    {
+        dc->seek = 1;
+        dc->seekWhere = dc->startms/1000.f;
+        pc->elapsedTime = 0;
+    }
+}
+
 static void stopDecode(DecoderControl * dc)
 {
 	if (decode_pid > 0 && (dc->start || dc->state != DECODE_STATE_STOP)) {
@@ -191,6 +253,16 @@
 			*next = -1;
 			dc->seekWhere = pc->seekWhere > pc->totalTime - 0.1 ?
 			    pc->totalTime - 0.1 : pc->seekWhere;
+            {
+                if( dc->rangems > 0 )
+                {
+                    if( pc->seekWhere > dc->rangems/1000.f - 0.1 )
+                        pc->seekWhere = dc->rangems/1000.f - 0.1;
+
+                    dc->seekWhere = pc->seekWhere + dc->startms/1000.f;
+                }
+            }
+
 			dc->seekWhere = 0 > dc->seekWhere ? 0 : dc->seekWhere;
 			dc->seekError = 0;
 			dc->seek = 1;
@@ -198,6 +270,8 @@
 				my_usleep(10000);
 			if (!dc->seekError) {
 				pc->elapsedTime = dc->seekWhere;
+                if(dc->rangems > 0 )
+                    pc->elapsedTime -= dc->startms/1000.f;
 				ret = 0;
 			}
 		}
@@ -265,7 +339,7 @@
 	if (isRemoteUrl(pc->utf8url))
 		path = utf8StrToLatin1Dup(pc->utf8url);
 	else
-		path = xstrdup(rmp2amp(utf8ToFsCharset(pc->utf8url)));
+		path = xstrdup(rmp2amp(utf8ToFsCharset(url_filename(pc->utf8url))));
 
 	if (!path) {
 		dc->error = DECODE_ERROR_FILE;
@@ -274,6 +348,8 @@
 		return;
 	}
 
+    checkUrlForRange(dc, pc);
+
 	copyMpdTagToOutputBuffer(cb, NULL);
 
 	pathcpy_trunc(dc->utf8url, pc->utf8url);
@@ -605,6 +681,17 @@
 				}
 			}
 			pc->elapsedTime = cb->times[cb->begin];
+            if ( dc->rangems > 0)
+            {
+                pc->elapsedTime -= dc->startms/1000.f;
+                pc->totalTime = pc->fileTime = dc->rangems/1000.f;
+#if 0
+                if(cb->times[cb->begin] > dc->stopms )
+                    dc->state = DECODE_STATE_STOP;
+#endif
+            }
+            if(dc->rangems > 0 && dc->stopms >= cb->times[cb->begin] )
+                ;
 			pc->bitRate = cb->bitRate[cb->begin];
 			pcm_volumeChange(cb->chunks + cb->begin *
 					 CHUNK_SIZE,
diff -dNaur mpd-0.13.2/src/decode.h mpd-0.13.2.2/src/decode.h
--- mpd-0.13.2/src/decode.h	2007-04-05 14:22:33.000000000 +1100
+++ mpd-0.13.2.2/src/decode.h	2008-06-18 00:31:57.000000000 +1100
@@ -50,6 +50,9 @@
 typedef struct _DecoderControl {
 	volatile mpd_sint8 state;
 	volatile mpd_sint8 stop;
+    volatile int stopms;
+    volatile int startms;
+    volatile int rangems;
 	volatile mpd_sint8 start;
 	volatile mpd_uint16 error;
 	volatile mpd_sint8 seek;
diff -dNaur mpd-0.13.2/src/directory.c mpd-0.13.2.2/src/directory.c
--- mpd-0.13.2/src/directory.c	2008-01-27 08:16:46.000000000 +1000
+++ mpd-0.13.2.2/src/directory.c	2008-06-18 00:32:38.000000000 +1100
@@ -35,6 +35,7 @@
 #include "tagTracker.h"
 #include "utils.h"
 #include "volume.h"
+#include "cue.h"
 
 #include <sys/wait.h>
 #include <dirent.h>
@@ -784,6 +785,94 @@
 	return 1;
 }
 
+static int isCueSheet(const char* name)
+{
+    const char* s = getSuffix(name);
+
+    return s && !strcasecmp(s, "cue");
+
+}
+
+static void syncMpdTag(MpdTag* out, cue_track_t* in)
+{
+	if(in->desc.performer) addItemToMpdTag(out, TAG_ITEM_ARTIST, strdup(in->desc.performer));
+	if(in->desc.title) addItemToMpdTag(out, TAG_ITEM_TITLE, strdup(in->desc.title));
+	if(in->desc.genre) addItemToMpdTag(out, TAG_ITEM_GENRE, strdup(in->desc.genre));
+	if(in->desc.date) addItemToMpdTag(out, TAG_ITEM_DATE, strdup(in->desc.date)); 
+	if(in->desc.album) addItemToMpdTag(out, TAG_ITEM_ALBUM, strdup(in->desc.album));
+	if(in->desc.comment) addItemToMpdTag(out, TAG_ITEM_COMMENT, strdup(in->desc.comment));
+	if(in->desc.track) addItemToMpdTag(out, TAG_ITEM_TRACK, strdup(in->desc.track));
+}
+
+static char*
+abs_path(char* name)
+{
+	char *abs_path_ = rmp2amp(utf8ToFsCharset(name));
+
+	return strdup(abs_path_);
+}
+
+static int addCueToDirectory(Directory * directory, char *shortname, char *name)
+{
+    int n;
+    int i;
+    /* XXX: */
+    char new_sn[10000];
+    char new_n[10000];
+    cue_track_t** tr;
+
+    tr = cue_parse_from_file(abs_path(name), &n);
+
+    if(!tr || n <= 0)
+        return -1;
+
+    for( i = 0; i < n; i++ ) {
+        char app[128];
+
+        if(!tr[i]->desc.file)
+            continue;
+
+        strcpy(new_sn, tr[i]->desc.file);
+        strcpy(new_n, directory->path);
+        strcat(new_n, "/");
+        strcat(new_n, tr[i]->desc.file);
+
+        if ( tr[i]->end_time == 0 )
+        {
+            Song* s = newSong(new_sn, SONG_TYPE_FILE, directory);
+
+            if(s)
+            {
+                tr[i]->end_time = s->tag->time*1000;
+                freeJustSong(s);
+            } 
+            else
+                tr[i]->end_time = 1000*1000*1000;
+        }
+
+        snprintf(app, sizeof(app) - 1, "?startms=%i&stopms=%i", tr[i]->start_time, tr[i]->end_time);
+
+        strcat(new_sn, app);
+        strcat(new_n, app);
+
+        Song* song = addSongToList(directory->songs, new_sn, new_n,
+                SONG_TYPE_FILE, directory);
+        if( song )
+        {
+#if 1
+            freeMpdTag(song->tag);
+            song->tag = newMpdTag();
+#endif
+            syncMpdTag(song->tag, tr[i]);
+            song->tag->time = tr[i]->end_time - tr[i]->start_time;
+            song->tag->time /= 1000.;
+        }
+    }
+    if(tr) cue_free_tracks(tr, n);
+
+    return 0;
+}
+
 static int addToDirectory(Directory * directory, char *shortname, char *name)
 {
 	struct stat st;
@@ -793,7 +882,11 @@
 		return -1;
 	}
 
-	if (S_ISREG(st.st_mode) && hasMusicSuffix(name, 0)) {
+    if (S_ISREG(st.st_mode))
+    {
+        if( isCueSheet(name) ) 
+            addCueToDirectory(directory, shortname, name);
+        else if( hasMusicSuffix(name, 0)) {
 		Song *song;
 		song = addSongToList(directory->songs, shortname, name,
 				     SONG_TYPE_FILE, directory);
@@ -801,6 +894,7 @@
 			return -1;
 		LOG("added %s\n", name);
 		return 1;
+        }
 	} else if (S_ISDIR(st.st_mode)) {
 		return addSubDirectoryToDirectory(directory, shortname, name,
 						  &st);
diff -dNaur mpd-0.13.2/src/inputPlugin.c mpd-0.13.2.2/src/inputPlugin.c
--- mpd-0.13.2/src/inputPlugin.c	2007-04-05 14:22:33.000000000 +1100
+++ mpd-0.13.2.2/src/inputPlugin.c	2008-06-18 00:32:49.000000000 +1100
@@ -150,6 +150,8 @@
 	loadInputPlugin(&mp4Plugin);
 	loadInputPlugin(&mpcPlugin);
 	loadInputPlugin(&modPlugin);
+	loadInputPlugin(&ffmpegPlugin);
+	loadInputPlugin(&wvPlugin);
 }
 
 void finishInputPlugins(void)
diff -dNaur mpd-0.13.2/src/inputPlugin.h mpd-0.13.2.2/src/inputPlugin.h
--- mpd-0.13.2/src/inputPlugin.h	2007-04-05 14:22:33.000000000 +1100
+++ mpd-0.13.2.2/src/inputPlugin.h	2008-06-18 00:32:59.000000000 +1100
@@ -105,5 +105,7 @@
 extern InputPlugin mpcPlugin;
 extern InputPlugin aacPlugin;
 extern InputPlugin modPlugin;
+extern InputPlugin ffmpegPlugin;
+extern InputPlugin wvPlugin;
 
 #endif
diff -dNaur mpd-0.13.2/src/inputPlugins/ffmpeg_plugin.c mpd-0.13.2.2/src/inputPlugins/ffmpeg_plugin.c
--- mpd-0.13.2/src/inputPlugins/ffmpeg_plugin.c	1970-01-01 10:00:00.000000000 +1000
+++ mpd-0.13.2.2/src/inputPlugins/ffmpeg_plugin.c	2008-06-17 22:27:19.000000000 +1100
@@ -0,0 +1,465 @@
+/* 
+ * the Music Player Daemon (MPD)
+ *
+ * Copyright (C) 2008 by A.Leo. (mb005z@yahoo.com)
+ * This project's homepage is: http://www.musicpd.org
+ *
+ * libavcodec/libavformat plugin  for mpd
+ *
+ * This file is a public domain.
+ *
+ */
+
+#include "../inputPlugin.h"
+
+#if  HAVE_FFMPEG 
+
+#include "../utils.h"
+#include "../audio.h"
+#include "../log.h"
+#include "../pcm_utils.h"
+#include "../playerData.h"
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+#include <ffmpeg/avcodec.h>
+#include <ffmpeg/avformat.h>
+
+
+#define LOG(a...) /* empty */
+
+
+struct ffmpeg_context
+{
+        AVInputFormat* input_format;
+        AVFormatContext* format_ctx;
+
+        unsigned int audio_stream_index;
+        AVCodecContext* codec_ctx;
+
+        AVStream* stream;
+
+        AVCodec* codec;
+        int16_t* decoded_samples;
+        size_t decoded_samples_size;
+        size_t decoded_samples_current_size;
+        
+        AVPacket* packet;
+        int bytes_decoded;
+        int bytes_remaining;
+        uint8_t* raw_input;
+
+        char* file_name;
+};
+
+
+
+static struct ffmpeg_context* 
+ffmpeg_create_context(void)
+{
+        return (struct ffmpeg_context*)calloc(sizeof(struct ffmpeg_context), 1);
+}
+
+
+static void 
+ffmpeg_destroy_context(struct ffmpeg_context* ctx)
+{
+        if(ctx->file_name)
+                free(ctx->file_name);
+
+        if(ctx->decoded_samples)
+                free(ctx->decoded_samples);
+
+        if(ctx->packet) 
+        {
+                av_free_packet(ctx->packet);
+                free(ctx->packet);
+        }
+
+        if(ctx->codec_ctx)
+        {
+                avcodec_close(ctx->codec_ctx);
+               /* av_free(ctx->codec_ctx); / * XXX: is it really needed? TODO: */
+                ctx->codec_ctx = 0;
+        }
+
+        if(ctx->format_ctx)
+                av_close_input_file(ctx->format_ctx);
+
+        free(ctx);
+}
+
+
+static int 
+ffmpeg_init_codec(struct ffmpeg_context* ctx)
+{
+        int i;
+        AVFormatContext* format_ctx = ctx->format_ctx;
+
+        for( i = 0; i < format_ctx->nb_streams; i++ )
+        {
+                AVStream* stream;
+
+                stream = format_ctx->streams[i];
+
+                if( stream->codec->codec_type == CODEC_TYPE_AUDIO )
+                {
+                        ctx->codec_ctx = stream->codec;
+                        ctx->audio_stream_index = i;
+                        ctx->stream = stream;
+                        break;
+                }
+        }
+
+        ctx->codec = avcodec_find_decoder(ctx->codec_ctx->codec_id);
+
+        if( !ctx->codec )
+                return -1;
+        
+        /* XXX: overkill */
+        ctx->decoded_samples_size = AVCODEC_MAX_AUDIO_FRAME_SIZE;
+        ctx->decoded_samples = (int16_t*)calloc(ctx->decoded_samples_size + FF_INPUT_BUFFER_PADDING_SIZE, 2);
+        ctx->packet = (AVPacket*)calloc(sizeof(AVPacket), 1);
+	av_init_packet(ctx->packet);
+	av_new_packet(ctx->packet, 16384);
+        
+        return avcodec_open(ctx->codec_ctx, ctx->codec); 
+}
+
+
+static struct ffmpeg_context* 
+ffmpeg_open_file(const char* file_name)
+{
+        int res;
+        struct ffmpeg_context* ctx = ffmpeg_create_context();
+
+        res = av_open_input_file(&ctx->format_ctx, file_name, ctx->input_format, 0, NULL); 
+
+        if( res < 0 || ctx->format_ctx == 0  )
+        {
+                ffmpeg_destroy_context(ctx);
+                return 0;
+        }
+
+        ctx->file_name = strdup(file_name);
+
+        //res = 
+        av_find_stream_info(ctx->format_ctx);
+
+        return ctx;
+}
+
+
+static int 
+ffmpeg_plugin_init(void)
+{
+        avcodec_init();
+        avcodec_register_all();
+        av_register_all();
+
+        return 1;
+}
+
+
+static void 
+ffmpeg_plugin_cleanup(void)
+{
+}
+
+
+static int 
+ffmpeg_read_frame(struct ffmpeg_context* ctx)
+{
+        AVPacket* packet = ctx->packet;
+
+        do 
+        {
+                if(packet->data)
+                        av_free_packet(packet);
+
+                if(av_read_frame(ctx->format_ctx, packet) < 0 )
+                        return -3;
+
+        } while(packet->stream_index != ctx->audio_stream_index);
+
+        ctx->bytes_remaining = packet->size;
+        ctx->raw_input = packet->data;
+
+        return packet->size;
+}
+
+
+static int 
+ffmpeg_decode_frame(struct ffmpeg_context* ctx)
+{
+        while( ctx->bytes_remaining > 0 )
+        {
+                int decoded_samples_size;
+
+                decoded_samples_size = ctx->decoded_samples_size;
+
+                ctx->bytes_decoded = avcodec_decode_audio2(ctx->codec_ctx,
+                                ctx->decoded_samples,
+                                &decoded_samples_size,
+                                ctx->raw_input,
+                                ctx->bytes_remaining);
+
+                if( ctx->bytes_decoded < 0 )
+                        return -1;
+
+                ctx->bytes_remaining -= ctx->bytes_decoded;
+                ctx->raw_input += ctx->bytes_decoded;
+#if 0
+                if( decoded_samples_size <= 0 )
+                        return -2;
+#endif
+                if( ctx->bytes_decoded == 0 )
+                        return 0;
+
+                return decoded_samples_size;
+        }
+        return 0;
+}
+
+/* XXX: */
+static int
+ffmpeg_seek(struct ffmpeg_context* ctx, float time)
+{
+        int res;
+        float seek_time;
+        AVStream* stream = ctx->stream;
+
+        seek_time =  time * stream->time_base.den / stream->time_base.num;
+
+        avcodec_flush_buffers(ctx->codec_ctx);
+
+        res =  av_seek_frame(ctx->format_ctx, 
+                        ctx->audio_stream_index,
+
+                        (int64_t)seek_time, 
+
+                        AVSEEK_FLAG_ANY );
+        return res;
+}
+
+
+static int 
+ffmpeg_decode(OutputBuffer * cb, DecoderControl * dc, char *path)
+{
+        int res;
+        //mpd_uint16 bitRate;
+        struct stat st;
+        struct ffmpeg_context* ctx;
+
+        if (stat(path, &st) < 0) 
+        {
+                ERROR("failed to stat: %s\n", path);
+                return -1;
+        }
+
+        ctx = ffmpeg_open_file(path);
+
+        if( ctx == 0 )
+        {
+                LOG("open_file failed: %p",(void*)ctx);
+                return -1;
+        }
+
+        res = ffmpeg_init_codec(ctx);
+
+        if( res < 0 )
+        {
+                LOG("init codec failed: %i", res);
+                ffmpeg_destroy_context(ctx);
+                return -1;
+        }
+
+        dc->audioFormat.bits = 16;
+        dc->audioFormat.sampleRate = ctx->codec_ctx->sample_rate; 
+        dc->audioFormat.channels = ctx->codec_ctx->channels; 
+        getOutputAudioFormat(&(dc->audioFormat), &(cb->audioFormat));
+        dc->totalTime = (float) ctx->format_ctx->duration/AV_TIME_BASE;
+
+        dc->state = DECODE_STATE_DECODE;
+        while(1)
+        {
+                int res;
+                int samples_written;
+
+                if (dc->seek)
+                {
+                        dc->seek = 0;
+
+                        res = ffmpeg_seek(ctx, dc->seekWhere); 
+
+//                        if( res < 0 )
+//                                dc->seekError = 1;
+//                        else
+                                clearOutputBuffer(cb);
+                }
+                res = ffmpeg_read_frame(ctx);
+
+                if( res < 0 )
+                        break;
+
+                samples_written = 0;
+                do
+                {
+                        float cur_time = 0.;
+                        float est;
+                        AVStream* stream = ctx->format_ctx->streams[ctx->audio_stream_index];
+
+                        cur_time = ctx->packet->dts;
+                        cur_time *= stream->time_base.num;
+                        cur_time /= stream->time_base.den;
+
+                        est = (float)samples_written / ctx->codec_ctx->sample_rate / ctx->codec_ctx->channels;
+                        est *= 8; /* 1 byte's bits */
+                        est /= dc->audioFormat.bits;
+
+                        cur_time += est;
+
+                        res = ffmpeg_decode_frame(ctx);
+        
+                        if( res <= 0 )
+                                break;
+
+                        samples_written += res;
+                        sendDataToOutputBuffer(cb,
+                                        NULL,
+                                        dc,
+                                        1,
+                                        ctx->decoded_samples,
+                                        res,
+                                        cur_time,
+                                        ctx->format_ctx->bit_rate,
+                                        NULL);
+                } while( res > 0 && !dc->stop && !dc->seek);
+
+                if (dc->stop || res < 0)
+                {
+                        dc->stop = 0;
+                        break;
+                }
+        }
+
+        dc->state = DECODE_STATE_STOP;
+        
+        flushOutputBuffer(cb);
+
+        ffmpeg_destroy_context(ctx);
+
+        return 0;
+}
+
+
+
+static MpdTag* 
+ffmpeg_create_tags(struct ffmpeg_context* ctx)
+{
+        AVFormatContext* format = ctx->format_ctx;
+        MpdTag* ret = newMpdTag();
+        char t[1024] = {0};
+
+        if(!ret)
+                return 0;
+
+        ret->time = 1;
+
+
+        /* XXX: always non-zero? */
+        if( format->duration )
+        {
+                unsigned int secs = (unsigned int)(format->duration/AV_TIME_BASE);
+                ret->time = secs;
+        }
+
+        if( format->track )
+        {
+                snprintf(t, sizeof(t) - 1, "%02i", format->track);
+                addItemToMpdTag(ret, TAG_ITEM_TRACK, strdup(t));
+        }
+
+        if( format->year )
+        {
+                snprintf(t, sizeof(t) - 1, "%i", format->year);
+                addItemToMpdTag(ret, TAG_ITEM_DATE, strdup(t));
+        }
+
+        if( format->genre && *format->genre)
+                addItemToMpdTag(ret, TAG_ITEM_GENRE, strdup(format->genre));
+        
+        if( format->album && *format->album)
+                addItemToMpdTag(ret, TAG_ITEM_ALBUM, strdup(format->album));
+        
+        if( format->title && *format->title)
+                addItemToMpdTag(ret, TAG_ITEM_TITLE, strdup(format->title));
+        
+        if( format->author && *format->author)
+                addItemToMpdTag(ret, TAG_ITEM_ARTIST, strdup(format->author));
+        
+        if( format->comment && *format->comment)
+                addItemToMpdTag(ret, TAG_ITEM_COMMENT, strdup(format->comment));
+
+        return ret;
+}
+
+
+static MpdTag* 
+ffmpeg_tag_dup(char *file)
+{
+
+        MpdTag* ret = NULL;
+        struct ffmpeg_context* ctx;
+
+        LOG("%s", file);
+
+        ctx = ffmpeg_open_file(file);
+
+        if( !ctx) 
+                return 0;
+
+        ret = ffmpeg_create_tags(ctx);
+
+        ffmpeg_destroy_context(ctx);
+
+        return ret;
+}
+
+
+static char* 
+ffmpeg_suffixes[] = 
+{ 
+        "ape",
+//      "flac",
+//        "mp3",
+//        "ogg",
+        NULL 
+};
+
+InputPlugin 
+ffmpegPlugin = {
+        "ape",
+        ffmpeg_plugin_init,
+        ffmpeg_plugin_cleanup,
+        NULL,
+        NULL,
+        ffmpeg_decode,
+        ffmpeg_tag_dup,
+        INPUT_PLUGIN_STREAM_FILE,
+        ffmpeg_suffixes,
+        NULL
+};
+
+#else
+
+InputPlugin apePlugin;
+
+#endif /* HAVE_AUDIOFILE */
diff -dNaur mpd-0.13.2/src/inputPlugins/wv_plugin.c mpd-0.13.2.2/src/inputPlugins/wv_plugin.c
--- mpd-0.13.2/src/inputPlugins/wv_plugin.c	1970-01-01 10:00:00.000000000 +1000
+++ mpd-0.13.2.2/src/inputPlugins/wv_plugin.c	2008-06-17 22:28:14.000000000 +1100
@@ -0,0 +1,401 @@
+/* 
+ * the Music Player Daemon (MPD)
+ *
+ * Copyright (C) 2008 by A.Leo. (mb005z@yahoo.com)
+ * This project's homepage is: http://www.musicpd.org
+ *
+ * libwavpack  plugin for mpd
+ *
+ * This file is a public domain.
+ *
+ */
+
+#include "../inputPlugin.h"
+
+#if HAVE_WAVPACK
+
+#include "../utils.h"
+#include "../audio.h"
+#include "../log.h"
+#include "../pcm_utils.h"
+#include "../playerData.h"
+
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+#include <wavpack/wavpack.h>
+
+
+/* FIXME */
+#define LOG(a...) /* empty */
+
+
+
+struct wv_context
+{
+    WavpackContext* wctx;
+
+    int16_t* decoded_samples;
+    size_t decoded_samples_size;
+    size_t decoded_samples_current_size;
+
+    int bit_rate;
+    int samples_total;
+    int sample_rate;
+    int error;
+
+    int bytes_decoded;
+    int bytes_remaining;
+    uint8_t* raw_input;
+
+    char* file_name;
+
+    float duration; 
+};
+
+
+
+static struct wv_context* 
+wv_create_context(void)
+{
+    return (struct wv_context*)calloc(1, sizeof(struct wv_context));
+}
+
+
+static void 
+wv_destroy_context(struct wv_context* ctx)
+{
+    if(ctx->file_name)
+        free(ctx->file_name);
+
+    if(ctx->decoded_samples)
+        free(ctx->decoded_samples);
+
+    if(ctx->wctx)
+        WavpackCloseFile(ctx->wctx);
+
+    free(ctx);
+}
+
+
+
+
+static struct wv_context* 
+wv_open_file(const char* file_name)
+{
+    int res;
+    int sr;
+    char error_msg[81] = {0};
+    struct wv_context* ctx = wv_create_context();
+
+    ctx->wctx = WavpackOpenFileInput( file_name, error_msg, OPEN_WVC | OPEN_TAGS | OPEN_2CH_MAX, 0 );
+
+    if( ctx->wctx == NULL )
+    {
+        LOG("wp open input failed: %s", error_msg);
+
+        wv_destroy_context(ctx);
+        return NULL;
+    }
+    else
+        LOG("wp open file %s : ok", file_name);
+
+    ctx->file_name = strdup(file_name);
+
+    sr = WavpackGetSampleRate(ctx->wctx);
+    res = WavpackGetNumSamples(ctx->wctx);
+    ctx->samples_total = res;
+    LOG("wp samples total %i, %i s", res, res/sr);
+    ctx->duration = (float)res/sr;
+
+    return ctx;
+}
+
+
+static int 
+wv_plugin_init(void)
+{
+    return 1;
+}
+
+
+static void 
+wv_plugin_cleanup(void)
+{
+}
+
+static int
+wv_seek(struct wv_context* ctx, float seek_time)
+{
+    uint32_t new_idx;
+
+    LOG("seek to: %f\n", seek_time);
+    new_idx = ctx->sample_rate * seek_time; 
+
+    return ctx->error = !WavpackSeekSample(ctx->wctx, new_idx);
+}
+
+static uchar *format_samples (int bps, uchar *dst, int32_t *src, uint32_t samcnt)
+{
+    int32_t temp;
+
+    switch (bps) {
+
+        case 1:
+            while (samcnt--)
+                *dst++ = *src++ + 128;
+
+            break;
+
+        case 2:
+            while (samcnt--) {
+                *dst++ = (uchar) (temp = *src++);
+                *dst++ = (uchar) (temp >> 8);
+            }
+
+            break;
+
+        case 3:
+            while (samcnt--) {
+                *dst++ = (uchar) (temp = *src++);
+                *dst++ = (uchar) (temp >> 8);
+                *dst++ = (uchar) (temp >> 16);
+            }
+
+            break;
+
+        case 4:
+            while (samcnt--) {
+                *dst++ = (uchar) (temp = *src++);
+                *dst++ = (uchar) (temp >> 8);
+                *dst++ = (uchar) (temp >> 16);
+                *dst++ = (uchar) (temp >> 24);
+            }
+
+            break;
+    }
+
+    return dst;
+}
+
+static int 
+wv_decode(OutputBuffer * cb, DecoderControl * dc, char *path)
+{
+    int res;
+    int sr, bytes_ps, channels;
+    int n;
+    struct stat st;
+    struct wv_context* ctx;
+    WavpackContext* wpc;
+    
+    int32_t* samples;
+    void* samples_raw;
+
+    if (stat(path, &st) < 0) 
+    {
+        ERROR("failed to stat: %s\n", path);
+        return -1;
+    }
+
+    ctx = wv_open_file(path);
+
+    if( ctx == 0 )
+    {
+        LOG("open_file failed: %p",(void*)ctx);
+        return -1;
+    }
+    else
+        LOG("open_file %s : ok", path);
+
+    wpc = ctx->wctx;
+
+    res = WavpackGetNumChannels(wpc);
+    LOG("channels: %i", res);
+    channels = dc->audioFormat.channels = res;
+
+    ctx->sample_rate = sr = res = WavpackGetSampleRate(wpc);
+    LOG("wp samples rate: %i", res);
+    dc->audioFormat.sampleRate = n = res ;
+
+    bytes_ps = res = WavpackGetBytesPerSample(wpc);
+    LOG("wp bytes per sample: %i", res);
+    n *= res;
+    ctx->bit_rate = n;
+
+    res = WavpackGetNumSamples(wpc);
+    LOG("wp samples total %i, %i s", res, res/sr);
+    ctx->duration = dc->totalTime = (float)res/sr;
+    ctx->samples_total = res;
+    
+    res = WavpackGetBitsPerSample(wpc);
+    LOG("bits per sample: %i", res);
+    dc->audioFormat.bits = res;
+
+//    dc->audioFormat.bits = 16;
+//    dc->audioFormat.sampleRate = ctx->codec_ctx->sample_rate; 
+//    dc->audioFormat.channels = ctx->codec_ctx->channels; 
+    getOutputAudioFormat(&(dc->audioFormat), &(cb->audioFormat));
+    dc->totalTime = ctx->duration;
+
+    n /= 1;
+    samples = calloc(n, sizeof(*samples));
+    samples_raw = calloc(n, sizeof(*samples));
+
+    dc->state = DECODE_STATE_DECODE;
+    while(1)
+    {
+        int res;
+
+        if (dc->seek)
+        {
+            res = wv_seek(ctx, dc->seekWhere); 
+
+            // FIXME:
+            if( res != 0 )
+            {
+                dc->seekError = 1;
+                break;
+            }
+            else
+                clearOutputBuffer(cb);
+
+            dc->seek = 0;
+            usleep(10000);
+            continue;
+        }
+
+        res = WavpackUnpackSamples(ctx->wctx, samples, n/channels);
+        LOG("decoded %i samples", res);
+        {
+            format_samples(2, samples_raw, samples, res*channels); 
+        }
+
+        if( res <= 0 )
+            break;
+
+        sendDataToOutputBuffer(cb,
+                NULL,
+                dc,
+                1,
+                samples_raw,
+                channels*bytes_ps*res,
+                ctx->duration * WavpackGetProgress(ctx->wctx),
+                ctx->bit_rate,
+                NULL);
+
+        if (ctx->error || dc->stop || res < 0)
+        {
+            dc->stop = 0;
+            break;
+        }
+    }
+
+    dc->state = DECODE_STATE_STOP;
+
+    free(samples);
+    flushOutputBuffer(cb);
+
+    wv_destroy_context(ctx);
+
+    return 0;
+}
+
+
+
+static MpdTag* 
+wv_create_tags(struct wv_context* ctx)
+{
+    MpdTag* ret = newMpdTag();
+    char t[3500] = {0};
+
+    if(!ret)
+        return 0;
+
+    ret->time = 1;
+
+
+    /* XXX: always non-zero? */
+    {
+        unsigned int secs = (unsigned int)ctx->duration;
+        ret->time = secs;
+    }
+
+    if( WavpackGetTagItem(ctx->wctx, "track", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_TRACK, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "year", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_DATE, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "genre", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_GENRE, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "album", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_ALBUM, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "title", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_TITLE, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "author", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_ARTIST, strdup(t));
+
+    if( WavpackGetTagItem(ctx->wctx, "comment", t, sizeof(t) - 1) > 0 )
+        addItemToMpdTag(ret, TAG_ITEM_COMMENT, strdup(t));
+
+    return ret;
+}
+
+
+static MpdTag* 
+wv_tag_dup(char *file)
+{
+
+    MpdTag* ret = NULL;
+    struct wv_context* ctx;
+
+    LOG("wv_tag_dup: %s", file);
+
+    ctx = wv_open_file(file);
+
+    if( !ctx) 
+        return 0;
+
+    ret = wv_create_tags(ctx);
+
+    wv_destroy_context(ctx);
+
+    return ret;
+}
+
+
+static char* 
+wv_suffixes[] = 
+{ 
+    "wv",
+    NULL 
+};
+
+InputPlugin 
+wvPlugin = {
+    "wv",
+    wv_plugin_init,
+    wv_plugin_cleanup,
+    NULL,
+    NULL,
+    wv_decode,
+    wv_tag_dup,
+    INPUT_PLUGIN_STREAM_FILE,
+    wv_suffixes,
+    NULL
+};
+
+#else
+
+InputPlugin wvPlugin;
+
+#endif /* HAVE_AUDIOFILE */
diff -dNaur mpd-0.13.2/src/ls.c mpd-0.13.2.2/src/ls.c
--- mpd-0.13.2/src/ls.c	2007-04-05 14:22:33.000000000 +1100
+++ mpd-0.13.2.2/src/ls.c	2008-06-18 00:34:28.000000000 +1100
@@ -181,7 +181,7 @@
 
 int myStat(char *utf8file, struct stat *st)
 {
-	char *file = utf8ToFsCharset(utf8file);
+	char *file = utf8ToFsCharset(url_filename(utf8file));
 	char *actualFile = file;
 
 	if (actualFile[0] != '/')
@@ -215,6 +215,7 @@
 char *getSuffix(char *utf8file)
 {
 	char *ret = NULL;
+    utf8file = url_filename(utf8file);
 
 	while (*utf8file) {
 		if (*utf8file == '.')
@@ -271,7 +272,7 @@
 
 InputPlugin *isMusic(char *utf8file, time_t * mtime, unsigned int next)
 {
-	if (isFile(utf8file, mtime)) {
+	if (isFile(url_filename(utf8file), mtime)) {
 		InputPlugin *plugin = hasMusicSuffix(utf8file, next);
 		if (plugin != NULL)
 			return plugin;
@@ -279,3 +280,46 @@
 	DEBUG("isMusic: %s is not a valid file\n", utf8file);
 	return NULL;
 }
+const char* url_filename(const char* url)
+{
+    static char res[MAXPATHLEN+1];
+    char* s = res;
+
+    while(url && *url && *url != '?' )
+        *s++ = *url++;
+    *s = 0;
+    return res;
+}
+
+
+const char* url_get_param(const char* str, const char* param_name)
+{
+    static char res[1024];
+    char* r, *out;
+    char* src = strchr(str, '?');
+
+    if(!src)
+        return 0;
+
+    r = strstr(src, param_name);
+
+    if(!r)
+        return 0;
+
+    while(*r && *r != '=' )
+        ++r;
+
+    if( *r == 0 )
+        return "";
+    ++r;
+
+    out = res;
+
+    while(*r && *r && *r != '&' )
+        *out++ = *r++;
+    *out = 0;
+
+    return res;
+}
+
+
diff -dNaur mpd-0.13.2/src/ls.h mpd-0.13.2.2/src/ls.h
--- mpd-0.13.2/src/ls.h	2007-04-05 14:22:33.000000000 +1100
+++ mpd-0.13.2.2/src/ls.h	2008-06-18 00:34:37.000000000 +1100
@@ -49,4 +49,6 @@
 
 int printRemoteUrlHandlers(int fd);
 
+const char* url_filename(const char* url);
+const char* url_get_param(const char* url, const char* param_name);
 #endif
diff -dNaur mpd-0.13.2/src/outputBuffer.c mpd-0.13.2.2/src/outputBuffer.c
--- mpd-0.13.2/src/outputBuffer.c	2007-05-27 03:39:55.000000000 +1100
+++ mpd-0.13.2.2/src/outputBuffer.c	2008-06-18 00:35:22.000000000 +1100
@@ -131,6 +131,12 @@
 				cb->metaChunk[currentChunk] = -1;
 			cb->bitRate[currentChunk] = bitRate;
 			cb->times[currentChunk] = time;
+
+            if(dc->rangems > 0 ) {
+                if( time >= (dc->stopms/1000.f) )
+                    dc->stop = 1;
+            }
+
 		}
 
 		chunkLeft = CHUNK_SIZE - cb->chunkSize[currentChunk];
diff -dNaur mpd-0.13.2/src/song.c mpd-0.13.2.2/src/song.c
--- mpd-0.13.2/src/song.c	2008-06-14 15:16:21.000000000 +1100
+++ mpd-0.13.2.2/src/song.c	2008-06-18 00:35:48.000000000 +1100
@@ -67,7 +67,7 @@
 		InputPlugin *plugin;
 		unsigned int next = 0;
 		char *song_url = getSongUrl(song);
-		char *abs_path = rmp2amp(utf8ToFsCharset(song_url));
+		char *abs_path = rmp2amp(utf8ToFsCharset(url_filename(song_url)));
 		while (!song->tag && (plugin = isMusic(song_url,
 						       &(song->mtime),
 						       next++))) {
diff -dNaur mpd-0.13.2/src/tag.c mpd-0.13.2.2/src/tag.c
--- mpd-0.13.2/src/tag.c	2007-05-27 05:15:54.000000000 +1100
+++ mpd-0.13.2.2/src/tag.c	2008-06-18 00:36:24.000000000 +1100
@@ -610,6 +610,7 @@
 	} \
 }
 
+#if 0
 static void appendToTagItems(MpdTag * tag, int type, char *value, int len)
 {
 	int i = tag->numOfItems;
@@ -629,6 +630,37 @@
 
 	free(dup);
 }
+#else
+static void appendToTagItems(MpdTag * tag, int type, char *value, int len)
+{
+	int i;
+    int j;
+	char *dup = xmalloc(len + 1);
+
+	memcpy(dup, value, len);
+	dup[len] = '\0';
+
+	fixUtf8(dup);
+	stripReturnChar(dup);
+
+    for( j = 0; j < tag->numOfItems; j++ )
+    {
+        if( tag->items[i].type == type )
+        {
+            deleteItem(tag, j);
+            --j;
+        }
+    }
+
+	i = tag->numOfItems++;
+	tag->items = xrealloc(tag->items, tag->numOfItems * sizeof(MpdTagItem));
+
+	tag->items[i].type = type;
+	tag->items[i].value = getTagItemString(type, dup);
+
+	free(dup);
+}
+#endif
 
 void addItemToMpdTagWithLen(MpdTag * tag, int itemType, char *value, int len)
 {
