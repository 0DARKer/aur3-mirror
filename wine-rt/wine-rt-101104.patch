From 3b5eaf0bfd4e55358d81881adee81979ba7741ab Mon Sep 17 00:00:00 2001
From: Joakim B Hernberg <jhernberg@alchemy.lu>
Date: Thu, 4 Nov 2010 11:43:17 +0100
Subject: [PATCH] 2:nd wine realtime patch 101104

---
 server/main.c   |   60 ++++++++++++++++++++++++++++++++++++++
 server/thread.c |   87 ++++++++++++++++++++++++++++++++++++++++++------------
 2 files changed, 127 insertions(+), 20 deletions(-)

diff --git a/server/main.c b/server/main.c
index 2d841e8..c8ff4d7 100644
--- a/server/main.c
+++ b/server/main.c
@@ -27,10 +27,18 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/mman.h>
 #include <unistd.h>
 #ifdef HAVE_GETOPT_H
 # include <getopt.h>
 #endif
+#ifdef HAVE_SCHED_H
+#include <sched.h>
+#ifndef SCHED_NORMAL
+#define SCHED_NORMAL SCHED_OTHER
+#endif
+#endif
 
 #include "object.h"
 #include "file.h"
@@ -44,6 +52,9 @@ int foreground = 0;
 timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
+/* global variable used here and in thread.c to determine whether wine runs with rt threads and at what base value */
+int base_rt_priority = -1;
+
 /* parse-line args */
 
 static void usage(void)
@@ -125,6 +136,52 @@ static void sigterm_handler( int signum )
     exit(1);  /* make sure atexit functions get called */
 }
 
+#ifdef HAVE_SCHED_H
+void init_rt_scheduling( void )
+{
+    struct sched_param param;
+    struct rlimit limit;
+    int priority_max, policy, wine_server_rt_priority;
+    char *enviroment, *endptr;
+
+    getrlimit( RLIMIT_RTPRIO, &limit );
+    priority_max = limit.rlim_max;
+
+    /* check for realtime mode and set the base priority level */
+
+    if (!(enviroment = getenv( "WINE_RT" )))
+        return;
+    base_rt_priority = (int) strtol( enviroment, &endptr, 10 );
+    if (enviroment == endptr || base_rt_priority == 0 || base_rt_priority > priority_max - 10)
+    {
+        fprintf( stderr, "Unable to run WINE in rt mode, WINE_RT values supported on this system range from 1 to  %i\n", priority_max - 10 );
+        base_rt_priority = -1;
+        return;
+    }
+    fprintf( stderr, "WINE realtime scheduling hack enabled, realtime base priority has been set to %i\n", base_rt_priority );
+
+    /* determine scheduling policy for the main wineserver thread */
+
+    if (!(enviroment = getenv( "WINE_SRV_RT" )))
+    {
+        fprintf( stderr, "wineserver running SCHED_NORMAL\n" );
+        return;
+    }
+    wine_server_rt_priority = (int) strtol( enviroment, &endptr, 10 );
+    if (enviroment == endptr || wine_server_rt_priority == 0 || wine_server_rt_priority > priority_max)
+    {
+        fprintf( stderr, "Unable to run the wineserver SCHED_FIFO, valid WINE_SRV_RT values range from 1 to %i\n", priority_max );
+        return;
+    }
+    fprintf( stderr, "wineserver running SCHED_FIFO at priority %i\n", wine_server_rt_priority );
+    policy = SCHED_FIFO;
+    param.sched_priority = wine_server_rt_priority;
+    if (sched_setscheduler ( 0, policy, &param) != 0)
+        fprintf (stderr, "Error scheduling wineserver as SCHED_FIFO\n");
+    mlockall(MCL_FUTURE);
+}
+#endif
+
 int main( int argc, char *argv[] )
 {
     setvbuf( stderr, NULL, _IOLBF, 0 );
@@ -138,6 +195,9 @@ int main( int argc, char *argv[] )
     signal( SIGTERM, sigterm_handler );
     signal( SIGABRT, sigterm_handler );
 
+#ifdef HAVE_SCHED_H
+    init_rt_scheduling();
+#endif
     sock_init();
     open_master_socket();
 
diff --git a/server/thread.c b/server/thread.c
index 05e4121..2d103b4 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -32,11 +32,18 @@
 #include <sys/types.h>
 #include <unistd.h>
 #include <time.h>
-#ifdef HAVE_POLL_H
-#include <poll.h>
-#endif
 #ifdef HAVE_SCHED_H
 #include <sched.h>
+#ifndef SCHED_NORMAL
+#define SCHED_NORMAL SCHED_OTHER
+#endif
+#ifndef SCHED_IDLE
+#define SCHED_IDLE 5 /* missing from my glibc, taken from linux/sched.h */
+#endif
+#endif
+
+#ifdef HAVE_POLL_H
+#include <poll.h>
 #endif
 
 #include "ntstatus.h"
@@ -164,6 +171,8 @@ static const struct fd_ops thread_fd_ops =
 
 static struct list thread_list = LIST_INIT(thread_list);
 
+extern int base_rt_priority;
+
 /* initialize the structure for a newly allocated thread */
 static inline void init_thread_structure( struct thread *thread )
 {
@@ -432,29 +441,67 @@ int set_thread_affinity( struct thread *thread, affinity_t affinity )
     return ret;
 }
 
-#define THREAD_PRIORITY_REALTIME_HIGHEST 6
-#define THREAD_PRIORITY_REALTIME_LOWEST -7
+void set_thread_priority( struct thread *thread, int priority )
+{
+#ifdef HAVE_SCHED_H
+    struct sched_param param;
+    int policy;
+
+    if (base_rt_priority == -1 || (thread->unix_tid == -1)) return;
+
+    switch (priority)
+    {
+      case THREAD_PRIORITY_TIME_CRITICAL:
+        param.sched_priority = base_rt_priority + 10;
+        policy = SCHED_FIFO;
+        fprintf( stderr, "Thread %i at THREAD_PRIORITY_TIME_CRITICAL set to SCHED_FIFO - priority %i\n", thread->unix_tid, param.sched_priority );
+        break;
+      case THREAD_PRIORITY_HIGHEST:
+        param.sched_priority = base_rt_priority + 5;
+        policy = SCHED_FIFO;
+        fprintf( stderr, "Thread %i at THREAD_PRIORITY_HIGHEST set to SCHED_FIFO - priority %i\n", thread->unix_tid, param.sched_priority );
+        break;
+      case THREAD_PRIORITY_ABOVE_NORMAL:
+        param.sched_priority = base_rt_priority;
+        policy = SCHED_FIFO;
+        fprintf( stderr, "Thread %i at THREAD_PRIORITY_ABOVE_NORMAL set to SCHED_FIFO - priority %i\n", thread->unix_tid, param.sched_priority );
+        break;
+      case THREAD_PRIORITY_NORMAL:
+        param.sched_priority = 0;
+        policy = SCHED_NORMAL;
+        fprintf( stderr, "Setting thread %i at level THREAD_PRIORITY_NORMAL to SCHED_NORMAL\n", thread->unix_tid );
+	break;
+      case THREAD_PRIORITY_BELOW_NORMAL:
+        param.sched_priority = 0;
+        policy = SCHED_BATCH;
+        fprintf( stderr, "Setting thread %i at level THREAD_PRIORITY_BELOW_NORMAL to SCHED_BATCH\n", thread->unix_tid );
+        break;
+      case THREAD_PRIORITY_LOWEST:
+        param.sched_priority = 0;
+        policy = SCHED_BATCH;
+        fprintf( stderr, "Setting thread %i at THREAD_PRIORITY_LOWEST level to SCHED_BATCH\n", thread->unix_tid );
+        break;
+      case THREAD_PRIORITY_IDLE:
+        param.sched_priority = 0;
+        policy = SCHED_IDLE;
+        fprintf( stderr, "Setting thread %i with level THREAD_PRIORITY_IDLE to SCHED_IDLE\n", thread->unix_tid );
+        break;
+      default:
+        fprintf( stderr, "Error setting scheduling priority level, unknown should never come here\n" );
+        return;
+    }
+    if (sched_setscheduler (thread->unix_tid, policy, &param) != 0) fprintf (stderr, "Error setting priorities\n");
+    thread->priority = priority;
+    return;
+#endif
+}
 
 /* set all information about a thread */
 static void set_thread_info( struct thread *thread,
                              const struct set_thread_info_request *req )
 {
     if (req->mask & SET_THREAD_INFO_PRIORITY)
-    {
-        int max = THREAD_PRIORITY_HIGHEST;
-        int min = THREAD_PRIORITY_LOWEST;
-        if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
-        {
-            max = THREAD_PRIORITY_REALTIME_HIGHEST;
-            min = THREAD_PRIORITY_REALTIME_LOWEST;
-        }
-        if ((req->priority >= min && req->priority <= max) ||
-            req->priority == THREAD_PRIORITY_IDLE ||
-            req->priority == THREAD_PRIORITY_TIME_CRITICAL)
-            thread->priority = req->priority;
-        else
-            set_error( STATUS_INVALID_PARAMETER );
-    }
+        set_thread_priority( thread, req->priority );
     if (req->mask & SET_THREAD_INFO_AFFINITY)
     {
         if ((req->affinity & thread->process->affinity) != req->affinity)
-- 
1.7.3.2

