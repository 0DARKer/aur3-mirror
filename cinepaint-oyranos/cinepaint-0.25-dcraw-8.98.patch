--- plug-ins/rawphoto/dcraw.c	2007-10-25 12:26:21.000000000 +0200
+++ plug-ins/rawphoto/dcraw.c	2009-09-21 12:19:14.000000000 +0200
@@ -1,31 +1,33 @@
 /*
    dcraw.c -- Dave Coffin's raw photo decoder
-   Copyright 1997-2006 by Dave Coffin, dcoffin a cybercom o net
+   Copyright 1997-2009 by Dave Coffin, dcoffin a cybercom o net
 
    This is a command-line ANSI C program to convert raw photos from
    any digital camera on any computer running any operating system.
 
-   Attention!  Some parts of this program are restricted under the
-   terms of the GNU General Public License.  Such code is enclosed
-   in "BEGIN GPL BLOCK" and "END GPL BLOCK" declarations.
-   Any code not declared GPL is free for all uses.
-
-   Starting in Revision 1.237, the code to support Foveon cameras
-   is under GPL.
-
-   To lawfully redistribute dcraw.c, you must either (a) include
-   full source code for all executable files containing restricted
-   functions, (b) remove these functions, re-implement them, or
-   copy them from an earlier, non-GPL Revision of dcraw.c, or (c)
-   purchase a license from the author.
+   No license is required to download and use dcraw.c.  However,
+   to lawfully redistribute dcraw, you must either (a) offer, at
+   no extra charge, full source code* for all executable files
+   containing RESTRICTED functions, (b) distribute this code under
+   the GPL Version 2 or later, (c) remove all RESTRICTED functions,
+   re-implement them, or copy them from an earlier, unrestricted
+   Revision of dcraw.c, or (d) purchase a license from the author.
 
-   $Revision: 1.3 $
-   $Date: 2007/10/25 10:26:21 $
+   The functions that process Foveon images have been RESTRICTED
+   since Revision 1.237.  All other code remains free for all uses.
+
+   *If you have not modified dcraw.c in any way, a link to my
+   homepage qualifies as "full source code".
+
+   $Revision: 1.430 $
+   $Date: 2009/09/19 05:00:03 $
  */
 
-#define VERSION_ "8.48"
+#define VERSION "8.98"
 
+#ifndef _GNU_SOURCE
 #define _GNU_SOURCE
+#endif
 #define _USE_MATH_DEFINES
 #include <ctype.h>
 #include <errno.h>
@@ -38,6 +40,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#include <sys/types.h>
 
 /* CinePaint includes */
 #include <libgimp/stdplugins-intl.h>
@@ -52,13 +55,18 @@
 #ifndef NO_LCMS
 #include <lcms.h>
 #endif
-#ifdef ENABLE_NLS_
+#ifdef LOCALEDIR_
 #include <libintl.h>
 #define _(String) gettext(String)
 #else
 #define _(String) (String)
 #endif
-
+#ifdef DJGPP
+#define fseeko fseek
+#define ftello ftell
+#else
+#define fgetc getc_unlocked
+#endif
 #ifdef __CYGWIN__
 #include <io.h>
 #endif
@@ -66,7 +74,9 @@
 #include <sys/utime.h>
 #include <winsock2.h>
 #pragma comment(lib, "ws2_32.lib")
+#define snprintf _snprintf
 #define strcasecmp stricmp
+#define strncasecmp strnicmp
 typedef __int64 INT64;
 typedef unsigned __int64 UINT64;
 #else
@@ -95,36 +105,41 @@
    access them are prefixed with "CLASS".  Note that a thread-safe
    C++ class cannot have non-const static local variables.
  */
-FILE *ifp;
+FILE *ifp, *ofp;
 short order;
-char *ifname, make[64], model[64], model2[64], *meta_data, cdesc[5];
+const char *ifname;
+char *meta_data;
+char cdesc[5], desc[512], make[64], model[64], model2[64], artist[64];
 float flash_used, canon_ev, iso_speed, shutter, aperture, focal_len;
 time_t timestamp;
-unsigned shot_order, kodak_cbpp, filters, unique_id, *oprof;
-int profile_offset, profile_length;
-int thumb_offset, thumb_length, thumb_width, thumb_height, thumb_misc;
-int data_offset, strip_offset, curve_offset, meta_offset, meta_length;
-int tiff_nifds, tiff_flip, tiff_bps, tiff_compress, tile_length;
-int raw_height, raw_width, top_margin, left_margin;
-int height, width, fuji_width, colors, tiff_samples;
-int black, maximum, raw_color, use_gamma;
-int iheight, iwidth, shrink, flip;
-double pixel_aspect;
-int zero_after_ff, is_raw, dng_version, is_foveon;
-ushort (*image)[4], white[8][8], curve[0x1000], cr2_slice[3];
-float bright=1, user_mul[4]={0,0,0,0}, sigma_d=0, sigma_r=0;
-int four_color_rgb=0, document_mode=0, highlight=0;
-int verbose=0, use_auto_wb=0, use_camera_wb=0;
-int output_color=1, output_bps=8, output_tiff=0;
-int fuji_layout, fuji_secondary, shot_select=0;
-float cam_mul[4], pre_mul[4], rgb_cam[3][4];	/* RGB from camera color */
+unsigned shot_order, kodak_cbpp, filters, exif_cfa, unique_id;
+off_t    strip_offset, data_offset;
+off_t    thumb_offset, meta_offset, profile_offset;
+unsigned thumb_length, meta_length, profile_length;
+unsigned thumb_misc, *oprof, fuji_layout, shot_select=0, multi_out=0;
+unsigned tiff_nifds, tiff_samples, tiff_bps, tiff_compress;
+unsigned black, maximum, mix_green, raw_color, zero_is_bad;
+unsigned zero_after_ff, is_raw, dng_version, is_foveon, data_error;
+unsigned tile_width, tile_length, gpsdata[32], load_flags;
+ushort raw_height, raw_width, height, width, top_margin, left_margin;
+ushort shrink, iheight, iwidth, fuji_width, thumb_width, thumb_height;
+int flip, tiff_flip, colors;
+double pixel_aspect, aber[4]={1,1,1,1}, gamm[6]={ 0.45,4.5,0,0,0,0 };
+ushort (*image)[4], white[8][8], curve[0x10000], cr2_slice[3], sraw_mul[4];
+float bright=1, user_mul[4]={0,0,0,0}, threshold=0;
+int half_size=0, four_color_rgb=0, document_mode=0, highlight=0;
+int verbose=0, use_auto_wb=0, use_camera_wb=0, use_camera_matrix=-1;
+int output_color=1, output_bps=8, output_tiff=0, med_passes=0;
+int no_auto_bright=0;
+unsigned greybox[4] = { 0, 0, UINT_MAX, UINT_MAX };
+float cam_mul[4], pre_mul[4], cmatrix[3][4], rgb_cam[3][4];
 const double xyz_rgb[3][3] = {			/* XYZ from RGB */
   { 0.412453, 0.357580, 0.180423 },
   { 0.212671, 0.715160, 0.072169 },
   { 0.019334, 0.119193, 0.950227 } };
 const float d65_white[3] = { 0.950456, 1, 1.088754 };
 int histogram[4][0x2000];
-void (*write_thumb)(FILE *), (*write_fun)(FILE *);
+void (*write_thumb)(), (*write_fun)();
 void (*load_raw)(), (*thumb_load_raw)();
 jmp_buf failure;
 
@@ -133,21 +148,21 @@
   int leaf;
 } first_decode[2048], *second_decode, *free_decode;
 
-struct {
+struct tiff_ifd {
   int width, height, bps, comp, phint, offset, flip, samples, bytes;
 } tiff_ifd[10];
 
-struct {
+struct ph1 {
   int format, key_off, black, black_off, split_col, tag_21a;
   float tag_210;
 } ph1;
 
 #define CLASS
-#define fgetc getc_unlocked
 
-#define FORC3 for (c=0; c < 3; c++)
-#define FORC4 for (c=0; c < 4; c++)
-#define FORCC for (c=0; c < colors; c++)
+#define FORC(cnt) for (c=0; c < cnt; c++)
+#define FORC3 FORC(3)
+#define FORC4 FORC(4)
+#define FORCC FORC(colors)
 
 #define SQR(x) ((x)*(x))
 #define ABS(x) (((int)(x) ^ ((int)(x) >> 31)) - ((int)(x) >> 31))
@@ -238,18 +253,30 @@
   for (c = haystack; c <= haystack + haystacklen - needlelen; c++)
     if (!memcmp (c, needle, needlelen))
       return c;
-  return NULL;
+  return 0;
 }
 #define memmem my_memmem
 #endif
 
-void CLASS merror (void *ptr, char *where)
+void CLASS merror (void *ptr, const char *where)
 {
   if (ptr) return;
   fprintf (stderr,_("%s: Out of memory in %s\n"), ifname, where);
   longjmp (failure, 1);
 }
 
+void CLASS derror()
+{
+  if (!data_error) {
+    fprintf (stderr, "%s: ", ifname);
+    if (feof(ifp))
+      fprintf (stderr,_("Unexpected end of file\n"));
+    else
+      fprintf (stderr,_("Corrupt data near 0x%llx\n"), (INT64) ftello(ifp));
+  }
+  data_error = 1;
+}
+
 ushort CLASS sget2 (uchar *s)
 {
   if (order == 0x4949)		/* "II" means little-endian */
@@ -265,7 +292,7 @@
   return sget2(str);
 }
 
-int CLASS sget4 (uchar *s)
+unsigned CLASS sget4 (uchar *s)
 {
   if (order == 0x4949)
     return s[0] | s[1] << 8 | s[2] << 16 | s[3] << 24;
@@ -274,14 +301,14 @@
 }
 #define sget4(s) sget4((uchar *)s)
 
-int CLASS get4()
+unsigned CLASS get4()
 {
   uchar str[4] = { 0xff,0xff,0xff,0xff };
   fread (str, 1, 4, ifp);
   return sget4(str);
 }
 
-int CLASS getint (int type)
+unsigned CLASS getint (int type)
 {
   return type == 3 ? get2() : get4();
 }
@@ -316,15 +343,28 @@
     default: return fgetc(ifp);
   }
 }
-#define getrat() getreal(10)
 
 void CLASS read_shorts (ushort *pixel, int count)
 {
-  fread (pixel, 2, count, ifp);
+  if (fread (pixel, 2, count, ifp) < count) derror();
   if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))
     swab (pixel, pixel, count*2);
 }
 
+void CLASS canon_black (double dark[2], int nblack)
+{
+  int c, diff, row, col;
+
+  if (!nblack) return;
+  FORC(2) dark[c] /= nblack >> 1;
+  if ((diff = dark[0] - dark[1]))
+    for (row=0; row < height; row++)
+      for (col=1; col < width; col+=2)
+	BAYER(row,col) += diff;
+  dark[1] += diff;
+  black = (dark[0] + dark[1] + 1) / 2;
+}
+
 void CLASS canon_600_fixed_wb (int temp)
 {
   static const short mul[4][5] = {
@@ -408,7 +448,7 @@
       for (i=0; i < 8; i++)
 	total[st][i] += test[i];
       count[st]++;
-next: continue;
+next: ;
     }
   if (count[0] | count[1]) {
     st = count[0]*200 < count[1];
@@ -450,7 +490,7 @@
   { { 1141,1145 }, { 1128,1109 }, { 1178,1149 }, { 1128,1109 } };
 
   for (irow=row=0; irow < height; irow++) {
-    fread (data, raw_width * 10 / 8, 1, ifp);
+    if (fread (data, 1, raw_width*5/4, ifp) < raw_width*5/4) derror();
     for (dp=data, pix=pixel; dp < data+1120; dp+=10, pix+=8) {
       pix[0] = (dp[0] << 2) + (dp[1] >> 6    );
       pix[1] = (dp[2] << 2) + (dp[1] >> 4 & 3);
@@ -471,8 +511,8 @@
     black = black / ((raw_width - width) * height) - 4;
   for (row=0; row < height; row++)
     for (col=0; col < width; col++) {
-      val = (BAYER(row,col) - black) * mul[row & 3][col & 1] >> 9;
-      if (val < 0) val = 0;
+      if ((val = BAYER(row,col) - black) < 0) val = 0;
+      val = val * mul[row & 3][col & 1] >> 9;
       BAYER(row,col) = val;
     }
   canon_600_fixed_wb(1311);
@@ -499,33 +539,22 @@
       }
 }
 
-void CLASS canon_a5_load_raw()
+int CLASS canon_s2is()
 {
-  ushort data[1970], *dp, pixel;
-  int vbits=0, buf=0, row, col, bc=0;
+  unsigned row;
 
-  order = 0x4949;
-  for (row=-top_margin; row < raw_height-top_margin; row++) {
-    read_shorts (dp=data, raw_width * 10 / 16);
-    for (col=-left_margin; col < raw_width-left_margin; col++) {
-      if (vbits < 10)
-	buf = (vbits += 16, (buf << 16) + *dp++);
-      pixel = buf >> (vbits -= 10) & 0x3ff;
-      if ((unsigned) row < height && (unsigned) col < width)
-	BAYER(row,col) = pixel;
-      else black += (bc++,pixel);
-    }
+  for (row=0; row < 100; row++) {
+    fseek (ifp, row*3340 + 3284, SEEK_SET);
+    if (getc(ifp) > 15) return 1;
   }
-  if (bc) black /= bc;
-  maximum = 0x3ff;
-  if (raw_width > 1600) remove_zeroes();
+  return 0;
 }
 
 /*
    getbits(-1) initializes the buffer
    getbits(n) where 0 <= n <= 25 returns an n-bit integer
  */
-unsigned CLASS getbits (int nbits)
+unsigned CLASS getbithuff (int nbits, ushort *huff)
 {
   static unsigned bitbuf=0;
   static int vbits=0, reset=0;
@@ -533,22 +562,24 @@
 
   if (nbits == -1)
     return bitbuf = vbits = reset = 0;
-  if (nbits == 0 || reset) return 0;
-  while (vbits < nbits) {
-    c = fgetc(ifp);
-    if ((reset = zero_after_ff && c == 0xff && fgetc(ifp))) return 0;
-    bitbuf = (bitbuf << 8) + c;
+  if (nbits == 0 || vbits < 0) return 0;
+  while (!reset && vbits < nbits && (c = fgetc(ifp)) != EOF &&
+    !(reset = zero_after_ff && c == 0xff && fgetc(ifp))) {
+    bitbuf = (bitbuf << 8) + (uchar) c;
     vbits += 8;
   }
-  vbits -= nbits;
-  return bitbuf << (32-nbits-vbits) >> (32-nbits);
+  c = bitbuf << (32-vbits) >> (32-nbits);
+  if (huff) {
+    vbits -= huff[c] >> 8;
+    c = (uchar) huff[c];
+  } else
+    vbits -= nbits;
+  if (vbits < 0) derror();
+  return c;
 }
 
-void CLASS init_decoder()
-{
-  memset (first_decode, 0, sizeof first_decode);
-  free_decode = first_decode;
-}
+#define getbits(n) getbithuff(n,0)
+#define gethuff(h) getbithuff(*h,h+1)
 
 /*
    Construct a decode tree according the specification in *source.
@@ -576,33 +607,31 @@
 	1111110		0x0b
 	1111111		0xff
  */
-uchar * CLASS make_decoder (const uchar *source, int level)
+ushort * CLASS make_decoder_ref (const uchar **source)
 {
-  struct decode *cur;
-  static int leaf;
-  int i, next;
+  int max, len, h, i, j;
+  const uchar *count;
+  ushort *huff;
 
-  if (level==0) leaf=0;
-  cur = free_decode++;
-  if (free_decode > first_decode+2048) {
-    fprintf (stderr,_("%s: decoder table overflow\n"), ifname);
-    longjmp (failure, 2);
-  }
-  for (i=next=0; i <= leaf && next < 16; )
-    i += source[next++];
-  if (i > leaf) {
-    if (level < next) {
-      cur->branch[0] = free_decode;
-      make_decoder (source, level+1);
-      cur->branch[1] = free_decode;
-      make_decoder (source, level+1);
-    } else
-      cur->leaf = source[16 + leaf++];
-  }
-  return (uchar *) source + 16 + leaf;
+  count = (*source += 16) - 17;
+  for (max=16; max && !count[max]; max--);
+  huff = (ushort *) calloc (1 + (1 << max), sizeof *huff);
+  merror (huff, "make_decoder()");
+  huff[0] = max;
+  for (h=len=1; len <= max; len++)
+    for (i=0; i < count[len]; i++, ++*source)
+      for (j=0; j < 1 << (max-len); j++)
+	if (h <= 1 << max)
+	  huff[h++] = len << 8 | **source;
+  return huff;
+}
+
+ushort * CLASS make_decoder (const uchar *source)
+{
+  return make_decoder_ref (&source);
 }
 
-void CLASS crw_init_tables (unsigned table)
+void CLASS crw_init_tables (unsigned table, ushort *huff[2])
 {
   static const uchar first_tree[3][29] = {
     { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,
@@ -660,10 +689,8 @@
       0xe2,0x82,0xf1,0xa3,0xc2,0xa1,0xc1,0xe3,0xa2,0xe1,0xff,0xff  }
   };
   if (table > 2) table = 2;
-  init_decoder();
-  make_decoder ( first_tree[table], 0);
-  second_decode = free_decode;
-  make_decoder (second_tree[table], 0);
+  huff[0] = make_decoder ( first_tree[table]);
+  huff[1] = make_decoder (second_tree[table]);
 }
 
 /*
@@ -689,14 +716,13 @@
 
 void CLASS canon_compressed_load_raw()
 {
-  ushort *pixel, *prow;
-  int lowbits, i, row, r, col, save, val;
+  ushort *pixel, *prow, *huff[2];
+  int nblocks, lowbits, i, c, row, r, col, save, val, nblack=0;
   unsigned irow, icol;
-  struct decode *decode, *dindex;
   int block, diffbuf[64], leaf, len, diff, carry=0, pnum=0, base[2];
-  uchar c;
+  double dark[2] = { 0,0 };
 
-  crw_init_tables (tiff_compress);
+  crw_init_tables (tiff_compress, huff);
   pixel = (ushort *) calloc (raw_width*8, sizeof *pixel);
   merror (pixel, "canon_compressed_load_raw()");
   lowbits = canon_has_lowbits();
@@ -705,14 +731,11 @@
   zero_after_ff = 1;
   getbits(-1);
   for (row=0; row < raw_height; row+=8) {
-    for (block=0; block < raw_width >> 3; block++) {
+    nblocks = MIN (8, raw_height-row) * raw_width >> 6;
+    for (block=0; block < nblocks; block++) {
       memset (diffbuf, 0, sizeof diffbuf);
-      decode = first_decode;
       for (i=0; i < 64; i++ ) {
-	for (dindex=decode; dindex->branch[0]; )
-	  dindex = dindex->branch[getbits(1)];
-	leaf = dindex->leaf;
-	decode = second_decode;
+	leaf = gethuff(huff[i > 0]);
 	if (leaf == 0 && i) break;
 	if (leaf == 0xff) continue;
 	i  += leaf >> 4;
@@ -728,7 +751,8 @@
       for (i=0; i < 64; i++ ) {
 	if (pnum++ % raw_width == 0)
 	  base[0] = base[1] = 512;
-	pixel[(block << 6) + i] = ( base[i & 1] += diffbuf[i] );
+	if ((pixel[(block << 6) + i] = base[i & 1] += diffbuf[i]) >> 10)
+	  derror();
       }
     }
     if (lowbits) {
@@ -751,14 +775,14 @@
 	icol = col - left_margin;
 	if (icol < width)
 	  BAYER(irow,icol) = pixel[r*raw_width+col];
-	else
-	  black += pixel[r*raw_width+col];
+	else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
+	  dark[icol & 1] += (nblack++,pixel[r*raw_width+col]);
       }
     }
   }
   free (pixel);
-  if (raw_width > width)
-    black /= (raw_width - width) * height;
+  FORC(2) free (huff[c]);
+  canon_black (dark, nblack);
 }
 
 /*
@@ -766,19 +790,17 @@
    enough to decode Canon, Kodak and Adobe DNG images.
  */
 struct jhead {
-  int bits, high, wide, clrs, restart, vpred[4];
-  struct decode *huff[4];
-  ushort *row;
+  int bits, high, wide, clrs, sraw, psv, restart, vpred[6];
+  ushort *huff[6], *free[4], *row;
 };
 
 int CLASS ljpeg_start (struct jhead *jh, int info_only)
 {
-  int i, tag, len;
-  uchar data[0x10000], *dp;
+  int c, tag, len;
+  uchar data[0x10000];
+  const uchar *dp;
 
-  init_decoder();
-  for (i=0; i < 4; i++)
-    jh->huff[i] = free_decode;
+  memset (jh, 0, sizeof *jh);
   jh->restart = INT_MAX;
   fread (data, 2, 1, ifp);
   if (data[1] != 0xd8) return 0;
@@ -789,37 +811,51 @@
     if (tag <= 0xff00) return 0;
     fread (data, 1, len, ifp);
     switch (tag) {
-      case 0xffc0:
       case 0xffc3:
+	jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;
+      case 0xffc0:
 	jh->bits = data[0];
 	jh->high = data[1] << 8 | data[2];
 	jh->wide = data[3] << 8 | data[4];
-	jh->clrs = data[5];
+	jh->clrs = data[5] + jh->sraw;
+	if (len == 9 && !dng_version) getc(ifp);
 	break;
       case 0xffc4:
 	if (info_only) break;
-	for (dp = data; dp < data+len && *dp < 4; ) {
-	  jh->huff[*dp] = free_decode;
-	  dp = make_decoder (++dp, 0);
-	}
+	for (dp = data; dp < data+len && (c = *dp++) < 4; )
+	  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);
+	break;
+      case 0xffda:
+	jh->psv = data[1+data[0]*2];
+	jh->bits -= data[3+data[0]*2] & 15;
 	break;
       case 0xffdd:
 	jh->restart = data[0] << 8 | data[1];
     }
   } while (tag != 0xffda);
   if (info_only) return 1;
-  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 2);
-  merror (jh->row, " jpeg_start()");
+  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];
+  if (jh->sraw) {
+    FORC(4)        jh->huff[2+c] = jh->huff[1];
+    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];
+  }
+  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);
+  merror (jh->row, "ljpeg_start()");
   return zero_after_ff = 1;
 }
 
-int CLASS ljpeg_diff (struct decode *dindex)
+void CLASS ljpeg_end (struct jhead *jh)
+{
+  int c;
+  FORC4 if (jh->free[c]) free (jh->free[c]);
+  free (jh->row);
+}
+
+int CLASS ljpeg_diff (ushort *huff)
 {
   int len, diff;
 
-  while (dindex->branch[0])
-    dindex = dindex->branch[getbits(1)];
-  len = dindex->leaf;
+  len = gethuff(huff);
   if (len == 16 && (!dng_version || dng_version >= 0x1010000))
     return -32768;
   diff = getbits(len);
@@ -828,41 +864,62 @@
   return diff;
 }
 
-void CLASS ljpeg_row (int jrow, struct jhead *jh)
+ushort * CLASS ljpeg_row (int jrow, struct jhead *jh)
 {
-  int col, c, diff;
-  ushort mark=0, *outp=jh->row;
+  int col, c, diff, pred, spred=0;
+  ushort mark=0, *row[3];
 
   if (jrow * jh->wide % jh->restart == 0) {
-    FORC4 jh->vpred[c] = 1 << (jh->bits-1);
-    if (jrow)
+    FORC(6) jh->vpred[c] = 1 << (jh->bits-1);
+    if (jrow) {
+      fseek (ifp, -2, SEEK_CUR);
       do mark = (mark << 8) + (c = fgetc(ifp));
       while (c != EOF && mark >> 4 != 0xffd);
+    }
     getbits(-1);
   }
+  FORC3 row[c] = jh->row + jh->wide*jh->clrs*((jrow+c) & 1);
   for (col=0; col < jh->wide; col++)
-    for (c=0; c < jh->clrs; c++) {
+    FORC(jh->clrs) {
       diff = ljpeg_diff (jh->huff[c]);
-      *outp = col ? outp[-jh->clrs]+diff : (jh->vpred[c] += diff);
-      outp++;
+      if (jh->sraw && c <= jh->sraw && (col | c))
+		    pred = spred;
+      else if (col) pred = row[0][-jh->clrs];
+      else	    pred = (jh->vpred[c] += diff) - diff;
+      if (jrow && col) switch (jh->psv) {
+	case 1:	break;
+	case 2: pred = row[1][0];					break;
+	case 3: pred = row[1][-jh->clrs];				break;
+	case 4: pred = pred +   row[1][0] - row[1][-jh->clrs];		break;
+	case 5: pred = pred + ((row[1][0] - row[1][-jh->clrs]) >> 1);	break;
+	case 6: pred = row[1][0] + ((pred - row[1][-jh->clrs]) >> 1);	break;
+	case 7: pred = (pred + row[1][0]) >> 1;				break;
+	default: pred = 0;
+      }
+      if ((**row = pred + diff) >> jh->bits) derror();
+      if (c <= jh->sraw) spred = **row;
+      row[0]++; row[1]++;
     }
+  return row[2];
 }
 
 void CLASS lossless_jpeg_load_raw()
 {
-  int jwide, jrow, jcol, val, jidx, i, j, row=0, col=0;
+  int jwide, jrow, jcol, val, jidx, i, j, row=0, col=0, nblack=0;
+  double dark[2] = { 0,0 };
   struct jhead jh;
   int min=INT_MAX;
+  ushort *rp;
 
   if (!ljpeg_start (&jh, 0)) return;
   jwide = jh.wide * jh.clrs;
 
   for (jrow=0; jrow < jh.high; jrow++) {
-    ljpeg_row (jrow, &jh);
+    rp = ljpeg_row (jrow, &jh);
     for (jcol=0; jcol < jwide; jcol++) {
-      val = jh.row[jcol];
+      val = *rp++;
       if (jh.bits <= 12)
-	val = curve[val];
+	val = curve[val & 0xfff];
       if (cr2_slice[0]) {
 	jidx = jrow*jwide + jcol;
 	i = jidx / (cr2_slice[1]*jh.high);
@@ -872,30 +929,99 @@
 	row = jidx / cr2_slice[1+j];
 	col = jidx % cr2_slice[1+j] + i*cr2_slice[1];
       }
+      if (raw_width == 3984 && (col -= 2) < 0)
+	col += (row--,raw_width);
       if ((unsigned) (row-top_margin) < height) {
 	if ((unsigned) (col-left_margin) < width) {
 	  BAYER(row-top_margin,col-left_margin) = val;
 	  if (min > val) min = val;
-	} else black += val;
+	} else if (col > 1 && (unsigned) (col-left_margin+2) > width+3)
+	  dark[(col-left_margin) & 1] += (nblack++,val);
       }
       if (++col >= raw_width)
 	col = (row++,0);
     }
   }
-  free (jh.row);
-  if (raw_width > width)
-    black /= (raw_width - width) * height;
+  ljpeg_end (&jh);
+  canon_black (dark, nblack);
   if (!strcasecmp(make,"KODAK"))
     black = min;
 }
 
+void CLASS canon_sraw_load_raw()
+{
+  struct jhead jh;
+  short *rp=0, (*ip)[4];
+  int jwide, slice, scol, ecol, row, col, jrow=0, jcol=0, pix[3], c;
+  int v[3]={0,0,0}, ver, hue;
+  char *cp;
+
+  if (!ljpeg_start (&jh, 0)) return;
+  jwide = (jh.wide >>= 1) * jh.clrs;
+
+  for (ecol=slice=0; slice <= cr2_slice[0]; slice++) {
+    scol = ecol;
+    ecol += cr2_slice[1] * 2 / jh.clrs;
+    if (!cr2_slice[0] || ecol > raw_width-1) ecol = raw_width & -2;
+    for (row=0; row < height; row += (jh.clrs >> 1) - 1) {
+      ip = (short (*)[4]) image + row*width;
+      for (col=scol; col < ecol; col+=2, jcol+=jh.clrs) {
+	if ((jcol %= jwide) == 0)
+	  rp = (short *) ljpeg_row (jrow++, &jh);
+	if (col >= width) continue;
+	FORC (jh.clrs-2)
+	  ip[col + (c >> 1)*width + (c & 1)][0] = rp[jcol+c];
+	ip[col][1] = rp[jcol+jh.clrs-2] - 16384;
+	ip[col][2] = rp[jcol+jh.clrs-1] - 16384;
+      }
+    }
+  }
+  for (cp=model2; *cp && !isdigit(*cp); cp++);
+  sscanf (cp, "%d.%d.%d", v, v+1, v+2);
+  ver = (v[0]*1000 + v[1])*1000 + v[2];
+  hue = (jh.sraw+1) << 2;
+  if (unique_id == 0x80000218 && ver > 1000006 && ver < 3000000)
+    hue = jh.sraw << 1;
+  ip = (short (*)[4]) image;
+  rp = ip[0];
+  for (row=0; row < height; row++, ip+=width) {
+    if (row & (jh.sraw >> 1))
+      for (col=0; col < width; col+=2)
+	for (c=1; c < 3; c++)
+	  if (row == height-1)
+	       ip[col][c] =  ip[col-width][c];
+	  else ip[col][c] = (ip[col-width][c] + ip[col+width][c] + 1) >> 1;
+    for (col=1; col < width; col+=2)
+      for (c=1; c < 3; c++)
+	if (col == width-1)
+	     ip[col][c] =  ip[col-1][c];
+	else ip[col][c] = (ip[col-1][c] + ip[col+1][c] + 1) >> 1;
+  }
+  for ( ; rp < ip[0]; rp+=4) {
+    if (unique_id < 0x80000200) {
+      pix[0] = rp[0] + rp[2] - 512;
+      pix[2] = rp[0] + rp[1] - 512;
+      pix[1] = rp[0] + ((-778*rp[1] - (rp[2] << 11)) >> 12) - 512;
+    } else {
+      rp[1] = (rp[1] << 2) + hue;
+      rp[2] = (rp[2] << 2) + hue;
+      pix[0] = rp[0] + ((  200*rp[1] + 22929*rp[2]) >> 14);
+      pix[1] = rp[0] + ((-5640*rp[1] - 11751*rp[2]) >> 14);
+      pix[2] = rp[0] + ((29040*rp[1] -   101*rp[2]) >> 14);
+    }
+    FORC3 rp[c] = CLIP(pix[c] * sraw_mul[c] >> 10);
+  }
+  ljpeg_end (&jh);
+  maximum = 0x3fff;
+}
+
 void CLASS adobe_copy_pixel (int row, int col, ushort **rp)
 {
   unsigned r, c;
 
   r = row -= top_margin;
   c = col -= left_margin;
-  if (fuji_secondary && shot_select) (*rp)++;
+  if (is_raw == 2 && shot_select) (*rp)++;
   if (filters) {
     if (fuji_width) {
       r = row + fuji_width - 1 - (col >> 1);
@@ -903,47 +1029,42 @@
     }
     if (r < height && c < width)
       BAYER(r,c) = **rp < 0x1000 ? curve[**rp] : **rp;
-    *rp += 1 + fuji_secondary;
+    *rp += is_raw;
   } else {
     if (r < height && c < width)
-      for (c=0; c < tiff_samples; c++)
+      FORC(tiff_samples)
 	image[row*width+col][c] = (*rp)[c] < 0x1000 ? curve[(*rp)[c]]:(*rp)[c];
     *rp += tiff_samples;
   }
-  if (fuji_secondary && shot_select) (*rp)--;
+  if (is_raw == 2 && shot_select) (*rp)--;
 }
 
 void CLASS adobe_dng_load_raw_lj()
 {
-  int save, twide, trow=0, tcol=0, jrow, jcol;
+  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;
   struct jhead jh;
   ushort *rp;
 
-  while (1) {
+  while (trow < raw_height) {
     save = ftell(ifp);
-    fseek (ifp, get4(), SEEK_SET);
+    if (tile_length < INT_MAX)
+      fseek (ifp, get4(), SEEK_SET);
     if (!ljpeg_start (&jh, 0)) break;
-    if (trow >= raw_height) break;
-    if (jh.high > raw_height-trow)
-	jh.high = raw_height-trow;
-    twide = jh.wide;
-    if (filters) twide *= jh.clrs;
-    else         colors = jh.clrs;
-    if (fuji_secondary) twide /= 2;
-    if (twide > raw_width-tcol)
-	twide = raw_width-tcol;
-
-    for (jrow=0; jrow < jh.high; jrow++) {
-      ljpeg_row (jrow, &jh);
-      for (rp=jh.row, jcol=0; jcol < twide; jcol++)
-	adobe_copy_pixel (trow+jrow, tcol+jcol, &rp);
+    jwide = jh.wide;
+    if (filters) jwide *= jh.clrs;
+    jwide /= is_raw;
+    for (row=col=jrow=0; jrow < jh.high; jrow++) {
+      rp = ljpeg_row (jrow, &jh);
+      for (jcol=0; jcol < jwide; jcol++) {
+	adobe_copy_pixel (trow+row, tcol+col, &rp);
+	if (++col >= tile_width || col >= raw_width)
+	  row += 1 + (col = 0);
+      }
     }
     fseek (ifp, save+4, SEEK_SET);
-    if ((tcol += twide) >= raw_width) {
-      tcol = 0;
-      trow += jh.high;
-    }
-    free (jh.row);
+    if ((tcol += tile_width) >= raw_width)
+      trow += tile_length + (tcol = 0);
+    ljpeg_end (&jh);
   }
 }
 
@@ -968,91 +1089,96 @@
   free (pixel);
 }
 
-void CLASS pentax_k10_load_raw()
+void CLASS pentax_load_raw()
 {
-  static const uchar pentax_tree[] =
-  { 0,2,3,1,1,1,1,1,1,2,0,0,0,0,0,0,
-    3,4,2,5,1,6,0,7,8,9,10,11,12 };
-  int row, col, diff, i;
-  ushort vpred[4] = {0,0,0,0}, hpred[2];
+  ushort bit[2][13], huff[4097];
+  int row, col, diff, c, i;
+  ushort vpred[2][2] = {{0,0},{0,0}}, hpred[2];
 
-  init_decoder();
-  make_decoder (pentax_tree, 0);
+  fseek (ifp, meta_offset, SEEK_SET);
+  FORC(13) bit[0][c] = get2();
+  FORC(13) bit[1][c] = fgetc(ifp);
+  FORC(13)
+    for (i=bit[0][c]; i <= ((bit[0][c]+(4096 >> bit[1][c])-1) & 4095); )
+      huff[++i] = bit[1][c] << 8 | c;
+  huff[0] = 12;
+  fseek (ifp, data_offset, SEEK_SET);
   getbits(-1);
-  for (row=0; row < height; row++)
+  for (row=0; row < raw_height; row++)
     for (col=0; col < raw_width; col++) {
-      diff = ljpeg_diff (first_decode);
-      if (col < 2) {
-	i = 2*(row & 1) + (col & 1);
-	vpred[i] += diff;
-	hpred[col] = vpred[i];
-      } else
-	hpred[col & 1] += diff;
-      if (col < width)
-	BAYER(row,col) = hpred[col & 1];
+      diff = ljpeg_diff (huff);
+      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
+      else	   hpred[col & 1] += diff;
+      if ((unsigned) (row-top_margin) < height && col < width)
+	BAYER(row-top_margin,col) = hpred[col & 1];
+      if (hpred[col & 1] >> 12) derror();
     }
 }
 
 void CLASS nikon_compressed_load_raw()
 {
-  static const uchar nikon_tree[] =
-  { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,
-    5,4,3,6,2,7,1,0,8,9,11,10,12 };
-  int csize, row, col, diff, i;
-  ushort vpred[4], hpred[2], *curve;
-
-  init_decoder();
-  make_decoder (nikon_tree, 0);
-
-  fseek (ifp, curve_offset, SEEK_SET);
-  read_shorts (vpred, 4);
-  csize = get2();
-  curve = (ushort *) calloc (csize, sizeof *curve);
-  merror (curve, "nikon_compressed_load_raw()");
-  read_shorts (curve, csize);
+  static const uchar nikon_tree[][32] = {
+    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy */
+      5,4,3,6,2,7,1,0,8,9,11,10,12 },
+    { 0,1,5,1,1,1,1,1,1,2,0,0,0,0,0,0,	/* 12-bit lossy after split */
+      0x39,0x5a,0x38,0x27,0x16,5,4,3,2,1,0,11,12,12 },
+    { 0,1,4,2,3,1,2,0,0,0,0,0,0,0,0,0,  /* 12-bit lossless */
+      5,4,6,3,7,2,8,1,9,0,10,11,12 },
+    { 0,1,4,3,1,1,1,1,1,2,0,0,0,0,0,0,	/* 14-bit lossy */
+      5,6,4,7,8,3,9,2,1,0,10,11,12,13,14 },
+    { 0,1,5,1,1,1,1,1,1,1,2,0,0,0,0,0,	/* 14-bit lossy after split */
+      8,0x5c,0x4b,0x3a,0x29,7,6,5,4,3,2,1,0,13,14 },
+    { 0,1,4,2,2,3,1,2,0,0,0,0,0,0,0,0,	/* 14-bit lossless */
+      7,6,8,5,9,4,10,3,11,12,2,0,1,13,14 } };
+  ushort *huff, ver0, ver1, vpred[2][2], hpred[2], csize;
+  int i, min, max, step=0, tree=0, split=0, row, col, len, shl, diff;
 
+  fseek (ifp, meta_offset, SEEK_SET);
+  ver0 = fgetc(ifp);
+  ver1 = fgetc(ifp);
+  if (ver0 == 0x49 || ver1 == 0x58)
+    fseek (ifp, 2110, SEEK_CUR);
+  if (ver0 == 0x46) tree = 2;
+  if (tiff_bps == 14) tree += 3;
+  read_shorts (vpred[0], 4);
+  max = 1 << tiff_bps & 0x7fff;
+  if ((csize = get2()) > 1)
+    step = max / (csize-1);
+  if (ver0 == 0x44 && ver1 == 0x20 && step > 0) {
+    for (i=0; i < csize; i++)
+      curve[i*step] = get2();
+    for (i=0; i < max; i++)
+      curve[i] = ( curve[i-i%step]*(step-i%step) +
+		   curve[i-i%step+step]*(i%step) ) / step;
+    fseek (ifp, meta_offset+562, SEEK_SET);
+    split = get2();
+  } else if (ver0 != 0x46 && csize <= 0x4001)
+    read_shorts (curve, max=csize);
+  while (curve[max-2] == curve[max-1]) max--;
+  huff = make_decoder (nikon_tree[tree]);
   fseek (ifp, data_offset, SEEK_SET);
   getbits(-1);
-  for (row=0; row < height; row++)
-    for (col=0; col < raw_width; col++) {
-      diff = ljpeg_diff (first_decode);
-      if (col < 2) {
-	i = 2*(row & 1) + (col & 1);
-	vpred[i] += diff;
-	hpred[col] = vpred[i];
-      } else
-	hpred[col & 1] += diff;
-      if ((unsigned) (col-left_margin) >= width) continue;
-      diff = hpred[col & 1];
-      if (diff >= csize) diff = csize-1;
-      BAYER(row,col-left_margin) = curve[diff];
-    }
-  free (curve);
-}
-
-void CLASS nikon_load_raw()
-{
-  int irow, row, col, i;
-
-  getbits(-1);
-  for (irow=0; irow < height; irow++) {
-    row = irow;
-    if (make[0] == 'O' || model[0] == 'E') {
-      row = irow * 2 % height + irow / (height/2);
-      if (row == 1 && data_offset == 0) {
-	fseek (ifp, 0, SEEK_END);
-	fseek (ifp, ftell(ifp)/2, SEEK_SET);
-	getbits(-1);
-      }
+  for (min=row=0; row < height; row++) {
+    if (split && row == split) {
+      free (huff);
+      huff = make_decoder (nikon_tree[tree+1]);
+      max += (min = 16) << 1;
     }
     for (col=0; col < raw_width; col++) {
-      i = getbits(12);
+      i = gethuff(huff);
+      len = i & 15;
+      shl = i >> 4;
+      diff = ((getbits(len-shl) << 1) + 1) << shl >> 1;
+      if ((diff & (1 << (len-1))) == 0)
+	diff -= (1 << len) - !shl;
+      if (col < 2) hpred[col] = vpred[row & 1][col] += diff;
+      else	   hpred[col & 1] += diff;
+      if ((ushort)(hpred[col & 1] + min) >= max) derror();
       if ((unsigned) (col-left_margin) < width)
-	BAYER(row,col-left_margin) = i;
-      if (tiff_compress == 34713 && (col % 10) == 9)
-	getbits(8);
+	BAYER(row,col-left_margin) = curve[LIM((short)hpred[col & 1],0,0x3fff)];
     }
   }
+  free (huff);
 }
 
 /*
@@ -1065,10 +1191,6 @@
   uchar test[256];
   int i;
 
-  if (tiff_compress != 34713)
-    return 0;
-  if (strcmp(model,"D100"))
-    return 1;
   fseek (ifp, data_offset, SEEK_SET);
   fread (test, 1, 256, ifp);
   for (i=15; i < 256; i+=16)
@@ -1140,58 +1262,14 @@
  */
 int CLASS minolta_z2()
 {
-  int i;
+  int i, nz;
   char tail[424];
 
   fseek (ifp, -sizeof tail, SEEK_END);
   fread (tail, 1, sizeof tail, ifp);
-  for (i=0; i < sizeof tail; i++)
-    if (tail[i]) return 1;
-  return 0;
-}
-
-/* Here raw_width is in bytes, not pixels. */
-void CLASS nikon_e900_load_raw()
-{
-  int offset=0, irow, row, col;
-
-  for (irow=0; irow < height; irow++) {
-    row = irow * 2 % height;
-    if (row == 1)
-      offset = - (-offset & -4096);
-    fseek (ifp, offset, SEEK_SET);
-    offset += raw_width;
-    getbits(-1);
-    for (col=0; col < width; col++)
-      BAYER(row,col) = getbits(10);
-  }
-}
-
-void CLASS nikon_e2100_load_raw()
-{
-  uchar   data[3456], *dp;
-  ushort pixel[2304], *pix;
-  int row, col;
-
-  for (row=0; row <= height; row+=2) {
-    if (row == height) {
-      fseek (ifp, ((width==1616) << 13) - (-ftell(ifp) & -2048), SEEK_SET);
-      row = 1;
-    }
-    fread (data, 1, width*3/2, ifp);
-    for (dp=data, pix=pixel; pix < pixel+width; dp+=12, pix+=8) {
-      pix[0] = (dp[2] >> 4) + (dp[ 3] << 4);
-      pix[1] = (dp[2] << 8) +  dp[ 1];
-      pix[2] = (dp[7] >> 4) + (dp[ 0] << 4);
-      pix[3] = (dp[7] << 8) +  dp[ 6];
-      pix[4] = (dp[4] >> 4) + (dp[ 5] << 4);
-      pix[5] = (dp[4] << 8) +  dp[11];
-      pix[6] = (dp[9] >> 4) + (dp[10] << 4);
-      pix[7] = (dp[9] << 8) +  dp[ 8];
-    }
-    for (col=0; col < width; col++)
-      BAYER(row,col) = (pixel[col] & 0xfff);
-  }
+  for (nz=i=0; i < sizeof tail; i++)
+    if (tail[i]) nz++;
+  return nz > 20;
 }
 
 /*
@@ -1200,14 +1278,16 @@
 void CLASS fuji_load_raw()
 {
   ushort *pixel;
-  int row, col, r, c;
+  int wide, row, col, r, c;
 
   fseek (ifp, (top_margin*raw_width + left_margin) * 2, SEEK_CUR);
-  pixel = (ushort *) calloc (raw_width, sizeof *pixel);
+  wide = fuji_width << !fuji_layout;
+  pixel = (ushort *) calloc (wide, sizeof *pixel);
   merror (pixel, "fuji_load_raw()");
   for (row=0; row < raw_height; row++) {
-    read_shorts (pixel, raw_width);
-    for (col=0; col < fuji_width << !fuji_layout; col++) {
+    read_shorts (pixel, wide);
+    fseek (ifp, 2*(raw_width - wide), SEEK_CUR);
+    for (col=0; col < wide; col++) {
       if (fuji_layout) {
 	r = fuji_width - 1 - col + (row >> 1);
 	c = col + ((row+1) >> 1);
@@ -1221,56 +1301,51 @@
   free (pixel);
 }
 
-void CLASS jpeg_thumb (FILE *tfp)
-{
-  unsigned char *thumb = (unsigned char *) malloc (thumb_length);
-  merror (thumb, "jpeg_thumb()");
-  fread  (thumb, 1, thumb_length, ifp);
-  thumb[0] = 0xff;
-  fwrite (thumb, 1, thumb_length, tfp);
-  free (thumb);
-}
+void CLASS jpeg_thumb();
 
-void CLASS ppm_thumb (FILE *tfp)
+void CLASS ppm_thumb()
 {
   char *thumb;
   thumb_length = thumb_width*thumb_height*3;
   thumb = (char *) malloc (thumb_length);
   merror (thumb, "ppm_thumb()");
-  fprintf (tfp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
+  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
   fread  (thumb, 1, thumb_length, ifp);
-  fwrite (thumb, 1, thumb_length, tfp);
+  fwrite (thumb, 1, thumb_length, ofp);
   free (thumb);
 }
 
-void CLASS layer_thumb (FILE *tfp)
+void CLASS layer_thumb()
 {
   int i, c;
   char *thumb, map[][4] = { "012","102" };
 
   colors = thumb_misc >> 5 & 7;
   thumb_length = thumb_width*thumb_height;
-  thumb = (char *) malloc (thumb_length*colors);
+  thumb = (char *) calloc (colors, thumb_length);
   merror (thumb, "layer_thumb()");
-  fprintf (tfp, "P%d\n%d %d\n255\n",
+  fprintf (ofp, "P%d\n%d %d\n255\n",
 	5 + (colors >> 1), thumb_width, thumb_height);
   fread (thumb, thumb_length, colors, ifp);
   for (i=0; i < thumb_length; i++)
-    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], tfp);
+    FORCC putc (thumb[i+thumb_length*(map[thumb_misc >> 8][c]-'0')], ofp);
   free (thumb);
 }
 
-void CLASS rollei_thumb (FILE *tfp)
+void CLASS rollei_thumb()
 {
-  int i, size = thumb_width * thumb_height;
-  ushort *thumb = (ushort *) calloc (size, 2);
+  unsigned i;
+  ushort *thumb;
+
+  thumb_length = thumb_width * thumb_height;
+  thumb = (ushort *) calloc (thumb_length, 2);
   merror (thumb, "rollei_thumb()");
-  fprintf (tfp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
-  read_shorts (thumb, size);
-  for (i=0; i < size; i++) {
-    putc (thumb[i] << 3, tfp);
-    putc (thumb[i] >> 5  << 2, tfp);
-    putc (thumb[i] >> 11 << 3, tfp);
+  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
+  read_shorts (thumb, thumb_length);
+  for (i=0; i < thumb_length; i++) {
+    putc (thumb[i] << 3, ofp);
+    putc (thumb[i] >> 5  << 2, ofp);
+    putc (thumb[i] >> 11 << 3, ofp);
   }
   free (thumb);
 }
@@ -1359,9 +1434,9 @@
     { {-1,-1}, {-1,1}, {1,-1}, {1,1}, {-2,0}, {0,-2}, {0,2}, {2,0},
       {-2,-2}, {-2,2}, {2,-2}, {2,2} };
   float poly[8], num, cfrac, frac, mult[2], *yval[2];
-  ushort curve[0x10000], *xval[2];
+  ushort *xval[2];
 
-  if (shrink || !meta_length) return;
+  if (half_size || !meta_length) return;
   if (verbose) fprintf (stderr,_("Phase One correction...\n"));
   fseek (ifp, meta_offset, SEEK_SET);
   order = get2();
@@ -1441,7 +1516,7 @@
   }
   if (off_412) {
     fseek (ifp, off_412, SEEK_SET);
-    for (i=0; i < 9; i++) head[i] = get4();
+    for (i=0; i < 9; i++) head[i] = get4() & 0x7fff;
     yval[0] = (float *) calloc (head[1]*head[3] + head[2]*head[4], 6);
     merror (yval[0], "phase_one_correct()");
     yval[1] = (float  *) (yval[0] + head[1]*head[3]);
@@ -1501,20 +1576,29 @@
   phase_one_correct();
 }
 
-unsigned CLASS ph1_bits (int nbits)
+unsigned CLASS ph1_bithuff (int nbits, ushort *huff)
 {
   static UINT64 bitbuf=0;
   static int vbits=0;
+  unsigned c;
 
-  if (nbits == 0)
+  if (nbits == -1)
     return bitbuf = vbits = 0;
+  if (nbits == 0) return 0;
   if (vbits < nbits) {
-    bitbuf = bitbuf << 32 | (unsigned) get4();
+    bitbuf = bitbuf << 32 | get4();
     vbits += 32;
   }
+  c = bitbuf << (64-vbits) >> (64-nbits);
+  if (huff) {
+    vbits -= huff[c] >> 8;
+    return (uchar) huff[c];
+  }
   vbits -= nbits;
-  return bitbuf << (64 - nbits - vbits) >> (64 - nbits);
+  return c;
 }
+#define ph1_bits(n) ph1_bithuff(n,0)
+#define ph1_huff(h) ph1_bithuff(*h,h+1)
 
 void CLASS phase_one_load_raw_c()
 {
@@ -1537,7 +1621,7 @@
     curve[i] = i*i / 3.969 + 0.5;
   for (row=0; row < raw_height; row++) {
     fseek (ifp, data_offset + offset[row], SEEK_SET);
-    ph1_bits(0);
+    ph1_bits(-1);
     pred[0] = pred[1] = 0;
     for (col=0; col < raw_width; col++) {
       if (col >= (raw_width & -8))
@@ -1551,6 +1635,7 @@
 	pixel[col] = pred[col & 1] = ph1_bits(16);
       else
 	pixel[col] = pred[col & 1] += ph1_bits(i) + 1 - (1 << (i - 1));
+      if (pred[col & 1] >> 16) derror();
       if (ph1.format == 5 && pixel[col] < 256)
 	pixel[col] = curve[pixel[col]];
     }
@@ -1566,6 +1651,33 @@
   maximum = 0xfffc - ph1.black;
 }
 
+void CLASS hasselblad_load_raw()
+{
+  struct jhead jh;
+  int row, col, pred[2], len[2], diff, c;
+
+  if (!ljpeg_start (&jh, 0)) return;
+  order = 0x4949;
+  ph1_bits(-1);
+  for (row=-top_margin; row < height; row++) {
+    pred[0] = pred[1] = 0x8000;
+    for (col=-left_margin; col < raw_width-left_margin; col+=2) {
+      FORC(2) len[c] = ph1_huff(jh.huff[0]);
+      FORC(2) {
+	diff = ph1_bits(len[c]);
+	if ((diff & (1 << (len[c]-1))) == 0)
+	  diff -= (1 << len[c]) - 1;
+	if (diff == 65535) diff = -32768;
+	pred[c] += diff;
+	if (row >= 0 && (unsigned)(col+c) < width)
+	  BAYER(row,col+c) = pred[c];
+      }
+    }
+  }
+  ljpeg_end (&jh);
+  maximum = 0xffff;
+}
+
 void CLASS leaf_hdr_load_raw()
 {
   ushort *pixel;
@@ -1573,7 +1685,7 @@
 
   pixel = (ushort *) calloc (raw_width, sizeof *pixel);
   merror (pixel, "leaf_hdr_load_raw()");
-  for (c=0; c < tiff_samples; c++) {
+  FORC(tiff_samples)
     for (r=0; r < raw_height; r++) {
       if (r % tile_length == 0) {
 	fseek (ifp, data_offset + 4*tile++, SEEK_SET);
@@ -1586,7 +1698,6 @@
 	if (filters)  BAYER(row,col) = pixel[col];
 	else image[row*width+col][c] = pixel[col];
     }
-  }
   free (pixel);
   if (!filters) {
     maximum = 0xffff;
@@ -1601,7 +1712,7 @@
   ushort *pixel;
   unsigned shot, row, col, r, c;
 
-  if ((shot = shot_select) || shrink) {
+  if ((shot = shot_select) || half_size) {
     if (shot) shot--;
     if (shot > 3) shot = 3;
     fseek (ifp, data_offset + shot*4, SEEK_SET);
@@ -1609,6 +1720,10 @@
     unpacked_load_raw();
     return;
   }
+  free (image);
+  image = (ushort (*)[4])
+	calloc ((iheight=height)*(iwidth=width), sizeof *image);
+  merror (image, "sinar_4shot_load_raw()");
   pixel = (ushort *) calloc (raw_width, sizeof *pixel);
   merror (pixel, "sinar_4shot_load_raw()");
   for (shot=0; shot < 4; shot++) {
@@ -1624,7 +1739,7 @@
     }
   }
   free (pixel);
-  filters = 0;
+  shrink = filters = 0;
 }
 
 void CLASS imacon_full_load_raw()
@@ -1636,75 +1751,175 @@
       read_shorts (image[row*width+col], 3);
 }
 
-/* Here raw_width is in bytes, not pixels. */
-void CLASS packed_12_load_raw()
+void CLASS packed_load_raw()
 {
-  int row, col;
+  int vbits=0, bwide, pwide, rbits, bite, half, irow, row, col, val, i;
+  UINT64 bitbuf=0;
 
-  getbits(-1);
-  for (row=0; row < height; row++) {
-    for (col=0; col < width; col++)
-      BAYER(row,col) = getbits(12);
-    for (col = width*3/2; col < raw_width; col++)
-      getbits(8);
+  if (raw_width * 8 >= width * tiff_bps)	/* Is raw_width in bytes? */
+       pwide = (bwide = raw_width) * 8 / tiff_bps;
+  else bwide = (pwide = raw_width) * tiff_bps / 8;
+  rbits = bwide * 8 - pwide * tiff_bps;
+  if (load_flags & 1) bwide = bwide * 16 / 15;
+  fseek (ifp, top_margin*bwide, SEEK_CUR);
+  bite = 8 + (load_flags & 24);
+  half = (height+1) >> 1;
+  for (irow=0; irow < height; irow++) {
+    row = irow;
+    if (load_flags & 2 &&
+	(row = irow % half * 2 + irow / half) == 1 &&
+	load_flags & 4) {
+      if (vbits=0, tiff_compress)
+	fseek (ifp, data_offset - (-half*bwide & -2048), SEEK_SET);
+      else {
+	fseek (ifp, 0, SEEK_END);
+	fseek (ifp, ftell(ifp) >> 3 << 2, SEEK_SET);
+      }
+    }
+    for (col=0; col < pwide; col++) {
+      for (vbits -= tiff_bps; vbits < 0; vbits += bite) {
+	bitbuf <<= bite;
+	for (i=0; i < bite; i+=8)
+	  bitbuf |= (unsigned) (fgetc(ifp) << i);
+      }
+      val = bitbuf << (64-tiff_bps-vbits) >> (64-tiff_bps);
+      i = (col ^ (bite == 24)) - left_margin;
+      if ((unsigned) i < width)
+	BAYER(row,i) = val << (load_flags >> 6);
+      else if (load_flags & 32)
+	black += val;
+      if (load_flags & 1 && (col % 10) == 9 &&
+	fgetc(ifp) && col < width+left_margin) derror();
+    }
+    vbits -= rbits;
   }
+  if (load_flags & 32 && pwide > width)
+    black /= (pwide - width) * height;
 }
 
 void CLASS unpacked_load_raw()
 {
   ushort *pixel;
-  int row, col;
+  int row, col, bits=0;
 
+  while (1 << ++bits < maximum);
   fseek (ifp, (top_margin*raw_width + left_margin) * 2, SEEK_CUR);
-  pixel = (ushort *) calloc (raw_width, sizeof *pixel);
+  pixel = (ushort *) calloc (width, sizeof *pixel);
   merror (pixel, "unpacked_load_raw()");
   for (row=0; row < height; row++) {
-    read_shorts (pixel, raw_width);
+    read_shorts (pixel, width);
+    fseek (ifp, 2*(raw_width - width), SEEK_CUR);
     for (col=0; col < width; col++)
-      BAYER2(row,col) = pixel[col];
+      if ((BAYER2(row,col) = pixel[col]) >> bits) derror();
   }
   free (pixel);
 }
 
-void CLASS olympus_e300_load_raw()
+void CLASS nokia_load_raw()
 {
   uchar  *data,  *dp;
   ushort *pixel, *pix;
-  int dwide, row, col;
+  int dwide, row, c;
 
-  dwide = raw_width * 16 / 10;
+  dwide = raw_width * 5 / 4;
   data = (uchar *) malloc (dwide + raw_width*2);
-  merror (data, "olympus_e300_load_raw()");
+  merror (data, "nokia_load_raw()");
   pixel = (ushort *) (data + dwide);
-  for (row=0; row < height; row++) {
-    fread (data, 1, dwide, ifp);
-    for (dp=data, pix=pixel; pix < pixel+raw_width; dp+=3, pix+=2) {
-      if (((dp-data) & 15) == 15) dp++;
-      pix[0] = dp[1] << 8 | dp[0];
-      pix[1] = dp[2] << 4 | dp[1] >> 4;
-    }
-    for (col=0; col < width; col++)
-      BAYER(row,col) = (pixel[col] & 0xfff);
+  for (row=0; row < raw_height; row++) {
+    if (fread (data, 1, dwide, ifp) < dwide) derror();
+    for (dp=data, pix=pixel; pix < pixel+raw_width; dp+=5, pix+=4)
+      FORC4 pix[c] = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);
+    if (row < top_margin)
+      FORC(width) black += pixel[c];
+    else
+      FORC(width) BAYER(row-top_margin,c) = pixel[c];
   }
   free (data);
-  maximum = 0xfff;
-  black >>= 4;
+  if (top_margin) black /= top_margin * width;
+  maximum = 0x3ff;
 }
 
-void CLASS olympus_cseries_load_raw()
+unsigned CLASS pana_bits (int nbits)
 {
-  int irow, row, col;
+  static uchar buf[0x4000];
+  static int vbits;
+  int byte;
 
-  for (irow=0; irow < height; irow++) {
-    row = irow * 2 % height + irow / (height/2);
-    if (row < 2) {
-      fseek (ifp, data_offset - row*(-width*height*3/4 & -2048), SEEK_SET);
-      getbits(-1);
+  if (!nbits) return vbits=0;
+  if (!vbits) {
+    fread (buf+load_flags, 1, 0x4000-load_flags, ifp);
+    fread (buf, 1, load_flags, ifp);
+  }
+  vbits = (vbits - nbits) & 0x1ffff;
+  byte = vbits >> 3 ^ 0x3ff0;
+  return (buf[byte] | buf[byte+1] << 8) >> (vbits & 7) & ~(-1 << nbits);
+}
+
+void CLASS panasonic_load_raw()
+{
+  int row, col, i, j, sh=0, pred[2], nonz[2];
+
+  pana_bits(0);
+  for (row=0; row < height; row++)
+    for (col=0; col < raw_width; col++) {
+      if ((i = col % 14) == 0)
+	pred[0] = pred[1] = nonz[0] = nonz[1] = 0;
+      if (i % 3 == 2) sh = 4 >> (3 - pana_bits(2));
+      if (nonz[i & 1]) {
+	if ((j = pana_bits(8))) {
+	  if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)
+	       pred[i & 1] &= ~(-1 << sh);
+	  pred[i & 1] += j << sh;
+	}
+      } else if ((nonz[i & 1] = pana_bits(8)) || i > 11)
+	pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);
+      if (col < width)
+	if ((BAYER(row,col) = pred[col & 1]) > 4098) derror();
+    }
+}
+
+void CLASS olympus_load_raw()
+{
+  ushort huff[4096];
+  int row, col, nbits, sign, low, high, i, c, w, n, nw;
+  int acarry[2][3], *carry, pred, diff;
+
+  huff[n=0] = 0xc0c;
+  for (i=12; i--; )
+    FORC(2048 >> i) huff[++n] = (i+1) << 8 | i;
+  fseek (ifp, 7, SEEK_CUR);
+  getbits(-1);
+  for (row=0; row < height; row++) {
+    memset (acarry, 0, sizeof acarry);
+    for (col=0; col < raw_width; col++) {
+      carry = acarry[col & 1];
+      i = 2 * (carry[2] < 3);
+      for (nbits=2+i; (ushort) carry[0] >> (nbits+i); nbits++);
+      low = (sign = getbits(3)) & 3;
+      sign = sign << 29 >> 31;
+      if ((high = getbithuff(12,huff)) == 12)
+	high = getbits(16-nbits) >> 1;
+      carry[0] = (high << nbits) | getbits(nbits);
+      diff = (carry[0] ^ sign) + carry[1];
+      carry[1] = (diff*3 + carry[1]) >> 5;
+      carry[2] = carry[0] > 16 ? 0 : carry[2]+1;
+      if (col >= width) continue;
+      if (row < 2 && col < 2) pred = 0;
+      else if (row < 2) pred = BAYER(row,col-2);
+      else if (col < 2) pred = BAYER(row-2,col);
+      else {
+	w  = BAYER(row,col-2);
+	n  = BAYER(row-2,col);
+	nw = BAYER(row-2,col-2);
+	if ((w < nw && nw < n) || (n < nw && nw < w)) {
+	  if (ABS(w-nw) > 32 || ABS(n-nw) > 32)
+	    pred = w + n - nw;
+	  else pred = (w + n) >> 1;
+	} else pred = ABS(w-nw) > ABS(n-nw) ? w : n;
+      }
+      if ((BAYER(row,col) = pred + ((diff << 2) | low)) >> 12) derror();
     }
-    for (col=0; col < width; col++)
-      BAYER(row,col) = getbits(12);
   }
-  black >>= 4;
 }
 
 void CLASS minolta_rd175_load_raw()
@@ -1713,7 +1928,7 @@
   unsigned irow, box, row, col;
 
   for (irow=0; irow < 1481; irow++) {
-    fread (pixel, 1, 768, ifp);
+    if (fread (pixel, 1, 768, ifp) < 768) derror();
     box = irow / 82;
     row = irow % 82 * 12 + ((box < 12) ? box | 1 : (box-12)*2);
     switch (irow) {
@@ -1735,80 +1950,83 @@
   maximum = 0xff << 1;
 }
 
-void CLASS eight_bit_load_raw()
+void CLASS quicktake_100_load_raw()
 {
-  uchar *pixel;
-  int row, col;
+  uchar pixel[484][644];
+  static const short gstep[16] =
+  { -89,-60,-44,-32,-22,-15,-8,-2,2,8,15,22,32,44,60,89 };
+  static const short rstep[6][4] =
+  { {  -3,-1,1,3  }, {  -5,-1,1,5  }, {  -8,-2,2,8  },
+    { -13,-3,3,13 }, { -19,-4,4,19 }, { -28,-6,6,28 } };
+  static const short curve[256] =
+  { 0,1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
+    28,29,30,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,53,
+    54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,74,75,76,77,78,
+    79,80,81,82,83,84,86,88,90,92,94,97,99,101,103,105,107,110,112,114,116,
+    118,120,123,125,127,129,131,134,136,138,140,142,144,147,149,151,153,155,
+    158,160,162,164,166,168,171,173,175,177,179,181,184,186,188,190,192,195,
+    197,199,201,203,205,208,210,212,214,216,218,221,223,226,230,235,239,244,
+    248,252,257,261,265,270,274,278,283,287,291,296,300,305,309,313,318,322,
+    326,331,335,339,344,348,352,357,361,365,370,374,379,383,387,392,396,400,
+    405,409,413,418,422,426,431,435,440,444,448,453,457,461,466,470,474,479,
+    483,487,492,496,500,508,519,531,542,553,564,575,587,598,609,620,631,643,
+    654,665,676,687,698,710,721,732,743,754,766,777,788,799,810,822,833,844,
+    855,866,878,889,900,911,922,933,945,956,967,978,989,1001,1012,1023 };
+  int rb, row, col, sharp, val=0;
 
-  pixel = (uchar *) calloc (raw_width, sizeof *pixel);
-  merror (pixel, "eight_bit_load_raw()");
-  for (row=0; row < height; row++) {
-    fread (pixel, 1, raw_width, ifp);
-    for (col=0; col < width; col++)
-      BAYER(row,col) = pixel[col];
-  }
-  free (pixel);
-  maximum = 0xff;
-}
-
-void CLASS casio_qv5700_load_raw()
-{
-  uchar  data[3232],  *dp;
-  ushort pixel[2576], *pix;
-  int row, col;
-
-  for (row=0; row < height; row++) {
-    fread (data, 1, 3232, ifp);
-    for (dp=data, pix=pixel; dp < data+3220; dp+=5, pix+=4) {
-      pix[0] = (dp[0] << 2) + (dp[1] >> 6);
-      pix[1] = (dp[1] << 4) + (dp[2] >> 4);
-      pix[2] = (dp[2] << 6) + (dp[3] >> 2);
-      pix[3] = (dp[3] << 8) + (dp[4]     );
+  getbits(-1);
+  memset (pixel, 0x80, sizeof pixel);
+  for (row=2; row < height+2; row++) {
+    for (col=2+(row & 1); col < width+2; col+=2) {
+      val = ((pixel[row-1][col-1] + 2*pixel[row-1][col+1] +
+		pixel[row][col-2]) >> 2) + gstep[getbits(4)];
+      pixel[row][col] = val = LIM(val,0,255);
+      if (col < 4)
+	pixel[row][col-2] = pixel[row+1][~row & 1] = val;
+      if (row == 2)
+	pixel[row-1][col+1] = pixel[row-1][col+3] = val;
+    }
+    pixel[row][col] = val;
+  }
+  for (rb=0; rb < 2; rb++)
+    for (row=2+rb; row < height+2; row+=2)
+      for (col=3-(row & 1); col < width+2; col+=2) {
+	if (row < 4 || col < 4) sharp = 2;
+	else {
+	  val = ABS(pixel[row-2][col] - pixel[row][col-2])
+	      + ABS(pixel[row-2][col] - pixel[row-2][col-2])
+	      + ABS(pixel[row][col-2] - pixel[row-2][col-2]);
+	  sharp = val <  4 ? 0 : val <  8 ? 1 : val < 16 ? 2 :
+		  val < 32 ? 3 : val < 48 ? 4 : 5;
+	}
+	val = ((pixel[row-2][col] + pixel[row][col-2]) >> 1)
+	      + rstep[sharp][getbits(2)];
+	pixel[row][col] = val = LIM(val,0,255);
+	if (row < 4) pixel[row-2][col+2] = val;
+	if (col < 4) pixel[row+2][col-2] = val;
+      }
+  for (row=2; row < height+2; row++)
+    for (col=3-(row & 1); col < width+2; col+=2) {
+      val = ((pixel[row][col-1] + (pixel[row][col] << 2) +
+	      pixel[row][col+1]) >> 1) - 0x100;
+      pixel[row][col] = LIM(val,0,255);
     }
+  for (row=0; row < height; row++)
     for (col=0; col < width; col++)
-      BAYER(row,col) = (pixel[col] & 0x3ff);
-  }
-  maximum = 0x3fc;
+      BAYER(row,col) = curve[pixel[row+2][col+2]];
+  maximum = 0x3ff;
 }
 
-void CLASS nucore_load_raw()
-{
-  ushort *pixel;
-  int irow, row, col;
-
-  pixel = (ushort *) calloc (width, 2);
-  merror (pixel, "nucore_load_raw()");
-  for (irow=0; irow < height; irow++) {
-    read_shorts (pixel, width);
-    row = irow/2 + height/2 * (irow & 1);
-    for (col=0; col < width; col++)
-      BAYER(row,col) = pixel[col];
-  }
-  free (pixel);
-}
+#define radc_token(tree) ((signed char) getbithuff(8,huff[tree]))
 
-const int * CLASS make_decoder_int (const int *source, int level)
-{
-  struct decode *cur;
+#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)
 
-  cur = free_decode++;
-  if (level < source[0]) {
-    cur->branch[0] = free_decode;
-    source = make_decoder_int (source, level+1);
-    cur->branch[1] = free_decode;
-    source = make_decoder_int (source, level+1);
-  } else {
-    cur->leaf = source[1];
-    source += 2;
-  }
-  return source;
-}
+#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \
+: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)
 
-int CLASS radc_token (int tree)
+void CLASS kodak_radc_load_raw()
 {
-  int t;
-  static struct decode *dstart[18], *dindex;
-  static const int *s, source[] = {
+  static const char src[] = {
     1,1, 2,3, 3,4, 4,2, 5,7, 6,5, 7,6, 7,8,
     1,0, 2,1, 3,3, 4,4, 5,2, 6,7, 7,6, 8,5, 8,8,
     2,1, 2,3, 3,0, 3,2, 3,4, 4,6, 5,5, 6,7, 6,8,
@@ -1828,34 +2046,21 @@
     2,-1, 2,13, 2,26, 3,39, 4,-16, 5,55, 6,-37, 6,76,
     2,-26, 2,-13, 2,1, 3,-39, 4,16, 5,-55, 6,-76, 6,37
   };
-
-  if (free_decode == first_decode)
-    for (s=source, t=0; t < 18; t++) {
-      dstart[t] = free_decode;
-      s = make_decoder_int (s, 0);
-    }
-  if (tree == 18) {
-    if (kodak_cbpp == 243)
-      return (getbits(6) << 2) + 2;	/* most DC50 photos */
-    else
-      return (getbits(5) << 3) + 4;	/* DC40, Fotoman Pixtura */
-  }
-  for (dindex = dstart[tree]; dindex->branch[0]; )
-    dindex = dindex->branch[getbits(1)];
-  return dindex->leaf;
-}
-
-#define FORYX for (y=1; y < 3; y++) for (x=col+1; x >= col; x--)
-
-#define PREDICTOR (c ? (buf[c][y-1][x] + buf[c][y][x+1]) / 2 \
-: (buf[c][y-1][x+1] + 2*buf[c][y-1][x] + buf[c][y][x+1]) / 4)
-
-void CLASS kodak_radc_load_raw()
-{
+  ushort huff[19][256];
   int row, col, tree, nreps, rep, step, i, c, s, r, x, y, val;
   short last[3] = { 16,16,16 }, mul[3], buf[3][3][386];
+  static const ushort pt[] =
+    { 0,0, 1280,1344, 2320,3616, 3328,8000, 4095,16383, 65535,16383 };
 
-  init_decoder();
+  for (i=2; i < 12; i+=2)
+    for (c=pt[i-2]; c <= pt[i]; c++)
+      curve[c] = (float)
+	(c-pt[i-2]) / (pt[i]-pt[i-2]) * (pt[i+1]-pt[i-1]) + pt[i-1] + 0.5;
+  for (s=i=0; i < sizeof src; i+=2)
+    FORC(256 >> src[i])
+      huff[0][s++] = src[i] << 8 | (uchar) src[i+1];
+  s = kodak_cbpp == 243 ? 2 : 3;
+  FORC(256) huff[18][c] = (8-s) << 8 | c >> s << s | 1 << (s-1);
   getbits(-1);
   for (i=0; i < sizeof(buf)/sizeof(short); i++)
     buf[0][0][i] = 2048;
@@ -1875,7 +2080,7 @@
 	  if ((tree = radc_token(tree))) {
 	    col -= 2;
 	    if (tree == 8)
-	      FORYX buf[c][y][x] = radc_token(tree+10) * mul[c];
+	      FORYX buf[c][y][x] = (uchar) radc_token(18) * mul[c];
 	    else
 	      FORYX buf[c][y][x] = radc_token(tree+10) * 16 + PREDICTOR;
 	  } else
@@ -1895,10 +2100,8 @@
 	  for (x=0; x < width/2; x++) {
 	    val = (buf[c][y+1][x] << 4) / mul[c];
 	    if (val < 0) val = 0;
-	    if (c)
-	      BAYER(row+y*2+c-1,x*2+2-c) = val;
-	    else
-	      BAYER(row+r*2+y,x*2+y) = val;
+	    if (c) BAYER(row+y*2+c-1,x*2+2-c) = val;
+	    else   BAYER(row+r*2+y,x*2+y) = val;
 	  }
 	memcpy (buf[c][0]+!c, buf[c][2], sizeof buf[c][0]-2*!c);
       }
@@ -1906,12 +2109,16 @@
     for (y=row; y < row+4; y++)
       for (x=0; x < width; x++)
 	if ((x+y) & 1) {
-	  val = (BAYER(y,x)-2048)*2 + (BAYER(y,x-1)+BAYER(y,x+1))/2;
+	  r = x ? x-1 : x+1;
+	  s = x+1 < width ? x+1 : x-1;
+	  val = (BAYER(y,x)-2048)*2 + (BAYER(y,r)+BAYER(y,s))/2;
 	  if (val < 0) val = 0;
 	  BAYER(y,x) = val;
 	}
   }
-  maximum = 10000;
+  for (i=0; i < iheight*iwidth*4; i++)
+    image[0][i] = curve[image[0][i]];
+  maximum = 0x3fff;
 }
 
 #undef FORYX
@@ -1983,7 +2190,7 @@
   int row, shift, col;
 
   for (row=0; row < height; row++) {
-    fread (pixel, 848, 1, ifp);
+    if (fread (pixel, 1, 848, ifp) < 848) derror();
     shift = row * mul[row & 3] + add[row & 3];
     for (col=0; col < width; col++)
       BAYER(row,col) = (ushort) pixel[(col + shift) % 848];
@@ -1991,53 +2198,71 @@
   maximum = 0xff;
 }
 
-void CLASS kodak_easy_load_raw()
+void CLASS eight_bit_load_raw()
 {
   uchar *pixel;
-  unsigned row, col, val;
+  unsigned row, col, val, lblack=0;
 
-  if (raw_width > width)
-    black = 0;
   pixel = (uchar *) calloc (raw_width, sizeof *pixel);
-  merror (pixel, "kodak_easy_load_raw()");
+  merror (pixel, "eight_bit_load_raw()");
+  fseek (ifp, top_margin*raw_width, SEEK_CUR);
   for (row=0; row < height; row++) {
-    fread (pixel, 1, raw_width, ifp);
+    if (fread (pixel, 1, raw_width, ifp) < raw_width) derror();
     for (col=0; col < raw_width; col++) {
       val = curve[pixel[col]];
       if ((unsigned) (col-left_margin) < width)
         BAYER(row,col-left_margin) = val;
-      else black += val;
+      else lblack += val;
     }
   }
   free (pixel);
-  if (raw_width > width)
-    black /= (raw_width - width) * height;
+  if (raw_width > width+1)
+    black = lblack / ((raw_width - width) * height);
   if (!strncmp(model,"DC2",3))
     black = 0;
   maximum = curve[0xff];
 }
 
+void CLASS kodak_yrgb_load_raw()
+{
+  uchar *pixel;
+  int row, col, y, cb, cr, rgb[3], c;
+
+  pixel = (uchar *) calloc (raw_width, 3*sizeof *pixel);
+  merror (pixel, "kodak_yrgb_load_raw()");
+  for (row=0; row < height; row++) {
+    if (~row & 1)
+      if (fread (pixel, raw_width, 3, ifp) < 3) derror();
+    for (col=0; col < raw_width; col++) {
+      y  = pixel[width*2*(row & 1) + col];
+      cb = pixel[width + (col & -2)]   - 128;
+      cr = pixel[width + (col & -2)+1] - 128;
+      rgb[1] = y-((cb + cr + 2) >> 2);
+      rgb[2] = rgb[1] + cb;
+      rgb[0] = rgb[1] + cr;
+      FORC3 image[row*width+col][c] = curve[LIM(rgb[c],0,255)];
+    }
+  }
+  free (pixel);
+  maximum = curve[0xff];
+}
+
 void CLASS kodak_262_load_raw()
 {
   static const uchar kodak_tree[2][26] =
   { { 0,1,5,1,1,2,0,0,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 },
     { 0,3,1,1,1,1,1,2,0,0,0,0,0,0,0,0, 0,1,2,3,4,5,6,7,8,9 } };
-  struct decode *decode[2];
+  ushort *huff[2];
   uchar *pixel;
-  int *strip, ns, i, row, col, chess, pi=0, pi1, pi2, pred, val;
+  int *strip, ns, c, row, col, chess, pi=0, pi1, pi2, pred, val;
 
-  init_decoder();
-  for (i=0; i < 2; i++) {
-    decode[i] = free_decode;
-    make_decoder (kodak_tree[i], 0);
-  }
+  FORC(2) huff[c] = make_decoder (kodak_tree[c]);
   ns = (raw_height+63) >> 5;
   pixel = (uchar *) malloc (raw_width*32 + ns*4);
   merror (pixel, "kodak_262_load_raw()");
   strip = (int *) (pixel + raw_width*32);
   order = 0x4d4d;
-  for (i=0; i < ns; i++)
-    strip[i] = get4();
+  FORC(ns) strip[c] = get4();
   for (row=0; row < raw_height; row++) {
     if ((row & 31) == 0) {
       fseek (ifp, strip[row >> 5], SEEK_SET);
@@ -2053,7 +2278,8 @@
       if (pi2 < 0) pi2 = pi1;
       if (pi1 < 0 && col > 1) pi1 = pi2 = pi-2;
       pred = (pi1 < 0) ? 0 : (pixel[pi1] + pixel[pi2]) >> 1;
-      pixel[pi] = pred + ljpeg_diff (decode[chess]);
+      pixel[pi] = val = pred + ljpeg_diff (huff[chess]);
+      if (val >> 8) derror();
       val = curve[pixel[pi++]];
       if ((unsigned) (col-left_margin) < width)
 	BAYER(row,col-left_margin) = val;
@@ -2061,6 +2287,7 @@
     }
   }
   free (pixel);
+  FORC(2) free (huff[c]);
   if (raw_width > width)
     black /= (raw_width - width) * height;
 }
@@ -2122,7 +2349,8 @@
       len = MIN (256, width-col);
       ret = kodak_65000_decode (buf, len);
       for (i=0; i < len; i++)
-	BAYER(row,col+i) = curve[ret ? buf[i] : (pred[i & 1] += buf[i])];
+	if ((BAYER(row,col+i) =	curve[ret ? buf[i] :
+		(pred[i & 1] += buf[i])]) >> 12) derror();
     }
 }
 
@@ -2145,7 +2373,7 @@
 	rgb[0] = rgb[1] + cr;
 	for (j=0; j < 2; j++)
 	  for (k=0; k < 2; k++) {
-	    y[j][k] = y[j][k^1] + *bp++;
+	    if ((y[j][k] = y[j][k^1] + *bp++) >> 10) derror();
 	    ip = image[(row+j)*width + col+i+k];
 	    FORC3 ip[c] = curve[LIM(y[j][k]+rgb[c], 0, 0xfff)];
 	  }
@@ -2165,7 +2393,7 @@
       kodak_65000_decode (buf, len*3);
       memset (rgb, 0, sizeof rgb);
       for (bp=buf, i=0; i < len; i++, ip+=4)
-	FORC3 ip[c] = (rgb[c] += *bp++) & 0xfff;
+	FORC3 if ((ip[c] = rgb[c] += *bp++) >> 12) derror();
     }
 }
 
@@ -2215,12 +2443,13 @@
   pixel = (ushort *) calloc (raw_width, sizeof *pixel);
   merror (pixel, "sony_load_raw()");
   for (row=0; row < height; row++) {
-    fread (pixel, 2, raw_width, ifp);
+    if (fread (pixel, 2, raw_width, ifp) < raw_width) derror();
     sony_decrypt ((unsigned int *) pixel, raw_width/2, !row, key);
     for (col=9; col < left_margin; col++)
       black += ntohs(pixel[col]);
     for (col=0; col < width; col++)
-      BAYER(row,col) = ntohs(pixel[col+left_margin]);
+      if ((BAYER(row,col) = ntohs(pixel[col+left_margin])) >> 14)
+	derror();
   }
   free (pixel);
   if (left_margin > 9)
@@ -2230,24 +2459,59 @@
 
 void CLASS sony_arw_load_raw()
 {
-  int col, row, len, diff, sum=0;
+  ushort huff[32768];
+  static const ushort tab[18] =
+  { 0xf11,0xf10,0xe0f,0xd0e,0xc0d,0xb0c,0xa0b,0x90a,0x809,
+    0x708,0x607,0x506,0x405,0x304,0x303,0x300,0x202,0x201 };
+  int i, c, n, col, row, len, diff, sum=0;
 
+  for (n=i=0; i < 18; i++)
+    FORC(32768 >> (tab[i] >> 8)) huff[n++] = tab[i];
   getbits(-1);
   for (col = raw_width; col--; )
     for (row=0; row < raw_height+1; row+=2) {
       if (row == raw_height) row = 1;
-      len = 4 - getbits(2);
-      if (len == 3 && getbits(1)) len = 0;
-      if (len == 4)
-	while (len < 17 && !getbits(1)) len++;
+      len = getbithuff(15,huff);
       diff = getbits(len);
       if ((diff & (1 << (len-1))) == 0)
 	diff -= (1 << len) - 1;
-      sum += diff;
+      if ((sum += diff) >> 12) derror();
       if (row < height) BAYER(row,col) = sum;
     }
 }
 
+void CLASS sony_arw2_load_raw()
+{
+  uchar *data, *dp;
+  ushort pix[16];
+  int row, col, val, max, min, imax, imin, sh, bit, i;
+
+  data = (uchar *) malloc (raw_width);
+  merror (data, "sony_arw2_load_raw()");
+  for (row=0; row < height; row++) {
+    fread (data, 1, raw_width, ifp);
+    for (dp=data, col=0; col < width-30; dp+=16) {
+      max = 0x7ff & (val = sget4(dp));
+      min = 0x7ff & val >> 11;
+      imax = 0x0f & val >> 22;
+      imin = 0x0f & val >> 26;
+      for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
+      for (bit=30, i=0; i < 16; i++)
+	if      (i == imax) pix[i] = max;
+	else if (i == imin) pix[i] = min;
+	else {
+	  pix[i] = ((sget2(dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;
+	  if (pix[i] > 0x7ff) pix[i] = 0x7ff;
+	  bit += 7;
+	}
+      for (i=0; i < 16; i++, col+=2)
+	BAYER(row,col) = curve[pix[i] << 1] >> 1;
+      col -= col & 1 ? 1:31;
+    }
+  }
+  free (data);
+}
+
 #define HOLE(row) ((holes >> (((row) - raw_height) & 7)) & 1)
 
 /* Kudos to Rich Taylor for figuring out SMaL's compression algorithm. */
@@ -2327,7 +2591,6 @@
   seg[1][0] = raw_width * raw_height;
   seg[1][1] = INT_MAX;
   smal_decode_segment (seg, 0);
-  use_gamma = 0;
 }
 
 int CLASS median4 (int *p)
@@ -2389,7 +2652,7 @@
   if (holes) fill_holes (holes);
 }
 
-/* BEGIN GPL BLOCK */
+/* RESTRICTED code starts here */
 
 void CLASS foveon_decoder (unsigned size, unsigned code)
 {
@@ -2400,7 +2663,8 @@
   if (!code) {
     for (i=0; i < size; i++)
       huff[i] = get4();
-    init_decoder();
+    memset (first_decode, 0, sizeof first_decode);
+    free_decode = first_decode;
   }
   cur = free_decode++;
   if (free_decode > first_decode+2048) {
@@ -2422,22 +2686,22 @@
   foveon_decoder (size, code+1);
 }
 
-void CLASS foveon_thumb (FILE *tfp)
+void CLASS foveon_thumb()
 {
-  int bwide, row, col, bit=-1, c, i;
+  unsigned bwide, row, col, bitbuf=0, bit=1, c, i;
   char *buf;
   struct decode *dindex;
   short pred[3];
-  unsigned bitbuf=0;
 
   bwide = get4();
-  fprintf (tfp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
+  fprintf (ofp, "P6\n%d %d\n255\n", thumb_width, thumb_height);
   if (bwide > 0) {
+    if (bwide < thumb_width*3) return;
     buf = (char *) malloc (bwide);
     merror (buf, "foveon_thumb()");
     for (row=0; row < thumb_height; row++) {
       fread  (buf, 1, bwide, ifp);
-      fwrite (buf, 3, thumb_width, tfp);
+      fwrite (buf, 3, thumb_width, ofp);
     }
     free (buf);
     return;
@@ -2447,7 +2711,7 @@
   for (row=0; row < thumb_height; row++) {
     memset (pred, 0, sizeof pred);
     if (!bit) get4();
-    for (col=bit=0; col < thumb_width; col++)
+    for (bit=col=0; col < thumb_width; col++)
       FORC3 {
 	for (dindex=first_decode; dindex->branch[0]; ) {
 	  if ((bit = (bit-1) & 31) == 31)
@@ -2456,7 +2720,7 @@
 	  dindex = dindex->branch[bitbuf >> bit & 1];
 	}
 	pred[c] += dindex->leaf;
-	fputc (pred[c], tfp);
+	fputc (pred[c], ofp);
       }
   }
 }
@@ -2478,9 +2742,9 @@
 void CLASS foveon_load_raw()
 {
   struct decode *dindex;
-  short diff[1024], pred[3];
+  short diff[1024];
   unsigned bitbuf=0;
-  int fixed, row, col, bit=-1, c, i;
+  int pred[3], fixed, row, col, bit=-1, c, i;
 
   fixed = get4();
   read_shorts ((ushort *) diff, 1024);
@@ -2488,7 +2752,7 @@
 
   for (row=0; row < height; row++) {
     memset (pred, 0, sizeof pred);
-    if (!bit && !fixed) get4();
+    if (!bit && !fixed && atoi(model+2) < 14) get4();
     for (col=bit=0; col < width; col++) {
       if (fixed) {
 	bitbuf = get4();
@@ -2502,6 +2766,7 @@
 	  dindex = dindex->branch[bitbuf >> bit & 1];
 	}
 	pred[c] += diff[dindex->leaf];
+	if (pred[c] >> 16 && ~pred[c] >> 16) derror();
       }
       FORC3 image[row*width+col][c] = pred[c];
     }
@@ -2531,13 +2796,14 @@
 	return dp+sget4(cp+4);
     }
   }
-  return NULL;
+  return 0;
 }
 
-void * CLASS foveon_camf_matrix (int dim[3], const char *name)
+void * CLASS foveon_camf_matrix (unsigned dim[3], const char *name)
 {
   unsigned i, idx, type, ndim, size, *mat;
   char *pos, *cp, *dp;
+  double dsize;
 
   for (idx=0; idx < meta_length; idx += sget4(pos+8)) {
     pos = meta_data + idx;
@@ -2553,8 +2819,8 @@
       cp += 12;
       dim[i] = sget4(cp);
     }
-    if ((size = dim[0]*dim[1]*dim[2]) > meta_length/4) break;
-    mat = (unsigned *) malloc (size * 4);
+    if ((dsize = (double) dim[0]*dim[1]*dim[2]) > meta_length/4) break;
+    mat = (unsigned *) malloc ((size = dsize) * 4);
     merror (mat, "foveon_camf_matrix()");
     for (i=0; i < size; i++)
       if (type && type != 6)
@@ -2564,13 +2830,13 @@
     return mat;
   }
   fprintf (stderr,_("%s: \"%s\" matrix not found!\n"), ifname, name);
-  return NULL;
+  return 0;
 }
 
 int CLASS foveon_fixed (void *ptr, int size, const char *name)
 {
   void *dp;
-  int dim[3];
+  unsigned dim[3];
 
   dp = foveon_camf_matrix (dim, name);
   if (!dp) return 0;
@@ -2589,17 +2855,19 @@
     if (min > val) min = val;
     if (max < val) max = val;
   }
+  if (range[1] - range[0] == 1) return sum/2;
   return (sum - min - max) / (range[1] - range[0] - 1);
 }
 
 short * CLASS foveon_make_curve (double max, double mul, double filt)
 {
   short *curve;
-  int i, size;
+  unsigned i, size;
   double x;
 
   if (!filt) filt = 0.8;
   size = 4*M_PI*max / filt;
+  if (size == UINT_MAX) size--;
   curve = (short *) calloc (size+1, sizeof *curve);
   merror (curve, "foveon_make_curve()");
   curve[0] = size;
@@ -2639,10 +2907,10 @@
   float (*black)[3], (*sgain)[3], (*sgrow)[3];
   float fsum[3], val, frow, num;
   int row, col, c, i, j, diff, sgx, irow, sum, min, max, limit;
-  int dim[3], dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];
+  int dscr[2][2], dstb[4], (*smrow[7])[3], total[4], ipix[3];
   int work[3][3], smlast, smred, smred_p=0, dev[3];
   int satlev[3], keep[4], active[4];
-  unsigned *badpix;
+  unsigned dim[3], *badpix;
   double dsum=0, trsum[3];
   char str[128];
   const char* cp;
@@ -2684,16 +2952,14 @@
     for (j=0; j < 3; j++)
       FORC3 last[i][j] += correct[i][c] * cam_xyz[c][j];
 
+  #define LAST(x,y) last[(i+x)%3][(c+y)%3]
+  for (i=0; i < 3; i++)
+    FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);
+  #undef LAST
+  FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;
   sprintf (str, "%sRGBNeutral", model2);
   if (foveon_camf_param ("IncludeBlocks", str))
     foveon_fixed (div, 3, str);
-  else {
-    #define LAST(x,y) last[(i+x)%3][(c+y)%3]
-    for (i=0; i < 3; i++)
-      FORC3 diag[c][i] = LAST(1,1)*LAST(2,2) - LAST(1,2)*LAST(2,1);
-    #undef LAST
-    FORC3 div[c] = diag[c][0]*0.3127 + diag[c][1]*0.329 + diag[c][2]*0.3583;
-  }
   num = 0;
   FORC3 if (num < div[c]) num = div[c];
   FORC3 div[c] /= num;
@@ -3028,41 +3294,45 @@
 }
 #undef image
 
-/* END GPL BLOCK */
+/* RESTRICTED code ends here */
 
 /*
    Seach from the current directory up to the root looking for
    a ".badpixels" file, and fix those pixels now.
  */
-void CLASS bad_pixels()
+void CLASS bad_pixels (const char *cfname)
 {
-  FILE *fp=NULL;
+  FILE *fp=0;
   char *fname, *cp, line[128];
   int len, time, row, col, r, c, rad, tot, n, fixed=0;
 
   if (!filters) return;
-  for (len=32 ; ; len *= 2) {
-    fname = (char *) malloc (len);
-    if (!fname) return;
-    if (getcwd (fname, len-16)) break;
-    free (fname);
-    if (errno != ERANGE) return;
-  }
+  if (cfname)
+    fp = fopen (cfname, "r");
+  else {
+    for (len=32 ; ; len *= 2) {
+      fname = (char *) malloc (len);
+      if (!fname) return;
+      if (getcwd (fname, len-16)) break;
+      free (fname);
+      if (errno != ERANGE) return;
+    }
 #if defined(WIN32) || defined(DJGPP)
-  if (fname[1] == ':')
-    memmove (fname, fname+2, len-2);
-  for (cp=fname; *cp; cp++)
-    if (*cp == '\\') *cp = '/';
+    if (fname[1] == ':')
+      memmove (fname, fname+2, len-2);
+    for (cp=fname; *cp; cp++)
+      if (*cp == '\\') *cp = '/';
 #endif
-  cp = fname + strlen(fname);
-  if (cp[-1] == '/') cp--;
-  while (*fname == '/') {
-    strcpy (cp, "/.badpixels");
-    if ((fp = fopen (fname, "r"))) break;
-    if (cp == fname) break;
-    while (*--cp != '/');
+    cp = fname + strlen(fname);
+    if (cp[-1] == '/') cp--;
+    while (*fname == '/') {
+      strcpy (cp, "/.badpixels");
+      if ((fp = fopen (fname, "r"))) break;
+      if (cp == fname) break;
+      while (*--cp != '/');
+    }
+    free (fname);
   }
-  free (fname);
   if (!fp) return;
   while (fgets (line, 128, fp)) {
     cp = strchr (line, '#');
@@ -3081,7 +3351,7 @@
     BAYER2(row,col) = tot/n;
     if (verbose) {
       if (!fixed++)
-	fprintf (stderr,_("Fixed bad pixels at:"));
+	fprintf (stderr,_("Fixed dead pixels at:"));
       fprintf (stderr, " %d,%d", col, row);
     }
   }
@@ -3089,7 +3359,7 @@
   fclose (fp);
 }
 
-void CLASS subtract (char *fname)
+void CLASS subtract (const char *fname)
 {
   FILE *fp;
   int dim[3]={0,0,0}, comment=0, number=0, error=0, nd=0, c, row, col;
@@ -3129,6 +3399,41 @@
   black = 0;
 }
 
+void CLASS gamma_curve (double pwr, double ts, int mode, int imax)
+{
+  int i;
+  double g[6], bnd[2]={0,0}, r;
+
+  g[0] = pwr;
+  g[1] = ts;
+  g[2] = g[3] = g[4] = 0;
+  bnd[g[1] >= 1] = 1;
+  if (g[1] && (g[1]-1)*(g[0]-1) <= 0) {
+    for (i=0; i < 48; i++) {
+      g[2] = (bnd[0] + bnd[1])/2;
+      if (g[0]) bnd[(pow(g[2]/g[1],-g[0]) - 1)/g[0] - 1/g[2] > -1] = g[2];
+      else	bnd[g[2]/exp(1-1/g[2]) < g[1]] = g[2];
+    }
+    g[3] = g[2] / g[1];
+    if (g[0]) g[4] = g[2] * (1/g[0] - 1);
+  }
+  if (g[0]) g[5] = 1 / (g[1]*SQR(g[3])/2 - g[4]*(1 - g[3]) +
+		(1 - pow(g[3],1+g[0]))*(1 + g[4])/(1 + g[0])) - 1;
+  else      g[5] = 1 / (g[1]*SQR(g[3])/2 + 1
+		- g[2] - g[3] -	g[2]*g[3]*(log(g[3]) - 1)) - 1;
+  if (!mode--) {
+    memcpy (gamm, g, sizeof gamm);
+    return;
+  }
+  for (i=0; i < 0x10000; i++) {
+    curve[i] = 0xffff;
+    if ((r = (double) i / imax) < 1)
+      curve[i] = 0x10000 * ( mode
+	? (r < g[3] ? r*g[1] : (g[0] ? pow( r,g[0])*(1+g[4])-g[4]    : log(r)*g[2]+1))
+	: (r < g[2] ? r/g[1] : (g[0] ? pow((r+g[4])/(1+g[4]),1/g[0]) : exp((r-1)/g[2]))));
+  }
+}
+
 void CLASS pseudoinverse (double (*in)[3], double (*out)[3], int size)
 {
   double work[3][6], num;
@@ -3187,31 +3492,7 @@
 #define NSQ 24
 // Coordinates of the GretagMacbeth ColorChecker squares
 // width, height, 1st_column, 1st_row
-  static const int cut[NSQ][4] = {
-    { 241, 231, 234, 274 },
-    { 251, 235, 534, 274 },
-    { 255, 239, 838, 272 },
-    { 255, 240, 1146, 274 },
-    { 251, 237, 1452, 278 },
-    { 243, 238, 1758, 288 },
-    { 253, 253, 218, 558 },
-    { 255, 249, 524, 562 },
-    { 261, 253, 830, 562 },
-    { 260, 255, 1144, 564 },
-    { 261, 255, 1450, 566 },
-    { 247, 247, 1764, 576 },
-    { 255, 251, 212, 862 },
-    { 259, 259, 518, 862 },
-    { 263, 261, 826, 864 },
-    { 265, 263, 1138, 866 },
-    { 265, 257, 1450, 872 },
-    { 257, 255, 1762, 874 },
-    { 257, 253, 212, 1164 },
-    { 262, 251, 516, 1172 },
-    { 263, 257, 826, 1172 },
-    { 263, 255, 1136, 1176 },
-    { 255, 252, 1452, 1182 },
-    { 257, 253, 1760, 1180 } };
+  int cut[NSQ][4];			// you must set these
 // ColorChecker Chart under 6500-kelvin illumination
   static const double gmb_xyY[NSQ][3] = {
     { 0.400, 0.350, 10.1 },		// Dark Skin
@@ -3275,32 +3556,125 @@
 }
 #endif
 
+void CLASS hat_transform (float *temp, float *base, int st, int size, int sc)
+{
+  int i;
+  for (i=0; i < sc; i++)
+    temp[i] = 2*base[st*i] + base[st*(sc-i)] + base[st*(i+sc)];
+  for (; i+sc < size; i++)
+    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(i+sc)];
+  for (; i < size; i++)
+    temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];
+}
+
+void CLASS wavelet_denoise()
+{
+  float *fimg=0, *temp, thold, mul[2], avg, diff;
+  int scale=1, size, lev, hpass, lpass, row, col, nc, c, i, wlast;
+  ushort *window[4];
+  static const float noise[] =
+  { 0.8002,0.2735,0.1202,0.0585,0.0291,0.0152,0.0080,0.0044 };
+
+  if (verbose) fprintf (stderr,_("Wavelet denoising...\n"));
+
+  while (maximum << scale < 0x10000) scale++;
+  maximum <<= --scale;
+  black <<= scale;
+  if ((size = iheight*iwidth) < 0x15550000)
+    fimg = (float *) malloc ((size*3 + iheight + iwidth) * sizeof *fimg);
+  merror (fimg, "wavelet_denoise()");
+  temp = fimg + size*3;
+  if ((nc = colors) == 3 && filters) nc++;
+  FORC(nc) {			/* denoise R,G1,B,G3 individually */
+    for (i=0; i < size; i++)
+      fimg[i] = 256 * sqrt(image[i][c] << scale);
+    for (hpass=lev=0; lev < 5; lev++) {
+      lpass = size*((lev & 1)+1);
+      for (row=0; row < iheight; row++) {
+	hat_transform (temp, fimg+hpass+row*iwidth, 1, iwidth, 1 << lev);
+        for (col=0; col < iwidth; col++)
+	  fimg[lpass + row*iwidth + col] = temp[col] * 0.25;
+      }
+      for (col=0; col < iwidth; col++) {
+	hat_transform (temp, fimg+lpass+col, iwidth, iheight, 1 << lev);
+	for (row=0; row < iheight; row++)
+	  fimg[lpass + row*iwidth + col] = temp[row] * 0.25;
+      }
+      thold = threshold * noise[lev];
+      for (i=0; i < size; i++) {
+	fimg[hpass+i] -= fimg[lpass+i];
+	if	(fimg[hpass+i] < -thold) fimg[hpass+i] += thold;
+	else if (fimg[hpass+i] >  thold) fimg[hpass+i] -= thold;
+	else	 fimg[hpass+i] = 0;
+	if (hpass) fimg[i] += fimg[hpass+i];
+      }
+      hpass = lpass;
+    }
+    for (i=0; i < size; i++)
+      image[i][c] = CLIP(SQR(fimg[i]+fimg[lpass+i])/0x10000);
+  }
+  if (filters && colors == 3) {  /* pull G1 and G3 closer together */
+    for (row=0; row < 2; row++)
+      mul[row] = 0.125 * pre_mul[FC(row+1,0) | 1] / pre_mul[FC(row,0) | 1];
+    for (i=0; i < 4; i++)
+      window[i] = (ushort *) fimg + width*i;
+    for (wlast=-1, row=1; row < height-1; row++) {
+      while (wlast < row+1) {
+	for (wlast++, i=0; i < 4; i++)
+	  window[(i+3) & 3] = window[i];
+	for (col = FC(wlast,1) & 1; col < width; col+=2)
+	  window[2][col] = BAYER(wlast,col);
+      }
+      thold = threshold/512;
+      for (col = (FC(row,0) & 1)+1; col < width-1; col+=2) {
+	avg = ( window[0][col-1] + window[0][col+1] +
+		window[2][col-1] + window[2][col+1] - black*4 )
+	      * mul[row & 1] + (window[1][col] - black) * 0.5 + black;
+	avg = avg < 0 ? 0 : sqrt(avg);
+	diff = sqrt(BAYER(row,col)) - avg;
+	if      (diff < -thold) diff += thold;
+	else if (diff >  thold) diff -= thold;
+	else diff = 0;
+	BAYER(row,col) = CLIP(SQR(avg+diff) + 0.5);
+      }
+    }
+  }
+  free (fimg);
+}
+
 void CLASS scale_colors()
 {
-  int row, col, x, y, c, val, sum[8];
+  unsigned bottom, right, size, row, col, ur, uc, i, x, y, c, sum[8];
+  int val, dark, sat;
   double dsum[8], dmin, dmax;
-  float scale_mul[4];
+  float scale_mul[4], fr, fc;
+  ushort *img=0, *pix;
 
-  maximum -= black;
+  if (user_mul[0])
+    memcpy (pre_mul, user_mul, sizeof pre_mul);
   if (use_auto_wb || (use_camera_wb && cam_mul[0] == -1)) {
     memset (dsum, 0, sizeof dsum);
-    for (row=0; row < height-7; row += 8)
-      for (col=0; col < width-7; col += 8) {
+    bottom = MIN (greybox[1]+greybox[3], height);
+    right  = MIN (greybox[0]+greybox[2], width);
+    for (row=greybox[1]; row < bottom; row += 8)
+      for (col=greybox[0]; col < right; col += 8) {
 	memset (sum, 0, sizeof sum);
-	for (y=row; y < row+8; y++)
-	  for (x=col; x < col+8; x++)
+	for (y=row; y < row+8 && y < bottom; y++)
+	  for (x=col; x < col+8 && x < right; x++)
 	    FORC4 {
-	      val = image[y*width+x][c];
-	      if (!val) continue;
-	      val -= black;
+	      if (filters) {
+		c = FC(y,x);
+		val = BAYER(y,x);
+	      } else
+		val = image[y*width+x][c];
 	      if (val > maximum-25) goto skip_block;
-	      if (val < 0) val = 0;
+	      if ((val -= black) < 0) val = 0;
 	      sum[c] += val;
 	      sum[c+4]++;
+	      if (filters) break;
 	    }
-	for (c=0; c < 8; c++) dsum[c] += sum[c];
-skip_block:
-	continue;
+	FORC(8) dsum[c] += sum[c];
+skip_block: ;
       }
     FORC4 if (dsum[c]) pre_mul[c] = dsum[c+4] / dsum[c];
   }
@@ -3320,9 +3694,11 @@
     else
       fprintf (stderr,_("%s: Cannot use camera white balance.\n"), ifname);
   }
-  if (user_mul[0])
-    memcpy (pre_mul, user_mul, sizeof pre_mul);
   if (pre_mul[3] == 0) pre_mul[3] = colors < 4 ? pre_mul[1] : 1;
+  dark = black;
+  sat = maximum;
+  if (threshold) wavelet_denoise();
+  maximum -= black;
   for (dmin=DBL_MAX, dmax=c=0; c < 4; c++) {
     if (dmin > pre_mul[c])
 	dmin = pre_mul[c];
@@ -3332,30 +3708,79 @@
   if (!highlight) dmax = dmin;
   FORC4 scale_mul[c] = (pre_mul[c] /= dmax) * 65535.0 / maximum;
   if (verbose) {
-    fprintf (stderr,_("Scaling with black %d, multipliers"), black);
+    fprintf (stderr,
+      _("Scaling with darkness %d, saturation %d, and\nmultipliers"), dark, sat);
     FORC4 fprintf (stderr, " %f", pre_mul[c]);
     fputc ('\n', stderr);
   }
-  for (row=0; row < height; row++)
-    for (col=0; col < width; col++)
-      FORC4 {
-	val = image[row*width+col][c];
-	if (!val) continue;
-	val -= black;
-	val *= scale_mul[c];
-	image[row*width+col][c] = CLIP(val);
+  size = iheight*iwidth;
+  for (i=0; i < size*4; i++) {
+    val = image[0][i];
+    if (!val) continue;
+    val -= black;
+    val *= scale_mul[i & 3];
+    image[0][i] = CLIP(val);
+  }
+  if ((aber[0] != 1 || aber[2] != 1) && colors == 3) {
+    if (verbose)
+      fprintf (stderr,_("Correcting chromatic aberration...\n"));
+    for (c=0; c < 4; c+=2) {
+      if (aber[c] == 1) continue;
+      img = (ushort *) malloc (size * sizeof *img);
+      merror (img, "scale_colors()");
+      for (i=0; i < size; i++)
+	img[i] = image[i][c];
+      for (row=0; row < iheight; row++) {
+	ur = fr = (row - iheight*0.5) * aber[c] + iheight*0.5;
+	if (ur > iheight-2) continue;
+	fr -= ur;
+	for (col=0; col < iwidth; col++) {
+	  uc = fc = (col - iwidth*0.5) * aber[c] + iwidth*0.5;
+	  if (uc > iwidth-2) continue;
+	  fc -= uc;
+	  pix = img + ur*iwidth + uc;
+	  image[row*iwidth+col][c] =
+	    (pix[     0]*(1-fc) + pix[       1]*fc) * (1-fr) +
+	    (pix[iwidth]*(1-fc) + pix[iwidth+1]*fc) * fr;
+	}
       }
-  if (filters && colors == 3) {
-    if (four_color_rgb) {
-      colors++;
-      FORC3 rgb_cam[c][3] = rgb_cam[c][1] /= 2;
+      free(img);
+    }
+  }
+}
+
+void CLASS pre_interpolate()
+{
+  ushort (*img)[4];
+  int row, col, c;
+
+  if (shrink) {
+    if (half_size) {
+      height = iheight;
+      width  = iwidth;
     } else {
+      img = (ushort (*)[4]) calloc (height*width, sizeof *img);
+      merror (img, "pre_interpolate()");
+      for (row=0; row < height; row++)
+	for (col=0; col < width; col++) {
+	  c = fc(row,col);
+	  img[row*width+col][c] = image[(row >> 1)*iwidth+(col >> 1)][c];
+	}
+      free (image);
+      image = img;
+      shrink = 0;
+    }
+  }
+  if (filters && colors == 3) {
+    if ((mix_green = four_color_rgb)) colors++;
+    else {
       for (row = FC(1,0) >> 1; row < height; row+=2)
 	for (col = FC(row,1) & 1; col < width; col+=2)
 	  image[row*width+col][1] = image[row*width+col][3];
       filters &= ~((filters & 0x55555555) << 1);
     }
   }
+  if (half_size) filters = 0;
 }
 
 void CLASS border_interpolate (int border)
@@ -3406,7 +3831,7 @@
       FORCC
 	if (c != fc(row,col)) {
 	  *ip++ = c;
-	  *ip++ = sum[c];
+	  *ip++ = 256 / sum[c];
 	}
     }
   for (row=1; row < height-1; row++)
@@ -3417,7 +3842,7 @@
       for (i=8; i--; ip+=3)
 	sum[ip[2]] += pix[ip[0]] << ip[1];
       for (i=colors; --i; ip+=2)
-	pix[ip[0]] = sum[ip[0]] / ip[1];
+	pix[ip[0]] = sum[ip[0]] * ip[1] >> 8;
     }
 }
 
@@ -3557,35 +3982,58 @@
   free (code[0][0]);
 }
 
-void CLASS cam_to_cielab (ushort cam[4], float lab[3])
-{
-  int c, i, j, k;
-  float r, xyz[3];
-  static float cbrt[0x10000], xyz_cam[3][4];
-
-  if (cam == NULL) {
-    for (i=0; i < 0x10000; i++) {
-      r = i / 65535.0;
-      cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
+/*
+   Patterned Pixel Grouping Interpolation by Alain Desbiolles
+*/
+void CLASS ppg_interpolate()
+{
+  int dir[5] = { 1, width, -1, -width, 1 };
+  int row, col, diff[2], guess[2], c, d, i;
+  ushort (*pix)[4];
+
+  border_interpolate(3);
+  if (verbose) fprintf (stderr,_("PPG interpolation...\n"));
+
+/*  Fill in the green layer with gradients and pattern recognition: */
+  for (row=3; row < height-3; row++)
+    for (col=3+(FC(row,3) & 1), c=FC(row,col); col < width-3; col+=2) {
+      pix = image + row*width+col;
+      for (i=0; (d=dir[i]) > 0; i++) {
+	guess[i] = (pix[-d][1] + pix[0][c] + pix[d][1]) * 2
+		      - pix[-2*d][c] - pix[2*d][c];
+	diff[i] = ( ABS(pix[-2*d][c] - pix[ 0][c]) +
+		    ABS(pix[ 2*d][c] - pix[ 0][c]) +
+		    ABS(pix[  -d][1] - pix[ d][1]) ) * 3 +
+		  ( ABS(pix[ 3*d][1] - pix[ d][1]) +
+		    ABS(pix[-3*d][1] - pix[-d][1]) ) * 2;
+      }
+      d = dir[i = diff[0] > diff[1]];
+      pix[0][1] = ULIM(guess[i] >> 2, pix[d][1], pix[-d][1]);
+    }
+/*  Calculate red and blue for each green pixel:		*/
+  for (row=1; row < height-1; row++)
+    for (col=1+(FC(row,2) & 1), c=FC(row,col+1); col < width-1; col+=2) {
+      pix = image + row*width+col;
+      for (i=0; (d=dir[i]) > 0; c=2-c, i++)
+	pix[0][c] = CLIP((pix[-d][c] + pix[d][c] + 2*pix[0][1]
+			- pix[-d][1] - pix[d][1]) >> 1);
+    }
+/*  Calculate blue for red pixels and vice versa:		*/
+  for (row=1; row < height-1; row++)
+    for (col=1+(FC(row,1) & 1), c=2-FC(row,col); col < width-1; col+=2) {
+      pix = image + row*width+col;
+      for (i=0; (d=dir[i]+dir[i+1]) > 0; i++) {
+	diff[i] = ABS(pix[-d][c] - pix[d][c]) +
+		  ABS(pix[-d][1] - pix[0][1]) +
+		  ABS(pix[ d][1] - pix[0][1]);
+	guess[i] = pix[-d][c] + pix[d][c] + 2*pix[0][1]
+		 - pix[-d][1] - pix[d][1];
+      }
+      if (diff[0] != diff[1])
+	pix[0][c] = CLIP(guess[diff[0] > diff[1]] >> 1);
+      else
+	pix[0][c] = CLIP((guess[0]+guess[1]) >> 2);
     }
-    for (i=0; i < 3; i++)
-      for (j=0; j < colors; j++)
-        for (xyz_cam[i][j] = k=0; k < 3; k++)
-	  xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];
-  } else {
-    xyz[0] = xyz[1] = xyz[2] = 0.5;
-    FORCC {
-      xyz[0] += xyz_cam[0][c] * cam[c];
-      xyz[1] += xyz_cam[1][c] * cam[c];
-      xyz[2] += xyz_cam[2][c] * cam[c];
-    }
-    xyz[0] = cbrt[CLIP((int) xyz[0])];
-    xyz[1] = cbrt[CLIP((int) xyz[1])];
-    xyz[2] = cbrt[CLIP((int) xyz[2])];
-    lab[0] = 116 * xyz[1] - 16;
-    lab[1] = 500 * (xyz[0] - xyz[1]);
-    lab[2] = 200 * (xyz[1] - xyz[2]);
-  }
 }
 
 /*
@@ -3596,48 +4044,56 @@
 
 void CLASS ahd_interpolate()
 {
-  int i, j, top, left, row, col, tr, tc, fc, c, d, val, hm[2];
+  int i, j, k, top, left, row, col, tr, tc, c, d, val, hm[2];
   ushort (*pix)[4], (*rix)[3];
   static const int dir[4] = { -1, 1, -TS, TS };
   unsigned ldiff[2][4], abdiff[2][4], leps, abeps;
-  float flab[3];
+  float r, cbrt[0x10000], xyz[3], xyz_cam[3][4];
   ushort (*rgb)[TS][TS][3];
-   short (*lab)[TS][TS][3];
+   short (*lab)[TS][TS][3], (*lix)[3];
    char (*homo)[TS][TS], *buffer;
 
   if (verbose) fprintf (stderr,_("AHD interpolation...\n"));
 
-  border_interpolate(3);
+  for (i=0; i < 0x10000; i++) {
+    r = i / 65535.0;
+    cbrt[i] = r > 0.008856 ? pow(r,1/3.0) : 7.787*r + 16/116.0;
+  }
+  for (i=0; i < 3; i++)
+    for (j=0; j < colors; j++)
+      for (xyz_cam[i][j] = k=0; k < 3; k++)
+	xyz_cam[i][j] += xyz_rgb[i][k] * rgb_cam[k][j] / d65_white[i];
+
+  border_interpolate(5);
   buffer = (char *) malloc (26*TS*TS);		/* 1664 kB */
   merror (buffer, "ahd_interpolate()");
   rgb  = (ushort(*)[TS][TS][3]) buffer;
   lab  = (short (*)[TS][TS][3])(buffer + 12*TS*TS);
   homo = (char  (*)[TS][TS])   (buffer + 24*TS*TS);
 
-  for (top=0; top < height; top += TS-6)
-    for (left=0; left < width; left += TS-6) {
-      memset (rgb, 0, 12*TS*TS);
+  for (top=2; top < height-5; top += TS-6)
+    for (left=2; left < width-5; left += TS-6) {
 
 /*  Interpolate green horizontally and vertically:		*/
-      for (row = top < 2 ? 2:top; row < top+TS && row < height-2; row++) {
-	col = left + (FC(row,left) == 1);
-	if (col < 2) col += 2;
-	for (fc = FC(row,col); col < left+TS && col < width-2; col+=2) {
+      for (row = top; row < top+TS && row < height-2; row++) {
+	col = left + (FC(row,left) & 1);
+	for (c = FC(row,col); col < left+TS && col < width-2; col+=2) {
 	  pix = image + row*width+col;
-	  val = ((pix[-1][1] + pix[0][fc] + pix[1][1]) * 2
-		- pix[-2][fc] - pix[2][fc]) >> 2;
+	  val = ((pix[-1][1] + pix[0][c] + pix[1][1]) * 2
+		- pix[-2][c] - pix[2][c]) >> 2;
 	  rgb[0][row-top][col-left][1] = ULIM(val,pix[-1][1],pix[1][1]);
-	  val = ((pix[-width][1] + pix[0][fc] + pix[width][1]) * 2
-		- pix[-2*width][fc] - pix[2*width][fc]) >> 2;
+	  val = ((pix[-width][1] + pix[0][c] + pix[width][1]) * 2
+		- pix[-2*width][c] - pix[2*width][c]) >> 2;
 	  rgb[1][row-top][col-left][1] = ULIM(val,pix[-width][1],pix[width][1]);
 	}
       }
 /*  Interpolate red and blue, and convert to CIELab:		*/
       for (d=0; d < 2; d++)
-	for (row=top+1; row < top+TS-1 && row < height-1; row++)
-	  for (col=left+1; col < left+TS-1 && col < width-1; col++) {
+	for (row=top+1; row < top+TS-1 && row < height-3; row++)
+	  for (col=left+1; col < left+TS-1 && col < width-3; col++) {
 	    pix = image + row*width+col;
 	    rix = &rgb[d][row-top][col-left];
+	    lix = &lab[d][row-top][col-left];
 	    if ((c = 2 - FC(row,col)) == 1) {
 	      c = FC(row+1,col);
 	      val = pix[0][1] + (( pix[-1][2-c] + pix[1][2-c]
@@ -3653,25 +4109,35 @@
 	    rix[0][c] = CLIP(val);
 	    c = FC(row,col);
 	    rix[0][c] = pix[0][c];
-	    cam_to_cielab (rix[0], flab);
-	    FORC3 lab[d][row-top][col-left][c] = 64*flab[c];
+	    xyz[0] = xyz[1] = xyz[2] = 0.5;
+	    FORCC {
+	      xyz[0] += xyz_cam[0][c] * rix[0][c];
+	      xyz[1] += xyz_cam[1][c] * rix[0][c];
+	      xyz[2] += xyz_cam[2][c] * rix[0][c];
+	    }
+	    xyz[0] = cbrt[CLIP((int) xyz[0])];
+	    xyz[1] = cbrt[CLIP((int) xyz[1])];
+	    xyz[2] = cbrt[CLIP((int) xyz[2])];
+	    lix[0][0] = 64 * (116 * xyz[1] - 16);
+	    lix[0][1] = 64 * 500 * (xyz[0] - xyz[1]);
+	    lix[0][2] = 64 * 200 * (xyz[1] - xyz[2]);
 	  }
 /*  Build homogeneity maps from the CIELab images:		*/
       memset (homo, 0, 2*TS*TS);
-      for (row=top+2; row < top+TS-2 && row < height; row++) {
+      for (row=top+2; row < top+TS-2 && row < height-4; row++) {
 	tr = row-top;
-	for (col=left+2; col < left+TS-2 && col < width; col++) {
+	for (col=left+2; col < left+TS-2 && col < width-4; col++) {
 	  tc = col-left;
-	  for (d=0; d < 2; d++)
-	    for (i=0; i < 4; i++)
-	      ldiff[d][i] = ABS(lab[d][tr][tc][0]-lab[d][tr][tc+dir[i]][0]);
+	  for (d=0; d < 2; d++) {
+	    lix = &lab[d][tr][tc];
+	    for (i=0; i < 4; i++) {
+	       ldiff[d][i] = ABS(lix[0][0]-lix[dir[i]][0]);
+	      abdiff[d][i] = SQR(lix[0][1]-lix[dir[i]][1])
+			   + SQR(lix[0][2]-lix[dir[i]][2]);
+	    }
+	  }
 	  leps = MIN(MAX(ldiff[0][0],ldiff[0][1]),
 		     MAX(ldiff[1][2],ldiff[1][3]));
-	  for (d=0; d < 2; d++)
-	    for (i=0; i < 4; i++)
-	      if (i >> 1 == d || ldiff[d][i] <= leps)
-		abdiff[d][i] = SQR(lab[d][tr][tc][1]-lab[d][tr][tc+dir[i]][1])
-			     + SQR(lab[d][tr][tc][2]-lab[d][tr][tc+dir[i]][2]);
 	  abeps = MIN(MAX(abdiff[0][0],abdiff[0][1]),
 		      MAX(abdiff[1][2],abdiff[1][3]));
 	  for (d=0; d < 2; d++)
@@ -3681,9 +4147,9 @@
 	}
       }
 /*  Combine the most homogenous pixels for the final result:	*/
-      for (row=top+3; row < top+TS-3 && row < height-3; row++) {
+      for (row=top+3; row < top+TS-3 && row < height-5; row++) {
 	tr = row-top;
-	for (col=left+3; col < left+TS-3 && col < width-3; col++) {
+	for (col=left+3; col < left+TS-3 && col < width-5; col++) {
 	  tc = col-left;
 	  for (d=0; d < 2; d++)
 	    for (hm[d]=0, i=tr-1; i <= tr+1; i++)
@@ -3701,61 +4167,69 @@
 }
 #undef TS
 
-/*
-   Bilateral Filtering was developed by C. Tomasi and R. Manduchi.
- */
-void CLASS bilateral_filter()
+void CLASS median_filter()
 {
-  float (**window)[7], *kernel, scale_r, elut[1024], sum[5];
-  int c, i, wr, ws, wlast, row, col, y, x;
-  unsigned sep;
-
-  if (verbose) fprintf (stderr,_("Bilateral filtering...\n"));
-
-  wr = ceil(sigma_d*2);		/* window radius */
-  ws = 2*wr + 1;		/* window size */
-  window = (float (**)[7]) calloc ((ws+1)*sizeof *window +
-		ws*width*sizeof **window + ws*sizeof *kernel, 1);
-  merror (window, "bilateral_filter()");
-  for (i=0; i <= ws; i++)
-    window[i] = (float (*)[7]) (window+ws+1) + i*width;
-  kernel = (float *) window[ws] + wr;
-  for (i=-wr; i <= wr; i++)
-    kernel[i] = 256 / (2*SQR(sigma_d)) * i*i + 0.25;
-  scale_r     = 256 / (2*SQR(sigma_r));
-  for (i=0; i < 1024; i++)
-    elut[i] = exp (-i/256.0);
-
-  for (wlast=-1, row=0; row < height; row++) {
-    while (wlast < row+wr) {
-      wlast++;
-      for (i=0; i <= ws; i++)	/* rotate window rows */
-	window[(ws+i) % (ws+1)] = window[i];
-      if (wlast < height)
-	for (col=0; col < width; col++) {
-	  FORCC window[ws-1][col][c] = image[wlast*width+col][c];
-	  cam_to_cielab (image[wlast*width+col], window[ws-1][col]+4);
-	}
+  ushort (*pix)[4];
+  int pass, c, i, j, k, med[9];
+  static const uchar opt[] =	/* Optimal 9-element median search */
+  { 1,2, 4,5, 7,8, 0,1, 3,4, 6,7, 1,2, 4,5, 7,8,
+    0,3, 5,8, 4,7, 3,6, 1,4, 2,5, 4,7, 4,2, 6,4, 4,2 };
+
+  for (pass=1; pass <= med_passes; pass++) {
+    if (verbose)
+      fprintf (stderr,_("Median filter pass %d...\n"), pass);
+    for (c=0; c < 3; c+=2) {
+      for (pix = image; pix < image+width*height; pix++)
+	pix[0][3] = pix[0][c];
+      for (pix = image+width; pix < image+width*(height-1); pix++) {
+	if ((pix-image+1) % width < 2) continue;
+	for (k=0, i = -width; i <= width; i += width)
+	  for (j = i-1; j <= i+1; j++)
+	    med[k++] = pix[j][3] - pix[j][1];
+	for (i=0; i < sizeof opt; i+=2)
+	  if     (med[opt[i]] > med[opt[i+1]])
+	    SWAP (med[opt[i]] , med[opt[i+1]]);
+	pix[0][c] = CLIP(med[4] + pix[0][1]);
+      }
     }
+  }
+}
+
+void CLASS blend_highlights()
+{
+  int clip=INT_MAX, row, col, c, i, j;
+  static const float trans[2][4][4] =
+  { { { 1,1,1 }, { 1.7320508,-1.7320508,0 }, { -1,-1,2 } },
+    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
+  static const float itrans[2][4][4] =
+  { { { 1,0.8660254,-0.5 }, { 1,-0.8660254,-0.5 }, { 1,0,1 } },
+    { { 1,1,1,1 }, { 1,-1,1,-1 }, { 1,1,-1,-1 }, { 1,-1,-1,1 } } };
+  float cam[2][4], lab[2][4], sum[2], chratio;
+
+  if ((unsigned) (colors-3) > 1) return;
+  if (verbose) fprintf (stderr,_("Blending highlights...\n"));
+  FORCC if (clip > (i = 65535*pre_mul[c])) clip = i;
+  for (row=0; row < height; row++)
     for (col=0; col < width; col++) {
-      memset (sum, 0, sizeof sum);
-      for (y=-wr; y <= wr; y++)
-	if ((unsigned)(row+y) < height)
-	  for (x=-wr; x <= wr; x++)
-	    if ((unsigned)(col+x) < width) {
-	      sep = ( SQR(window[wr+y][col+x][4] - window[wr][col][4])
-		    + SQR(window[wr+y][col+x][5] - window[wr][col][5])
-		    + SQR(window[wr+y][col+x][6] - window[wr][col][6]) )
-			* scale_r + kernel[y] + kernel[x];
-	      if (sep < 1024) {
-		FORCC sum[c] += elut[sep] * window[wr+y][col+x][c];
-		sum[4] += elut[sep];
-	      }
-	    }
-      FORCC image[row*width+col][c] = sum[c]/sum[4];
+      FORCC if (image[row*width+col][c] > clip) break;
+      if (c == colors) continue;
+      FORCC {
+	cam[0][c] = image[row*width+col][c];
+	cam[1][c] = MIN(cam[0][c],clip);
+      }
+      for (i=0; i < 2; i++) {
+	FORCC for (lab[i][c]=j=0; j < colors; j++)
+	  lab[i][c] += trans[colors-3][c][j] * cam[i][j];
+	for (sum[i]=0,c=1; c < colors; c++)
+	  sum[i] += SQR(lab[i][c]);
+      }
+      chratio = sqrt(sum[1]/sum[0]);
+      for (c=1; c < colors; c++)
+	lab[0][c] *= chratio;
+      FORCC for (cam[0][c]=j=0; j < colors; j++)
+	cam[0][c] += itrans[colors-3][c][j] * lab[0][j];
+      FORCC image[row*width+col][c] = cam[0][c] / colors;
     }
-  }
-  free (window);
 }
 
 #define SCALE (4 >> shrink)
@@ -3768,7 +4242,7 @@
   static const signed char dir[8][2] =
     { {-1,-1}, {-1,0}, {-1,1}, {0,1}, {1,1}, {1,0}, {1,-1}, {0,-1} };
 
-  if (verbose) fprintf (stderr,_("Highlight recovery...\n"));
+  if (verbose) fprintf (stderr,_("Rebuilding highlights...\n"));
 
   grow = pow (2, 4-highlight);
   FORCC hsat[c] = 32000 * pre_mul[c];
@@ -3843,7 +4317,7 @@
   *type = get2();
   *len  = get4();
   *save = ftell(ifp) + 4;
-  if (*len * ("1112481124848"[*type < 13 ? *type:0]-'0') > 4)
+  if (*len * ("11124811248488"[*type < 14 ? *type:0]-'0') > 4)
     fseek (ifp, get4()+base, SEEK_SET);
 }
 
@@ -3854,13 +4328,15 @@
   entries = get2();
   while (entries--) {
     tiff_get (base, &tag, &type, &len, &save);
-    if (tag == toff) thumb_offset = get4();
+    if (tag == toff) thumb_offset = get4()+base;
     if (tag == tlen) thumb_length = get4();
     fseek (ifp, save, SEEK_SET);
   }
 }
 
-void CLASS parse_makernote (int base)
+int CLASS parse_tiff_ifd (int base);
+
+void CLASS parse_makernote (int base, int uptag)
 {
   static const uchar xlat[2][256] = {
   { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,
@@ -3896,15 +4372,14 @@
     0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,
     0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };
   unsigned offset=0, entries, tag, type, len, save, c;
-  unsigned ver97=0, serial=0, i, wb[4]={0,0,0,0};
+  unsigned ver97=0, serial=0, i, wbi=0, wb[4]={0,0,0,0};
   uchar buf97[324], ci, cj, ck;
-  short sorder;
+  short sorder=order;
   char buf[10];
 /*
    The MakerNote might have its own TIFF header (possibly with
    its own byte-order!), or it might just be a table.
  */
-  sorder = order;
   fread (buf, 1, 10, ifp);
   if (!strncmp (buf,"KDK" ,3) ||	/* these aren't TIFF tables */
       !strncmp (buf,"VER" ,3) ||
@@ -3928,6 +4403,10 @@
     if (get2() != 42) goto quit;
     offset = get4();
     fseek (ifp, offset-8, SEEK_CUR);
+  } else if (!strcmp (buf,"OLYMPUS")) {
+    base = ftell(ifp)-10;
+    fseek (ifp, -2, SEEK_CUR);
+    order = get2();  get2();
   } else if (!strncmp (buf,"FUJIFILM",8) ||
 	     !strncmp (buf,"SONY",4) ||
 	     !strcmp  (buf,"Panasonic")) {
@@ -3947,31 +4426,55 @@
   if (entries > 1000) return;
   while (entries--) {
     tiff_get (base, &tag, &type, &len, &save);
+    tag |= uptag << 16;
     if (tag == 2 && strstr(make,"NIKON"))
       iso_speed = (get2(),get2());
-    if (tag == 4 && len == 27) {
-      iso_speed = 50 * pow (2, (get4(),get2())/32.0 - 4);
-      aperture = (get2(), pow (2, get2()/64.0));
-      shutter = pow (2, ((short) get2())/-32.0);
+    if (tag == 4 && len > 26 && len < 35) {
+      if ((i=(get4(),get2())) != 0x7fff && !iso_speed)
+	iso_speed = 50 * pow (2, i/32.0 - 4);
+      if ((i=(get2(),get2())) != 0x7fff && !aperture)
+	aperture = pow (2, i/64.0);
+      if ((i=get2()) != 0xffff && !shutter)
+	shutter = pow (2, (short) i/-32.0);
+      wbi = (get2(),get2());
+      shot_order = (get2(),get2());
+    }
+    if ((tag == 4 || tag == 0x114) && !strncmp(make,"KONICA",6)) {
+      fseek (ifp, tag == 4 ? 140:160, SEEK_CUR);
+      switch (get2()) {
+	case 72:  flip = 0;  break;
+	case 76:  flip = 6;  break;
+	case 82:  flip = 5;  break;
+      }
     }
+    if (tag == 7 && type == 2 && len > 20)
+      fgets (model2, 64, ifp);
     if (tag == 8 && type == 4)
       shot_order = get4();
+    if (tag == 9 && !strcmp(make,"Canon"))
+      fread (artist, 64, 1, ifp);
     if (tag == 0xc && len == 4) {
-      cam_mul[0] = getrat();
-      cam_mul[2] = getrat();
+      cam_mul[0] = getreal(type);
+      cam_mul[2] = getreal(type);
     }
     if (tag == 0x10 && type == 4)
       unique_id = get4();
+    if (tag == 0x11 && is_raw && !strncmp(make,"NIKON",5)) {
+      fseek (ifp, get4()+base, SEEK_SET);
+      parse_tiff_ifd (base);
+    }
     if (tag == 0x14 && len == 2560 && type == 7) {
       fseek (ifp, 1248, SEEK_CUR);
       goto get2_256;
     }
+    if (tag == 0x15 && type == 2 && is_raw)
+      fread (model, 64, 1, ifp);
     if (strstr(make,"PENTAX")) {
       if (tag == 0x1b) tag = 0x1018;
       if (tag == 0x1c) tag = 0x1017;
     }
     if (tag == 0x1d)
-      while ((c = fgetc(ifp)))
+      while ((c = fgetc(ifp)) && c != EOF)
 	serial = serial*10 + (isdigit(c) ? c - '0' : c % 10);
     if (tag == 0x81 && type == 4) {
       data_offset = get4();
@@ -3980,6 +4483,11 @@
       raw_width  = get2();
       filters = 0x61616161;
     }
+    if (tag == 0x29 && type == 1) {
+      c = wbi < 18 ? "012347800000005896"[wbi]-'0' : 0;
+      fseek (ifp, 8 + c*32, SEEK_CUR);
+      FORC4 cam_mul[c ^ (c >> 1) ^ 1] = get4();
+    }
     if ((tag == 0x81  && type == 7) ||
 	(tag == 0x100 && type == 7) ||
 	(tag == 0x280 && type == 1)) {
@@ -3990,43 +4498,50 @@
       thumb_offset += base;
     if (tag == 0x89 && type == 4)
       thumb_length = get4();
-    if (tag == 0x8c)
-      curve_offset = ftell(ifp) + 2112;
-    if (tag == 0x96)
-      curve_offset = ftell(ifp) + 2;
+    if (tag == 0x8c || tag == 0x96)
+      meta_offset = ftell(ifp);
     if (tag == 0x97) {
       for (i=0; i < 4; i++)
-	ver97 = (ver97 << 4) + fgetc(ifp)-'0';
+	ver97 = ver97 * 10 + fgetc(ifp)-'0';
       switch (ver97) {
-	case 0x100:
+	case 100:
 	  fseek (ifp, 68, SEEK_CUR);
 	  FORC4 cam_mul[(c >> 1) | ((c & 1) << 1)] = get2();
 	  break;
-	case 0x102:
+	case 102:
 	  fseek (ifp, 6, SEEK_CUR);
 	  goto get2_rggb;
-	case 0x103:
+	case 103:
 	  fseek (ifp, 16, SEEK_CUR);
 	  FORC4 cam_mul[c] = get2();
       }
-      if (ver97 >> 8 == 2) {
-	if (ver97 != 0x205) fseek (ifp, 280, SEEK_CUR);
+      if (ver97 >= 200) {
+	if (ver97 != 205) fseek (ifp, 280, SEEK_CUR);
 	fread (buf97, 324, 1, ifp);
       }
     }
-    if (tag == 0xa7 && ver97 >> 8 == 2) {
+    if (tag == 0xa4 && type == 3) {
+      fseek (ifp, wbi*48, SEEK_CUR);
+      FORC3 cam_mul[c] = get2();
+    }
+    if (tag == 0xa7 && (unsigned) (ver97-200) < 12 && !cam_mul[0]) {
       ci = xlat[0][serial & 0xff];
       cj = xlat[1][fgetc(ifp)^fgetc(ifp)^fgetc(ifp)^fgetc(ifp)];
       ck = 0x60;
       for (i=0; i < 324; i++)
 	buf97[i] ^= (cj += ci * ck++);
-      FORC4 cam_mul[c ^ (c >> 1)] =
-	sget2 (buf97 + (ver97 == 0x205 ? 14:6) + c*2);
+      i = "66666>666;6A"[ver97-200] - '0';
+      FORC4 cam_mul[c ^ (c >> 1) ^ (i & 1)] =
+	sget2 (buf97 + (i & -2) + c*2);
     }
+    if (tag == 0x200 && len == 3)
+      shot_order = (get4(),get4());
     if (tag == 0x200 && len == 4)
       black = (get2()+get2()+get2()+get2())/4;
     if (tag == 0x201 && len == 4)
       goto get2_rggb;
+    if (tag == 0x220 && len == 53)
+      meta_offset = ftell(ifp) + 14;
     if (tag == 0x401 && len == 4) {
       black = (get4()+get4()+get4()+get4())/4;
     }
@@ -4056,17 +4571,15 @@
       else goto next;
       goto get2_256;
     }
-    if (tag == 0x1011 && len == 9 && use_camera_wb) {
+    if ((tag == 0x1011 && len == 9) || tag == 0x20400200)
       for (i=0; i < 3; i++)
-	FORC3 rgb_cam[i][c] = ((short) get2()) / 256.0;
-      raw_color = rgb_cam[0][0] < 1;
-    }
-    if (tag == 0x1012 && len == 4)
+	FORC3 cmatrix[i][c] = ((short) get2()) / 256.0;
+    if ((tag == 0x1012 || tag == 0x20400600) && len == 4)
       for (black = i=0; i < 4; i++)
 	black += get2() << 2;
-    if (tag == 0x1017)
+    if (tag == 0x1017 || tag == 0x20400100)
       cam_mul[0] = get2() / 256.0;
-    if (tag == 0x1018)
+    if (tag == 0x1018 || tag == 0x20400100)
       cam_mul[2] = get2() / 256.0;
     if (tag == 0x2011 && len == 2) {
 get2_256:
@@ -4074,17 +4587,25 @@
       cam_mul[0] = get2() / 256.0;
       cam_mul[2] = get2() / 256.0;
     }
+    if ((tag | 0x70) == 0x2070 && type == 4)
+      fseek (ifp, get4()+base, SEEK_SET);
+    if (tag == 0x2010 && type != 7)
+      load_raw = &CLASS olympus_load_raw;
     if (tag == 0x2020)
       parse_thumb_note (base, 257, 258);
+    if (tag == 0x2040)
+      parse_makernote (base, 0x2040);
     if (tag == 0xb028) {
       fseek (ifp, get4(), SEEK_SET);
       parse_thumb_note (base, 136, 137);
     }
-    if (tag == 0x4001) {
-      i = len == 582 ? 50 : len == 653 ? 68 : len == 796 ? 126 : 0;
+    if (tag == 0x4001 && len > 500) {
+      i = len == 582 ? 50 : len == 653 ? 68 : len == 5120 ? 142 : 126;
       fseek (ifp, i, SEEK_CUR);
 get2_rggb:
       FORC4 cam_mul[c ^ (c >> 1)] = get2();
+      fseek (ifp, 22, SEEK_CUR);
+      FORC4 sraw_mul[c ^ (c >> 1)] = get2();
     }
 next:
     fseek (ifp, save, SEEK_SET);
@@ -4103,7 +4624,6 @@
   char str[20];
   int i;
 
-  if (timestamp) return;
   str[19] = 0;
   if (reversed)
     for (i=19; i--; ) str[i] = fgetc(ifp);
@@ -4121,7 +4641,7 @@
 
 void CLASS parse_exif (int base)
 {
-  unsigned kodak, entries, tag, type, len, save;
+  unsigned kodak, entries, tag, type, len, save, c;
   double expo;
 
   kodak = !strncmp(make,"EASTMAN",7);
@@ -4129,18 +4649,43 @@
   while (entries--) {
     tiff_get (base, &tag, &type, &len, &save);
     switch (tag) {
-      case 33434:  shutter = getrat();			break;
-      case 33437:  aperture = getrat();			break;
+      case 33434:  shutter = getreal(type);		break;
+      case 33437:  aperture = getreal(type);		break;
       case 34855:  iso_speed = get2();			break;
       case 36867:
       case 36868:  get_timestamp(0);			break;
-      case 37377:  if ((expo = -getrat()) < 128)
+      case 37377:  if ((expo = -getreal(type)) < 128)
 		     shutter = pow (2, expo);		break;
-      case 37378:  aperture = pow (2, getrat()/2);	break;
-      case 37386:  focal_len = getrat();		break;
-      case 37500:  parse_makernote (base);		break;
+      case 37378:  aperture = pow (2, getreal(type)/2);	break;
+      case 37386:  focal_len = getreal(type);		break;
+      case 37500:  parse_makernote (base, 0);		break;
       case 40962:  if (kodak) raw_width  = get4();	break;
       case 40963:  if (kodak) raw_height = get4();	break;
+      case 41730:
+	if (get4() == 0x20002)
+	  for (exif_cfa=c=0; c < 8; c+=2)
+	    exif_cfa |= fgetc(ifp) * 0x01010101 << c;
+    }
+    fseek (ifp, save, SEEK_SET);
+  }
+}
+
+void CLASS parse_gps (int base)
+{
+  unsigned entries, tag, type, len, save, c;
+
+  entries = get2();
+  while (entries--) {
+    tiff_get (base, &tag, &type, &len, &save);
+    switch (tag) {
+      case 1: case 3: case 5:
+	gpsdata[29+tag/2] = getc(ifp);			break;
+      case 2: case 4: case 7:
+	FORC(6) gpsdata[tag/3*6+c] = get4();		break;
+      case 6:
+	FORC(2) gpsdata[18+c] = get4();			break;
+      case 18: case 29:
+	fgets ((char *) (gpsdata+14+tag/3), MIN(len,12), ifp);
     }
     fseek (ifp, save, SEEK_SET);
   }
@@ -4154,10 +4699,10 @@
     { -0.008565, -0.153273,  1.161839 } };
   int i, j, k;
 
-  for (raw_color = i=0; i < 3; i++)
+  for (i=0; i < 3; i++)
     for (j=0; j < 3; j++)
-      for (rgb_cam[i][j] = k=0; k < 3; k++)
-	rgb_cam[i][j] += rgb_romm[i][k] * romm_cam[k][j];
+      for (cmatrix[i][j] = k=0; k < 3; k++)
+	cmatrix[i][j] += rgb_romm[i][k] * romm_cam[k][j];
 }
 
 void CLASS parse_mos (int offset)
@@ -4166,7 +4711,8 @@
   int skip, from, i, c, neut[4], planes=0, frot=0;
   static const char *mod[] =
   { "","DCB2","Volare","Cantare","CMost","Valeo 6","Valeo 11","Valeo 22",
-    "","Valeo 17","","Aptus 17","Aptus 22","Aptus 75","Aptus 65" };
+    "Valeo 11p","Valeo 17","","Aptus 17","Aptus 22","Aptus 75","Aptus 65",
+    "Aptus 54S","Aptus 65S","Aptus 75S","AFi 5","AFi 6","AFi 7" };
   float romm_cam[3][3];
 
   fseek (ifp, offset, SEEK_SET);
@@ -4189,7 +4735,12 @@
       if ((unsigned) i < sizeof mod / sizeof (*mod))
 	strcpy (model, mod[i]);
     }
-    if (!strcmp(data,"CaptProf_color_matrix") && use_camera_wb) {
+    if (!strcmp(data,"icc_camera_to_tone_matrix")) {
+      for (i=0; i < 9; i++)
+	romm_cam[0][i] = int_to_float(get4());
+      romm_coeff (romm_cam);
+    }
+    if (!strcmp(data,"CaptProf_color_matrix")) {
       for (i=0; i < 9; i++)
 	fscanf (ifp, "%f", &romm_cam[0][i]);
       romm_coeff (romm_cam);
@@ -4234,6 +4785,7 @@
   unsigned entries, tag, type, len, save;
   int i, c, wbi=-2, wbtemp=6500;
   float mul[3], num;
+  static const int wbtag[]={ 0xfa25,0xfa28,0xfa27,0xfa29,-1,-1,0xfa2a };
 
   entries = get2();
   if (entries > 1024) return;
@@ -4256,13 +4808,16 @@
       }
     if (tag == 2317) linear_table (len);
     if (tag == 6020) iso_speed = getint(type);
+    if (tag == 0xfa0d) wbi = fgetc(ifp);
+    if ((unsigned) wbi < 7 && tag == wbtag[wbi])
+      FORC3 cam_mul[c] = get4();
     fseek (ifp, save, SEEK_SET);
   }
 }
 
 void CLASS parse_minolta (int base);
 
-int CLASS parse_tiff_ifd (int base, int level)
+int CLASS parse_tiff_ifd (int base)
 {
   unsigned entries, tag, type, len, plen=16, save;
   int ifd, use_cm=0, cfa, i, j, c, ima_len=0;
@@ -4270,6 +4825,7 @@
   uchar cfa_pat[16], cfa_pc[] = { 0,1,2,3 }, tab[256];
   double dblack, cc[4][4], cm[4][3], cam_xyz[4][3], num;
   double ab[]={ 1,1,1,1 }, asn[] = { 0,0,0,0 }, xyz[] = { 1,1,1 };
+  unsigned sony_curve[] = { 0,0,0,0,0,4095 };
   unsigned *buf, sony_offset=0, sony_length=0, sony_key=0;
   struct jhead jh;
   FILE *sfp;
@@ -4300,6 +4856,11 @@
 	fseek (ifp, 12, SEEK_CUR);
 	FORC3 cam_mul[c] = get2();
 	break;
+      case 46:
+	if (type != 7 || fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8) break;
+	thumb_offset = ftell(ifp) - 2;
+	thumb_length = len;
+	break;
       case 2: case 256:			/* ImageWidth */
 	tiff_ifd[ifd].width = getint(type);
 	break;
@@ -4307,7 +4868,7 @@
 	tiff_ifd[ifd].height = getint(type);
 	break;
       case 258:				/* BitsPerSample */
-	tiff_ifd[ifd].samples = len;
+	tiff_ifd[ifd].samples = len & 7;
 	tiff_ifd[ifd].bps = get2();
 	break;
       case 259:				/* Compression */
@@ -4316,12 +4877,19 @@
       case 262:				/* PhotometricInterpretation */
 	tiff_ifd[ifd].phint = get2();
 	break;
+      case 270:				/* ImageDescription */
+	fread (desc, 512, 1, ifp);
+	break;
       case 271:				/* Make */
 	fgets (make, 64, ifp);
 	break;
       case 272:				/* Model */
 	fgets (model, 64, ifp);
 	break;
+      case 280:				/* Panasonic RW2 offset */
+	if (type != 4) break;
+	load_raw = &CLASS panasonic_load_raw;
+	load_flags = 0x2008;
       case 273:				/* StripOffset */
       case 513:
 	tiff_ifd[ifd].offset = get4()+base;
@@ -4340,16 +4908,17 @@
 	tiff_ifd[ifd].flip = "50132467"[get2() & 7]-'0';
 	break;
       case 277:				/* SamplesPerPixel */
-	tiff_ifd[ifd].samples = getint(type);
+	tiff_ifd[ifd].samples = getint(type) & 7;
 	break;
       case 279:				/* StripByteCounts */
       case 514:
 	tiff_ifd[ifd].bytes = get4();
 	break;
-      case 305:				/* Software */
+      case 305:  case 11:		/* Software */
 	fgets (software, 64, ifp);
 	if (!strncmp(software,"Adobe",5) ||
 	    !strncmp(software,"dcraw",5) ||
+	    !strncmp(software,"UFRaw",5) ||
 	    !strncmp(software,"Bibble",6) ||
 	    !strncmp(software,"Nikon Scan",10) ||
 	    !strcmp (software,"Digital Photo Professional"))
@@ -4358,22 +4927,32 @@
       case 306:				/* DateTime */
 	get_timestamp(0);
 	break;
+      case 315:				/* Artist */
+	fread (artist, 64, 1, ifp);
+	break;
+      case 322:				/* TileWidth */
+	tile_width = getint(type);
+	break;
       case 323:				/* TileLength */
 	tile_length = getint(type);
 	break;
       case 324:				/* TileOffsets */
 	tiff_ifd[ifd].offset = len > 1 ? ftell(ifp) : get4();
-	if (len == 4) load_raw = &CLASS sinar_4shot_load_raw;
+	if (len == 4) {
+	  load_raw = &CLASS sinar_4shot_load_raw;
+	  is_raw = 5;
+	}
 	break;
       case 330:				/* SubIFDs */
 	if (!strcmp(model,"DSLR-A100") && tiff_ifd[ifd].width == 3872) {
+	  load_raw = &CLASS sony_arw_load_raw;
 	  data_offset = get4()+base;
 	  ifd++;  break;
 	}
 	while (len--) {
 	  i = ftell(ifp);
 	  fseek (ifp, get4()+base, SEEK_SET);
-	  if (parse_tiff_ifd (base, level+1)) break;
+	  if (parse_tiff_ifd (base)) break;
 	  fseek (ifp, i+4, SEEK_SET);
 	}
 	break;
@@ -4381,12 +4960,25 @@
 	strcpy (make, "Sarnoff");
 	maximum = 0xfff;
 	break;
+      case 28688:
+	FORC4 sony_curve[c+1] = get2() >> 2 & 0xfff;
+	for (i=0; i < 5; i++)
+	  for (j = sony_curve[i]+1; j <= sony_curve[i+1]; j++)
+	    curve[j] = curve[j-1] + (1 << i);
+	break;
       case 29184: sony_offset = get4();  break;
       case 29185: sony_length = get4();  break;
       case 29217: sony_key    = get4();  break;
+      case 29264:
+	parse_minolta (ftell(ifp));
+	raw_width = 0;
+	break;
       case 29443:
 	FORC4 cam_mul[c ^ (c < 2)] = get2();
 	break;
+      case 29459:
+	FORC4 cam_mul[c ^ (c >> 1)] = get2();
+	break;
       case 33405:			/* Model2 */
 	fgets (model2, 64, ifp);
 	break;
@@ -4402,14 +4994,15 @@
 	if (cfa == 072) memcpy (cfa_pc,"\005\003\004\001",4);	/* GMCY */
 	goto guess_cfa_pc;
       case 33424:
+      case 65024:
 	fseek (ifp, get4()+base, SEEK_SET);
 	parse_kodak_ifd (base);
 	break;
       case 33434:			/* ExposureTime */
-	shutter = getrat();
+	shutter = getreal(type);
 	break;
       case 33437:			/* FNumber */
-	aperture = getrat();
+	aperture = getreal(type);
 	break;
       case 34306:			/* Leaf white balance */
 	FORC4 cam_mul[c ^ 1] = 4096.0 / get2();
@@ -4435,6 +5028,10 @@
 	fseek (ifp, get4()+base, SEEK_SET);
 	parse_exif (base);
 	break;
+      case 34853:			/* GPSInfo tag */
+	fseek (ifp, get4()+base, SEEK_SET);
+	parse_gps (base);
+	break;
       case 34675:			/* InterColorProfile */
       case 50831:			/* AsShotICCProfile */
 	profile_offset = ftell(ifp);
@@ -4444,15 +5041,15 @@
 	kodak_cbpp = get4();
 	break;
       case 37386:			/* FocalLength */
-	focal_len = getrat();
+	focal_len = getreal(type);
 	break;
       case 37393:			/* ImageNumber */
 	shot_order = getint(type);
 	break;
       case 37400:			/* old Kodak KDC tag */
 	for (raw_color = i=0; i < 3; i++) {
-	  getrat();
-	  FORC3 rgb_cam[i][c] = getrat();
+	  getreal(type);
+	  FORC3 rgb_cam[i][c] = getreal(type);
 	}
 	break;
       case 46275:			/* Imacon tags */
@@ -4461,6 +5058,7 @@
 	ima_len = len;
 	break;
       case 46279:
+	if (!ima_len) break;
 	fseek (ifp, 78, SEEK_CUR);
 	raw_width  = get4();
 	raw_height = get4();
@@ -4468,6 +5066,11 @@
 	width = raw_width - left_margin - (get4() & 7);
 	top_margin = get4() & 7;
 	height = raw_height - top_margin - (get4() & 7);
+	if (raw_width == 7262) {
+	  height = 5444;
+	  width  = 7244;
+	  left_margin = 7;
+	}
 	fseek (ifp, 52, SEEK_CUR);
 	FORC3 cam_mul[c] = getreal(11);
 	fseek (ifp, 114, SEEK_CUR);
@@ -4476,6 +5079,13 @@
 	  if (flip % 180 == 90) SWAP(width,height);
 	  filters = flip = 0;
 	}
+	sprintf (model, "Ixpress %d-Mp", height*width/1000000);
+	load_raw = &CLASS imacon_full_load_raw;
+	if (filters) {
+	  if (left_margin & 1) filters = 0x61616161;
+	  load_raw = &CLASS unpacked_load_raw;
+	}
+	maximum = 0xffff;
 	break;
       case 50454:			/* Sinar tag */
       case 50455:
@@ -4486,8 +5096,24 @@
 	    sscanf (cp+8, "%f %f %f", cam_mul, cam_mul+1, cam_mul+2);
 	free (cbuf);
 	break;
+      case 50458:
+	if (!make[0]) strcpy (make, "Hasselblad");
+	break;
+      case 50459:			/* Hasselblad tag */
+	i = order;
+	j = ftell(ifp);
+	c = tiff_nifds;
+	order = get2();
+	fseek (ifp, j+(get2(),get4()), SEEK_SET);
+	parse_tiff_ifd (j);
+	maximum = 0xffff;
+	tiff_nifds = c;
+	order = i;
+	break;
       case 50706:			/* DNGVersion */
 	FORC4 dng_version = (dng_version << 8) + fgetc(ifp);
+	if (!make[0]) strcpy (make, "DNG");
+	is_raw = 1;
 	break;
       case 50710:			/* CFAPlaneColor */
 	if (len > 4) len = 4;
@@ -4520,38 +5146,36 @@
 	maximum = getint(type);
 	break;
       case 50718:			/* DefaultScale */
-	pixel_aspect  = getrat();
-	pixel_aspect /= getrat();
+	pixel_aspect  = getreal(type);
+	pixel_aspect /= getreal(type);
 	break;
       case 50721:			/* ColorMatrix1 */
       case 50722:			/* ColorMatrix2 */
 	FORCC for (j=0; j < 3; j++)
-	  cm[c][j] = getrat();
+	  cm[c][j] = getreal(type);
 	use_cm = 1;
 	break;
       case 50723:			/* CameraCalibration1 */
       case 50724:			/* CameraCalibration2 */
 	for (i=0; i < colors; i++)
-	  FORCC cc[i][c] = getrat();
+	  FORCC cc[i][c] = getreal(type);
       case 50727:			/* AnalogBalance */
-	FORCC ab[c] = getrat();
+	FORCC ab[c] = getreal(type);
 	break;
       case 50728:			/* AsShotNeutral */
 	FORCC asn[c] = getreal(type);
 	break;
       case 50729:			/* AsShotWhiteXY */
-	xyz[0] = getrat();
-	xyz[1] = getrat();
+	xyz[0] = getreal(type);
+	xyz[1] = getreal(type);
 	xyz[2] = 1 - xyz[0] - xyz[1];
 	FORC3 xyz[c] /= d65_white[c];
 	break;
       case 50740:			/* DNGPrivateData */
 	if (dng_version) break;
-	i = order;
 	parse_minolta (j = get4()+base);
-	order = i;
 	fseek (ifp, j, SEEK_SET);
-	parse_tiff_ifd (base, level+1);
+	parse_tiff_ifd (base);
 	break;
       case 50752:
 	read_shorts (cr2_slice, 3);
@@ -4563,11 +5187,15 @@
 	width = getint(type) - left_margin;
 	break;
       case 64772:			/* Kodak P-series */
+	if (len < 13) break;
 	fseek (ifp, 16, SEEK_CUR);
 	data_offset = get4();
 	fseek (ifp, 28, SEEK_CUR);
 	data_offset += get4();
-	load_raw = &CLASS packed_12_load_raw;
+	load_raw = &CLASS packed_load_raw;
+	break;
+      case 65026:
+	if (type == 2) fgets (model2, 64, ifp);
     }
     fseek (ifp, save, SEEK_SET);
   }
@@ -4579,7 +5207,7 @@
     if ((ifp = tmpfile())) {
       fwrite (buf, sony_length, 1, ifp);
       fseek (ifp, 0, SEEK_SET);
-      parse_tiff_ifd (-sony_offset, level);
+      parse_tiff_ifd (-sony_offset);
       fclose (ifp);
     }
     ifp = sfp;
@@ -4593,8 +5221,10 @@
 	cam_xyz[c][i] += cc[c][j] * cm[j][i] * xyz[i];
     cam_xyz_coeff (cam_xyz);
   }
-  if (asn[0])
-    FORCC pre_mul[c] = 1 / asn[c];
+  if (asn[0]) {
+    cam_mul[3] = 0;
+    FORCC cam_mul[c] = 1 / asn[c];
+  }
   if (!use_cm)
     FORCC pre_mul[c] /= cc[c][c];
   return 0;
@@ -4613,7 +5243,7 @@
   tiff_nifds = 0;
   while ((doff = get4())) {
     fseek (ifp, doff+base, SEEK_SET);
-    if (parse_tiff_ifd (base, 0)) break;
+    if (parse_tiff_ifd (base)) break;
   }
   thumb_misc = 16;
   if (thumb_offset) {
@@ -4627,7 +5257,9 @@
   for (i=0; i < tiff_nifds; i++) {
     if (max_samp < tiff_ifd[i].samples)
 	max_samp = tiff_ifd[i].samples;
+    if (max_samp > 3) max_samp = 3;
     if ((tiff_ifd[i].comp != 6 || tiff_ifd[i].samples != 3) &&
+	(tiff_ifd[i].width | tiff_ifd[i].height) < 0x10000 &&
 	tiff_ifd[i].width*tiff_ifd[i].height > raw_width*raw_height) {
       raw_width     = tiff_ifd[i].width;
       raw_height    = tiff_ifd[i].height;
@@ -4636,7 +5268,6 @@
       data_offset   = tiff_ifd[i].offset;
       tiff_flip     = tiff_ifd[i].flip;
       tiff_samples  = tiff_ifd[i].samples;
-      fuji_secondary = tiff_samples == 2;
       raw = i;
     }
   }
@@ -4645,28 +5276,59 @@
   if (raw >= 0 && !load_raw)
     switch (tiff_compress) {
       case 0:  case 1:
-	load_raw = tiff_bps > 8 ?
-	  &CLASS unpacked_load_raw : &CLASS eight_bit_load_raw;
-	if (tiff_ifd[raw].bytes * 5 == raw_width * raw_height * 8)
-	  load_raw = &CLASS olympus_e300_load_raw;
+	switch (tiff_bps) {
+	  case  8: load_raw = &CLASS eight_bit_load_raw;	break;
+	  case 12: load_raw = &CLASS packed_load_raw;
+		   if (tiff_ifd[raw].phint == 2)
+		     load_flags = 6;
+		   if (strncmp(make,"PENTAX",6)) break;
+	  case 14:
+	  case 16: load_raw = &CLASS unpacked_load_raw;		break;
+	}
+	if (tiff_ifd[raw].bytes*5 == raw_width*raw_height*8) {
+	  tiff_bps = 12;
+	  maximum = 0xffff;
+	  load_raw = &CLASS packed_load_raw;
+	  load_flags = 273;
+	}
 	break;
       case 6:  case 7:  case 99:
 	load_raw = &CLASS lossless_jpeg_load_raw;		break;
       case 262:
 	load_raw = &CLASS kodak_262_load_raw;			break;
+      case 32767:
+	if (tiff_ifd[raw].bytes*8 != raw_width*raw_height*tiff_bps) {
+	  raw_height += 8;
+	  load_raw = &CLASS sony_arw_load_raw;			break;
+	}
+	if (tiff_bps == 8) {
+	  tiff_bps = 12;
+	  load_raw = &CLASS sony_arw2_load_raw;			break;
+	}
+	load_flags = 79;
+      case 32769:
+	load_flags++;
       case 32773:
-	load_raw = &CLASS packed_12_load_raw;			break;
+	load_raw = &CLASS packed_load_raw;			break;
+      case 34713:
+	load_raw = &CLASS nikon_compressed_load_raw;		break;
       case 65535:
-	load_raw = &CLASS pentax_k10_load_raw;			break;
+	load_raw = &CLASS pentax_load_raw;			break;
       case 65000:
 	switch (tiff_ifd[raw].phint) {
 	  case 2: load_raw = &CLASS kodak_rgb_load_raw;   filters = 0;  break;
 	  case 6: load_raw = &CLASS kodak_ycbcr_load_raw; filters = 0;  break;
 	  case 32803: load_raw = &CLASS kodak_65000_load_raw;
 	}
+      case 32867: break;
+      default: is_raw = 0;
     }
-  if (tiff_samples == 3 && tiff_bps == 8)
-    if (!dng_version) is_raw = 0;
+  if (!dng_version)
+    if ( (tiff_samples == 3 && tiff_ifd[raw].bytes &&
+	  tiff_bps != 14 && tiff_bps != 2048)
+      || (tiff_bps == 8 && !strstr(make,"KODAK") && !strstr(make,"Kodak") &&
+	  !strstr(model2,"DEBUG RAW")))
+      is_raw = 0;
   for (i=0; i < tiff_nifds; i++)
     if (i != raw && tiff_ifd[i].samples == max_samp &&
 	tiff_ifd[i].width * tiff_ifd[i].height / SQR(tiff_ifd[i].bps+1) >
@@ -4700,6 +5362,7 @@
 void CLASS parse_minolta (int base)
 {
   int save, tag, len, offset, high=0, wide=0, i, c;
+  short sorder=order;
 
   fseek (ifp, base, SEEK_SET);
   if (fgetc(ifp) || fgetc(ifp)-'M' || fgetc(ifp)-'R') return;
@@ -4717,7 +5380,7 @@
 	break;
       case 0x574247:				/* WBG */
 	get4();
-	i = strstr(model,"A200") ? 3:0;
+	i = strcmp(model,"DiMAGE A200") ? 0:3;
 	FORC4 cam_mul[c ^ (c >> 1) ^ i] = get2();
 	break;
       case 0x545457:				/* TTW */
@@ -4728,6 +5391,7 @@
   }
   raw_height = high;
   raw_width  = wide;
+  order = sorder;
 }
 
 /*
@@ -4737,7 +5401,8 @@
  */
 void CLASS parse_external_jpeg()
 {
-  char *file, *ext, *jname, *jfile, *jext;
+  const char *file, *ext;
+  char *jname, *jfile, *jext;
   FILE *save=ifp;
 
   ext  = strrchr (ifname, '.');
@@ -4747,14 +5412,16 @@
   file++;
   if (!ext || strlen(ext) != 4 || ext-file != 8) return;
   jname = (char *) malloc (strlen(ifname) + 1);
-  merror (jname, "parse_external()");
+  merror (jname, "parse_external_jpeg()");
   strcpy (jname, ifname);
   jfile = file - ifname + jname;
   jext  = ext  - ifname + jname;
   if (strcasecmp (ext, ".jpg")) {
     strcpy (jext, isupper(ext[1]) ? ".JPG":".jpg");
-    memcpy (jfile, file+4, 4);
-    memcpy (jfile+4, file, 4);
+    if (isdigit(*file)) {
+      memcpy (jfile, file+4, 4);
+      memcpy (jfile+4, file, 4);
+    }
   } else
     while (isdigit(*--jext)) {
       if (*jext != '9') {
@@ -4825,6 +5492,8 @@
     if ((((type >> 8) + 8) | 8) == 0x38)
       parse_ciff (ftell(ifp), len);	/* Parse a sub-table */
 
+    if (type == 0x0810)
+      fread (artist, 64, 1, ifp);
     if (type == 0x080a) {
       fread (make, 64, 1, ifp);
       fseek (ifp, strlen(make) - 63, SEEK_CUR);
@@ -4947,6 +5616,38 @@
   write_thumb = &CLASS rollei_thumb;
 }
 
+void CLASS parse_sinar_ia()
+{
+  int entries, off;
+  char str[8], *cp;
+
+  order = 0x4949;
+  fseek (ifp, 4, SEEK_SET);
+  entries = get4();
+  fseek (ifp, get4(), SEEK_SET);
+  while (entries--) {
+    off = get4(); get4();
+    fread (str, 8, 1, ifp);
+    if (!strcmp(str,"META"))   meta_offset = off;
+    if (!strcmp(str,"THUMB")) thumb_offset = off;
+    if (!strcmp(str,"RAW0"))   data_offset = off;
+  }
+  fseek (ifp, meta_offset+20, SEEK_SET);
+  fread (make, 64, 1, ifp);
+  make[63] = 0;
+  if ((cp = strchr(make,' '))) {
+    strcpy (model, cp+1);
+    *cp = 0;
+  }
+  raw_width  = get2();
+  raw_height = get2();
+  load_raw = &CLASS unpacked_load_raw;
+  thumb_width = (get4(),get2());
+  thumb_height = get2();
+  write_thumb = &CLASS ppm_thumb;
+  maximum = 0x3fff;
+}
+
 void CLASS parse_phase_one (int base)
 {
   unsigned entries, tag, type, len, data, save, i, c;
@@ -4957,7 +5658,7 @@
   fseek (ifp, base, SEEK_SET);
   order = get4() & 0xffff;
   if (get4() >> 8 != 0x526177) return;		/* "Raw" */
-  fseek (ifp, base+get4(), SEEK_SET);
+  fseek (ifp, get4()+base, SEEK_SET);
   entries = get4();
   get4();
   while (entries--) {
@@ -4975,7 +5676,7 @@
 	romm_coeff (romm_cam);
 	break;
       case 0x107:
-	FORC3 cam_mul[c] = pre_mul[c] = getreal(11);
+	FORC3 cam_mul[c] = getreal(11);
 	break;
       case 0x108:  raw_width     = data;	break;
       case 0x109:  raw_height    = data;	break;
@@ -5037,10 +5738,8 @@
       FORC4 cam_mul[c ^ 1] = get2();
     fseek (ifp, save+len, SEEK_SET);
   }
-  if (fuji_layout) {
-    height *= 2;
-    width  /= 2;
-  }
+  height <<= fuji_layout;
+  width  >>= fuji_layout;
 }
 
 int CLASS parse_jpeg (int offset)
@@ -5080,18 +5779,26 @@
   order = 0x4949;
   fread (tag, 4, 1, ifp);
   size = get4();
+  end = ftell(ifp) + size;
   if (!memcmp(tag,"RIFF",4) || !memcmp(tag,"LIST",4)) {
-    end = ftell(ifp) + size;
     get4();
-    while (ftell(ifp) < end)
+    while (ftell(ifp)+7 < end)
       parse_riff();
+  } else if (!memcmp(tag,"nctg",4)) {
+    while (ftell(ifp)+7 < end) {
+      i = get2();
+      size = get2();
+      if ((i+1) >> 1 == 10 && size == 20)
+	get_timestamp(0);
+      else fseek (ifp, size, SEEK_CUR);
+    }
   } else if (!memcmp(tag,"IDIT",4) && size < 64) {
     fread (date, 64, 1, ifp);
     date[size] = 0;
     memset (&t, 0, sizeof t);
     if (sscanf (date, "%*s %s %d %d:%d:%d %d", month, &t.tm_mday,
 	&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {
-      for (i=0; i < 12 && strcmp(mon[i],month); i++);
+      for (i=0; i < 12 && strcasecmp(mon[i],month); i++);
       t.tm_mon = i;
       t.tm_year -= 1900;
       if (mktime(&t) > 0)
@@ -5120,6 +5827,55 @@
   if (ver == 9) load_raw = &CLASS smal_v9_load_raw;
 }
 
+void CLASS parse_cine()
+{
+  unsigned off_head, off_setup, off_image, i;
+
+  order = 0x4949;
+  fseek (ifp, 4, SEEK_SET);
+  is_raw = get2() == 2;
+  fseek (ifp, 14, SEEK_CUR);
+  is_raw *= get4();
+  off_head = get4();
+  off_setup = get4();
+  off_image = get4();
+  timestamp = get4();
+  if ((i = get4())) timestamp = i;
+  fseek (ifp, off_head+4, SEEK_SET);
+  raw_width = get4();
+  raw_height = get4();
+  switch (get2(),get2()) {
+    case  8:  load_raw = &CLASS eight_bit_load_raw;  break;
+    case 16:  load_raw = &CLASS  unpacked_load_raw;
+  }
+  fseek (ifp, off_setup+792, SEEK_SET);
+  strcpy (make, "CINE");
+  sprintf (model, "%d", get4());
+  fseek (ifp, 12, SEEK_CUR);
+  switch ((i=get4()) & 0xffffff) {
+    case  3:  filters = 0x94949494;  break;
+    case  4:  filters = 0x49494949;  break;
+    default:  is_raw = 0;
+  }
+  fseek (ifp, 72, SEEK_CUR);
+  switch ((get4()+3600) % 360) {
+    case 270:  flip = 4;  break;
+    case 180:  flip = 1;  break;
+    case  90:  flip = 7;  break;
+    case   0:  flip = 2;
+  }
+  cam_mul[0] = getreal(11);
+  cam_mul[2] = getreal(11);
+  maximum = ~(-1 << get4());
+  fseek (ifp, 668, SEEK_CUR);
+  shutter = get4()/1000000000.0;
+  fseek (ifp, off_image, SEEK_SET);
+  if (shot_select < is_raw)
+    fseek (ifp, shot_select*8, SEEK_CUR);
+  data_offset  = (INT64) get4() + 8;
+  data_offset += (INT64) get4() << 32;
+}
+
 char * CLASS foveon_gets (int offset, char *str, int len)
 {
   int i;
@@ -5161,9 +5917,11 @@
 	  data_offset = off+24;
 	}
 	fseek (ifp, off+28, SEEK_SET);
-	if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8) {
+	if (fgetc(ifp) == 0xff && fgetc(ifp) == 0xd8
+		&& thumb_length < len-28) {
 	  thumb_offset = off+28;
 	  thumb_length = len-28;
+	  write_thumb = &CLASS jpeg_thumb;
 	}
 	if (++img == 2 && !thumb_length) {
 	  thumb_offset = off+24;
@@ -5182,7 +5940,7 @@
 	pent = (get4(),get4());
 	fseek (ifp, 12, SEEK_CUR);
 	off += pent*8 + 24;
-	if (pent > 256) pent=256;
+	if ((unsigned) pent > 256) pent=256;
 	for (i=0; i < pent*2; i++)
 	  poff[0][i] = off + get4()*2;
 	for (i=0; i < pent; i++) {
@@ -5215,304 +5973,494 @@
 }
 
 /*
-   Thanks to Adobe for providing these excellent CAM -> XYZ matrices!
+   All matrices are from Adobe DNG Converter unless otherwise noted.
  */
-void CLASS adobe_coeff (char *make, char *model)
+void CLASS adobe_coeff (const char *make, const char *model)
 {
   static const struct {
     const char *prefix;
-    short black, trans[12];
+    short black, maximum, trans[12];
   } table[] = {
-    { "Canon EOS D2000", 0,
+    { "AGFAPHOTO DC-833m", 0, 0,	/* DJC */
+	{ 11438,-3762,-1115,-2409,9914,2497,-1227,2295,5300 } },
+    { "Apple QuickTake", 0, 0,		/* DJC */
+	{ 21392,-5653,-3353,2406,8010,-415,7166,1427,2078 } },
+    { "Canon EOS D2000", 0, 0,
 	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
-    { "Canon EOS D6000", 0,
+    { "Canon EOS D6000", 0, 0,
 	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
-    { "Canon EOS D30", 0,
+    { "Canon EOS D30", 0, 0,
 	{ 9805,-2689,-1312,-5803,13064,3068,-2438,3075,8775 } },
-    { "Canon EOS D60", 0,
+    { "Canon EOS D60", 0, 0xfa0,
 	{ 6188,-1341,-890,-7168,14489,2937,-2640,3228,8483 } },
-    { "Canon EOS 5D", 0,
+    { "Canon EOS 5D Mark II", 0, 0x3cf0,
+	{ 4716,603,-830,-7798,15474,2480,-1496,1937,6651 } },
+    { "Canon EOS 5D", 0, 0xe6c,
 	{ 6347,-479,-972,-8297,15954,2480,-1968,2131,7649 } },
-    { "Canon EOS 20Da", 0,
+    { "Canon EOS 7D", 0, 0x3510,	/* DJC */
+	{ 7956,-1490,-850,-2896,10428,2469,-827,1800,5680 } },
+    { "Canon EOS 10D", 0, 0xfa0,
+	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
+    { "Canon EOS 20Da", 0, 0,
 	{ 14155,-5065,-1382,-6550,14633,2039,-1623,1824,6561 } },
-    { "Canon EOS 20D", 0,
+    { "Canon EOS 20D", 0, 0xfff,
 	{ 6599,-537,-891,-8071,15783,2424,-1983,2234,7462 } },
-    { "Canon EOS 30D", 0,
+    { "Canon EOS 30D", 0, 0,
 	{ 6257,-303,-1000,-7880,15621,2396,-1714,1904,7046 } },
-    { "Canon EOS 350D", 0,
+    { "Canon EOS 40D", 0, 0x3f60,
+	{ 6071,-747,-856,-7653,15365,2441,-2025,2553,7315 } },
+    { "Canon EOS 50D", 0, 0x3d93,
+	{ 4920,616,-593,-6493,13964,2784,-1774,3178,7005 } },
+    { "Canon EOS 300D", 0, 0xfa0,
+	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
+    { "Canon EOS 350D", 0, 0xfff,
 	{ 6018,-617,-965,-8645,15881,2975,-1530,1719,7642 } },
-    { "Canon EOS 400D", 0,
+    { "Canon EOS 400D", 0, 0xe8e,
 	{ 7054,-1501,-990,-8156,15544,2812,-1278,1414,7796 } },
-    { "Canon EOS-1Ds Mark II", 0,
+    { "Canon EOS 450D", 0, 0x390d,
+	{ 5784,-262,-821,-7539,15064,2672,-1982,2681,7427 } },
+    { "Canon EOS 500D", 0, 0x3479,
+	{ 4763,712,-646,-6821,14399,2640,-1921,3276,6561 } },
+    { "Canon EOS 1000D", 0, 0xe43,
+	{ 6771,-1139,-977,-7818,15123,2928,-1244,1437,7533 } },
+    { "Canon EOS-1Ds Mark III", 0, 0x3bb0,
+	{ 5859,-211,-930,-8255,16017,2353,-1732,1887,7448 } },
+    { "Canon EOS-1Ds Mark II", 0, 0xe80,
 	{ 6517,-602,-867,-8180,15926,2378,-1618,1771,7633 } },
-    { "Canon EOS-1D Mark II N", 0,
+    { "Canon EOS-1D Mark II N", 0, 0xe80,
 	{ 6240,-466,-822,-8180,15825,2500,-1801,1938,8042 } },
-    { "Canon EOS-1D Mark II", 0,
+    { "Canon EOS-1D Mark III", 0, 0x3bb0,
+	{ 6291,-540,-976,-8350,16145,2311,-1714,1858,7326 } },
+    { "Canon EOS-1D Mark II", 0, 0xe80,
 	{ 6264,-582,-724,-8312,15948,2504,-1744,1919,8664 } },
-    { "Canon EOS-1DS", 0,
+    { "Canon EOS-1DS", 0, 0xe20,
 	{ 4374,3631,-1743,-7520,15212,2472,-2892,3632,8161 } },
-    { "Canon EOS-1D", 0,
+    { "Canon EOS-1D", 0, 0xe20,
 	{ 6806,-179,-1020,-8097,16415,1687,-3267,4236,7690 } },
-    { "Canon EOS", 0,
+    { "Canon EOS", 0, 0,
 	{ 8197,-2000,-1118,-6714,14335,2592,-2536,3178,8266 } },
-    { "Canon PowerShot A50", 0,
+    { "Canon PowerShot A530", 0, 0,
+	{ 0 } },	/* don't want the A5 matrix */	
+    { "Canon PowerShot A50", 0, 0,
 	{ -5300,9846,1776,3436,684,3939,-5540,9879,6200,-1404,11175,217 } },
-    { "Canon PowerShot A5", 0,
+    { "Canon PowerShot A5", 0, 0,
 	{ -4801,9475,1952,2926,1611,4094,-5259,10164,5947,-1554,10883,547 } },
-    { "Canon PowerShot G1", 0,
+    { "Canon PowerShot G10", 0, 0,
+	{ 11093,-3906,-1028,-5047,12492,2879,-1003,1750,5561 } },
+    { "Canon PowerShot G11", 0, 0,
+	{ 0 } },	/* don't want the G1 matrix */
+    { "Canon PowerShot G1", 0, 0,
 	{ -4778,9467,2172,4743,-1141,4344,-5146,9908,6077,-1566,11051,557 } },
-    { "Canon PowerShot G2", 0,
+    { "Canon PowerShot G2", 0, 0,
 	{ 9087,-2693,-1049,-6715,14382,2537,-2291,2819,7790 } },
-    { "Canon PowerShot G3", 0,
+    { "Canon PowerShot G3", 0, 0,
 	{ 9212,-2781,-1073,-6573,14189,2605,-2300,2844,7664 } },
-    { "Canon PowerShot G5", 0,
+    { "Canon PowerShot G5", 0, 0,
 	{ 9757,-2872,-933,-5972,13861,2301,-1622,2328,7212 } },
-    { "Canon PowerShot G6", 0,
+    { "Canon PowerShot G6", 0, 0,
 	{ 9877,-3775,-871,-7613,14807,3072,-1448,1305,7485 } },
-    { "Canon PowerShot Pro1", 0,
+    { "Canon PowerShot G9", 0, 0,
+	{ 7368,-2141,-598,-5621,13254,2625,-1418,1696,5743 } },
+    { "Canon PowerShot Pro1", 0, 0,
 	{ 10062,-3522,-999,-7643,15117,2730,-765,817,7323 } },
-    { "Canon PowerShot Pro70", 34,
+    { "Canon PowerShot Pro70", 34, 0,
 	{ -4155,9818,1529,3939,-25,4522,-5521,9870,6610,-2238,10873,1342 } },
-    { "Canon PowerShot Pro90", 0,
+    { "Canon PowerShot Pro90", 0, 0,
 	{ -4963,9896,2235,4642,-987,4294,-5162,10011,5859,-1770,11230,577 } },
-    { "Canon PowerShot S30", 0,
+    { "Canon PowerShot S30", 0, 0,
 	{ 10566,-3652,-1129,-6552,14662,2006,-2197,2581,7670 } },
-    { "Canon PowerShot S40", 0,
+    { "Canon PowerShot S40", 0, 0,
 	{ 8510,-2487,-940,-6869,14231,2900,-2318,2829,9013 } },
-    { "Canon PowerShot S45", 0,
+    { "Canon PowerShot S45", 0, 0,
 	{ 8163,-2333,-955,-6682,14174,2751,-2077,2597,8041 } },
-    { "Canon PowerShot S50", 0,
+    { "Canon PowerShot S50", 0, 0,
 	{ 8882,-2571,-863,-6348,14234,2288,-1516,2172,6569 } },
-    { "Canon PowerShot S60", 0,
+    { "Canon PowerShot S60", 0, 0,
 	{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },
-    { "Canon PowerShot S70", 0,
+    { "Canon PowerShot S70", 0, 0,
 	{ 9976,-3810,-832,-7115,14463,2906,-901,989,7889 } },
-    { "Canon PowerShot A610", 0, /* copied from the S60 */
-	{ 8795,-2482,-797,-7804,15403,2573,-1422,1996,7082 } },
-    { "Canon PowerShot A620", 0, /* DJC */
+    { "Canon PowerShot A470", 0, 0,	/* DJC */
+	{ 12513,-4407,-1242,-2680,10276,2405,-878,2215,4734 } },
+    { "Canon PowerShot A610", 0, 0,	/* DJC */
+	{ 15591,-6402,-1592,-5365,13198,2168,-1300,1824,5075 } },
+    { "Canon PowerShot A620", 0, 0,	/* DJC */
 	{ 15265,-6193,-1558,-4125,12116,2010,-888,1639,5220 } },
-    { "Contax N Digital", 0,
+    { "Canon PowerShot A630", 0, 0,	/* DJC */
+	{ 14201,-5308,-1757,-6087,14472,1617,-2191,3105,5348 } },
+    { "Canon PowerShot A640", 0, 0,	/* DJC */
+	{ 13124,-5329,-1390,-3602,11658,1944,-1612,2863,4885 } },
+    { "Canon PowerShot A650", 0, 0,	/* DJC */
+	{ 9427,-3036,-959,-2581,10671,1911,-1039,1982,4430 } },
+    { "Canon PowerShot A720", 0, 0,	/* DJC */
+	{ 14573,-5482,-1546,-1266,9799,1468,-1040,1912,3810 } },
+    { "Canon PowerShot S3 IS", 0, 0,	/* DJC */
+	{ 14062,-5199,-1446,-4712,12470,2243,-1286,2028,4836 } },
+    { "Canon PowerShot SX1 IS", 0, 0,
+	{ 6578,-259,-502,-5974,13030,3309,-308,1058,4970 } },
+    { "Canon PowerShot SX110 IS", 0, 0,	/* DJC */
+        { 14134,-5576,-1527,-1991,10719,1273,-1158,1929,3581 } },
+    { "CASIO EX-S20", 0, 0,		/* DJC */
+	{ 11634,-3924,-1128,-4968,12954,2015,-1588,2648,7206 } },
+    { "CINE 650", 0, 0,
+	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
+    { "CINE 660", 0, 0,
+	{ 3390,480,-500,-800,3610,340,-550,2336,1192 } },
+    { "CINE", 0, 0,
+	{ 20183,-4295,-423,-3940,15330,3985,-280,4870,9800 } },
+    { "Contax N Digital", 0, 0xf1e,
 	{ 7777,1285,-1053,-9280,16543,2916,-3677,5679,7060 } },
-    { "EPSON R-D1", 0,
+    { "EPSON R-D1", 0, 0,
 	{ 6827,-1878,-732,-8429,16012,2564,-704,592,7145 } },
-    { "FUJIFILM FinePix E550", 0,
+    { "FUJIFILM FinePix E550", 0, 0,
 	{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },
-    { "FUJIFILM FinePix E900", 0,
+    { "FUJIFILM FinePix E900", 0, 0,
 	{ 9183,-2526,-1078,-7461,15071,2574,-2022,2440,8639 } },
-    { "FUJIFILM FinePix F8", 0,
+    { "FUJIFILM FinePix F8", 0, 0,
 	{ 11044,-3888,-1120,-7248,15168,2208,-1531,2277,8069 } },
-    { "FUJIFILM FinePix F7", 0,
+    { "FUJIFILM FinePix F7", 0, 0,
 	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
-    { "FUJIFILM FinePix S20Pro", 0,
+    { "FUJIFILM FinePix S100FS", 514, 0,
+	{ 11521,-4355,-1065,-6524,13767,3058,-1466,1984,6045 } },
+    { "FUJIFILM FinePix S20Pro", 0, 0,
 	{ 10004,-3219,-1201,-7036,15047,2107,-1863,2565,7736 } },
-    { "FUJIFILM FinePix S2Pro", 128,
+    { "FUJIFILM FinePix S2Pro", 128, 0,
 	{ 12492,-4690,-1402,-7033,15423,1647,-1507,2111,7697 } },
-    { "FUJIFILM FinePix S3Pro", 0,
+    { "FUJIFILM FinePix S3Pro", 0, 0,
 	{ 11807,-4612,-1294,-8927,16968,1988,-2120,2741,8006 } },
-    { "FUJIFILM FinePix S5000", 0,
+    { "FUJIFILM FinePix S5Pro", 0, 0,
+	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
+    { "FUJIFILM FinePix S5000", 0, 0,
 	{ 8754,-2732,-1019,-7204,15069,2276,-1702,2334,6982 } },
-    { "FUJIFILM FinePix S5100", 0,
+    { "FUJIFILM FinePix S5100", 0, 0x3e00,
 	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
-    { "FUJIFILM FinePix S5500", 0,
+    { "FUJIFILM FinePix S5500", 0, 0x3e00,
 	{ 11940,-4431,-1255,-6766,14428,2542,-993,1165,7421 } },
-    { "FUJIFILM FinePix S5200", 0,
+    { "FUJIFILM FinePix S5200", 0, 0,
 	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
-    { "FUJIFILM FinePix S5600", 0,
+    { "FUJIFILM FinePix S5600", 0, 0,
 	{ 9636,-2804,-988,-7442,15040,2589,-1803,2311,8621 } },
-    { "FUJIFILM FinePix S7000", 0,
+    { "FUJIFILM FinePix S6", 0, 0,
+	{ 12628,-4887,-1401,-6861,14996,1962,-2198,2782,7091 } },
+    { "FUJIFILM FinePix S7000", 0, 0,
 	{ 10190,-3506,-1312,-7153,15051,2238,-2003,2399,7505 } },
-    { "FUJIFILM FinePix S9000", 0,
+    { "FUJIFILM FinePix S9000", 0, 0,
 	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
-    { "FUJIFILM FinePix S9500", 0,
+    { "FUJIFILM FinePix S9500", 0, 0,
 	{ 10491,-3423,-1145,-7385,15027,2538,-1809,2275,8692 } },
-    { "FUJIFILM FinePix S9100", 0,
+    { "FUJIFILM FinePix S9100", 0, 0,
 	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
-    { "FUJIFILM FinePix S9600", 0,
+    { "FUJIFILM FinePix S9600", 0, 0,
 	{ 12343,-4515,-1285,-7165,14899,2435,-1895,2496,8800 } },
-    { "Imacon Ixpress", 0,	/* DJC */
+    { "FUJIFILM IS-1", 0, 0,
+	{ 21461,-10807,-1441,-2332,10599,1999,289,875,7703 } },
+    { "FUJIFILM IS Pro", 0, 0,
+	{ 12300,-5110,-1304,-9117,17143,1998,-1947,2448,8100 } },
+    { "Imacon Ixpress", 0, 0,		/* DJC */
 	{ 7025,-1415,-704,-5188,13765,1424,-1248,2742,6038 } },
-    { "KODAK NC2000", 0,	/* DJC */
-	{ 16475,-6903,-1218,-851,10375,477,2505,-7,1020 } },
-    { "Kodak DCS315C", 8,
+    { "KODAK NC2000", 0, 0,
+	{ 13891,-6055,-803,-465,9919,642,2121,82,1291 } },
+    { "Kodak DCS315C", 8, 0,
 	{ 17523,-4827,-2510,756,8546,-137,6113,1649,2250 } },
-    { "Kodak DCS330C", 8,
+    { "Kodak DCS330C", 8, 0,
 	{ 20620,-7572,-2801,-103,10073,-396,3551,-233,2220 } },
-    { "KODAK DCS420", 0,
+    { "KODAK DCS420", 0, 0,
 	{ 10868,-1852,-644,-1537,11083,484,2343,628,2216 } },
-    { "KODAK DCS460", 0,
+    { "KODAK DCS460", 0, 0,
 	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
-    { "KODAK EOSDCS1", 0,
+    { "KODAK EOSDCS1", 0, 0,
 	{ 10592,-2206,-967,-1944,11685,230,2206,670,1273 } },
-    { "KODAK EOSDCS3B", 0,
+    { "KODAK EOSDCS3B", 0, 0,
 	{ 9898,-2700,-940,-2478,12219,206,1985,634,1031 } },
-    { "Kodak DCS520C", 180,
+    { "Kodak DCS520C", 180, 0,
 	{ 24542,-10860,-3401,-1490,11370,-297,2858,-605,3225 } },
-    { "Kodak DCS560C", 188,
+    { "Kodak DCS560C", 188, 0,
 	{ 20482,-7172,-3125,-1033,10410,-285,2542,226,3136 } },
-    { "Kodak DCS620C", 180,
+    { "Kodak DCS620C", 180, 0,
 	{ 23617,-10175,-3149,-2054,11749,-272,2586,-489,3453 } },
-    { "Kodak DCS620X", 185,
+    { "Kodak DCS620X", 185, 0,
 	{ 13095,-6231,154,12221,-21,-2137,895,4602,2258 } },
-    { "Kodak DCS660C", 214,
+    { "Kodak DCS660C", 214, 0,
 	{ 18244,-6351,-2739,-791,11193,-521,3711,-129,2802 } },
-    { "Kodak DCS720X", 0,
+    { "Kodak DCS720X", 0, 0,
 	{ 11775,-5884,950,9556,1846,-1286,-1019,6221,2728 } },
-    { "Kodak DCS760C", 0,
+    { "Kodak DCS760C", 0, 0,
 	{ 16623,-6309,-1411,-4344,13923,323,2285,274,2926 } },
-    { "Kodak DCS Pro SLR", 0,
+    { "Kodak DCS Pro SLR", 0, 0,
 	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
-    { "Kodak DCS Pro 14nx", 0,
+    { "Kodak DCS Pro 14nx", 0, 0,
 	{ 5494,2393,-232,-6427,13850,2846,-1876,3997,5445 } },
-    { "Kodak DCS Pro 14", 0,
+    { "Kodak DCS Pro 14", 0, 0,
 	{ 7791,3128,-776,-8588,16458,2039,-2455,4006,6198 } },
-    { "Kodak ProBack645", 0,
+    { "Kodak ProBack645", 0, 0,
 	{ 16414,-6060,-1470,-3555,13037,473,2545,122,4948 } },
-    { "Kodak ProBack", 0,
+    { "Kodak ProBack", 0, 0,
 	{ 21179,-8316,-2918,-915,11019,-165,3477,-180,4210 } },
-    { "KODAK P712", 0,
+    { "KODAK P712", 0, 0,
 	{ 9658,-3314,-823,-5163,12695,2768,-1342,1843,6044 } },
-    { "KODAK P850", 0,
+    { "KODAK P850", 0, 0xf7c,
 	{ 10511,-3836,-1102,-6946,14587,2558,-1481,1792,6246 } },
-    { "KODAK P880", 0,
+    { "KODAK P880", 0, 0xfff,
 	{ 12805,-4662,-1376,-7480,15267,2360,-1626,2194,7904 } },
-    { "Leaf CMost", 0,
+    { "KODAK EasyShare Z980", 0, 0,
+	{ 11313,-3559,-1101,-3893,11891,2257,-1214,2398,4908 } },
+    { "KODAK EASYSHARE Z1015", 0, 0xef1,
+	{ 11265,-4286,-992,-4694,12343,2647,-1090,1523,5447 } },
+    { "Leaf CMost", 0, 0,
 	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
-    { "Leaf Valeo 6", 0,
+    { "Leaf Valeo 6", 0, 0,
 	{ 3952,2189,449,-6701,14585,2275,-4536,7349,6536 } },
-    { "Leaf Aptus 65", 0,
+    { "Leaf Aptus 54S", 0, 0,
+	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
+    { "Leaf Aptus 65", 0, 0,
 	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
-    { "Leaf Aptus 75", 0,
+    { "Leaf Aptus 75", 0, 0,
 	{ 7914,1414,-1190,-8777,16582,2280,-2811,4605,5562 } },
-    { "Leaf", 0,
+    { "Leaf", 0, 0,
 	{ 8236,1746,-1314,-8251,15953,2428,-3673,5786,5771 } },
-    { "Micron 2010", 110,	/* DJC */
+    { "Mamiya ZD", 0, 0,
+	{ 7645,2579,-1363,-8689,16717,2015,-3712,5941,5961 } },
+    { "Micron 2010", 110, 0,		/* DJC */
 	{ 16695,-3761,-2151,155,9682,163,3433,951,4904 } },
-    { "Minolta DiMAGE 5", 0,
+    { "Minolta DiMAGE 5", 0, 0xf7d,
 	{ 8983,-2942,-963,-6556,14476,2237,-2426,2887,8014 } },
-    { "Minolta DiMAGE 7Hi", 0,
+    { "Minolta DiMAGE 7Hi", 0, 0xf7d,
 	{ 11368,-3894,-1242,-6521,14358,2339,-2475,3056,7285 } },
-    { "Minolta DiMAGE 7", 0,
+    { "Minolta DiMAGE 7", 0, 0xf7d,
 	{ 9144,-2777,-998,-6676,14556,2281,-2470,3019,7744 } },
-    { "Minolta DiMAGE A1", 0,
+    { "Minolta DiMAGE A1", 0, 0xf8b,
 	{ 9274,-2547,-1167,-8220,16323,1943,-2273,2720,8340 } },
-    { "MINOLTA DiMAGE A200", 0,
+    { "MINOLTA DiMAGE A200", 0, 0,
 	{ 8560,-2487,-986,-8112,15535,2771,-1209,1324,7743 } },
-    { "Minolta DiMAGE A2", 0,
+    { "Minolta DiMAGE A2", 0, 0xf8f,
 	{ 9097,-2726,-1053,-8073,15506,2762,-966,981,7763 } },
-    { "Minolta DiMAGE Z2", 0,	/* DJC */
+    { "Minolta DiMAGE Z2", 0, 0,	/* DJC */
 	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
-    { "MINOLTA DYNAX 5", 0,
+    { "MINOLTA DYNAX 5", 0, 0xffb,
 	{ 10284,-3283,-1086,-7957,15762,2316,-829,882,6644 } },
-    { "MINOLTA DYNAX 7", 0,
+    { "MINOLTA DYNAX 7", 0, 0xffb,
 	{ 10239,-3104,-1099,-8037,15727,2451,-927,925,6871 } },
-    { "NIKON D100", 0,
+    { "MOTOROLA PIXL", 0, 0,		/* DJC */
+	{ 8898,-989,-1033,-3292,11619,1674,-661,3178,5216 } },
+    { "NIKON D100", 0, 0,
 	{ 5902,-933,-782,-8983,16719,2354,-1402,1455,6464 } },
-    { "NIKON D1H", 0,
+    { "NIKON D1H", 0, 0,
 	{ 7577,-2166,-926,-7454,15592,1934,-2377,2808,8606 } },
-    { "NIKON D1X", 0,
+    { "NIKON D1X", 0, 0,
 	{ 7702,-2245,-975,-9114,17242,1875,-2679,3055,8521 } },
-    { "NIKON D1", 0,	/* multiplied by 2.218750, 1.0, 1.148438 */
+    { "NIKON D1", 0, 0, /* multiplied by 2.218750, 1.0, 1.148438 */
 	{ 16772,-4726,-2141,-7611,15713,1972,-2846,3494,9521 } },
-    { "NIKON D2H", 0,
+    { "NIKON D200", 0, 0xfbc,
+	{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },
+    { "NIKON D2H", 0, 0,
 	{ 5710,-901,-615,-8594,16617,2024,-2975,4120,6830 } },
-    { "NIKON D2X", 0,
+    { "NIKON D2X", 0, 0,
 	{ 10231,-2769,-1255,-8301,15900,2552,-797,680,7148 } },
-    { "NIKON D50", 0,
+    { "NIKON D3000", 0, 0,
+	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
+    { "NIKON D300", 0, 0,
+	{ 9030,-1992,-715,-8465,16302,2255,-2689,3217,8069 } },
+    { "NIKON D3X", 0, 0,
+	{ 7171,-1986,-648,-8085,15555,2718,-2170,2512,7457 } },
+    { "NIKON D3", 0, 0,
+	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
+    { "NIKON D40X", 0, 0,
+	{ 8819,-2543,-911,-9025,16928,2151,-1329,1213,8449 } },
+    { "NIKON D40", 0, 0,
+	{ 6992,-1668,-806,-8138,15748,2543,-874,850,7897 } },
+    { "NIKON D5000", 0, 0xf00,
+	{ 7309,-1403,-519,-8474,16008,2622,-2433,2826,8064 } },
+    { "NIKON D50", 0, 0,
 	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
-    { "NIKON D70", 0,
+    { "NIKON D60", 0, 0,
+	{ 8736,-2458,-935,-9075,16894,2251,-1354,1242,8263 } },
+    { "NIKON D700", 0, 0,
+	{ 8139,-2171,-663,-8747,16541,2295,-1925,2008,8093 } },
+    { "NIKON D70", 0, 0,
 	{ 7732,-2422,-789,-8238,15884,2498,-859,783,7330 } },
-    { "NIKON D80", 0,
+    { "NIKON D80", 0, 0,
 	{ 8629,-2410,-883,-9055,16940,2171,-1490,1363,8520 } },
-    { "NIKON D200", 0,
-	{ 8367,-2248,-763,-8758,16447,2422,-1527,1550,8053 } },
-    { "NIKON E950", 0,		/* DJC */
+    { "NIKON D90", 0, 0xf00,
+	{ 7309,-1403,-519,-8474,16008,2622,-2434,2826,8064 } },
+    { "NIKON E950", 0, 0x3dd,		/* DJC */
 	{ -3746,10611,1665,9621,-1734,2114,-2389,7082,3064,3406,6116,-244 } },
-    { "NIKON E995", 0,	/* copied from E5000 */
+    { "NIKON E995", 0, 0,	/* copied from E5000 */
 	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
-    { "NIKON E2500", 0,
+    { "NIKON E2100", 0, 0,	/* copied from Z2, new white balance */
+	{ 13142,-4152,-1596,-4655,12374,2282,-1769,2696,6711} },
+    { "NIKON E2500", 0, 0,
 	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
-    { "NIKON E4300", 0, /* copied from Minolta DiMAGE Z2 */
+    { "NIKON E4300", 0, 0,	/* copied from Minolta DiMAGE Z2 */
 	{ 11280,-3564,-1370,-4655,12374,2282,-1423,2168,5396 } },
-    { "NIKON E4500", 0,
+    { "NIKON E4500", 0, 0,
 	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
-    { "NIKON E5000", 0,
+    { "NIKON E5000", 0, 0,
 	{ -5547,11762,2189,5814,-558,3342,-4924,9840,5949,688,9083,96 } },
-    { "NIKON E5400", 0,
+    { "NIKON E5400", 0, 0,
 	{ 9349,-2987,-1001,-7919,15766,2266,-2098,2680,6839 } },
-    { "NIKON E5700", 0,
+    { "NIKON E5700", 0, 0,
 	{ -5368,11478,2368,5537,-113,3148,-4969,10021,5782,778,9028,211 } },
-    { "NIKON E8400", 0,
+    { "NIKON E8400", 0, 0,
 	{ 7842,-2320,-992,-8154,15718,2599,-1098,1342,7560 } },
-    { "NIKON E8700", 0,
+    { "NIKON E8700", 0, 0,
 	{ 8489,-2583,-1036,-8051,15583,2643,-1307,1407,7354 } },
-    { "NIKON E8800", 0,
+    { "NIKON E8800", 0, 0,
 	{ 7971,-2314,-913,-8451,15762,2894,-1442,1520,7610 } },
-    { "OLYMPUS C5050", 0,
+    { "NIKON COOLPIX P6000", 0, 0,
+	{ 9698,-3367,-914,-4706,12584,2368,-837,968,5801 } },
+    { "OLYMPUS C5050", 0, 0,
 	{ 10508,-3124,-1273,-6079,14294,1901,-1653,2306,6237 } },
-    { "OLYMPUS C5060", 0,
+    { "OLYMPUS C5060", 0, 0,
 	{ 10445,-3362,-1307,-7662,15690,2058,-1135,1176,7602 } },
-    { "OLYMPUS C7070", 0,
+    { "OLYMPUS C7070", 0, 0,
 	{ 10252,-3531,-1095,-7114,14850,2436,-1451,1723,6365 } },
-    { "OLYMPUS C70", 0,
+    { "OLYMPUS C70", 0, 0,
 	{ 10793,-3791,-1146,-7498,15177,2488,-1390,1577,7321 } },
-    { "OLYMPUS C80", 0,
+    { "OLYMPUS C80", 0, 0,
 	{ 8606,-2509,-1014,-8238,15714,2703,-942,979,7760 } },
-    { "OLYMPUS E-10", 0,
+    { "OLYMPUS E-10", 0, 0xffc0,
 	{ 12745,-4500,-1416,-6062,14542,1580,-1934,2256,6603 } },
-    { "OLYMPUS E-1", 0,
+    { "OLYMPUS E-1", 0, 0xfff0,
 	{ 11846,-4767,-945,-7027,15878,1089,-2699,4122,8311 } },
-    { "OLYMPUS E-20", 0,
+    { "OLYMPUS E-20", 0, 0xffc0,
 	{ 13173,-4732,-1499,-5807,14036,1895,-2045,2452,7142 } },
-    { "OLYMPUS E-300", 0,
+    { "OLYMPUS E-300", 0, 0,
 	{ 7828,-1761,-348,-5788,14071,1830,-2853,4518,6557 } },
-    { "OLYMPUS E-330", 0,
+    { "OLYMPUS E-330", 0, 0,
 	{ 8961,-2473,-1084,-7979,15990,2067,-2319,3035,8249 } },
-    { "OLYMPUS E-400", 0,
+    { "OLYMPUS E-30", 0, 0xfbc,
+	{ 8144,-1861,-1111,-7763,15894,1929,-1865,2542,7607 } },
+    { "OLYMPUS E-3", 0, 0xf99,
+	{ 9487,-2875,-1115,-7533,15606,2010,-1618,2100,7389 } },
+    { "OLYMPUS E-400", 0, 0xfff0,
 	{ 6169,-1483,-21,-7107,14761,2536,-2904,3580,8568 } },
-    { "OLYMPUS E-500", 0,
+    { "OLYMPUS E-410", 0, 0xf6a,
+	{ 8856,-2582,-1026,-7761,15766,2082,-2009,2575,7469 } },
+    { "OLYMPUS E-420", 0, 0xfd7,
+	{ 8746,-2425,-1095,-7594,15612,2073,-1780,2309,7416 } },
+    { "OLYMPUS E-450", 0, 0xfd2,
+	{ 8745,-2425,-1095,-7594,15613,2073,-1780,2309,7416 } },
+    { "OLYMPUS E-500", 0, 0xfff0,
 	{ 8136,-1968,-299,-5481,13742,1871,-2556,4205,6630 } },
-    { "OLYMPUS SP350", 0,
+    { "OLYMPUS E-510", 0, 0xf6a,
+	{ 8785,-2529,-1033,-7639,15624,2112,-1783,2300,7817 } },
+    { "OLYMPUS E-520", 0, 0xfd2,
+	{ 8344,-2322,-1020,-7596,15635,2048,-1748,2269,7287 } },
+    { "OLYMPUS E-620", 0, 0xfb9,
+	{ 8453,-2198,-1092,-7609,15681,2008,-1725,2337,7824 } },
+    { "OLYMPUS E-P1", 0, 0xffd,
+	{ 8343,-2050,-1021,-7715,15705,2103,-1831,2380,8235 } },
+    { "OLYMPUS SP350", 0, 0,
 	{ 12078,-4836,-1069,-6671,14306,2578,-786,939,7418 } },
-    { "OLYMPUS SP3", 0,
+    { "OLYMPUS SP3", 0, 0,
 	{ 11766,-4445,-1067,-6901,14421,2707,-1029,1217,7572 } },
-    { "OLYMPUS SP500UZ", 0,
+    { "OLYMPUS SP500UZ", 0, 0xfff,
 	{ 9493,-3415,-666,-5211,12334,3260,-1548,2262,6482 } },
-    { "PENTAX *ist DL2", 0,
+    { "OLYMPUS SP510UZ", 0, 0xffe,
+	{ 10593,-3607,-1010,-5881,13127,3084,-1200,1805,6721 } },
+    { "OLYMPUS SP550UZ", 0, 0xffe,
+	{ 11597,-4006,-1049,-5432,12799,2957,-1029,1750,6516 } },
+    { "OLYMPUS SP560UZ", 0, 0xff9,
+	{ 10915,-3677,-982,-5587,12986,2911,-1168,1968,6223 } },
+    { "OLYMPUS SP570UZ", 0, 0,
+	{ 11522,-4044,-1146,-4736,12172,2904,-988,1829,6039 } },
+    { "PENTAX *ist DL2", 0, 0,
 	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
-    { "PENTAX *ist DL", 0,
+    { "PENTAX *ist DL", 0, 0,
 	{ 10829,-2838,-1115,-8339,15817,2696,-837,680,11939 } },
-    { "PENTAX *ist DS2", 0,
+    { "PENTAX *ist DS2", 0, 0,
 	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
-    { "PENTAX *ist DS", 0,
+    { "PENTAX *ist DS", 0, 0,
 	{ 10371,-2333,-1206,-8688,16231,2602,-1230,1116,11282 } },
-    { "PENTAX *ist D", 0,
+    { "PENTAX *ist D", 0, 0,
 	{ 9651,-2059,-1189,-8881,16512,2487,-1460,1345,10687 } },
-    { "PENTAX K10D", 0,
-	{ 28402,-6651,-983,-14699,32553,6467,-1746,1571,25283 } },
-    { "PENTAX K1", 0,
+    { "PENTAX K10D", 0, 0,
+	{ 9566,-2863,-803,-7170,15172,2112,-818,803,9705 } },
+    { "PENTAX K1", 0, 0,
 	{ 11095,-3157,-1324,-8377,15834,2720,-1108,947,11688 } },
-    { "Panasonic DMC-FZ30", 0,
+    { "PENTAX K20D", 0, 0,
+	{ 9427,-2714,-868,-7493,16092,1373,-2199,3264,7180 } },
+    { "PENTAX K200D", 0, 0,
+	{ 9186,-2678,-907,-8693,16517,2260,-1129,1094,8524 } },
+    { "PENTAX K2000", 0, 0,
+	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
+    { "PENTAX K-m", 0, 0,
+	{ 11057,-3604,-1155,-5152,13046,2329,-282,375,8104 } },
+    { "PENTAX K-7", 0, 0,
+	{ 9142,-2947,-678,-8648,16967,1663,-2224,2898,8615 } },
+    { "Panasonic DMC-FZ8", 0, 0xf7f0,
+	{ 8986,-2755,-802,-6341,13575,3077,-1476,2144,6379 } },
+    { "Panasonic DMC-FZ18", 0, 0,
+	{ 9932,-3060,-935,-5809,13331,2753,-1267,2155,5575 } },
+    { "Panasonic DMC-FZ28", 15, 0xfff,
+	{ 10109,-3488,-993,-5412,12812,2916,-1305,2140,5543 } },
+    { "Panasonic DMC-FZ30", 0, 0xf94c,
 	{ 10976,-4029,-1141,-7918,15491,2600,-1670,2071,8246 } },
-    { "Panasonic DMC-FZ50", 0,
+    { "Panasonic DMC-FZ35", 147, 0xfff,
+	{ 9938,-2780,-890,-4604,12393,2480,-1117,2304,4620 } },
+    { "Panasonic DMC-FZ50", 0, 0xfff0,	/* aka "LEICA V-LUX1" */
 	{ 7906,-2709,-594,-6231,13351,3220,-1922,2631,6537 } },
-    { "Panasonic DMC-LC1", 0,
+    { "Panasonic DMC-L10", 15, 0xf96,
+	{ 8025,-1942,-1050,-7920,15904,2100,-2456,3005,7039 } },
+    { "Panasonic DMC-L1", 0, 0xf7fc,	/* aka "LEICA DIGILUX 3" */
+	{ 8054,-1885,-1025,-8349,16367,2040,-2805,3542,7629 } },
+    { "Panasonic DMC-LC1", 0, 0,	/* aka "LEICA DIGILUX 2" */
 	{ 11340,-4069,-1275,-7555,15266,2448,-2960,3426,7685 } },
-    { "Panasonic DMC-LX1", 0,
+    { "Panasonic DMC-LX1", 0, 0xf7f0,	/* aka "LEICA D-LUX2" */
 	{ 10704,-4187,-1230,-8314,15952,2501,-920,945,8927 } },
-    { "Panasonic DMC-LX2", 0,
+    { "Panasonic DMC-LX2", 0, 0,	/* aka "LEICA D-LUX3" */
 	{ 8048,-2810,-623,-6450,13519,3272,-1700,2146,7049 } },
-    { "SAMSUNG GX-1", 0,
+    { "Panasonic DMC-LX3", 15, 0xfff,	/* aka "LEICA D-LUX4" */
+	{ 8128,-2668,-655,-6134,13307,3161,-1782,2568,6083 } },
+    { "Panasonic DMC-FX150", 15, 0xfff,
+	{ 9082,-2907,-925,-6119,13377,3058,-1797,2641,5609 } },
+    { "Panasonic DMC-G1", 15, 0xfff,
+	{ 8199,-2065,-1056,-8124,16156,2033,-2458,3022,7220 } },
+    { "Panasonic DMC-GF1", 15, 0xf92,
+	{ 7888,-1902,-1011,-8106,16085,2099,-2353,2866,7330 } },
+    { "Panasonic DMC-GH1", 15, 0xf92,
+	{ 6299,-1466,-532,-6535,13852,2969,-2331,3112,5984 } },
+    { "Phase One H 20", 0, 0,		/* DJC */
+	{ 1313,1855,-109,-6715,15908,808,-327,1840,6020 } },
+    { "Phase One P 2", 0, 0,
+	{ 2905,732,-237,-8134,16626,1476,-3038,4253,7517 } },
+    { "Phase One P 30", 0, 0,
+	{ 4516,-245,-37,-7020,14976,2173,-3206,4671,7087 } },
+    { "Phase One P 45", 0, 0,
+	{ 5053,-24,-117,-5684,14076,1702,-2619,4492,5849 } },
+    { "Phase One P65", 0, 0,		/* DJC */
+	{ 8522,1268,-1916,-7706,16350,1358,-2397,4344,4923 } },
+    { "SAMSUNG GX-1", 0, 0,
 	{ 10504,-2438,-1189,-8603,16207,2531,-1022,863,12242 } },
-    { "Sinar", 0,		/* DJC */
+    { "SAMSUNG S85", 0, 0,		/* DJC */
+	{ 11885,-3968,-1473,-4214,12299,1916,-835,1655,5549 } },
+    { "Sinar", 0, 0,			/* DJC */
 	{ 16442,-2956,-2422,-2877,12128,750,-1136,6066,4559 } },
-    { "SONY DSC-F828", 491,
+    { "SONY DSC-F828", 491, 0,
 	{ 7924,-1910,-777,-8226,15459,2998,-1517,2199,6818,-7242,11401,3481 } },
-    { "SONY DSC-R1", 512,
+    { "SONY DSC-R1", 512, 0,
 	{ 8512,-2641,-694,-8042,15670,2526,-1821,2117,7414 } },
-    { "SONY DSC-V3", 0,
+    { "SONY DSC-V3", 0, 0,
 	{ 7511,-2571,-692,-7894,15088,3060,-948,1111,8128 } },
-    { "SONY DSLR-A100", 0,
-	{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } }
+    { "SONY DSLR-A100", 0, 0xfeb,
+	{ 9437,-2811,-774,-8405,16215,2290,-710,596,7181 } },
+    { "SONY DSLR-A200", 0, 0,
+	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
+    { "SONY DSLR-A230", 0, 0,	/* copied */
+	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
+    { "SONY DSLR-A300", 0, 0,
+	{ 9847,-3091,-928,-8485,16345,2225,-715,595,7103 } },
+    { "SONY DSLR-A330", 0, 0,
+	{ 9847,-3091,-929,-8485,16346,2225,-714,595,7103 } },
+    { "SONY DSLR-A350", 0, 0xffc,
+	{ 6038,-1484,-578,-9146,16746,2513,-875,746,7217 } },
+    { "SONY DSLR-A380", 0, 0,
+	{ 6038,-1484,-579,-9145,16746,2512,-875,746,7218 } },
+    { "SONY DSLR-A700", 254, 0x1ffe,
+	{ 5775,-805,-359,-8574,16295,2391,-1943,2341,7249 } },
+    { "SONY DSLR-A850", 256, 0x1ffe,
+	{ 5209,-1072,-397,-8845,16121,2919,-1618,1802,8654 } },
+    { "SONY DSLR-A900", 254, 0x1ffe,
+	{ 5209,-1072,-397,-8845,16120,2919,-1618,1803,8654 } }
   };
   double cam_xyz[4][3];
   char name[130];
@@ -5521,11 +6469,13 @@
   sprintf (name, "%s %s", make, model);
   for (i=0; i < sizeof table / sizeof *table; i++)
     if (!strncmp (name, table[i].prefix, strlen(table[i].prefix))) {
-      if (table[i].black)
-	black = table[i].black;
-      for (j=0; j < 12; j++)
-	cam_xyz[0][j] = table[i].trans[j] / 10000.0;
-      cam_xyz_coeff (cam_xyz);
+      if (table[i].black)   black   = (ushort) table[i].black;
+      if (table[i].maximum) maximum = (ushort) table[i].maximum;
+      if (table[i].trans[0]) {
+	for (j=0; j < 12; j++)
+	  cam_xyz[0][j] = table[i].trans[j] / 10000.0;
+	cam_xyz_coeff (cam_xyz);
+      }
       break;
     }
 }
@@ -5569,6 +6519,31 @@
   return sum[0] < sum[1] ? 0x4d4d : 0x4949;
 }
 
+float CLASS find_green (int bps, int bite, int off0, int off1)
+{
+  UINT64 bitbuf=0;
+  int vbits, col, i, c;
+  ushort img[2][2064];
+  double sum[]={0,0};
+
+  FORC(2) {
+    fseek (ifp, c ? off1:off0, SEEK_SET);
+    for (vbits=col=0; col < width; col++) {
+      for (vbits -= bps; vbits < 0; vbits += bite) {
+	bitbuf <<= bite;
+	for (i=0; i < bite; i+=8)
+	  bitbuf |= (unsigned) (fgetc(ifp) << i);
+      }
+      img[c][col] = bitbuf << (64-bps-vbits) >> (64-bps);
+    }
+  }
+  FORC(width-1) {
+    sum[ c & 1] += ABS(img[0][c]-img[1][c+1]);
+    sum[~c & 1] += ABS(img[1][c]-img[0][c+1]);
+  }
+  return 100 * log(sum[0]/sum[1]);
+}
+
 /*
    Identify which camera created this file, and set global variables
    accordingly.
@@ -5576,88 +6551,115 @@
 void CLASS identify()
 {
   char head[32], *cp;
-  unsigned hlen, fsize, i, c, is_canon;
+  int hlen, fsize, i, c, is_canon;
   struct jhead jh;
   static const struct {
     int fsize;
     char make[12], model[19], withjpeg;
   } table[] = {
-    {    62464, "Kodak",    "DC20"       ,0 },
-    {   124928, "Kodak",    "DC20"       ,0 },
-    {  1652736, "Kodak",    "DCS200"     ,0 },
-    {   311696, "ST Micro", "STV680 VGA" ,0 },  /* SPYz */
-    {   614400, "Kodak",    "KAI-0340"   ,0 },
-    {   787456, "Creative", "PC-CAM 600" ,0 },
-    {  1138688, "Minolta",  "RD175"      ,0 },
-    {  3840000, "Foculus",  "531C"       ,0 },
-    {  1447680, "AVT",      "F-145C"     ,0 },
-    {  1920000, "AVT",      "F-201C"     ,0 },
-    {  5067304, "AVT",      "F-510C"     ,0 },
-    { 10134608, "AVT",      "F-510C"     ,0 },
-    { 16157136, "AVT",      "F-810C"     ,0 },
-    {  1409024, "Sony",     "XCD-SX910CR",0 },
-    {  2818048, "Sony",     "XCD-SX910CR",0 },
-    {  3884928, "Micron",   "2010"       ,0 },
-    {  6624000, "Pixelink", "A782"       ,0 },
-    { 13248000, "Pixelink", "A782"       ,0 },
-    {  6291456, "RoverShot","3320AF"     ,0 },
-    {  6573120, "Canon",    "PowerShot A610",0 },
-    {  9219600, "Canon",    "PowerShot A620",0 },
-    {  7710960, "Canon",    "PowerShot S3 IS",0 },
-    {  5939200, "OLYMPUS",  "C770UZ"     ,0 },
-    {  1581060, "NIKON",    "E900"       ,1 },  /* or E900s,E910 */
-    {  2465792, "NIKON",    "E950"       ,1 },  /* or E800,E700 */
-    {  2940928, "NIKON",    "E2100"      ,1 },  /* or E2500 */
-    {  4771840, "NIKON",    "E990"       ,1 },  /* or E995, Oly C3030Z */
-    {  4775936, "NIKON",    "E3700"      ,1 },  /* or Optio 33WR */
-    {  5869568, "NIKON",    "E4300"      ,1 },  /* or DiMAGE Z2 */
-    {  5865472, "NIKON",    "E4500"      ,1 },
-    {  7438336, "NIKON",    "E5000"      ,1 },  /* or E5700 */
-    {  1976352, "CASIO",    "QV-2000UX"  ,1 },
-    {  3217760, "CASIO",    "QV-3*00EX"  ,1 },
-    {  6218368, "CASIO",    "QV-5700"    ,1 },
-    {  7530816, "CASIO",    "QV-R51"     ,1 },
-    {  7684000, "CASIO",    "QV-4000"    ,1 },
-    {  4948608, "CASIO",    "EX-S100"    ,1 },
-    {  7542528, "CASIO",    "EX-Z50"     ,1 },
-    {  7753344, "CASIO",    "EX-Z55"     ,1 },
-    {  7426656, "CASIO",    "EX-P505"    ,1 },
-    {  9313536, "CASIO",    "EX-P600"    ,1 },
-    { 10979200, "CASIO",    "EX-P700"    ,1 },
-    {  3178560, "PENTAX",   "Optio S"    ,1 },
-    {  4841984, "PENTAX",   "Optio S"    ,1 },
-    {  6114240, "PENTAX",   "Optio S4"   ,1 },  /* or S4i */
-    { 12582980, "Sinar",    ""           ,0 },
-    { 33292868, "Sinar",    ""           ,0 },
-    { 44390468, "Sinar",    ""           ,0 } };
+    {    62464, "Kodak",    "DC20"            ,0 },
+    {   124928, "Kodak",    "DC20"            ,0 },
+    {  1652736, "Kodak",    "DCS200"          ,0 },
+    {  4159302, "Kodak",    "C330"            ,0 },
+    {  4162462, "Kodak",    "C330"            ,0 },
+    {   460800, "Kodak",    "C603v"           ,0 },
+    {   614400, "Kodak",    "C603v"           ,0 },
+    {  6163328, "Kodak",    "C603"            ,0 },
+    {  6166488, "Kodak",    "C603"            ,0 },
+    {  9116448, "Kodak",    "C603y"           ,0 },
+    {   311696, "ST Micro", "STV680 VGA"      ,0 },  /* SPYz */
+    {   787456, "Creative", "PC-CAM 600"      ,0 },
+    {  1138688, "Minolta",  "RD175"           ,0 },
+    {  3840000, "Foculus",  "531C"            ,0 },
+    {   786432, "AVT",      "F-080C"          ,0 },
+    {  1447680, "AVT",      "F-145C"          ,0 },
+    {  1920000, "AVT",      "F-201C"          ,0 },
+    {  5067304, "AVT",      "F-510C"          ,0 },
+    { 10134608, "AVT",      "F-510C"          ,0 },
+    { 16157136, "AVT",      "F-810C"          ,0 },
+    {  1409024, "Sony",     "XCD-SX910CR"     ,0 },
+    {  2818048, "Sony",     "XCD-SX910CR"     ,0 },
+    {  3884928, "Micron",   "2010"            ,0 },
+    {  6624000, "Pixelink", "A782"            ,0 },
+    { 13248000, "Pixelink", "A782"            ,0 },
+    {  6291456, "RoverShot","3320AF"          ,0 },
+    {  6553440, "Canon",    "PowerShot A460"  ,0 },
+    {  6653280, "Canon",    "PowerShot A530"  ,0 },
+    {  6573120, "Canon",    "PowerShot A610"  ,0 },
+    {  9219600, "Canon",    "PowerShot A620"  ,0 },
+    {  9243240, "Canon",    "PowerShot A470"  ,0 },
+    { 10341600, "Canon",    "PowerShot A720"  ,0 },
+    { 10383120, "Canon",    "PowerShot A630"  ,0 },
+    { 12945240, "Canon",    "PowerShot A640"  ,0 },
+    { 15636240, "Canon",    "PowerShot A650"  ,0 },
+    {  5298000, "Canon",    "PowerShot SD300" ,0 },
+    {  7710960, "Canon",    "PowerShot S3 IS" ,0 },
+    { 15467760, "Canon",    "PowerShot SX110 IS",0 },
+    {  5939200, "OLYMPUS",  "C770UZ"          ,0 },
+    {  1581060, "NIKON",    "E900"            ,1 },  /* or E900s,E910 */
+    {  2465792, "NIKON",    "E950"            ,1 },  /* or E800,E700 */
+    {  2940928, "NIKON",    "E2100"           ,1 },  /* or E2500 */
+    {  4771840, "NIKON",    "E990"            ,1 },  /* or E995, Oly C3030Z */
+    {  4775936, "NIKON",    "E3700"           ,1 },  /* or Optio 33WR */
+    {  5869568, "NIKON",    "E4300"           ,1 },  /* or DiMAGE Z2 */
+    {  5865472, "NIKON",    "E4500"           ,1 },
+    {  7438336, "NIKON",    "E5000"           ,1 },  /* or E5700 */
+    {  8998912, "NIKON",    "COOLPIX S6"      ,1 },
+    {  1976352, "CASIO",    "QV-2000UX"       ,1 },
+    {  3217760, "CASIO",    "QV-3*00EX"       ,1 },
+    {  6218368, "CASIO",    "QV-5700"         ,1 },
+    {  6054400, "CASIO",    "QV-R41"          ,1 },
+    {  7530816, "CASIO",    "QV-R51"          ,1 },
+    {  7684000, "CASIO",    "QV-4000"         ,1 },
+    {  2937856, "CASIO",    "EX-S20"          ,1 },
+    {  4948608, "CASIO",    "EX-S100"         ,1 },
+    {  7542528, "CASIO",    "EX-Z50"          ,1 },
+    {  7753344, "CASIO",    "EX-Z55"          ,1 },
+    {  7816704, "CASIO",    "EX-Z60"          ,1 },
+    { 10843712, "CASIO",    "EX-Z75"          ,1 },
+    { 12310144, "CASIO",    "EX-Z850"         ,1 },
+    {  7426656, "CASIO",    "EX-P505"         ,1 },
+    {  9313536, "CASIO",    "EX-P600"         ,1 },
+    { 10979200, "CASIO",    "EX-P700"         ,1 },
+    {  3178560, "PENTAX",   "Optio S"         ,1 },
+    {  4841984, "PENTAX",   "Optio S"         ,1 },
+    {  6114240, "PENTAX",   "Optio S4"        ,1 },  /* or S4i, CASIO EX-Z4 */
+    { 10702848, "PENTAX",   "Optio 750Z"      ,1 },
+    { 15980544, "AGFAPHOTO","DC-833m"         ,1 },
+    { 16098048, "SAMSUNG",  "S85"             ,1 },
+    { 16215552, "SAMSUNG",  "S85"             ,1 },
+    { 12582980, "Sinar",    ""                ,0 },
+    { 33292868, "Sinar",    ""                ,0 },
+    { 44390468, "Sinar",    ""                ,0 } };
   static const char *corp[] =
     { "Canon", "NIKON", "EPSON", "KODAK", "Kodak", "OLYMPUS", "PENTAX",
       "MINOLTA", "Minolta", "Konica", "CASIO", "Sinar", "Phase One",
-      "SAMSUNG" };
+      "SAMSUNG", "Mamiya", "MOTOROLA" };
 
   tiff_flip = flip = filters = -1;	/* 0 is valid, so -1 is unknown */
-  raw_height = raw_width = fuji_width = cr2_slice[0] = 0;
+  raw_height = raw_width = fuji_width = fuji_layout = cr2_slice[0] = 0;
   maximum = height = width = top_margin = left_margin = 0;
-  make[0] = model[0] = model2[0] = cdesc[0] = 0;
+  cdesc[0] = desc[0] = artist[0] = make[0] = model[0] = model2[0] = 0;
   iso_speed = shutter = aperture = focal_len = unique_id = 0;
+  memset (gpsdata, 0, sizeof gpsdata);
   memset (white, 0, sizeof white);
   thumb_offset = thumb_length = thumb_width = thumb_height = 0;
-  load_raw = thumb_load_raw = NULL;
+  load_raw = thumb_load_raw = 0;
   write_thumb = &CLASS jpeg_thumb;
   data_offset = meta_length = tiff_bps = tiff_compress = 0;
-  kodak_cbpp = zero_after_ff = dng_version = fuji_secondary = 0;
+  kodak_cbpp = zero_after_ff = dng_version = load_flags = 0;
   timestamp = shot_order = tiff_samples = black = is_foveon = 0;
-  pixel_aspect = is_raw = raw_color = use_gamma = 1;
-  tile_length = INT_MAX;
+  mix_green = profile_length = data_error = zero_is_bad = 0;
+  pixel_aspect = is_raw = raw_color = 1;
+  tile_width = tile_length = INT_MAX;
   for (i=0; i < 4; i++) {
     cam_mul[i] = i == 1;
     pre_mul[i] = i < 3;
+    FORC3 cmatrix[c][i] = 0;
     FORC3 rgb_cam[c][i] = c == i;
   }
   colors = 3;
-  tiff_bps = 12;
-  for (i=0; i < 0x1000; i++) curve[i] = i;
-  profile_length = 0;
+  for (i=0; i < 0x4000; i++) curve[i] = i;
 
   order = get2();
   hlen = get4();
@@ -5684,29 +6686,6 @@
     if (fgetc(ifp) != 0xff)
       parse_tiff(12);
     thumb_offset = 0;
-  } else if (!memcmp (head,"BM",2) &&
-	head[26] == 1 && head[28] == 16 && head[30] == 0) {
-    data_offset = 0x1000;
-    order = 0x4949;
-    fseek (ifp, 38, SEEK_SET);
-    if (get4() == 2834 && get4() == 2834 && get4() == 0 && get4() == 4096) {
-      strcpy (model, "BMQ");
-      flip = 3;
-      goto nucore;
-    }
-  } else if (!memcmp (head,"BR",2)) {
-    strcpy (model, "RAW");
-nucore:
-    strcpy (make, "Nucore");
-    order = 0x4949;
-    fseek (ifp, 10, SEEK_SET);
-    data_offset += get4();
-    raw_width = (get4(),get4());
-    raw_height = get4();
-    if (model[0] == 'B' && raw_width == 2597) {
-      raw_width++;
-      data_offset -= 0x1000;
-    }
   } else if (!memcmp (head+25,"ARECOYK",7)) {
     strcpy (make, "Contax");
     strcpy (model,"N Digital");
@@ -5717,6 +6696,12 @@
   } else if (!strcmp (head, "PXN")) {
     strcpy (make, "Logitech");
     strcpy (model,"Fotoman Pixtura");
+  } else if (!strcmp (head, "qktk")) {
+    strcpy (make, "Apple");
+    strcpy (model,"QuickTake 100");
+  } else if (!strcmp (head, "qktn")) {
+    strcpy (make, "Apple");
+    strcpy (model,"QuickTake 150");
   } else if (!memcmp (head,"FUJIFILM",8)) {
     fseek (ifp, 84, SEEK_SET);
     thumb_offset = get4();
@@ -5725,8 +6710,8 @@
     parse_fuji (get4());
     if (thumb_offset > 120) {
       fseek (ifp, 120, SEEK_SET);
-      fuji_secondary = (i = get4()) && 1;
-      if (fuji_secondary && shot_select)
+      is_raw += (i = get4()) && 1;
+      if (is_raw == 2 && shot_select)
 	parse_fuji (i);
     }
     fseek (ifp, 100, SEEK_SET);
@@ -5735,12 +6720,27 @@
   } else if (!memcmp (head,"RIFF",4)) {
     fseek (ifp, 0, SEEK_SET);
     parse_riff();
+  } else if (!memcmp (head,"\0\001\0\001\0@",6)) {
+    fseek (ifp, 6, SEEK_SET);
+    fread (make, 1, 8, ifp);
+    fread (model, 1, 8, ifp);
+    fread (model2, 1, 16, ifp);
+    data_offset = get2();
+    get2();
+    raw_width = get2();
+    raw_height = get2();
+    load_raw = &CLASS nokia_load_raw;
+    filters = 0x61616161;
   } else if (!memcmp (head,"DSC-Image",9))
     parse_rollei();
+  else if (!memcmp (head,"PWAD",4))
+    parse_sinar_ia();
   else if (!memcmp (head,"\0MRM",4))
     parse_minolta(0);
   else if (!memcmp (head,"FOVb",4))
     parse_foveon();
+  else if (!memcmp (head,"CI",2))
+    parse_cine();
   else
     for (i=0; i < sizeof table / sizeof *table; i++)
       if (fsize == table[i].fsize) {
@@ -5755,23 +6755,23 @@
   for (i=0; i < sizeof corp / sizeof *corp; i++)
     if (strstr (make, corp[i]))		/* Simplify company names */
 	strcpy (make, corp[i]);
-  if (!strncmp (make,"KODAK",5))
-    make[16] = model[16] = 0;
+  if (!strncmp (make,"KODAK",5) &&
+	((cp = strstr(model," DIGITAL CAMERA")) ||
+	 (cp = strstr(model," Digital Camera")) ||
+	 (cp = strstr(model,"FILE VERSION"))))
+     *cp = 0;
   cp = make + strlen(make);		/* Remove trailing spaces */
   while (*--cp == ' ') *cp = 0;
   cp = model + strlen(model);
   while (*--cp == ' ') *cp = 0;
   i = strlen(make);			/* Remove make from model */
-  if (!strncmp (model, make, i) && model[i++] == ' ')
+  if (!strncasecmp (model, make, i) && model[i++] == ' ')
     memmove (model, model+i, 64-i);
   if (!strncmp (model,"Digital Camera ",15))
     strcpy (model, model+15);
-  make[63] = model[63] = model2[63] = 0;
-  if (!is_raw) return;
+  desc[511] = artist[63] = make[63] = model[63] = model2[63] = 0;
+  if (!is_raw) goto notraw;
 
-  if ((raw_height | raw_width) < 0)
-       raw_height = raw_width  = 0;
-  if (!maximum) maximum = (1 << tiff_bps) - 1;
   if (!height) height = raw_height;
   if (!width)  width  = raw_width;
   if (fuji_width) {
@@ -5779,34 +6779,38 @@
     height = width - 1;
     pixel_aspect = 1;
   }
-  if (!strcmp(model,"K10D")) {		/* Camera DNGs are not cropped! */
-    height = 2616;
-    width  = 3896;
-  }
+  if (height == 2624 && width == 3936)	/* Pentax K10D and Samsung GX10 */
+    { height  = 2616;   width  = 3896; }
+  if (height == 3136 && width == 4864)	/* Pentax K20D */
+    { height  = 3124;   width  = 4688; }
+  if (height == 3136 && width == 4736)	/* Pentax K-7 */
+    { height  = 3122;   width  = 4684;
+      top_margin = 2;  filters = 0x16161616; }
+  if (height == 3014 && width == 4096)	/* Ricoh GX200 */
+			width  = 4014;
   if (dng_version) {
     if (filters == UINT_MAX) filters = 0;
-    if (!filters)
-      colors = tiff_samples;
+    if (filters) is_raw = tiff_samples;
+    else	 colors = tiff_samples;
     if (tiff_compress == 1)
       load_raw = &CLASS adobe_dng_load_raw_nc;
     if (tiff_compress == 7)
       load_raw = &CLASS adobe_dng_load_raw_lj;
-    FORC4 cam_mul[c] = pre_mul[c];
     goto dng_skip;
   }
-
-/*  We'll try to decode anything from Canon or Nikon. */
-
-  if ((is_canon = !strcmp(make,"Canon"))) {
+  if ((is_canon = !strcmp(make,"Canon")))
     load_raw = memcmp (head+6,"HEAPCCDR",8) ?
 	&CLASS lossless_jpeg_load_raw : &CLASS canon_compressed_load_raw;
-    maximum = 0xfff;
+  if (!strcmp(make,"NIKON")) {
+    if (!load_raw)
+      load_raw = &CLASS packed_load_raw;
+    if (model[0] == 'E')
+      load_flags |= !data_offset << 2 | 2;
+  }
+  if (!strcmp(make,"CASIO")) {
+    load_raw = &CLASS packed_load_raw;
+    maximum = 0xf7f;
   }
-  if (!strcmp(make,"NIKON"))
-    load_raw = nikon_is_compressed() ?
-	&CLASS nikon_compressed_load_raw : &CLASS nikon_load_raw;
-  if (!strncmp (make,"OLYMPUS",7))
-    height += height & 1;
 
 /* Set parameters based on camera name (for non-DNG files). */
 
@@ -5816,6 +6820,13 @@
     filters = 0;
     load_raw = &CLASS foveon_load_raw;
     simple_coeff(0);
+  } else if (is_canon && tiff_bps == 15) {
+    switch (width) {
+      case 3344: width -= 66;
+      case 3872: width -= 6;
+    }
+    filters = 0;
+    load_raw = &CLASS canon_sraw_load_raw;
   } else if (!strcmp(model,"PowerShot 600")) {
     height = 613;
     width  = 854;
@@ -5832,28 +6843,53 @@
     pixel_aspect = 256/235.0;
     colors = 4;
     filters = 0x1e4e1e4e;
-    load_raw = &CLASS canon_a5_load_raw;
+    goto canon_a5;
   } else if (!strcmp(model,"PowerShot A50")) {
     height =  968;
     width  = 1290;
     raw_width = 1320;
     colors = 4;
     filters = 0x1b4e4b1e;
-    load_raw = &CLASS canon_a5_load_raw;
+    goto canon_a5;
   } else if (!strcmp(model,"PowerShot Pro70")) {
     height = 1024;
     width  = 1552;
     colors = 4;
     filters = 0x1e4b4e1b;
-    load_raw = &CLASS canon_a5_load_raw;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot SD300")) {
+    height = 1752;
+    width  = 2344;
+    raw_height = 1766;
+    raw_width  = 2400;
+    top_margin  = 12;
+    left_margin = 12;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A460")) {
+    height = 1960;
+    width  = 2616;
+    raw_height = 1968;
+    raw_width  = 2664;
+    top_margin  = 4;
+    left_margin = 4;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A530")) {
+    height = 1984;
+    width  = 2620;
+    raw_height = 1992;
+    raw_width  = 2672;
+    top_margin  = 6;
+    left_margin = 10;
+    goto canon_a5;
   } else if (!strcmp(model,"PowerShot A610")) {
+    if (canon_s2is()) strcpy (model+10, "S2 IS");
     height = 1960;
     width  = 2616;
     raw_height = 1968;
     raw_width  = 2672;
     top_margin  = 8;
     left_margin = 12;
-    load_raw = &CLASS canon_a5_load_raw;
+    goto canon_a5;
   } else if (!strcmp(model,"PowerShot A620")) {
     height = 2328;
     width  = 3112;
@@ -5861,7 +6897,47 @@
     raw_width  = 3152;
     top_margin  = 12;
     left_margin = 36;
-    load_raw = &CLASS canon_a5_load_raw;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A470")) {
+    height = 2328;
+    width  = 3096;
+    raw_height = 2346;
+    raw_width  = 3152;
+    top_margin  = 6;
+    left_margin = 12;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A720")) {
+    height = 2472;
+    width  = 3298;
+    raw_height = 2480;
+    raw_width  = 3336;
+    top_margin  = 5;
+    left_margin = 6;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A630")) {
+    height = 2472;
+    width  = 3288;
+    raw_height = 2484;
+    raw_width  = 3344;
+    top_margin  = 6;
+    left_margin = 12;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A640")) {
+    height = 2760;
+    width  = 3672;
+    raw_height = 2772;
+    raw_width  = 3736;
+    top_margin  = 6;
+    left_margin = 12;
+    goto canon_a5;
+  } else if (!strcmp(model,"PowerShot A650")) {
+    height = 3024;
+    width  = 4032;
+    raw_height = 3048;
+    raw_width  = 4104;
+    top_margin  = 12;
+    left_margin = 48;
+    goto canon_a5;
   } else if (!strcmp(model,"PowerShot S3 IS")) {
     height = 2128;
     width  = 2840;
@@ -5869,7 +6945,21 @@
     raw_width  = 2888;
     top_margin  = 8;
     left_margin = 44;
-    load_raw = &CLASS canon_a5_load_raw;
+canon_a5:
+    tiff_bps = 10;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 40;
+    if (raw_width > 1600) zero_is_bad = 1;
+  } else if (!strcmp(model,"PowerShot SX110 IS")) {
+    height = 2760;
+    width  = 3684;
+    raw_height = 2772;
+    raw_width  = 3720;
+    top_margin  = 12;
+    left_margin = 6;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 40;
+    zero_is_bad = 1;
   } else if (!strcmp(model,"PowerShot Pro90 IS")) {
     width  = 1896;
     colors = 4;
@@ -5905,7 +6995,6 @@
     left_margin = 64;
     if (unique_id == 0x80000170)
       adobe_coeff ("Canon","EOS 300D");
-    maximum = 0xfa0;
   } else if (is_canon && raw_width == 3160) {
     height = 2328;
     width  = 3112;
@@ -5929,59 +7018,133 @@
     top_margin  = 12;
     left_margin = 74;
     goto canon_cr2;
+  } else if (is_canon && raw_width == 3744) {
+    height = 2760;
+    width  = 3684;
+    top_margin  = 16;
+    left_margin = 8;
+  } else if (is_canon && raw_width == 3944) {
+    height = 2602;
+    width  = 3908;
+    top_margin  = 18;
+    left_margin = 30;
   } else if (is_canon && raw_width == 3948) {
     top_margin  = 18;
     left_margin = 42;
     height -= 2;
     if (unique_id == 0x80000236)
       adobe_coeff ("Canon","EOS 400D");
+    if (unique_id == 0x80000254)
+      adobe_coeff ("Canon","EOS 1000D");
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 3984) {
+    top_margin  = 20;
+    left_margin = 76;
+    height -= 2;
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 4104) {
+    height = 3024;
+    width  = 4032;
+    top_margin  = 12;
+    left_margin = 48;
+  } else if (is_canon && raw_width == 4152) {
+    top_margin  = 12;
+    left_margin = 192;
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 4312) {
+    top_margin  = 18;
+    left_margin = 22;
+    height -= 2;
+    if (unique_id == 0x80000176)
+      adobe_coeff ("Canon","EOS 450D");
     goto canon_cr2;
   } else if (is_canon && raw_width == 4476) {
     top_margin  = 34;
     left_margin = 90;
-    maximum = 0xe6c;
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 4480) {
+    height = 3326;
+    width  = 4432;
+    top_margin  = 10;
+    left_margin = 12;
+    filters = 0x49494949;
+  } else if (is_canon && raw_width == 1208) {
+    top_margin = unique_id == 0x80000261 ? 51:26;
+    left_margin = 62;
+    raw_width = width *= 4;
+    if (unique_id == 0x80000252)
+      adobe_coeff ("Canon","EOS 500D");
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 1340) {
+    top_margin = 51;
+    left_margin = 158;
+    raw_width = width *= 4;
+    goto canon_cr2;
+  } else if (is_canon && raw_width == 1448) {
+    top_margin  = 51;
+    left_margin = 158;
+    raw_width = width *= 4;
     goto canon_cr2;
   } else if (is_canon && raw_width == 5108) {
     top_margin  = 13;
     left_margin = 98;
-    maximum = 0xe80;
 canon_cr2:
     height -= top_margin;
     width  -= left_margin;
+  } else if (is_canon && raw_width == 5712) {
+    height = 3752;
+    width  = 5640;
+    top_margin  = 20;
+    left_margin = 62;
   } else if (!strcmp(model,"D1")) {
     cam_mul[0] *= 256/527.0;
     cam_mul[2] *= 256/317.0;
   } else if (!strcmp(model,"D1X")) {
     width -= 4;
     pixel_aspect = 0.5;
-  } else if (!strncmp(model,"D40",3)) {
-    width--;
-  } else if (!strncmp(model,"D50",3) || !strncmp(model,"D70",3)) {
-    width--;
-    maximum = 0xf53;
-  } else if (!strcmp(model,"D80")) {
+  } else if (!strcmp(model,"D40X") ||
+	     !strcmp(model,"D60")  ||
+	     !strcmp(model,"D80")  ||
+	     !strcmp(model,"D3000")) {
     height -= 3;
     width  -= 4;
+  } else if (!strcmp(model,"D3")   ||
+	     !strcmp(model,"D700")) {
+    width -= 4;
+    left_margin = 2;
+  } else if (!strcmp(model,"D5000")) {
+    width -= 42;
+  } else if (!strncmp(model,"D40",3) ||
+	     !strncmp(model,"D50",3) ||
+	     !strncmp(model,"D70",3)) {
+    width--;
+  } else if (!strcmp(model,"D90")) {
+    width -= 42;
   } else if (!strcmp(model,"D100")) {
-    if (tiff_compress == 34713 && load_raw == &CLASS nikon_load_raw)
+    if (tiff_compress == 34713 && !nikon_is_compressed()) {
+      load_raw = &CLASS packed_load_raw;
+      load_flags |= 1;
       raw_width = (width += 3) + 3;
-    maximum = 0xf44;
+    }
   } else if (!strcmp(model,"D200")) {
     left_margin = 1;
     width -= 4;
-    maximum = 0xfbc;
     filters = 0x94949494;
   } else if (!strncmp(model,"D2H",3)) {
     left_margin = 6;
     width -= 14;
-  } else if (!strcmp(model,"D2X")) {
-    width -= 8;
-    maximum = 0xf35;
+  } else if (!strncmp(model,"D2X",3)) {
+    if (width == 3264) width -= 32;
+    else width -= 8;
+  } else if (!strncmp(model,"D300",4)) {
+    width -= 32;
+  } else if (!strcmp(model,"COOLPIX P6000")) {
+    load_flags = 24;
+    filters = 0x94949494;
   } else if (fsize == 1581060) {
     height = 963;
     width = 1287;
     raw_width = 1632;
-    load_raw = &CLASS nikon_e900_load_raw;
     maximum = 0x3f4;
     colors = 4;
     filters = 0x1e1e1e1e;
@@ -5989,21 +7152,25 @@
     pre_mul[0] = 1.2085;
     pre_mul[1] = 1.0943;
     pre_mul[3] = 1.1103;
+    goto e900;
   } else if (fsize == 2465792) {
     height = 1203;
     width  = 1616;
     raw_width = 2048;
-    load_raw = &CLASS nikon_e900_load_raw;
-    maximum = 0x3dd;
     colors = 4;
     filters = 0x4b4b4b4b;
     adobe_coeff ("NIKON","E950");
+e900:
+    tiff_bps = 10;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 6;
   } else if (fsize == 4771840) {
     height = 1540;
     width  = 2064;
     colors = 4;
     filters = 0xe1e1e1e1;
-    load_raw = &CLASS nikon_load_raw;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 6;
     if (!timestamp && nikon_e995())
       strcpy (model, "E995");
     if (strcmp(model,"E995")) {
@@ -6017,9 +7184,7 @@
     if (!timestamp && !nikon_e2100()) goto cp_e2500;
     height = 1206;
     width  = 1616;
-    load_raw = &CLASS nikon_e2100_load_raw;
-    pre_mul[0] = 1.945;
-    pre_mul[2] = 1.040;
+    load_flags = 30;
   } else if (!strcmp(model,"E2500")) {
 cp_e2500:
     strcpy (model, "E2500");
@@ -6030,17 +7195,23 @@
   } else if (fsize == 4775936) {
     height = 1542;
     width  = 2064;
-    load_raw = &CLASS nikon_e2100_load_raw;
-    pre_mul[0] = 1.818;
-    pre_mul[2] = 1.618;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 30;
     if (!timestamp) nikon_3700();
     if (model[0] == 'E' && atoi(model+1) < 3700)
       filters = 0x49494949;
     if (!strcmp(model,"Optio 33WR")) {
       flip = 1;
       filters = 0x16161616;
-      pre_mul[0] = 1.331;
-      pre_mul[2] = 1.820;
+    }
+    if (make[0] == 'O') {
+      i = find_green (12, 32, 0, fsize/2);
+      c = find_green (12, 32, 0, 3096);
+      if (abs(i) < abs(c)) {
+	SWAP(i,c);
+	load_flags = 24;
+      }
+      if (i < 0) filters = 0x61616161;
     }
   } else if (fsize == 5869568) {
     height = 1710;
@@ -6050,8 +7221,8 @@
       strcpy (make, "Minolta");
       strcpy (model,"DiMAGE Z2");
     }
-    if (make[0] == 'M')
-      load_raw = &CLASS nikon_e2100_load_raw;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 6 + 24*(make[0] == 'M');
   } else if (!strcmp(model,"E4500")) {
     height = 1708;
     width  = 2288;
@@ -6062,14 +7233,16 @@
     width  = 2576;
     colors = 4;
     filters = 0xb4b4b4b4;
-  } else if (!strncmp(model,"R-D1",4)) {
-    tiff_compress = 34713;
-    load_raw = &CLASS nikon_load_raw;
+  } else if (fsize == 8998912) {
+    height = 2118;
+    width  = 2832;
+    maximum = 0xf83;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 30;
   } else if (!strcmp(model,"FinePix S5100") ||
 	     !strcmp(model,"FinePix S5500")) {
     load_raw = &CLASS unpacked_load_raw;
-    maximum = 0x3e00;
-  } else if (!strncmp(model,"FinePix",7)) {
+  } else if (!strcmp(make,"FUJIFILM")) {
     if (!strcmp(model+7,"S2Pro")) {
       strcpy (model+7," S2Pro");
       height = 2144;
@@ -6077,13 +7250,13 @@
       flip = 6;
     } else
       maximum = 0x3e00;
-    if (fuji_secondary && shot_select)
+    if (is_raw == 2 && shot_select)
       maximum = 0x2f00;
     top_margin = (raw_height - height)/2;
     left_margin = (raw_width - width )/2;
-    if (fuji_secondary)
-      data_offset += (shot_select > 0) * ( strcmp(model+7," S3Pro")
-		? (raw_width *= 2) : raw_height*raw_width*2 );
+    if (is_raw == 2)
+      data_offset += (shot_select > 0) * ( fuji_layout ?
+		(raw_width *= 2) : raw_height*raw_width*2 );
     fuji_width = width >> !fuji_layout;
     width = (height >> fuji_layout) + fuji_width;
     raw_height = height;
@@ -6105,19 +7278,18 @@
     goto konica_510z;
   } else if (!strcasecmp(make,"MINOLTA")) {
     load_raw = &CLASS unpacked_load_raw;
-    maximum = 0xf7d;
+    maximum = 0xfff;
     if (!strncmp(model,"DiMAGE A",8)) {
       if (!strcmp(model,"DiMAGE A200"))
 	filters = 0x49494949;
-      load_raw = &CLASS packed_12_load_raw;
-      maximum = model[8] == '1' ? 0xf8b : 0xfff;
+      tiff_bps = 12;
+      load_raw = &CLASS packed_load_raw;
     } else if (!strncmp(model,"ALPHA",5) ||
 	       !strncmp(model,"DYNAX",5) ||
 	       !strncmp(model,"MAXXUM",6)) {
       sprintf (model+20, "DYNAX %-10s", model+6+(model[0]=='M'));
       adobe_coeff (make, model+20);
-      load_raw = &CLASS packed_12_load_raw;
-      maximum = 0xffb;
+      load_raw = &CLASS packed_load_raw;
     } else if (!strncmp(model,"DiMAGE G",8)) {
       if (model[8] == '4') {
 	height = 1716;
@@ -6140,6 +7312,8 @@
     }
   } else if (!strcmp(model,"*ist DS")) {
     height -= 2;
+  } else if (!strcmp(model,"K20D")) {
+    filters = 0x16161616;
   } else if (!strcmp(model,"Optio S")) {
     if (fsize == 3178560) {
       height = 1540;
@@ -6147,25 +7321,38 @@
       load_raw = &CLASS eight_bit_load_raw;
       cam_mul[0] *= 4;
       cam_mul[2] *= 4;
-      pre_mul[0] = 1.391;
-      pre_mul[2] = 1.188;
     } else {
       height = 1544;
       width  = 2068;
       raw_width = 3136;
-      load_raw = &CLASS packed_12_load_raw;
+      load_raw = &CLASS packed_load_raw;
       maximum = 0xf7c;
-      pre_mul[0] = 1.137;
-      pre_mul[2] = 1.453;
     }
-  } else if (!strncmp(model,"Optio S4",8)) {
+  } else if (fsize == 6114240) {
     height = 1737;
     width  = 2324;
     raw_width = 3520;
-    load_raw = &CLASS packed_12_load_raw;
+    load_raw = &CLASS packed_load_raw;
     maximum = 0xf7a;
-    pre_mul[0] = 1.980;
-    pre_mul[2] = 1.570;
+  } else if (!strcmp(model,"Optio 750Z")) {
+    height = 2302;
+    width  = 3072;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 30;
+  } else if (!strcmp(model,"DC-833m")) {
+    height = 2448;
+    width  = 3264;
+    order = 0x4949;
+    filters = 0x61616161;
+    load_raw = &CLASS unpacked_load_raw;
+    maximum = 0xfc00;
+  } else if (!strncmp(model,"S85",3)) {
+    height = 2448;
+    width  = 3264;
+    raw_width = fsize/height/2;
+    order = 0x4d4d;
+    load_raw = &CLASS unpacked_load_raw;
+    maximum = 0xffff;
   } else if (!strcmp(model,"STV680 VGA")) {
     height = 484;
     width  = 644;
@@ -6173,22 +7360,17 @@
     flip = 2;
     filters = 0x16161616;
     black = 16;
-    pre_mul[0] = 1.097;
-    pre_mul[2] = 1.128;
-  } else if (!strcmp(model,"KAI-0340")) {
-    height = 477;
-    width  = 640;
-    order = 0x4949;
-    data_offset = 3840;
-    load_raw = &CLASS unpacked_load_raw;
-    pre_mul[0] = 1.561;
-    pre_mul[2] = 2.454;
+  } else if (!strcmp(model,"N95")) {
+    height = raw_height - (top_margin = 2);
   } else if (!strcmp(model,"531C")) {
     height = 1200;
     width  = 1600;
     load_raw = &CLASS unpacked_load_raw;
     filters = 0x49494949;
-    pre_mul[1] = 1.218;
+  } else if (!strcmp(model,"F-080C")) {
+    height = 768;
+    width  = 1024;
+    load_raw = &CLASS eight_bit_load_raw;
   } else if (!strcmp(model,"F-145C")) {
     height = 1040;
     width  = 1392;
@@ -6237,8 +7419,6 @@
     filters = 0x61616161;
     load_raw = &CLASS unpacked_load_raw;
     maximum = 0x3ff;
-    pre_mul[0] = 1.717;
-    pre_mul[2] = 1.138;
     fseek (ifp, 0x300000, SEEK_SET);
     if ((order = guess_byte_order(0x10000)) == 0x4d4d) {
       height -= (top_margin = 16);
@@ -6247,14 +7427,21 @@
       strcpy (make, "ISG");
       model[0] = 0;
     }
-  } else if (!strcmp(make,"Imacon")) {
-    sprintf (model, "Ixpress %d-Mp", height*width/1000000);
-    load_raw = &CLASS imacon_full_load_raw;
-    if (filters) {
-      if (left_margin & 1) filters = 0x61616161;
-      load_raw = &CLASS unpacked_load_raw;
+  } else if (!strcmp(make,"Hasselblad")) {
+    if (load_raw == &CLASS lossless_jpeg_load_raw)
+      load_raw = &CLASS hasselblad_load_raw;
+    if (raw_width == 7262) {
+      height = 5444;
+      width  = 7248;
+      top_margin  = 4;
+      left_margin = 7;
+      filters = 0x61616161;
+    } else if (raw_width == 4090) {
+      strcpy (model, "V96C");
+      height -= (top_margin = 6);
+      width -= (left_margin = 3) + 7;
+      filters = 0x61616161;
     }
-    maximum = 0xffff;
   } else if (!strcmp(make,"Sinar")) {
     if (!memcmp(head,"8BPS",4)) {
       fseek (ifp, 14, SEEK_SET);
@@ -6267,6 +7454,9 @@
     maximum = 0x3fff;
   } else if (!strcmp(make,"Leaf")) {
     maximum = 0x3fff;
+    fseek (ifp, data_offset, SEEK_SET);
+    if (ljpeg_start (&jh, 1) && jh.bits == 15)
+      maximum = 0x1fff;
     if (tiff_samples > 1) filters = 0;
     if (tiff_samples > 1 || tile_length < raw_height)
       load_raw = &CLASS leaf_hdr_load_raw;
@@ -6290,6 +7480,7 @@
 	filters = 0x16161616;
       }
       if (!cam_mul[0] || model[0] == 'V') filters = 0;
+      else is_raw = tiff_samples;
     } else if (width == 2116) {
       strcpy (model, "Valeo 6");
       height -= 2 * (top_margin = 30);
@@ -6303,78 +7494,149 @@
     }
   } else if (!strcmp(make,"LEICA") || !strcmp(make,"Panasonic")) {
     maximum = 0xfff0;
-    if (width == 2568)
-      adobe_coeff ("Panasonic","DMC-LC1");
-    else if (width == 3304) {
-      maximum = 0xf94c;
-      width -= 16;
-      adobe_coeff ("Panasonic","DMC-FZ30");
-    } else if (width == 3690) {
-      maximum = 0xf7f0;
-      height -= 3;
-      width = 3672;
-      left_margin = 3;
-      filters = 0x49494949;
-      adobe_coeff ("Panasonic","DMC-FZ50");
-    } else if (width == 3770) {
-      height = 2760;
-      width  = 3672;
-      top_margin  = 15;
-      left_margin = 17;
-      adobe_coeff ("Panasonic","DMC-FZ50");
-    } else if (width == 3880) {
-      maximum = 0xf7f0;
-      width -= 22;
-      left_margin = 6;
-      adobe_coeff ("Panasonic","DMC-LX1");
-    } else if (width == 4290) {
-      height--;
-      width = 4248;
-      left_margin = 3;
-      filters = 0x49494949;
-      adobe_coeff ("Panasonic","DMC-LX2");
-    } else if (width == 4330) {
-      height = 2400;
-      width  = 4248;
-      top_margin  = 15;
-      left_margin = 17;
-      adobe_coeff ("Panasonic","DMC-LX2");
+    if ((fsize-data_offset) / (width*8/7) == height)
+      load_raw = &CLASS panasonic_load_raw;
+    if (!load_raw) load_raw = &CLASS unpacked_load_raw;
+    switch (width) {
+      case 2568:
+	adobe_coeff ("Panasonic","DMC-LC1");  break;
+      case 3130:
+	left_margin = -14;
+      case 3170:
+	left_margin += 18;
+	width = 3096;
+	if (height > 2326) {
+	  height = 2326;
+	  top_margin = 13;
+	  filters = 0x49494949;
+	}
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-FZ8");  break;
+      case 3213:
+	width -= 27;
+      case 3177:
+	width -= 10;
+	filters = 0x49494949;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-L1");  break;
+      case 3304:
+	width -= 17;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-FZ30");  break;
+      case 3330:
+	width += 43;
+	left_margin = -6;
+	maximum = 0xf7f0;
+      case 3370:
+	width -= 82;
+	left_margin += 15;
+	if (height > 2480)
+	    height = 2480 - (top_margin = 10);
+	filters = 0x49494949;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-FZ18");  break;
+      case 3690:
+	height -= 2;
+	left_margin = -14;
+	maximum = 0xf7f0;
+      case 3770:
+	width = 3672;
+	if (--height == 2798 && (height = 2760))
+	  top_margin = 15;
+	else filters = 0x49494949;
+	left_margin += 17;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-FZ50");  break;
+      case 3710:
+	width = 3682;
+	filters = 0x49494949;
+	adobe_coeff ("Panasonic","DMC-L10");  break;
+      case 3724:
+	width -= 14;
+	if (height == 2450) height -= 2;
+      case 3836:
+	width -= 42;
+lx3:	filters = 0x16161616;
+	if (make[0] != 'P')
+	  adobe_coeff ("Panasonic","DMC-LX3");
+	break;
+      case 3880:
+	width -= 22;
+	left_margin = 6;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-LX1");  break;
+      case 4060:
+	width = 3982;
+	if (height == 2250) goto lx3;
+	width = 4018;
+	filters = 0x16161616;
+	if (!strncmp(model,"DMC-FZ3",7)) {
+	  height -= 2;
+	  adobe_coeff ("Panasonic","DMC-FZ35");  break;
+	}
+	filters = 0x49494949;
+	if (!strcmp(model,"DMC-GH1")) break;
+	zero_is_bad = 1;
+	adobe_coeff ("Panasonic","DMC-G1");  break;
+      case 4172:
+      case 4396:
+	width -= 28;
+	filters = 0x49494949;
+	adobe_coeff ("Panasonic","DMC-GH1");  break;
+      case 4290:
+	height += 38;
+	left_margin = -14;
+	filters = 0x49494949;
+      case 4330:
+	width = 4248;
+	if ((height -= 39) == 2400)
+	  top_margin = 15;
+	left_margin += 17;
+	adobe_coeff ("Panasonic","DMC-LX2");  break;
+      case 4508:
+	height -= 6;
+	width = 4429;
+	filters = 0x16161616;
+	adobe_coeff ("Panasonic","DMC-FX150");  break;
     }
-    load_raw = &CLASS unpacked_load_raw;
-  } else if (!strcmp(model,"E-1") ||
-	     !strcmp(model,"E-400")) {
-    filters = 0x61616161;
-    maximum = 0xfff0;
-  } else if (!strcmp(model,"E-10") ||
-	    !strncmp(model,"E-20",4)) {
-    maximum = 0xffc0;
-    black <<= 2;
-  } else if (!strcmp(model,"E-300") ||
-	     !strcmp(model,"E-500")) {
-    width -= 20;
-    maximum = 0xfc30;
-    if (load_raw == &CLASS unpacked_load_raw) black = 0;
-  } else if (!strcmp(model,"E-330")) {
-    width -= 30;
   } else if (!strcmp(model,"C770UZ")) {
     height = 1718;
     width  = 2304;
     filters = 0x16161616;
-    load_raw = &CLASS nikon_e2100_load_raw;
+    load_raw = &CLASS packed_load_raw;
+    load_flags = 30;
   } else if (!strcmp(make,"OLYMPUS")) {
-    load_raw = &CLASS olympus_cseries_load_raw;
-    if (!strcmp(model,"C5050Z") ||
-	!strcmp(model,"C8080WZ"))
-      filters = 0x16161616;
-    if (!strcmp(model,"SP500UZ"))
-      filters = 0x49494949;
+    height += height & 1;
+    filters = exif_cfa;
+    if (width == 4100) width -= 4;
+    if (load_raw == &CLASS olympus_load_raw) {
+      tiff_bps = 12;
+      black >>= 4;
+    } else if (!strcmp(model,"E-10") ||
+	      !strncmp(model,"E-20",4)) {
+      black <<= 2;
+    } else if (!strcmp(model,"E-300") ||
+	       !strcmp(model,"E-500")) {
+      width -= 20;
+      if (load_raw == &CLASS unpacked_load_raw) {
+	maximum = 0xfc30;
+	black = 0;
+      }
+    } else if (!strcmp(model,"E-330")) {
+      width -= 30;
+      if (load_raw == &CLASS unpacked_load_raw)
+	maximum = 0xf790;
+    } else if (!strcmp(model,"SP550UZ")) {
+      thumb_length = fsize - (thumb_offset = 0xa39800);
+      thumb_height = 480;
+      thumb_width  = 640;
+    }
   } else if (!strcmp(model,"N Digital")) {
     height = 2047;
     width  = 3072;
     filters = 0x61616161;
     data_offset = 0x1a00;
-    load_raw = &CLASS packed_12_load_raw;
-    maximum = 0xf1e;
+    load_raw = &CLASS packed_load_raw;
   } else if (!strcmp(model,"DSC-F828")) {
     width = 3288;
     left_margin = 5;
@@ -6394,10 +7656,58 @@
     order = 0x4d4d;
   } else if (!strcmp(model,"DSLR-A100")) {
     height--;
-    load_raw = &CLASS sony_arw_load_raw;
-    maximum = 0xfeb;
-  } else if (!strncmp(model,"P850",4)) {
-    maximum = 0xf7c;
+    width = ++raw_width;
+    filters = 0x61616161;
+  } else if (!strcmp(model,"DSLR-A350")) {
+    height -= 4;
+  } else if (!strcmp(model,"PIXL")) {
+    height -= top_margin = 4;
+    width -= left_margin = 32;
+    gamma_curve (0, 7, 1, 255);
+  } else if (!strcmp(model,"C603v")) {
+    height = 480;
+    width  = 640;
+    if (fsize < 614400 || find_green (16, 16, 3840, 5120) < 25) goto c603v;
+    strcpy (model,"KAI-0340");
+    height -= 3;
+    data_offset = 3840;
+    order = 0x4949;
+    load_raw = &CLASS unpacked_load_raw;
+  } else if (!strcmp(model,"C603y")) {
+    height = 2134;
+    width  = 2848;
+c603v:
+    filters = 0;
+    load_raw = &CLASS kodak_yrgb_load_raw;
+    gamma_curve (0, 3.875, 1, 255);
+  } else if (!strcmp(model,"C603")) {
+    raw_height = height = 2152;
+    raw_width  = width  = 2864;
+    goto c603;
+  } else if (!strcmp(model,"C330")) {
+    height = 1744;
+    width  = 2336;
+    raw_height = 1779;
+    raw_width  = 2338;
+    top_margin = 33;
+    left_margin = 1;
+c603:
+    order = 0x4949;
+    if ((data_offset = fsize - raw_height*raw_width)) {
+      fseek (ifp, 168, SEEK_SET);
+      read_shorts (curve, 256);
+    } else gamma_curve (0, 3.875, 1, 255);
+    load_raw = &CLASS eight_bit_load_raw;
+  } else if (!strcmp(model,"EASYSHARE Z1015 IS")) {
+    height = 2742;
+    width  = 3664;
+    goto ezshare;
+  } else if (!strcmp(model,"EasyShare Z980")) {
+    height = 3006;
+    width  = 4016;
+ezshare:
+    data_offset = 0x15000;
+    load_raw = &CLASS packed_load_raw;
   } else if (!strcasecmp(make,"KODAK")) {
     if (filters == UINT_MAX) filters = 0x61616161;
     if (!strncmp(model,"NC2000",6)) {
@@ -6412,7 +7722,8 @@
     } else if (!strcmp(model,"DCS420")) {
       width -= 4;
       left_margin = 2;
-    } else if (!strcmp(model,"DCS460")) {
+    } else if (!strncmp(model,"DCS460 ",7)) {
+      model[6] = 0;
       width -= 4;
       left_margin = 2;
     } else if (!strcmp(model,"DCS460A")) {
@@ -6428,8 +7739,8 @@
       colors = 1;
       filters = 0;
     }
-    if (load_raw == &CLASS eight_bit_load_raw)
-	load_raw = &CLASS kodak_easy_load_raw;
+    if (!strcmp(model+4,"20X"))
+      strcpy (cdesc, "MYCY");
     if (strstr(model,"DC25")) {
       strcpy (model, "DC25");
       data_offset = 15424;
@@ -6438,8 +7749,10 @@
       height = 242;
       if (fsize < 100000) {
 	raw_width = 256; width = 249;
+	pixel_aspect = (4.0*height) / (3.0*width);
       } else {
 	raw_width = 512; width = 501;
+	pixel_aspect = (493.0*height) / (373.0*width);
       }
       data_offset += raw_width + 1;
       colors = 4;
@@ -6448,7 +7761,7 @@
       pre_mul[1] = 1.179;
       pre_mul[2] = 1.209;
       pre_mul[3] = 1.036;
-      load_raw = &CLASS kodak_easy_load_raw;
+      load_raw = &CLASS eight_bit_load_raw;
     } else if (!strcmp(model,"40")) {
       strcpy (model, "DC40");
       height = 512;
@@ -6487,7 +7800,26 @@
     load_raw = &CLASS kodak_radc_load_raw;
     filters = 0x61616161;
     simple_coeff(2);
-  } else if (!strcmp(make,"Rollei")) {
+  } else if (!strcmp(model,"QuickTake 100")) {
+    fseek (ifp, 544, SEEK_SET);
+    height = get2();
+    width  = get2();
+    data_offset = (get4(),get2()) == 30 ? 738:736;
+    if (height > width) {
+      SWAP(height,width);
+      fseek (ifp, data_offset-6, SEEK_SET);
+      flip = ~get2() & 3 ? 5:6;
+    }
+    load_raw = &CLASS quicktake_100_load_raw;
+    filters = 0x61616161;
+  } else if (!strcmp(model,"QuickTake 150")) {
+    data_offset = 738 - head[5];
+    if (head[5]) strcpy (model+10, "200");
+    load_raw = &CLASS kodak_radc_load_raw;
+    height = 480;
+    width  = 640;
+    filters = 0x61616161;
+  } else if (!strcmp(make,"Rollei") && !load_raw) {
     switch (raw_width) {
       case 1316:
 	height = 1030;
@@ -6503,15 +7835,11 @@
     }
     filters = 0x16161616;
     load_raw = &CLASS rollei_load_raw;
-    pre_mul[0] = 1.8;
-    pre_mul[2] = 1.3;
   } else if (!strcmp(model,"PC-CAM 600")) {
     height = 768;
     data_offset = width = 1024;
     filters = 0x49494949;
     load_raw = &CLASS eight_bit_load_raw;
-    pre_mul[0] = 1.14;
-    pre_mul[2] = 2.73;
   } else if (!strcmp(model,"QV-2000UX")) {
     height = 1208;
     width  = 1632;
@@ -6530,69 +7858,70 @@
   } else if (!strcmp(model,"QV-5700")) {
     height = 1924;
     width  = 2576;
-    load_raw = &CLASS casio_qv5700_load_raw;
+    raw_width = 3232;
+    tiff_bps = 10;
+  } else if (!strcmp(model,"QV-R41")) {
+    height = 1720;
+    width  = 2312;
+    raw_width = 3520;
+    left_margin = 2;
   } else if (!strcmp(model,"QV-R51")) {
     height = 1926;
-    width  = 2576;
+    width  = 2580;
     raw_width = 3904;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 1.340;
-    pre_mul[2] = 1.672;
+  } else if (!strcmp(model,"EX-S20")) {
+    height = 1208;
+    width  = 1620;
+    raw_width = 2432;
+    flip = 3;
   } else if (!strcmp(model,"EX-S100")) {
     height = 1544;
     width  = 2058;
     raw_width = 3136;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 1.631;
-    pre_mul[2] = 1.106;
   } else if (!strcmp(model,"EX-Z50")) {
     height = 1931;
     width  = 2570;
     raw_width = 3904;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 2.529;
-    pre_mul[2] = 1.185;
   } else if (!strcmp(model,"EX-Z55")) {
     height = 1960;
     width  = 2570;
     raw_width = 3904;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 1.520;
-    pre_mul[2] = 1.316;
+  } else if (!strcmp(model,"EX-Z60")) {
+    height = 2145;
+    width  = 2833;
+    raw_width = 3584;
+    filters = 0x16161616;
+    tiff_bps = 10;
+  } else if (!strcmp(model,"EX-Z75")) {
+    height = 2321;
+    width  = 3089;
+    raw_width = 4672;
+    maximum = 0xfff;
+  } else if (!strcmp(model,"EX-Z850")) {
+    height = 2468;
+    width  = 3279;
+    raw_width = 4928;
+    maximum = 0xfff;
   } else if (!strcmp(model,"EX-P505")) {
     height = 1928;
     width  = 2568;
     raw_width = 3852;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 2.07;
-    pre_mul[2] = 1.88;
+    maximum = 0xfff;
   } else if (fsize == 9313536) {	/* EX-P600 or QV-R61 */
     height = 2142;
     width  = 2844;
     raw_width = 4288;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 1.797;
-    pre_mul[2] = 1.219;
   } else if (!strcmp(model,"EX-P700")) {
     height = 2318;
     width  = 3082;
     raw_width = 4672;
-    load_raw = &CLASS packed_12_load_raw;
-    pre_mul[0] = 1.758;
-    pre_mul[2] = 1.504;
-  } else if (!strcmp(make,"Nucore")) {
-    filters = 0x61616161;
-    load_raw = &CLASS unpacked_load_raw;
-    if (width == 2598) {
-      filters = 0x16161616;
-      load_raw = &CLASS nucore_load_raw;
-      flip = 2;
-    }
   }
   if (!model[0])
     sprintf (model, "%dx%d", width, height);
   if (filters == UINT_MAX) filters = 0x94949494;
   if (raw_color) adobe_coeff (make, model);
+  if (load_raw == &CLASS kodak_radc_load_raw)
+    if (raw_color) adobe_coeff ("Apple","Quicktake");
   if (thumb_offset && !thumb_height) {
     fseek (ifp, thumb_offset, SEEK_SET);
     if (ljpeg_start (&jh, 1)) {
@@ -6601,15 +7930,15 @@
     }
   }
 dng_skip:
-  if (!load_raw || !height) is_raw = 0;
+  if (!tiff_bps) tiff_bps = 12;
+  if (!maximum) maximum = (1 << tiff_bps) - 1;
+  if (!load_raw || height < 22) is_raw = 0;
 #ifdef NO_JPEG
-  if (load_raw == kodak_jpeg_load_raw) {
+  if (load_raw == &CLASS kodak_jpeg_load_raw) {
     fprintf (stderr,_("%s: You must link dcraw with libjpeg!!\n"), ifname);
     is_raw = 0;
   }
 #endif
-  if (flip == -1) flip = tiff_flip;
-  if (flip == -1) flip = 0;
   if (!cdesc[0])
     strcpy (cdesc, colors == 3 ? "RGB":"GMCY");
   if (!raw_height) raw_height = height;
@@ -6621,13 +7950,16 @@
       if ((filters >> i & 15) == 6)
 	filters |= 8 << i;
     }
+notraw:
+  if (flip == -1) flip = tiff_flip;
+  if (flip == -1) flip = 0;
 }
 
 #ifndef NO_LCMS
-void CLASS apply_profile (char *input, char *output)
+void CLASS apply_profile (const char *input, const char *output)
 {
   char *prof;
-  cmsHPROFILE hInProfile=NULL, hOutProfile=NULL;
+  cmsHPROFILE hInProfile=0, hOutProfile=0;
   cmsHTRANSFORM hTransform;
   FILE *fp;
   unsigned size;
@@ -6656,7 +7988,7 @@
     fclose (fp);
     if (!(hOutProfile = cmsOpenProfileFromMem (oprof, size))) {
       free (oprof);
-      oprof = NULL;
+      oprof = 0;
     }
   } else
     fprintf (stderr,_("Cannot open file %s!\n"), output);
@@ -6676,7 +8008,7 @@
 
 void CLASS convert_to_rgb()
 {
-  int mix_green, row, col, c, i, j, k;
+  int row, col, c, i, j, k;
   ushort *img;
   float out[3], out_cam[3][4];
   double num, inverse[3][3];
@@ -6719,6 +8051,7 @@
   static const unsigned pwhite[] = { 0xf351, 0x10000, 0x116cc };
   unsigned pcurve[] = { 0x63757276, 0, 1, 0x1000000 };
 
+  gamma_curve (gamm[0], gamm[1], 0, 0);
   memcpy (out_cam, rgb_cam, sizeof out_cam);
   raw_color |= colors == 1 || document_mode ||
 		output_color < 1 || output_color > 5;
@@ -6736,12 +8069,7 @@
     memcpy (oprof+32, pbody, sizeof pbody);
     oprof[pbody[5]/4+2] = strlen(name[output_color-1]) + 1;
     memcpy ((char *)oprof+pbody[8]+8, pwhite, sizeof pwhite);
-    if (output_bps == 8)
-#ifdef SRGB_GAMMA
-      pcurve[3] = 0x2330000;
-#else
-      pcurve[3] = 0x1f00000;
-#endif
+    pcurve[3] = (short)(256/gamm[5]+0.5) << 16;
     for (i=4; i < 7; i++)
       memcpy ((char *)oprof+pbody[i*3+2], pcurve, sizeof pcurve);
     pseudoinverse ((double (*)[3]) out_rgb[output_color-1], inverse, 3);
@@ -6764,7 +8092,6 @@
     fprintf (stderr, raw_color ? _("Building histograms...\n") :
 	_("Converting to %s colorspace...\n"), name[output_color-1]);
 
-  mix_green = rgb_cam[1][1] == rgb_cam[1][3];
   memset (histogram, 0, sizeof histogram);
   for (img=image[0], row=0; row < height; row++)
     for (col=0; col < width; col++, img+=4) {
@@ -6779,21 +8106,19 @@
       }
       else if (document_mode)
 	img[0] = img[FC(row,col)];
-      else if (mix_green)
-	img[1] = (img[1] + img[3]) >> 1;
       FORCC histogram[c][img[c] >> 3]++;
     }
-  if (colors == 4 && (output_color || mix_green)) colors = 3;
+  if (colors == 4 && output_color) colors = 3;
   if (document_mode && filters) colors = 1;
 }
 
 void CLASS fuji_rotate()
 {
-  int i, wide, high, row, col;
+  int i, row, col;
   double step;
   float r, c, fr, fc;
   unsigned ur, uc;
-  ushort (*img)[4], (*pix)[4];
+  ushort wide, high, (*img)[4], (*pix)[4];
 
   if (!fuji_width) return;
   if (verbose)
@@ -6827,9 +8152,9 @@
 
 void CLASS stretch()
 {
-  int newdim, row, col, c;
+  ushort newdim, (*img)[4], *pix0, *pix1;
+  int row, col, c;
   double rc, frac;
-  ushort (*img)[4], *pix0, *pix1;
 
   if (pixel_aspect == 1) return;
   if (verbose) fprintf (stderr,_("Stretching the image...\n"));
@@ -6870,125 +8195,171 @@
   return row * iwidth + col;
 }
 
-void CLASS gamma_lut (uchar lut[0x10000])
-{
-  int perc, c, val, total, i;
-  float white=0, r;
-
-  perc = width * height * 0.01;		/* 99th percentile white point */
-  if (fuji_width) perc /= 2;
-  if (highlight) perc = 0;
-  FORCC {
-    for (val=0x2000, total=0; --val > 32; )
-      if ((total += histogram[c][val]) > perc) break;
-    if (white < val) white = val;
-  }
-  white *= 8 / bright;
-  for (i=0; i < 0x10000; i++) {
-    r = i / white;
-    val = 256 * ( !use_gamma ? r :
-#ifdef SRGB_GAMMA
-	r <= 0.00304 ? r*12.92 : pow(r,2.5/6)*1.055-0.055 );
-#else
-	r <= 0.018 ? r*4.5 : pow(r,0.45)*1.099-0.099 );
-#endif
-    if (val > 255) val = 255;
-    lut[i] = val;
-  }
-}
-
 struct tiff_tag {
   ushort tag, type;
   int count;
-  union { short s0, s1; int i0; } val;
+  union { char c[4]; short s[2]; int i; } val;
 };
 
 struct tiff_hdr {
   ushort order, magic;
   int ifd;
   ushort pad, ntag;
-  struct tiff_tag tag[15];
+  struct tiff_tag tag[23];
   int nextifd;
   ushort pad2, nexif;
   struct tiff_tag exif[4];
+  ushort pad3, ngps;
+  struct tiff_tag gpst[10];
   short bps[4];
-  int rat[6];
-  char make[64], model[64], soft[32], date[20];
+  int rat[10];
+  unsigned gps[26];
+  char desc[512], make[64], model[64], soft[32], date[20], artist[64];
 };
 
 void CLASS tiff_set (ushort *ntag,
 	ushort tag, ushort type, int count, int val)
 {
   struct tiff_tag *tt;
+  int c;
 
   tt = (struct tiff_tag *)(ntag+1) + (*ntag)++;
   tt->tag = tag;
   tt->type = type;
   tt->count = count;
-  if (type == 3 && count == 1)
-    tt->val.s0 = val;
-  else tt->val.i0 = val;
+  if (type < 3 && count <= 4)
+    FORC(4) tt->val.c[c] = val >> (c << 3);
+  else if (type == 3 && count <= 2)
+    FORC(2) tt->val.s[c] = val >> (c << 4);
+  else tt->val.i = val;
 }
 
-#define TOFF(ptr) ((char *)(&(ptr)) - (char *)(&th))
+#define TOFF(ptr) ((char *)(&(ptr)) - (char *)th)
 
-void CLASS write_ppm_tiff (FILE *ofp)
+void CLASS tiff_head (struct tiff_hdr *th, int full)
 {
-  struct tiff_hdr th;
+  int c, psize=0;
   struct tm *t;
-  uchar *ppm, lut[0x10000];
+
+  memset (th, 0, sizeof *th);
+  th->order = htonl(0x4d4d4949) >> 16;
+  th->magic = 42;
+  th->ifd = 10;
+  if (full) {
+    tiff_set (&th->ntag, 254, 4, 1, 0);
+    tiff_set (&th->ntag, 256, 4, 1, width);
+    tiff_set (&th->ntag, 257, 4, 1, height);
+    tiff_set (&th->ntag, 258, 3, colors, output_bps);
+    if (colors > 2)
+      th->tag[th->ntag-1].val.i = TOFF(th->bps);
+    FORC4 th->bps[c] = output_bps;
+    tiff_set (&th->ntag, 259, 3, 1, 1);
+    tiff_set (&th->ntag, 262, 3, 1, 1 + (colors > 1));
+  }
+  tiff_set (&th->ntag, 270, 2, 512, TOFF(th->desc));
+  tiff_set (&th->ntag, 271, 2, 64, TOFF(th->make));
+  tiff_set (&th->ntag, 272, 2, 64, TOFF(th->model));
+  if (full) {
+    if (oprof) psize = ntohl(oprof[0]);
+    tiff_set (&th->ntag, 273, 4, 1, sizeof *th + psize);
+    tiff_set (&th->ntag, 277, 3, 1, colors);
+    tiff_set (&th->ntag, 278, 4, 1, height);
+    tiff_set (&th->ntag, 279, 4, 1, height*width*colors*output_bps/8);
+  } else
+    tiff_set (&th->ntag, 274, 3, 1, "12435867"[flip]-'0');
+  tiff_set (&th->ntag, 282, 5, 1, TOFF(th->rat[0]));
+  tiff_set (&th->ntag, 283, 5, 1, TOFF(th->rat[2]));
+  tiff_set (&th->ntag, 284, 3, 1, 1);
+  tiff_set (&th->ntag, 296, 3, 1, 2);
+  tiff_set (&th->ntag, 305, 2, 32, TOFF(th->soft));
+  tiff_set (&th->ntag, 306, 2, 20, TOFF(th->date));
+  tiff_set (&th->ntag, 315, 2, 64, TOFF(th->artist));
+  tiff_set (&th->ntag, 34665, 4, 1, TOFF(th->nexif));
+  if (psize) tiff_set (&th->ntag, 34675, 7, psize, sizeof *th);
+  tiff_set (&th->nexif, 33434, 5, 1, TOFF(th->rat[4]));
+  tiff_set (&th->nexif, 33437, 5, 1, TOFF(th->rat[6]));
+  tiff_set (&th->nexif, 34855, 3, 1, iso_speed);
+  tiff_set (&th->nexif, 37386, 5, 1, TOFF(th->rat[8]));
+  if (gpsdata[1]) {
+    tiff_set (&th->ntag, 34853, 4, 1, TOFF(th->ngps));
+    tiff_set (&th->ngps,  0, 1,  4, 0x202);
+    tiff_set (&th->ngps,  1, 2,  2, gpsdata[29]);
+    tiff_set (&th->ngps,  2, 5,  3, TOFF(th->gps[0]));
+    tiff_set (&th->ngps,  3, 2,  2, gpsdata[30]);
+    tiff_set (&th->ngps,  4, 5,  3, TOFF(th->gps[6]));
+    tiff_set (&th->ngps,  5, 1,  1, gpsdata[31]);
+    tiff_set (&th->ngps,  6, 5,  1, TOFF(th->gps[18]));
+    tiff_set (&th->ngps,  7, 5,  3, TOFF(th->gps[12]));
+    tiff_set (&th->ngps, 18, 2, 12, TOFF(th->gps[20]));
+    tiff_set (&th->ngps, 29, 2, 12, TOFF(th->gps[23]));
+    memcpy (th->gps, gpsdata, sizeof th->gps);
+  }
+  th->rat[0] = th->rat[2] = 300;
+  th->rat[1] = th->rat[3] = 1;
+  FORC(6) th->rat[4+c] = 1000000;
+  th->rat[4] *= shutter;
+  th->rat[6] *= aperture;
+  th->rat[8] *= focal_len;
+  strncpy (th->desc, desc, 512);
+  strncpy (th->make, make, 64);
+  strncpy (th->model, model, 64);
+  strcpy (th->soft, "dcraw v"VERSION);
+  t = gmtime (&timestamp);
+  sprintf (th->date, "%04d:%02d:%02d %02d:%02d:%02d",
+      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
+  strncpy (th->artist, artist, 64);
+}
+
+void CLASS jpeg_thumb()
+{
+  char *thumb;
+  ushort exif[5];
+  struct tiff_hdr th;
+
+  thumb = (char *) malloc (thumb_length);
+  merror (thumb, "jpeg_thumb()");
+  fread (thumb, 1, thumb_length, ifp);
+  fputc (0xff, ofp);
+  fputc (0xd8, ofp);
+  if (strcmp (thumb+6, "Exif")) {
+    memcpy (exif, "\xff\xe1  Exif\0\0", 10);
+    exif[1] = htons (8 + sizeof th);
+    fwrite (exif, 1, sizeof exif, ofp);
+    tiff_head (&th, 0);
+    fwrite (&th, 1, sizeof th, ofp);
+  }
+  fwrite (thumb+2, 1, thumb_length-2, ofp);
+  free (thumb);
+}
+
+void CLASS write_ppm_tiff()
+{
+  struct tiff_hdr th;
+  uchar *ppm;
   ushort *ppm2;
-  int i, c, row, col, psize=0, soff, rstep, cstep;
+  int c, row, col, soff, rstep, cstep;
+  int perc, val, total, white=0x2000;
 
+  perc = width * height * 0.01;		/* 99th percentile white level */
+  if (fuji_width) perc /= 2;
+  if (!((highlight & ~2) || no_auto_bright))
+    for (white=c=0; c < colors; c++) {
+      for (val=0x2000, total=0; --val > 32; )
+	if ((total += histogram[c][val]) > perc) break;
+      if (white < val) white = val;
+    }
+  gamma_curve (gamm[0], gamm[1], 2, (white << 3)/bright);
   iheight = height;
   iwidth  = width;
   if (flip & 4) SWAP(height,width);
   ppm = (uchar *) calloc (width, colors*output_bps/8);
   ppm2 = (ushort *) ppm;
   merror (ppm, "write_ppm_tiff()");
-
-  memset (&th, 0, sizeof th);
-  th.order = htonl(0x4d4d4949) >> 16;
-  th.magic = 42;
-  th.ifd = 10;
-  tiff_set (&th.ntag, 256, 4, 1, width);
-  tiff_set (&th.ntag, 257, 4, 1, height);
-  tiff_set (&th.ntag, 258, 3, colors, output_bps);
-  if (colors > 2)
-    th.tag[th.ntag-1].val.i0 = TOFF(th.bps);
-  FORC4 th.bps[c] = output_bps;
-  tiff_set (&th.ntag, 259, 3, 1, 1);
-  tiff_set (&th.ntag, 262, 3, 1, 1 + (colors > 1));
-  tiff_set (&th.ntag, 271, 2, 64, TOFF(th.make));
-  tiff_set (&th.ntag, 272, 2, 72, TOFF(th.model));
-  if (oprof) psize = ntohl(oprof[0]);
-  tiff_set (&th.ntag, 273, 4, 1, sizeof th + psize);
-  tiff_set (&th.ntag, 277, 3, 1, colors);
-  tiff_set (&th.ntag, 278, 4, 1, height);
-  tiff_set (&th.ntag, 279, 4, 1, height*width*colors*output_bps/8);
-  tiff_set (&th.ntag, 305, 2, 32, TOFF(th.soft));
-  tiff_set (&th.ntag, 306, 2, 20, TOFF(th.date));
-  tiff_set (&th.ntag, 34665, 4, 1, TOFF(th.nexif));
-  if (psize) tiff_set (&th.ntag, 34675, 7, psize, sizeof th);
-  tiff_set (&th.nexif, 33434, 5, 1, TOFF(th.rat[0]));
-  tiff_set (&th.nexif, 33437, 5, 1, TOFF(th.rat[2]));
-  tiff_set (&th.nexif, 34855, 3, 1, iso_speed);
-  tiff_set (&th.nexif, 37386, 5, 1, TOFF(th.rat[4]));
-  for (i=0; i < 6; i++) th.rat[i] = 1000000;
-  th.rat[0] *= shutter;
-  th.rat[2] *= aperture;
-  th.rat[4] *= focal_len;
-  strncpy (th.make, make, 64);
-  strncpy (th.model, model, 64);
-  strcpy (th.soft, "dcraw v"VERSION_);
-  t = gmtime (&timestamp);
-  sprintf (th.date, "%04d:%02d:%02d %02d:%02d:%02d",
-      t->tm_year+1900,t->tm_mon+1,t->tm_mday,t->tm_hour,t->tm_min,t->tm_sec);
-
   if (output_tiff) {
+    tiff_head (&th, 1);
     fwrite (&th, sizeof th, 1, ofp);
-    if (psize)
-      fwrite (oprof, psize, 1, ofp);
+    if (oprof)
+      fwrite (oprof, ntohl(oprof[0]), 1, ofp);
   } else if (colors > 3)
     fprintf (ofp,
       "P7\nWIDTH %d\nHEIGHT %d\nDEPTH %d\nMAXVAL %d\nTUPLTYPE %s\nENDHDR\n",
@@ -6996,40 +8367,38 @@
   else
     fprintf (ofp, "P%d\n%d %d\n%d\n",
 	colors/2+5, width, height, (1 << output_bps)-1);
-
-  if (output_bps == 8) gamma_lut (lut);
   soff  = flip_index (0, 0);
   cstep = flip_index (0, 1) - soff;
   rstep = flip_index (1, 0) - flip_index (0, width);
   for (row=0; row < height; row++, soff += rstep) {
     for (col=0; col < width; col++, soff += cstep)
       if (output_bps == 8)
-	   FORCC ppm [col*colors+c] = lut[image[soff][c]];
-      else FORCC ppm2[col*colors+c] =     image[soff][c];
-    if (output_bps == 16 && !output_tiff && th.order == 0x4949)
+	   FORCC ppm [col*colors+c] = curve[image[soff][c]] >> 8;
+      else FORCC ppm2[col*colors+c] = curve[image[soff][c]];
+    if (output_bps == 16 && !output_tiff && htons(0x55aa) != 0x55aa)
       swab (ppm2, ppm2, width*colors*2);
     fwrite (ppm, colors*output_bps/8, width, ofp);
   }
   free (ppm);
 }
 
-int CLASS main (int argc, char **argv)
+int CLASS main (int argc, const char **argv)
 {
-  int arg, status=0, user_flip=-1, user_black=-1, user_qual=-1;
-  int timestamp_only=0, thumbnail_only=0, identify_only=0, write_to_stdout=0;
-  int half_size=0, use_fuji_rotate=1, quality, i, c;
-  char opt, *ofname, *sp, *cp, *dark_frame = NULL;
-  const char *write_ext;
+  int arg, status=0;
+  int timestamp_only=0, thumbnail_only=0, identify_only=0;
+  int user_qual=-1, user_black=-1, user_sat=-1, user_flip=-1;
+  int use_fuji_rotate=1, write_to_stdout=0, quality, i, c;
+  const char *sp, *bpfile=0, *dark_frame=0, *write_ext;
+  char opm, opt, *ofname, *cp;
   struct utimbuf ut;
-  FILE *ofp = stdout;
 #ifndef NO_LCMS
-  char *cam_profile = NULL, *out_profile = NULL;
+  const char *cam_profile=0, *out_profile=0;
 #endif
 
 #ifndef LOCALTIME
-  putenv ("TZ=UTC");
+  putenv ((char *) "TZ=UTC");
 #endif
-#ifdef ENABLE_NLS_
+#ifdef LOCALEDIR
   setlocale (LC_CTYPE, "");
   setlocale (LC_MESSAGES, "");
   bindtextdomain ("dcraw", LOCALEDIR);
@@ -7037,7 +8406,7 @@
 #endif
 
   if (argc == 1) {
-    printf(_("\nRaw photo decoder \"dcraw\" v%s"), VERSION_);
+    printf(_("\nRaw photo decoder \"dcraw\" v%s"), VERSION);
     printf(_("\nby Dave Coffin, dcoffin a cybercom o net\n"));
     printf(_("\nUsage:  %s [OPTION]... [FILE]...\n\n"), argv[0]);
     puts(_("-v        Print verbose messages"));
@@ -7046,13 +8415,18 @@
     puts(_("-i        Identify files without decoding them"));
     puts(_("-i -v     Identify files and show metadata"));
     puts(_("-z        Change file dates to camera timestamp"));
-    puts(_("-a        Use automatic white balance"));
     puts(_("-w        Use camera white balance, if possible"));
-    puts(_("-r <4 numbers> Set custom white balance"));
-    puts(_("-b <num>  Adjust brightness (default = 1.0)"));
-    puts(_("-k <num>  Set black point"));
+    puts(_("-a        Average the whole image for white balance"));
+    puts(_("-A <x y w h> Average a grey box for white balance"));
+    puts(_("-r <r g b g> Set custom white balance"));
+    puts(_("+M/-M     Use/don't use an embedded color matrix"));
+    puts(_("-C <r b>  Correct chromatic aberration"));
+    puts(_("-P <file> Fix the dead pixels listed in this file"));
     puts(_("-K <file> Subtract dark frame (16-bit raw PGM)"));
-    puts(_("-H [0-9]  Highlight mode (0=clip, 1=no clip, 2+=recover)"));
+    puts(_("-k <num>  Set the darkness level"));
+    puts(_("-S <num>  Set the saturation level"));
+    puts(_("-n <num>  Set threshold for wavelet denoising"));
+    puts(_("-H [0-9]  Highlight mode (0=clip, 1=unclip, 2=blend, 3+=rebuild)"));
     puts(_("-t [0-7]  Flip image (0=none, 3=180, 5=90CCW, 6=90CW)"));
     puts(_("-o [0-5]  Output colorspace (raw,sRGB,Adobe,Wide,ProPhoto,XYZ)"));
 #ifndef NO_LCMS
@@ -7062,36 +8436,49 @@
     puts(_("-d        Document mode (no color, no interpolation)"));
     puts(_("-D        Document mode without scaling (totally raw)"));
     puts(_("-j        Don't stretch or rotate raw pixels"));
+    puts(_("-W        Don't automatically brighten the image"));
+    puts(_("-b <num>  Adjust brightness (default = 1.0)"));
+    puts(_("-g <p ts> Set custom gamma curve (default = 2.222 4.5)"));
     puts(_("-q [0-3]  Set the interpolation quality"));
     puts(_("-h        Half-size color image (twice as fast as \"-q 0\")"));
     puts(_("-f        Interpolate RGGB as four colors"));
-    puts(_("-B <domain> <range> Apply bilateral filter to smooth noise"));
-    puts(_("-s [0-99] Select a different raw image from the same file"));
-    puts(_("-4        Write 16-bit linear instead of 8-bit with gamma"));
+    puts(_("-m <num>  Apply a 3x3 median filter to R-G and B-G"));
+    puts(_("-s [0..N-1] Select one raw image or \"all\" from each file"));
+    puts(_("-6        Write 16-bit instead of 8-bit"));
+    puts(_("-4        Linear 16-bit, same as \"-6 -W -g 1 1\""));
     puts(_("-T        Write TIFF instead of PPM"));
     puts("");
     return 1;
   }
   argv[argc] = "";
-  for (arg=1; argv[arg][0] == '-'; ) {
+  for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == '+'; ) {
     opt = argv[arg++][1];
-    if ((cp = strchr (sp="BbrktqsH", opt)))
-      for (i=0; i < "21411111"[cp-sp]-'0'; i++)
+    if ((cp = (char *) strchr (sp="nbrkStqmHACg", opt)))
+      for (i=0; i < "114111111422"[cp-sp]-'0'; i++)
 	if (!isdigit(argv[arg+i][0])) {
 	  fprintf (stderr,_("Non-numeric argument to \"-%c\"\n"), opt);
 	  return 1;
 	}
     switch (opt) {
-      case 'B':  sigma_d     = atof(argv[arg++]);
-		 sigma_r     = atof(argv[arg++]);  break;
+      case 'n':  threshold   = atof(argv[arg++]);  break;
       case 'b':  bright      = atof(argv[arg++]);  break;
       case 'r':
 	   FORC4 user_mul[c] = atof(argv[arg++]);  break;
+      case 'C':  aber[0] = 1 / atof(argv[arg++]);
+		 aber[2] = 1 / atof(argv[arg++]);  break;
+      case 'g':  gamm[0] =     atof(argv[arg++]);
+		 gamm[1] =     atof(argv[arg++]);
+		 if (gamm[0]) gamm[0] = 1/gamm[0]; break;
       case 'k':  user_black  = atoi(argv[arg++]);  break;
+      case 'S':  user_sat    = atoi(argv[arg++]);  break;
       case 't':  user_flip   = atoi(argv[arg++]);  break;
       case 'q':  user_qual   = atoi(argv[arg++]);  break;
-      case 's':  shot_select = atoi(argv[arg++]);  break;
+      case 'm':  med_passes  = atoi(argv[arg++]);  break;
       case 'H':  highlight   = atoi(argv[arg++]);  break;
+      case 's':
+	shot_select = abs(atoi(argv[arg]));
+	multi_out = !strcmp(argv[arg++],"all");
+	break;
       case 'o':
 	if (isdigit(argv[arg][0]) && !argv[arg][1])
 	  output_color = atoi(argv[arg++]);
@@ -7101,8 +8488,8 @@
       case 'p':  cam_profile = argv[arg++];
 #endif
 	break;
-      case 'K':  dark_frame  = argv[arg++];
-	break;
+      case 'P':  bpfile     = argv[arg++];  break;
+      case 'K':  dark_frame = argv[arg++];  break;
       case 'z':  timestamp_only    = 1;  break;
       case 'e':  thumbnail_only    = 1;  break;
       case 'i':  identify_only     = 1;  break;
@@ -7110,19 +8497,25 @@
       case 'v':  verbose           = 1;  break;
       case 'h':  half_size         = 1;		/* "-h" implies "-f" */
       case 'f':  four_color_rgb    = 1;  break;
+      case 'A':  FORC4 greybox[c]  = atoi(argv[arg++]);
       case 'a':  use_auto_wb       = 1;  break;
       case 'w':  use_camera_wb     = 1;  break;
+      case 'M':  use_camera_matrix = (opm == '+');  break;
       case 'D':
       case 'd':  document_mode = 1 + (opt == 'D');
       case 'j':  use_fuji_rotate   = 0;  break;
-      case 'm':  output_color      = 0;  break;
+      case 'W':  no_auto_bright    = 1;  break;
       case 'T':  output_tiff       = 1;  break;
-      case '4':  output_bps       = 16;  break;
+      case '4':  gamm[0] = gamm[1] =
+		 no_auto_bright    = 1;
+      case '6':  output_bps       = 16;  break;
       default:
 	fprintf (stderr,_("Unknown option \"-%c\".\n"), opt);
 	return 1;
     }
   }
+  if (use_camera_matrix < 0)
+      use_camera_matrix = use_camera_wb;
   if (arg == argc) {
     fprintf (stderr,_("No files to process.\n"));
     return 1;
@@ -7134,21 +8527,22 @@
     }
 #if defined(WIN32) || defined(DJGPP) || defined(__CYGWIN__)
     if (setmode(1,O_BINARY) < 0) {
-      perror("setmode()");
+      perror ("setmode()");
       return 1;
     }
 #endif
   }
   for ( ; arg < argc; arg++) {
     status = 1;
-    image = NULL;
-    oprof = NULL;
+    image = 0;
+    oprof = 0;
+    meta_data = ofname = 0;
+    ofp = stdout;
     if (setjmp (failure)) {
       if (fileno(ifp) > 2) fclose(ifp);
       if (fileno(ofp) > 2) fclose(ofp);
-      if (image) free (image);
       status = 1;
-      continue;
+      goto cleanup;
     }
     ifname = argv[arg];
     if (!(ifp = fopen (ifname, "rb"))) {
@@ -7156,6 +8550,13 @@
       continue;
     }
     status = (identify(),!is_raw);
+    if (user_flip >= 0)
+      flip = user_flip;
+    switch ((flip+3600) % 360) {
+      case 270:  flip = 5;  break;
+      case 180:  flip = 3;  break;
+      case  90:  flip = 6;
+    }
     if (timestamp_only) {
       if ((status = !timestamp))
 	fprintf (stderr,_("%s has no timestamp.\n"), ifname);
@@ -7194,6 +8595,8 @@
       printf (_("\nFilename: %s\n"), ifname);
       printf (_("Timestamp: %s"), ctime(&timestamp));
       printf (_("Camera: %s %s\n"), make, model);
+      if (artist[0])
+	printf (_("Owner: %s\n"), artist);
       if (dng_version) {
 	printf (_("DNG Version: "));
 	for (i=24; i >= 0; i -= 8)
@@ -7206,9 +8609,8 @@
       printf (_("%0.1f sec\n"), shutter);
       printf (_("Aperture: f/%0.1f\n"), aperture);
       printf (_("Focal length: %0.1f mm\n"), focal_len);
-      printf (_("Secondary pixels: %s\n"), fuji_secondary ? _("yes"):_("no"));
       printf (_("Embedded ICC profile: %s\n"), profile_length ? _("yes"):_("no"));
-      printf (_("Decodable with dcraw: %s\n"), is_raw ? _("yes"):_("no"));
+      printf (_("Number of raw images: %d\n"), is_raw);
       if (pixel_aspect != 1)
 	printf (_("Pixel Aspect Ratio: %0.6f\n"), pixel_aspect);
       if (thumb_offset)
@@ -7217,14 +8619,8 @@
     } else if (!is_raw)
       fprintf (stderr,_("Cannot decode file %s\n"), ifname);
     if (!is_raw) goto next;
-    if (user_flip >= 0)
-      flip = user_flip;
-    switch ((flip+3600) % 360) {
-      case 270:  flip = 5;  break;
-      case 180:  flip = 3;  break;
-      case  90:  flip = 6;
-    }
-    shrink = half_size && filters;
+    shrink = filters &&
+	(half_size || threshold || aber[0] != 1 || aber[2] != 1);
     iheight = (height + shrink) >> shrink;
     iwidth  = (width  + shrink) >> shrink;
     if (identify_only) {
@@ -7263,38 +8659,52 @@
       fclose(ifp);
       continue;
     }
-    image = (ushort (*)[4])
-	calloc (iheight*iwidth*sizeof *image + meta_length, 1);
+    if (use_camera_matrix && cmatrix[0][0] > 0.25) {
+      memcpy (rgb_cam, cmatrix, sizeof cmatrix);
+      raw_color = 0;
+    }
+    image = (ushort (*)[4]) calloc (iheight*iwidth, sizeof *image);
     merror (image, "main()");
-    meta_data = (char *) (image + iheight*iwidth);
+    if (meta_length) {
+      meta_data = (char *) malloc (meta_length);
+      merror (meta_data, "main()");
+    }
     if (verbose)
-      fprintf (stderr,
-	_("Loading %s %s image from %s ...\n"), make, model, ifname);
-    fseek (ifp, data_offset, SEEK_SET);
+      fprintf (stderr,_("Loading %s %s image from %s ...\n"),
+	make, model, ifname);
+    if (shot_select >= is_raw)
+      fprintf (stderr,_("%s: \"-s %d\" requests a nonexistent image!\n"),
+	ifname, shot_select);
+    fseeko (ifp, data_offset, SEEK_SET);
     (*load_raw)();
-    bad_pixels();
+    if (zero_is_bad) remove_zeroes();
+    bad_pixels (bpfile);
     if (dark_frame) subtract (dark_frame);
-    height = iheight;
-    width  = iwidth;
     quality = 2 + !fuji_width;
     if (user_qual >= 0) quality = user_qual;
     if (user_black >= 0) black = user_black;
+    if (user_sat > 0) maximum = user_sat;
 #ifdef COLORCHECK
     colorcheck();
 #endif
     if (is_foveon && !document_mode) foveon_interpolate();
     if (!is_foveon && document_mode < 2) scale_colors();
-    if (shrink) filters = 0;
-    cam_to_cielab (NULL,NULL);
+    pre_interpolate();
     if (filters && !document_mode) {
       if (quality == 0)
 	lin_interpolate();
-      else if (quality < 3 || colors > 3)
-	   vng_interpolate();
+      else if (quality == 1 || colors > 3)
+	vng_interpolate();
+      else if (quality == 2)
+	ppg_interpolate();
       else ahd_interpolate();
     }
-    if (sigma_d > 0 && sigma_r > 0) bilateral_filter();
-    if (!is_foveon && highlight > 1) recover_highlights();
+    if (mix_green)
+      for (colors=3, i=0; i < height*width; i++)
+	image[i][1] = (image[i][1] + image[i][3]) >> 1;
+    if (!is_foveon && colors == 3) median_filter();
+    if (!is_foveon && highlight == 2) blend_highlights();
+    if (!is_foveon && highlight > 2) recover_highlights();
     if (use_fuji_rotate) fuji_rotate();
 #ifndef NO_LCMS
     if (cam_profile) apply_profile (cam_profile, out_profile);
@@ -7308,32 +8718,40 @@
       write_ext = ".tiff";
     else
       write_ext = ".pgm\0.ppm\0.ppm\0.pam" + colors*5-5;
-    ofname = (char *) malloc (strlen(ifname) + 16);
+    ofname = (char *) malloc (strlen(ifname) + 64);
     merror (ofname, "main()");
     if (write_to_stdout)
       strcpy (ofname,_("standard output"));
     else {
       strcpy (ofname, ifname);
       if ((cp = strrchr (ofname, '.'))) *cp = 0;
+      if (multi_out)
+	sprintf (ofname+strlen(ofname), "_%0*d",
+		snprintf(0,0,"%d",is_raw-1), shot_select);
       if (thumbnail_only)
 	strcat (ofname, ".thumb");
       strcat (ofname, write_ext);
       ofp = fopen (ofname, "wb");
       if (!ofp) {
 	status = 1;
-	perror(ofname);
+	perror (ofname);
 	goto cleanup;
       }
     }
     if (verbose)
       fprintf (stderr,_("Writing data to %s ...\n"), ofname);
-    (*write_fun)(ofp);
+    (*write_fun)();
     fclose(ifp);
     if (ofp != stdout) fclose(ofp);
 cleanup:
-    if (oprof) free(oprof);
-    free (ofname);
-    free (image);
+    if (meta_data) free (meta_data);
+    if (ofname) free (ofname);
+    if (oprof) free (oprof);
+    if (image) free (image);
+    if (multi_out) {
+      if (++shot_select < is_raw) arg--;
+      else shot_select = 0;
+    }
   }
   return status;
 }
