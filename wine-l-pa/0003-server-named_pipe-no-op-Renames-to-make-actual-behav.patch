From d68f0135293420fce2a1aeded049c20f761ee197 Mon Sep 17 00:00:00 2001
From: Adam Martinson <adam.r.martinson@gmail.com>
Date: Thu, 20 Dec 2012 16:58:47 -0600
Subject: [PATCH 03/10] server/named_pipe: (no-op) Renames to make actual behavior clearer part 2.
Reply-To: wine-devel <wine-devel@winehq.org>
To: wine-patches <wine-patches@winehq.org>

---
 server/named_pipe.c |  410 +++++++++++++++++++++++++-------------------------
 1 files changed, 205 insertions(+), 205 deletions(-)

diff --git a/server/named_pipe.c b/server/named_pipe.c
index fa7ae88..6bc4572 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -65,26 +65,26 @@ enum pipe_state
 
 struct named_pipe;
 
-struct pipe_server
+struct pipe_instance
 {
     struct object        obj;        /* object header */
     struct fd           *fd;         /* pipe file descriptor */
     struct fd           *ioctl_fd;   /* file descriptor for ioctls when not connected */
-    struct list          entry;      /* entry in named pipe servers list */
-    enum pipe_state      state;      /* server state */
-    struct pipe_end     *client;     /* client that this server is connected to */
+    struct list          entry;      /* entry in named pipe instances list */
+    enum pipe_state      state;      /* instance state */
+    struct pipe_end     *client;     /* client that this instance is connected to */
     struct named_pipe   *pipe;
     struct timeout_user *flush_poll;
-    struct event        *event;
+    struct event        *event_empty;
     unsigned int         options;    /* pipe options */
 };
 
 struct pipe_end
 {
-    struct object        obj;        /* object header */
-    struct fd           *fd;         /* pipe file descriptor */
-    struct pipe_server  *server;     /* server that this end is connected to */
-    unsigned int         flags;      /* pipe flags */
+    struct object            obj;        /* object header */
+    struct fd               *fd;         /* pipe file descriptor */
+    struct pipe_instance    *inst;       /* instance that this end is connected to */
+    unsigned int             flags;      /* pipe flags */
 };
 
 struct named_pipe
@@ -95,9 +95,9 @@ struct named_pipe
     unsigned int        maxinstances;
     unsigned int        outsize;
     unsigned int        insize;
-    unsigned int        instances;
+    unsigned int        numinstances;
     timeout_t           timeout;
-    struct list         servers;     /* list of servers using this pipe */
+    struct list         instances;   /* list of instances using this pipe */
     struct async_queue *waiters;     /* list of clients waiting to connect */
 };
 
@@ -134,48 +134,48 @@ static const struct object_ops named_pipe_ops =
     named_pipe_destroy            /* destroy */
 };
 
-/* server end functions */
-static void pipe_server_dump( struct object *obj, int verbose );
-static struct fd *pipe_server_get_fd( struct object *obj );
-static void pipe_server_destroy( struct object *obj);
-static void pipe_server_flush( struct fd *fd, struct event **event );
-static enum server_fd_type pipe_server_get_fd_type( struct fd *fd );
-static obj_handle_t pipe_server_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async,
+/* pipe instance functions */
+static void pipe_instance_dump( struct object *obj, int verbose );
+static struct fd *pipe_instance_get_fd( struct object *obj );
+static void pipe_instance_destroy( struct object *obj);
+static void pipe_instance_flush( struct fd *fd, struct event **event );
+static enum server_fd_type pipe_instance_get_fd_type( struct fd *fd );
+static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async,
                                        int blocking, const void *data, data_size_t size );
 
-static const struct object_ops pipe_server_ops =
+static const struct object_ops pipe_instance_ops =
 {
-    sizeof(struct pipe_server),   /* size */
-    pipe_server_dump,             /* dump */
+    sizeof(struct pipe_instance), /* size */
+    pipe_instance_dump,           /* dump */
     no_get_type,                  /* get_type */
     add_queue,                    /* add_queue */
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
-    pipe_server_get_fd,           /* get_fd */
+    pipe_instance_get_fd,         /* get_fd */
     default_fd_map_access,        /* map_access */
     default_get_sd,               /* get_sd */
     default_set_sd,               /* set_sd */
     no_lookup_name,               /* lookup_name */
     no_open_file,                 /* open_file */
     fd_close_handle,              /* close_handle */
-    pipe_server_destroy           /* destroy */
+    pipe_instance_destroy         /* destroy */
 };
 
-static const struct fd_ops pipe_server_fd_ops =
+static const struct fd_ops pipe_instance_fd_ops =
 {
     default_fd_get_poll_events,   /* get_poll_events */
     default_poll_event,           /* poll_event */
-    pipe_server_flush,            /* flush */
-    pipe_server_get_fd_type,      /* get_fd_type */
-    pipe_server_ioctl,            /* ioctl */
+    pipe_instance_flush,          /* flush */
+    pipe_instance_get_fd_type,    /* get_fd_type */
+    pipe_instance_ioctl,          /* ioctl */
     default_fd_queue_async,       /* queue_async */
     default_fd_reselect_async,    /* reselect_async */
     default_fd_cancel_async,      /* cancel_async */
 };
 
-/* client end functions */
+/* pipe end functions */
 static void pipe_end_dump( struct object *obj, int verbose );
 static int pipe_end_signaled( struct object *obj, struct thread *thread );
 static struct fd *pipe_end_get_fd( struct object *obj );
@@ -277,18 +277,18 @@ static unsigned int named_pipe_map_access( struct object *obj, unsigned int acce
     return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
 }
 
-static void pipe_server_dump( struct object *obj, int verbose )
+static void pipe_instance_dump( struct object *obj, int verbose )
 {
-    struct pipe_server *server = (struct pipe_server *) obj;
-    assert( obj->ops == &pipe_server_ops );
-    fprintf( stderr, "Named pipe server pipe=%p state=%d\n", server->pipe, server->state );
+    struct pipe_instance *inst = (struct pipe_instance *) obj;
+    assert( obj->ops == &pipe_instance_ops );
+    fprintf( stderr, "Named pipe instance pipe=%p state=%d\n", inst->pipe, inst->state );
 }
 
 static void pipe_end_dump( struct object *obj, int verbose )
 {
     struct pipe_end *end = (struct pipe_end *) obj;
     assert( obj->ops == &pipe_end_ops );
-    fprintf( stderr, "Named pipe client server=%p\n", end->server );
+    fprintf( stderr, "Named pipe end instance=%p\n", end->inst );
 }
 
 static int pipe_end_signaled( struct object *obj, struct thread *thread )
@@ -302,8 +302,8 @@ static void named_pipe_destroy( struct object *obj)
 {
     struct named_pipe *pipe = (struct named_pipe *) obj;
 
-    assert( list_empty( &pipe->servers ) );
-    assert( !pipe->instances );
+    assert( list_empty( &pipe->instances ) );
+    assert( !pipe->numinstances );
     free_async_queue( pipe->waiters );
 }
 
@@ -316,112 +316,112 @@ static struct fd *pipe_end_get_fd( struct object *obj )
     return NULL;
 }
 
-static void set_server_state( struct pipe_server *server, enum pipe_state state )
+static void set_instance_state( struct pipe_instance *inst, enum pipe_state state )
 {
-    server->state = state;
+    inst->state = state;
 
     switch(state)
     {
     case ps_connected:
     case ps_disconnected_client:
-        assert( server->fd );
+        assert( inst->fd );
         break;
     case ps_wait_open:
     case ps_idle_server:
-        assert( !server->fd );
-        set_no_fd_status( server->ioctl_fd, STATUS_PIPE_LISTENING );
+        assert( !inst->fd );
+        set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_LISTENING );
         break;
     case ps_disconnected_server:
     case ps_wait_connect:
-        assert( !server->fd );
-        set_no_fd_status( server->ioctl_fd, STATUS_PIPE_DISCONNECTED );
+        assert( !inst->fd );
+        set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_DISCONNECTED );
         break;
     }
 }
 
-static struct fd *pipe_server_get_fd( struct object *obj )
+static struct fd *pipe_instance_get_fd( struct object *obj )
 {
-    struct pipe_server *server = (struct pipe_server *) obj;
+    struct pipe_instance *inst = (struct pipe_instance *) obj;
 
-    return (struct fd *)grab_object( server->fd ? server->fd : server->ioctl_fd );
+    return (struct fd *)grab_object( inst->fd ? inst->fd : inst->ioctl_fd );
 }
 
 
-static void notify_empty( struct pipe_server *server )
+static void notify_empty( struct pipe_instance *end )
 {
-    if (!server->flush_poll)
+    if (!end->flush_poll)
         return;
-    assert( server->state == ps_connected );
-    assert( server->event );
-    remove_timeout_user( server->flush_poll );
-    server->flush_poll = NULL;
-    set_event( server->event );
-    release_object( server->event );
-    server->event = NULL;
+    assert( end->state == ps_connected );
+    assert( end->event_empty );
+    remove_timeout_user( end->flush_poll );
+    end->flush_poll = NULL;
+    set_event( end->event_empty );
+    release_object( end->event_empty );
+    end->event_empty = NULL;
 }
 
-static void do_disconnect( struct pipe_server *server )
+static void do_disconnect( struct pipe_instance *inst )
 {
     /* we may only have a server fd, if the client disconnected */
-    if (server->client)
+    if (inst->client)
     {
-        assert( server->client->server == server );
-        assert( server->client->fd );
-        release_object( server->client->fd );
-        server->client->fd = NULL;
+        assert( inst->client->inst == inst );
+        assert( inst->client->fd );
+        release_object( inst->client->fd );
+        inst->client->fd = NULL;
     }
-    assert( server->fd );
-    shutdown( get_unix_fd( server->fd ), SHUT_RDWR );
-    release_object( server->fd );
-    server->fd = NULL;
+    assert( inst->fd );
+    shutdown( get_unix_fd( inst->fd ), SHUT_RDWR );
+    release_object( inst->fd );
+    inst->fd = NULL;
 }
 
-static void pipe_server_destroy( struct object *obj)
+static void pipe_instance_destroy( struct object *obj )
 {
-    struct pipe_server *server = (struct pipe_server *)obj;
+    struct pipe_instance *inst = (struct pipe_instance *)obj;
 
-    assert( obj->ops == &pipe_server_ops );
+    assert( obj->ops == &pipe_instance_ops );
 
-    if (server->fd)
+    if (inst->fd)
     {
-        notify_empty( server );
-        do_disconnect( server );
+        notify_empty( inst );
+        do_disconnect( inst );
     }
 
-    if (server->client)
+    if (inst->client)
     {
-        server->client->server = NULL;
-        server->client = NULL;
+        inst->client->inst = NULL;
+        inst->client = NULL;
     }
 
-    assert( server->pipe->instances );
-    server->pipe->instances--;
+    assert( inst->pipe->numinstances );
+    inst->pipe->numinstances--;
 
-    if (server->ioctl_fd) release_object( server->ioctl_fd );
-    list_remove( &server->entry );
-    release_object( server->pipe );
+    if (inst->ioctl_fd) release_object( inst->ioctl_fd );
+    list_remove( &inst->entry );
+    release_object( inst->pipe );
 }
 
-static void pipe_end_destroy( struct object *obj)
+static void pipe_end_destroy( struct object *obj )
 {
     struct pipe_end *end = (struct pipe_end *)obj;
-    struct pipe_server *server = end->server;
+    struct pipe_instance *inst = end->inst;
 
     assert( obj->ops == &pipe_end_ops );
 
-    if (server)
+    if (inst)
     {
-        notify_empty( server );
+        notify_empty( inst );
 
-        switch(server->state)
+        switch(inst->state)
         {
         case ps_connected:
-            /* Don't destroy the server's fd here as we can't
+            /* Don't destroy the instances's fd here as we can't
                do a successful flush without it. */
-            set_server_state( server, ps_disconnected_client );
+            set_instance_state( inst, ps_disconnected_client );
             break;
         case ps_disconnected_server:
-            set_server_state( server, ps_wait_connect );
+            set_instance_state( inst, ps_wait_connect );
             break;
         case ps_idle_server:
         case ps_wait_open:
@@ -430,9 +430,9 @@ static void pipe_end_destroy( struct object *obj)
             assert( 0 );
             break;
         }
-        assert( server->client );
-        server->client = NULL;
-        end->server = NULL;
+        assert( inst->client );
+        inst->client = NULL;
+        end->inst = NULL;
     }
     if (end->fd) release_object( end->fd );
 }
@@ -508,14 +508,14 @@ void create_named_pipe_device( struct directory *root, const struct unicode_str
     if (dev) make_object_static( &dev->obj );
 }
 
-static int pipe_data_remaining( struct pipe_server *server )
+static int pipe_data_remaining( struct pipe_instance *inst )
 {
     struct pollfd pfd;
     int fd;
 
-    assert( server->client );
+    assert( inst->client );
 
-    fd = get_unix_fd( server->client->fd );
+    fd = get_unix_fd( inst->client->fd );
     if (fd < 0)
         return 0;
     pfd.fd = fd;
@@ -524,47 +524,47 @@ static int pipe_data_remaining( struct pipe_server *server )
 
     if (0 > poll( &pfd, 1, 0 ))
         return 0;
- 
+
     return pfd.revents&POLLIN;
 }
 
 static void check_flushed( void *arg )
 {
-    struct pipe_server *server = (struct pipe_server*) arg;
+    struct pipe_instance *end = (struct pipe_instance*) arg;
 
-    assert( server->event );
-    if (pipe_data_remaining( server ))
+    assert( end->event_empty );
+    if (pipe_data_remaining( end ))
     {
-        server->flush_poll = add_timeout_user( -TICKS_PER_SEC / 10, check_flushed, server );
+        end->flush_poll = add_timeout_user( -TICKS_PER_SEC / 10, check_flushed, end );
     }
     else
     {
         /* notify_empty( server ); */
-        server->flush_poll = NULL;
-        set_event( server->event );
-        release_object( server->event );
-        server->event = NULL;
+        end->flush_poll = NULL;
+        set_event( end->event_empty );
+        release_object( end->event_empty );
+        end->event_empty = NULL;
     }
 }
 
-static void pipe_server_flush( struct fd *fd, struct event **event )
+static void pipe_instance_flush( struct fd *fd, struct event **event )
 {
-    struct pipe_server *server = get_fd_user( fd );
+    struct pipe_instance *other_end = get_fd_user( fd );
 
-    if (!server || server->state != ps_connected) return;
+    if (!other_end || other_end->state != ps_connected) return;
 
     /* FIXME: if multiple threads flush the same pipe,
               maybe should create a list of processes to notify */
-    if (server->flush_poll) return;
+    if (other_end->flush_poll) return;
 
-    if (pipe_data_remaining( server ))
+    if (pipe_data_remaining( other_end ))
     {
         /* this kind of sux -
            there's no unix way to be alerted when a pipe becomes empty */
-        server->event = create_event( NULL, NULL, 0, 0, 0, NULL );
-        if (!server->event) return;
-        server->flush_poll = add_timeout_user( -TICKS_PER_SEC / 10, check_flushed, server );
-        *event = server->event;
+        other_end->event_empty = create_event( NULL, NULL, 0, 0, 0, NULL );
+        if (!other_end->event_empty) return;
+        other_end->flush_poll = add_timeout_user( -TICKS_PER_SEC / 10, check_flushed, other_end );
+        *event = other_end->event_empty;
     }
 }
 
@@ -578,7 +578,7 @@ static inline int is_overlapped( unsigned int options )
     return !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
 }
 
-static enum server_fd_type pipe_server_get_fd_type( struct fd *fd )
+static enum server_fd_type pipe_instance_get_fd_type( struct fd *fd )
 {
     return FD_TYPE_PIPE;
 }
@@ -601,17 +601,17 @@ static obj_handle_t alloc_wait_event( struct process *process )
     return handle;
 }
 
-static obj_handle_t pipe_server_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async_data,
+static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async_data,
                                        int blocking, const void *data, data_size_t size )
 {
-    struct pipe_server *server = get_fd_user( fd );
+    struct pipe_instance *inst = get_fd_user( fd );
     struct async *async;
     obj_handle_t wait_handle = 0;
 
     switch(code)
     {
     case FSCTL_PIPE_LISTEN:
-        switch(server->state)
+        switch(inst->state)
         {
         case ps_idle_server:
         case ps_wait_connect:
@@ -620,18 +620,18 @@ static obj_handle_t pipe_server_ioctl( struct fd *fd, ioctl_code_t code, const a
                 async_data_t new_data = *async_data;
                 if (!(wait_handle = alloc_wait_event( current->process ))) break;
                 new_data.event = wait_handle;
-                if (!(async = fd_queue_async( server->ioctl_fd, &new_data, ASYNC_TYPE_WAIT )))
+                if (!(async = fd_queue_async( inst->ioctl_fd, &new_data, ASYNC_TYPE_WAIT )))
                 {
                     close_handle( current->process, wait_handle );
                     break;
                 }
             }
-            else async = fd_queue_async( server->ioctl_fd, async_data, ASYNC_TYPE_WAIT );
+            else async = fd_queue_async( inst->ioctl_fd, async_data, ASYNC_TYPE_WAIT );
 
             if (async)
             {
-                set_server_state( server, ps_wait_open );
-                if (server->pipe->waiters) async_wake_up( server->pipe->waiters, STATUS_SUCCESS );
+                set_instance_state( inst, ps_wait_open );
+                if (inst->pipe->waiters) async_wake_up( inst->pipe->waiters, STATUS_SUCCESS );
                 release_object( async );
                 set_error( STATUS_PENDING );
                 return wait_handle;
@@ -653,23 +653,23 @@ static obj_handle_t pipe_server_ioctl( struct fd *fd, ioctl_code_t code, const a
         return 0;
 
     case FSCTL_PIPE_DISCONNECT:
-        switch(server->state)
+        switch(inst->state)
         {
         case ps_connected:
-            assert( server->client );
-            assert( server->client->fd );
+            assert( inst->client );
+            assert( inst->client->fd );
 
-            notify_empty( server );
+            notify_empty( inst );
 
             /* dump the client and server fds, but keep the pointers
                around - client loses all waiting data */
-            do_disconnect( server );
-            set_server_state( server, ps_disconnected_server );
+            do_disconnect( inst );
+            set_instance_state( inst, ps_disconnected_server );
             break;
         case ps_disconnected_client:
-            assert( !server->client );
-            do_disconnect( server );
-            set_server_state( server, ps_wait_connect );
+            assert( !inst->client );
+            do_disconnect( inst );
+            set_instance_state( inst, ps_wait_connect );
             break;
         case ps_idle_server:
         case ps_wait_open:
@@ -730,37 +730,12 @@ static struct named_pipe *create_named_pipe( struct directory *root, const struc
     return pipe;
 }
 
-static struct pipe_server *get_pipe_server_obj( struct process *process,
+static struct pipe_instance *get_pipe_instance_obj( struct process *process,
                                 obj_handle_t handle, unsigned int access )
 {
     struct object *obj;
-    obj = get_handle_obj( process, handle, access, &pipe_server_ops );
-    return (struct pipe_server *) obj;
-}
-
-static struct pipe_server *create_pipe_server( struct named_pipe *pipe, unsigned int options )
-{
-    struct pipe_server *server;
-
-    server = alloc_object( &pipe_server_ops );
-    if (!server)
-        return NULL;
-
-    server->fd = NULL;
-    server->pipe = pipe;
-    server->client = NULL;
-    server->flush_poll = NULL;
-    server->options = options;
-
-    list_add_head( &pipe->servers, &server->entry );
-    grab_object( pipe );
-    if (!(server->ioctl_fd = alloc_pseudo_fd( &pipe_server_fd_ops, &server->obj, options )))
-    {
-        release_object( server );
-        return NULL;
-    }
-    set_server_state( server, ps_idle_server );
-    return server;
+    obj = get_handle_obj( process, handle, access, &pipe_instance_ops );
+    return (struct pipe_instance *) obj;
 }
 
 static struct pipe_end *create_pipe_end( unsigned int flags )
@@ -772,28 +747,53 @@ static struct pipe_end *create_pipe_end( unsigned int flags )
         return NULL;
 
     end->fd = NULL;
-    end->server = NULL;
+    end->inst = NULL;
     end->flags = flags;
 
     return end;
 }
 
-static struct pipe_server *find_available_server( struct named_pipe *pipe )
+static struct pipe_instance *create_pipe_instance( struct named_pipe *pipe, unsigned int options )
+{
+    struct pipe_instance *inst;
+
+    inst = alloc_object( &pipe_instance_ops );
+    if (!inst)
+        return NULL;
+
+    inst->fd = NULL;
+    inst->pipe = pipe;
+    inst->client = NULL;
+    inst->flush_poll = NULL;
+    inst->options = options;
+
+    list_add_head( &pipe->instances, &inst->entry );
+    grab_object( pipe );
+    if (!(inst->ioctl_fd = alloc_pseudo_fd( &pipe_instance_fd_ops, &inst->obj, options )))
+    {
+        release_object( inst );
+        return NULL;
+    }
+    set_instance_state( inst, ps_idle_server );
+    return inst;
+}
+
+static struct pipe_instance *find_available_instance( struct named_pipe *pipe )
 {
-    struct pipe_server *server;
+    struct pipe_instance *inst;
 
-    /* look for pipe servers that are listening */
-    LIST_FOR_EACH_ENTRY( server, &pipe->servers, struct pipe_server, entry )
+    /* look for pipe instances that are listening */
+    LIST_FOR_EACH_ENTRY( inst, &pipe->instances, struct pipe_instance, entry )
     {
-        if (server->state == ps_wait_open)
-            return (struct pipe_server *)grab_object( server );
+        if (inst->state == ps_wait_open)
+            return (struct pipe_instance *)grab_object( inst );
     }
 
-    /* fall back to pipe servers that are idle */
-    LIST_FOR_EACH_ENTRY( server, &pipe->servers, struct pipe_server, entry )
+    /* fall back to pipe instances that are idle */
+    LIST_FOR_EACH_ENTRY( inst, &pipe->instances, struct pipe_instance, entry )
     {
-        if (server->state == ps_idle_server)
-            return (struct pipe_server *)grab_object( server );
+        if (inst->state == ps_idle_server)
+            return (struct pipe_instance *)grab_object( inst );
     }
 
     return NULL;
@@ -803,23 +803,23 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
                                             unsigned int sharing, unsigned int options )
 {
     struct named_pipe *pipe = (struct named_pipe *)obj;
-    struct pipe_server *server;
+    struct pipe_instance *inst;
     struct pipe_end *client;
     unsigned int pipe_sharing;
     int fds[2];
 
-    if (!(server = find_available_server( pipe )))
+    if (!(inst = find_available_instance( pipe )))
     {
         set_error( STATUS_PIPE_NOT_AVAILABLE );
         return NULL;
     }
 
-    pipe_sharing = server->pipe->sharing;
+    pipe_sharing = inst->pipe->sharing;
     if (((access & GENERIC_READ) && !(pipe_sharing & FILE_SHARE_READ)) ||
         ((access & GENERIC_WRITE) && !(pipe_sharing & FILE_SHARE_WRITE)))
     {
         set_error( STATUS_ACCESS_DENIED );
-        release_object( server );
+        release_object( inst );
         return NULL;
     }
 
@@ -827,13 +827,13 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
     {
         if (!socketpair( PF_UNIX, SOCK_STREAM, 0, fds ))
         {
-            assert( !server->fd );
+            assert( !inst->fd );
 
             /* for performance reasons, only set nonblocking mode when using
              * overlapped I/O. Otherwise, we will be doing too much busy
              * looping */
             if (is_overlapped( options )) fcntl( fds[1], F_SETFL, O_NONBLOCK );
-            if (is_overlapped( server->options )) fcntl( fds[0], F_SETFL, O_NONBLOCK );
+            if (is_overlapped( inst->options )) fcntl( fds[0], F_SETFL, O_NONBLOCK );
 
             if (pipe->insize)
             {
@@ -847,17 +847,17 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             }
 
             client->fd = create_anonymous_fd( &pipe_end_fd_ops, fds[1], &client->obj, options );
-            server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
-            if (client->fd && server->fd)
+            inst->fd = create_anonymous_fd( &pipe_instance_fd_ops, fds[0], &inst->obj, inst->options );
+            if (client->fd && inst->fd)
             {
                 allow_fd_caching( client->fd );
-                allow_fd_caching( server->fd );
-                fd_copy_completion( server->ioctl_fd, server->fd );
-                if (server->state == ps_wait_open)
-                    fd_async_wake_up( server->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
-                set_server_state( server, ps_connected );
-                server->client = client;
-                client->server = server;
+                allow_fd_caching( inst->fd );
+                fd_copy_completion( inst->ioctl_fd, inst->fd );
+                if (inst->state == ps_wait_open)
+                    fd_async_wake_up( inst->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
+                set_instance_state( inst, ps_connected );
+                inst->client = client;
+                client->inst = inst;
             }
             else
             {
@@ -872,7 +872,7 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             client = NULL;
         }
     }
-    release_object( server );
+    release_object( inst );
     return &client->obj;
 }
 
@@ -888,7 +888,7 @@ static obj_handle_t named_pipe_device_ioctl( struct fd *fd, ioctl_code_t code, c
             const FILE_PIPE_WAIT_FOR_BUFFER *buffer = data;
             obj_handle_t wait_handle = 0;
             struct named_pipe *pipe;
-            struct pipe_server *server;
+            struct pipe_instance *inst;
             struct unicode_str name;
 
             if (size < sizeof(*buffer) ||
@@ -904,7 +904,7 @@ static obj_handle_t named_pipe_device_ioctl( struct fd *fd, ioctl_code_t code, c
                 set_error( STATUS_PIPE_NOT_AVAILABLE );
                 return 0;
             }
-            if (!(server = find_available_server( pipe )))
+            if (!(inst = find_available_instance( pipe )))
             {
                 struct async *async;
 
@@ -931,7 +931,7 @@ static obj_handle_t named_pipe_device_ioctl( struct fd *fd, ioctl_code_t code, c
                     set_error( STATUS_PENDING );
                 }
             }
-            else release_object( server );
+            else release_object( inst );
 
         done:
             release_object( pipe );
@@ -947,7 +947,7 @@ static obj_handle_t named_pipe_device_ioctl( struct fd *fd, ioctl_code_t code, c
 DECL_HANDLER(create_named_pipe)
 {
     struct named_pipe *pipe;
-    struct pipe_server *server;
+    struct pipe_instance *inst;
     struct unicode_str name;
     struct directory *root = NULL;
 
@@ -971,9 +971,9 @@ DECL_HANDLER(create_named_pipe)
     if (get_error() != STATUS_OBJECT_NAME_EXISTS)
     {
         /* initialize it if it didn't already exist */
-        pipe->instances = 0;
+        pipe->numinstances = 0;
         pipe->waiters = NULL;
-        list_init( &pipe->servers );
+        list_init( &pipe->instances );
         pipe->insize = req->insize;
         pipe->outsize = req->outsize;
         pipe->maxinstances = req->maxinstances;
@@ -983,7 +983,7 @@ DECL_HANDLER(create_named_pipe)
     }
     else
     {
-        if (pipe->maxinstances <= pipe->instances)
+        if (pipe->maxinstances <= pipe->numinstances)
         {
             set_error( STATUS_INSTANCE_NOT_AVAILABLE );
             release_object( pipe );
@@ -998,12 +998,12 @@ DECL_HANDLER(create_named_pipe)
         clear_error(); /* clear the name collision */
     }
 
-    server = create_pipe_server( pipe, req->options );
-    if (server)
+    inst = create_pipe_instance( pipe, req->options );
+    if (inst)
     {
-        reply->handle = alloc_handle( current->process, server, req->access, req->attributes );
-        server->pipe->instances++;
-        release_object( server );
+        reply->handle = alloc_handle( current->process, inst, req->access, req->attributes );
+        inst->pipe->numinstances++;
+        release_object( inst );
     }
 
     release_object( pipe );
@@ -1011,11 +1011,11 @@ DECL_HANDLER(create_named_pipe)
 
 DECL_HANDLER(get_named_pipe_info)
 {
-    struct pipe_server *server;
+    struct pipe_instance *inst;
     struct pipe_end *client = NULL;
 
-    server = get_pipe_server_obj( current->process, req->handle, FILE_READ_ATTRIBUTES );
-    if (!server)
+    inst = get_pipe_instance_obj( current->process, req->handle, FILE_READ_ATTRIBUTES );
+    if (!inst)
     {
         if (get_error() != STATUS_OBJECT_TYPE_MISMATCH)
             return;
@@ -1024,21 +1024,21 @@ DECL_HANDLER(get_named_pipe_info)
         client = (struct pipe_end *)get_handle_obj( current->process, req->handle,
                                                        0, &pipe_end_ops );
         if (!client) return;
-        server = client->server;
+        inst = client->inst;
     }
 
-    reply->flags        = server->pipe->flags;
-    reply->sharing      = server->pipe->sharing;
-    reply->maxinstances = server->pipe->maxinstances;
-    reply->instances    = server->pipe->instances;
-    reply->insize       = server->pipe->insize;
-    reply->outsize      = server->pipe->outsize;
+    reply->flags        = inst->pipe->flags;
+    reply->sharing      = inst->pipe->sharing;
+    reply->maxinstances = inst->pipe->maxinstances;
+    reply->instances    = inst->pipe->numinstances;
+    reply->insize       = inst->pipe->insize;
+    reply->outsize      = inst->pipe->outsize;
 
     if (client)
         release_object(client);
     else
     {
         reply->flags |= NAMED_PIPE_SERVER_END;
-        release_object(server);
+        release_object( inst );
     }
 }
-- 
1.7.1

