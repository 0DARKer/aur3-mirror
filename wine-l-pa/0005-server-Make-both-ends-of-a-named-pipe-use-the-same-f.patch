From f34c7817bc58ef7d4e08cc077421dcc4d97d795c Mon Sep 17 00:00:00 2001
From: Adam Martinson <adam.r.martinson@gmail.com>
Date: Wed, 2 Jan 2013 17:57:11 -0600
Subject: [PATCH 05/10] server: Use the same fd ops for both ends of a named pipe.
Reply-To: wine-devel <wine-devel@winehq.org>
To: wine-patches <wine-patches@winehq.org>

Makes either end of a named pipe is readable after the other has been closed.
(If the pipe has not been disconnected)
---
 server/named_pipe.c |  236 ++++++++++++++++++++++++++++++++-------------------
 1 files changed, 147 insertions(+), 89 deletions(-)

diff --git a/server/named_pipe.c b/server/named_pipe.c
index 47e37e4..9e5d158 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -138,7 +138,6 @@ static const struct object_ops named_pipe_ops =
 static void pipe_instance_dump( struct object *obj, int verbose );
 static struct fd *pipe_instance_get_fd( struct object *obj );
 static void pipe_instance_destroy( struct object *obj);
-static void pipe_instance_flush( struct fd *fd, struct event **event );
 static enum server_fd_type pipe_instance_get_fd_type( struct fd *fd );
 static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async,
                                        int blocking, const void *data, data_size_t size );
@@ -167,7 +166,7 @@ static const struct fd_ops pipe_instance_fd_ops =
 {
     default_fd_get_poll_events,   /* get_poll_events */
     default_poll_event,           /* poll_event */
-    pipe_instance_flush,          /* flush */
+    no_flush,                     /* flush */
     pipe_instance_get_fd_type,    /* get_fd_type */
     pipe_instance_ioctl,          /* ioctl */
     default_fd_queue_async,       /* queue_async */
@@ -182,6 +181,8 @@ static struct fd *pipe_end_get_fd( struct object *obj );
 static void pipe_end_destroy( struct object *obj );
 static void pipe_end_flush( struct fd *fd, struct event **event );
 static enum server_fd_type pipe_end_get_fd_type( struct fd *fd );
+static obj_handle_t pipe_end_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async,
+                                    int blocking, const void *data, data_size_t size );
 
 static const struct object_ops pipe_end_ops =
 {
@@ -209,7 +210,7 @@ static const struct fd_ops pipe_end_fd_ops =
     default_poll_event,           /* poll_event */
     pipe_end_flush,               /* flush */
     pipe_end_get_fd_type,         /* get_fd_type */
-    default_fd_ioctl,             /* ioctl */
+    pipe_end_ioctl,               /* ioctl */
     default_fd_queue_async,       /* queue_async */
     default_fd_reselect_async,    /* reselect_async */
     default_fd_cancel_async       /* cancel_async */
@@ -325,6 +326,8 @@ static struct fd *pipe_end_get_fd( struct object *obj )
     struct pipe_end *end = (struct pipe_end *) obj;
     if (end->fd)
         return (struct fd *) grab_object( end->fd );
+    else if ((end->flags & NAMED_PIPE_SERVER_END) && end->inst)
+        return (struct fd *) grab_object( end->inst->ioctl_fd );
     set_error( STATUS_PIPE_DISCONNECTED );
     return NULL;
 }
@@ -336,20 +339,31 @@ static void set_instance_state( struct pipe_instance *inst, enum pipe_state stat
     switch(state)
     {
     case ps_connected:
-    case ps_disconnected_client:
         assert( inst->server );
         assert( inst->server->fd );
+        assert( inst->client );
+        assert( inst->client->fd );
         break;
     case ps_wait_open:
     case ps_idle_server:
         assert( inst->server );
         assert( !inst->server->fd );
+        assert( !inst->client );
         set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_LISTENING );
         break;
+    case ps_disconnected_client:
+        assert( !inst->server );
+        assert( inst->client );
+        break;
     case ps_disconnected_server:
+        assert( inst->server );
+        assert( !inst->client );
+        set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_DISCONNECTED );
+        break;
     case ps_wait_connect:
         assert( inst->server );
         assert( !inst->server->fd );
+        assert( !inst->client );
         set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_DISCONNECTED );
         break;
     }
@@ -359,8 +373,7 @@ static struct fd *pipe_instance_get_fd( struct object *obj )
 {
     struct pipe_instance *inst = (struct pipe_instance *) obj;
 
-    assert( inst->server );
-    return (struct fd *)grab_object( inst->server->fd ? inst->server->fd : inst->ioctl_fd );
+    return (struct fd *)grab_object( inst->ioctl_fd );
 }
 
 
@@ -377,7 +390,6 @@ static void notify_empty( struct pipe_end *end )
     end->event_empty = NULL;
 }
 
-
 static void do_disconnect_end( struct pipe_end *end, int is_shutdown )
 {
     assert( end->fd );
@@ -409,28 +421,15 @@ static void pipe_instance_destroy( struct object *obj )
     struct pipe_instance *inst = (struct pipe_instance *)obj;
 
     assert( obj->ops == &pipe_instance_ops );
-    assert( inst->server );
-
-    if (inst->server->fd)
-    {
-        notify_empty( inst->server );
-        do_disconnect( inst );
-    }
-
-    if (inst->client)
-    {
-        inst->client->inst = NULL;
-        inst->client = NULL;
-    }
 
+    assert( !inst->server );
+    assert( !inst->client );
     assert( inst->pipe->numinstances );
     inst->pipe->numinstances--;
 
     if (inst->ioctl_fd) release_object( inst->ioctl_fd );
     list_remove( &inst->entry );
     release_object( inst->pipe );
-    inst->server->inst = NULL;
-    release_object( inst->server );
 }
 
 static void pipe_end_destroy( struct object *obj )
@@ -439,32 +438,41 @@ static void pipe_end_destroy( struct object *obj )
     struct pipe_instance *inst = end->inst;
 
     assert( obj->ops == &pipe_end_ops );
-    assert( !end->event_empty );
+    if (end->event_empty)
+        notify_empty( end );
 
     if (inst)
     {
-        notify_empty( inst->server );
+        if (is_server_end( end ))
+        {
+            if (!inst->client)
+                assert( inst->obj.refcount == 1 );
+            inst->server = NULL;
+        }
+        else
+        {
+           if (!inst->server)
+                assert( inst->obj.refcount == 1 );
+            inst->client = NULL;
+        }
 
         switch(inst->state)
         {
         case ps_connected:
-            /* Don't destroy the instances's fd here as we can't
-               do a successful flush without it. */
-            set_instance_state( inst, ps_disconnected_client );
+            if (end->flags & NAMED_PIPE_SERVER_END)
+                set_instance_state( inst, ps_disconnected_client );
+            else
+                set_instance_state( inst, ps_disconnected_server );
             break;
         case ps_disconnected_server:
-            set_instance_state( inst, ps_wait_connect );
-            break;
+        case ps_disconnected_client:
         case ps_idle_server:
         case ps_wait_open:
-        case ps_disconnected_client:
         case ps_wait_connect:
-            assert( 0 );
             break;
         }
-        assert( inst->client );
-        inst->client = NULL;
-        end->inst = NULL;
+
+        release_object( inst );
     }
     if (end->fd) release_object( end->fd );
 }
@@ -545,9 +553,8 @@ static int pipe_data_remaining( struct pipe_end *end )
     struct pollfd pfd;
     int fd;
 
-    assert( end->inst->client );
-
-    fd = get_unix_fd( end->inst->client->fd );
+    assert( end->fd );
+    fd = get_unix_fd( end->fd );
     if (fd < 0)
         return 0;
     pfd.fd = fd;
@@ -571,7 +578,7 @@ static void check_flushed( void *arg )
     }
     else
     {
-        /* notify_empty( server ); */
+        notify_empty( end );
         end->flush_poll = NULL;
         set_event( end->event_empty );
         release_object( end->event_empty );
@@ -579,12 +586,16 @@ static void check_flushed( void *arg )
     }
 }
 
-static void pipe_instance_flush( struct fd *fd, struct event **event )
+static void pipe_end_flush( struct fd *fd, struct event **event )
 {
-    struct pipe_instance *inst = get_fd_user( fd );
-    struct pipe_end *other_end = inst->server;
+    struct pipe_end *other_end, *end = get_fd_user( fd );
+
+    if (!end) return;
+    assert( end->inst );
+    if (end->inst->state != ps_connected) return;
 
-    if (!other_end || !inst || inst->state != ps_connected) return;
+    other_end = is_server_end( end )? end->inst->client : end->inst->server;
+    assert( other_end );
 
     /* FIXME: if multiple threads flush the same pipe,
               maybe should create a list of processes to notify */
@@ -601,11 +612,6 @@ static void pipe_instance_flush( struct fd *fd, struct event **event )
     }
 }
 
-static void pipe_end_flush( struct fd *fd, struct event **event )
-{
-    /* FIXME: what do we have to do for this? */
-}
-
 static inline int is_overlapped( unsigned int options )
 {
     return !(options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT));
@@ -648,6 +654,7 @@ static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const
         {
         case ps_idle_server:
         case ps_wait_connect:
+        case ps_disconnected_server:
             if (blocking)
             {
                 async_data_t new_data = *async_data;
@@ -672,10 +679,7 @@ static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const
             }
             break;
         case ps_connected:
-            set_error( STATUS_PIPE_CONNECTED );
-            break;
-        case ps_disconnected_server:
-            set_error( STATUS_PIPE_BUSY );
+            assert( 0 );
             break;
         case ps_disconnected_client:
             set_error( STATUS_NO_DATA_DETECTED );
@@ -690,32 +694,86 @@ static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const
         switch(inst->state)
         {
         case ps_connected:
-            assert( inst->client );
-            assert( inst->client->fd );
+            assert( 0 );
+            break;
+        case ps_idle_server:
+        case ps_wait_open:
+            set_error( STATUS_PIPE_LISTENING );
+            break;
+        case ps_wait_connect:
+        case ps_disconnected_server:
+        case ps_disconnected_client:
+            set_error( STATUS_PIPE_DISCONNECTED );
+            break;
+        }
+        return 0;
+
+    default:
+        return default_fd_ioctl( fd, code, async_data, blocking, data, size );
+    }
+}
+
+static obj_handle_t pipe_end_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *async_data,
+                                    int blocking, const void *data, data_size_t size )
+{
+    struct pipe_end *end = get_fd_user( fd );
 
-            notify_empty( inst->server );
+    assert( end->inst );
 
-            /* dump the client and server fds, but keep the pointers
-               around - client loses all waiting data */
-            do_disconnect( inst );
-            set_instance_state( inst, ps_disconnected_server );
+    switch(code)
+    {
+    case FSCTL_PIPE_DISCONNECT:
+        switch(end->inst->state)
+        {
+        case ps_connected:
+            assert( end->inst->server );
+            assert( end->inst->server->fd );
+            assert( end->inst->client );
+            assert( end->inst->client->fd );
+
+            notify_empty( end->inst->server );
+            notify_empty( end->inst->client );
+
+            /* all waiting data lost */
+            do_disconnect( end->inst );
+            if (is_server_end( end ))
+            {
+                end->inst->client->inst = NULL;
+                end->inst->client = NULL;
+                set_instance_state( end->inst, ps_disconnected_server );
+                release_object( end->inst );
+            }
+            else
+            {
+                /* FIXME: is this allowed?? */
+                struct pipe_instance *inst = end->inst;
+                end->inst->client = NULL;
+                end->inst = NULL;
+                set_instance_state( inst, ps_disconnected_server );
+                release_object( inst );
+            }
+            break;
+        case ps_disconnected_server:
+            assert( !end->inst->client );
+            do_disconnect( end->inst );
             break;
         case ps_disconnected_client:
-            assert( !inst->client );
-            do_disconnect( inst );
-            set_instance_state( inst, ps_wait_connect );
+            /* FIXME: is this allowed?? */
+            assert( !end->inst->server );
+            do_disconnect( end->inst );
             break;
         case ps_idle_server:
         case ps_wait_open:
-            set_error( STATUS_PIPE_LISTENING );
-            break;
-        case ps_disconnected_server:
         case ps_wait_connect:
-            set_error( STATUS_PIPE_DISCONNECTED );
+            assert( 0 );
             break;
         }
         return 0;
 
+    case FSCTL_PIPE_LISTEN:
+        set_error( STATUS_PIPE_CONNECTED );
+        return 0;
+
     default:
         return default_fd_ioctl( fd, code, async_data, blocking, data, size );
     }
@@ -764,12 +822,17 @@ static struct named_pipe *create_named_pipe( struct directory *root, const struc
     return pipe;
 }
 
-static struct pipe_instance *get_pipe_instance_obj( struct process *process,
+static struct pipe_end *get_pipe_end_obj( struct process *process,
                                 obj_handle_t handle, unsigned int access )
 {
-    struct object *obj;
-    obj = get_handle_obj( process, handle, access, &pipe_instance_ops );
-    return (struct pipe_instance *) obj;
+    struct pipe_end *end;
+    end = (struct pipe_end *)get_handle_obj( process, handle, 0, &pipe_end_ops );
+    if (end && is_server_end( end ))
+    {
+        release_object( end );
+        end = (struct pipe_end *)get_handle_obj( process, handle, access, &pipe_end_ops );
+    }
+    return end;
 }
 
 static struct pipe_end *create_pipe_end( struct pipe_instance *inst, unsigned int options, unsigned int flags )
@@ -792,6 +855,8 @@ static struct pipe_end *create_pipe_end( struct pipe_instance *inst, unsigned in
     else
         inst->client = end;
 
+    grab_object( inst );
+
     return end;
 }
 
@@ -876,6 +941,8 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
     {
         if (!socketpair( PF_UNIX, SOCK_STREAM, 0, fds ))
         {
+            assert( !inst->server->fd );
+
             /* for performance reasons, only set nonblocking mode when using
              * overlapped I/O. Otherwise, we will be doing too much busy
              * looping */
@@ -894,8 +961,8 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             }
 
             client->fd = create_anonymous_fd( &pipe_end_fd_ops, fds[1], &client->obj, options );
-            inst->server->fd = create_anonymous_fd( &pipe_instance_fd_ops, fds[0],
-                                                    &inst->obj, inst->server->options );
+            inst->server->fd = create_anonymous_fd( &pipe_end_fd_ops, fds[0],
+                                                    &inst->server->obj, inst->server->options );
 
             if (client->fd && inst->server->fd)
             {
@@ -1047,7 +1114,8 @@ DECL_HANDLER(create_named_pipe)
     inst = create_pipe_instance( pipe, req->options, req->flags );
     if (inst)
     {
-        reply->handle = alloc_handle( current->process, inst, req->access, req->attributes );
+        reply->handle = alloc_handle( current->process, inst->server, req->access, req->attributes );
+        release_object( inst->server );
         inst->pipe->numinstances++;
         release_object( inst );
     }
@@ -1057,23 +1125,16 @@ DECL_HANDLER(create_named_pipe)
 
 DECL_HANDLER(get_named_pipe_info)
 {
-    struct pipe_instance *inst;
-    struct pipe_end *end = NULL;
+    struct pipe_end *end;
 
-    inst = get_pipe_instance_obj( current->process, req->handle, FILE_READ_ATTRIBUTES );
-    if (!inst)
+    if ((end = get_pipe_end_obj( current->process, req->handle, FILE_READ_ATTRIBUTES )))
     {
-        if (get_error() != STATUS_OBJECT_TYPE_MISMATCH)
+        if (!end->inst)
+        {
+            set_error( STATUS_PIPE_DISCONNECTED );
+            release_object( end );
             return;
-
-        clear_error();
-        end = (struct pipe_end *)get_handle_obj( current->process, req->handle, 0, &pipe_end_ops );
-    }
-    else
-        end = (struct pipe_end *)grab_object( inst->server );
-
-    if (end)
-    {
+        }
         assert( end->inst->pipe );
         reply->flags        = end->flags;
         reply->sharing      = end->inst->pipe->sharing;
@@ -1084,7 +1145,4 @@ DECL_HANDLER(get_named_pipe_info)
 
         release_object( end );
     }
-
-    if (inst)
-        release_object( inst );
 }
-- 
1.7.1

