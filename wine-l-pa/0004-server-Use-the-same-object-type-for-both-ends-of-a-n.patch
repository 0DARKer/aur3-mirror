From e5b43772870195d4a2cb163e67622fa838f29a90 Mon Sep 17 00:00:00 2001
From: Adam Martinson <adam.r.martinson@gmail.com>
Date: Wed, 2 Jan 2013 17:49:28 -0600
Subject: [PATCH 04/10] server: Use the same object type for both ends of a named pipe.
Reply-To: wine-devel <wine-devel@winehq.org>
To: wine-patches <wine-patches@winehq.org>

---
 server/named_pipe.c |  176 ++++++++++++++++++++++++++++++++-------------------
 1 files changed, 111 insertions(+), 65 deletions(-)

diff --git a/server/named_pipe.c b/server/named_pipe.c
index 6bc4572..47e37e4 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -3,6 +3,7 @@
  *
  * Copyright (C) 1998 Alexandre Julliard
  * Copyright (C) 2001 Mike McCormack
+ * Copyright (C) 2012-2013 Adam Martinson
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -68,15 +69,12 @@ struct named_pipe;
 struct pipe_instance
 {
     struct object        obj;        /* object header */
-    struct fd           *fd;         /* pipe file descriptor */
     struct fd           *ioctl_fd;   /* file descriptor for ioctls when not connected */
     struct list          entry;      /* entry in named pipe instances list */
     enum pipe_state      state;      /* instance state */
+    struct pipe_end     *server;     /* server that this instance is connected to */
     struct pipe_end     *client;     /* client that this instance is connected to */
     struct named_pipe   *pipe;
-    struct timeout_user *flush_poll;
-    struct event        *event_empty;
-    unsigned int         options;    /* pipe options */
 };
 
 struct pipe_end
@@ -84,13 +82,15 @@ struct pipe_end
     struct object            obj;        /* object header */
     struct fd               *fd;         /* pipe file descriptor */
     struct pipe_instance    *inst;       /* instance that this end is connected to */
+    unsigned int             options;    /* pipe options */
     unsigned int             flags;      /* pipe flags */
+    struct timeout_user     *flush_poll;
+    struct event            *event_empty;
 };
 
 struct named_pipe
 {
     struct object       obj;         /* object header */
-    unsigned int        flags;
     unsigned int        sharing;
     unsigned int        maxinstances;
     unsigned int        outsize;
@@ -259,6 +259,19 @@ static const struct fd_ops named_pipe_device_fd_ops =
     default_fd_cancel_async           /* cancel_async */
 };
 
+static inline int is_server_end( struct pipe_end *end )
+{
+    int res = (end->flags & NAMED_PIPE_SERVER_END)? 1 : 0;
+    if (end->inst)
+    {
+        if (res)
+            assert( end->inst->server == end );
+        else
+            assert( end->inst->client == end );
+    }
+    return res;
+}
+
 static void named_pipe_dump( struct object *obj, int verbose )
 {
     struct named_pipe *pipe = (struct named_pipe *) obj;
@@ -324,16 +337,19 @@ static void set_instance_state( struct pipe_instance *inst, enum pipe_state stat
     {
     case ps_connected:
     case ps_disconnected_client:
-        assert( inst->fd );
+        assert( inst->server );
+        assert( inst->server->fd );
         break;
     case ps_wait_open:
     case ps_idle_server:
-        assert( !inst->fd );
+        assert( inst->server );
+        assert( !inst->server->fd );
         set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_LISTENING );
         break;
     case ps_disconnected_server:
     case ps_wait_connect:
-        assert( !inst->fd );
+        assert( inst->server );
+        assert( !inst->server->fd );
         set_no_fd_status( inst->ioctl_fd, STATUS_PIPE_DISCONNECTED );
         break;
     }
@@ -343,15 +359,16 @@ static struct fd *pipe_instance_get_fd( struct object *obj )
 {
     struct pipe_instance *inst = (struct pipe_instance *) obj;
 
-    return (struct fd *)grab_object( inst->fd ? inst->fd : inst->ioctl_fd );
+    assert( inst->server );
+    return (struct fd *)grab_object( inst->server->fd ? inst->server->fd : inst->ioctl_fd );
 }
 
 
-static void notify_empty( struct pipe_instance *end )
+static void notify_empty( struct pipe_end *end )
 {
     if (!end->flush_poll)
         return;
-    assert( end->state == ps_connected );
+    assert( end->inst && end->inst->state == ps_connected );
     assert( end->event_empty );
     remove_timeout_user( end->flush_poll );
     end->flush_poll = NULL;
@@ -360,20 +377,31 @@ static void notify_empty( struct pipe_instance *end )
     end->event_empty = NULL;
 }
 
+
+static void do_disconnect_end( struct pipe_end *end, int is_shutdown )
+{
+    assert( end->fd );
+
+    if (!is_shutdown)
+        shutdown( get_unix_fd( end->fd ), SHUT_RDWR );
+    release_object( end->fd );
+    end->fd = NULL;
+}
+
 static void do_disconnect( struct pipe_instance *inst )
 {
-    /* we may only have a server fd, if the client disconnected */
+    int is_shutdown = 0;
+    /* we may only have 1 end */
+    if (inst->server)
+    {
+        do_disconnect_end( inst->server, 0 );
+        is_shutdown = 1;
+    }
+
     if (inst->client)
     {
-        assert( inst->client->inst == inst );
-        assert( inst->client->fd );
-        release_object( inst->client->fd );
-        inst->client->fd = NULL;
+        do_disconnect_end( inst->client, is_shutdown );
     }
-    assert( inst->fd );
-    shutdown( get_unix_fd( inst->fd ), SHUT_RDWR );
-    release_object( inst->fd );
-    inst->fd = NULL;
 }
 
 static void pipe_instance_destroy( struct object *obj )
@@ -381,10 +409,11 @@ static void pipe_instance_destroy( struct object *obj )
     struct pipe_instance *inst = (struct pipe_instance *)obj;
 
     assert( obj->ops == &pipe_instance_ops );
+    assert( inst->server );
 
-    if (inst->fd)
+    if (inst->server->fd)
     {
-        notify_empty( inst );
+        notify_empty( inst->server );
         do_disconnect( inst );
     }
 
@@ -400,6 +429,8 @@ static void pipe_instance_destroy( struct object *obj )
     if (inst->ioctl_fd) release_object( inst->ioctl_fd );
     list_remove( &inst->entry );
     release_object( inst->pipe );
+    inst->server->inst = NULL;
+    release_object( inst->server );
 }
 
 static void pipe_end_destroy( struct object *obj )
@@ -408,10 +439,11 @@ static void pipe_end_destroy( struct object *obj )
     struct pipe_instance *inst = end->inst;
 
     assert( obj->ops == &pipe_end_ops );
+    assert( !end->event_empty );
 
     if (inst)
     {
-        notify_empty( inst );
+        notify_empty( inst->server );
 
         switch(inst->state)
         {
@@ -508,14 +540,14 @@ void create_named_pipe_device( struct directory *root, const struct unicode_str
     if (dev) make_object_static( &dev->obj );
 }
 
-static int pipe_data_remaining( struct pipe_instance *inst )
+static int pipe_data_remaining( struct pipe_end *end )
 {
     struct pollfd pfd;
     int fd;
 
-    assert( inst->client );
+    assert( end->inst->client );
 
-    fd = get_unix_fd( inst->client->fd );
+    fd = get_unix_fd( end->inst->client->fd );
     if (fd < 0)
         return 0;
     pfd.fd = fd;
@@ -530,7 +562,7 @@ static int pipe_data_remaining( struct pipe_instance *inst )
 
 static void check_flushed( void *arg )
 {
-    struct pipe_instance *end = (struct pipe_instance*) arg;
+    struct pipe_end *end = (struct pipe_end*) arg;
 
     assert( end->event_empty );
     if (pipe_data_remaining( end ))
@@ -549,9 +581,10 @@ static void check_flushed( void *arg )
 
 static void pipe_instance_flush( struct fd *fd, struct event **event )
 {
-    struct pipe_instance *other_end = get_fd_user( fd );
+    struct pipe_instance *inst = get_fd_user( fd );
+    struct pipe_end *other_end = inst->server;
 
-    if (!other_end || other_end->state != ps_connected) return;
+    if (!other_end || !inst || inst->state != ps_connected) return;
 
     /* FIXME: if multiple threads flush the same pipe,
               maybe should create a list of processes to notify */
@@ -630,6 +663,7 @@ static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const
 
             if (async)
             {
+                assert( inst->pipe );
                 set_instance_state( inst, ps_wait_open );
                 if (inst->pipe->waiters) async_wake_up( inst->pipe->waiters, STATUS_SUCCESS );
                 release_object( async );
@@ -659,7 +693,7 @@ static obj_handle_t pipe_instance_ioctl( struct fd *fd, ioctl_code_t code, const
             assert( inst->client );
             assert( inst->client->fd );
 
-            notify_empty( inst );
+            notify_empty( inst->server );
 
             /* dump the client and server fds, but keep the pointers
                around - client loses all waiting data */
@@ -738,7 +772,7 @@ static struct pipe_instance *get_pipe_instance_obj( struct process *process,
     return (struct pipe_instance *) obj;
 }
 
-static struct pipe_end *create_pipe_end( unsigned int flags )
+static struct pipe_end *create_pipe_end( struct pipe_instance *inst, unsigned int options, unsigned int flags )
 {
     struct pipe_end *end;
 
@@ -747,13 +781,21 @@ static struct pipe_end *create_pipe_end( unsigned int flags )
         return NULL;
 
     end->fd = NULL;
-    end->inst = NULL;
+    end->inst = inst;
+    end->options = options;
+    end->flush_poll = NULL;
+    end->event_empty = NULL;
     end->flags = flags;
 
+    if (flags & NAMED_PIPE_SERVER_END)
+        inst->server = end;
+    else
+        inst->client = end;
+
     return end;
 }
 
-static struct pipe_instance *create_pipe_instance( struct named_pipe *pipe, unsigned int options )
+static struct pipe_instance *create_pipe_instance( struct named_pipe *pipe, unsigned int options, unsigned int flags )
 {
     struct pipe_instance *inst;
 
@@ -761,11 +803,14 @@ static struct pipe_instance *create_pipe_instance( struct named_pipe *pipe, unsi
     if (!inst)
         return NULL;
 
-    inst->fd = NULL;
     inst->pipe = pipe;
     inst->client = NULL;
-    inst->flush_poll = NULL;
-    inst->options = options;
+    inst->server = create_pipe_end( inst, options, flags | NAMED_PIPE_SERVER_END );
+    if (!inst->server)
+    {
+        release_object( inst );
+        return NULL;
+    }
 
     list_add_head( &pipe->instances, &inst->entry );
     grab_object( pipe );
@@ -814,6 +859,10 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
         return NULL;
     }
 
+    assert( inst->server );
+    assert( !inst->server->fd );
+    assert( !inst->client );
+
     pipe_sharing = inst->pipe->sharing;
     if (((access & GENERIC_READ) && !(pipe_sharing & FILE_SHARE_READ)) ||
         ((access & GENERIC_WRITE) && !(pipe_sharing & FILE_SHARE_WRITE)))
@@ -823,17 +872,15 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
         return NULL;
     }
 
-    if ((client = create_pipe_end( options )))
+    if ((client = create_pipe_end( inst, options, inst->server->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE )))
     {
         if (!socketpair( PF_UNIX, SOCK_STREAM, 0, fds ))
         {
-            assert( !inst->fd );
-
             /* for performance reasons, only set nonblocking mode when using
              * overlapped I/O. Otherwise, we will be doing too much busy
              * looping */
             if (is_overlapped( options )) fcntl( fds[1], F_SETFL, O_NONBLOCK );
-            if (is_overlapped( inst->options )) fcntl( fds[0], F_SETFL, O_NONBLOCK );
+            if (is_overlapped( inst->server->options )) fcntl( fds[0], F_SETFL, O_NONBLOCK );
 
             if (pipe->insize)
             {
@@ -847,17 +894,17 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             }
 
             client->fd = create_anonymous_fd( &pipe_end_fd_ops, fds[1], &client->obj, options );
-            inst->fd = create_anonymous_fd( &pipe_instance_fd_ops, fds[0], &inst->obj, inst->options );
-            if (client->fd && inst->fd)
+            inst->server->fd = create_anonymous_fd( &pipe_instance_fd_ops, fds[0],
+                                                    &inst->obj, inst->server->options );
+
+            if (client->fd && inst->server->fd)
             {
                 allow_fd_caching( client->fd );
-                allow_fd_caching( inst->fd );
-                fd_copy_completion( inst->ioctl_fd, inst->fd );
+                allow_fd_caching( inst->server->fd );
+                fd_copy_completion( inst->ioctl_fd, inst->server->fd );
                 if (inst->state == ps_wait_open)
                     fd_async_wake_up( inst->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
                 set_instance_state( inst, ps_connected );
-                inst->client = client;
-                client->inst = inst;
             }
             else
             {
@@ -978,7 +1025,6 @@ DECL_HANDLER(create_named_pipe)
         pipe->outsize = req->outsize;
         pipe->maxinstances = req->maxinstances;
         pipe->timeout = req->timeout;
-        pipe->flags = req->flags;
         pipe->sharing = req->sharing;
     }
     else
@@ -998,7 +1044,7 @@ DECL_HANDLER(create_named_pipe)
         clear_error(); /* clear the name collision */
     }
 
-    inst = create_pipe_instance( pipe, req->options );
+    inst = create_pipe_instance( pipe, req->options, req->flags );
     if (inst)
     {
         reply->handle = alloc_handle( current->process, inst, req->access, req->attributes );
@@ -1012,7 +1058,7 @@ DECL_HANDLER(create_named_pipe)
 DECL_HANDLER(get_named_pipe_info)
 {
     struct pipe_instance *inst;
-    struct pipe_end *client = NULL;
+    struct pipe_end *end = NULL;
 
     inst = get_pipe_instance_obj( current->process, req->handle, FILE_READ_ATTRIBUTES );
     if (!inst)
@@ -1021,24 +1067,24 @@ DECL_HANDLER(get_named_pipe_info)
             return;
 
         clear_error();
-        client = (struct pipe_end *)get_handle_obj( current->process, req->handle,
-                                                       0, &pipe_end_ops );
-        if (!client) return;
-        inst = client->inst;
+        end = (struct pipe_end *)get_handle_obj( current->process, req->handle, 0, &pipe_end_ops );
     }
-
-    reply->flags        = inst->pipe->flags;
-    reply->sharing      = inst->pipe->sharing;
-    reply->maxinstances = inst->pipe->maxinstances;
-    reply->instances    = inst->pipe->numinstances;
-    reply->insize       = inst->pipe->insize;
-    reply->outsize      = inst->pipe->outsize;
-
-    if (client)
-        release_object(client);
     else
+        end = (struct pipe_end *)grab_object( inst->server );
+
+    if (end)
     {
-        reply->flags |= NAMED_PIPE_SERVER_END;
-        release_object( inst );
+        assert( end->inst->pipe );
+        reply->flags        = end->flags;
+        reply->sharing      = end->inst->pipe->sharing;
+        reply->maxinstances = end->inst->pipe->maxinstances;
+        reply->instances    = end->inst->pipe->numinstances;
+        reply->insize       = end->inst->pipe->insize;
+        reply->outsize      = end->inst->pipe->outsize;
+
+        release_object( end );
     }
+
+    if (inst)
+        release_object( inst );
 }
-- 
1.7.1

