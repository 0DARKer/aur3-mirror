diff -ru odb-2.3.0-orig/odb/gcc-fwd.hxx odb-2.3.0/odb/gcc-fwd.hxx
--- odb-2.3.0-orig/odb/gcc-fwd.hxx	2013-02-09 00:14:57.000000000 -0800
+++ odb-2.3.0/odb/gcc-fwd.hxx	2014-05-06 17:22:47.904116483 -0700
@@ -5,8 +5,26 @@
 #ifndef ODB_GCC_FWD_HXX
 #define ODB_GCC_FWD_HXX
 
+#include <bversion.h>
+
+#if BUILDING_GCC_MAJOR > 4 || BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR > 8
+#  include <limits.h> // CHAR_BIT
+#  include <config.h>
+#endif
+
 extern "C"
 {
+// The hwint.h header uses gcc_checking_assert macro from system.h. But
+// if we include system.h here, it pulls in all kinds of GCC trouble that
+// "poisons" standard C/C++ declarations (see safe-ctype.h for an example).
+// Instead we are just going to provide the no-op definition of this macro.
+//
+#if BUILDING_GCC_MAJOR > 4 || BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR > 8
+#  define gcc_checking_assert(expr) ((void)(0 & (expr)))
+#  include <hwint.h>
+#  undef gcc_checking_assert
+#endif
+
 #include <coretypes.h>
 
 typedef unsigned int source_location; // <line-map.h>
diff -ru odb-2.3.0-orig/odb/gcc.hxx odb-2.3.0/odb/gcc.hxx
--- odb-2.3.0-orig/odb/gcc.hxx	2013-10-01 23:35:41.000000000 -0700
+++ odb-2.3.0/odb/gcc.hxx	2014-05-06 17:22:47.904116483 -0700
@@ -16,8 +16,6 @@
 
 #include <cstdlib> // Include before GCC poisons some declarations.
 
-#include <bversion.h>
-
 // GCC 4.7 can be built using either C or C++ compiler. From 4.8 it
 // is always built as C++.
 //
@@ -56,6 +54,10 @@
 #  include <c-pragma.h>
 #endif
 
+#if BUILDING_GCC_MAJOR > 4 || BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR > 8
+#  include <stringpool.h> // get_identifier
+#endif
+
 #include <diagnostic.h>
 #include <output.h>
 
@@ -63,6 +65,22 @@
 } // extern "C"
 #endif
 
+// In 4.9.0 the tree code type was changed from int to enum tree_code.
+// the tree_code_name array is also gone with the get_tree_code_name()
+// function in its place.
+//
+#if BUILDING_GCC_MAJOR > 4 || BUILDING_GCC_MAJOR == 4 && BUILDING_GCC_MINOR > 8
+typedef enum tree_code gcc_tree_code_type;
+
+inline const char*
+gcc_tree_code_name (gcc_tree_code_type tc) {return get_tree_code_name (tc);}
+#else
+typedef int gcc_tree_code_type;
+
+inline const char*
+gcc_tree_code_name (gcc_tree_code_type tc) {return tree_code_name[tc];}
+#endif
+
 // Only since GCC 4.7.0.
 //
 #ifndef LOCATION_COLUMN
diff -ru odb-2.3.0-orig/odb/parser.cxx odb-2.3.0/odb/parser.cxx
--- odb-2.3.0-orig/odb/parser.cxx	2013-10-14 22:01:32.000000000 -0700
+++ odb-2.3.0/odb/parser.cxx	2014-05-06 17:22:47.904116483 -0700
@@ -1028,7 +1028,7 @@
 emit_type_decl (tree decl)
 {
   tree t (TREE_TYPE (decl));
-  int tc (TREE_CODE (t));
+  gcc_tree_code_type tc (TREE_CODE (t));
 
   tree decl_name (DECL_NAME (decl));
   char const* name (IDENTIFIER_POINTER (decl_name));
@@ -1086,7 +1086,7 @@
     {
 
       if (trace)
-        ts << "start " <<  tree_code_name[tc] << " " << name
+        ts << "start " <<  gcc_tree_code_name(tc) << " " << name
            << " at " << file << ":" << line << endl;
 
       switch (tc)
@@ -1106,10 +1106,12 @@
           node = &emit_enum (t, decl_access (decl), file, line, clmn);
           break;
         }
+      default:
+        break;
       }
 
       if (trace)
-        ts << "end " <<  tree_code_name[tc] << " " << name
+        ts << "end " <<  gcc_tree_code_name(tc) << " " << name
            << " (" << node << ") at "
            << DECL_SOURCE_FILE (decl) << ":"
            << DECL_SOURCE_LINE (decl) << endl;
@@ -1176,11 +1178,11 @@
   // Currently we only handle class/union templates.
   //
   tree t (TREE_TYPE (DECL_TEMPLATE_RESULT (decl)));
-  int tc (TREE_CODE (t));
+  gcc_tree_code_type tc (TREE_CODE (t));
 
   if (trace)
   {
-    ts << tree_code_name[tc] << " template (" << decl << ") "
+    ts << gcc_tree_code_name(tc) << " template (" << decl << ") "
        << IDENTIFIER_POINTER (DECL_NAME (decl)) << " (" << t << ") at "
        << DECL_SOURCE_FILE (decl) << ":"
        << DECL_SOURCE_LINE (decl) << endl;
@@ -1215,7 +1217,7 @@
   char const* name (IDENTIFIER_POINTER (DECL_NAME (decl)));
 
   if (trace)
-    ts << "start " <<  tree_code_name[tc] << " template " << name << " at "
+    ts << "start " <<  gcc_tree_code_name(tc) << " template " << name << " at "
        << DECL_SOURCE_FILE (decl) << ":"
        << DECL_SOURCE_LINE (decl) << endl;
 
@@ -1232,7 +1234,7 @@
     unit_->new_edge<declares> (*scope_, *t_node, name);
 
   if (trace)
-    ts << "end " <<  tree_code_name[tc] << " template " << name
+    ts << "end " <<  gcc_tree_code_name(tc) << " template " << name
        << " (" << t_node << ") at "
        << DECL_SOURCE_FILE (decl) << ":"
        << DECL_SOURCE_LINE (decl) << endl;
@@ -1510,7 +1512,7 @@
 
   if (trace)
   {
-    ts << tree_code_name[TREE_CODE (t)] << " " << t
+    ts << gcc_tree_code_name(TREE_CODE (t)) << " " << t
        << " main " << mv << endl;
 
     for (tree v (TYPE_MAIN_VARIANT (t)); v != 0; v = TYPE_NEXT_VARIANT (v))
@@ -1630,7 +1632,7 @@
              size_t clmn)
 {
   type* r (0);
-  int tc (TREE_CODE (t));
+  gcc_tree_code_type tc (TREE_CODE (t));
 
   switch (tc)
   {
@@ -1671,7 +1673,7 @@
           tree d (TYPE_NAME (t));
 
           if (trace)
-            ts << "start anon/stub " << tree_code_name[tc] << " at "
+            ts << "start anon/stub " << gcc_tree_code_name(tc) << " at "
                << file << ":" << line << endl;
 
           if (d == NULL_TREE || ANON_AGGRNAME_P (DECL_NAME (d)))
@@ -1697,7 +1699,7 @@
           }
 
           if (trace)
-            ts << "end anon/stub " << tree_code_name[tc] << " (" << r << ")"
+            ts << "end anon/stub " << gcc_tree_code_name(tc) << " (" << r << ")"
                << " at " << file << ":" << line << endl;
         }
       }
@@ -1722,7 +1724,7 @@
         else
         {
           if (trace)
-            ts << "start stub " << tree_code_name[tc] << " template for ("
+            ts << "start stub " << gcc_tree_code_name(tc) << " template for ("
                << decl << ") at " << file << ":" << line << endl;
 
           if (tc == RECORD_TYPE)
@@ -1731,12 +1733,12 @@
             t_node = &emit_union_template (decl, true);
 
           if (trace)
-            ts << "end stub " << tree_code_name[tc] << " template ("
+            ts << "end stub " << gcc_tree_code_name(tc) << " template ("
                << t_node << ") at " << file << ":" << line << endl;
         }
 
         if (trace)
-          ts << "start " << tree_code_name[tc] << " instantiation ("
+          ts << "start " << gcc_tree_code_name(tc) << " instantiation ("
              << t << ") for template (" << t_node << ")"
              << " at " << file << ":" << line << endl;
 
@@ -1748,7 +1750,7 @@
           i_node = &emit_union<union_instantiation> (t, file, line, clmn);
 
         if (trace)
-          ts << "end " << tree_code_name[tc] << " instantiation ("
+          ts << "end " << gcc_tree_code_name(tc) << " instantiation ("
              << static_cast<type*> (i_node) << ")"
              << " at " << file << ":" << line << endl;
 
@@ -1769,7 +1771,7 @@
       tree d (TYPE_NAME (t));
 
       if (trace)
-        ts << "start anon/stub " << tree_code_name[tc] << " at "
+        ts << "start anon/stub " << gcc_tree_code_name(tc) << " at "
            << file << ":" << line << endl;
 
       if (d == NULL_TREE || ANON_AGGRNAME_P (DECL_NAME (d)))
@@ -1789,7 +1791,7 @@
       }
 
       if (trace)
-        ts << "end anon/stub " << tree_code_name[tc] << " (" << r << ")"
+        ts << "end anon/stub " << gcc_tree_code_name(tc) << " (" << r << ")"
            << " at " << file << ":" << line << endl;
 
       break;
@@ -1828,7 +1830,8 @@
         else
         {
           error (file, line, clmn)
-            << "non-integer array index " << tree_code_name[TREE_CODE (max)]
+            << "non-integer array index " <<
+            gcc_tree_code_name(TREE_CODE (max))
             << endl;
 
           throw failed ();
@@ -1915,11 +1918,11 @@
     {
       t = TYPE_MAIN_VARIANT (t);
       r = &unit_->new_node<unsupported_type> (
-        file, line, clmn, t, tree_code_name[tc]);
+        file, line, clmn, t, gcc_tree_code_name(tc));
       unit_->insert (t, *r);
 
       if (trace)
-        ts << "unsupported " << tree_code_name[tc] << " (" << r << ")"
+        ts << "unsupported " << gcc_tree_code_name(tc) << " (" << r << ")"
            << " at " << file << ":" << line << endl;
 
       break;
@@ -1956,7 +1959,7 @@
   if (CP_TYPE_RESTRICT_P (type))
     r += " __restrict";
 
-  int tc (TREE_CODE (type));
+  gcc_tree_code_type tc (TREE_CODE (type));
 
   switch (tc)
   {
@@ -2107,7 +2110,7 @@
     }
   default:
     {
-      r = "<" + string (tree_code_name[tc]) + ">";
+      r = "<" + string (gcc_tree_code_name(tc)) + ">";
       break;
     }
   }
diff -ru odb-2.3.0-orig/odb/pragma.cxx odb-2.3.0/odb/pragma.cxx
--- odb-2.3.0-orig/odb/pragma.cxx	2013-10-01 23:35:41.000000000 -0700
+++ odb-2.3.0/odb/pragma.cxx	2014-05-06 17:22:47.908116483 -0700
@@ -368,7 +368,7 @@
                       string const& p,
                       location_t l)
 {
-  int tc (d.tree_code ());
+  gcc_tree_code_type tc (d.tree_code ());
   bool type (TREE_CODE_CLASS (tc) == tcc_type);
 
   if (p == "no_id")
@@ -2475,7 +2475,7 @@
                       string const& p,
                       location_t l)
 {
-  int tc (d.tree_code ());
+  gcc_tree_code_type tc (d.tree_code ());
   bool type (TREE_CODE_CLASS (tc) == tcc_type);
 
   if (p == "model" ||
diff -ru odb-2.3.0-orig/odb/pragma.hxx odb-2.3.0/odb/pragma.hxx
--- odb-2.3.0-orig/odb/pragma.hxx	2013-02-09 00:14:56.000000000 -0800
+++ odb-2.3.0/odb/pragma.hxx	2014-05-06 17:23:22.096116996 -0700
@@ -20,12 +20,15 @@
 
 struct virt_declaration
 {
-  virt_declaration (location_t l, std::string const& n, int tc, tree t)
+  virt_declaration (location_t l,
+                    std::string const& n,
+                    gcc_tree_code_type tc,
+                    tree t)
       : loc (l), name (n), tree_code (tc), type (t) {}
 
   location_t loc;
   std::string name;
-  int tree_code;
+  gcc_tree_code_type tree_code;
   tree type;      // Declaration's type.
 };
 
@@ -35,7 +38,7 @@
 //
 struct virt_declaration_set
 {
-  typedef cutl::container::key<std::string, int> key;
+  typedef cutl::container::key<std::string, gcc_tree_code_type> key;
   typedef std::map<key, virt_declaration> map;
   typedef cutl::container::map_const_iterator<map> const_iterator;
 
@@ -54,7 +57,7 @@
   }
 
   const_iterator
-  find (std::string const& name, int tree_code) const
+  find (std::string const& name, gcc_tree_code_type tree_code) const
   {
     return map_.find (key (name, tree_code));
   }
@@ -89,7 +92,7 @@
     virt_declaration const* virt;
   } decl;
 
-  int
+  gcc_tree_code_type
   tree_code () const
   {
     return (virt ? decl.virt->tree_code : TREE_CODE (decl.real));
diff -ru odb-2.3.0-orig/odb/processor.cxx odb-2.3.0/odb/processor.cxx
--- odb-2.3.0-orig/odb/processor.cxx	2013-10-21 02:01:09.000000000 -0700
+++ odb-2.3.0/odb/processor.cxx	2014-05-06 17:23:51.772117441 -0700
@@ -180,7 +180,7 @@
 
       // Accessor is a function with no arguments (other than 'this').
       //
-      if (FUNCTION_FIRST_USER_PARM (f) != NULL_TREE)
+      if (FUNCTION_FIRST_USER_PARMTYPE (f) != void_list_node)
         return found_none;
 
       // Note that to get the return type we have to use
@@ -188,7 +188,7 @@
       // suggested in the documentation.
       //
       tree r (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (f))));
-      int tc (TREE_CODE (r));
+      gcc_tree_code_type tc (TREE_CODE (r));
 
       // In the strict mode make sure the function returns for non-array
       // types a value or a (const) reference to the member type and for
@@ -235,7 +235,7 @@
                     member_access& ma,
                     bool strict)
     {
-      tree a (FUNCTION_FIRST_USER_PARM (f));
+      tree a (FUNCTION_FIRST_USER_PARMTYPE (f));
 
       // For a modifier, it can either be a function that returns a non-
       // const reference (or non-const pointer, in case the member is an
@@ -246,14 +246,14 @@
       semantics::type& t (utype (m));
       semantics::array* ar (dynamic_cast<semantics::array*> (&t));
 
-      if (a == NULL_TREE)
+      if (a == void_list_node)
       {
         // Note that to get the return type we have to use
         // TREE_TYPE(TREE_TYPE()) and not DECL_RESULT, as
         // suggested in the documentation.
         //
         tree r (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (f))));
-        int tc (TREE_CODE (r));
+        gcc_tree_code_type tc (TREE_CODE (r));
 
         // By-reference modifier. Should return a reference or a pointer.
         //
@@ -285,7 +285,7 @@
       // Otherwise look for a by value modifier, which is a function
       // with a single argument.
       //
-      else if (DECL_CHAIN (a) == NULL_TREE)
+      else if (DECL_CHAIN (a) == void_list_node)
       {
         // In the lax mode any function with a single argument works
         // for us. And we don't care what it returns.
@@ -296,8 +296,8 @@
           // member. This is exactly the same logic as in accessor
           // with regards to arrays, references, etc.
           //
-          tree at (TREE_TYPE (a));
-          int tc (TREE_CODE (at));
+          tree at (TREE_VALUE (a));
+          gcc_tree_code_type tc (TREE_CODE (at));
 
           if (ar != 0 && tc != POINTER_TYPE)
             return found_none;
@@ -2581,7 +2581,7 @@
             // template or a type.
             //
             decl = resolve_name (p, cp->scope, true);
-            int tc (TREE_CODE (decl));
+            gcc_tree_code_type tc (TREE_CODE (decl));
 
             if (tc == TYPE_DECL)
             {
@@ -2671,7 +2671,7 @@
               // Resolve this name and make sure it is a template.
               //
               decl = resolve_name (p, cp->scope, true);
-              int tc (TREE_CODE (decl));
+              gcc_tree_code_type tc (TREE_CODE (decl));
 
               if (tc == TEMPLATE_DECL && DECL_CLASS_TEMPLATE_P (decl))
               {
