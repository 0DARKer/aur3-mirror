diff -Naur xen/seabios-config xen-a/seabios-config
--- xen/seabios-config	1970-01-01 00:00:00.000000000 +0000
+++ xen-a/seabios-config	2013-09-25 11:41:52.739562371 +0000
@@ -0,0 +1,97 @@
+#
+# Automatically generated make config: don't edit
+# SeaBIOS Configuration
+# Thu Apr  4 20:14:55 2013
+#
+
+#
+# General Features
+#
+# CONFIG_COREBOOT is not set
+CONFIG_QEMU=y
+# CONFIG_CSM is not set
+CONFIG_QEMU_HARDWARE=y
+CONFIG_XEN=y
+CONFIG_THREADS=y
+# CONFIG_THREAD_OPTIONROMS is not set
+CONFIG_RELOCATE_INIT=y
+CONFIG_BOOTMENU=y
+# CONFIG_BOOTSPLASH is not set
+CONFIG_BOOTORDER=y
+CONFIG_ENTRY_EXTRASTACK=y
+
+#
+# Hardware support
+#
+CONFIG_ATA=y
+CONFIG_ATA_DMA=y
+CONFIG_ATA_PIO32=y
+CONFIG_AHCI=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_VIRTIO_SCSI=y
+CONFIG_ESP_SCSI=y
+CONFIG_LSI_SCSI=y
+CONFIG_MEGASAS=y
+CONFIG_FLOPPY=y
+CONFIG_PS2PORT=y
+CONFIG_USB=y
+CONFIG_USB_UHCI=y
+CONFIG_USB_OHCI=y
+CONFIG_USB_EHCI=y
+CONFIG_USB_MSC=y
+CONFIG_USB_UAS=y
+CONFIG_USB_HUB=y
+CONFIG_USB_KEYBOARD=y
+CONFIG_USB_MOUSE=y
+CONFIG_SERIAL=y
+CONFIG_LPT=y
+CONFIG_USE_SMM=y
+CONFIG_MTRR_INIT=y
+CONFIG_PMTIMER=y
+
+#
+# BIOS interfaces
+#
+CONFIG_DRIVES=y
+CONFIG_CDROM_BOOT=y
+CONFIG_CDROM_EMU=y
+CONFIG_PCIBIOS=y
+CONFIG_APMBIOS=y
+CONFIG_PNPBIOS=y
+CONFIG_OPTIONROMS=y
+# CONFIG_OPTIONROMS_DEPLOYED is not set
+CONFIG_PMM=y
+CONFIG_BOOT=y
+CONFIG_KEYBOARD=y
+CONFIG_KBD_CALL_INT15_4F=y
+CONFIG_MOUSE=y
+CONFIG_S3_RESUME=y
+CONFIG_VGAHOOKS=y
+# CONFIG_DISABLE_A20 is not set
+
+#
+# BIOS Tables
+#
+CONFIG_PIRTABLE=y
+CONFIG_MPTABLE=y
+CONFIG_SMBIOS=y
+CONFIG_ACPI=y
+CONFIG_ACPI_DSDT=y
+
+#
+# VGA ROM
+#
+CONFIG_NO_VGABIOS=y
+# CONFIG_VGA_STANDARD_VGA is not set
+# CONFIG_VGA_CIRRUS is not set
+# CONFIG_VGA_BOCHS is not set
+# CONFIG_VGA_GEODEGX2 is not set
+# CONFIG_VGA_GEODELX is not set
+# CONFIG_BUILD_VGABIOS is not set
+
+#
+# Debugging
+#
+CONFIG_DEBUG_LEVEL=1
+# CONFIG_DEBUG_SERIAL is not set
+CONFIG_DEBUG_IO=y
diff -Naur xen/tools/firmware/Makefile xen-a/tools/firmware/Makefile
--- xen/tools/firmware/Makefile	2013-09-25 03:51:32.069188726 +0000
+++ xen-a/tools/firmware/Makefile	2013-09-25 11:41:52.739562371 +0000
@@ -22,6 +22,7 @@
 seabios-dir:
 	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_TAG) seabios-dir
 	cp seabios-config seabios-dir/.config;
+	patch -d seabios-dir -p1 -i ../seabios-mac-20130223.patch
 
 .PHONY: all
 all: $(SUBDIRS-y)
diff -Naur xen/tools/firmware/seabios-config xen-a/tools/firmware/seabios-config
--- xen/tools/firmware/seabios-config	2013-09-25 03:51:32.079188726 +0000
+++ xen-a/tools/firmware/seabios-config	2013-09-25 11:41:52.739562371 +0000
@@ -1,13 +1,16 @@
 #
 # Automatically generated make config: don't edit
 # SeaBIOS Configuration
-# Thu Jan  3 17:25:45 2013
+# Tue Aug 20 15:53:34 2013
 #
 
 #
 # General Features
 #
 # CONFIG_COREBOOT is not set
+CONFIG_QEMU=y
+# CONFIG_CSM is not set
+CONFIG_QEMU_HARDWARE=y
 CONFIG_XEN=y
 CONFIG_THREADS=y
 # CONFIG_THREAD_OPTIONROMS is not set
@@ -15,6 +18,8 @@
 CONFIG_BOOTMENU=y
 # CONFIG_BOOTSPLASH is not set
 CONFIG_BOOTORDER=y
+CONFIG_ENTRY_EXTRASTACK=y
+CONFIG_MALLOC_UPPERMEMORY=y
 
 #
 # Hardware support
@@ -27,6 +32,7 @@
 CONFIG_VIRTIO_SCSI=y
 CONFIG_ESP_SCSI=y
 CONFIG_LSI_SCSI=y
+CONFIG_MEGASAS=y
 CONFIG_FLOPPY=y
 CONFIG_PS2PORT=y
 CONFIG_USB=y
@@ -42,6 +48,7 @@
 CONFIG_LPT=y
 CONFIG_USE_SMM=y
 CONFIG_MTRR_INIT=y
+CONFIG_PMTIMER=y
 
 #
 # BIOS interfaces
@@ -62,6 +69,7 @@
 CONFIG_S3_RESUME=y
 CONFIG_VGAHOOKS=y
 # CONFIG_DISABLE_A20 is not set
+CONFIG_WRITABLE_UPPERMEMORY=y
 
 #
 # BIOS Tables
@@ -70,6 +78,7 @@
 CONFIG_MPTABLE=y
 CONFIG_SMBIOS=y
 CONFIG_ACPI=y
+CONFIG_ACPI_DSDT=y
 
 #
 # VGA ROM
diff -Naur xen/tools/firmware/seabios-mac-20130223.patch xen-a/tools/firmware/seabios-mac-20130223.patch
--- xen/tools/firmware/seabios-mac-20130223.patch	1970-01-01 00:00:00.000000000 +0000
+++ xen-a/tools/firmware/seabios-mac-20130223.patch	2013-09-25 11:39:26.852921152 +0000
@@ -0,0 +1,1193 @@
+diff -Naur a/src/fw/acpi-dsdt-hpet.dsl b/src/fw/acpi-dsdt-hpet.dsl
+--- a/src/fw/acpi-dsdt-hpet.dsl	2013-09-25 11:34:29.559556285 +0000
++++ b/src/fw/acpi-dsdt-hpet.dsl	2013-09-25 11:38:13.729560324 +0000
+@@ -23,14 +23,23 @@
+             }
+             Return (0x0F)
+         }
+-        Name(_CRS, ResourceTemplate() {
+-#if 0       /* This makes WinXP BSOD for not yet figured reasons. */
+-            IRQNoFlags() {2, 8}
+-#endif
++        Name(RESP, ResourceTemplate() {
+             Memory32Fixed(ReadOnly,
+                 0xFED00000,         // Address Base
+                 0x00000400,         // Address Length
+                 )
+         })
++        Name(RESI, ResourceTemplate() {
++            IRQNoFlags() {2, 8}
++        })
++        Method(_CRS, 0) {
++            Store(\_SB.PCI0.ISA.SMC._STA(), Local0)
++            If (LEqual(Local0, 0x0B)) {        // AppleSMC present, add IRQ
++                ConcatenateResTemplate(RESP, RESI, Local1)
++                Return (Local1)
++            } else {
++                Return (RESP)
++            }
++        }
+     }
+ }
+diff -Naur a/src/fw/acpi-dsdt-isa.dsl b/src/fw/acpi-dsdt-isa.dsl
+--- a/src/fw/acpi-dsdt-isa.dsl	2013-09-25 11:34:29.559556285 +0000
++++ b/src/fw/acpi-dsdt-isa.dsl	2013-09-25 11:38:19.856221047 +0000
+@@ -1,6 +1,28 @@
+ /* Common legacy ISA style devices. */
+ Scope(\_SB.PCI0.ISA) {
+ 
++    Device (SMC) {
++        Name(_HID, EisaId("APP0001"))
++        OperationRegion(SMC, SystemIO, 0x0300, 0x20)
++        Field(SMC, ByteAcc, NoLock, Preserve) {
++            Offset(0x04),
++            CMDP, 8,
++        }
++        Method(_STA, 0) {
++//            Store(0x10, CMDP)    // APPLESMC_READ_CMD
++//            Store(CMDP, Local0)
++//            If (LEqual(Local0, 0x0c)) {
++                Return (0x0B)
++//            } Else {
++//                Return (0x00)
++//            }
++        }
++        Name (_CRS, ResourceTemplate () {
++            IO (Decode16, 0x0300, 0x0300, 0x01, 0x20)
++            IRQNoFlags() { 6 }
++        })
++    }
++
+     Device(RTC) {
+         Name(_HID, EisaId("PNP0B00"))
+         Name(_CRS, ResourceTemplate() {
+diff -Naur a/src/fw/smbios.c b/src/fw/smbios.c
+--- a/src/fw/smbios.c	2013-09-25 11:34:29.619556286 +0000
++++ b/src/fw/smbios.c	2013-09-25 11:38:31.046256448 +0000
+@@ -42,7 +42,7 @@
+     memcpy(ep->anchor_string, "_SM_", 4);
+     ep->length = 0x1f;
+     ep->smbios_major_version = 2;
+-    ep->smbios_minor_version = 4;
++    ep->smbios_minor_version = 5;
+     ep->max_structure_size = max_structure_size;
+     ep->entry_point_revision = 0;
+     memset(ep->formatted_area, 0, 5);
+@@ -51,7 +51,7 @@
+     ep->structure_table_length = structure_table_length;
+     ep->structure_table_address = (u32)finaltable;
+     ep->number_of_structures = number_of_structures;
+-    ep->smbios_bcd_revision = 0x24;
++    ep->smbios_bcd_revision = 0x25;
+ 
+     ep->checksum -= checksum(ep, 0x10);
+ 
+@@ -176,8 +176,8 @@
+     p->header.length = sizeof(struct smbios_type_0);
+     p->header.handle = 0;
+ 
+-    load_str_field_with_default(0, vendor_str, BUILD_APPNAME);
+-    load_str_field_with_default(0, bios_version_str, BUILD_APPNAME);
++    load_str_field_with_default(0, vendor_str, "Apple Inc.");
++    load_str_field_with_default(0, bios_version_str, "IM81.88Z.00C1.B00.0802091538");
+ 
+     p->bios_starting_address_segment = 0xe800;
+ 
+@@ -188,8 +188,10 @@
+     if (!get_field(0, offsetof(struct smbios_type_0, bios_characteristics),
+                    &p->bios_characteristics)) {
+         memset(p->bios_characteristics, 0, 8);
+-        /* BIOS characteristics not supported */
+-        p->bios_characteristics[0] = 0x08;
++        p->bios_characteristics[0] = 0x80;
++        p->bios_characteristics[1] = 0x98;
++        p->bios_characteristics[2] = 0x09;
++        p->bios_characteristics[3] = 0x78;
+     }
+ 
+     if (!get_field(0, offsetof(struct smbios_type_0,
+@@ -224,18 +226,18 @@
+     p->header.length = sizeof(struct smbios_type_1);
+     p->header.handle = 0x100;
+ 
+-    load_str_field_with_default(1, manufacturer_str, BUILD_APPNAME);
+-    load_str_field_with_default(1, product_name_str, BUILD_APPNAME);
+-    load_str_field_or_skip(1, version_str);
+-    load_str_field_or_skip(1, serial_number_str);
++    load_str_field_with_default(1, manufacturer_str, "Apple Inc.");
++    load_str_field_with_default(1, product_name_str, "iMac8,1");
++    load_str_field_with_default(1, version_str, "1.0");
++    load_str_field_with_default(1, serial_number_str, "SystemSerial#");
+ 
+     if (!get_field(1, offsetof(struct smbios_type_1, uuid), &p->uuid))
+         memset(p->uuid, 0, 16);
+ 
+     set_field_with_default(1, wake_up_type, 0x06); /* power switch */
+ 
+-    load_str_field_or_skip(1, sku_number_str);
+-    load_str_field_or_skip(1, family_str);
++    load_str_field_with_default(1, sku_number_str, "SKU#");
++    load_str_field_with_default(1, family_str, "Mac");
+ 
+     *end = 0;
+     end++;
+@@ -247,6 +249,44 @@
+     return end;
+ }
+ 
++/* Type 2 -- Base Board */
++static void *
++smbios_init_type_2(void *start)
++{
++    struct smbios_type_2 *p = (struct smbios_type_2 *)start;
++
++    p->header.type = 2;
++    p->header.length = sizeof(struct smbios_type_2);
++    p->header.handle = 0x300;
++
++    p->manufacturer_str = 1;
++    p->product_str = 2;
++    p->version_str = 3;
++    p->serial_number_str = 4;
++    p->asset_tag_number_str = 0;
++    p->feature_flags = 1; /* Motherboard */
++    p->location_str = 0;
++    p->chassis_handle = 0x301;
++    p->board_type = 0x0a; /* Motherboard */
++    p->contained_element_count = 0;
++
++    start += sizeof(struct smbios_type_2);
++    memcpy((char *)start, "Apple Inc.", sizeof("Apple Inc."));
++    start += sizeof("Apple Inc.");
++
++    memcpy((char *)start, "Mac-F227BEC8", sizeof("Mac-F227BEC8"));
++    start += sizeof("Mac-F227BEC8");
++
++    memcpy((char *)start, "VERSION", sizeof("VERSION"));
++    start += sizeof("VERSION");
++
++    memcpy((char *)start, "BoardSerial#", sizeof("BoardSerial#"));
++    start += sizeof("BoardSerial#");
++
++    *((u8 *)start) = 0;
++    return start + 1;
++}
++
+ /* Type 3 -- System Enclosure */
+ static void *
+ smbios_init_type_3(void *start)
+@@ -258,13 +298,13 @@
+ 
+     p->header.type = 3;
+     p->header.length = sizeof(struct smbios_type_3);
+-    p->header.handle = 0x300;
++    p->header.handle = 0x301;
+ 
+     load_str_field_with_default(3, manufacturer_str, BUILD_APPNAME);
+     set_field_with_default(3, type, 0x01); /* other */
+ 
+-    load_str_field_or_skip(3, version_str);
+-    load_str_field_or_skip(3, serial_number_str);
++    load_str_field_with_default(3, version_str, "VERSION");
++    load_str_field_with_default(3, serial_number_str, "ChassisSerial#");
+     load_str_field_or_skip(3, asset_tag_number_str);
+ 
+     set_field_with_default(3, boot_up_state, 0x03); /* safe */
+@@ -327,7 +367,7 @@
+ 
+     load_str_field_or_skip(4, processor_version_str);
+     set_field_with_default(4, voltage, 0);
+-    set_field_with_default(4, external_clock, 0);
++    set_field_with_default(4, external_clock, 800);
+ 
+     set_field_with_default(4, max_speed, 2000);
+     set_field_with_default(4, current_speed, 2000);
+@@ -336,9 +376,16 @@
+     set_field_with_default(4, processor_upgrade, 0x01); /* other */
+ 
+     /* cache information structure not provided */
+-    p->l1_cache_handle =  0xffff;
+-    p->l2_cache_handle =  0xffff;
+-    p->l3_cache_handle =  0xffff;
++    p->l1_cache_handle = 0x600 + cpu_number * 2;
++    p->l2_cache_handle = 0x600 + cpu_number * 2 + 1;
++    p->l3_cache_handle = 0xffff; /* cache information structure not provided */
++
++    p->asset_tag_str = 0;
++    p->part_no_str = 0;
++    p->core_count = 2;
++    p->core_enabled = 2;
++    p->thread_count = 2;
++    p->processor_characteristics = 0;
+ 
+     *end = 0;
+     end++;
+@@ -350,6 +397,35 @@
+     return end;
+ }
+ 
++static void *
++smbios_init_type_7(void *start, unsigned int cpu_number, unsigned int level)
++{
++    struct smbios_type_7 *p = (struct smbios_type_7 *)start;
++
++    p->header.type = 7;
++    p->header.length = sizeof(struct smbios_type_7);
++    p->header.handle = 0x600 + cpu_number * 2 + level - 1;
++
++    p->socket_designation_str = 1;
++    p->cache_config = 0x80 & (level - 1); /* enabled + level */
++    p->max_cache_size = p->installed_cache_size =
++	level == 1 ? 64 : 512; /* 1k granularity */
++    p->supported_sram_type = p->current_sram_type =
++        0x08 & 0x10 & 0x80; /* Burst, Pipeline Burst, Asynchronous */
++    p->cache_speed = 0; /* in ns, 0 for unknown */
++    p->error_correction = 0x05; /* Single-bit ECC */
++    p->system_cache_type = 0x05; /* Unified */
++    p->associativity = 0x06; /* Fully Associative */
++
++    start += sizeof(struct smbios_type_7);
++
++    snprintf((char*)start, 9, "L%d Cache", level);
++    start += 9;
++
++    *((u8 *)start) = 0;
++    return start + 1;
++}
++
+ /* Type 16 -- Physical Memory Array */
+ static void *
+ smbios_init_type_16(void *start, u32 memory_size_mb, int nr_mem_devs)
+@@ -390,6 +466,8 @@
+     p->header.length = sizeof(struct smbios_type_17);
+     p->header.handle = 0x1100 + instance;
+ 
++    p->speed = 667;
++    p->attributes = 0;
+     p->physical_memory_array_handle = 0x1000;
+     set_field_with_default(17, total_width, 64);
+     set_field_with_default(17, data_width, 64);
+@@ -409,7 +487,10 @@
+     end += strlen(name) + 1;
+     p->device_locator_str = ++str_index;
+ 
+-    load_str_field_or_skip(17, bank_locator_str);
++    load_str_field_with_default(17, bank_locator_str, "Bank 0");
++    load_str_field_with_default(17, manufactor_str, "Manufactor");
++    load_str_field_with_default(17, serial_str, "MemSerial#");
++
+     set_field_with_default(17, memory_type, 0x07); /* RAM */
+     set_field_with_default(17, type_detail, 0);
+ 
+@@ -536,11 +617,15 @@
+ 
+     add_struct(0, p);
+     add_struct(1, p);
++    add_struct(2, p);
+     add_struct(3, p);
+ 
+     int cpu_num;
+-    for (cpu_num = 1; cpu_num <= MaxCountCPUs; cpu_num++)
++    for (cpu_num = 1; cpu_num <= MaxCountCPUs; cpu_num++) {
+         add_struct(4, p, cpu_num);
++        add_struct(7, p, cpu_num, 1); /* L1 & L2 cache */
++        add_struct(7, p, cpu_num, 2);
++    }
+ 
+     int ram_mb = (RamSize + RamSizeOver4G) >> 20;
+     int nr_mem_devs = (ram_mb + 0x3fff) >> 14;
+diff -Naur a/src/fw/smbios.c.orig b/src/fw/smbios.c.orig
+--- a/src/fw/smbios.c.orig	1970-01-01 00:00:00.000000000 +0000
++++ b/src/fw/smbios.c.orig	2013-09-25 11:34:29.619556286 +0000
+@@ -0,0 +1,654 @@
++// smbios table generation (on emulators)
++//
++// Copyright (C) 2008,2009  Kevin O'Connor <kevin@koconnor.net>
++// Copyright (C) 2006 Fabrice Bellard
++//
++// This file may be distributed under the terms of the GNU LGPLv3 license.
++
++#include "config.h" // CONFIG_*
++#include "malloc.h" // free
++#include "output.h" // dprintf
++#include "paravirt.h" // RamSize
++#include "romfile.h" // romfile_findprefix
++#include "std/smbios.h" // struct smbios_entry_point
++#include "string.h" // memset
++#include "util.h" // MaxCountCPUs
++#include "x86.h" // cpuid
++
++struct smbios_entry_point *SMBiosAddr;
++
++static void
++smbios_entry_point_setup(u16 max_structure_size,
++                         u16 structure_table_length,
++                         void *structure_table_address,
++                         u16 number_of_structures)
++{
++    struct smbios_entry_point *ep = malloc_fseg(sizeof(*ep));
++    void *finaltable;
++    if (structure_table_length <= BUILD_MAX_SMBIOS_FSEG)
++        // Table is small enough for f-seg - allocate there.  This
++        // works around a bug in JunOS (at least for small SMBIOS tables).
++        finaltable = malloc_fseg(structure_table_length);
++    else
++        finaltable = malloc_high(structure_table_length);
++    if (!ep || !finaltable) {
++        warn_noalloc();
++        free(ep);
++        free(finaltable);
++        return;
++    }
++    memcpy(finaltable, structure_table_address, structure_table_length);
++
++    memcpy(ep->anchor_string, "_SM_", 4);
++    ep->length = 0x1f;
++    ep->smbios_major_version = 2;
++    ep->smbios_minor_version = 4;
++    ep->max_structure_size = max_structure_size;
++    ep->entry_point_revision = 0;
++    memset(ep->formatted_area, 0, 5);
++    memcpy(ep->intermediate_anchor_string, "_DMI_", 5);
++
++    ep->structure_table_length = structure_table_length;
++    ep->structure_table_address = (u32)finaltable;
++    ep->number_of_structures = number_of_structures;
++    ep->smbios_bcd_revision = 0x24;
++
++    ep->checksum -= checksum(ep, 0x10);
++
++    ep->intermediate_checksum -= checksum((void*)ep + 0x10, ep->length - 0x10);
++
++    SMBiosAddr = ep;
++    dprintf(1, "SMBIOS ptr=%p table=%p size=%d\n"
++            , ep, finaltable, structure_table_length);
++}
++
++static int
++get_field(int type, int offset, void *dest)
++{
++    char name[128];
++    snprintf(name, sizeof(name), "smbios/field%d-%d", type, offset);
++    struct romfile_s *file = romfile_find(name);
++    if (!file)
++        return 0;
++    file->copy(file, dest, file->size);
++    return file->size;
++}
++
++static int
++get_external(int type, char **p, unsigned *nr_structs,
++             unsigned *max_struct_size, char *end)
++{
++    static u64 used_bitmap[4] = { 0 };
++    char *start = *p;
++
++    /* Check if we've already reported these tables */
++    if (used_bitmap[(type >> 6) & 0x3] & (1ULL << (type & 0x3f)))
++        return 1;
++
++    /* Don't introduce spurious end markers */
++    if (type == 127)
++        return 0;
++
++    char prefix[128];
++    snprintf(prefix, sizeof(prefix), "smbios/table%d-", type);
++    struct romfile_s *file = NULL;
++    for (;;) {
++        file = romfile_findprefix(prefix, file);
++        if (!file)
++            break;
++
++        if (end - *p < file->size) {
++            warn_noalloc();
++            break;
++        }
++
++        struct smbios_structure_header *header = (void*)*p;
++        file->copy(file, header, file->size);
++        *p += file->size;
++
++        /* Entries end with a double NULL char, if there's a string at
++         * the end (length is greater than formatted length), the string
++         * terminator provides the first NULL. */
++        *((u8*)*p) = 0;
++        (*p)++;
++        if (header->length >= file->size) {
++            *((u8*)*p) = 0;
++            (*p)++;
++        }
++
++        (*nr_structs)++;
++        if (*p - (char*)header > *max_struct_size)
++            *max_struct_size = *p - (char*)header;
++    }
++
++    if (start == *p)
++        return 0;
++
++    /* Mark that we've reported on this type */
++    used_bitmap[(type >> 6) & 0x3] |= (1ULL << (type & 0x3f));
++    return 1;
++}
++
++#define load_str_field_with_default(type, field, def)                   \
++    do {                                                                \
++        size = get_field(type, offsetof(struct smbios_type_##type,      \
++                                        field), end);                   \
++        if (size > 0) {                                                 \
++            end += size;                                                \
++        } else {                                                        \
++            memcpy(end, def, sizeof(def));                              \
++            end += sizeof(def);                                         \
++        }                                                               \
++        p->field = ++str_index;                                         \
++    } while (0)
++
++#define load_str_field_or_skip(type, field)                             \
++    do {                                                                \
++        size = get_field(type, offsetof(struct smbios_type_##type,      \
++                                        field), end);                   \
++        if (size > 0) {                                                 \
++            end += size;                                                \
++            p->field = ++str_index;                                     \
++        } else {                                                        \
++            p->field = 0;                                               \
++        }                                                               \
++    } while (0)
++
++#define set_field_with_default(type, field, def)                        \
++    do {                                                                \
++        if (!get_field(type, offsetof(struct smbios_type_##type,        \
++                                      field), &p->field)) {             \
++            p->field = def;                                             \
++        }                                                               \
++    } while (0)
++
++/* Type 0 -- BIOS Information */
++#define RELEASE_DATE_STR "01/01/2011"
++static void *
++smbios_init_type_0(void *start)
++{
++    struct smbios_type_0 *p = (struct smbios_type_0 *)start;
++    char *end = (char *)start + sizeof(struct smbios_type_0);
++    size_t size;
++    int str_index = 0;
++
++    p->header.type = 0;
++    p->header.length = sizeof(struct smbios_type_0);
++    p->header.handle = 0;
++
++    load_str_field_with_default(0, vendor_str, BUILD_APPNAME);
++    load_str_field_with_default(0, bios_version_str, BUILD_APPNAME);
++
++    p->bios_starting_address_segment = 0xe800;
++
++    load_str_field_with_default(0, bios_release_date_str, RELEASE_DATE_STR);
++
++    p->bios_rom_size = 0; /* FIXME */
++
++    if (!get_field(0, offsetof(struct smbios_type_0, bios_characteristics),
++                   &p->bios_characteristics)) {
++        memset(p->bios_characteristics, 0, 8);
++        /* BIOS characteristics not supported */
++        p->bios_characteristics[0] = 0x08;
++    }
++
++    if (!get_field(0, offsetof(struct smbios_type_0,
++                               bios_characteristics_extension_bytes),
++                   &p->bios_characteristics_extension_bytes)) {
++        p->bios_characteristics_extension_bytes[0] = 0;
++        /* Enable targeted content distribution. Needed for SVVP */
++        p->bios_characteristics_extension_bytes[1] = 4;
++    }
++
++    set_field_with_default(0, system_bios_major_release, 1);
++    set_field_with_default(0, system_bios_minor_release, 0);
++    set_field_with_default(0, embedded_controller_major_release, 0xff);
++    set_field_with_default(0, embedded_controller_minor_release, 0xff);
++
++    *end = 0;
++    end++;
++
++    return end;
++}
++
++/* Type 1 -- System Information */
++static void *
++smbios_init_type_1(void *start)
++{
++    struct smbios_type_1 *p = (struct smbios_type_1 *)start;
++    char *end = (char *)start + sizeof(struct smbios_type_1);
++    size_t size;
++    int str_index = 0;
++
++    p->header.type = 1;
++    p->header.length = sizeof(struct smbios_type_1);
++    p->header.handle = 0x100;
++
++    load_str_field_with_default(1, manufacturer_str, BUILD_APPNAME);
++    load_str_field_with_default(1, product_name_str, BUILD_APPNAME);
++    load_str_field_or_skip(1, version_str);
++    load_str_field_or_skip(1, serial_number_str);
++
++    if (!get_field(1, offsetof(struct smbios_type_1, uuid), &p->uuid))
++        memset(p->uuid, 0, 16);
++
++    set_field_with_default(1, wake_up_type, 0x06); /* power switch */
++
++    load_str_field_or_skip(1, sku_number_str);
++    load_str_field_or_skip(1, family_str);
++
++    *end = 0;
++    end++;
++    if (!str_index) {
++        *end = 0;
++        end++;
++    }
++
++    return end;
++}
++
++/* Type 3 -- System Enclosure */
++static void *
++smbios_init_type_3(void *start)
++{
++    struct smbios_type_3 *p = (struct smbios_type_3 *)start;
++    char *end = (char *)start + sizeof(struct smbios_type_3);
++    size_t size;
++    int str_index = 0;
++
++    p->header.type = 3;
++    p->header.length = sizeof(struct smbios_type_3);
++    p->header.handle = 0x300;
++
++    load_str_field_with_default(3, manufacturer_str, BUILD_APPNAME);
++    set_field_with_default(3, type, 0x01); /* other */
++
++    load_str_field_or_skip(3, version_str);
++    load_str_field_or_skip(3, serial_number_str);
++    load_str_field_or_skip(3, asset_tag_number_str);
++
++    set_field_with_default(3, boot_up_state, 0x03); /* safe */
++    set_field_with_default(3, power_supply_state, 0x03); /* safe */
++    set_field_with_default(3, thermal_state, 0x03); /* safe */
++    set_field_with_default(3, security_status, 0x02); /* unknown */
++
++    set_field_with_default(3, oem_defined, 0);
++    set_field_with_default(3, height, 0);
++    set_field_with_default(3, number_of_power_cords, 0);
++    set_field_with_default(3, contained_element_count, 0);
++
++    *end = 0;
++    end++;
++    if (!str_index) {
++        *end = 0;
++        end++;
++    }
++
++    return end;
++}
++
++/* Type 4 -- Processor Information */
++static void *
++smbios_init_type_4(void *start, unsigned int cpu_number)
++{
++    struct smbios_type_4 *p = (struct smbios_type_4 *)start;
++    char *end = (char *)start + sizeof(struct smbios_type_4);
++    size_t size;
++    int str_index = 0;
++    char name[1024];
++
++    p->header.type = 4;
++    p->header.length = sizeof(struct smbios_type_4);
++    p->header.handle = 0x400 + cpu_number;
++
++    size = get_field(4, offsetof(struct smbios_type_4, socket_designation_str),
++                     name);
++    if (size)
++        snprintf(name + size - 1, sizeof(name) - size, "%2x", cpu_number);
++    else
++        snprintf(name, sizeof(name), "CPU%2x", cpu_number);
++
++    memcpy(end, name, strlen(name) + 1);
++    end += strlen(name) + 1;
++    p->socket_designation_str = ++str_index;
++
++    set_field_with_default(4, processor_type, 0x03); /* CPU */
++    set_field_with_default(4, processor_family, 0x01); /* other */
++
++    load_str_field_with_default(4, processor_manufacturer_str, BUILD_APPNAME);
++
++    if (!get_field(4, offsetof(struct smbios_type_4, processor_id)
++                   , p->processor_id)) {
++        u32 cpuid_signature, ebx, ecx, cpuid_features;
++        cpuid(1, &cpuid_signature, &ebx, &ecx, &cpuid_features);
++        p->processor_id[0] = cpuid_signature;
++        p->processor_id[1] = cpuid_features;
++    }
++
++    load_str_field_or_skip(4, processor_version_str);
++    set_field_with_default(4, voltage, 0);
++    set_field_with_default(4, external_clock, 0);
++
++    set_field_with_default(4, max_speed, 2000);
++    set_field_with_default(4, current_speed, 2000);
++
++    set_field_with_default(4, status, 0x41); /* socket populated, CPU enabled */
++    set_field_with_default(4, processor_upgrade, 0x01); /* other */
++
++    /* cache information structure not provided */
++    p->l1_cache_handle =  0xffff;
++    p->l2_cache_handle =  0xffff;
++    p->l3_cache_handle =  0xffff;
++
++    *end = 0;
++    end++;
++    if (!str_index) {
++        *end = 0;
++        end++;
++    }
++
++    return end;
++}
++
++/* Type 16 -- Physical Memory Array */
++static void *
++smbios_init_type_16(void *start, u32 memory_size_mb, int nr_mem_devs)
++{
++    struct smbios_type_16 *p = (struct smbios_type_16*)start;
++
++    p->header.type = 16;
++    p->header.length = sizeof(struct smbios_type_16);
++    p->header.handle = 0x1000;
++
++    set_field_with_default(16, location, 0x01); /* other */
++    set_field_with_default(16, use, 0x03); /* system memory */
++    /* Multi-bit ECC to make Microsoft happy */
++    set_field_with_default(16, error_correction, 0x06);
++    /* 0x80000000 = unknown, accept sizes < 2TB - TODO multiple arrays */
++    p->maximum_capacity = memory_size_mb < 2 << 20 ?
++                          memory_size_mb << 10 : 0x80000000;
++    p->memory_error_information_handle = 0xfffe; /* none provided */
++    p->number_of_memory_devices = nr_mem_devs;
++
++    start += sizeof(struct smbios_type_16);
++    *((u16 *)start) = 0;
++
++    return start + 2;
++}
++
++/* Type 17 -- Memory Device */
++static void *
++smbios_init_type_17(void *start, u32 size_mb, int instance)
++{
++    struct smbios_type_17 *p = (struct smbios_type_17 *)start;
++    char *end = (char *)start + sizeof(struct smbios_type_17);
++    size_t size;
++    int str_index = 0;
++    char name[1024];
++
++    p->header.type = 17;
++    p->header.length = sizeof(struct smbios_type_17);
++    p->header.handle = 0x1100 + instance;
++
++    p->physical_memory_array_handle = 0x1000;
++    set_field_with_default(17, total_width, 64);
++    set_field_with_default(17, data_width, 64);
++/* TODO: should assert in case something is wrong   ASSERT((memory_size_mb & ~0x7fff) == 0); */
++    p->size = size_mb;
++    set_field_with_default(17, form_factor, 0x09); /* DIMM */
++    p->device_set = 0;
++
++    size = get_field(17, offsetof(struct smbios_type_17, device_locator_str),
++                     name);
++    if (size)
++        snprintf(name + size - 1, sizeof(name) - size, "%d", instance);
++    else
++        snprintf(name, sizeof(name), "DIMM %d", instance);
++
++    memcpy(end, name, strlen(name) + 1);
++    end += strlen(name) + 1;
++    p->device_locator_str = ++str_index;
++
++    load_str_field_or_skip(17, bank_locator_str);
++    set_field_with_default(17, memory_type, 0x07); /* RAM */
++    set_field_with_default(17, type_detail, 0);
++
++    *end = 0;
++    end++;
++    if (!str_index) {
++        *end = 0;
++        end++;
++    }
++
++    return end;
++}
++
++/* Type 19 -- Memory Array Mapped Address */
++static void *
++smbios_init_type_19(void *start, u32 start_mb, u32 size_mb, int instance)
++{
++    struct smbios_type_19 *p = (struct smbios_type_19 *)start;
++
++    p->header.type = 19;
++    p->header.length = sizeof(struct smbios_type_19);
++    p->header.handle = 0x1300 + instance;
++
++    p->starting_address = start_mb << 10;
++    p->ending_address = p->starting_address + (size_mb << 10) - 1;
++    p->memory_array_handle = 0x1000;
++    p->partition_width = 1;
++
++    start += sizeof(struct smbios_type_19);
++    *((u16 *)start) = 0;
++
++    return start + 2;
++}
++
++/* Type 20 -- Memory Device Mapped Address */
++static void *
++smbios_init_type_20(void *start, u32 start_mb, u32 size_mb, int instance,
++                    int dev_handle, int array_handle)
++{
++    struct smbios_type_20 *p = (struct smbios_type_20 *)start;
++
++    p->header.type = 20;
++    p->header.length = sizeof(struct smbios_type_20);
++    p->header.handle = 0x1400 + instance;
++
++    p->starting_address = start_mb << 10;
++    p->ending_address = p->starting_address + (size_mb << 10) - 1;
++    p->memory_device_handle = 0x1100 + dev_handle;
++    p->memory_array_mapped_address_handle = 0x1300 + array_handle;
++    p->partition_row_position = 1;
++    p->interleave_position = 0;
++    p->interleaved_data_depth = 0;
++
++    start += sizeof(struct smbios_type_20);
++
++    *((u16 *)start) = 0;
++    return start+2;
++}
++
++/* Type 32 -- System Boot Information */
++static void *
++smbios_init_type_32(void *start)
++{
++    struct smbios_type_32 *p = (struct smbios_type_32 *)start;
++
++    p->header.type = 32;
++    p->header.length = sizeof(struct smbios_type_32);
++    p->header.handle = 0x2000;
++    memset(p->reserved, 0, 6);
++    set_field_with_default(32, boot_status, 0); /* no errors detected */
++
++    start += sizeof(struct smbios_type_32);
++    *((u16 *)start) = 0;
++
++    return start+2;
++}
++
++/* Type 127 -- End of Table */
++static void *
++smbios_init_type_127(void *start)
++{
++    struct smbios_type_127 *p = (struct smbios_type_127 *)start;
++
++    p->header.type = 127;
++    p->header.length = sizeof(struct smbios_type_127);
++    p->header.handle = 0x7f00;
++
++    start += sizeof(struct smbios_type_127);
++    *((u16 *)start) = 0;
++
++    return start + 2;
++}
++
++#define TEMPSMBIOSSIZE (32 * 1024)
++
++void
++smbios_setup(void)
++{
++    if (! CONFIG_SMBIOS)
++        return;
++
++    dprintf(3, "init SMBIOS tables\n");
++
++    char *start = malloc_tmphigh(TEMPSMBIOSSIZE);
++    if (! start) {
++        warn_noalloc();
++        return;
++    }
++
++    u32 nr_structs = 0, max_struct_size = 0;
++    char *q, *p = start;
++    char *end = start + TEMPSMBIOSSIZE - sizeof(struct smbios_type_127);
++
++#define add_struct(type, args...)                                       \
++    do {                                                                \
++        if (!get_external(type, &p, &nr_structs, &max_struct_size, end)) { \
++            q = smbios_init_type_##type(args);                          \
++            nr_structs++;                                               \
++            if ((q - p) > max_struct_size)                              \
++                max_struct_size = q - p;                                \
++            p = q;                                                      \
++        }                                                               \
++    } while (0)
++
++    add_struct(0, p);
++    add_struct(1, p);
++    add_struct(3, p);
++
++    int cpu_num;
++    for (cpu_num = 1; cpu_num <= MaxCountCPUs; cpu_num++)
++        add_struct(4, p, cpu_num);
++
++    int ram_mb = (RamSize + RamSizeOver4G) >> 20;
++    int nr_mem_devs = (ram_mb + 0x3fff) >> 14;
++    add_struct(16, p, ram_mb, nr_mem_devs);
++
++    int i, j;
++    for (i = 0; i < nr_mem_devs; i++) {
++        u32 dev_mb = ((i == (nr_mem_devs - 1))
++                      ? (((ram_mb - 1) & 0x3fff) + 1)
++                      : 16384);
++        add_struct(17, p, dev_mb, i);
++    }
++
++    add_struct(19, p, 0, RamSize >> 20, 0);
++    if (RamSizeOver4G)
++        add_struct(19, p, 4096, RamSizeOver4G >> 20, 1);
++
++    add_struct(20, p, 0, RamSize >> 20, 0, 0, 0);
++    if (RamSizeOver4G) {
++        u32 start_mb = 4096;
++        for (j = 1, i = 0; i < nr_mem_devs; i++, j++) {
++            u32 dev_mb = ((i == (nr_mem_devs - 1))
++                               ? (((ram_mb - 1) & 0x3fff) + 1)
++                               : 16384);
++            if (i == 0)
++                dev_mb -= RamSize >> 20;
++
++            add_struct(20, p, start_mb, dev_mb, j, i, 1);
++            start_mb += dev_mb;
++        }
++    }
++
++    add_struct(32, p);
++    /* Add any remaining provided entries before the end marker */
++    for (i = 0; i < 256; i++)
++        get_external(i, &p, &nr_structs, &max_struct_size, end);
++    add_struct(127, p);
++
++#undef add_struct
++
++    smbios_entry_point_setup(max_struct_size, p - start, start, nr_structs);
++    free(start);
++}
++
++void
++display_uuid(void)
++{
++    u32 addr, end;
++    u8 *uuid;
++    u8 empty_uuid[16] = { 0 };
++
++    if (SMBiosAddr == NULL)
++        return;
++
++    addr =        SMBiosAddr->structure_table_address;
++    end  = addr + SMBiosAddr->structure_table_length;
++
++    /* the following takes care of any initial wraparound too */
++    while (addr < end) {
++        const struct smbios_structure_header *hdr;
++
++        /* partial structure header */
++        if (end - addr < sizeof(struct smbios_structure_header))
++            return;
++
++        hdr = (struct smbios_structure_header *)addr;
++
++        /* partial structure */
++        if (end - addr < hdr->length)
++            return;
++
++        /* any Type 1 structure version will do that has the UUID */
++        if (hdr->type == 1 &&
++            hdr->length >= offsetof(struct smbios_type_1, uuid) + 16)
++            break;
++
++        /* done with formatted area, skip string-set */
++        addr += hdr->length;
++
++        while (end - addr >= 2 &&
++               (*(u8 *)addr     != '\0' ||
++                *(u8 *)(addr+1) != '\0'))
++            ++addr;
++
++        /* structure terminator not found */
++        if (end - addr < 2)
++            return;
++
++        addr += 2;
++    }
++
++    /* parsing finished or skipped entirely, UUID not found */
++    if (addr >= end)
++        return;
++
++    uuid = (u8 *)(addr + offsetof(struct smbios_type_1, uuid));
++    if (memcmp(uuid, empty_uuid, sizeof empty_uuid) == 0)
++        return;
++
++    printf("Machine UUID"
++             " %02x%02x%02x%02x"
++             "-%02x%02x"
++             "-%02x%02x"
++             "-%02x%02x"
++             "-%02x%02x%02x%02x%02x%02x\n"
++           , uuid[ 0], uuid[ 1], uuid[ 2], uuid[ 3]
++           , uuid[ 4], uuid[ 5]
++           , uuid[ 6], uuid[ 7]
++           , uuid[ 8], uuid[ 9]
++           , uuid[10], uuid[11], uuid[12], uuid[13], uuid[14], uuid[15]);
++}
+diff -Naur a/src/std/smbios.h b/src/std/smbios.h
+--- a/src/std/smbios.h	2013-09-25 11:34:29.642889620 +0000
++++ b/src/std/smbios.h	2013-09-25 11:38:41.792894984 +0000
+@@ -59,6 +59,22 @@
+     u8 family_str;
+ } PACKED;
+ 
++/* SMBIOS type 2 - Base Board */
++struct smbios_type_2 {
++    struct smbios_structure_header header;
++    u8 manufacturer_str;
++    u8 product_str;
++    u8 version_str;
++    u8 serial_number_str;
++    u8 asset_tag_number_str;
++    u8 feature_flags;
++    u8 location_str;
++    u16 chassis_handle;
++    u8 board_type;
++    u8 contained_element_count;
++    // contained elements follow
++} PACKED;
++
+ /* SMBIOS type 3 - System Enclosure (v2.3) */
+ struct smbios_type_3 {
+     struct smbios_structure_header header;
+@@ -96,6 +112,28 @@
+     u16 l1_cache_handle;
+     u16 l2_cache_handle;
+     u16 l3_cache_handle;
++    u8 serial_str;
++    u8 asset_tag_str;
++    u8 part_no_str;
++    u8 core_count;
++    u8 core_enabled;
++    u8 thread_count;
++    u16 processor_characteristics;
++} PACKED;
++
++/* SMBIOS type 7 - Cache Information (v2.0) */
++struct smbios_type_7 {
++    struct smbios_structure_header header;
++    u8 socket_designation_str;
++    u16 cache_config;
++    u16 max_cache_size;
++    u16 installed_cache_size;
++    u16 supported_sram_type;
++    u16 current_sram_type;
++    u8 cache_speed;
++    u8 error_correction;
++    u8 system_cache_type;
++    u8 associativity;
+ } PACKED;
+ 
+ /* SMBIOS type 16 - Physical Memory Array
+@@ -127,6 +165,12 @@
+     u8 bank_locator_str;
+     u8 memory_type;
+     u16 type_detail;
++    u16 speed;
++    u8 manufactor_str;
++    u8 serial_str;
++    u8 asset_tag_str;
++    u8 part_no_str;
++    u8 attributes;
+ } PACKED;
+ 
+ /* SMBIOS type 19 - Memory Array Mapped Address */
+diff -Naur a/src/std/smbios.h.orig b/src/std/smbios.h.orig
+--- a/src/std/smbios.h.orig	1970-01-01 00:00:00.000000000 +0000
++++ b/src/std/smbios.h.orig	2013-09-25 11:34:29.642889620 +0000
+@@ -0,0 +1,165 @@
++#ifndef __SMBIOS_H
++#define __SMBIOS_H
++
++#include "types.h" // u32
++
++/* SMBIOS entry point -- must be written to a 16-bit aligned address
++   between 0xf0000 and 0xfffff.
++ */
++struct smbios_entry_point {
++    char anchor_string[4];
++    u8 checksum;
++    u8 length;
++    u8 smbios_major_version;
++    u8 smbios_minor_version;
++    u16 max_structure_size;
++    u8 entry_point_revision;
++    u8 formatted_area[5];
++    char intermediate_anchor_string[5];
++    u8 intermediate_checksum;
++    u16 structure_table_length;
++    u32 structure_table_address;
++    u16 number_of_structures;
++    u8 smbios_bcd_revision;
++} PACKED;
++
++/* This goes at the beginning of every SMBIOS structure. */
++struct smbios_structure_header {
++    u8 type;
++    u8 length;
++    u16 handle;
++} PACKED;
++
++/* SMBIOS type 0 - BIOS Information */
++struct smbios_type_0 {
++    struct smbios_structure_header header;
++    u8 vendor_str;
++    u8 bios_version_str;
++    u16 bios_starting_address_segment;
++    u8 bios_release_date_str;
++    u8 bios_rom_size;
++    u8 bios_characteristics[8];
++    u8 bios_characteristics_extension_bytes[2];
++    u8 system_bios_major_release;
++    u8 system_bios_minor_release;
++    u8 embedded_controller_major_release;
++    u8 embedded_controller_minor_release;
++} PACKED;
++
++/* SMBIOS type 1 - System Information */
++struct smbios_type_1 {
++    struct smbios_structure_header header;
++    u8 manufacturer_str;
++    u8 product_name_str;
++    u8 version_str;
++    u8 serial_number_str;
++    u8 uuid[16];
++    u8 wake_up_type;
++    u8 sku_number_str;
++    u8 family_str;
++} PACKED;
++
++/* SMBIOS type 3 - System Enclosure (v2.3) */
++struct smbios_type_3 {
++    struct smbios_structure_header header;
++    u8 manufacturer_str;
++    u8 type;
++    u8 version_str;
++    u8 serial_number_str;
++    u8 asset_tag_number_str;
++    u8 boot_up_state;
++    u8 power_supply_state;
++    u8 thermal_state;
++    u8 security_status;
++    u32 oem_defined;
++    u8 height;
++    u8 number_of_power_cords;
++    u8 contained_element_count;
++    // contained elements follow
++} PACKED;
++
++/* SMBIOS type 4 - Processor Information (v2.0) */
++struct smbios_type_4 {
++    struct smbios_structure_header header;
++    u8 socket_designation_str;
++    u8 processor_type;
++    u8 processor_family;
++    u8 processor_manufacturer_str;
++    u32 processor_id[2];
++    u8 processor_version_str;
++    u8 voltage;
++    u16 external_clock;
++    u16 max_speed;
++    u16 current_speed;
++    u8 status;
++    u8 processor_upgrade;
++    u16 l1_cache_handle;
++    u16 l2_cache_handle;
++    u16 l3_cache_handle;
++} PACKED;
++
++/* SMBIOS type 16 - Physical Memory Array
++ *   Associated with one type 17 (Memory Device).
++ */
++struct smbios_type_16 {
++    struct smbios_structure_header header;
++    u8 location;
++    u8 use;
++    u8 error_correction;
++    u32 maximum_capacity;
++    u16 memory_error_information_handle;
++    u16 number_of_memory_devices;
++} PACKED;
++
++/* SMBIOS type 17 - Memory Device
++ *   Associated with one type 19
++ */
++struct smbios_type_17 {
++    struct smbios_structure_header header;
++    u16 physical_memory_array_handle;
++    u16 memory_error_information_handle;
++    u16 total_width;
++    u16 data_width;
++    u16 size;
++    u8 form_factor;
++    u8 device_set;
++    u8 device_locator_str;
++    u8 bank_locator_str;
++    u8 memory_type;
++    u16 type_detail;
++} PACKED;
++
++/* SMBIOS type 19 - Memory Array Mapped Address */
++struct smbios_type_19 {
++    struct smbios_structure_header header;
++    u32 starting_address;
++    u32 ending_address;
++    u16 memory_array_handle;
++    u8 partition_width;
++} PACKED;
++
++/* SMBIOS type 20 - Memory Device Mapped Address */
++struct smbios_type_20 {
++    struct smbios_structure_header header;
++    u32 starting_address;
++    u32 ending_address;
++    u16 memory_device_handle;
++    u16 memory_array_mapped_address_handle;
++    u8 partition_row_position;
++    u8 interleave_position;
++    u8 interleaved_data_depth;
++} PACKED;
++
++/* SMBIOS type 32 - System Boot Information */
++struct smbios_type_32 {
++    struct smbios_structure_header header;
++    u8 reserved[6];
++    u8 boot_status;
++} PACKED;
++
++/* SMBIOS type 127 -- End-of-table */
++struct smbios_type_127 {
++    struct smbios_structure_header header;
++} PACKED;
++
++#endif // smbios.h
