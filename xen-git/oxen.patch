diff -Naur xen/tools/blktap/drivers/Makefile xen-a/tools/blktap/drivers/Makefile
--- xen/tools/blktap/drivers/Makefile	2013-08-20 14:59:43.879332341 -0600
+++ xen-a/tools/blktap/drivers/Makefile	2013-08-20 15:15:06.613332341 -0600
@@ -38,8 +38,9 @@
 CFLAGS += $(PTHREAD_CFLAGS)
 LDFLAGS += $(PTHREAD_LDFLAGS)
 
-LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
-LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz
+LDLIBS_xen := $(LDLIBS_libxenctrl) $(LDLIBS_libxenstore)
+LDLIBS_blktapctrl := $(MEMSHRLIBS) $(LDLIBS_xen) -L../lib -lblktap -lrt -lm $(PTHREAD_LIBS)
+LDLIBS_img := $(AIOLIBS) $(CRYPT_LIB) $(PTHREAD_LIBS) -lz $(LDLIBS_xen)
 
 BLK-OBJS-y  := block-aio.o
 BLK-OBJS-y  += block-sync.o
@@ -47,6 +48,7 @@
 BLK-OBJS-y  += block-ram.o
 BLK-OBJS-y  += block-qcow.o
 BLK-OBJS-y  += block-qcow2.o
+BLK-OBJS-y  += block-cdrom.o
 BLK-OBJS-y  += aes.o
 BLK-OBJS-y  += tapaio.o
 BLK-OBJS-$(CONFIG_Linux) += blk_linux.o
diff -Naur xen/tools/blktap/drivers/blktapctrl.c xen-a/tools/blktap/drivers/blktapctrl.c
--- xen/tools/blktap/drivers/blktapctrl.c	2013-08-20 14:59:43.880332341 -0600
+++ xen-a/tools/blktap/drivers/blktapctrl.c	2013-08-20 15:16:39.765332341 -0600
@@ -61,6 +61,9 @@
 #include "list.h"
 #include "xs_api.h" /* for xs_fire_next_watch() */
 
+#undef DPRINTF
+#define DPRINTF(_f, _a...) ((void)0)
+
 #define PIDFILE "/var/run/blktapctrl.pid"
 
 #define NUM_POLL_FDS 2
diff -Naur xen/tools/blktap/drivers/block-cdrom.c xen-a/tools/blktap/drivers/block-cdrom.c
--- xen/tools/blktap/drivers/block-cdrom.c	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/tools/blktap/drivers/block-cdrom.c	2013-08-20 15:15:26.218332341 -0600
@@ -0,0 +1,568 @@
+/* block-cdrom.c
+ *
+ * simple slow synchronous cdrom disk implementation. Based off
+ * of block-sync.c
+ *
+ * (c) 2006 Andrew Warfield and Julian Chesterfield
+ * (c) 2008 Novell Inc. <plc@novell.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation; or, when distributed
+ * separately from the Linux kernel or incorporated into other
+ * software packages, subject to the following license:
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <sys/statvfs.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/mount.h>
+
+#include "tapdisk.h"
+#include <xen/io/cdromif.h>
+
+struct tdcdrom_state {
+	int fd;
+	int xs_fd;        /* for xen event polling */
+	int media_present;
+	int media_changed;
+	struct xs_handle *xs_handle;
+	char *dev_name;
+	int dev_type;
+	td_flag_t flags;
+};
+
+#define BLOCK_DEVICE   0
+#define FILE_DEVICE    1
+#define CDROM_DEFAULT_SECTOR_SIZE 2048
+#define CDROM_DEFAULT_SIZE 2000000000
+
+/*Get Image size, secsize*/
+static void get_image_info(struct disk_driver *dd)
+{
+	int ret;
+	long size;
+	unsigned long total_size;
+	struct statvfs statBuf;
+	struct stat stat;
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+
+	s->size = 0;
+	s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+	s->info = (VDISK_CDROM | VDISK_REMOVABLE | VDISK_READONLY);
+	prv->media_present = 0;
+
+	ret = fstat(prv->fd, &stat);
+	if (ret != 0) {
+		DPRINTF("ERROR: fstat failed, Couldn't stat image");
+		return;
+	}
+
+	if (S_ISBLK(stat.st_mode)) {
+		/*Accessing block device directly*/
+		int status;
+
+		prv->dev_type = BLOCK_DEVICE;
+		status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+		if (status == CDS_DISC_OK) {
+			prv->media_present = 1;
+			if ((ret =ioctl(prv->fd,BLKGETSIZE,&s->size))!=0) {
+				DPRINTF("ERR: BLKGETSIZE failed, couldn't stat image");
+				s->size = CDROM_DEFAULT_SIZE;
+			}
+		}
+		else {
+			s->size = CDROM_DEFAULT_SIZE;
+		}
+		/*Get the sector size*/
+#if defined(BLKSSZGET)
+		{
+			int arg;
+			s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+			ioctl(prv->fd, BLKSSZGET, &s->sector_size);
+
+			if (s->sector_size != CDROM_DEFAULT_SECTOR_SIZE)
+				DPRINTF("Note: sector size is %llu (not %d)\n",
+					(long long unsigned)s->sector_size,
+					CDROM_DEFAULT_SECTOR_SIZE);
+		}
+#else
+		s->sector_size = CDROM_DEFAULT_SECTOR_SIZE;
+#endif
+		DPRINTF("Block Device: Image size: %llu"
+			" media_present: %d sector_size: %llu\n",
+			(long long unsigned)s->size, prv->media_present,
+			(long long unsigned)s->sector_size);
+	} else {
+		/*Local file? try fstat instead*/
+		prv->dev_type = FILE_DEVICE;
+		prv->media_present = 1;
+		s->size = (stat.st_size >> SECTOR_SHIFT);
+		s->sector_size = DEFAULT_SECTOR_SIZE;
+		DPRINTF("Local File: Image size: %llu\n",
+				(long long unsigned)s->size);
+	}
+	return;
+}
+
+static inline void init_fds(struct disk_driver *dd)
+{
+	int i;
+	struct tdcdrom_state *prv = dd->private;
+
+	for(i = 0; i < MAX_IOFD; i++)
+		dd->io_fd[i] = 0;
+
+	prv->xs_handle = xs_daemon_open();
+	prv->xs_fd = xs_fileno(prv->xs_handle);
+	dd->io_fd[0] = prv->xs_fd;
+}
+
+void open_device (struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+	int o_flags;
+
+	o_flags = O_NONBLOCK | O_LARGEFILE |
+		((prv->flags == TD_RDONLY) ? O_RDONLY : O_RDWR);
+
+	if (prv->fd < 0) {
+		prv->fd = open(prv->dev_name, o_flags);
+		if (prv->fd == -1) {
+			DPRINTF("Unable tp open: (%s)\n", prv->dev_name);
+			return;
+		}
+	}
+
+	if (prv->fd != -1) {
+
+		get_image_info(dd);
+
+		if (prv->dev_type == BLOCK_DEVICE) {
+			int status;
+			status = ioctl(prv->fd, CDROM_DRIVE_STATUS, CDSL_CURRENT);
+			switch (status) {
+				case CDS_DISC_OK:
+					prv->media_present = 1;
+					break;
+				default:
+					prv->media_present = 0;
+			}
+		}
+		else
+			prv->media_present = 1;
+	}
+}
+
+/*
+ * Main entry point, called when first loaded
+ */
+int tdcdrom_open (struct disk_driver *dd, const char *name, td_flag_t flags)
+{
+	int ret;
+	struct tdcdrom_state *prv = dd->private;
+
+	ret = asprintf(&prv->dev_name, "%s", name);
+	if (ret < 0) {
+		prv->dev_name = NULL;
+		goto out;
+	}
+	prv->fd = -1;
+	prv->media_changed = 0;
+	prv->media_present = 0;
+	prv->flags = flags;
+	init_fds(dd);
+
+	open_device(dd);
+
+out:
+	return ret;
+}
+
+int tdcdrom_queue_read(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	size    = nb_sectors * 512;
+	offset  = sector * (uint64_t)512;
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = read(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_write(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	if (prv->fd == -1 || prv->media_present == 0) {
+		ret = 0 - ENOMEDIUM;
+		return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+	}
+	ret = lseek(prv->fd, offset, SEEK_SET);
+	if (ret != (off_t)-1) {
+		ret = write(prv->fd, buf, size);
+		if (ret != size) {
+			ret = 0 - errno;
+		} else {
+			ret = 1;
+		}
+	} else ret = 0 - errno;
+
+	return cb(dd, (ret < 0) ? ret : 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_queue_packet(struct disk_driver *dd, uint64_t sector,
+		int nb_sectors, char *buf, td_callback_t cb,
+		int id, void *private)
+{
+	struct td_state     *s   = dd->td_state;
+	struct tdcdrom_state *prv = dd->private;
+	int      size    = nb_sectors * s->sector_size;
+	uint64_t offset  = sector * (uint64_t)s->sector_size;
+	int ret = 0;
+
+	union xen_block_packet *sp;
+	struct xen_cdrom_packet *xcp;
+	struct xen_cdrom_support *xcs;
+	struct xen_cdrom_open *xco;
+	struct xen_cdrom_media_info *xcmi;
+	struct xen_cdrom_media_changed *xcmc;
+	struct cdrom_generic_command cgc;
+	struct vcd_generic_command * vgc;
+	struct request_sense sense;
+
+	sp = (union xen_block_packet *)buf;
+	switch(sp->type) {
+		case XEN_TYPE_CDROM_SUPPORT:
+			xcs = &(sp->xcs);
+			xcs->err = 0;
+			xcs->ret = 0;
+			xcs->supported = 1;
+			break;
+		case XEN_TYPE_CDROM_PACKET:
+			xcp = &(sp->xcp);
+			xcp->err = 0;
+			xcp->ret = 0;
+			vgc = (struct vcd_generic_command *)(buf + PACKET_PAYLOAD_OFFSET);
+
+			memset( &cgc, 0, sizeof(struct cdrom_generic_command));
+			memcpy(cgc.cmd, vgc->cmd, CDROM_PACKET_SIZE);
+			cgc.stat = vgc->stat;
+			cgc.data_direction = vgc->data_direction;
+			cgc.quiet = vgc->quiet;
+			cgc.timeout = vgc->timeout;
+
+			if (prv->fd == -1) {
+				xcp = &(sp->xcp);
+				xcp->ret = -1;
+				xcp->err =  0 - ENODEV;
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			if (prv->dev_type == FILE_DEVICE) {
+				DPRINTF("%s() FILE_DEVICE inappropriate packetcmd \n",__func__);
+				return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+			}
+			switch ( cgc.cmd[0]) {
+				case GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
+					{
+						int lock;
+						lock = cgc.cmd[4] & 1;
+						if (ioctl (prv->fd, CDROM_LOCKDOOR, lock) < 0) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+					}
+					break;
+				case GPCMD_START_STOP_UNIT:
+					{
+						int start, eject;
+						start = cgc.cmd[4] & 1;
+						eject = (cgc.cmd[4] >> 1) & 1;
+						if (eject && !start) {
+							if (ioctl (prv->fd, CDROMEJECT, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						} else if (eject && start) {
+							if (ioctl (prv->fd, CDROMCLOSETRAY, NULL) < 0) {
+								xcp->err = -(errno);
+								xcp->ret = -1;
+							}
+						}
+					}
+					break;
+				default:
+					{
+						if (vgc->sense_offset) {
+							cgc.sense = &sense;
+						}
+						if (vgc->buffer_offset) {
+							cgc.buffer = malloc(vgc->buflen);
+							memcpy(cgc.buffer, (char *)sp + PACKET_BUFFER_OFFSET, vgc->buflen);
+							cgc.buflen = vgc->buflen;
+						}
+						if (ioctl (prv->fd, CDROM_SEND_PACKET, &cgc) < 0 ) {
+							xcp->err = -(errno);
+							xcp->ret = -1;
+						}
+						if (cgc.sense) {
+							memcpy((char *)sp + PACKET_SENSE_OFFSET, cgc.sense, sizeof(struct request_sense));
+						}
+						if (cgc.buffer) {
+							vgc->buflen = cgc.buflen;
+							memcpy((char *)sp + PACKET_BUFFER_OFFSET, cgc.buffer, cgc.buflen);
+							free(cgc.buffer);
+						}
+						break;
+					}
+			}
+			break;
+		case XEN_TYPE_CDROM_OPEN:
+			{
+				unsigned int len;
+				struct stat statbuf;
+				int major = 0;
+				int minor = 0;
+
+				if (stat (prv->dev_name, &statbuf) == 0) {
+					major = major (statbuf.st_rdev);
+					minor = minor (statbuf.st_rdev);
+				}
+				xco = &(sp->xco);
+				xco->err = 0;
+				xco->ret = 0;
+				if (xco->payload_offset) {
+					char *present;
+					char *buf;
+					char *num;
+					char *nodename;
+					char media_present[2];
+					nodename = (char *)sp + xco->payload_offset;
+					if (asprintf(&buf, "%s/media-present", nodename) < 0)
+						goto out_payload_offset;
+					present = xs_read(prv->xs_handle, XBT_NULL, buf, &len);
+					if (present) {
+						free(buf);
+						goto out_payload_offset_free;
+					}
+
+					sprintf(media_present, "%d", prv->media_present);
+					xs_write(prv->xs_handle, XBT_NULL, buf, media_present, strlen(media_present));
+					xs_watch(prv->xs_handle, buf, "media-present");
+					free(buf);
+
+					if (asprintf(&buf, "%s/params", nodename) < 0)
+						goto out_payload_offset_free;
+					xs_watch(prv->xs_handle, buf, "params");
+					free(buf);
+
+					if (asprintf(&num, "%x:%x", major, minor) < 0)
+						goto out_payload_offset_free;
+					if (asprintf(&buf, "%s/physical-device", nodename) < 0) {
+						free(num);
+						goto out_payload_offset_free;
+					}
+					xs_write(prv->xs_handle, XBT_NULL, buf, num, strlen(num));
+					free(buf);
+					free(num);
+out_payload_offset_free:
+					free(present);
+out_payload_offset:
+					;
+				}
+
+				xco->media_present = prv->media_present;
+				xco->sectors = 0;
+				xco->sector_size = 2048;
+				if (prv->media_present && prv->fd != -1 ) {
+					get_image_info(dd);
+					xco->sectors = s->size;
+					xco->sector_size = s->sector_size;
+				}
+			}
+			break;
+		case XEN_TYPE_CDROM_MEDIA_CHANGED:
+			xcmc = &(sp->xcmc);
+			xcmc->err = 0;
+			xcmc->ret = 0;
+			xcmc->media_changed = prv->media_changed;
+			prv->media_changed = 0;
+			break;
+		default:
+			xcp = &(sp->xcp);
+			xcp->err = -EINVAL;
+			xcp->ret = -1;
+			break;
+	}
+
+	return cb(dd, (ret < 0) ? ret: 0, sector, nb_sectors, id, private);
+}
+
+int tdcdrom_submit(struct disk_driver *dd)
+{
+	return 0;
+}
+
+int tdcdrom_close(struct disk_driver *dd)
+{
+	struct tdcdrom_state *prv = dd->private;
+
+	if (prv->fd != -1) {
+		close(prv->fd);
+		prv->fd = -1;
+	}
+	prv->xs_fd = -1;
+	xs_daemon_close(prv->xs_handle);
+	free(prv->dev_name);
+
+	return 0;
+}
+
+void tdcdrom_process_media_change_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *media_present;
+    unsigned int len;
+
+	media_present = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+    if (media_present == NULL)
+        return;
+
+	if (strcmp(media_present, "0") == 0) {
+		close(prv->fd);
+		prv->fd = -1;
+		prv->media_present = 0;
+	}
+	else {
+		open_device(dd);
+		prv->media_changed = 1;
+	}
+	free(media_present);
+}
+
+void tdcrom_process_params_event(struct disk_driver *dd, char **vec)
+{
+    struct tdcdrom_state *prv = dd->private;
+    char *params;
+    unsigned int len;
+
+	params = xs_read(prv->xs_handle, XBT_NULL, vec[XS_WATCH_PATH], &len);
+	if (params) {
+		char *cp = strchr(params, ':');
+		if (cp) {
+			cp++;
+			if (prv->dev_name)
+				free(prv->dev_name);
+			if (asprintf(&prv->dev_name, "%s", cp) < 0) {
+				prv->dev_name = NULL;
+				return;
+			}
+			if (prv->fd != -1) {
+				close(prv->fd);
+				prv->fd = -1;
+			}
+			open_device(dd);
+			prv->media_changed = 1;
+		}
+		free(params);
+	}
+}
+
+int tdcdrom_do_callbacks(struct disk_driver *dd, int sid)
+{
+	struct tdcdrom_state *prv = dd->private;
+	char **vec;
+	unsigned int num;
+
+	vec = xs_read_watch(prv->xs_handle, &num);
+	if (!vec)
+		return 1;
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "media-present")) {
+        tdcdrom_process_media_change_event(dd, vec);
+        goto out;
+    }
+
+    if (!strcmp(vec[XS_WATCH_TOKEN], "params")) {
+        tdcrom_process_params_event(dd, vec);
+        goto out;
+    }
+
+ out:
+    free(vec);
+	return 1;
+}
+
+int tdcdrom_get_parent_id(struct disk_driver *dd, struct disk_id *id)
+{
+	return TD_NO_PARENT;
+}
+
+int tdcdrom_validate_parent(struct disk_driver *dd,
+		struct disk_driver *parent, td_flag_t flags)
+{
+	return -EINVAL;
+}
+
+struct tap_disk tapdisk_cdrom = {
+	.disk_type           = "tapdisk_cdrom",
+	.private_data_size   = sizeof(struct tdcdrom_state),
+	.td_open             = tdcdrom_open,
+	.td_queue_read       = tdcdrom_queue_read,
+	.td_queue_packet     = tdcdrom_queue_packet,
+	.td_queue_write      = tdcdrom_queue_write,
+	.td_submit           = tdcdrom_submit,
+	.td_close            = tdcdrom_close,
+	.td_do_callbacks     = tdcdrom_do_callbacks,
+	.td_get_parent_id    = tdcdrom_get_parent_id,
+	.td_validate_parent  = tdcdrom_validate_parent
+};
diff -Naur xen/tools/blktap/drivers/tapdisk.c xen-a/tools/blktap/drivers/tapdisk.c
--- xen/tools/blktap/drivers/tapdisk.c	2013-08-20 14:59:43.884332341 -0600
+++ xen-a/tools/blktap/drivers/tapdisk.c	2013-08-20 15:15:26.246332341 -0600
@@ -735,6 +735,22 @@
 					goto out;
 				}
 				break;
+			case BLKIF_OP_PACKET:
+				ret = 0;
+				if (drv->td_queue_packet)
+					ret = drv->td_queue_packet(dd, sector_nr,
+							nsects, page,
+							send_responses,
+							idx, (void *)(long)i);
+				if (ret > 0) dd->early += ret;
+				else if (ret == -EBUSY) {
+					/* put req back on queue */
+					--info->fe_ring.req_cons;
+					info->busy.req     = req;
+					info->busy.seg_idx = i;
+					goto out;
+				}
+				break;
 			default:
 				DPRINTF("Unknown block operation\n");
 				break;
diff -Naur xen/tools/blktap/drivers/tapdisk.h xen-a/tools/blktap/drivers/tapdisk.h
--- xen/tools/blktap/drivers/tapdisk.h	2013-08-20 14:59:43.885332341 -0600
+++ xen-a/tools/blktap/drivers/tapdisk.h	2013-08-20 15:15:26.264332341 -0600
@@ -137,6 +137,9 @@
 	int (*td_get_parent_id)  (struct disk_driver *dd, struct disk_id *id);
 	int (*td_validate_parent)(struct disk_driver *dd, 
 				  struct disk_driver *p, td_flag_t flags);
+	int (*td_queue_packet)  (struct disk_driver *dd, uint64_t sector,
+				  int nb_sectors, char *buf, td_callback_t cb,
+				  int id, void *prv);
 };
 
 typedef struct disk_info {
@@ -160,6 +163,7 @@
 extern struct tap_disk tapdisk_ram;
 extern struct tap_disk tapdisk_qcow;
 extern struct tap_disk tapdisk_qcow2;
+extern struct tap_disk tapdisk_cdrom;
 
 
 /*Define Individual Disk Parameters here */
@@ -229,6 +233,17 @@
 #endif
 };
 
+static disk_info_t cdrom_disk = {
+	DISK_TYPE_CDROM,
+	"raw image (cdrom)",
+	"cdrom",
+	0,
+	0,
+#ifdef TAPDISK
+	&tapdisk_cdrom,
+#endif
+};
+
 /*Main disk info array */
 static disk_info_t *dtypes[] = {
 	&aio_disk,
@@ -237,6 +252,7 @@
 	&ram_disk,
 	&qcow_disk,
 	&qcow2_disk,
+	&cdrom_disk,
 };
 
 typedef struct driver_list_entry {
diff -Naur xen/tools/blktap/lib/blktaplib.h xen-a/tools/blktap/lib/blktaplib.h
--- xen/tools/blktap/lib/blktaplib.h	2013-08-20 14:59:43.885332341 -0600
+++ xen-a/tools/blktap/lib/blktaplib.h	2013-08-20 15:15:26.294332341 -0600
@@ -219,6 +219,7 @@
 #define DISK_TYPE_RAM      3
 #define DISK_TYPE_QCOW     4
 #define DISK_TYPE_QCOW2    5
+#define DISK_TYPE_CDROM    6
 
 /* xenstore/xenbus: */
 #define DOMNAME "Domain-0"
diff -Naur xen/tools/console/client/main.c xen-a/tools/console/client/main.c
--- xen/tools/console/client/main.c	2013-08-20 14:59:43.927332341 -0600
+++ xen-a/tools/console/client/main.c	2013-08-20 15:10:58.333332341 -0600
@@ -96,6 +96,7 @@
  * Assumes there is already a watch set in the store for this path. */
 {
 	struct timeval tv;
+	struct flock lock;
 	fd_set watch_fdset;
 	int xs_fd = xs_fileno(xs), pty_fd = -1;
 	int start, now;
@@ -122,6 +123,12 @@
 				if (pty_fd == -1) 
 					err(errno, "Could not open tty `%s'", 
 					    pty_path);
+				memset(&lock, 0, sizeof(lock));
+				lock.l_type = F_WRLCK;
+				lock.l_whence = SEEK_SET;
+				if (fcntl(pty_fd, F_SETLK, &lock) != 0)
+					err(errno, "Could not lock tty '%s'",
+					    pty_path);
 				free(pty_path);
 			}
 		}
diff -Naur xen/tools/hotplug/Linux/init.d/sysconfig.xencommons xen-a/tools/hotplug/Linux/init.d/sysconfig.xencommons
--- xen/tools/hotplug/Linux/init.d/sysconfig.xencommons	2013-08-20 14:59:43.984332341 -0600
+++ xen-a/tools/hotplug/Linux/init.d/sysconfig.xencommons	2013-08-20 15:10:19.773332341 -0600
@@ -1,15 +1,31 @@
+## Path: System/Virtualization
+## Type: string
+## Default: "none"
+#
 # Log xenconsoled messages (cf xl dmesg)
 #XENCONSOLED_TRACE=[none|guest|hv|all]
 
+## Type: string
+## Default: xenstored
+#
 # Select xenstored implementation
 #XENSTORED=[oxenstored|xenstored]
 
+## Type: string
+## Default: Not defined, tracing off
+#
 # Log xenstored messages
 #XENSTORED_TRACE=[yes|on|1]
 
+## Type: string
+## Default: "/var/lib/xenstored"
+#
 # Running xenstored on XENSTORED_ROOTDIR
 #XENSTORED_ROOTDIR=/var/lib/xenstored
 
+## Type: string
+## Default: Not defined, xenbackendd debug mode off
+#
 # Running xenbackendd in debug mode
 #XENBACKENDD_DEBUG=[yes|on|1]
 
diff -Naur xen/tools/hotplug/Linux/xen-backend.rules xen-a/tools/hotplug/Linux/xen-backend.rules
--- xen/tools/hotplug/Linux/xen-backend.rules	2013-08-20 14:59:43.992332341 -0600
+++ xen-a/tools/hotplug/Linux/xen-backend.rules	2013-08-20 15:11:57.528332341 -0600
@@ -12,4 +12,5 @@
 KERNEL=="gntdev", NAME="xen/%k", MODE="0600"
 KERNEL=="pci_iomul", NAME="xen/%k", MODE="0600"
 KERNEL=="tapdev[a-z]*", NAME="xen/blktap-2/tapdev%m", MODE="0600"
-SUBSYSTEM=="net", KERNEL=="vif*-emu", ACTION=="add", ENV{UDEV_CALL}="1", RUN+="/etc/xen/scripts/vif-setup $env{ACTION} type_if=tap"
+SUBSYSTEM=="net", KERNEL=="vif*-emu", ACTION=="add", ENV{UDEV_CALL}="1", TEST=="/proc/xen" RUN+="/etc/xen/scripts/vif-setup $env{ACTION} type_if=tap"
+KERNELS=="xen", KERNEL=="xvd*", SUBSYSTEM=="block", OPTIONS+="last_rule"
diff -Naur xen/tools/libxc/xc_suspend.c xen-a/tools/libxc/xc_suspend.c
--- xen/tools/libxc/xc_suspend.c	2013-08-20 14:59:44.071332341 -0600
+++ xen-a/tools/libxc/xc_suspend.c	2013-08-20 15:13:03.427332341 -0600
@@ -16,8 +16,43 @@
 
 #include "xc_private.h"
 #include "xenguest.h"
+#include <signal.h>
+#ifdef __MINIOS__
+extern int kill (__pid_t __pid, int __sig);
+#endif
 
 #define SUSPEND_LOCK_FILE "/var/lib/xen/suspend_evtchn"
+/* cleanup obsolete suspend lock file which is unlinked for any reason,
+so that current process can get lock */
+static void clean_obsolete_lock(int domid)
+{
+    int fd, pid, n;
+    char buf[128];
+    char suspend_file[256];
+
+    snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
+        SUSPEND_LOCK_FILE, domid);
+    fd = open(suspend_file, O_RDWR);
+
+    if (fd < 0)
+        return;
+
+    n = read(fd, buf, 127);
+
+    close(fd);
+
+    if (n > 0)
+    {
+        sscanf(buf, "%d", &pid);
+        /* pid does not exist, this lock file is obsolete, just delete it */
+        if ( kill(pid,0) )
+        {
+            unlink(suspend_file);
+            return;
+        }
+    }
+}
+
 static int lock_suspend_event(xc_interface *xch, int domid)
 {
     int fd, rc;
@@ -27,6 +62,7 @@
 
     snprintf(suspend_file, sizeof(suspend_file), "%s_%d_lock.d",
 	    SUSPEND_LOCK_FILE, domid);
+    clean_obsolete_lock(domid);
     mask = umask(022);
     fd = open(suspend_file, O_CREAT | O_EXCL | O_RDWR, 0666);
     if (fd < 0)
@@ -41,6 +77,9 @@
     rc = write_exact(fd, buf, strlen(buf));
     close(fd);
 
+    if(rc)
+    unlink(suspend_file);
+
     return rc;
 }
 
@@ -127,8 +166,7 @@
     return suspend_evtchn;
 
 cleanup:
-    if (suspend_evtchn != -1)
-        xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
+    xc_suspend_evtchn_release(xch, xce, domid, suspend_evtchn);
 
     return -1;
 }
diff -Naur xen/tools/libxen/src/xen_common.c xen-a/tools/libxen/src/xen_common.c
--- xen/tools/libxen/src/xen_common.c	2013-08-20 14:59:44.092332341 -0600
+++ xen-a/tools/libxen/src/xen_common.c	2013-08-20 15:14:01.346332341 -0600
@@ -904,8 +904,15 @@
             0 != strcmp((char *)value_node->children->name, "struct") ||
             value_node->children->children == NULL)
         {
+#if PERMISSIVE
+            fprintf(stderr,
+                    "Expected Map from the server, but didn't get one\n");
+            ((arbitrary_map **)value)[slot] = NULL;
+#else
+
             server_error(s,
                          "Expected Map from the server, but didn't get it");
+#endif
         }
         else
         {
diff -Naur xen/xen/Makefile xen-a/xen/Makefile
--- xen/xen/Makefile	2013-08-20 14:59:44.476332341 -0600
+++ xen-a/xen/Makefile	2013-08-20 15:08:57.221332341 -0600
@@ -1,3 +1,4 @@
+export XEN_CHANGESET     = unavailable
 # This is the correct place to edit the build version.
 # All other places this is stored (eg. compile.h) should be autogenerated.
 export XEN_VERSION       = 4
@@ -120,7 +121,7 @@
 	@rm -f $@1 $@2
 
 # compile.h contains dynamic build info. Rebuilt on every 'make' invocation.
-include/xen/compile.h: include/xen/compile.h.in .banner
+include/xen/compile.h: include/xen/compile.h.in
 	@sed -e 's/@@date@@/$(shell LC_ALL=C date)/g' \
 	    -e 's/@@time@@/$(shell LC_ALL=C date +%T)/g' \
 	    -e 's/@@whoami@@/$(XEN_WHOAMI)/g' \
@@ -130,10 +131,9 @@
 	    -e 's/@@version@@/$(XEN_VERSION)/g' \
 	    -e 's/@@subversion@@/$(XEN_SUBVERSION)/g' \
 	    -e 's/@@extraversion@@/$(XEN_EXTRAVERSION)/g' \
-	    -e 's!@@changeset@@!$(shell tools/scmversion $(XEN_ROOT) || echo "unavailable")!g' \
+ 	    -e 's!@@changeset@@!$(XEN_CHANGESET)!g' \
 	    < include/xen/compile.h.in > $@.new
-	@grep \" .banner >> $@.new
-	@grep -v \" .banner
+	tools/figlet/figlet -d tools/figlet Xen $(XEN_FULLVERSION) >> $@.new
 	@mv -f $@.new $@
 
 include/asm-$(TARGET_ARCH)/asm-offsets.h: arch/$(TARGET_ARCH)/asm-offsets.s
diff -Naur xen/xen/arch/x86/domain.c xen-a/xen/arch/x86/domain.c
--- xen/xen/arch/x86/domain.c	2013-08-20 14:59:44.512332341 -0600
+++ xen-a/xen/arch/x86/domain.c	2013-08-20 15:04:09.453332341 -0600
@@ -151,15 +151,30 @@
 
     printk("Memory pages belonging to domain %u:\n", d->domain_id);
 
-    if ( d->tot_pages >= 10 )
+    if ( d->tot_pages >= 10 && d->is_dying < DOMDYING_dead )
     {
         printk("    DomPage list too long to display\n");
     }
     else
     {
+        unsigned long total[PGT_type_mask
+                            / (PGT_type_mask & -PGT_type_mask) + 1] = {};
+
         spin_lock(&d->page_alloc_lock);
         page_list_for_each ( page, &d->page_list )
         {
+            unsigned int index = (page->u.inuse.type_info & PGT_type_mask)
+                                 / (PGT_type_mask & -PGT_type_mask);
+
+            if ( ++total[index] > 16 )
+            {
+                switch ( page->u.inuse.type_info & PGT_type_mask )
+                {
+                case PGT_none:
+                case PGT_writable_page:
+                    continue;
+                }
+            }
             printk("    DomPage %p: caf=%08lx, taf=%" PRtype_info "\n",
                    _p(page_to_mfn(page)),
                    page->count_info, page->u.inuse.type_info);
diff -Naur xen/xen/arch/x86/hvm/stdvga.c xen-a/xen/arch/x86/hvm/stdvga.c
--- xen/xen/arch/x86/hvm/stdvga.c	2013-08-20 14:59:44.603332341 -0600
+++ xen-a/xen/arch/x86/hvm/stdvga.c	2013-08-20 15:14:19.543332341 -0600
@@ -135,7 +135,10 @@
 
     /* When in standard vga mode, emulate here all writes to the vram buffer
      * so we can immediately satisfy reads without waiting for qemu. */
-    s->stdvga = (s->sr[7] == 0x00);
+    s->stdvga =
+        (s->sr[7] == 0x00) &&  /* standard vga mode */
+        (s->gr[6] == 0x05);    /* misc graphics register w/ MemoryMapSelect=1
+                                * 0xa0000-0xaffff (64k region), AlphaDis=1 */
 
     if ( !prev_stdvga && s->stdvga )
     {
diff -Naur xen/xen/arch/x86/io_apic.c xen-a/xen/arch/x86/io_apic.c
--- xen/xen/arch/x86/io_apic.c	2013-08-20 14:59:44.613332341 -0600
+++ xen-a/xen/arch/x86/io_apic.c	2013-08-20 15:08:39.595332341 -0600
@@ -2026,7 +2026,10 @@
         io_apic_irqs = ~PIC_IRQS;
 
     printk("ENABLING IO-APIC IRQs\n");
-    printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    if (!directed_eoi_enabled && !ioapic_ack_forced) {
+        ioapic_ack_new = (nr_ioapics > 1);
+        printk(" -> Using %s ACK method\n", ioapic_ack_new ? "new" : "old");
+    }
 
     if (ioapic_ack_new) {
         ioapic_level_type.ack = irq_complete_move;
diff -Naur xen/xen/arch/x86/platform_hypercall.c xen-a/xen/arch/x86/platform_hypercall.c
--- xen/xen/arch/x86/platform_hypercall.c	2013-08-20 14:59:44.637332341 -0600
+++ xen-a/xen/arch/x86/platform_hypercall.c	2013-08-20 15:03:32.414332341 -0600
@@ -25,7 +25,7 @@
 #include <xen/irq.h>
 #include <asm/current.h>
 #include <public/platform.h>
-#include <acpi/cpufreq/processor_perf.h>
+#include <acpi/cpufreq/cpufreq.h>
 #include <asm/edd.h>
 #include <asm/mtrr.h>
 #include <asm/io_apic.h>
@@ -597,6 +597,41 @@
     }
     break;
 
+    case XENPF_get_cpu_freq:
+    case XENPF_get_cpu_freq_min:
+    case XENPF_get_cpu_freq_max:
+    {
+        struct vcpu *v;
+        const struct cpufreq_policy *policy;
+
+        if ( op->u.get_cpu_freq.vcpu >= current->domain->max_vcpus ||
+             !(v = current->domain->vcpu[op->u.get_cpu_freq.vcpu]) )
+        {
+            ret = -EINVAL;
+            break;
+        }
+
+        policy = per_cpu(cpufreq_cpu_policy, v->processor);
+        switch ( op->cmd & -!!policy )
+        {
+        case XENPF_get_cpu_freq:
+            op->u.get_cpu_freq.freq = policy->cur;
+            break;
+        case XENPF_get_cpu_freq_min:
+            op->u.get_cpu_freq.freq = policy->min;
+            break;
+        case XENPF_get_cpu_freq_max:
+            op->u.get_cpu_freq.freq = policy->max;
+            break;
+        default:
+            op->u.get_cpu_freq.freq = 0;
+            break;
+        }
+        if ( __copy_field_to_guest(u_xenpf_op, op, u.get_cpu_freq.freq) )
+            ret = -EFAULT;
+    }
+    break;
+
     default:
         ret = -ENOSYS;
         break;
diff -Naur xen/xen/include/public/io/blkif.h xen-a/xen/include/public/io/blkif.h
--- xen/xen/include/public/io/blkif.h	2013-08-20 14:59:44.780332341 -0600
+++ xen-a/xen/include/public/io/blkif.h	2013-08-20 15:15:26.306332341 -0600
@@ -444,7 +444,7 @@
  * Used in SLES sources for device specific command packet
  * contained within the request. Reserved for that purpose.
  */
-#define BLKIF_OP_RESERVED_1        4
+#define BLKIF_OP_PACKET        4
 /*
  * Indicate to the backend device that a region of storage is no longer in
  * use, and may be discarded at any time without impact to the client.  If
diff -Naur xen/xen/include/public/io/cdromif.h xen-a/xen/include/public/io/cdromif.h
--- xen/xen/include/public/io/cdromif.h	1969-12-31 17:00:00.000000000 -0700
+++ xen-a/xen/include/public/io/cdromif.h	2013-08-20 15:15:26.307332341 -0600
@@ -0,0 +1,122 @@
+/******************************************************************************
+ * cdromif.h
+ *
+ * Shared definitions between backend driver and Xen guest Virtual CDROM
+ * block device.
+ *
+ * Copyright (c) 2008, Pat Campell  plc@novell.com
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this source file (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use, copy, modify,
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#ifndef __XEN_PUBLIC_IO_CDROMIF_H__
+#define __XEN_PUBLIC_IO_CDROMIF_H__
+
+#include <linux/cdrom.h>
+
+/*
+ * Queries backend for CDROM support
+ */
+#define XEN_TYPE_CDROM_SUPPORT         _IO('c', 1)
+
+struct xen_cdrom_support
+{
+	uint32_t type;
+	int8_t ret;                  /* returned, 0 succeded, -1 error */
+	int8_t err;                  /* returned, backend errno */
+	int8_t supported;            /* returned, 1 supported */
+};
+
+/*
+ * Opens backend device, returns drive geometry or
+ * any encountered errors
+ */
+#define XEN_TYPE_CDROM_OPEN            _IO('c', 2)
+
+struct xen_cdrom_open
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad;
+	int8_t media_present;        /* returned */
+	uint32_t sectors;            /* returned */
+	uint32_t sector_size;        /* returned */
+	int32_t payload_offset;      /* offset to backend node name payload */
+};
+
+/*
+ * Queries backend for media changed status
+ */
+#define XEN_TYPE_CDROM_MEDIA_CHANGED   _IO('c', 3)
+
+struct xen_cdrom_media_changed
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t media_changed;        /* returned */
+};
+
+/*
+ * Sends vcd generic CDROM packet to backend, followed
+ * immediately by the vcd_generic_command payload
+ */
+#define XEN_TYPE_CDROM_PACKET          _IO('c', 4)
+
+struct xen_cdrom_packet
+{
+	uint32_t type;
+	int8_t ret;
+	int8_t err;
+	int8_t pad[2];
+	int32_t payload_offset;      /* offset to struct vcd_generic_command payload */
+};
+
+/* CDROM_PACKET_COMMAND, payload for XEN_TYPE_CDROM_PACKET */
+struct vcd_generic_command
+{
+	uint8_t  cmd[CDROM_PACKET_SIZE];
+	uint8_t  pad[4];
+	uint32_t buffer_offset;
+	uint32_t buflen;
+	int32_t  stat;
+	uint32_t sense_offset;
+	uint8_t  data_direction;
+	uint8_t  pad1[3];
+	int32_t  quiet;
+	int32_t  timeout;
+};
+
+union xen_block_packet
+{
+	uint32_t type;
+	struct xen_cdrom_support xcs;
+	struct xen_cdrom_open xco;
+	struct xen_cdrom_media_changed xcmc;
+	struct xen_cdrom_packet xcp;
+};
+
+#define PACKET_PAYLOAD_OFFSET (sizeof(struct xen_cdrom_packet))
+#define PACKET_SENSE_OFFSET (PACKET_PAYLOAD_OFFSET + sizeof(struct vcd_generic_command))
+#define PACKET_BUFFER_OFFSET (PACKET_SENSE_OFFSET + sizeof(struct request_sense))
+#define MAX_PACKET_DATA (PAGE_SIZE - sizeof(struct xen_cdrom_packet) - \
+            sizeof(struct vcd_generic_command) - sizeof(struct request_sense))
+
+#endif
diff -Naur xen/xen/include/public/platform.h xen-a/xen/include/public/platform.h
--- xen/xen/include/public/platform.h	2013-08-20 14:59:44.786332341 -0600
+++ xen-a/xen/include/public/platform.h	2013-08-20 15:03:32.416332341 -0600
@@ -527,6 +527,16 @@
 typedef struct xenpf_core_parking xenpf_core_parking_t;
 DEFINE_XEN_GUEST_HANDLE(xenpf_core_parking_t);
 
+#define XENPF_get_cpu_freq        ('N' << 24)
+#define XENPF_get_cpu_freq_min    (XENPF_get_cpu_freq + 1)
+#define XENPF_get_cpu_freq_max    (XENPF_get_cpu_freq_min + 1)
+struct xenpf_get_cpu_freq {
+    /* IN variables */
+    uint32_t vcpu;
+    /* OUT variables */
+    uint32_t freq; /* in kHz */
+};
+
 /*
  * ` enum neg_errnoval
  * ` HYPERVISOR_platform_op(const struct xen_platform_op*);
@@ -553,6 +563,7 @@
         struct xenpf_cpu_hotadd        cpu_add;
         struct xenpf_mem_hotadd        mem_add;
         struct xenpf_core_parking      core_parking;
+        struct xenpf_get_cpu_freq      get_cpu_freq;
         uint8_t                        pad[128];
     } u;
 };
