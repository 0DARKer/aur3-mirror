From 8f8c10ee1e589bdf029133cab9b7a0eb46e71bae Mon Sep 17 00:00:00 2001
From: Dave Reisner <d@falconindy.com>
Date: Tue, 26 Apr 2011 17:16:57 -0400
Subject: [PATCH] fixes for yajl 2.x API changes

This isn't intended to be a real fix, but it's a start and at least gets
Kiwi's Clyde working again.
---
 lua_yajl.c |   80 +++++++++++++++++++++++++++---------------------------------
 1 files changed, 36 insertions(+), 44 deletions(-)

diff --git a/lua_yajl.c b/lua_yajl.c
index f4d1613..e944901 100644
--- a/lua_yajl.c
+++ b/lua_yajl.c
@@ -18,7 +18,7 @@ static void js_parser_assert(lua_State* L,
                              yajl_status status,
                              yajl_handle* handle,
                              const unsigned char* json_text,
-                             unsigned int json_text_len,
+                             size_t json_text_len,
                              int expect_complete,
                              const char* file,
                              int line);
@@ -27,7 +27,7 @@ static int got_map_value(lua_State* L);
 
 
 //////////////////////////////////////////////////////////////////////
-static double todouble(lua_State* L, const char* val, unsigned int len) {
+static double todouble(lua_State* L, const char* val, size_t len) {
     // Convert into number using a temporary:
     char* tmp = (char*)lua_newuserdata(L, len+1);
     memcpy(tmp, val, len);
@@ -75,7 +75,7 @@ static int js_to_string(lua_State *L) {
     // convert_me, {extra}, ?, gen_ud
     yajl_gen* gen = js_check_generator(L, -1);
     const unsigned char *buf;
-    unsigned int len;
+    size_t len;
     yajl_gen_get_buf(*gen, &buf, &len);
     // Copy into results:
     lua_pushlstring(L, (char*)buf, len);
@@ -101,7 +101,7 @@ static int to_value_boolean(void* ctx, int val) {
     return 1;
 }
 
-static int to_value_number(void* ctx, const char* val, unsigned int len) {
+static int to_value_number(void* ctx, const char* val, size_t len) {
     lua_State* L = (lua_State*)ctx;
 
     lua_pushnumber(L, todouble(L, val, len));
@@ -110,7 +110,7 @@ static int to_value_number(void* ctx, const char* val, unsigned int len) {
     return 1;
 }
 
-static int to_value_string(void* ctx, const unsigned char *val, unsigned int len) {
+static int to_value_string(void* ctx, const unsigned char *val, size_t len) {
     lua_State* L = (lua_State*)ctx;
 
     lua_pushlstring(L, (const char*)val, len);
@@ -219,7 +219,6 @@ static yajl_callbacks js_to_value_callbacks = {
 
 //////////////////////////////////////////////////////////////////////
 static int js_to_value(lua_State *L) {
-    yajl_parser_config   cfg = { 1, 1 };
     yajl_handle          handle;
     size_t               len;
     const unsigned char* buff = (const unsigned char*) luaL_checklstring(L, 1, &len);
@@ -227,23 +226,23 @@ static int js_to_value(lua_State *L) {
 
     if ( NULL == buff ) return 0;
 
+    handle = yajl_alloc(&js_to_value_callbacks, NULL, (void*)L);
+    lua_pushcfunction(L, noop);
+
     if ( lua_istable(L, 2) ) {
         lua_getfield(L, 2, "allow_comments");
         if ( ! lua_isnil(L, -1) ) {
-            cfg.allowComments = lua_toboolean(L, -1);
+            yajl_config(handle, yajl_allow_comments, lua_toboolean(L, -1));
         }
         lua_pop(L, 1);
 
         lua_getfield(L, 2, "check_utf8");
         if ( ! lua_isnil(L, -1) ) {
-            cfg.checkUTF8 = lua_toboolean(L, -1);
+            yajl_config(handle, yajl_dont_validate_strings, !lua_toboolean(L, -1));
         }
         lua_pop(L, 1);
     }
 
-    handle = yajl_alloc(&js_to_value_callbacks, &cfg, NULL, (void*)L);
-    lua_pushcfunction(L, noop);
-
     js_parser_assert(L,
                      yajl_parse(handle, buff, len),
                      &handle,
@@ -292,7 +291,7 @@ static int js_parser_boolean(void *ctx, int val) {
 }
 
 //////////////////////////////////////////////////////////////////////
-static int js_parser_number(void *ctx, const char* buffer, unsigned int buffer_len) {
+static int js_parser_number(void *ctx, const char* buffer, size_t buffer_len) {
     lua_State *L=(lua_State*)ctx;
 
     lua_getfield(L, lua_upvalueindex(2), "value");
@@ -309,7 +308,7 @@ static int js_parser_number(void *ctx, const char* buffer, unsigned int buffer_l
 }
 
 //////////////////////////////////////////////////////////////////////
-static int js_parser_string(void *ctx, const unsigned char *val, unsigned int len) {
+static int js_parser_string(void *ctx, const unsigned char *val, size_t len) {
     lua_State *L=(lua_State*)ctx;
 
     lua_getfield(L, lua_upvalueindex(2), "value");
@@ -341,7 +340,7 @@ static int js_parser_start_map(void *ctx) {
 }
 
 //////////////////////////////////////////////////////////////////////
-static int js_parser_map_key(void *ctx, const unsigned char *val, unsigned int len) {
+static int js_parser_map_key(void *ctx, const unsigned char *val, size_t len) {
     lua_State *L=(lua_State*)ctx;
 
     // TODO: Do we want to fall-back to calling "value"?
@@ -423,7 +422,7 @@ static void js_parser_assert(lua_State* L,
                              yajl_status status,
                              yajl_handle* handle,
                              const unsigned char* json_text,
-                             unsigned int json_text_len,
+                             size_t json_text_len,
                              int expect_complete,
                              const char* file,
                              int line)
@@ -438,11 +437,6 @@ static void js_parser_assert(lua_State* L,
         lua_pushfstring(L, "Unreachable: yajl_status_client_canceled should never be returned since all callbacks return true at %s line %d",
                         file, line);
         break;
-    case yajl_status_insufficient_data:
-        if ( ! expect_complete ) return;
-        lua_pushfstring(L, "IncompleteInput: js_parser_parse called with nil input, but the json input was not complete at %s line %d",
-                        file, line);
-        break;
     case yajl_status_error:
         msg = yajl_get_error(*handle, verbose, json_text, json_text_len);
         lua_pushfstring(L, "InvalidJSONInput: %s at %s line %d", msg, file, line);
@@ -459,7 +453,7 @@ static int js_parser_parse(lua_State *L) {
     if ( lua_isnil(L, 1) ) {
         int expect_complete = 1;
         js_parser_assert(L,
-                         yajl_parse_complete(*handle),
+                         yajl_complete_parse(*handle),
                          handle,
                          NULL,
                          0,
@@ -492,28 +486,27 @@ static int js_parser_delete(lua_State *L) {
 
 //////////////////////////////////////////////////////////////////////
 static int js_parser(lua_State *L) {
-    yajl_parser_config cfg = { 1, 1 };
 
     luaL_checktype(L, 1, LUA_TTABLE);
 
+    yajl_handle* handle = (yajl_handle*)lua_newuserdata(L, sizeof(yajl_handle));
+
+    *handle = yajl_alloc(&js_parser_callbacks, NULL, (void*)L);
+    luaL_getmetatable(L, "yajl.parser.meta");
+    lua_setmetatable(L, -2);
+
     lua_getfield(L, 1, "allow_comments");
     if ( ! lua_isnil(L, -1) ) {
-        cfg.allowComments = lua_toboolean(L, -1);
+        yajl_config(*handle, yajl_allow_comments, lua_toboolean(L, -1));
     }
     lua_pop(L, 1);
 
     lua_getfield(L, 1, "check_utf8");
     if ( ! lua_isnil(L, -1) ) {
-        cfg.checkUTF8 = lua_toboolean(L, -1);
+        yajl_config(*handle, yajl_dont_validate_strings, !lua_toboolean(L, -1));
     }
     lua_pop(L, 1);
 
-    yajl_handle* handle = (yajl_handle*)lua_newuserdata(L, sizeof(yajl_handle));
-
-    *handle = yajl_alloc(&js_parser_callbacks, &cfg, NULL, (void*)L);
-    luaL_getmetatable(L, "yajl.parser.meta");
-    lua_setmetatable(L, -2);
-
     lua_getfield(L, 1, "events");
 
     // Create callback function that calls yajl_parse[_complete]()
@@ -827,7 +820,7 @@ typedef struct {
 } js_printer_ctx;
 
 //////////////////////////////////////////////////////////////////////
-static void js_printer(void* void_ctx, const char* str, unsigned int len) {
+static void js_printer(void* void_ctx, const char* str, size_t len) {
     js_printer_ctx* ctx = (js_printer_ctx*)void_ctx;
     lua_State* L = ctx->L;
 
@@ -847,7 +840,6 @@ static void js_printer(void* void_ctx, const char* str, unsigned int len) {
 
 //////////////////////////////////////////////////////////////////////
 static int js_generator(lua_State *L) {
-    yajl_gen_config cfg = { 0, NULL };
     yajl_print_t   print = NULL;
     void *          ctx  = NULL;
 
@@ -885,17 +877,6 @@ static int js_generator(lua_State *L) {
     lua_pop(L, 1);
     // {args}, ?, tbl
 
-    // Get the indent and save so it isn't gc'ed:
-    lua_getfield(L, 1, "indent");
-    if ( ! lua_isnil(L, -1) ) {
-        cfg.beautify = 1;
-        cfg.indentString = lua_tostring(L, -1);
-        lua_setfield(L, -2, "indent");
-    } else {
-        lua_pop(L, 1);
-    }
-    // {args}, ?, tbl
-
     // Sucks that yajl's generator doesn't keep track of this for me
     // (this is a stack of strings "array" and "object" so I can keep
     // track of what to "close"):
@@ -904,7 +885,18 @@ static int js_generator(lua_State *L) {
 
     // {args}, ?, tbl
     yajl_gen* handle = (yajl_gen*)lua_newuserdata(L, sizeof(yajl_gen));
-    *handle = yajl_gen_alloc2(print, &cfg, NULL, ctx);
+    *handle = yajl_gen_alloc(NULL);
+
+    // Get the indent and save so it isn't gc'ed:
+    lua_getfield(L, 1, "indent");
+    if ( ! lua_isnil(L, -1) ) {
+        yajl_config(*handle, yajl_gen_beautify, 1);
+        yajl_config(*handle, yajl_gen_indent_string, lua_tostring(L, -1));
+        lua_setfield(L, -2, "indent");
+    } else {
+        lua_pop(L, 1);
+    }
+    // {args}, ?, tbl
 
     // {args}, ?, tbl, ud, meta
     luaL_getmetatable(L, "yajl.generator.meta");
-- 
1.7.4.1

