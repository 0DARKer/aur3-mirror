--- a/patch-2.6.37-ck2	2011-02-14 00:29:35.000000000 +0100
+++ b/patch-2.6.37-ck2	2011-02-19 02:06:32.000000000 +0100
@@ -4239,7 +4239,7 @@
 + * This waits for either a completion of a specific task to be signaled or for a
 + * specified timeout to expire. It is interruptible. The timeout is in jiffies.
 + */
-+unsigned long __sched
++long __sched
 +wait_for_completion_interruptible_timeout(struct completion *x,
 +					  unsigned long timeout)
 +{
@@ -4272,7 +4272,7 @@
 + * signaled or for a specified timeout to expire. It can be
 + * interrupted by a kill signal. The timeout is in jiffies.
 + */
-+unsigned long __sched
++long __sched
 +wait_for_completion_killable_timeout(struct completion *x,
 +				     unsigned long timeout)
 +{
@@ -8320,17 +8320,17 @@
  
  	if (!populated_zone(zone))
  		return;
-@@ -2495,7 +2531,9 @@
- 	trace_mm_vmscan_wakeup_kswapd(pgdat->node_id, zone_idx(zone), order);
- 	if (!cpuset_zone_allowed_hardwall(zone, GFP_KERNEL))
- 		return;
+@@ -2494,7 +2530,9 @@
+ 	pgdat = zone->zone_pgdat;
+ 	if (pgdat->kswapd_max_order < order)
+ 		pgdat->kswapd_max_order = order;
 -	if (!waitqueue_active(&pgdat->kswapd_wait))
 +	active = waitqueue_active(&pgdat->kswapd_wait);
 +	set_kswapd_nice(pgdat->kswapd, active);
 +	if (!active)
  		return;
- 	wake_up_interruptible(&pgdat->kswapd_wait);
- }
+ 	if (zone_watermark_ok_safe(zone, order, low_wmark_pages(zone), 0, 0))
+ 		return;
 @@ -2601,20 +2639,57 @@
  }
