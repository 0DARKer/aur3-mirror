diff -Naur OpenCASCADE6.3.0.orig//ros/ChangeLog OpenCASCADE6.3.0/ros/ChangeLog
--- OpenCASCADE6.3.0.orig//ros/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ OpenCASCADE6.3.0/ros/ChangeLog	2010-04-13 09:41:49.000000000 +0200
@@ -0,0 +1,118 @@
+----------------------------------------------------------------------------------------------------------------
+Service pack 9
+----------------------------------------------------------------------------------------------------------------
+New define has been added for include "unistd.h" in lex.*.c od StepFiles and ExprIntr packages 
+for windows platform
+----------------------------------------------------------------------------------------------------------------
+New define OCC_VERSION_SERVICEPACK has been added to Standard_Version.hxx
+Sample for sp9 : #define OCC_VERSION_SERVICEPACK   9
+----------------------------------------------------------------------------------------------------------------
+OCC21534 Need correction of IntTools_Context (attached) for Salome partition algorithm 
+Mantis : 0020603: EDF 1188 GEOM: MakePartition fails on 1st try but succeeds on 2nd try
+----------------------------------------------------------------------------------------------------------------
+OCC21499 ShapeAnalysis_FreeBounds::ConnectEdgesToWires() builds wrong wires 
+Mantis : 0020596: EDF 1115 GEOM: Creation of a face with vectors, lines and arcs 	
+----------------------------------------------------------------------------------------------------------------
+OCC21171 Problem with vfit of vertex and edge
+Mantis : 0020668: [CEA] FitAll and points 	
+----------------------------------------------------------------------------------------------------------------
+OCC21548 Problem with cut operation. Appendix for Mantis 0020621 issue 
+Mantis : 0020621: EDF 1211 GEOM: result of cut operation different depending on order 	
+----------------------------------------------------------------------------------------------------------------
+OCC21572 The bug is appendix to the Salome Bug 0020642 
+Mantis : 0020642: EDF 1227 GEOM: Partition fail	
+----------------------------------------------------------------------------------------------------------------
+OCC21588 Appendix to the SALOME bug: 0020683
+Mantis : 0020683: EDF 1249 GEOM : Sometimes Partition adds crosses on a solid that has to be meshed with prisms 	
+----------------------------------------------------------------------------------------------------------------
+OCC21603 The bug is appendix to the Salome Bug  0020707
+Mantis : 0020707: EDF 1224 GEOM: Result of MakeCommon is not valid
+----------------------------------------------------------------------------------------------------------------
+OCC21609 Bad result after re-writing to IGES.
+Mantis : 0020726: EDF 1259 GEOM : Bug d'export IGES 5.1
+----------------------------------------------------------------------------------------------------------------
+OCC21616 ShapeAnalysis_FreeBounds problem
+Mantis : 0020729: EDF 1256 GEOM : Partition between 2 contact surfaces 	
+----------------------------------------------------------------------------------------------------------------
+OCC21618 Appendix to the SALOME bug: 0020730
+Mantis : 0020730: EDF 1282 GEOM : MakeCut issue 	
+----------------------------------------------------------------------------------------------------------------
+OCC21645 Slow and bad triangulation on attached shape.
+Mantis : 0020718: EDF 1231 GEOM : Very very long display with deflection 
+----------------------------------------------------------------------------------------------------------------
+OCC21638 The bug is appendix to the Salome Bug 0020773, 0020774
+Mantis : 0020774: EDF 1325 GEOM : MakeCommon Issue
+         0020773: EDF 1324 GEOM : MakeCut Issue
+----------------------------------------------------------------------------------------------------------------
+
+----------------------------------------------------------------------------------------------------------------
+Service pack 8
+----------------------------------------------------------------------------------------------------------------
+OCC21448 Invalid result of BRepOffsetAPI_MakePipeShell
+Mantis : 0020539 [CEA 366] MakeCut regression
+----------------------------------------------------------------------------------------------------------------
+OCC21460 SIGFPE in BOP on two attached edges
+Mantis : 0020562 [CEA] V5.1.3 - Error with Partition
+----------------------------------------------------------------------------------------------------------------
+
+----------------------------------------------------------------------------------------------------------------
+Service pack 7
+----------------------------------------------------------------------------------------------------------------
+OCC21332 Corrupted user-defined marker in multi-view applications
+Mantis : 0020012 : EDF 831 GEOM : API for points representation in 3D viewer
+----------------------------------------------------------------------------------------------------------------
+OCC21262 - Application is crashed if Open CASCADE libraries are installed to the very long path (>128 symbols)
+Mantis : 0020426: EDF 1075 GEOM: Salome freezes on GEOM activation if install path of Opencascade is too long
+----------------------------------------------------------------------------------------------------------------
+OCC21255 Some problems with 3D chamfer construction
+Mantis : 0020419: EDF 1066 GEOM : Chamfer issue with a T pipe
+Mantis : 0020423: EDF 1067 GEOM: Anomaly on chamfer
+----------------------------------------------------------------------------------------------------------------
+
+---------------------------------------------------------------------------------------------------------------
+Service pack 6
+---------------------------------------------------------------------------------------------------------------	
+OCC20881 EDF GEOM: Regression with Propagate algorithm 0020060
+OCC20866 EDF 941 GEOM :MakePipeWithDifferents Sections : Pipe face not normal to the section 0020143
+OCC20904 EDF 904 GEOM : Partition by the common NOOK. Mantis: 0020103
+OCC20784 Problem (fainding dps package) of make procedure.
+----------------------------------------------------------------------------------------------------------------
+
+--------------
+Service pack 5
+--------------
+Fixed bugs and improvements:
+Eliminating regressions on partition.
+
+--------------
+Service pack 4
+--------------
+Fixed bugs and improvements:
+Make partition fail. Salome bugs 20221.
+
+--------------
+Service pack 3
+--------------
+Fixed bugs and improvements:
+Eliminated problem with slowly displaying in OCC viewer of GEOM module after remute connection. Salome bugs 20218.
+
+--------------
+Service pack 2
+--------------
+Fixed bugs and improvements:
+OCC20864 This bug is appendix to the Salome bugs 0019957 and 0020102 (Partition issues).
+OCC20205 Improvements from Open CASCADE Forum for Visualization  (trihedron position). The Salome bug 0020126. 
+OCC20802 V3d_View: Text size used by V3d_ZBUFFER'ed trihedron is too large (size of trihedron axis labels). The Salome bug 0020126.
+			 
+--------------
+Service pack 1
+--------------
+Fixed bugs and improvements:
+OCC19184 Bad performance of Append operation of TDataStd_TreeNode class. Appendix for the Salome bug 0019909
+OCC19793 Fuse problem of symetrical shapes. Appendix for the Salome bug 0019789.
+OCC19811 Scaling problem. Appendix for the Salome bug 0019806.
+OCC20037 Shading display on a spring is very bad. Appendix for the Salome bug 0019902.
+OCC20056 The bug is appendix to the Salome bug 0019881.
+OCC20104 The bug is appendix to the Salome bug 0019912.
+OCC20184 Pb at make install 2 times. Appendix for the Salome bug 0019917.
+OCC20017 Eliminating of compilation warnings. Appendix for the Salome bug 0019884.
diff -Naur OpenCASCADE6.3.0.orig//ros/config.h.in OpenCASCADE6.3.0/ros/config.h.in
--- OpenCASCADE6.3.0.orig//ros/config.h.in	2010-07-04 20:16:01.385899457 +0200
+++ OpenCASCADE6.3.0/ros/config.h.in	2009-09-25 14:21:40.000000000 +0200
@@ -87,6 +87,9 @@
 /* Define to 1 if you have the <libc.h> header file. */
 #undef HAVE_LIBC_H
 
+/* Define to 1 if you have the `dl' library (-ldl). */
+#undef HAVE_LIBDL
+
 /* Define to 1 if you have the `pthread' library (-lpthread). */
 #undef HAVE_LIBPTHREAD
 
diff -Naur OpenCASCADE6.3.0.orig//ros/configure OpenCASCADE6.3.0/ros/configure
--- OpenCASCADE6.3.0.orig//ros/configure	2010-07-04 20:16:01.379243616 +0200
+++ OpenCASCADE6.3.0/ros/configure	2009-09-25 14:21:40.000000000 +0200
@@ -466,7 +466,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot build build_cpu build_vendor build_os host host_cpu host_vendor host_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP LN_S ECHO RANLIB ac_ct_RANLIB LIBTOOL CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE U ANSI2KNR YACC CXXCPP CSF_ThreadLibs_LIB TCL_VERSION TK_VERSION CSF_TclLibs_INCLUDES CSF_TclTkLibs_INCLUDES CSF_TclLibs_LIB CSF_TclTkLibs_LIB platform ALLOCA LIBOBJS HAVE_GL_TRUE HAVE_GL_FALSE ENABLE_MODEL_TRUE ENABLE_MODEL_FALSE ENABLE_VIS_TRUE ENABLE_VIS_FALSE ENABLE_OCAF_TRUE ENABLE_OCAF_FALSE ENABLE_DE_TRUE ENABLE_DE_FALSE ENABLE_DRAW_TRUE ENABLE_DRAW_FALSE ENABLE_WRAPPERS_TRUE ENABLE_WRAPPERS_FALSE ENABLE_WOK_TRUE ENABLE_WOK_FALSE CXXCPPFLAGS CSF_SOCKETLibs_LIB CSF_FPELibs_LIB CSF_OpenGlLibs_INCLUDES CSF_OpenGlLibs_LIB CSF_advapi32_LIB CSF_gdi32_LIB CSF_user32_LIB CSF_wsock32_LIB CSF_XwLibs_LIB CSF_dpsLibs_LIB CSF_dpsLibs_INCLUDES CSF_XmuLibs_LIB CSF_XmuLibs_INCLUDES LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot build build_cpu build_vendor build_os host host_cpu host_vendor host_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP EGREP LN_S ECHO RANLIB ac_ct_RANLIB LIBTOOL CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE U ANSI2KNR YACC CXXCPP CSF_ThreadLibs_LIB TCL_VERSION TK_VERSION CSF_TclLibs_INCLUDES CSF_TclTkLibs_INCLUDES CSF_TclLibs_LIB CSF_TclTkLibs_LIB CSF_SOCKETLibs_LIB platform ALLOCA LIBOBJS HAVE_GL_TRUE HAVE_GL_FALSE ENABLE_MODEL_TRUE ENABLE_MODEL_FALSE ENABLE_VIS_TRUE ENABLE_VIS_FALSE ENABLE_OCAF_TRUE ENABLE_OCAF_FALSE ENABLE_DE_TRUE ENABLE_DE_FALSE ENABLE_DRAW_TRUE ENABLE_DRAW_FALSE ENABLE_WRAPPERS_TRUE ENABLE_WRAPPERS_FALSE ENABLE_WOK_TRUE ENABLE_WOK_FALSE CXXCPPFLAGS CSF_FPELibs_LIB CSF_OpenGlLibs_INCLUDES CSF_OpenGlLibs_LIB CSF_advapi32_LIB CSF_gdi32_LIB CSF_user32_LIB CSF_wsock32_LIB CSF_XwLibs_LIB CSF_dpsLibs_LIB CSF_dpsLibs_INCLUDES CSF_XmuLibs_LIB CSF_XmuLibs_INCLUDES LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -12353,6 +12353,79 @@
 CSF_ThreadLibs_LIB=-lpthread
 
 
+#-----------------------------------------------------------------------------
+# dl library is required
+#-----------------------------------------------------------------------------
+
+echo "$as_me:$LINENO: checking for dlopen in -ldl" >&5
+echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
+if test "${ac_cv_lib_dl_dlopen+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ldl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char dlopen ();
+int
+main ()
+{
+dlopen ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_dl_dlopen=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_dl_dlopen=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_dl_dlopen" >&5
+echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
+if test $ac_cv_lib_dl_dlopen = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBDL 1
+_ACEOF
+
+  LIBS="-ldl $LIBS"
+
+else
+  { { echo "$as_me:$LINENO: error: dl library is required" >&5
+echo "$as_me: error: dl library is required" >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+CSF_SOCKETLibs_LIB=-ldl
+
 #------------------------------------------------------------------------------
 # Get Tcl and TK configuration information from tclConfig.sh.
 #------------------------------------------------------------------------------
@@ -12828,13 +12901,16 @@
 		LDFLAGS="$LDFLAGS -lstdc++";;
 	SunOS*) CXXFLAGS="$CXXFLAGS -Usun -DSOLARIS -instances=static"
 		CFLAGS="$CFLAGS -Usun -DSOLARIS -instances=static"
-		LDFLAGS="$LDFLAGS -instances=static";;
+		LDFLAGS="$LDFLAGS -instances=static"
+		CSF_SOCKETLibs_LIB="-lnsl ${CSF_SOCKETLibs_LIB}";;
         OSF1*)  CXXFLAGS="$CXXFLAGS -DDECOSF1 -D__USE_STD_IOSTREAM -D_RWSTD_NO_EXCEPTIONS"
                 CFLAGS="$CFLAGS -std1 -DDECOSF1"
 		LD=$CXX;;
 	*) ;;
 esac
 
+
+
 ac_ext=cc
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -15427,228 +15503,6 @@
 fi
 
 
-#---------------------------------------------------------------------
-#
-# Check for DPS libraries
-#
-#
-#---------------------------------------------------------------------
-CSF_dpsLibs_INCLUDES="$X_INCLUDE"
-CSF_dpsLibs_LIB="$X_LIBS"
-if test "xno" = "x$HAVE_X11"; then
-  HAVE_DPS=no
-else
-  if test "${ac_cv_header_DPS_dpsXclient_h+set}" = set; then
-  echo "$as_me:$LINENO: checking for DPS/dpsXclient.h" >&5
-echo $ECHO_N "checking for DPS/dpsXclient.h... $ECHO_C" >&6
-if test "${ac_cv_header_DPS_dpsXclient_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: $ac_cv_header_DPS_dpsXclient_h" >&5
-echo "${ECHO_T}$ac_cv_header_DPS_dpsXclient_h" >&6
-else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking DPS/dpsXclient.h usability" >&5
-echo $ECHO_N "checking DPS/dpsXclient.h usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <DPS/dpsXclient.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_header_compiler=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
-
-# Is the header present?
-echo "$as_me:$LINENO: checking DPS/dpsXclient.h presence" >&5
-echo $ECHO_N "checking DPS/dpsXclient.h presence... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <DPS/dpsXclient.h>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: DPS/dpsXclient.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: DPS/dpsXclient.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: DPS/dpsXclient.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: DPS/dpsXclient.h: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: DPS/dpsXclient.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: DPS/dpsXclient.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: DPS/dpsXclient.h: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: DPS/dpsXclient.h: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: DPS/dpsXclient.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: DPS/dpsXclient.h: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for DPS/dpsXclient.h" >&5
-echo $ECHO_N "checking for DPS/dpsXclient.h... $ECHO_C" >&6
-if test "${ac_cv_header_DPS_dpsXclient_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_header_DPS_dpsXclient_h=$ac_header_preproc
-fi
-echo "$as_me:$LINENO: result: $ac_cv_header_DPS_dpsXclient_h" >&5
-echo "${ECHO_T}$ac_cv_header_DPS_dpsXclient_h" >&6
-
-fi
-if test $ac_cv_header_DPS_dpsXclient_h = yes; then
-  HAVE_DPS_INC=yes
-else
-  HAVE_DPS_INC=no
-fi
-
-
-  echo "$as_me:$LINENO: checking for DPSInitialize in -ldps" >&5
-echo $ECHO_N "checking for DPSInitialize in -ldps... $ECHO_C" >&6
-if test "${ac_cv_lib_dps_DPSInitialize+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldps  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char DPSInitialize ();
-int
-main ()
-{
-DPSInitialize ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_dps_DPSInitialize=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_lib_dps_DPSInitialize=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_dps_DPSInitialize" >&5
-echo "${ECHO_T}$ac_cv_lib_dps_DPSInitialize" >&6
-if test $ac_cv_lib_dps_DPSInitialize = yes; then
-  HAVE_DPS_LIB=yes
-else
-  HAVE_DPS_LIB=no
-fi
-
-  HAVE_DPS=yes
-  if test "xno" = "x$HAVE_DPS_INC"; then
-    HAVE_DPS=no
-    { echo "$as_me:$LINENO: \"Specify CPPFLAGS=-I<dps_include_dir> to enable DPS support\"" >&5
-echo "$as_me: \"Specify CPPFLAGS=-I<dps_include_dir> to enable DPS support\"" >&6;}
-  fi
-  if test "xno" = "x$HAVE_DPS_LIB"; then
-    HAVE_DPS=no
-    { echo "$as_me:$LINENO: \"Specify LDFLAGS=-L<dps_lib_dir> to enable DPS support\"" >&5
-echo "$as_me: \"Specify LDFLAGS=-L<dps_lib_dir> to enable DPS support\"" >&6;}
-  else
-    CSF_dpsLibs_LIB="$CSF_dpsLibs_LIB -ldps"
-  fi
-fi
-
 CFLAGS="$CFLAGS_save"
 CXXFLAGS="$CXXFLAGS_save"
 CPPFLAGS="$CPPFLAGS_save"
@@ -16051,7 +15905,6 @@
 
 
 
-CSF_SOCKETLibs_LIB=""
 CSF_XwLibs_LIB="$X_LIBS"
 
 
@@ -16947,6 +16800,7 @@
 s,@CSF_TclTkLibs_INCLUDES@,$CSF_TclTkLibs_INCLUDES,;t t
 s,@CSF_TclLibs_LIB@,$CSF_TclLibs_LIB,;t t
 s,@CSF_TclTkLibs_LIB@,$CSF_TclTkLibs_LIB,;t t
+s,@CSF_SOCKETLibs_LIB@,$CSF_SOCKETLibs_LIB,;t t
 s,@platform@,$platform,;t t
 s,@ALLOCA@,$ALLOCA,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
@@ -16967,7 +16821,6 @@
 s,@ENABLE_WOK_TRUE@,$ENABLE_WOK_TRUE,;t t
 s,@ENABLE_WOK_FALSE@,$ENABLE_WOK_FALSE,;t t
 s,@CXXCPPFLAGS@,$CXXCPPFLAGS,;t t
-s,@CSF_SOCKETLibs_LIB@,$CSF_SOCKETLibs_LIB,;t t
 s,@CSF_FPELibs_LIB@,$CSF_FPELibs_LIB,;t t
 s,@CSF_OpenGlLibs_INCLUDES@,$CSF_OpenGlLibs_INCLUDES,;t t
 s,@CSF_OpenGlLibs_LIB@,$CSF_OpenGlLibs_LIB,;t t
diff -Naur OpenCASCADE6.3.0.orig//ros/configure.in OpenCASCADE6.3.0/ros/configure.in
--- OpenCASCADE6.3.0.orig//ros/configure.in	2010-07-04 20:16:01.379243616 +0200
+++ OpenCASCADE6.3.0/ros/configure.in	2009-09-25 14:21:40.000000000 +0200
@@ -67,6 +67,12 @@
 CSF_ThreadLibs_LIB=-lpthread
 AC_SUBST(CSF_ThreadLibs_LIB)
 
+#-----------------------------------------------------------------------------
+# dl library is required
+#-----------------------------------------------------------------------------
+AC_CHECK_LIB([dl],[dlopen],[],[AC_MSG_ERROR([dl library is required])])
+CSF_SOCKETLibs_LIB=-ldl
+
 #------------------------------------------------------------------------------
 # Get Tcl and TK configuration information from tclConfig.sh.
 #------------------------------------------------------------------------------
@@ -102,12 +108,15 @@
 		LDFLAGS="$LDFLAGS -lstdc++";;
 	SunOS*) CXXFLAGS="$CXXFLAGS -Usun -DSOLARIS -instances=static"
 		CFLAGS="$CFLAGS -Usun -DSOLARIS -instances=static"
-		LDFLAGS="$LDFLAGS -instances=static";;
+		LDFLAGS="$LDFLAGS -instances=static"
+		CSF_SOCKETLibs_LIB="-lnsl ${CSF_SOCKETLibs_LIB}";;
         OSF1*)  CXXFLAGS="$CXXFLAGS -DDECOSF1 -D__USE_STD_IOSTREAM -D_RWSTD_NO_EXCEPTIONS" 
                 CFLAGS="$CFLAGS -std1 -DDECOSF1"
 		LD=$CXX;;
 	*) ;;
 esac
+AC_SUBST(CSF_SOCKETLibs_LIB)
+
 AC_SUBST(platform)
 AC_LANG([C++])
 
@@ -370,32 +379,6 @@
 fi
 AM_CONDITIONAL( HAVE_GL, [test "xyes" = "x$HAVE_GL"] )
 
-#---------------------------------------------------------------------
-#
-# Check for DPS libraries
-#  
-#  
-#---------------------------------------------------------------------
-CSF_dpsLibs_INCLUDES="$X_INCLUDE"
-CSF_dpsLibs_LIB="$X_LIBS"
-if test "xno" = "x$HAVE_X11"; then
-  HAVE_DPS=no
-else
-  AC_CHECK_HEADER( [DPS/dpsXclient.h], [HAVE_DPS_INC=yes], [HAVE_DPS_INC=no] )
-  AC_CHECK_LIB( [dps], [DPSInitialize], [HAVE_DPS_LIB=yes], [HAVE_DPS_LIB=no] )
-  HAVE_DPS=yes
-  if test "xno" = "x$HAVE_DPS_INC"; then
-    HAVE_DPS=no
-    AC_MSG_NOTICE("Specify CPPFLAGS=-I<dps_include_dir> to enable DPS support")
-  fi
-  if test "xno" = "x$HAVE_DPS_LIB"; then
-    HAVE_DPS=no
-    AC_MSG_NOTICE("Specify LDFLAGS=-L<dps_lib_dir> to enable DPS support")
-  else
-    CSF_dpsLibs_LIB="$CSF_dpsLibs_LIB -ldps"
-  fi
-fi
-
 CFLAGS="$CFLAGS_save"
 CXXFLAGS="$CXXFLAGS_save"
 CPPFLAGS="$CPPFLAGS_save"
@@ -632,7 +615,6 @@
 AC_SUBST(LDFLAGS)
 
 
-CSF_SOCKETLibs_LIB=""
 CSF_XwLibs_LIB="$X_LIBS"
 
 AC_SUBST(CSF_SOCKETLibs_LIB)
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/BOP/BOP_SDFWESFiller.jxx OpenCASCADE6.3.0/ros/drv/BOP/BOP_SDFWESFiller.jxx
--- OpenCASCADE6.3.0.orig//ros/drv/BOP/BOP_SDFWESFiller.jxx	2010-07-04 20:10:22.745945623 +0200
+++ OpenCASCADE6.3.0/ros/drv/BOP/BOP_SDFWESFiller.jxx	2010-03-25 10:54:51.000000000 +0100
@@ -10,6 +10,9 @@
 #ifndef _TopoDS_Face_HeaderFile
 #include <TopoDS_Face.hxx>
 #endif
+#ifndef _TopTools_ListOfShape_HeaderFile
+#include <TopTools_ListOfShape.hxx>
+#endif
 #ifndef _BOP_SDFWESFiller_HeaderFile
 #include <BOP_SDFWESFiller.hxx>
 #endif
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx OpenCASCADE6.3.0/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx
--- OpenCASCADE6.3.0.orig//ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx	2010-07-04 20:10:44.816356921 +0200
+++ OpenCASCADE6.3.0/ros/drv/BRepMesh/BRepMesh_FastDiscret.jxx	2009-02-18 15:07:44.000000000 +0100
@@ -25,9 +25,6 @@
 #ifndef _BRepMesh_ListOfVertex_HeaderFile
 #include <BRepMesh_ListOfVertex.hxx>
 #endif
-#ifndef _TColStd_ListOfReal_HeaderFile
-#include <TColStd_ListOfReal.hxx>
-#endif
 #ifndef _BRepMesh_Classifier_HeaderFile
 #include <BRepMesh_Classifier.hxx>
 #endif
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/ExprInterp/lex.ExprIntrp.c OpenCASCADE6.3.0/ros/drv/ExprInterp/lex.ExprIntrp.c
--- OpenCASCADE6.3.0.orig//ros/drv/ExprInterp/lex.ExprIntrp.c	1970-01-01 01:00:00.000000000 +0100
+++ OpenCASCADE6.3.0/ros/drv/ExprInterp/lex.ExprIntrp.c	2009-09-21 15:25:03.000000000 +0200
@@ -0,0 +1,3426 @@
+
+#line 3 "lex.ExprIntrp.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE ExprIntrprestart(ExprIntrpin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ExprIntrpleng;
+
+extern FILE *ExprIntrpin, *ExprIntrpout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ExprIntrptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ExprIntrptext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via ExprIntrprestart()), so that the user can continue scanning by
+	 * just pointing ExprIntrpin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when ExprIntrptext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int ExprIntrpleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow ExprIntrpwrap()'s to do buffer switches
+ * instead of setting up a fresh ExprIntrpin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void ExprIntrprestart (FILE *input_file  );
+void ExprIntrp_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ExprIntrp_create_buffer (FILE *file,int size  );
+void ExprIntrp_delete_buffer (YY_BUFFER_STATE b  );
+void ExprIntrp_flush_buffer (YY_BUFFER_STATE b  );
+void ExprIntrppush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ExprIntrppop_buffer_state (void );
+
+static void ExprIntrpensure_buffer_stack (void );
+static void ExprIntrp_load_buffer_state (void );
+static void ExprIntrp_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ExprIntrp_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ExprIntrp_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ExprIntrp_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ExprIntrp_scan_bytes (yyconst char *bytes,int len  );
+
+void *ExprIntrpalloc (yy_size_t  );
+void *ExprIntrprealloc (void *,yy_size_t  );
+void ExprIntrpfree (void *  );
+
+#define yy_new_buffer ExprIntrp_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ExprIntrpensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ExprIntrpensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+typedef unsigned char YY_CHAR;
+
+FILE *ExprIntrpin = (FILE *) 0, *ExprIntrpout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int ExprIntrplineno;
+
+int ExprIntrplineno = 1;
+
+extern char *ExprIntrptext;
+#define yytext_ptr ExprIntrptext
+static yyconst flex_int16_t yy_nxt[][256] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0
+    },
+
+    {
+        3,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    5,    4,    4,    4,    4,    4,    4,    6,
+
+        7,    8,    9,   10,   11,   12,   13,   14,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,    4,   15,
+       16,   17,    4,    4,   18,   19,   19,   20,   21,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       22,   19,   19,   23,   19,   19,   19,   19,   19,   19,
+       19,   24,    4,   25,   26,    4,    4,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4
+    },
+
+    {
+        3,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    5,    4,    4,    4,    4,    4,    4,    6,
+        7,    8,    9,   10,   11,   12,   13,   14,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,    4,   15,
+       16,   17,    4,    4,   18,   19,   19,   20,   21,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+
+       22,   19,   19,   23,   19,   19,   19,   19,   19,   19,
+       19,   24,    4,   25,   26,    4,    4,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4
+    },
+
+    {
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,   -3,
+       -3,   -3,   -3,   -3,   -3,   -3
+    },
+
+    {
+        3,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,   -4,
+       -4,   -4,   -4,   -4,   -4,   -4
+
+    },
+
+    {
+        3,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,   -5,
+       -5,   -5,   -5,   -5,   -5,   -5
+    },
+
+    {
+        3,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   27,
+
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+
+       -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,   -6,
+       -6,   -6,   -6,   -6,   -6,   -6
+    },
+
+    {
+        3,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,   -7,
+       -7,   -7,   -7,   -7,   -7,   -7
+    },
+
+    {
+        3,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
+       -8,   -8,   -8,   -8,   -8,   -8
+    },
+
+    {
+        3,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   28,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
+       -9,   -9,   -9,   -9,   -9,   -9
+
+    },
+
+    {
+        3,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,  -10,
+      -10,  -10,  -10,  -10,  -10,  -10
+    },
+
+    {
+        3,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+        3,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+        3,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,   29,  -13,   29,   29,
+       29,   29,   29,   29,   29,   29,   29,   29,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,   30,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+        3,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+        3,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,  -15,
+      -15,  -15,  -15,  -15,  -15,  -15
+    },
+
+    {
+        3,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+
+      -16,  -16,  -16,  -16,  -16,   31,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+
+      -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+        3,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+        3,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,  -18,  -18,  -18
+    },
+
+    {
+        3,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -19,  -19,
+
+      -19,  -19,  -19,  -19,  -19,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -19,  -19,  -19,  -19,   32,  -19,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
+      -19,  -19,  -19,  -19,  -19,  -19
+
+    },
+
+    {
+        3,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -20,  -20,  -20,  -20,   32,  -20,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   33,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+        3,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -21,  -21,  -21,  -21,   32,  -21,   32,   32,   32,
+       32,   34,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+
+      -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,  -21,
+      -21,  -21,  -21,  -21,  -21,  -21
+    },
+
+    {
+        3,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -22,  -22,  -22,  -22,   32,  -22,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   35,   32,   32,   32,   32,   32,
+       32,   32,   32,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,  -22,
+      -22,  -22,  -22,  -22,  -22,  -22
+    },
+
+    {
+        3,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -23,  -23,  -23,  -23,   32,  -23,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   36,   32,   32,
+
+       32,   32,   32,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+        3,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+        3,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
+      -25,  -25,  -25,  -25,  -25,  -25
+    },
+
+    {
+        3,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+
+      -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+        3,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,   27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+        3,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,  -28,  -28
+    },
+
+    {
+        3,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,   29,  -29,   29,   29,
+       29,   29,   29,   29,   29,   29,   29,   29,  -29,  -29,
+
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,   30,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+        3,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,   37,  -30,   37,  -30,  -30,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   38,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,   37,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,  -30,
+      -30,  -30,  -30,  -30,  -30,  -30
+    },
+
+    {
+        3,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+
+      -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+        3,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -32,  -32,  -32,  -32,   32,  -32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+        3,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -33,  -33,  -33,  -33,   32,  -33,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       39,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+        3,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -34,  -34,
+
+      -34,  -34,  -34,  -34,  -34,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -34,  -34,  -34,  -34,   32,  -34,   40,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   41,   32,   32,   32,   32,   32,
+       32,   32,   32,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,  -34,  -34,  -34,  -34,  -34
+
+    },
+
+    {
+        3,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -35,  -35,  -35,  -35,   32,  -35,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   42,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,  -35,  -35,  -35,  -35,  -35
+    },
+
+    {
+        3,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -36,  -36,  -36,  -36,   32,  -36,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   43,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+
+      -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+        3,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   38,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+        3,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38
+    },
+
+    {
+        3,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -39,  -39,
+
+      -39,  -39,  -39,  -39,  -39,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -39,  -39,  -39,  -39,   32,  -39,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   44,   32,   32,   32,   32,
+       32,   32,   32,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+        3,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -40,  -40,  -40,  -40,   32,  -40,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   45,   32,   32,   32,   32,
+       32,   32,   32,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+        3,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -41,  -41,  -41,  -41,   32,  -41,   32,   32,   32,
+       32,   32,   32,   32,   32,   46,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+
+      -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,  -41,
+      -41,  -41,  -41,  -41,  -41,  -41
+    },
+
+    {
+        3,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -42,  -42,  -42,  -42,   32,  -42,   32,   32,   32,
+       47,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,  -42,
+      -42,  -42,  -42,  -42,  -42,  -42
+    },
+
+    {
+        3,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -43,  -43,  -43,  -43,   32,  -43,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+        3,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -44,  -44,
+
+      -44,  -44,  -44,  -44,  -44,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -44,  -44,  -44,  -44,   32,  -44,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   48,   32,   32,   32,
+       32,   32,   32,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,  -44,  -44,  -44
+
+    },
+
+    {
+        3,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -45,  -45,  -45,  -45,   32,  -45,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   49,   32,   32,   32,   32,
+       32,   32,   32,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,  -45,
+      -45,  -45,  -45,  -45,  -45,  -45
+    },
+
+    {
+        3,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -46,  -46,  -46,  -46,   32,  -46,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   50,   32,
+       32,   32,   32,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+
+      -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+        3,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -47,  -47,  -47,  -47,   32,  -47,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
+      -47,  -47,  -47,  -47,  -47,  -47
+    },
+
+    {
+        3,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -48,  -48,  -48,  -48,   32,  -48,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+        3,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -49,  -49,
+
+      -49,  -49,  -49,  -49,  -49,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -49,  -49,  -49,  -49,   32,  -49,   32,   32,   32,
+       32,   32,   32,   32,   32,   51,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,  -49,
+      -49,  -49,  -49,  -49,  -49,  -49
+
+    },
+
+    {
+        3,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -50,  -50,  -50,  -50,   32,  -50,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+        3,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -51,  -51,  -51,  -51,   32,  -51,   32,   32,   32,
+       32,   32,   32,   52,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+
+      -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+        3,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -52,  -52,  -52,  -52,   32,  -52,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       53,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+        3,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,  -53,  -53,  -53,  -53,   32,  -53,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+       32,   32,   32,   32,   32,   32,   32,   32,   32,   32,
+
+       32,   32,   32,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up ExprIntrptext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	ExprIntrpleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 26
+#define YY_END_OF_BUFFER 27
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[54] =
+    {   0,
+        0,    0,   27,   26,    1,   25,    8,   10,    7,    2,
+       12,    3,   22,    4,   24,   26,   15,   13,   23,   23,
+       23,   23,   23,    9,   11,    5,   25,    6,   22,    0,
+       14,   23,   23,   23,   23,   23,    0,   21,   23,   23,
+       23,   23,   19,   23,   23,   23,   20,   18,   23,   17,
+       23,   23,   16
+    } ;
+
+static yy_state_type yy_last_accepting_state;
+static char *yy_last_accepting_cpos;
+
+static yyconst yy_state_type yy_NUL_trans[54] =
+    {   0,
+        4,    4,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0
+    } ;
+
+extern int ExprIntrp_flex_debug;
+int ExprIntrp_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *ExprIntrptext;
+#include <ExprIntrp.tab.h>
+#define YY_SKIP_YYWRAP
+
+static YY_BUFFER_STATE ExprIntrp_bufstring;
+
+void ExprIntrp_SetResult();
+void ExprIntrp_SetDegree();
+
+void ExprIntrp_start_string(char* str)
+{
+  ExprIntrp_bufstring = ExprIntrp_scan_string(str);
+}
+
+void ExprIntrp_stop_string()
+{
+  ExprIntrp_delete_buffer(ExprIntrp_bufstring);
+}
+
+int ExprIntrpwrap()
+{
+  return 1;
+}
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int ExprIntrpwrap (void );
+#else
+extern int ExprIntrpwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( ExprIntrptext, ExprIntrpleng, 1, ExprIntrpout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(ExprIntrpin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(ExprIntrpin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int ExprIntrplex (void);
+
+#define YY_DECL int ExprIntrplex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after ExprIntrptext and ExprIntrpleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! ExprIntrpin )
+			ExprIntrpin = stdin;
+
+		if ( ! ExprIntrpout )
+			ExprIntrpout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			ExprIntrpensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE );
+		}
+
+		ExprIntrp_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of ExprIntrptext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) > 0 )
+			{
+			if ( yy_accept[yy_current_state] )
+				{
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
+				}
+
+			++yy_cp;
+			}
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos) + 1;
+			yy_current_state = (yy_last_accepting_state);
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+{;}
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+{return(SUMOP) ;}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+{return(MINUSOP) ;}
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{return(DIVIDEOP) ;}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{return(EXPOP) ;}
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+{return(EXPOP) ;}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+{return(MULTOP) ;}
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+{return(PARENTHESIS);}
+	YY_BREAK
+case 9:
+YY_RULE_SETUP
+{return(BRACKET);}
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+{return(ENDPARENTHESIS);}
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+{return(ENDBRACKET);}
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+{return(COMMA);}
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+{return(DIFFERENTIAL);}
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+{return(ASSIGNOP);}
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+{return(EQUALOP);}
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{return(DEASSIGNKEY);}
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+{return(DERIVKEY);}
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+{return(CONSTKEY);}
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{return(SUMKEY);}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+{return(PRODKEY);}
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+{ExprIntrp_SetResult(); return(VALUE);}
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+{ExprIntrp_SetResult(); return(VALUE);}
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+{ExprIntrp_SetResult(); return(IDENTIFIER);}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{return(RELSEPARATOR);}
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+{ExprIntrp_SetDegree();return(DERIVATE);}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+ECHO;
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+	yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed ExprIntrpin at a new source and called
+			 * ExprIntrplex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ExprIntrpin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( ExprIntrpwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * ExprIntrptext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of ExprIntrplex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					ExprIntrprealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			ExprIntrprestart(ExprIntrpin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		if ( *yy_cp )
+			{
+			yy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(*yy_cp)];
+			}
+		else
+			yy_current_state = yy_NUL_trans[yy_current_state];
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    	register char *yy_cp = (yy_c_buf_p);
+
+	yy_current_state = yy_NUL_trans[yy_current_state];
+	yy_is_jam = (yy_current_state == 0);
+
+	if ( ! yy_is_jam )
+		{
+		if ( yy_accept[yy_current_state] )
+			{
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
+			}
+		}
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up ExprIntrptext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ExprIntrprestart(ExprIntrpin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( ExprIntrpwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ExprIntrptext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ExprIntrprestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ExprIntrpensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE );
+	}
+
+	ExprIntrp_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ExprIntrp_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ExprIntrp_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ExprIntrppop_buffer_state();
+	 *		ExprIntrppush_buffer_state(new_buffer);
+     */
+	ExprIntrpensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ExprIntrp_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (ExprIntrpwrap()) processing, but the only time this flag
+	 * is looked at is after ExprIntrpwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void ExprIntrp_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ExprIntrpin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ExprIntrp_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) ExprIntrpalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) ExprIntrpalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	ExprIntrp_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with ExprIntrp_create_buffer()
+ * 
+ */
+    void ExprIntrp_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		ExprIntrpfree((void *) b->yy_ch_buf  );
+
+	ExprIntrpfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ExprIntrprestart() or at EOF.
+ */
+    static void ExprIntrp_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	ExprIntrp_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then ExprIntrp_init_buffer was _probably_
+     * called from ExprIntrprestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ExprIntrp_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		ExprIntrp_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ExprIntrppush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ExprIntrpensure_buffer_stack();
+
+	/* This block is copied from ExprIntrp_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ExprIntrp_switch_to_buffer. */
+	ExprIntrp_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ExprIntrppop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ExprIntrp_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ExprIntrp_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ExprIntrpensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ExprIntrpalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ExprIntrprealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ExprIntrp_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) ExprIntrpalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	ExprIntrp_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to ExprIntrplex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ExprIntrp_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ExprIntrp_scan_string (yyconst char * yystr )
+{
+    
+	return ExprIntrp_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to ExprIntrplex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ExprIntrp_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) ExprIntrpalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = ExprIntrp_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in ExprIntrp_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ExprIntrptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ExprIntrptext[ExprIntrpleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ExprIntrptext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ExprIntrpleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int ExprIntrpget_lineno  (void)
+{
+        
+    return ExprIntrplineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *ExprIntrpget_in  (void)
+{
+        return ExprIntrpin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *ExprIntrpget_out  (void)
+{
+        return ExprIntrpout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int ExprIntrpget_leng  (void)
+{
+        return ExprIntrpleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *ExprIntrpget_text  (void)
+{
+        return ExprIntrptext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ExprIntrpset_lineno (int  line_number )
+{
+    
+    ExprIntrplineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ExprIntrp_switch_to_buffer
+ */
+void ExprIntrpset_in (FILE *  in_str )
+{
+        ExprIntrpin = in_str ;
+}
+
+void ExprIntrpset_out (FILE *  out_str )
+{
+        ExprIntrpout = out_str ;
+}
+
+int ExprIntrpget_debug  (void)
+{
+        return ExprIntrp_flex_debug;
+}
+
+void ExprIntrpset_debug (int  bdebug )
+{
+        ExprIntrp_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ExprIntrplex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ExprIntrpin = stdin;
+    ExprIntrpout = stdout;
+#else
+    ExprIntrpin = (FILE *) 0;
+    ExprIntrpout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ExprIntrplex_init()
+     */
+    return 0;
+}
+
+/* ExprIntrplex_destroy is for both reentrant and non-reentrant scanners. */
+int ExprIntrplex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ExprIntrp_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ExprIntrppop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ExprIntrpfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ExprIntrplex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *ExprIntrpalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *ExprIntrprealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void ExprIntrpfree (void * ptr )
+{
+	free( (char *) ptr );	/* see ExprIntrprealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/ExprIntrp/lex.ExprIntrp.c OpenCASCADE6.3.0/ros/drv/ExprIntrp/lex.ExprIntrp.c
--- OpenCASCADE6.3.0.orig//ros/drv/ExprIntrp/lex.ExprIntrp.c	2010-07-04 20:11:25.649255139 +0200
+++ OpenCASCADE6.3.0/ros/drv/ExprIntrp/lex.ExprIntrp.c	2010-04-13 09:29:14.000000000 +0200
@@ -1,49 +1,92 @@
-#define yy_create_buffer ExprIntrp_create_buffer
-#define yy_delete_buffer ExprIntrp_delete_buffer
-#define yy_scan_buffer ExprIntrp_scan_buffer
-#define yy_scan_string ExprIntrp_scan_string
-#define yy_scan_bytes ExprIntrp_scan_bytes
-#define yy_flex_debug ExprIntrp_flex_debug
-#define yy_init_buffer ExprIntrp_init_buffer
-#define yy_flush_buffer ExprIntrp_flush_buffer
-#define yy_load_buffer_state ExprIntrp_load_buffer_state
-#define yy_switch_to_buffer ExprIntrp_switch_to_buffer
-#define yyin ExprIntrpin
-#define yyleng ExprIntrpleng
-#define yylex ExprIntrplex
-#define yyout ExprIntrpout
-#define yyrestart ExprIntrprestart
-#define yytext ExprIntrptext
-#define yywrap ExprIntrpwrap
 
-/* A lexical scanner generated by flex */
+#line 3 "lex.ExprIntrp.c"
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.89 96/05/25 21:02:21 vern Exp $
- */
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
 #endif
 
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
 
-#ifdef __cplusplus
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
 
-#include <stdlib.h>
-#include <unistd.h>
+#endif /* ! FLEXINT_H */
 
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
+#ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
@@ -52,34 +95,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -94,71 +120,75 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE ExprIntrprestart(ExprIntrpin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
 
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int ExprIntrpleng;
 
-extern int yyleng;
-extern FILE *yyin, *yyout;
+extern FILE *ExprIntrpin, *ExprIntrpout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+		/* Undo effects of setting up ExprIntrptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up ExprIntrptext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -195,12 +225,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -210,81 +244,108 @@
 	 * possible backing-up.
 	 *
 	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
+	 * (via ExprIntrprestart()), so that the user can continue scanning by
+	 * just pointing ExprIntrpin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
+/* yy_hold_char holds the character lost when ExprIntrptext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+int ExprIntrpleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+/* Flag which is used to allow ExprIntrpwrap()'s to do buffer switches
+ * instead of setting up a fresh ExprIntrpin.  A bit of a hack ...
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
-
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
+void ExprIntrprestart (FILE *input_file  );
+void ExprIntrp_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE ExprIntrp_create_buffer (FILE *file,int size  );
+void ExprIntrp_delete_buffer (YY_BUFFER_STATE b  );
+void ExprIntrp_flush_buffer (YY_BUFFER_STATE b  );
+void ExprIntrppush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void ExprIntrppop_buffer_state (void );
+
+static void ExprIntrpensure_buffer_stack (void );
+static void ExprIntrp_load_buffer_state (void );
+static void ExprIntrp_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER ExprIntrp_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE ExprIntrp_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE ExprIntrp_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE ExprIntrp_scan_bytes (yyconst char *bytes,int len  );
+
+void *ExprIntrpalloc (yy_size_t  );
+void *ExprIntrprealloc (void *,yy_size_t  );
+void ExprIntrpfree (void *  );
 
-#define yy_new_buffer yy_create_buffer
+#define yy_new_buffer ExprIntrp_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        ExprIntrpensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        ExprIntrpensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
 typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+FILE *ExprIntrpin = (FILE *) 0, *ExprIntrpout = (FILE *) 0;
+
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
-static yyconst short yy_nxt[][256] =
+
+extern int ExprIntrplineno;
+
+int ExprIntrplineno = 1;
+
+extern char *ExprIntrptext;
+#define yytext_ptr ExprIntrptext
+static yyconst flex_int16_t yy_nxt[][256] =
     {
     {
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
@@ -1994,25 +2055,31 @@
 
     } ;
 
-
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
+ * corresponding action - sets up ExprIntrptext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	ExprIntrpleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
 #define YY_NUM_RULES 26
 #define YY_END_OF_BUFFER 27
-static yyconst short int yy_accept[54] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[54] =
     {   0,
         0,    0,   27,   26,    1,   25,    8,   10,    7,    2,
        12,    3,   22,    4,   24,   26,   15,   13,   23,   23,
@@ -2035,6 +2102,9 @@
         0,    0,    0
     } ;
 
+extern int ExprIntrp_flex_debug;
+int ExprIntrp_flex_debug = 0;
+
 /* The intent behind this definition is that it'll catch
  * any uses of REJECT which flex missed.
  */
@@ -2042,8 +2112,7 @@
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#define INITIAL 0
+char *ExprIntrptext;
 #include <ExprIntrp.tab.h>
 #define YY_SKIP_YYWRAP
 
@@ -2062,77 +2131,62 @@
   ExprIntrp_delete_buffer(ExprIntrp_bufstring);
 }
 
-int yywrap()
+int ExprIntrpwrap()
 {
   return 1;
 }
 
+#define INITIAL 0
 
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
  */
 
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+#ifdef WNT
 #else
-extern int yywrap YY_PROTO(( void ));
-#endif
+#include <unistd.h>
 #endif
 
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
 #endif
 
-#ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
 #endif
 
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
-#endif
+static int yy_init_globals (void );
 
-#ifndef YY_NO_INPUT
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
+extern "C" int ExprIntrpwrap (void );
 #else
-static int input YY_PROTO(( void ));
+extern int ExprIntrpwrap (void );
 #endif
 #endif
 
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
-#else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
+static int input (void );
 #endif
+
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -2141,12 +2195,11 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO (void) fwrite( ExprIntrptext, ExprIntrpleng, 1, ExprIntrpout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -2154,8 +2207,19 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( (result = read( fileno(yyin), (char *) buf, max_size )) < 0 ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	errno=0; \
+	while ( (result = read( fileno(ExprIntrpin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(ExprIntrpin); \
+	}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -2176,14 +2240,20 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
+
+extern int ExprIntrplex (void);
+
+#define YY_DECL int ExprIntrplex (void)
+#endif /* !YY_DECL */
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+/* Code executed at the beginning of each rule, after ExprIntrptext and ExprIntrpleng
  * have been set up.
  */
 #ifndef YY_USER_ACTION
@@ -2198,58 +2268,60 @@
 #define YY_RULE_SETUP \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
-
-
-	if ( yy_init )
+    
+	if ( !(yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
 
-		if ( ! yyin )
-			yyin = stdin;
+		if ( ! ExprIntrpin )
+			ExprIntrpin = stdin;
 
-		if ( ! yyout )
-			yyout = stdout;
+		if ( ! ExprIntrpout )
+			ExprIntrpout = stdout;
 
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+		if ( ! YY_CURRENT_BUFFER ) {
+			ExprIntrpensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		ExprIntrp_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		/* Support of ExprIntrptext. */
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
+		yy_current_state = (yy_start);
 yy_match:
-		while ( (yy_current_state = yy_nxt[yy_current_state][YY_SC_TO_UI(*yy_cp)]) > 0 )
+		while ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) > 0 )
 			{
 			if ( yy_accept[yy_current_state] )
 				{
-				yy_last_accepting_state = yy_current_state;
-				yy_last_accepting_cpos = yy_cp;
+				(yy_last_accepting_state) = yy_current_state;
+				(yy_last_accepting_cpos) = yy_cp;
 				}
 
 			++yy_cp;
@@ -2262,17 +2334,15 @@
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 			case 0: /* must back up */
 			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = yy_hold_char;
-			yy_cp = yy_last_accepting_cpos + 1;
-			yy_current_state = yy_last_accepting_state;
+			*yy_cp = (yy_hold_char);
+			yy_cp = (yy_last_accepting_cpos) + 1;
+			yy_current_state = (yy_last_accepting_state);
 			goto yy_find_action;
 
 case 1:
@@ -2385,26 +2455,26 @@
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * just pointed ExprIntrpin at a new source and called
+			 * ExprIntrplex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = ExprIntrpin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -2414,13 +2484,13 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -2433,41 +2503,41 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( ExprIntrpwrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
+					 * ExprIntrptext, we can now set up
 					 * yy_c_buf_p so that if some total
 					 * hoser (like flex itself) wants to
 					 * call the scanner after we return the
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -2475,30 +2545,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -2509,8 +2579,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of ExprIntrplex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -2519,21 +2588,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -2553,34 +2621,30 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
-			YY_FATAL_ERROR(
-"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
 
 			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
@@ -2593,8 +2657,7 @@
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
+					ExprIntrprealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
 				}
 			else
 				/* Can't grow it, we don't own it. */
@@ -2604,33 +2667,35 @@
 				YY_FATAL_ERROR(
 				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
 
-			num_to_read = yy_current_buffer->yy_buf_size -
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
 						number_to_move - 1;
-#endif
+
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			ExprIntrprestart(ExprIntrpin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -2638,26 +2703,25 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
-	}
-
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
 
-	yy_current_state = yy_start;
-
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		if ( *yy_cp )
 			{
@@ -2667,30 +2731,23 @@
 			yy_current_state = yy_NUL_trans[yy_current_state];
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-	register char *yy_cp = yy_c_buf_p;
+    	register char *yy_cp = (yy_c_buf_p);
 
 	yy_current_state = yy_NUL_trans[yy_current_state];
 	yy_is_jam = (yy_current_state == 0);
@@ -2699,95 +2756,102 @@
 		{
 		if ( yy_accept[yy_current_state] )
 			{
-			yy_last_accepting_state = yy_current_state;
-			yy_last_accepting_cpos = yy_cp;
+			(yy_last_accepting_state) = yy_current_state;
+			(yy_last_accepting_cpos) = yy_cp;
 			}
 		}
 
 	return yy_is_jam ? 0 : yy_current_state;
-	}
-
+}
 
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	/* undo effects of setting up ExprIntrptext */
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
 
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					ExprIntrprestart(ExprIntrpin );
+
+					/*FALLTHROUGH*/
+
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
-						{
-						yy_c_buf_p = yytext_ptr + offset;
+					if ( ExprIntrpwrap( ) )
 						return EOF;
-						}
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -2797,180 +2861,171 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
-
-				case EOB_ACT_LAST_MATCH:
-#ifdef __cplusplus
-					YY_FATAL_ERROR(
-					"unexpected last match in yyinput()" );
-#else
-					YY_FATAL_ERROR(
-					"unexpected last match in input()" );
-#endif
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve ExprIntrptext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
 	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void ExprIntrprestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        ExprIntrpensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            ExprIntrp_create_buffer(ExprIntrpin,YY_BUF_SIZE );
 	}
 
+	ExprIntrp_init_buffer(YY_CURRENT_BUFFER,input_file );
+	ExprIntrp_load_buffer_state( );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void ExprIntrp_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		ExprIntrppop_buffer_state();
+	 *		ExprIntrppush_buffer_state(new_buffer);
+     */
+	ExprIntrpensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	ExprIntrp_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
+	 * EOF (ExprIntrpwrap()) processing, but the only time this flag
+	 * is looked at is after ExprIntrpwrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
+static void ExprIntrp_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	ExprIntrpin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
 
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE ExprIntrp_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) ExprIntrpalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_create_buffer()" );
 
 	b->yy_buf_size = size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) ExprIntrpalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	ExprIntrp_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with ExprIntrp_create_buffer()
+ * 
+ */
+    void ExprIntrp_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
+		ExprIntrpfree((void *) b->yy_ch_buf  );
 
-	yy_flex_free( (void *) b );
-	}
-
-
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
+	ExprIntrpfree((void *) b  );
+}
 
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a ExprIntrprestart() or at EOF.
+ */
+    static void ExprIntrp_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	ExprIntrp_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
+    /* If b is the current buffer, then ExprIntrp_init_buffer was _probably_
+     * called from ExprIntrprestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
 
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void ExprIntrp_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
 
-	{
 	b->yy_n_chars = 0;
 
 	/* We always need two end-of-buffer characters.  The first causes
@@ -2985,31 +3040,123 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		ExprIntrp_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void ExprIntrppush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	ExprIntrpensure_buffer_stack();
+
+	/* This block is copied from ExprIntrp_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from ExprIntrp_switch_to_buffer. */
+	ExprIntrp_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void ExprIntrppop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	ExprIntrp_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		ExprIntrp_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
 	}
+}
 
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void ExprIntrpensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ExprIntrpalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)ExprIntrprealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
 
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE ExprIntrp_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) ExprIntrpalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_scan_buffer()" );
 
 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
@@ -3021,58 +3168,53 @@
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	ExprIntrp_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *str )
-#else
-YY_BUFFER_STATE yy_scan_string( str )
-yyconst char *str;
-#endif
-	{
-	int len;
-	for ( len = 0; str[len]; ++len )
-		;
-
-	return yy_scan_bytes( str, len );
-	}
-#endif
+}
 
+/** Setup the input buffer state to scan a string. The next call to ExprIntrplex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       ExprIntrp_scan_bytes() instead.
+ */
+YY_BUFFER_STATE ExprIntrp_scan_string (yyconst char * yystr )
+{
+    
+	return ExprIntrp_scan_bytes(yystr,strlen(yystr) );
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan the given bytes. The next call to ExprIntrplex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE ExprIntrp_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
 	int i;
-
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	n = _yybytes_len + 2;
+	buf = (char *) ExprIntrpalloc(n  );
 	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "out of dynamic memory in ExprIntrp_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = ExprIntrp_scan_buffer(buf,n );
 	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "bad buffer in ExprIntrp_scan_bytes()" );
 
 	/* It's okay to grow etc. this buffer, and we should throw it
 	 * away when we're done.
@@ -3080,148 +3222,196 @@
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
+}
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+/* Redefine yyless() so it works in section 3 code. */
 
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up ExprIntrptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		ExprIntrptext[ExprIntrpleng] = (yy_hold_char); \
+		(yy_c_buf_p) = ExprIntrptext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		ExprIntrpleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+/* Accessor  methods (get/set functions) to struct members. */
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+/** Get the current line number.
+ * 
+ */
+int ExprIntrpget_lineno  (void)
+{
+        
+    return ExprIntrplineno;
+}
 
-	BEGIN(new_state);
-	}
-#endif
+/** Get the input stream.
+ * 
+ */
+FILE *ExprIntrpget_in  (void)
+{
+        return ExprIntrpin;
+}
 
+/** Get the output stream.
+ * 
+ */
+FILE *ExprIntrpget_out  (void)
+{
+        return ExprIntrpout;
+}
 
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+/** Get the length of the current token.
+ * 
+ */
+int ExprIntrpget_leng  (void)
+{
+        return ExprIntrpleng;
+}
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
+/** Get the current token.
+ * 
+ */
 
+char *ExprIntrpget_text  (void)
+{
+        return ExprIntrptext;
+}
 
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void ExprIntrpset_lineno (int  line_number )
+{
+    
+    ExprIntrplineno = line_number;
+}
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see ExprIntrp_switch_to_buffer
+ */
+void ExprIntrpset_in (FILE *  in_str )
+{
+        ExprIntrpin = in_str ;
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+void ExprIntrpset_out (FILE *  out_str )
+{
+        ExprIntrpout = out_str ;
+}
 
+int ExprIntrpget_debug  (void)
+{
+        return ExprIntrp_flex_debug;
+}
 
+void ExprIntrpset_debug (int  bdebug )
+{
+        ExprIntrp_flex_debug = bdebug ;
+}
 
-/* Redefine yyless() so it works in section 3 code. */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from ExprIntrplex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    ExprIntrpin = stdin;
+    ExprIntrpout = stdout;
+#else
+    ExprIntrpin = (FILE *) 0;
+    ExprIntrpout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * ExprIntrplex_init()
+     */
+    return 0;
+}
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+/* ExprIntrplex_destroy is for both reentrant and non-reentrant scanners. */
+int ExprIntrplex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		ExprIntrp_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		ExprIntrppop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	ExprIntrpfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ExprIntrplex() is called, initialization will occur. */
+    yy_init_globals( );
 
+    return 0;
+}
 
-/* Internal utility routines. */
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *ExprIntrpalloc (yy_size_t  size )
+{
 	return (void *) malloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *ExprIntrprealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -3230,22 +3420,12 @@
 	 * as though doing an assignment.
 	 */
 	return (void *) realloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void ExprIntrpfree (void * ptr )
+{
+	free( (char *) ptr );	/* see ExprIntrprealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/IntPatch/IntPatch_Intersection_0.cxx OpenCASCADE6.3.0/ros/drv/IntPatch/IntPatch_Intersection_0.cxx
--- OpenCASCADE6.3.0.orig//ros/drv/IntPatch/IntPatch_Intersection_0.cxx	2010-07-04 20:11:17.725333739 +0200
+++ OpenCASCADE6.3.0/ros/drv/IntPatch/IntPatch_Intersection_0.cxx	2010-03-25 11:39:16.000000000 +0100
@@ -75,6 +75,9 @@
 #ifndef _IntPatch_TheRLineOfIntersection_HeaderFile
 #include <IntPatch_TheRLineOfIntersection.hxx>
 #endif
+#ifndef _IntPatch_TheALineToWLineOfIntersection_HeaderFile
+#include <IntPatch_TheALineToWLineOfIntersection.hxx>
+#endif
 #ifndef _IntPatch_TheArcFunctionOfIntersection_HeaderFile
 #include <IntPatch_TheArcFunctionOfIntersection.hxx>
 #endif
@@ -144,9 +147,6 @@
 #ifndef _IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection_HeaderFile
 #include <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
 #endif
-#ifndef _IntPatch_TheALineToWLineOfIntersection_HeaderFile
-#include <IntPatch_TheALineToWLineOfIntersection.hxx>
-#endif
 #ifndef _IntPatch_TheLineConstructorOfIntersection_HeaderFile
 #include <IntPatch_TheLineConstructorOfIntersection.hxx>
 #endif
@@ -192,6 +192,8 @@
 #define IntPatch_TheWLine_hxx <IntPatch_TheWLineOfIntersection.hxx>
 #define IntPatch_TheRLine IntPatch_TheRLineOfIntersection
 #define IntPatch_TheRLine_hxx <IntPatch_TheRLineOfIntersection.hxx>
+#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
+#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheArcFunction IntPatch_TheArcFunctionOfIntersection
 #define IntPatch_TheArcFunction_hxx <IntPatch_TheArcFunctionOfIntersection.hxx>
 #define IntPatch_TheSOnBounds IntPatch_TheSOnBoundsOfIntersection
@@ -272,8 +274,6 @@
 #define IntPatch_ThePWalkingInterOfThePPInt_hxx <IntPatch_ThePWalkingInterOfThePPIntOfIntersection.hxx>
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
-#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
-#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheLineConstructor IntPatch_TheLineConstructorOfIntersection
 #define IntPatch_TheLineConstructor_hxx <IntPatch_TheLineConstructorOfIntersection.hxx>
 #define Handle_IntPatch_SequenceNodeOfSequenceOfPoint Handle_IntPatch_SequenceNodeOfSequenceOfPointOfIntersection
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/StepFile/.adm/StepFile_obj_inc.In OpenCASCADE6.3.0/ros/drv/StepFile/.adm/StepFile_obj_inc.In
--- OpenCASCADE6.3.0.orig//ros/drv/StepFile/.adm/StepFile_obj_inc.In	2010-07-04 20:10:56.666348121 +0200
+++ OpenCASCADE6.3.0/ros/drv/StepFile/.adm/StepFile_obj_inc.In	2009-09-21 15:37:35.000000000 +0200
@@ -1,4 +1,4 @@
-+ StepFile:source:StepFile_CallFailure.hxx /dn23/RLSTST/ros/src/StepFile/StepFile_CallFailure.hxx
-+ StepFile:source:StepFile_Read.hxx /dn23/RLSTST/ros/src/StepFile/StepFile_Read.hxx
-+ StepFile:source:StepFile_Transfer.hxx /dn23/RLSTST/ros/src/StepFile/StepFile_Transfer.hxx
-- StepFile:admfile:StepFile_src.Out /dn23/RLSTST/ros/.adm/StepFile/StepFile_src.Out
++ StepFile:source:StepFile_CallFailure.hxx /dn03/OS/OCC/CAS63-sp7/src/StepFile/StepFile_CallFailure.hxx
++ StepFile:source:StepFile_Read.hxx /dn03/OS/OCC/CAS63-sp7/src/StepFile/StepFile_Read.hxx
++ StepFile:source:StepFile_Transfer.hxx /dn03/OS/OCC/CAS63-sp7/src/StepFile/StepFile_Transfer.hxx
+- StepFile:admfile:StepFile_src.Out /dn03/OS/OCC/CAS63-sp7/.adm/StepFile/StepFile_src.Out
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/StepFile/.adm/StepFile_obj_inc.Out OpenCASCADE6.3.0/ros/drv/StepFile/.adm/StepFile_obj_inc.Out
--- OpenCASCADE6.3.0.orig//ros/drv/StepFile/.adm/StepFile_obj_inc.Out	2010-07-04 20:10:56.666348121 +0200
+++ OpenCASCADE6.3.0/ros/drv/StepFile/.adm/StepFile_obj_inc.Out	2009-09-21 15:37:36.000000000 +0200
@@ -1,6 +1,6 @@
-+M StepFile:pubinclude:StepFile_CallFailure.hxx /dn23/RLSTST/ros/inc/StepFile_CallFailure.hxx
-+M StepFile:pubinclude:StepFile_Read.hxx /dn23/RLSTST/ros/inc/StepFile_Read.hxx
-+M StepFile:pubinclude:StepFile_Transfer.hxx /dn23/RLSTST/ros/inc/StepFile_Transfer.hxx
-+M StepFile:dbadmfile:StepFile_obj_inc.In /dn23/RLSTST/ros/drv/StepFile/.adm/StepFile_obj_inc.In
-+M StepFile:dbadmfile:StepFile_obj_inc.Out /dn23/RLSTST/ros/drv/StepFile/.adm/StepFile_obj_inc.Out
-+M StepFile:dbadmfile:StepFile_obj_inc.Dep /dn23/RLSTST/ros/drv/StepFile/.adm/StepFile_obj_inc.Dep
++M StepFile:pubinclude:StepFile_CallFailure.hxx /dn03/OS/OCC/CAS63-sp7/inc/StepFile_CallFailure.hxx
++M StepFile:pubinclude:StepFile_Read.hxx /dn03/OS/OCC/CAS63-sp7/inc/StepFile_Read.hxx
++M StepFile:pubinclude:StepFile_Transfer.hxx /dn03/OS/OCC/CAS63-sp7/inc/StepFile_Transfer.hxx
++M StepFile:dbadmfile:StepFile_obj_inc.In /dn03/OS/OCC/CAS63-sp7/drv/StepFile/.adm/StepFile_obj_inc.In
++M StepFile:dbadmfile:StepFile_obj_inc.Out /dn03/OS/OCC/CAS63-sp7/drv/StepFile/.adm/StepFile_obj_inc.Out
++M StepFile:dbadmfile:StepFile_obj_inc.Dep /dn03/OS/OCC/CAS63-sp7/drv/StepFile/.adm/StepFile_obj_inc.Dep
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/StepFile/lex.step.c OpenCASCADE6.3.0/ros/drv/StepFile/lex.step.c
--- OpenCASCADE6.3.0.orig//ros/drv/StepFile/lex.step.c	2010-07-04 20:10:56.666348121 +0200
+++ OpenCASCADE6.3.0/ros/drv/StepFile/lex.step.c	2009-09-21 15:37:35.000000000 +0200
@@ -1,49 +1,92 @@
-#define yy_create_buffer step_create_buffer
-#define yy_delete_buffer step_delete_buffer
-#define yy_scan_buffer step_scan_buffer
-#define yy_scan_string step_scan_string
-#define yy_scan_bytes step_scan_bytes
-#define yy_flex_debug step_flex_debug
-#define yy_init_buffer step_init_buffer
-#define yy_flush_buffer step_flush_buffer
-#define yy_load_buffer_state step_load_buffer_state
-#define yy_switch_to_buffer step_switch_to_buffer
-#define yyin stepin
-#define yyleng stepleng
-#define yylex steplex
-#define yyout stepout
-#define yyrestart steprestart
-#define yytext steptext
-#define yywrap stepwrap
 
-/* A lexical scanner generated by flex */
+#line 3 "lex.step.c"
 
-/* Scanner skeleton version:
- * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.89 96/05/25 21:02:21 vern Exp $
- */
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
 
+/* begin standard C headers. */
 #include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
 
+/* end standard C headers. */
 
-/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
-#ifdef c_plusplus
-#ifndef __cplusplus
-#define __cplusplus
-#endif
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
 #endif
 
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
 
-#ifdef __cplusplus
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
 
-#include <stdlib.h>
-#include <unistd.h>
+#endif /* ! FLEXINT_H */
 
-/* Use prototypes in function declarations. */
-#define YY_USE_PROTOS
+#ifdef __cplusplus
 
 /* The "const" storage-class-modifier is valid. */
 #define YY_USE_CONST
@@ -52,34 +95,17 @@
 
 #if __STDC__
 
-#define YY_USE_PROTOS
 #define YY_USE_CONST
 
 #endif	/* __STDC__ */
 #endif	/* ! __cplusplus */
 
-#ifdef __TURBOC__
- #pragma warn -rch
- #pragma warn -use
-#include <io.h>
-#include <stdlib.h>
-#define YY_USE_CONST
-#define YY_USE_PROTOS
-#endif
-
 #ifdef YY_USE_CONST
 #define yyconst const
 #else
 #define yyconst
 #endif
 
-
-#ifdef YY_USE_PROTOS
-#define YY_PROTO(proto) proto
-#else
-#define YY_PROTO(proto) ()
-#endif
-
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
@@ -94,71 +120,75 @@
  * but we do it the disgusting crufty way forced on us by the ()-less
  * definition of BEGIN.
  */
-#define BEGIN yy_start = 1 + 2 *
+#define BEGIN (yy_start) = 1 + 2 *
 
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
-#define YY_START ((yy_start - 1) / 2)
+#define YY_START (((yy_start) - 1) / 2)
 #define YYSTATE YY_START
 
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
 
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin )
+#define YY_NEW_FILE steprestart(stepin  )
 
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
 #define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
 
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int stepleng;
 
-extern int yyleng;
-extern FILE *yyin, *yyout;
+extern FILE *stepin, *stepout;
 
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
 
-/* The funky do-while in the following #define is used to turn the definition
- * int a single C statement (which needs a semi-colon terminator).  This
- * avoids problems with code like:
- *
- * 	if ( condition_holds )
- *		yyless( 5 );
- *	else
- *		do_something_else();
- *
- * Prior to using the do-while the compiler would get upset at the
- * "else" because it interpreted the "if" statement as being all
- * done when it reached the ';' after the yyless() call.
- */
-
-/* Return all but the first 'n' matched characters back to the input stream. */
-
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
 	do \
 		{ \
-		/* Undo effects of setting up yytext. */ \
-		*yy_cp = yy_hold_char; \
+		/* Undo effects of setting up steptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
 		YY_RESTORE_YY_MORE_OFFSET \
-		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up steptext again */ \
 		} \
 	while ( 0 )
 
-#define unput(c) yyunput( c, yytext_ptr )
+#define unput(c) yyunput( c, (yytext_ptr)  )
 
 /* The following is because we cannot portably get our hands on size_t
  * (without autoconf's help, which isn't available because we want
  * flex-generated scanners to compile on their own).
  */
-typedef unsigned int yy_size_t;
 
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
 
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
 struct yy_buffer_state
 	{
 	FILE *yy_input_file;
@@ -195,12 +225,16 @@
 	 */
 	int yy_at_bol;
 
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
 	int yy_fill_buffer;
 
 	int yy_buffer_status;
+
 #define YY_BUFFER_NEW 0
 #define YY_BUFFER_NORMAL 1
 	/* When an EOF's been seen but there's still some text to process
@@ -210,101 +244,133 @@
 	 * possible backing-up.
 	 *
 	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
+	 * (via steprestart()), so that the user can continue scanning by
+	 * just pointing stepin at a new input file.
 	 */
 #define YY_BUFFER_EOF_PENDING 2
+
 	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
 
-static YY_BUFFER_STATE yy_current_buffer = 0;
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
 
 /* We provide macros for accessing buffer states in case in the
  * future we want to put the buffer states in a more general
  * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
  */
-#define YY_CURRENT_BUFFER yy_current_buffer
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
 
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
 
-/* yy_hold_char holds the character lost when yytext is formed. */
+/* yy_hold_char holds the character lost when steptext is formed. */
 static char yy_hold_char;
-
 static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-
-
-int yyleng;
+int stepleng;
 
 /* Points to current character in buffer. */
 static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 1;		/* whether we need to initialize */
+static int yy_init = 0;		/* whether we need to initialize */
 static int yy_start = 0;	/* start state number */
 
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
+/* Flag which is used to allow stepwrap()'s to do buffer switches
+ * instead of setting up a fresh stepin.  A bit of a hack ...
  */
 static int yy_did_buffer_switch_on_eof;
 
-void yyrestart YY_PROTO(( FILE *input_file ));
+void steprestart (FILE *input_file  );
+void step_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE step_create_buffer (FILE *file,int size  );
+void step_delete_buffer (YY_BUFFER_STATE b  );
+void step_flush_buffer (YY_BUFFER_STATE b  );
+void steppush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void steppop_buffer_state (void );
+
+static void stepensure_buffer_stack (void );
+static void step_load_buffer_state (void );
+static void step_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER step_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE step_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE step_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE step_scan_bytes (yyconst char *bytes,int len  );
+
+void *stepalloc (yy_size_t  );
+void *steprealloc (void *,yy_size_t  );
+void stepfree (void *  );
 
-void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
-void yy_load_buffer_state YY_PROTO(( void ));
-YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
-void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
-void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
-#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )
-
-YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
-YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *str ));
-YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));
-
-static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
-static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
-static void yy_flex_free YY_PROTO(( void * ));
-
-#define yy_new_buffer yy_create_buffer
+#define yy_new_buffer step_create_buffer
 
 #define yy_set_interactive(is_interactive) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_is_interactive = is_interactive; \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        stepensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            step_create_buffer(stepin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
 
 #define yy_set_bol(at_bol) \
 	{ \
-	if ( ! yy_current_buffer ) \
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	yy_current_buffer->yy_at_bol = at_bol; \
+	if ( ! YY_CURRENT_BUFFER ){\
+        stepensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            step_create_buffer(stepin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
 
-#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)
-
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
-#define YY_USES_REJECT
 typedef unsigned char YY_CHAR;
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+FILE *stepin = (FILE *) 0, *stepout = (FILE *) 0;
+
 typedef int yy_state_type;
-extern char *yytext;
-#define yytext_ptr yytext
 
-static yy_state_type yy_get_previous_state YY_PROTO(( void ));
-static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
-static int yy_get_next_buffer YY_PROTO(( void ));
-static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));
+extern int steplineno;
+
+int steplineno = 1;
+
+extern char *steptext;
+#define yytext_ptr steptext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
 
 /* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
+ * corresponding action - sets up steptext.
  */
 #define YY_DO_BEFORE_ACTION \
-	yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	yy_hold_char = *yy_cp; \
+	(yytext_ptr) = yy_bp; \
+	stepleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
 	*yy_cp = '\0'; \
-	yy_c_buf_p = yy_cp;
+	(yy_c_buf_p) = yy_cp;
 
 #define YY_NUM_RULES 37
 #define YY_END_OF_BUFFER 38
-static yyconst short int yy_acclist[146] =
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_acclist[146] =
     {   0,
        38,   36,   37,    1,   36,   37,    3,   36,   37,    4,
        36,   37,    2,   36,   37,   36,   37,   36,   37,   36,
@@ -324,7 +390,7 @@
        33,   34,   27,   28,   28
     } ;
 
-static yyconst short int yy_accept[109] =
+static yyconst flex_int16_t yy_accept[109] =
     {   0,
         1,    1,    1,    2,    4,    7,   10,   13,   16,   18,
        20,   22,   25,   27,   29,   32,   34,   36,   39,   42,
@@ -340,7 +406,7 @@
       139,  140,  140,  141,  143,  145,  146,  146
     } ;
 
-static yyconst int yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
         4,    4,    5,    4,    4,    4,    4,    4,    4,    4,
@@ -372,7 +438,7 @@
         4,    4,    4,    4,    4
     } ;
 
-static yyconst int yy_meta[40] =
+static yyconst flex_int32_t yy_meta[40] =
     {   0,
         1,    2,    3,    2,    2,    2,    2,    2,    2,    2,
         2,    2,    2,    2,    2,    2,    2,    2,    4,    2,
@@ -380,7 +446,7 @@
         6,    6,    6,    6,    6,    6,    6,    7,    2
     } ;
 
-static yyconst short int yy_base[114] =
+static yyconst flex_int16_t yy_base[114] =
     {   0,
         0,    0,  209,  210,  210,  210,  210,  210,    0,    0,
       187,  210,  171,   37,  210,  210,  186,   22,  210,   23,
@@ -397,7 +463,7 @@
       176,  179,  186
     } ;
 
-static yyconst short int yy_def[114] =
+static yyconst flex_int16_t yy_def[114] =
     {   0,
       107,    1,  107,  107,  107,  107,  107,  107,  108,  109,
       107,  107,  107,  110,  107,  107,  107,  107,  107,  111,
@@ -414,7 +480,7 @@
       107,  107,  107
     } ;
 
-static yyconst short int yy_nxt[250] =
+static yyconst flex_int16_t yy_nxt[250] =
     {   0,
         4,    5,    6,    4,    7,    8,    9,   10,   11,   12,
        13,   14,   15,   16,   17,   18,   19,   18,   20,   21,
@@ -445,7 +511,7 @@
       107,  107,  107,  107,  107,  107,  107,  107,  107
     } ;
 
-static yyconst short int yy_chk[250] =
+static yyconst flex_int16_t yy_chk[250] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -476,7 +542,10 @@
       107,  107,  107,  107,  107,  107,  107,  107,  107
     } ;
 
-static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
+extern int step_flex_debug;
+int step_flex_debug = 0;
+
+static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
 static char *yy_full_match;
 static int yy_lp;
 static int yy_looking_for_trail_begin = 0;
@@ -486,19 +555,19 @@
 #define YY_TRAILING_HEAD_MASK 0x4000
 #define REJECT \
 { \
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
-yy_cp = yy_full_match; /* restore poss. backed-over text */ \
-yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \
-yy_state_ptr = yy_full_state; /* restore orig. state */ \
-yy_current_state = *yy_state_ptr; /* restore curr. state */ \
-++yy_lp; \
+*yy_cp = (yy_hold_char); /* undo effects of setting up steptext */ \
+yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
+(yy_lp) = yy_full_lp; /* restore orig. accepting pos. */ \
+(yy_state_ptr) = yy_full_state; /* restore orig. state */ \
+yy_current_state = *(yy_state_ptr); /* restore curr. state */ \
+++(yy_lp); \
 goto find_rule; \
 }
+
 #define yymore() yymore_used_but_not_detected
 #define YY_MORE_ADJ 0
 #define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#define INITIAL 0
+char *steptext;
 #include "step.tab.h"
 #include "recfile.ph"
 #include "stdio.h"
@@ -522,8 +591,23 @@
 
   int  modcom = 0;      /* Commentaires type C */
   void resultat ()           /* Resultat alloue dynamiquement, "jete" une fois lu */
-      { if (modcom == 0) rec_restext(yytext,yyleng); }
+      { if (modcom == 0) rec_restext(steptext,stepleng); }
 
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -531,65 +615,30 @@
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap YY_PROTO(( void ));
+extern "C" int stepwrap (void );
 #else
-extern int yywrap YY_PROTO(( void ));
-#endif
+extern int stepwrap (void );
 #endif
-
-#ifndef YY_NO_UNPUT
-static void yyunput YY_PROTO(( int c, char *buf_ptr ));
 #endif
 
+    static void yyunput (int c,char *buf_ptr  );
+    
 #ifndef yytext_ptr
-static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
+static void yy_flex_strncpy (char *,yyconst char *,int );
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen YY_PROTO(( yyconst char * ));
+static int yy_flex_strlen (yyconst char * );
 #endif
 
 #ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput YY_PROTO(( void ));
-#else
-static int input YY_PROTO(( void ));
-#endif
-#endif
-
-#if YY_STACK_USED
-static int yy_start_stack_ptr = 0;
-static int yy_start_stack_depth = 0;
-static int *yy_start_stack = 0;
-#ifndef YY_NO_PUSH_STATE
-static void yy_push_state YY_PROTO(( int new_state ));
-#endif
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state YY_PROTO(( void ));
-#endif
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state YY_PROTO(( void ));
-#endif
 
+#ifdef __cplusplus
+static int yyinput (void );
 #else
-#define YY_NO_PUSH_STATE 1
-#define YY_NO_POP_STATE 1
-#define YY_NO_TOP_STATE 1
+static int input (void );
 #endif
 
-#ifdef YY_MALLOC_DECL
-YY_MALLOC_DECL
-#else
-#if __STDC__
-#ifndef __cplusplus
-#include <stdlib.h>
-#endif
-#else
-/* Just try to get by without declaring the routines.  This will fail
- * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
- * or sizeof(void*) != sizeof(int).
- */
-#endif
 #endif
 
 /* Amount of stuff to slurp up with each read. */
@@ -598,12 +647,11 @@
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
-
 #ifndef ECHO
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
+#define ECHO (void) fwrite( steptext, stepleng, 1, stepout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -611,21 +659,35 @@
  */
 #ifndef YY_INPUT
 #define YY_INPUT(buf,result,max_size) \
-	if ( yy_current_buffer->yy_is_interactive ) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
-		int c = '*', n; \
+		int c = '*'; \
+		size_t n; \
 		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			     (c = getc( stepin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
 		if ( c == '\n' ) \
 			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
+		if ( c == EOF && ferror( stepin ) ) \
 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
 		result = n; \
 		} \
-	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
-		  && ferror( yyin ) ) \
-		YY_FATAL_ERROR( "input in flex scanner failed" );
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, stepin))==0 && ferror(stepin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(stepin); \
+			} \
+		}\
+\
+
 #endif
 
 /* No semi-colon after return; correct usage is to write "yyterminate();" -
@@ -646,14 +708,20 @@
 #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
 #endif
 
+/* end tables serialization structures and prototypes */
+
 /* Default declaration of generated scanner - a define so the user can
  * easily add parameters.
  */
 #ifndef YY_DECL
-#define YY_DECL int yylex YY_PROTO(( void ))
-#endif
+#define YY_DECL_IS_OURS 1
 
-/* Code executed at the beginning of each rule, after yytext and yyleng
+extern int steplex (void);
+
+#define YY_DECL int steplex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after steptext and stepleng
  * have been set up.
  */
 #ifndef YY_USER_ACTION
@@ -668,53 +736,61 @@
 #define YY_RULE_SETUP \
 	YY_USER_ACTION
 
+/** The main scanner function which does all the work.
+ */
 YY_DECL
-	{
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp, *yy_bp;
 	register int yy_act;
-
-
-
-	if ( yy_init )
+    
+	if ( !(yy_init) )
 		{
-		yy_init = 0;
+		(yy_init) = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
 #endif
 
-		if ( ! yy_start )
-			yy_start = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! yy_current_buffer )
-			yy_current_buffer =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
+        /* Create the reject buffer large enough to save one state per allowed character. */
+        if ( ! (yy_state_buf) )
+            (yy_state_buf) = (yy_state_type *)stepalloc(YY_STATE_BUF_SIZE  );
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! stepin )
+			stepin = stdin;
+
+		if ( ! stepout )
+			stepout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			stepensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				step_create_buffer(stepin,YY_BUF_SIZE );
+		}
 
-		yy_load_buffer_state();
+		step_load_buffer_state( );
 		}
 
 	while ( 1 )		/* loops until end-of-file is reached */
 		{
-		yy_cp = yy_c_buf_p;
+		yy_cp = (yy_c_buf_p);
 
-		/* Support of yytext. */
-		*yy_cp = yy_hold_char;
+		/* Support of steptext. */
+		*yy_cp = (yy_hold_char);
 
 		/* yy_bp points to the position in yy_ch_buf of the start of
 		 * the current run.
 		 */
 		yy_bp = yy_cp;
 
-		yy_current_state = yy_start;
-		yy_state_ptr = yy_state_buf;
-		*yy_state_ptr++ = yy_current_state;
+		yy_current_state = (yy_start);
+
+		(yy_state_ptr) = (yy_state_buf);
+		*(yy_state_ptr)++ = yy_current_state;
+
 yy_match:
 		do
 			{
@@ -726,20 +802,20 @@
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			*yy_state_ptr++ = yy_current_state;
+			*(yy_state_ptr)++ = yy_current_state;
 			++yy_cp;
 			}
 		while ( yy_base[yy_current_state] != 210 );
 
 yy_find_action:
-		yy_current_state = *--yy_state_ptr;
-		yy_lp = yy_accept[yy_current_state];
+		yy_current_state = *--(yy_state_ptr);
+		(yy_lp) = yy_accept[yy_current_state];
 find_rule: /* we branch to this label when backing up */
 		for ( ; ; ) /* until we find what rule we matched */
 			{
-			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
+			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
 				{
-				yy_act = yy_acclist[yy_lp];
+				yy_act = yy_acclist[(yy_lp)];
 				if ( yy_act & YY_TRAILING_HEAD_MASK ||
 				     yy_looking_for_trail_begin )
 					{
@@ -757,25 +833,23 @@
 					}
 				else
 					{
-					yy_full_match = yy_cp;
-					yy_full_state = yy_state_ptr;
-					yy_full_lp = yy_lp;
+					(yy_full_match) = yy_cp;
+					yy_full_state = (yy_state_ptr);
+					yy_full_lp = (yy_lp);
 					break;
 					}
-				++yy_lp;
+				++(yy_lp);
 				goto find_rule;
 				}
 			--yy_cp;
-			yy_current_state = *--yy_state_ptr;
-			yy_lp = yy_accept[yy_current_state];
+			yy_current_state = *--(yy_state_ptr);
+			(yy_lp) = yy_accept[yy_current_state];
 			}
 
 		YY_DO_BEFORE_ACTION;
 
-
 do_action:	/* This label is used only to access EOF actions. */
 
-
 		switch ( yy_act )
 	{ /* beginning of action switch */
 case 1:
@@ -787,6 +861,7 @@
 {;}
 	YY_BREAK
 case 3:
+/* rule 3 can match eol */
 YY_RULE_SETUP
 { steplineno ++; }
 	YY_BREAK
@@ -799,9 +874,9 @@
 {;} /* fix from C21. for test load e3i file with line 15 with null symbols */
 	YY_BREAK
 case 6:
-*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
-yy_c_buf_p = yy_cp -= 1;
-YY_DO_BEFORE_ACTION; /* set up yytext again */
+*yy_cp = (yy_hold_char); /* undo effects of setting up steptext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up steptext again */
 YY_RULE_SETUP
 { resultat();  if (modcom == 0) return(ENTITY); }
 	YY_BREAK
@@ -826,6 +901,7 @@
 { resultat(); if (modcom == 0) { rec_typarg(rec_argFloat); return(QUID); } }
 	YY_BREAK
 case 12:
+/* rule 12 can match eol */
 YY_RULE_SETUP
 { resultat(); if (modcom == 0) { rec_typarg(rec_argText); return(QUID); } }
 	YY_BREAK
@@ -922,6 +998,7 @@
 { resultat();  if (modcom == 0) return(TYPE); }
 	YY_BREAK
 case 36:
+/* rule 36 can match eol */
 YY_RULE_SETUP
 { resultat();  if (modcom == 0) { rec_typarg(rec_argMisc); return(QUID); } }
 	YY_BREAK
@@ -935,26 +1012,26 @@
 	case YY_END_OF_BUFFER:
 		{
 		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
 
 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = yy_hold_char;
+		*yy_cp = (yy_hold_char);
 		YY_RESTORE_YY_MORE_OFFSET
 
-		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
 			{
 			/* We're scanning a new file or input source.  It's
 			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between yy_current_buffer and our
+			 * just pointed stepin at a new source and called
+			 * steplex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
 			 * globals.  Here is the right place to do so, because
 			 * this is the first action (other than possibly a
 			 * back-up) that will match for the new input source.
 			 */
-			yy_n_chars = yy_current_buffer->yy_n_chars;
-			yy_current_buffer->yy_input_file = yyin;
-			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = stepin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
 			}
 
 		/* Note that here we test for yy_c_buf_p "<=" to the position
@@ -964,13 +1041,13 @@
 		 * end-of-buffer state).  Contrast this with the test
 		 * in input().
 		 */
-		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			{ /* This was really a NUL. */
 			yy_state_type yy_next_state;
 
-			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
 
-			yy_current_state = yy_get_previous_state();
+			yy_current_state = yy_get_previous_state(  );
 
 			/* Okay, we're now positioned to make the NUL
 			 * transition.  We couldn't have
@@ -983,41 +1060,41 @@
 
 			yy_next_state = yy_try_NUL_trans( yy_current_state );
 
-			yy_bp = yytext_ptr + YY_MORE_ADJ;
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 
 			if ( yy_next_state )
 				{
 				/* Consume the NUL. */
-				yy_cp = ++yy_c_buf_p;
+				yy_cp = ++(yy_c_buf_p);
 				yy_current_state = yy_next_state;
 				goto yy_match;
 				}
 
 			else
 				{
-				yy_cp = yy_c_buf_p;
+				yy_cp = (yy_c_buf_p);
 				goto yy_find_action;
 				}
 			}
 
-		else switch ( yy_get_next_buffer() )
+		else switch ( yy_get_next_buffer(  ) )
 			{
 			case EOB_ACT_END_OF_FILE:
 				{
-				yy_did_buffer_switch_on_eof = 0;
+				(yy_did_buffer_switch_on_eof) = 0;
 
-				if ( yywrap() )
+				if ( stepwrap( ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
+					 * steptext, we can now set up
 					 * yy_c_buf_p so that if some total
 					 * hoser (like flex itself) wants to
 					 * call the scanner after we return the
 					 * YY_NULL, it'll still work - another
 					 * YY_NULL will get returned.
 					 */
-					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
 
 					yy_act = YY_STATE_EOF(YY_START);
 					goto do_action;
@@ -1025,30 +1102,30 @@
 
 				else
 					{
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 					}
 				break;
 				}
 
 			case EOB_ACT_CONTINUE_SCAN:
-				yy_c_buf_p =
-					yytext_ptr + yy_amount_of_matched_text;
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_match;
 
 			case EOB_ACT_LAST_MATCH:
-				yy_c_buf_p =
-				&yy_current_buffer->yy_ch_buf[yy_n_chars];
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
 
-				yy_current_state = yy_get_previous_state();
+				yy_current_state = yy_get_previous_state(  );
 
-				yy_cp = yy_c_buf_p;
-				yy_bp = yytext_ptr + YY_MORE_ADJ;
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
 				goto yy_find_action;
 			}
 		break;
@@ -1059,8 +1136,7 @@
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of yylex */
-
+} /* end of steplex */
 
 /* yy_get_next_buffer - try to read in a new buffer
  *
@@ -1069,21 +1145,20 @@
  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
  *	EOB_ACT_END_OF_FILE - end of file
  */
-
-static int yy_get_next_buffer()
-	{
-	register char *dest = yy_current_buffer->yy_ch_buf;
-	register char *source = yytext_ptr;
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
 	register int number_to_move, i;
 	int ret_val;
 
-	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
 		YY_FATAL_ERROR(
 		"fatal flex scanner internal error--end of buffer missed" );
 
-	if ( yy_current_buffer->yy_fill_buffer == 0 )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
 		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
 			{
 			/* We matched a single character, the EOB, so
 			 * treat this as a final EOF.
@@ -1103,84 +1178,52 @@
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
 
-	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
 		/* don't do the read, it's not guaranteed to return an EOF,
 		 * just force an EOF
 		 */
-		yy_n_chars = 0;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
 
 	else
 		{
-		int num_to_read =
-			yy_current_buffer->yy_buf_size - number_to_move - 1;
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
-#ifdef YY_USES_REJECT
+
 			YY_FATAL_ERROR(
 "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
-#else
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = yy_current_buffer;
-
-			int yy_c_buf_p_offset =
-				(int) (yy_c_buf_p - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yy_flex_realloc( (void *) b->yy_ch_buf,
-							 b->yy_buf_size + 2 );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
 
-			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = yy_current_buffer->yy_buf_size -
-						number_to_move - 1;
-#endif
 			}
 
 		if ( num_to_read > YY_READ_BUF_SIZE )
 			num_to_read = YY_READ_BUF_SIZE;
 
 		/* Read in more data. */
-		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
-			yy_n_chars, num_to_read );
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	if ( yy_n_chars == 0 )
+	if ( (yy_n_chars) == 0 )
 		{
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin );
+			steprestart(stepin  );
 			}
 
 		else
 			{
 			ret_val = EOB_ACT_LAST_MATCH;
-			yy_current_buffer->yy_buffer_status =
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
 				YY_BUFFER_EOF_PENDING;
 			}
 		}
@@ -1188,28 +1231,28 @@
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	yy_n_chars += number_to_move;
-	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
-	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
 
-	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
 
 	return ret_val;
-	}
-
+}
 
 /* yy_get_previous_state - get the state just before the EOB char was reached */
 
-static yy_state_type yy_get_previous_state()
-	{
+    static yy_state_type yy_get_previous_state (void)
+{
 	register yy_state_type yy_current_state;
 	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
 
-	yy_current_state = yy_start;
-	yy_state_ptr = yy_state_buf;
-	*yy_state_ptr++ = yy_current_state;
+	(yy_state_ptr) = (yy_state_buf);
+	*(yy_state_ptr)++ = yy_current_state;
 
-	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
 		{
 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 39);
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
@@ -1219,28 +1262,21 @@
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		*yy_state_ptr++ = yy_current_state;
+		*(yy_state_ptr)++ = yy_current_state;
 		}
 
 	return yy_current_state;
-	}
-
+}
 
 /* yy_try_NUL_trans - try to make a transition on the NUL character
  *
  * synopsis
  *	next_state = yy_try_NUL_trans( current_state );
  */
-
-#ifdef YY_USE_PROTOS
-static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
-#else
-static yy_state_type yy_try_NUL_trans( yy_current_state )
-yy_state_type yy_current_state;
-#endif
-	{
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
 	register int yy_is_jam;
-
+    
 	register YY_CHAR yy_c = 39;
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
@@ -1251,92 +1287,99 @@
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 	yy_is_jam = (yy_current_state == 107);
 	if ( ! yy_is_jam )
-		*yy_state_ptr++ = yy_current_state;
+		*(yy_state_ptr)++ = yy_current_state;
 
 	return yy_is_jam ? 0 : yy_current_state;
-	}
-
+}
 
-#ifndef YY_NO_UNPUT
-#ifdef YY_USE_PROTOS
-static void yyunput( int c, register char *yy_bp )
-#else
-static void yyunput( c, yy_bp )
-int c;
-register char *yy_bp;
-#endif
-	{
-	register char *yy_cp = yy_c_buf_p;
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
 
-	/* undo effects of setting up yytext */
-	*yy_cp = yy_hold_char;
+	/* undo effects of setting up steptext */
+	*yy_cp = (yy_hold_char);
 
-	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		register int number_to_move = yy_n_chars + 2;
-		register char *dest = &yy_current_buffer->yy_ch_buf[
-					yy_current_buffer->yy_buf_size + 2];
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
 		register char *source =
-				&yy_current_buffer->yy_ch_buf[number_to_move];
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
-		while ( source > yy_current_buffer->yy_ch_buf )
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			*--dest = *--source;
 
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
-		yy_n_chars = yy_current_buffer->yy_buf_size;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
-		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
 		}
 
 	*--yy_cp = (char) c;
 
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
 
-	yytext_ptr = yy_bp;
-	yy_hold_char = *yy_cp;
-	yy_c_buf_p = yy_cp;
-	}
-#endif	/* ifndef YY_NO_UNPUT */
-
-
+#ifndef YY_NO_INPUT
 #ifdef __cplusplus
-static int yyinput()
+    static int yyinput (void)
 #else
-static int input()
+    static int input  (void)
 #endif
-	{
-	int c;
 
-	*yy_c_buf_p = yy_hold_char;
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
 
-	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
 		{
 		/* yy_c_buf_p now points to the character we want to return.
 		 * If this occurs *before* the EOB characters, then it's a
 		 * valid NUL; if not, then we've hit the end of the buffer.
 		 */
-		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
 			/* This was really a NUL. */
-			*yy_c_buf_p = '\0';
+			*(yy_c_buf_p) = '\0';
 
 		else
 			{ /* need more input */
-			int offset = yy_c_buf_p - yytext_ptr;
-			++yy_c_buf_p;
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
 
-			switch ( yy_get_next_buffer() )
+			switch ( yy_get_next_buffer(  ) )
 				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					steprestart(stepin );
+
+					/*FALLTHROUGH*/
+
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap() )
-						{
-						yy_c_buf_p = yytext_ptr + offset;
+					if ( stepwrap( ) )
 						return EOF;
-						}
 
-					if ( ! yy_did_buffer_switch_on_eof )
+					if ( ! (yy_did_buffer_switch_on_eof) )
 						YY_NEW_FILE;
 #ifdef __cplusplus
 					return yyinput();
@@ -1346,180 +1389,171 @@
 					}
 
 				case EOB_ACT_CONTINUE_SCAN:
-					yy_c_buf_p = yytext_ptr + offset;
+					(yy_c_buf_p) = (yytext_ptr) + offset;
 					break;
-
-				case EOB_ACT_LAST_MATCH:
-#ifdef __cplusplus
-					YY_FATAL_ERROR(
-					"unexpected last match in yyinput()" );
-#else
-					YY_FATAL_ERROR(
-					"unexpected last match in input()" );
-#endif
 				}
 			}
 		}
 
-	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
-	*yy_c_buf_p = '\0';	/* preserve yytext */
-	yy_hold_char = *++yy_c_buf_p;
-
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve steptext */
+	(yy_hold_char) = *++(yy_c_buf_p);
 
 	return c;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yyrestart( FILE *input_file )
-#else
-void yyrestart( input_file )
-FILE *input_file;
-#endif
-	{
-	if ( ! yy_current_buffer )
-		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
+}
+#endif	/* ifndef YY_NO_INPUT */
 
-	yy_init_buffer( yy_current_buffer, input_file );
-	yy_load_buffer_state();
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void steprestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        stepensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            step_create_buffer(stepin,YY_BUF_SIZE );
 	}
 
+	step_init_buffer(YY_CURRENT_BUFFER,input_file );
+	step_load_buffer_state( );
+}
 
-#ifdef YY_USE_PROTOS
-void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
-#else
-void yy_switch_to_buffer( new_buffer )
-YY_BUFFER_STATE new_buffer;
-#endif
-	{
-	if ( yy_current_buffer == new_buffer )
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void step_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		steppop_buffer_state();
+	 *		steppush_buffer_state(new_buffer);
+     */
+	stepensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
 		return;
 
-	if ( yy_current_buffer )
+	if ( YY_CURRENT_BUFFER )
 		{
 		/* Flush out information for old buffer. */
-		*yy_c_buf_p = yy_hold_char;
-		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
-		yy_current_buffer->yy_n_chars = yy_n_chars;
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
 		}
 
-	yy_current_buffer = new_buffer;
-	yy_load_buffer_state();
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	step_load_buffer_state( );
 
 	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
+	 * EOF (stepwrap()) processing, but the only time this flag
+	 * is looked at is after stepwrap() is called, so it's safe
 	 * to go ahead and always set it.
 	 */
-	yy_did_buffer_switch_on_eof = 1;
-	}
-
-
-#ifdef YY_USE_PROTOS
-void yy_load_buffer_state( void )
-#else
-void yy_load_buffer_state()
-#endif
-	{
-	yy_n_chars = yy_current_buffer->yy_n_chars;
-	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
-	yyin = yy_current_buffer->yy_input_file;
-	yy_hold_char = *yy_c_buf_p;
-	}
+	(yy_did_buffer_switch_on_eof) = 1;
+}
 
+static void step_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	stepin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
 
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
-#else
-YY_BUFFER_STATE yy_create_buffer( file, size )
-FILE *file;
-int size;
-#endif
-	{
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE step_create_buffer  (FILE * file, int  size )
+{
 	YY_BUFFER_STATE b;
-
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+    
+	b = (YY_BUFFER_STATE) stepalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in step_create_buffer()" );
 
 	b->yy_buf_size = size;
 
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
+	b->yy_ch_buf = (char *) stepalloc(b->yy_buf_size + 2  );
 	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in step_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file );
+	step_init_buffer(b,file );
 
 	return b;
-	}
-
+}
 
-#ifdef YY_USE_PROTOS
-void yy_delete_buffer( YY_BUFFER_STATE b )
-#else
-void yy_delete_buffer( b )
-YY_BUFFER_STATE b;
-#endif
-	{
+/** Destroy the buffer.
+ * @param b a buffer created with step_create_buffer()
+ * 
+ */
+    void step_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
 	if ( ! b )
 		return;
 
-	if ( b == yy_current_buffer )
-		yy_current_buffer = (YY_BUFFER_STATE) 0;
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yy_flex_free( (void *) b->yy_ch_buf );
-
-	yy_flex_free( (void *) b );
-	}
+		stepfree((void *) b->yy_ch_buf  );
 
+	stepfree((void *) b  );
+}
 
-#ifndef YY_ALWAYS_INTERACTIVE
-#ifndef YY_NEVER_INTERACTIVE
-extern int isatty YY_PROTO(( int ));
-#endif
-#endif
-
-#ifdef YY_USE_PROTOS
-void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
-#else
-void yy_init_buffer( b, file )
-YY_BUFFER_STATE b;
-FILE *file;
-#endif
-
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a steprestart() or at EOF.
+ */
+    static void step_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
 
-	{
-	yy_flush_buffer( b );
+{
+	int oerrno = errno;
+    
+	step_flush_buffer(b );
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
 
-#if YY_ALWAYS_INTERACTIVE
-	b->yy_is_interactive = 1;
-#else
-#if YY_NEVER_INTERACTIVE
-	b->yy_is_interactive = 0;
-#else
-	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-#endif
-#endif
-	}
-
+    /* If b is the current buffer, then step_init_buffer was _probably_
+     * called from steprestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
 
-#ifdef YY_USE_PROTOS
-void yy_flush_buffer( YY_BUFFER_STATE b )
-#else
-void yy_flush_buffer( b )
-YY_BUFFER_STATE b;
-#endif
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void step_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
 
-	{
 	b->yy_n_chars = 0;
 
 	/* We always need two end-of-buffer characters.  The first causes
@@ -1534,31 +1568,123 @@
 	b->yy_at_bol = 1;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	if ( b == yy_current_buffer )
-		yy_load_buffer_state();
+	if ( b == YY_CURRENT_BUFFER )
+		step_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void steppush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	stepensure_buffer_stack();
+
+	/* This block is copied from step_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from step_switch_to_buffer. */
+	step_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void steppop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	step_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		step_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
 	}
+}
 
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void stepensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)stepalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
 
-#ifndef YY_NO_SCAN_BUFFER
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
-#else
-YY_BUFFER_STATE yy_scan_buffer( base, size )
-char *base;
-yy_size_t size;
-#endif
-	{
-	YY_BUFFER_STATE b;
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)steprealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
 
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE step_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
 	if ( size < 2 ||
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
 		return 0;
 
-	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
+	b = (YY_BUFFER_STATE) stepalloc(sizeof( struct yy_buffer_state )  );
 	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+		YY_FATAL_ERROR( "out of dynamic memory in step_scan_buffer()" );
 
 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
@@ -1570,58 +1696,53 @@
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b );
+	step_switch_to_buffer(b  );
 
 	return b;
-	}
-#endif
-
-
-#ifndef YY_NO_SCAN_STRING
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_string( yyconst char *str )
-#else
-YY_BUFFER_STATE yy_scan_string( str )
-yyconst char *str;
-#endif
-	{
-	int len;
-	for ( len = 0; str[len]; ++len )
-		;
-
-	return yy_scan_bytes( str, len );
-	}
-#endif
+}
 
+/** Setup the input buffer state to scan a string. The next call to steplex() will
+ * scan from a @e copy of @a str.
+ * @param str a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       step_scan_bytes() instead.
+ */
+YY_BUFFER_STATE step_scan_string (yyconst char * yystr )
+{
+    
+	return step_scan_bytes(yystr,strlen(yystr) );
+}
 
-#ifndef YY_NO_SCAN_BYTES
-#ifdef YY_USE_PROTOS
-YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
-#else
-YY_BUFFER_STATE yy_scan_bytes( bytes, len )
-yyconst char *bytes;
-int len;
-#endif
-	{
+/** Setup the input buffer state to scan the given bytes. The next call to steplex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE step_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
 	YY_BUFFER_STATE b;
 	char *buf;
 	yy_size_t n;
 	int i;
-
+    
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
-	buf = (char *) yy_flex_alloc( n );
+	n = _yybytes_len + 2;
+	buf = (char *) stepalloc(n  );
 	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "out of dynamic memory in step_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n );
+	b = step_scan_buffer(buf,n );
 	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+		YY_FATAL_ERROR( "bad buffer in step_scan_bytes()" );
 
 	/* It's okay to grow etc. this buffer, and we should throw it
 	 * away when we're done.
@@ -1629,148 +1750,204 @@
 	b->yy_is_our_buffer = 1;
 
 	return b;
-	}
-#endif
-
+}
 
-#ifndef YY_NO_PUSH_STATE
-#ifdef YY_USE_PROTOS
-static void yy_push_state( int new_state )
-#else
-static void yy_push_state( new_state )
-int new_state;
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
 #endif
-	{
-	if ( yy_start_stack_ptr >= yy_start_stack_depth )
-		{
-		yy_size_t new_size;
 
-		yy_start_stack_depth += YY_START_STACK_INCR;
-		new_size = yy_start_stack_depth * sizeof( int );
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
 
-		if ( ! yy_start_stack )
-			yy_start_stack = (int *) yy_flex_alloc( new_size );
+/* Redefine yyless() so it works in section 3 code. */
 
-		else
-			yy_start_stack = (int *) yy_flex_realloc(
-					(void *) yy_start_stack, new_size );
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up steptext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		steptext[stepleng] = (yy_hold_char); \
+		(yy_c_buf_p) = steptext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		stepleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
 
-		if ( ! yy_start_stack )
-			YY_FATAL_ERROR(
-			"out of memory expanding start-condition stack" );
-		}
+/* Accessor  methods (get/set functions) to struct members. */
 
-	yy_start_stack[yy_start_stack_ptr++] = YY_START;
+/** Get the current line number.
+ * 
+ */
+int stepget_lineno  (void)
+{
+        
+    return steplineno;
+}
 
-	BEGIN(new_state);
-	}
-#endif
+/** Get the input stream.
+ * 
+ */
+FILE *stepget_in  (void)
+{
+        return stepin;
+}
 
+/** Get the output stream.
+ * 
+ */
+FILE *stepget_out  (void)
+{
+        return stepout;
+}
 
-#ifndef YY_NO_POP_STATE
-static void yy_pop_state()
-	{
-	if ( --yy_start_stack_ptr < 0 )
-		YY_FATAL_ERROR( "start-condition stack underflow" );
+/** Get the length of the current token.
+ * 
+ */
+int stepget_leng  (void)
+{
+        return stepleng;
+}
 
-	BEGIN(yy_start_stack[yy_start_stack_ptr]);
-	}
-#endif
+/** Get the current token.
+ * 
+ */
 
+char *stepget_text  (void)
+{
+        return steptext;
+}
 
-#ifndef YY_NO_TOP_STATE
-static int yy_top_state()
-	{
-	return yy_start_stack[yy_start_stack_ptr - 1];
-	}
-#endif
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void stepset_lineno (int  line_number )
+{
+    
+    steplineno = line_number;
+}
 
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see step_switch_to_buffer
+ */
+void stepset_in (FILE *  in_str )
+{
+        stepin = in_str ;
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_fatal_error( yyconst char msg[] )
-#else
-static void yy_fatal_error( msg )
-char msg[];
-#endif
-	{
-	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-	}
+void stepset_out (FILE *  out_str )
+{
+        stepout = out_str ;
+}
 
+int stepget_debug  (void)
+{
+        return step_flex_debug;
+}
 
+void stepset_debug (int  bdebug )
+{
+        step_flex_debug = bdebug ;
+}
 
-/* Redefine yyless() so it works in section 3 code. */
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from steplex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+    (yy_state_buf) = 0;
+    (yy_state_ptr) = 0;
+    (yy_full_match) = 0;
+    (yy_lp) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    stepin = stdin;
+    stepout = stdout;
+#else
+    stepin = (FILE *) 0;
+    stepout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * steplex_init()
+     */
+    return 0;
+}
 
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-		yytext[yyleng] = yy_hold_char; \
-		yy_c_buf_p = yytext + n; \
-		yy_hold_char = *yy_c_buf_p; \
-		*yy_c_buf_p = '\0'; \
-		yyleng = n; \
-		} \
-	while ( 0 )
+/* steplex_destroy is for both reentrant and non-reentrant scanners. */
+int steplex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		step_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		steppop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	stepfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    stepfree ( (yy_state_buf) );
+    (yy_state_buf)  = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * steplex() is called, initialization will occur. */
+    yy_init_globals( );
 
+    return 0;
+}
 
-/* Internal utility routines. */
+/*
+ * Internal utility routines.
+ */
 
 #ifndef yytext_ptr
-#ifdef YY_USE_PROTOS
-static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
-#else
-static void yy_flex_strncpy( s1, s2, n )
-char *s1;
-yyconst char *s2;
-int n;
-#endif
-	{
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
 	register int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
-	}
+}
 #endif
 
 #ifdef YY_NEED_STRLEN
-#ifdef YY_USE_PROTOS
-static int yy_flex_strlen( yyconst char *s )
-#else
-static int yy_flex_strlen( s )
-yyconst char *s;
-#endif
-	{
+static int yy_flex_strlen (yyconst char * s )
+{
 	register int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
 	return n;
-	}
+}
 #endif
 
-
-#ifdef YY_USE_PROTOS
-static void *yy_flex_alloc( yy_size_t size )
-#else
-static void *yy_flex_alloc( size )
-yy_size_t size;
-#endif
-	{
+void *stepalloc (yy_size_t  size )
+{
 	return (void *) malloc( size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void *yy_flex_realloc( void *ptr, yy_size_t size )
-#else
-static void *yy_flex_realloc( ptr, size )
-void *ptr;
-yy_size_t size;
-#endif
-	{
+void *steprealloc  (void * ptr, yy_size_t  size )
+{
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -1779,22 +1956,12 @@
 	 * as though doing an assignment.
 	 */
 	return (void *) realloc( (char *) ptr, size );
-	}
+}
 
-#ifdef YY_USE_PROTOS
-static void yy_flex_free( void *ptr )
-#else
-static void yy_flex_free( ptr )
-void *ptr;
-#endif
-	{
-	free( ptr );
-	}
+void stepfree (void * ptr )
+{
+	free( (char *) ptr );	/* see steprealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
 
-#if YY_MAIN
-int main()
-	{
-	yylex();
-	return 0;
-	}
-#endif
diff -Naur OpenCASCADE6.3.0.orig//ros/drv/StepFile/step.tab.c OpenCASCADE6.3.0/ros/drv/StepFile/step.tab.c
--- OpenCASCADE6.3.0.orig//ros/drv/StepFile/step.tab.c	2010-07-04 20:10:56.673073803 +0200
+++ OpenCASCADE6.3.0/ros/drv/StepFile/step.tab.c	2009-09-21 15:37:35.000000000 +0200
@@ -1,36 +1,122 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/*  A Bison parser, made from /dn23/RLSTST/ros/src/StepFile/step.yacc
- by  GNU Bison version 1.25
-  */
+/* Skeleton implementation for Bison's Yacc-like parsers in C
 
-#define YYBISON 1  /* Identify Bison output.  */
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
 #define yyparse stepparse
-#define yylex steplex
+#define yylex   steplex
 #define yyerror steperror
-#define yylval steplval
-#define yychar stepchar
+#define yylval  steplval
+#define yychar  stepchar
 #define yydebug stepdebug
 #define yynerrs stepnerrs
-#define	STEP	258
-#define	HEADER	259
-#define	ENDSEC	260
-#define	DATA	261
-#define	ENDSTEP	262
-#define	SCOPE	263
-#define	ENDSCOPE	264
-#define	ENTITY	265
-#define	TYPE	266
-#define	INTEGER	267
-#define	FLOAT	268
-#define	IDENT	269
-#define	TEXT	270
-#define	NONDEF	271
-#define	ENUM	272
-#define	HEXA	273
-#define	QUID	274
 
-#line 3 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     STEP = 258,
+     HEADER = 259,
+     ENDSEC = 260,
+     DATA = 261,
+     ENDSTEP = 262,
+     SCOPE = 263,
+     ENDSCOPE = 264,
+     ENTITY = 265,
+     TYPE = 266,
+     INTEGER = 267,
+     FLOAT = 268,
+     IDENT = 269,
+     TEXT = 270,
+     NONDEF = 271,
+     ENUM = 272,
+     HEXA = 273,
+     QUID = 274
+   };
+#endif
+/* Tokens.  */
+#define STEP 258
+#define HEADER 259
+#define ENDSEC 260
+#define DATA 261
+#define ENDSTEP 262
+#define SCOPE 263
+#define ENDSCOPE 264
+#define ENTITY 265
+#define TYPE 266
+#define INTEGER 267
+#define FLOAT 268
+#define IDENT 269
+#define TEXT 270
+#define NONDEF 271
+#define ENUM 272
+#define HEXA 273
+#define QUID 274
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 3 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
 
 #include "recfile.ph"		/* definitions des types d'arguments */
 #include "recfile.pc"		/* la-dedans, tout y est */
@@ -65,451 +151,1106 @@
 #define alloca malloc
 #endif
 
-#ifndef YYSTYPE
-#define YYSTYPE int
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
 #endif
-#include <stdio.h>
 
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 188 "step.tab.c"
+
+#ifdef short
+# undef short
 #endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
 #endif
 
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
 
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
 
-#define	YYFINAL		85
-#define	YYFLAG		-32768
-#define	YYNTBASE	27
-
-#define YYTRANSLATE(x) ((unsigned)(x) <= 274 ? yytranslate[x] : 53)
-
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,    20,     2,     2,     2,     2,     2,     2,     2,    22,
-    23,     2,     2,    24,     2,     2,    26,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,    21,     2,
-    25,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     2,     3,     4,     5,
-     6,     7,     8,     9,    10,    11,    12,    13,    14,    15,
-    16,    17,    18,    19
-};
-
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     5,     7,    10,    19,    27,    34,    36,    38,
-    40,    42,    45,    49,    51,    53,    55,    57,    59,    62,
-    64,    66,    68,    70,    73,    77,    80,    82,    86,    89,
-    91,    94,    99,   107,   114,   116,   119,   123,   126,   130,
-   132,   134,   136,   140,   142,   144,   149,   151
-};
-
-static const short yyrhs[] = {    20,
-     0,    27,    20,     0,     7,     0,     7,    27,     0,     3,
-     4,    33,     5,    35,    42,     5,    28,     0,     3,     4,
-     5,    35,    42,     5,     7,     0,     3,     4,     5,    35,
-    42,     1,     0,    29,     0,    30,     0,    31,     0,    34,
-     0,    33,    34,     0,    52,    40,    21,     0,     1,     0,
-     6,     0,    14,     0,    19,     0,    40,     0,    37,    40,
-     0,     1,     0,    11,     0,    22,     0,    23,     0,    38,
-    39,     0,    38,    41,    39,     0,    38,     1,     0,    36,
-     0,    41,    24,    36,     0,    41,     1,     0,    43,     0,
-    42,    43,     0,    51,    25,    45,    21,     0,    51,    25,
-    46,    42,    50,    45,    21,     0,    51,    25,    46,    50,
-    45,    21,     0,     1,     0,    52,    40,     0,    44,    52,
-    40,     0,    52,    40,     0,    22,    44,    23,     0,     8,
-     0,    14,     0,    47,     0,    48,    24,    47,     0,    26,
-     0,     9,     0,     9,    49,    48,    26,     0,    10,     0,
-    11,     0
-};
-
-#endif
-
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-    41,    42,    43,    44,    45,    46,    47,    48,    48,    48,
-    51,    52,    54,    55,    57,    60,    61,    62,    63,    64,
-    68,    71,    74,    79,    80,    81,    83,    84,    85,    87,
-    88,    90,    91,    92,    93,    95,    96,    98,    99,   101,
-   104,   107,   108,   110,   113,   115,   120,   123
-};
-#endif
-
-
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","STEP","HEADER",
-"ENDSEC","DATA","ENDSTEP","SCOPE","ENDSCOPE","ENTITY","TYPE","INTEGER","FLOAT",
-"IDENT","TEXT","NONDEF","ENUM","HEXA","QUID","' '","';'","'('","')'","','","'='",
-"'/'","finvide","finstep","stepf1","stepf2","stepf3","stepf","headl","headent",
-"endhead","unarg","listype","deblist","finlist","listarg","arglist","model",
-"bloc","plex","unent","debscop","unid","export","debexp","finscop","entlab",
-"enttype", NULL
-};
-#endif
-
-static const short yyr1[] = {     0,
-    27,    27,    28,    28,    29,    30,    31,    32,    32,    32,
-    33,    33,    34,    34,    35,    36,    36,    36,    36,    36,
-    37,    38,    39,    40,    40,    40,    41,    41,    41,    42,
-    42,    43,    43,    43,    43,    44,    44,    45,    45,    46,
-    47,    48,    48,    49,    50,    50,    51,    52
-};
-
-static const short yyr2[] = {     0,
-     1,     2,     1,     2,     8,     7,     6,     1,     1,     1,
-     1,     2,     3,     1,     1,     1,     1,     1,     2,     1,
-     1,     1,     1,     2,     3,     2,     1,     3,     2,     1,
-     2,     4,     7,     6,     1,     2,     3,     2,     3,     1,
-     1,     1,     3,     1,     1,     4,     1,     1
-};
-
-static const short yydefact[] = {     0,
-     0,     8,     9,    10,     0,    14,     0,    48,     0,    11,
-     0,    15,     0,     0,    12,    22,     0,     0,    35,    47,
-     0,    30,     0,     0,    20,    21,    16,    17,    23,    27,
-     0,    24,    18,     0,    13,    35,     0,    31,     0,     0,
-    19,    29,     0,    25,     6,    40,     0,     0,     0,     0,
-     0,    20,    28,     0,     0,    32,    45,     0,     0,    38,
-     3,     5,    39,     0,    36,    44,     0,     0,     0,     1,
-     4,    37,    41,    42,     0,     0,    34,     2,     0,    46,
-    33,    43,     0,     0,     0
-};
-
-static const short yydefgoto[] = {    71,
-    62,     2,     3,     4,    83,     9,    10,    13,    30,    31,
-    17,    32,    33,    34,    21,    22,    54,    48,    49,    74,
-    75,    67,    59,    23,    50
-};
-
-static const short yypact[] = {     9,
-    26,-32768,-32768,-32768,    13,-32768,    11,-32768,    36,-32768,
-    10,-32768,    32,    11,-32768,-32768,    12,    17,-32768,-32768,
-    50,-32768,    20,    32,     4,-32768,-32768,-32768,-32768,-32768,
-    10,-32768,-32768,     5,-32768,    48,    55,-32768,    -1,    51,
--32768,-32768,    35,-32768,-32768,-32768,    52,    43,    57,    10,
-    58,-32768,-32768,    -7,    10,-32768,    44,    57,    -3,-32768,
-    49,-32768,-32768,    10,-32768,-32768,    59,    -3,    53,-32768,
-    56,-32768,-32768,-32768,   -15,    54,-32768,-32768,    59,-32768,
--32768,-32768,    71,    72,-32768
-};
-
-static const short yypgoto[] = {-32768,
--32768,-32768,-32768,-32768,-32768,-32768,    68,    64,    37,-32768,
--32768,    45,   -11,-32768,   -22,   -18,-32768,     0,-32768,     2,
--32768,-32768,    24,-32768,    -4
-};
-
-
-#define	YYLAST		82
-
-
-static const short yytable[] = {    18,
-    11,    40,    38,     8,    11,    42,    46,     8,    79,     8,
-    80,     1,    25,     6,   -26,    63,    12,     7,    47,    41,
-    47,    38,    26,     8,   -26,    27,    58,    29,    43,     5,
-    28,    16,    19,    16,    29,    52,     6,    35,    60,    38,
-    14,    20,    55,    65,    39,    26,     8,    -7,    27,    64,
-    36,    19,    72,    28,    37,    51,    16,    19,    69,    20,
-    20,    45,     8,    56,    61,    57,    20,    76,    70,    66,
-    84,    85,    73,    77,    81,    78,    15,    24,    44,    53,
-    82,    68
-};
-
-static const short yycheck[] = {    11,
-     5,    24,    21,    11,     9,     1,     8,    11,    24,    11,
-    26,     3,     1,     1,    11,    23,     6,     5,    22,    31,
-    22,    40,    11,    11,    21,    14,    49,    23,    24,     4,
-    19,    22,     1,    22,    23,     1,     1,    21,    50,    58,
-     5,    10,    47,    55,    25,    11,    11,     0,    14,    54,
-     1,     1,    64,    19,     5,     5,    22,     1,    59,    10,
-    10,     7,    11,    21,     7,     9,    10,    68,    20,    26,
-     0,     0,    14,    21,    21,    20,     9,    14,    34,    43,
-    79,    58
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  7
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   81
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  27
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  27
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  49
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  85
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   274
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,    20,     2,     2,     2,     2,     2,     2,     2,
+      22,    23,     2,     2,    24,     2,     2,    26,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,    21,
+       2,    25,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19
 };
-/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/PRODUCTS/flexbis-253-125/share/bison.simple"
 
-/* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint8 yyprhs[] =
+{
+       0,     0,     3,     5,     8,    10,    13,    22,    30,    37,
+      39,    41,    43,    45,    48,    52,    54,    56,    58,    60,
+      62,    65,    67,    69,    71,    73,    76,    80,    83,    85,
+      89,    92,    94,    97,   102,   110,   117,   119,   122,   126,
+     129,   133,   135,   137,   139,   143,   145,   147,   152,   154
+};
 
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 2, or (at your option)
-   any later version.
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      33,     0,    -1,    20,    -1,    28,    20,    -1,     7,    -1,
+       7,    28,    -1,     3,     4,    34,     5,    36,    43,     5,
+      29,    -1,     3,     4,     5,    36,    43,     5,     7,    -1,
+       3,     4,     5,    36,    43,     1,    -1,    30,    -1,    31,
+      -1,    32,    -1,    35,    -1,    34,    35,    -1,    53,    41,
+      21,    -1,     1,    -1,     6,    -1,    14,    -1,    19,    -1,
+      41,    -1,    38,    41,    -1,     1,    -1,    11,    -1,    22,
+      -1,    23,    -1,    39,    40,    -1,    39,    42,    40,    -1,
+      39,     1,    -1,    37,    -1,    42,    24,    37,    -1,    42,
+       1,    -1,    44,    -1,    43,    44,    -1,    52,    25,    46,
+      21,    -1,    52,    25,    47,    43,    51,    46,    21,    -1,
+      52,    25,    47,    51,    46,    21,    -1,     1,    -1,    53,
+      41,    -1,    45,    53,    41,    -1,    53,    41,    -1,    22,
+      45,    23,    -1,     8,    -1,    14,    -1,    48,    -1,    49,
+      24,    48,    -1,    26,    -1,     9,    -1,     9,    50,    49,
+      26,    -1,    10,    -1,    11,    -1
+};
 
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint8 yyrline[] =
+{
+       0,    41,    41,    42,    43,    44,    45,    46,    47,    48,
+      48,    48,    51,    52,    54,    55,    57,    60,    61,    62,
+      63,    64,    68,    71,    74,    79,    80,    81,    83,    84,
+      85,    87,    88,    90,    91,    92,    93,    95,    96,    98,
+      99,   101,   104,   107,   108,   110,   113,   115,   120,   123
+};
+#endif
 
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "STEP", "HEADER", "ENDSEC", "DATA",
+  "ENDSTEP", "SCOPE", "ENDSCOPE", "ENTITY", "TYPE", "INTEGER", "FLOAT",
+  "IDENT", "TEXT", "NONDEF", "ENUM", "HEXA", "QUID", "' '", "';'", "'('",
+  "')'", "','", "'='", "'/'", "$accept", "finvide", "finstep", "stepf1",
+  "stepf2", "stepf3", "stepf", "headl", "headent", "endhead", "unarg",
+  "listype", "deblist", "finlist", "listarg", "arglist", "model", "bloc",
+  "plex", "unent", "debscop", "unid", "export", "debexp", "finscop",
+  "entlab", "enttype", 0
+};
+#endif
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
-
-#ifndef alloca
-#ifdef __GNUC__
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi)
-#include <alloca.h>
-#else /* not sparc */
-#if defined (MSDOS) && !defined (__TURBOC__)
-#include <malloc.h>
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-#include <malloc.h>
- #pragma alloca
-#else /* not MSDOS, __TURBOC__, or _AIX */
-#ifdef __hpux
-#ifdef __cplusplus
-extern "C" {
-void *alloca (unsigned int);
-};
-#else /* not __cplusplus */
-void *alloca ();
-#endif /* not __cplusplus */
-#endif /* __hpux */
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc.  */
-#endif /* not GNU C.  */
-#endif /* alloca not defined.  */
-
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+      32,    59,    40,    41,    44,    61,    47
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    27,    28,    28,    29,    29,    30,    31,    32,    33,
+      33,    33,    34,    34,    35,    35,    36,    37,    37,    37,
+      37,    37,    38,    39,    40,    41,    41,    41,    42,    42,
+      42,    43,    43,    44,    44,    44,    44,    45,    45,    46,
+      46,    47,    48,    49,    49,    50,    51,    51,    52,    53
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     2,     1,     2,     8,     7,     6,     1,
+       1,     1,     1,     2,     3,     1,     1,     1,     1,     1,
+       2,     1,     1,     1,     1,     2,     3,     2,     1,     3,
+       2,     1,     2,     4,     7,     6,     1,     2,     3,     2,
+       3,     1,     1,     1,     3,     1,     1,     4,     1,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       0,     0,     9,    10,    11,     0,     0,     1,    15,     0,
+      49,     0,    12,     0,    16,     0,     0,    13,    23,     0,
+       0,    36,    48,     0,    31,     0,     0,    21,    22,    17,
+      18,    24,    28,     0,    25,    19,     0,    14,    36,     0,
+      32,     0,     0,    20,    30,     0,    26,     7,    41,     0,
+       0,     0,     0,     0,    21,    29,     0,     0,    33,    46,
+       0,     0,    39,     4,     6,    40,     0,    37,    45,     0,
+       0,     0,     2,     5,    38,    42,    43,     0,     0,    35,
+       3,     0,    47,    34,    44
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,    73,    64,     2,     3,     4,     5,    11,    12,    15,
+      32,    33,    19,    34,    35,    36,    23,    24,    56,    50,
+      51,    76,    77,    69,    61,    25,    52
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -26
+static const yytype_int8 yypact[] =
+{
+      27,    30,   -26,   -26,   -26,    31,    36,   -26,   -26,    55,
+     -26,    49,   -26,    14,   -26,    41,    55,   -26,   -26,    10,
+      42,   -26,   -26,     9,   -26,    37,    41,    -3,   -26,   -26,
+     -26,   -26,   -26,    14,   -26,   -26,     4,   -26,    65,    59,
+     -26,     1,    54,   -26,   -26,    24,   -26,   -26,   -26,    56,
+      48,    47,    14,    61,   -26,   -26,    -7,    14,   -26,    44,
+      47,    -5,   -26,    51,   -26,   -26,    14,   -26,   -26,    58,
+      -5,    52,   -26,    57,   -26,   -26,   -26,   -11,    53,   -26,
+     -26,    58,   -26,   -26,   -26
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -26,   -26,   -26,   -26,   -26,   -26,   -26,   -26,    64,    60,
+      33,   -26,   -26,    43,   -13,   -26,   -25,   -20,   -26,   -12,
+     -26,    -1,   -26,   -26,    21,   -26,    -4
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -28
+static const yytype_int8 yytable[] =
+{
+      20,    42,    13,    40,    10,    44,    10,    13,   -27,    48,
+      38,    27,    10,    81,    39,    82,    65,    49,   -27,    22,
+      43,    28,    40,    49,    29,    54,    60,    31,    45,    30,
+       1,     7,    18,    31,     6,    28,    18,     8,    29,    62,
+      40,     9,    21,    30,    67,    57,    18,    10,    21,    71,
+       8,    22,    66,    74,    16,    21,    59,    22,    78,    53,
+      10,    14,    41,    37,    22,    -8,    47,    10,    63,    58,
+      68,    72,    75,    79,    83,    17,    26,    80,    55,    46,
+      84,    70
+};
+
+static const yytype_uint8 yycheck[] =
+{
+      13,    26,     6,    23,    11,     1,    11,    11,    11,     8,
+       1,     1,    11,    24,     5,    26,    23,    22,    21,    10,
+      33,    11,    42,    22,    14,     1,    51,    23,    24,    19,
+       3,     0,    22,    23,     4,    11,    22,     1,    14,    52,
+      60,     5,     1,    19,    57,    49,    22,    11,     1,    61,
+       1,    10,    56,    66,     5,     1,     9,    10,    70,     5,
+      11,     6,    25,    21,    10,     0,     7,    11,     7,    21,
+      26,    20,    14,    21,    21,    11,    16,    20,    45,    36,
+      81,    60
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    30,    31,    32,    33,     4,     0,     1,     5,
+      11,    34,    35,    53,     6,    36,     5,    35,    22,    39,
+      41,     1,    10,    43,    44,    52,    36,     1,    11,    14,
+      19,    23,    37,    38,    40,    41,    42,    21,     1,     5,
+      44,    25,    43,    41,     1,    24,    40,     7,     8,    22,
+      46,    47,    53,     5,     1,    37,    45,    53,    21,     9,
+      43,    51,    41,     7,    29,    23,    53,    41,    26,    50,
+      51,    46,    20,    28,    41,    14,    48,    49,    46,    21,
+      20,    24,    26,    21,    48
+};
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		-2
+#define YYEMPTY		(-2)
 #define YYEOF		0
-#define YYACCEPT	return(0)
-#define YYABORT 	return(1)
-#define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
+
 #define YYFAIL		goto yyerrlab
+
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
-      yychar1 = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
-while (0)
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
 #endif
 
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 #endif
-#else /* not YYLSP_NEEDED */
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
 #ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+# define YYLEX yylex (YYLEX_PARAM)
 #else
-#define YYLEX		yylex(&yylval)
+# define YYLEX yylex ()
 #endif
-#endif /* not YYLSP_NEEDED */
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
 #endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
 
-/* If nonreentrant, generate the variables here */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
 
-#ifndef YYPURE
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
 
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
 
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
 
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
 
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
 #endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      fprintf (stderr, "\n");
+    }
+}
 
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
 
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
+# define YYINITDEPTH 200
 #endif
 
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
 
-#if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
-#endif
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
+# define YYMAXDEPTH 10000
 #endif
 
-/* Prevent warning if -Wstrict-prototypes.  */
-#ifdef __GNUC__
-int yyparse (void);
-#endif
 
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     int count;
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
 
-  while (i-- > 0)
-    *t++ = *f++;
+  return yyd - 1;
 }
+#  endif
+# endif
 
-#else /* __cplusplus */
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
 
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, int count)
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
 {
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
 
-  while (i-- > 0)
-    *t++ = *f++;
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
 }
+#endif /* YYERROR_VERBOSE */
+
 
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
 #endif
-#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+	break;
+    }
+}
 
-#line 196 "/PRODUCTS/flexbis-253-125/share/bison.simple"
 
-/* The user can define YYPARSE_PARAM as the name of an argument to be passed
-   into yyparse.  The argument should have type void *.
-   It should actually point to an object.
-   Grammar actions can access the variable by casting it
-   to the proper pointer type.  */
+/* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
 
-int
-yyparse(YYPARSE_PARAM_ARG)
-     YYPARSE_PARAM_DECL
-{
-  register int yystate;
-  register int yyn;
-  register short *yyssp;
-  register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
 
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+/* The look-ahead symbol.  */
+int yychar;
 
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
 
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
-  YYLTYPE *yyls = yylsa;
-  YYLTYPE *yylsp;
+/* Number of syntax errors so far.  */
+int yynerrs;
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
 #else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
 #endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
 
-  int yystacksize = YYINITDEPTH;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
 #endif
 #endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
 
-  int yylen;
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -521,498 +1262,493 @@
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
-  yylsp = yyls;
-#endif
 
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
+  goto yysetstate;
 
-  *++yyssp = yystate;
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
 
-  if (yyssp >= yyss + yystacksize - 1)
-    {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
+ yysetstate:
+  *yyssp = yystate;
 
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
       /* Extend the stack our own way.  */
-      if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  return 2;
-	}
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
       yystacksize *= 2;
-      if (yystacksize > YYMAXDEPTH)
+      if (YYMAXDEPTH < yystacksize)
 	yystacksize = YYMAXDEPTH;
-      yyss = (short *) alloca (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1, size * sizeof (*yyssp));
-      yyvs = (YYSTYPE *) alloca (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1, size * sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) alloca (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1, size * sizeof (*yylsp));
-#endif
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
 
-      if (yyssp >= yyss + yystacksize - 1)
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a lookahead token if we need one and don't already have one.  */
-/* yyresume: */
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
-  /* First try to decide what to do without reference to lookahead token.  */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
+  /* First try to decide what to do without reference to look-ahead token.  */
   yyn = yypact[yystate];
-  if (yyn == YYFLAG)
+  if (yyn == YYPACT_NINF)
     goto yydefault;
 
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* yychar is either YYEMPTY or YYEOF
-     or a valid token in external form.  */
+  /* Not known => get a look-ahead token if don't already have one.  */
 
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
-  /* Convert token to internal form (in yychar1) for indexing tables with */
-
-  if (yychar <= 0)		/* This means end of input. */
+  if (yychar <= YYEOF)
     {
-      yychar1 = 0;
-      yychar = YYEOF;		/* Don't call YYLEX any more */
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
-      if (yydebug)
-	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
-	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
-	}
-#endif
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
     }
 
-  yyn += yychar1;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
     goto yydefault;
-
   yyn = yytable[yyn];
-
-  /* yyn is what to do for this token type in this state.
-     Negative => reduce, -yyn is rule number.
-     Positive => shift, yyn is new state.
-       New state is final state => don't bother to shift,
-       just return success.
-     0, or most negative number => error.  */
-
-  if (yyn < 0)
+  if (yyn <= 0)
     {
-      if (yyn == YYFLAG)
+      if (yyn == 0 || yyn == YYTABLE_NINF)
 	goto yyerrlab;
       yyn = -yyn;
       goto yyreduce;
     }
-  else if (yyn == 0)
-    goto yyerrlab;
 
   if (yyn == YYFINAL)
     YYACCEPT;
 
-  /* Shift the lookahead token.  */
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the token being shifted unless it is eof.  */
+  /* Discard the shifted token unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
+  yystate = yyn;
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
-
-  yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
-yydefault:
 
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
+  goto yyreduce;
+
 
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      int i;
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
 
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
-
-      /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
 
 
-  switch (yyn) {
-
-case 10:
-#line 49 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_finfile();  return(0);  /*  fini pour celui-la  */  ;
-    break;}
-case 15:
-#line 58 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_finhead();  ;
-    break;}
-case 16:
-#line 60 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_typarg(rec_argIdent);     rec_newarg();  ;
-    break;}
-case 17:
-#line 61 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  /* deja fait par lex*/ 	 rec_newarg();  ;
-    break;}
-case 18:
-#line 62 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_newarg();  ;
-    break;}
-case 19:
-#line 63 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_newarg();  ;
-    break;}
-case 20:
-#line 64 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_typarg(rec_argMisc);      rec_newarg();
-			   yyerrstatus = 1; yyclearin;  ;
-    break;}
-case 21:
-#line 69 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_listype();  ;
-    break;}
-case 22:
-#line 72 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_deblist();  ;
-    break;}
-case 23:
-#line 75 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  if (modeprint > 0)
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 11:
+#line 49 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_finfile();  return(0);  /*  fini pour celui-la  */  ;}
+    break;
+
+  case 16:
+#line 58 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_finhead();  ;}
+    break;
+
+  case 17:
+#line 60 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_typarg(rec_argIdent);     rec_newarg();  ;}
+    break;
+
+  case 18:
+#line 61 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  /* deja fait par lex*/ 	 rec_newarg();  ;}
+    break;
+
+  case 19:
+#line 62 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_newarg();  ;}
+    break;
+
+  case 20:
+#line 63 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_newarg();  ;}
+    break;
+
+  case 21:
+#line 64 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_typarg(rec_argMisc);      rec_newarg();
+			   yyerrstatus = 1; yyclearin;  ;}
+    break;
+
+  case 22:
+#line 69 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_listype();  ;}
+    break;
+
+  case 23:
+#line 72 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_deblist();  ;}
+    break;
+
+  case 24:
+#line 75 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  if (modeprint > 0)
 		{  printf("Record no : %d -- ",nbrec+1);  rec_print(currec);  }
-	   rec_newent ();  yyerrstatus = 0; ;
-    break;}
-case 40:
-#line 102 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  scope_debut();  ;
-    break;}
-case 41:
-#line 105 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_typarg(rec_argIdent);    rec_newarg();  ;
-    break;}
-case 44:
-#line 111 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_deblist();  ;
-    break;}
-case 45:
-#line 114 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  scope_fin();  ;
-    break;}
-case 46:
-#line 116 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  printf("***  Warning : Export List not yet processed\n");
-	   rec_newent();  scope_fin() ; ;
-    break;}
-case 47:
-#line 121 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_ident();  ;
-    break;}
-case 48:
-#line 124 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
-{  rec_type ();  ;
-    break;}
-}
-   /* the action file gets copied in in place of this dollarsign */
-#line 498 "/PRODUCTS/flexbis-253-125/share/bison.simple"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-#ifdef YYLSP_NEEDED
-  yylsp -= yylen;
-#endif
+	   rec_newent ();  yyerrstatus = 0; ;}
+    break;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+  case 41:
+#line 102 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  scope_debut();  ;}
+    break;
+
+  case 42:
+#line 105 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_typarg(rec_argIdent);    rec_newarg();  ;}
+    break;
+
+  case 45:
+#line 111 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_deblist();  ;}
+    break;
+
+  case 46:
+#line 114 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  scope_fin();  ;}
+    break;
+
+  case 47:
+#line 116 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  printf("***  Warning : Export List not yet processed\n");
+	   rec_newent();  scope_fin() ; ;}
+    break;
+
+  case 48:
+#line 121 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_ident();  ;}
+    break;
+
+  case 49:
+#line 124 "/dn03/OS/OCC/CAS63-sp7/src/StepFile/step.yacc"
+    {  rec_type ();  ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 1541 "step.tab.c"
+      default: break;
     }
-#endif
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
 
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
-  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
-  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
     yystate = yytable[yystate];
   else
-    yystate = yydefgoto[yyn - YYNTBASE];
+    yystate = yydefgoto[yyn - YYNTOKENS];
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
 
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
 
-#ifdef YYERROR_VERBOSE
-      yyn = yypact[yystate];
 
-      if (yyn > YYFLAG && yyn < YYLAST)
-	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
-	    {
-	      strcpy(msg, "parse error");
 
-	      if (count < 5)
-		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
-		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
-		      }
-		}
-	      yyerror(msg);
-	      free(msg);
-	    }
-	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
 	}
       else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
     }
 
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
 
-  if (yyerrstatus == 3)
-    {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
 
-      /* return failure if at end of input */
-      if (yychar == YYEOF)
-	YYABORT;
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
 
-      yychar = YYEMPTY;
-    }
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
 
-  yyerrstatus = 3;		/* Each real token shifted decrements this */
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
 
-  goto yyerrhandle;
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
 
-#if 0
-  /* This is wrong; only states that explicitly want error tokens
-     should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
+  if (yyn == YYFINAL)
+    YYACCEPT;
 
-yyerrpop:   /* pop the current state because it cannot handle the error token */
+  *++yyvsp = yylval;
 
-  if (yyssp == yyss) YYABORT;
-  yyvsp--;
-  yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
-  yylsp--;
-#endif
 
-#if YYDEBUG != 0
-  if (yydebug)
-    {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
-yyerrhandle:
-
-  yyn = yypact[yystate];
-  if (yyn == YYFLAG)
-    goto yyerrdefault;
+  yystate = yyn;
+  goto yynewstate;
 
-  yyn += YYTERROR;
-  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
-    goto yyerrdefault;
 
-  yyn = yytable[yyn];
-  if (yyn < 0)
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
     {
-      if (yyn == YYFLAG)
-	goto yyerrpop;
-      yyn = -yyn;
-      goto yyreduce;
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
     }
-  else if (yyn == 0)
-    goto yyerrpop;
-
-  if (yyn == YYFINAL)
-    YYACCEPT;
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
 #endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
 
-  *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
-  *++yylsp = yylloc;
-#endif
 
-  yystate = yyn;
-  goto yynewstate;
-}
-#line 126 "/dn23/RLSTST/ros/src/StepFile/step.yacc"
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/Aspect_GraphicCallbackProc.hxx OpenCASCADE6.3.0/ros/inc/Aspect_GraphicCallbackProc.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/Aspect_GraphicCallbackProc.hxx	2010-07-04 20:14:06.409264708 +0200
+++ OpenCASCADE6.3.0/ros/inc/Aspect_GraphicCallbackProc.hxx	2008-11-12 09:43:26.000000000 +0100
@@ -15,6 +15,13 @@
 #define OCC_REDRAW_WINDOWAREA 2
 #define OCC_REDRAW_BITMAP 3
 
+/* 
+   This flag, when bitwise OR`ed with the "reason" value, 
+   informs the callback that it is called before redrawing the overlayer .
+   Otherwise, the callback is invoked after the overlayer is redrawn.        
+*/
+#define OCC_PRE_OVERLAY 0x8000
+
  typedef struct {
    int reason;
    int wsID;
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/BOP_SDFWESFiller.hxx OpenCASCADE6.3.0/ros/inc/BOP_SDFWESFiller.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/BOP_SDFWESFiller.hxx	2010-07-04 20:13:50.355943457 +0200
+++ OpenCASCADE6.3.0/ros/inc/BOP_SDFWESFiller.hxx	2010-03-25 10:54:51.000000000 +0100
@@ -37,10 +37,14 @@
 #ifndef _BOPTools_IndexedDataMapOfIntegerState_HeaderFile
 #include <BOPTools_IndexedDataMapOfIntegerState.hxx>
 #endif
+#ifndef _TopTools_ListOfShape_HeaderFile
+#include <TopTools_ListOfShape.hxx>
+#endif
 class BOPTools_DSFiller;
 class BOPTools_IndexedDataMapOfIntegerState;
 class BOP_WireEdgeSet;
 class TopoDS_Face;
+class TopTools_ListOfShape;
 
 
 #ifndef _Standard_HeaderFile
@@ -135,9 +139,15 @@
 
 
 //! Update 3D-State for edges <br>
+//! <br>
 Standard_EXPORT   void UpdateDEStates3D() ;
 
 
+//!  Returns all split edges of nF1 that are CB with <br>
+//!  splis of nF1 but not included in myWES, <br>
+Standard_EXPORT  const TopTools_ListOfShape& RejectedOnParts() const;
+
+
 
 
 
@@ -211,6 +221,7 @@
 BOP_PWireEdgeSet myWES;
 BOPTools_IndexedDataMapOfIntegerState myStatesMap;
 Standard_Integer mySenseFlag;
+TopTools_ListOfShape myRejectedOnParts;
 
 
 };
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/BOP_ShellSolid.hxx OpenCASCADE6.3.0/ros/inc/BOP_ShellSolid.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/BOP_ShellSolid.hxx	2010-07-04 20:12:37.870242352 +0200
+++ OpenCASCADE6.3.0/ros/inc/BOP_ShellSolid.hxx	2010-03-25 10:54:45.000000000 +0100
@@ -176,6 +176,9 @@
 Standard_EXPORT   void AddINON2DPartsSh(const Standard_Integer nF1,const Standard_Integer iFF,BOP_WireEdgeSet& aWES) ;
 
 
+Standard_EXPORT   void AddINON2DPartsSh(const Standard_Integer nF1,const Standard_Integer iFF,BOP_WireEdgeSet& aWES,TopTools_IndexedMapOfShape& anEMap) ;
+
+
 Standard_EXPORT   void AddPartsEFNonSDSh(const Standard_Integer nF1,const Standard_Integer iFF,TopTools_IndexedMapOfShape& anEMap,BOP_WireEdgeSet& aWES) ;
 
 
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/BRepFill_Sweep.hxx OpenCASCADE6.3.0/ros/inc/BRepFill_Sweep.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/BRepFill_Sweep.hxx	2010-07-04 20:14:24.765917127 +0200
+++ OpenCASCADE6.3.0/ros/inc/BRepFill_Sweep.hxx	2009-03-31 14:38:16.000000000 +0200
@@ -28,6 +28,15 @@
 #ifndef _Standard_Real_HeaderFile
 #include <Standard_Real.hxx>
 #endif
+#ifndef _GeomFill_ApproxStyle_HeaderFile
+#include <GeomFill_ApproxStyle.hxx>
+#endif
+#ifndef _GeomAbs_Shape_HeaderFile
+#include <GeomAbs_Shape.hxx>
+#endif
+#ifndef _Standard_Integer_HeaderFile
+#include <Standard_Integer.hxx>
+#endif
 #ifndef _TopoDS_Shape_HeaderFile
 #include <TopoDS_Shape.hxx>
 #endif
@@ -52,15 +61,6 @@
 #ifndef _BRepFill_TransitionStyle_HeaderFile
 #include <BRepFill_TransitionStyle.hxx>
 #endif
-#ifndef _GeomFill_ApproxStyle_HeaderFile
-#include <GeomFill_ApproxStyle.hxx>
-#endif
-#ifndef _GeomAbs_Shape_HeaderFile
-#include <GeomAbs_Shape.hxx>
-#endif
-#ifndef _Standard_Integer_HeaderFile
-#include <Standard_Integer.hxx>
-#endif
 class BRepFill_LocationLaw;
 class BRepFill_SectionLaw;
 class TopTools_HArray2OfShape;
@@ -136,7 +136,7 @@
 //!    Degmax     : The maximum degree in v requiered on the surface <br>
 //!    Segmax     : The maximum number of span in v requiered on <br>
 //!                 the surface. <br>
-Standard_EXPORT   void Build(const BRepFill_TransitionStyle Transition = BRepFill_Modified,const GeomFill_ApproxStyle Approx = GeomFill_Location,const GeomAbs_Shape Continuity = GeomAbs_C2,const Standard_Integer Degmax = 10,const Standard_Integer Segmax = 30) ;
+Standard_EXPORT   void Build(const BRepFill_TransitionStyle Transition = BRepFill_Modified,const GeomFill_ApproxStyle Approx = GeomFill_Location,const GeomAbs_Shape Continuity = GeomAbs_C2,const Standard_Integer Degmax = 11,const Standard_Integer Segmax = 30) ;
 
 //! Say if the Shape is Build. <br>
 Standard_EXPORT   Standard_Boolean IsDone() const;
@@ -176,10 +176,13 @@
  // 
 
 
-Standard_EXPORT   Standard_Boolean BuildWire(const BRepFill_TransitionStyle Transition,const GeomFill_ApproxStyle Approx,const GeomAbs_Shape Continuity,const Standard_Integer Degmax,const Standard_Integer Segmax) ;
+Standard_EXPORT   Standard_Boolean CorrectApproxParameters() ;
+
+
+Standard_EXPORT   Standard_Boolean BuildWire(const BRepFill_TransitionStyle Transition) ;
 
 
-Standard_EXPORT   Standard_Boolean BuildShell(const BRepFill_TransitionStyle Transition,const Standard_Integer Vf,const Standard_Integer Vl,const GeomFill_ApproxStyle Approx,const GeomAbs_Shape Continuity,const Standard_Integer Degmax,const Standard_Integer Segmax,const Standard_Real ExtendFirst = 0.0,const Standard_Real ExtendLast = 0.0) ;
+Standard_EXPORT   Standard_Boolean BuildShell(const BRepFill_TransitionStyle Transition,const Standard_Integer Vf,const Standard_Integer Vl,const Standard_Real ExtendFirst = 0.0,const Standard_Real ExtendLast = 0.0) ;
 
 
 Standard_EXPORT   void PerformCorner(const Standard_Integer Index,const BRepFill_TransitionStyle Transition,const Handle(TopTools_HArray2OfShape)& Bounds) ;
@@ -204,6 +207,10 @@
 Standard_Real myTolAngular;
 Standard_Real myAngMin;
 Standard_Real myAngMax;
+GeomFill_ApproxStyle myApproxStyle;
+GeomAbs_Shape myContinuity;
+Standard_Integer myDegmax;
+Standard_Integer mySegmax;
 TopoDS_Shape myShape;
 Handle_BRepFill_LocationLaw myLoc;
 Handle_BRepFill_SectionLaw mySec;
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/BRepMesh_FastDiscret.hxx OpenCASCADE6.3.0/ros/inc/BRepMesh_FastDiscret.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/BRepMesh_FastDiscret.hxx	2010-07-04 20:12:07.960314079 +0200
+++ OpenCASCADE6.3.0/ros/inc/BRepMesh_FastDiscret.hxx	2009-02-18 15:07:44.000000000 +0100
@@ -105,7 +105,6 @@
 class Geom2d_Curve;
 class TopoDS_Vertex;
 class BRepMesh_ListOfVertex;
-class TColStd_ListOfReal;
 class BRepMesh_Classifier;
 class TColStd_ListOfInteger;
 class BRepMesh_Delaun;
@@ -285,9 +284,6 @@
 Standard_EXPORT   void Add(const TopoDS_Vertex& theVert,const TopoDS_Face& face,const Handle(BRepAdaptor_HSurface)& S) ;
 
 
-Standard_EXPORT   void InternalVerticesForRectangle(const Handle(BRepAdaptor_HSurface)& caro,BRepMesh_ListOfVertex& inter,const TColStd_ListOfReal& u1pars,const TColStd_ListOfReal& u2pars,const TColStd_ListOfReal& v1pars,const TColStd_ListOfReal& v2pars) ;
-
-
 Standard_EXPORT   void InternalVertices(const Handle(BRepAdaptor_HSurface)& caro,BRepMesh_ListOfVertex& inter,const Standard_Real defedge,const BRepMesh_Classifier& classifier) ;
 
 
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/ExprIntrp.tab.h OpenCASCADE6.3.0/ros/inc/ExprIntrp.tab.h
--- OpenCASCADE6.3.0.orig//ros/inc/ExprIntrp.tab.h	2010-07-04 20:13:21.939253465 +0200
+++ OpenCASCADE6.3.0/ros/inc/ExprIntrp.tab.h	2009-09-25 14:20:16.000000000 +0200
@@ -1,28 +1,101 @@
-#ifndef YYSTYPE
-#define YYSTYPE int
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     SUMOP = 258,
+     MINUSOP = 259,
+     DIVIDEOP = 260,
+     EXPOP = 261,
+     MULTOP = 262,
+     PARENTHESIS = 263,
+     BRACKET = 264,
+     ENDPARENTHESIS = 265,
+     ENDBRACKET = 266,
+     VALUE = 267,
+     IDENTIFIER = 268,
+     COMMA = 269,
+     DIFFERENTIAL = 270,
+     DERIVATE = 271,
+     DERIVKEY = 272,
+     ASSIGNOP = 273,
+     DEASSIGNKEY = 274,
+     EQUALOP = 275,
+     RELSEPARATOR = 276,
+     CONSTKEY = 277,
+     SUMKEY = 278,
+     PRODKEY = 279
+   };
 #endif
-#define	SUMOP	258
-#define	MINUSOP	259
-#define	DIVIDEOP	260
-#define	EXPOP	261
-#define	MULTOP	262
-#define	PARENTHESIS	263
-#define	BRACKET	264
-#define	ENDPARENTHESIS	265
-#define	ENDBRACKET	266
-#define	VALUE	267
-#define	IDENTIFIER	268
-#define	COMMA	269
-#define	DIFFERENTIAL	270
-#define	DERIVATE	271
-#define	DERIVKEY	272
-#define	ASSIGNOP	273
-#define	DEASSIGNKEY	274
-#define	EQUALOP	275
-#define	RELSEPARATOR	276
-#define	CONSTKEY	277
-#define	SUMKEY	278
-#define	PRODKEY	279
+/* Tokens.  */
+#define SUMOP 258
+#define MINUSOP 259
+#define DIVIDEOP 260
+#define EXPOP 261
+#define MULTOP 262
+#define PARENTHESIS 263
+#define BRACKET 264
+#define ENDPARENTHESIS 265
+#define ENDBRACKET 266
+#define VALUE 267
+#define IDENTIFIER 268
+#define COMMA 269
+#define DIFFERENTIAL 270
+#define DERIVATE 271
+#define DERIVKEY 272
+#define ASSIGNOP 273
+#define DEASSIGNKEY 274
+#define EQUALOP 275
+#define RELSEPARATOR 276
+#define CONSTKEY 277
+#define SUMKEY 278
+#define PRODKEY 279
+
+
 
 
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef int YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
 extern YYSTYPE ExprIntrplval;
+
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/InterfaceGraphic_tgl_all.h OpenCASCADE6.3.0/ros/inc/InterfaceGraphic_tgl_all.h
--- OpenCASCADE6.3.0.orig//ros/inc/InterfaceGraphic_tgl_all.h	2010-07-04 20:14:50.005912448 +0200
+++ OpenCASCADE6.3.0/ros/inc/InterfaceGraphic_tgl_all.h	2008-11-14 15:39:54.000000000 +0100
@@ -9,11 +9,16 @@
 #ifndef  INTERFACEGRAPHIC_TGL_ALL_H
 #define  INTERFACEGRAPHIC_TGL_ALL_H
 
-typedef  int   Tint;
-typedef  float Tfloat;
-typedef  char  Tchar;
-typedef  char  Tbool;
-typedef unsigned int    Tuint;
+typedef  int          Tint;
+typedef  float        Tfloat;
+/* PCD 04/07/07  */
+typedef	 double       Tdouble;
+/* Tchar is treated as a signed char in visualization code,
+therefore it should be made signed explicitly, as on Linux 
+-funsigned-char option is specified when building OCCT */
+typedef  signed char  Tchar;
+typedef  char         Tbool;
+typedef  unsigned int Tuint;
 
 #define  TGL_SP   1
 #define  TGL_DP   0
@@ -37,6 +42,7 @@
 #define  TNotDone  0
 
 typedef  Tfloat  Tmatrix3[4][4];
+
 typedef  enum    
 { 
   TPreConcatenate, 
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntPatch_ALineToWLine.gxx OpenCASCADE6.3.0/ros/inc/IntPatch_ALineToWLine.gxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntPatch_ALineToWLine.gxx	2010-07-04 20:12:30.715921947 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntPatch_ALineToWLine.gxx	2009-09-21 13:32:24.000000000 +0200
@@ -47,6 +47,16 @@
 			  Standard_Real& u2,
 			  const Standard_Real anu1,
 			  const Standard_Real anu2);
+
+static
+  void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
+			      const IntSurf_Quadric aQuad1,
+			      const IntSurf_Quadric aQuad2,
+			      const Standard_Real ref_u1,
+			      const Standard_Real ref_u2,
+			      Standard_Real& new_u1,
+			      Standard_Real& new_u2);
+
 //
 static
   void RefineParameters(const Handle(TheALine)& aALine,
@@ -278,6 +288,17 @@
   Handle(IntSurf_LineOn2S) LinOn2S;
   //
   LinOn2S = new IntSurf_LineOn2S;
+
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  Standard_Real refpar = RealLast(), ref_u1, ref_u2;
+  if (nbvtx)
+    {
+      const ThePoint& FirstVertex = aline->Vertex(1);
+      refpar = FirstVertex.ParameterOnLine();
+      FirstVertex.Parameters(ref_u1, v1, ref_u2, v2);
+    }
+  ////////////////////////////////////////////////
+
   //-----------------------------------------------------
   //-- Estimation Grossiere de la longueur de la courbe
   //-- 
@@ -362,6 +383,9 @@
   //
   // the loop
   DeltaU=0.;
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  Standard_Boolean Corrected = Standard_False;
+  ////////////////////////////////////////////////
   while(U<lastparam) { 
     Standard_Integer NbCalculD1;
     Standard_Real UPourCalculD1, pvavant, pvapres;
@@ -450,6 +474,13 @@
       }
     }
     //
+    //// Modified by jgv, 17.09.09 for OCC21255 ////
+    if (!Corrected && U >= refpar)
+      {
+	CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+	Corrected = Standard_True;
+      }
+    ////////////////////////////////////////////////
     U+=DeltaU;
     if(U < lastparam) { 
       nbpwline++;
@@ -492,6 +523,13 @@
   POn2S.SetValue(Pnt3d,u1,v1,u2,v2);
   LinOn2S->Add(POn2S);
   nbpwline++;
+
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  if (!Corrected && 
+      (lastparam >= refpar || refpar-lastparam < Precision::Confusion()))
+    CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+  ////////////////////////////////////////////////
+
   //
   //-----------------------------------------------------------------
   //--  Calcul de la transition de la ligne sur les surfaces      ---
@@ -895,6 +933,7 @@
   }
   while(u1-anu1 > 5.0) { 
     //
+    /*
     if (!bBothCylinders) {//cfe900/H6
       // this check on Cylinder/Cylinder intersection is probably 
       // because of pbs with ALine on it.
@@ -908,6 +947,7 @@
 	break;
       }
     }
+    */
     //
     u1-=PI+PI;
   }
@@ -916,15 +956,54 @@
   }
   while(u2-anu2 > 5.0) {
     //
+    /*
     if (!bBothCylinders) {//cfe900/H6
       if (u2-PI-PI<0.) {
 	break;
       }
     }
+    */
     //
     u2-=PI+PI;
   }
 }
+
+//=======================================================================
+//function : CorrectFirstPartOfLine
+//purpose  : 
+//=======================================================================
+void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
+			    const IntSurf_Quadric aQuad1,
+			    const IntSurf_Quadric aQuad2,
+			    const Standard_Real ref_u1,
+			    const Standard_Real ref_u2,
+			    Standard_Real& new_u1,
+			    Standard_Real& new_u2)
+{
+  Standard_Integer nbp = LinOn2S->NbPoints();
+  Standard_Real u1, v1, u2, v2, OffsetOnS1, OffsetOnS2;
+
+  IntSurf_PntOn2S aPoint = LinOn2S->Value(nbp);
+  aPoint.Parameters(u1, v1, u2, v2);
+
+  new_u1 = u1;
+  new_u2 = u2;
+  RecadreMemePeriode(aQuad1, aQuad2, new_u1, new_u2, ref_u1, ref_u2);
+  OffsetOnS1 = new_u1 - u1;
+  OffsetOnS2 = new_u2 - u2;
+  if (Abs(OffsetOnS1) > 1. || Abs(OffsetOnS2) > 1.) //recadre on n*2*PI is done
+    {
+      Standard_Integer i;
+      for (i = 1; i <= nbp; i++)
+	{
+	  aPoint = LinOn2S->Value(i);
+	  aPoint.Parameters(u1, v1, u2, v2);
+	  LinOn2S->SetUV( i, Standard_True,  u1 + OffsetOnS1, v1 );
+	  LinOn2S->SetUV( i, Standard_False, u2 + OffsetOnS2, v2 );
+	}
+    }
+}
+
 //
 //=======================================================================
 //function : IsApex
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntPatch_ImpImpIntersection_4.gxx OpenCASCADE6.3.0/ros/inc/IntPatch_ImpImpIntersection_4.gxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntPatch_ImpImpIntersection_4.gxx	2010-07-04 20:14:23.485932353 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntPatch_ImpImpIntersection_4.gxx	2010-02-12 04:56:52.000000000 +0100
@@ -10,6 +10,11 @@
 				const Standard_Real aTol,
 				IntAna_ListOfCurve& aLC);
 
+static
+  Standard_Boolean IsToReverse(const gp_Cylinder& Cy1,
+			       const gp_Cylinder& Cy2,
+			       const Standard_Real Tol);
+
 //
 
 //=======================================================================
@@ -152,10 +157,10 @@
   }
 }
 
-
-
-
-
+//=======================================================================
+//function : IntCyCy
+//purpose  : 
+//=======================================================================
 Standard_Boolean IntCyCy(const IntSurf_Quadric& Quad1,
 			 const IntSurf_Quadric& Quad2,
 			 const Standard_Real Tol,
@@ -425,6 +430,15 @@
     {
       gp_Pnt psol;
       Standard_Real U1,V1,U2,V2;
+      //xf
+      Standard_Boolean bReverse;
+      //
+      bReverse=IsToReverse(Cy1, Cy2, Tol);
+      if (bReverse){
+	Cy2=Quad1.Cylinder();
+	Cy1=Quad2.Cylinder();
+      }
+      //xt
       IntAna_IntQuadQuad anaint(Cy1,Cy2,Tol);
       if (!anaint.IsDone()) {
 	return Standard_False;
@@ -739,9 +753,6 @@
   }
   return Standard_True;
 }
-
-
-
 //=======================================================================
 //function : IntCyCo
 //purpose  : 
@@ -1003,3 +1014,46 @@
   //
   return bFind;
 }
+//=======================================================================
+//function : IsToReverse
+//purpose  : 
+//=======================================================================
+Standard_Boolean IsToReverse(const gp_Cylinder& Cy1,
+			     const gp_Cylinder& Cy2,
+			     const Standard_Real Tol)
+{
+  Standard_Boolean bRet;
+  Standard_Real aR1,aR2, dR, aSc1, aSc2;
+  //
+  bRet=Standard_False;
+  //
+  aR1=Cy1.Radius();
+  aR2=Cy2.Radius();
+  dR=aR1-aR2;
+  if (dR<0.) {
+    dR=-dR;
+  }
+  if (dR>Tol) {
+    bRet=aR1>aR2;
+  }
+  else {
+    gp_Dir aDZ(0.,0.,1.);
+    //
+    const gp_Dir& aDir1=Cy1.Axis().Direction();
+    aSc1=aDir1*aDZ;
+    if (aSc1<0.) {
+      aSc1=-aSc1;
+    }
+    //
+    const gp_Dir& aDir2=Cy2.Axis().Direction();
+    aSc2=aDir2*aDZ;
+    if (aSc2<0.) {
+      aSc2=-aSc2;
+    }
+    //
+    if (aSc2<aSc1) {
+      bRet=!bRet;
+    }
+  }//if (dR<Tol) {
+  return bRet;
+}
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntPatch_Intersection.hxx OpenCASCADE6.3.0/ros/inc/IntPatch_Intersection.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntPatch_Intersection.hxx	2010-07-04 20:12:11.105930537 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntPatch_Intersection.hxx	2010-03-25 11:39:16.000000000 +0100
@@ -85,6 +85,7 @@
 class IntPatch_TheALineOfIntersection;
 class IntPatch_TheWLineOfIntersection;
 class IntPatch_TheRLineOfIntersection;
+class IntPatch_TheALineToWLineOfIntersection;
 class IntPatch_TheArcFunctionOfIntersection;
 class IntPatch_TheSOnBoundsOfIntersection;
 class IntPatch_ThePathPointOfTheSOnBoundsOfIntersection;
@@ -108,7 +109,6 @@
 class IntPatch_TheInterfPolyhedronOfThePPIntOfIntersection;
 class IntPatch_ThePWalkingInterOfThePPIntOfIntersection;
 class IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection;
-class IntPatch_TheALineToWLineOfIntersection;
 class IntPatch_TheLineConstructorOfIntersection;
 class IntSurf_ListOfPntOn2S;
 class IntPatch_Line;
@@ -260,6 +260,8 @@
 #define IntPatch_TheWLine_hxx <IntPatch_TheWLineOfIntersection.hxx>
 #define IntPatch_TheRLine IntPatch_TheRLineOfIntersection
 #define IntPatch_TheRLine_hxx <IntPatch_TheRLineOfIntersection.hxx>
+#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
+#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheArcFunction IntPatch_TheArcFunctionOfIntersection
 #define IntPatch_TheArcFunction_hxx <IntPatch_TheArcFunctionOfIntersection.hxx>
 #define IntPatch_TheSOnBounds IntPatch_TheSOnBoundsOfIntersection
@@ -340,8 +342,6 @@
 #define IntPatch_ThePWalkingInterOfThePPInt_hxx <IntPatch_ThePWalkingInterOfThePPIntOfIntersection.hxx>
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection
 #define IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx <IntPatch_PrmPrmIntersection_T3BitsOfThePPIntOfIntersection.hxx>
-#define IntPatch_TheALineToWLine IntPatch_TheALineToWLineOfIntersection
-#define IntPatch_TheALineToWLine_hxx <IntPatch_TheALineToWLineOfIntersection.hxx>
 #define IntPatch_TheLineConstructor IntPatch_TheLineConstructorOfIntersection
 #define IntPatch_TheLineConstructor_hxx <IntPatch_TheLineConstructorOfIntersection.hxx>
 #define Handle_IntPatch_SequenceNodeOfSequenceOfPoint Handle_IntPatch_SequenceNodeOfSequenceOfPointOfIntersection
@@ -392,6 +392,8 @@
 #undef IntPatch_TheWLine_hxx
 #undef IntPatch_TheRLine
 #undef IntPatch_TheRLine_hxx
+#undef IntPatch_TheALineToWLine
+#undef IntPatch_TheALineToWLine_hxx
 #undef IntPatch_TheArcFunction
 #undef IntPatch_TheArcFunction_hxx
 #undef IntPatch_TheSOnBounds
@@ -472,8 +474,6 @@
 #undef IntPatch_ThePWalkingInterOfThePPInt_hxx
 #undef IntPatch_PrmPrmIntersection_T3BitsOfThePPInt
 #undef IntPatch_PrmPrmIntersection_T3BitsOfThePPInt_hxx
-#undef IntPatch_TheALineToWLine
-#undef IntPatch_TheALineToWLine_hxx
 #undef IntPatch_TheLineConstructor
 #undef IntPatch_TheLineConstructor_hxx
 #undef Handle_IntPatch_SequenceNodeOfSequenceOfPoint
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntPatch_Point.gxx OpenCASCADE6.3.0/ros/inc/IntPatch_Point.gxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntPatch_Point.gxx	2010-07-04 20:14:17.696642224 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntPatch_Point.gxx	2009-11-11 11:35:06.000000000 +0100
@@ -2,8 +2,23 @@
 
 #include <stdio.h>
 
-IntPatch_Point::IntPatch_Point () {}
-
+IntPatch_Point::IntPatch_Point()
+{
+  para = 0.;
+  tol  = 0.;
+  tgt     = Standard_False;
+  mult    = Standard_False;
+  onS1    = Standard_False;
+  onS2    = Standard_False;
+  vtxonS1 = Standard_False;
+  vS1   = NULL;
+  arcS1 = NULL;
+  vtxonS2 = Standard_False;
+  vS2   = NULL;
+  arcS2 = NULL;
+  prm1 = 0.;
+  prm2 = 0.;
+}
 
 void IntPatch_Point::SetValue (const gp_Pnt& Pt,
 			       const Standard_Real Tol,
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntPatch_PrmPrmIntersection.gxx OpenCASCADE6.3.0/ros/inc/IntPatch_PrmPrmIntersection.gxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntPatch_PrmPrmIntersection.gxx	2010-07-04 20:13:53.866847208 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntPatch_PrmPrmIntersection.gxx	2008-11-25 15:37:21.000000000 +0100
@@ -32,14 +32,14 @@
 				     Standard_Real& u2,
 				     Standard_Real& v2);
 
-//xf
+
 static 
   void AdjustOnPeriodic(const TheSurface& Surf1,
 			const TheSurface& Surf2,
 			IntPatch_SequenceOfLine& aSLin);
-//xt
+
 //==================================================================================
-// function : Constructor
+// function : 
 // purpose  : 
 //==================================================================================
 IntPatch_PrmPrmIntersection::IntPatch_PrmPrmIntersection(): done(Standard_False)
@@ -1677,8 +1677,7 @@
 	    }
 	  }
 	}
-	//--printf("\n\n1 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//--       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U1_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V1_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1712,8 +1711,7 @@
 	    }
 	  }
 	}
-	//printf("\n2 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U2_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V2_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1725,7 +1723,6 @@
     }
   }
   while(ok);
-  //-- cout<<"\n *** "<<Compt<<" Points de *1  ** 2* ds la grille UVP"<<ComptTrouve<<endl; Compt=0;
 }
 
 //==================================================================================
@@ -1764,7 +1761,7 @@
     if (ClearFlag)
       SLin.Clear();
     // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
-
+    //
     //IntPolyh_Intersection Interference(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     //     IntPolyh_Intersection Interference(Surf1, anUpars1, aVpars1, 
     // 				       Surf2, anUpars2, aVpars2);
@@ -1775,15 +1772,16 @@
       pInterference = new IntPolyh_Intersection(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     }
     else {
-      pInterference = new IntPolyh_Intersection( Surf1, anUpars1, aVpars1, 
+      pInterference = new IntPolyh_Intersection(Surf1, anUpars1, aVpars1, 
 						Surf2, anUpars2, aVpars2 );
     }
     if ( !pInterference ) {
       done = Standard_False;
       return;
     }
+    //
     IntPolyh_Intersection& Interference = *pInterference;
-
+    //
     done = Interference.IsDone();
     if( !done ) {
       if ( pInterference ) {
@@ -1792,7 +1790,7 @@
       }
       return;
     }
-
+    
     Standard_Real Deflection2 = Deflection*Deflection;
     Standard_Integer nbLigSec = Interference.NbSectionLines();
     Standard_Integer nbTanZon = Interference.NbTangentZones();
@@ -1828,11 +1826,18 @@
 	  }
 	}
       } while(triok==Standard_False);
-
+      //
       for( ls = 1; ls <= nbLigSec; ls++) {
-	Standard_Integer nbp = Interference.NbPointsInLine(TabL[ls]);
-	Standard_Integer *TabPtDep = new Standard_Integer [nbp+1];
-	Standard_Integer ilig;
+	Standard_Integer nbp, ilig, *TabPtDep;
+	//
+	nbp = Interference.NbPointsInLine(TabL[ls]);
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:28 2008f
+	if (!nbp) {
+	  continue;
+	}
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:31 2008t
+	TabPtDep = new Standard_Integer [nbp+1];
+	//
 	for( ilig = 1; ilig <= nbp; ilig++ )
 	  TabPtDep[ilig]=0;
 
@@ -1864,9 +1869,8 @@
 	Standard_Integer nbps2 = (nbp>3)? (nbp/2) :  1;
 	Standard_Integer NombreDePointsDeDepartDuCheminement = 0;
 	Standard_Boolean lignetrouvee=Standard_False;
-	// const Standard_Integer NbDePointsDeDepartDuChmLimit = 3;
 	const Standard_Integer NbDePointsDeDepartDuChmLimit = 5;
-
+	//
 	do { 
 	  NombreDePointsDeDepartDuCheminement++;
 	  switch (NombreDePointsDeDepartDuCheminement) {
@@ -1891,7 +1895,7 @@
 	    nbps2 = NombreDePointsDeDepartDuCheminement-3;
 	    NombreDePointsDeDepartDuCheminement++;
 	  }
-
+	  //
 	  if(TabPtDep[nbps2] == 0) {
 	    TabPtDep[nbps2] = 1;
 	    Interference.GetLinePoint(TabL[ls],nbps2,_x,_y,_z,U1,V1,U2,V2,incidence);
@@ -1966,7 +1970,6 @@
 		Standard_Boolean bPWIsDone;
 		Standard_Integer iPWNbPoints, aNbPointsVer;
 		Standard_Real aD11, aD12, aD21, aD22, aDx;
-
 		//
 		bPWIsDone=PW.IsDone();
 		//xt
@@ -2023,12 +2026,8 @@
 			  }
 			}
 		      }
-// 		      if(Point3dDebut.Distance(verPointDebut.Value()) <= TolTangency) { 
-// 			if(Point3dFin.Distance(verPointFin.Value()) <= TolTangency)
-// 			  RejetLigne = Standard_True; 
-// 		      }
 		    }
-		    
+		    //
 		    if(!RejetLigne) {
 		      IntSurf_TypeTrans trans1,trans2;
 		      Standard_Real locu,locv;
@@ -2227,10 +2226,9 @@
       delete [] TabL;
 
     }// if nbLigSec >= 1
-
-    //xf
+    //
     AdjustOnPeriodic(Surf1, Surf2, SLin);
-    //xt
+    //
 
     //--------------------------------------------------------------------
     //-- Calcul des parametres approches a partir des Zones De Tangence --
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/IntTools_Context.hxx OpenCASCADE6.3.0/ros/inc/IntTools_Context.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/IntTools_Context.hxx	2010-07-04 20:12:45.042661178 +0200
+++ OpenCASCADE6.3.0/ros/inc/IntTools_Context.hxx	2010-03-25 10:54:31.000000000 +0100
@@ -37,12 +37,12 @@
 #ifndef _Standard_Real_HeaderFile
 #include <Standard_Real.hxx>
 #endif
-#ifndef _TopAbs_State_HeaderFile
-#include <TopAbs_State.hxx>
-#endif
 #ifndef _Standard_Boolean_HeaderFile
 #include <Standard_Boolean.hxx>
 #endif
+#ifndef _TopAbs_State_HeaderFile
+#include <TopAbs_State.hxx>
+#endif
 class IntTools_FClass2d;
 class TopoDS_Face;
 class GeomAPI_ProjectPointOnSurf;
@@ -144,6 +144,19 @@
 Standard_EXPORT   Standard_Integer ComputeVE(const TopoDS_Vertex& aV,const TopoDS_Edge& aE,Standard_Real& aT) ;
 
 
+//! Computes parameter of the vertex aV on <br>
+//! the edge aE. <br>
+//! Returns zero if the distance between vertex <br>
+//! and edge is less than sum of tolerances, <br>
+//! otherwise and for following conditions returns <br>
+//! negative value <br>
+//! 1. the edge is degenerated (-1) <br>
+//! 2. the edge does not contain 3d curve and pcurves (-2) <br>
+//! 3. projection algorithm failed (-3) <br>
+//! <br>
+Standard_EXPORT   Standard_Integer ComputeVE(const TopoDS_Vertex& aV,const TopoDS_Edge& aE,Standard_Real& aT,Standard_Boolean& bToUpdateVertex,Standard_Real& aDist) ;
+
+
 //! Computes UV parameters of the vertex aV on face aF <br>
 //! Returns zero if the distance between vertex and face is <br>
 //! less than or equal the sum of tolerances and the projection <br>
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/Prs3d_ShadedShape.gxx OpenCASCADE6.3.0/ros/inc/Prs3d_ShadedShape.gxx
--- OpenCASCADE6.3.0.orig//ros/inc/Prs3d_ShadedShape.gxx	2010-07-04 20:12:26.459732648 +0200
+++ OpenCASCADE6.3.0/ros/inc/Prs3d_ShadedShape.gxx	2010-03-23 14:26:58.000000000 +0100
@@ -41,6 +41,7 @@
 #include <gp_Vec.hxx>
 #include <StdPrs_WFShape.hxx>
 #include <BRepBndLib.hxx>
+#include <Precision.hxx>
 #ifdef G005
 #include <Graphic3d_ArrayOfTriangles.hxx>
 #endif
@@ -89,6 +90,9 @@
     Standard_Integer t[3], n[3];
     Standard_Integer nbTriangles = 0, nbVertices = 0;
 
+    // precision for compare square distances
+    double dPreci = Precision::Confusion()*Precision::Confusion();
+
     if ( !aDrawer->ShadingAspectGlobal() ) {
 
       Handle(Graphic3d_AspectFillArea3d) Asp = aDrawer->ShadingAspect()->Aspect();
@@ -149,15 +153,15 @@
 	      gp_Pnt P2 = Nodes(n[1]);
 	      gp_Pnt P3 = Nodes(n[2]);
 	      gp_Vec V1(P1,P2);
-	      if (V1.SquareMagnitude() > 1.e-10) {
+	      if ( V1.SquareMagnitude() > dPreci ) {
 	        gp_Vec V2(P2,P3);
-	        if (V2.SquareMagnitude() > 1.e-10) {
-	          gp_Vec V3(P3,P1);
-		  if (V3.SquareMagnitude() > 1.e-10) {
+	        if ( V2.SquareMagnitude() > dPreci ) {
+		  gp_Vec V3(P3,P1);
+		  if ( V3.SquareMagnitude() > dPreci ) {
 		    V1.Normalize();
 		    V2.Normalize();
 		    V1.Cross(V2);
-		    if (V1.SquareMagnitude() > 1.e-10) {
+		    if ( V1.SquareMagnitude() > dPreci ) {
 		      parray->AddEdge(n[0]+decal,t[0] == 0);
 		      parray->AddEdge(n[1]+decal,t[1] == 0);
 		      parray->AddEdge(n[2]+decal,t[2] == 0);
@@ -196,15 +200,15 @@
 	  const gp_Pnt& P2 = Nodes(n2);
 	  const gp_Pnt& P3 = Nodes(n3);
 	  gp_Vec V1(P1,P2);
-	  if (V1.SquareMagnitude() > 1.e-10) {
+	  if ( V1.SquareMagnitude() > dPreci ) {
 	    gp_Vec V2(P2,P3);
-	    if (V2.SquareMagnitude() > 1.e-10) {
+	    if (V2.SquareMagnitude() > dPreci ) {
 	      gp_Vec V3(P3,P1);
-	      if (V3.SquareMagnitude() > 1.e-10) {
+	      if (V3.SquareMagnitude() > dPreci ) {
 		V1.Normalize();
 		V2.Normalize();
 		V1.Cross(V2);
-		if (V1.SquareMagnitude() > 1.e-10) {
+		if (V1.SquareMagnitude() > dPreci ) {
 		  nbTriangles++;
 		}
 	      }
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/ShapeAnalysis_FreeBounds.hxx OpenCASCADE6.3.0/ros/inc/ShapeAnalysis_FreeBounds.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/ShapeAnalysis_FreeBounds.hxx	2010-07-04 20:14:48.142597902 +0200
+++ OpenCASCADE6.3.0/ros/inc/ShapeAnalysis_FreeBounds.hxx	2010-03-25 11:33:55.000000000 +0100
@@ -105,7 +105,7 @@
 //!          built closed wires. <br>
 //!          If <splitopen> is True extracts closed sub-wires out of <br>
 //!          built open wires. <br>
-Standard_EXPORT ShapeAnalysis_FreeBounds(const TopoDS_Shape& shape,const Standard_Boolean splitclosed = Standard_False,const Standard_Boolean splitopen = Standard_True);
+Standard_EXPORT ShapeAnalysis_FreeBounds(const TopoDS_Shape& shape,const Standard_Boolean splitclosed = Standard_False,const Standard_Boolean splitopen = Standard_True,const Standard_Boolean checkinternaledges = Standard_False);
 //! Returns compound of closed wires out of free edges. <br>
  const TopoDS_Compound& GetClosedWires() const;
 //! Returns compound of open wires out of free edges. <br>
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/ShapeAnalysis_Shell.hxx OpenCASCADE6.3.0/ros/inc/ShapeAnalysis_Shell.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/ShapeAnalysis_Shell.hxx	2010-07-04 20:14:14.775909654 +0200
+++ OpenCASCADE6.3.0/ros/inc/ShapeAnalysis_Shell.hxx	2010-03-25 11:33:55.000000000 +0100
@@ -76,7 +76,7 @@
 //! <br>
 //!          If <alsofree> is True free edges are considered. <br>
 //!          Free edges can be queried but are not bad <br>
-Standard_EXPORT   Standard_Boolean CheckOrientedShells(const TopoDS_Shape& shape,const Standard_Boolean alsofree = Standard_False) ;
+Standard_EXPORT   Standard_Boolean CheckOrientedShells(const TopoDS_Shape& shape,const Standard_Boolean alsofree = Standard_False,const Standard_Boolean checkinternaledges = Standard_False) ;
 
 //! Tells if a shape is loaded (only shells are checked) <br>
 Standard_EXPORT   Standard_Boolean IsLoaded(const TopoDS_Shape& shape) const;
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/Standard_Version.hxx OpenCASCADE6.3.0/ros/inc/Standard_Version.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/Standard_Version.hxx	2010-07-04 20:12:31.749259679 +0200
+++ OpenCASCADE6.3.0/ros/inc/Standard_Version.hxx	2010-04-01 15:34:11.000000000 +0200
@@ -10,6 +10,7 @@
 //            OCC_VERSION_MAJOR       : (integer) number identifying major version 
 //            OCC_VERSION_MINOR       : (integer) number identifying minor version 
 //            OCC_VERSION_MAINTENANCE : (integer) number identifying maintenance version 
+//            OCC_VERSION_SERVICEPACK : (integer) number identifying service pack version 
 //            OCC_VERSION             : (real)    complete number (major.minor)
 //            OCC_VERSION_STRING      : (string)  complete number ("major.minor")
 //            OCC_VERSION_HEX         : (hex)     complete number as hex, two positions per each of major, minor, and patch number 
@@ -23,6 +24,7 @@
 #define OCC_VERSION_MAJOR         6
 #define OCC_VERSION_MINOR         3
 #define OCC_VERSION_MAINTENANCE   0
+#define OCC_VERSION_SERVICEPACK   9
 
 // Derived: version as real and string (major.minor)
 #define OCC_VERSION         6.3
diff -Naur OpenCASCADE6.3.0.orig//ros/inc/WNT_Window.hxx OpenCASCADE6.3.0/ros/inc/WNT_Window.hxx
--- OpenCASCADE6.3.0.orig//ros/inc/WNT_Window.hxx	2010-07-04 20:13:19.496835196 +0200
+++ OpenCASCADE6.3.0/ros/inc/WNT_Window.hxx	2009-02-18 15:10:04.000000000 +0100
@@ -104,6 +104,12 @@
 //!  Warning: The position and size for the creation of the window <br>
 //!	    are defined in Device Screen Unit (DSU) <br>
 //!	    floating [0,1] space. <br>
+//! <br>
+//!          As 3D view window is the main purpose of this class, <br>
+//!          and 3D view does not need its background to be drawn <br>
+//!          by the system, by default the window background is not drawn. <br>
+//!          This can be overridden by calling ClearFlags( WDF_NOERASEBKGRND ). <br>
+//!          See also WNT_WndProc.cxx and InterfaceGraphic_WNT.hxx. <br>
 class WNT_Window : public Aspect_Window {
 
 public:
@@ -256,9 +262,13 @@
 Standard_EXPORT   void SetPos(const Standard_Integer X,const Standard_Integer Y,const Standard_Integer X1,const Standard_Integer Y1) ;
 
 //! Sets user defined flags in the extra window data area. <br>
+//!          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx <br>
+//!          In particular, the window backround can be turned off using this method. <br>
 Standard_EXPORT   void SetFlags(const Standard_Integer aFlags) ;
 
 //! Reset specified flags in the extra window data area. <br>
+//!          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx <br>
+//!          In particular, the window backround can be turned on using this method. <br>
 Standard_EXPORT   void ResetFlags(const Standard_Integer aFlags) ;
 
 //! Returns the BackingStore capability for this Window. <br>
diff -Naur OpenCASCADE6.3.0.orig//ros/README.txt OpenCASCADE6.3.0/ros/README.txt
--- OpenCASCADE6.3.0.orig//ros/README.txt	2010-07-04 20:16:01.385899457 +0200
+++ OpenCASCADE6.3.0/ros/README.txt	2010-03-25 13:27:01.000000000 +0100
@@ -3,8 +3,8 @@
 On Linux Open CASCADE can be built from source files using scripts based on 
 GNU autoconf, automake and libtool. 
 
-Unpack CAS-6.3.tar.gz to some folder - ${DISTRIBUTIVE_DIR}.
-for example DISTRIBUTIVE_DIR=/tmp/CAS-6.3
+Unpack CAS-6.3sp9.tar.gz to some folder - ${DISTRIBUTIVE_DIR}.
+for example DISTRIBUTIVE_DIR=/tmp/CAS-6.3sp9
 
 cd  ${DISTRIBUTIVE_DIR}
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Aspect/Aspect_GraphicCallbackProc.hxx OpenCASCADE6.3.0/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx
--- OpenCASCADE6.3.0.orig//ros/src/Aspect/Aspect_GraphicCallbackProc.hxx	2010-07-04 20:15:12.906344698 +0200
+++ OpenCASCADE6.3.0/ros/src/Aspect/Aspect_GraphicCallbackProc.hxx	2008-11-12 09:43:26.000000000 +0100
@@ -15,6 +15,13 @@
 #define OCC_REDRAW_WINDOWAREA 2
 #define OCC_REDRAW_BITMAP 3
 
+/* 
+   This flag, when bitwise OR`ed with the "reason" value, 
+   informs the callback that it is called before redrawing the overlayer .
+   Otherwise, the callback is invoked after the overlayer is redrawn.        
+*/
+#define OCC_PRE_OVERLAY 0x8000
+
  typedef struct {
    int reason;
    int wsID;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_SDFWESFiller.cdl OpenCASCADE6.3.0/ros/src/BOP/BOP_SDFWESFiller.cdl
--- OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_SDFWESFiller.cdl	2010-07-04 20:15:06.265918803 +0200
+++ OpenCASCADE6.3.0/ros/src/BOP/BOP_SDFWESFiller.cdl	2010-03-09 09:59:48.000000000 +0100
@@ -2,7 +2,6 @@
 -- Created:	Wed Jun  6 12:37:44 2001
 -- Author:	Peter KURNEV
 --		<pkv@irinox>
----Copyright:	 Matra Datavision 2001
 
 
 class SDFWESFiller from BOP 
@@ -14,7 +13,7 @@
 	
 uses 
     Face from TopoDS, 
-     
+    ListOfShape from TopTools,
     DSFiller  from BOPTools, 
     PDSFiller from BOPTools, 
     IndexedDataMapOfIntegerState from BOPTools,  
@@ -181,8 +180,16 @@
     UpdateDEStates3D  (me:out); 
     	---Purpose:	 
     	--- Update 3D-State for edges    
-    	---
-
+    	--- 
+    --modified by NIZNHY-PKV Tue Mar  9 11:59:28 2010f
+    RejectedOnParts(me) 
+    	returns ListOfShape from TopTools; 
+    ---C++: return const &   
+    ---Purpose:   
+    --  Returns all split edges of nF1 that are CB with 
+    --  splis of nF1 but not included in myWES,     
+    --modified by NIZNHY-PKV Tue Mar  9 11:59:32 2010t
+     
 fields
  
     myDSFiller  : PDSFiller from BOPTools; 
@@ -194,5 +201,9 @@
     myStatesMap:  IndexedDataMapOfIntegerState from BOPTools;
     mySenseFlag:  Integer from Standard;   
     
+    --modified by NIZNHY-PKV Tue Mar  9 11:59:04 2010f 
+    myRejectedOnParts: ListOfShape  from TopTools;    	     
+    --modified by NIZNHY-PKV Tue Mar  9 11:59:07 2010t 
+
 end SDFWESFiller;
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_SDFWESFiller.cxx OpenCASCADE6.3.0/ros/src/BOP/BOP_SDFWESFiller.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_SDFWESFiller.cxx	2010-07-04 20:15:06.265918803 +0200
+++ OpenCASCADE6.3.0/ros/src/BOP/BOP_SDFWESFiller.cxx	2010-03-09 10:01:12.000000000 +0100
@@ -45,6 +45,7 @@
 #include <BOPTools_SolidStateFiller.hxx>
 
 #include <BOPTColStd_Dump.hxx>
+#include <TopTools_MapOfShape.hxx>
 
 //
 static Standard_Boolean IsValidSeam(const TopoDS_Edge& aE,
@@ -191,7 +192,16 @@
 {
   return myOperation;
 }
-
+//modified by NIZNHY-PKV Tue Mar  9 12:00:00 2010f
+//=======================================================================
+//function : RejectedOnParts
+//purpose  : 
+//=======================================================================
+  const TopTools_ListOfShape& BOP_SDFWESFiller::RejectedOnParts()const
+{
+  return myRejectedOnParts;
+}
+//modified by NIZNHY-PKV Tue Mar  9 12:00:06 2010t
 //=======================================================================
 // function: Prepare
 // purpose: 
@@ -683,15 +693,17 @@
   //
   Standard_Integer nE1, nE2, aNbSpON, nSp1, aBid, nSpTaken, nSp2, iRankF1, iRankF2;
   Standard_Real aT1, aT2, aU, aV, aScPr;
-  Standard_Boolean bToReverse, bInternal1, bInternal2;
+  Standard_Boolean bToReverse, bInternal1, bInternal2, bAdded;
   
   TopoDS_Edge aSS, aSSx;
   TopoDS_Face aF1FWD, aF2FWD;
   TopAbs_Orientation anOr, anOr2;
-
   TColStd_ListOfInteger aLs;
   TColStd_IndexedMapOfInteger aMap;
-  TopTools_IndexedMapOfShape aM;
+  TopTools_IndexedMapOfShape aM; 
+  //modified by NIZNHY-PKV Tue Mar  9 12:00:15 2010f
+  TopTools_MapOfShape aMFence;
+  //modified by NIZNHY-PKV Tue Mar  9 12:00:19 2010t
   //
   gp_Vec aN1, aN2, aTau1, aTau2, aBiN1, aBiN2;
   TopExp_Explorer anExpF1, anExpF2;
@@ -702,6 +714,10 @@
   //
   PrepareFaces(nF1, nF2, aF1FWD, aF2FWD);
   //
+  //modified by NIZNHY-PKV Tue Mar  9 12:00:36 2010f
+  myRejectedOnParts.Clear();
+  //modified by NIZNHY-PKV Tue Mar  9 12:00:40 2010t
+  //
   anExpF1.Init(aF1FWD, TopAbs_EDGE);
   for (; anExpF1.More(); anExpF1.Next()) {
     const TopoDS_Edge& anE1=TopoDS::Edge(anExpF1.Current());
@@ -737,14 +753,18 @@
 	aBid=anItLs.Value();
 	aMap.Add(aBid);
       }
-
+      //
       BOPTools_ListOfCommonBlock& aLCB=aCBPool(aDS.RefEdge(nE1));
       BOPTools_ListIteratorOfListOfCommonBlock anItCB(aLCB);
       for (; anItCB.More(); anItCB.Next()) {
+	//modified by NIZNHY-PKV Tue Mar  9 12:00:53 2010ft
+	bAdded=Standard_False;
+	//
 	BOPTools_CommonBlock& aCB=anItCB.Value();
 	// Pave Block from which new edge will be taken
 	const BOPTools_PaveBlock& aPB=aCB.PaveBlock1();
 	nSpTaken=aPB.Edge();
+	const TopoDS_Shape& aSpTaken=aDS.Shape(nSpTaken);
 	//
 	BOPTools_PaveBlock& aPB1=aCB.PaveBlock1(nE1);
 	nSp1=aPB1.Edge();
@@ -766,6 +786,7 @@
 	    if (bInternal1 && bInternal2) {
 	      if (anOperation==BOP_COMMON) {
 		aWES.AddStartElement (aSS);
+		bAdded=Standard_True;
 	      }
 	    }
 	    // b.
@@ -806,10 +827,12 @@
 	      // writting
 	      if (anOperation==BOP_COMMON) {
 		aWES.AddStartElement (aSS);
+		bAdded=Standard_True;
 	      }
 	      if (anOperation==BOP_CUT) { 
 		aSS.Reverse();
-		aWES.AddStartElement (aSS);
+		aWES.AddStartElement (aSS);	
+		bAdded=Standard_True;	
 	      }
 	    } // else x 
 	    continue;
@@ -900,9 +923,10 @@
 	      }
 	      //
 	      aWES.AddStartElement (aSS);
+	      bAdded=Standard_True;	
 	    } 
 	    
-	  }
+	  }//if (aScPr < 0.) {
 	  
 	  else {
 	    if (anOperation==BOP_COMMON) {
@@ -940,18 +964,27 @@
 		  aWES.AddStartElement (aSpE2);
 		  aSpE2.Reverse();
 		  aWES.AddStartElement (aSpE2);
+		  bAdded=Standard_True;	
 		  continue;  
 		}
 		//
 	      }
 	      //
 	      aWES.AddStartElement (aSS);
-	    } 
+	      bAdded=Standard_True;	
+	    }//if (anOperation==BOP_COMMON) {
+	  }//else {
+	  //modified by NIZNHY-PKV Tue Mar  9 12:01:01 2010f
+	  if (!bAdded) {
+	    if(aMFence.Add(aSpTaken)) { 
+	      myRejectedOnParts.Append(aSpTaken);
+	    }
 	  }
-	}
-      }
-    }
-  }
+	  //modified by NIZNHY-PKV Tue Mar  9 12:01:08 2010t
+	}//if (aMap.Contains(nSp1)) {
+      }//for (; anItCB.More(); anItCB.Next()) {
+    }//for (; anExpF2.More(); anExpF2.Next()) {
+  }//for (; anExpF1.More(); anExpF1.Next()) {
 }
 
 //=======================================================================
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid_1.cxx OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid_1.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid_1.cxx	2010-07-04 20:15:06.392581420 +0200
+++ OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid_1.cxx	2010-03-09 10:03:10.000000000 +0100
@@ -381,14 +381,25 @@
     } // next CB on nEF2
   }
 }
-
 //=======================================================================
 // function: AddINON2DPartsSh
 // purpose: 
 //=======================================================================
   void BOP_ShellSolid::AddINON2DPartsSh(const Standard_Integer nF1,
 					const Standard_Integer iFF,
-					BOP_WireEdgeSet& aWES) 
+					BOP_WireEdgeSet& aWES)
+{
+  TopTools_IndexedMapOfShape anEMap;
+  AddINON2DPartsSh(nF1, iFF, aWES, anEMap);
+}
+//=======================================================================
+// function: AddINON2DPartsSh
+// purpose: 
+//=======================================================================
+  void BOP_ShellSolid::AddINON2DPartsSh(const Standard_Integer nF1,
+					const Standard_Integer iFF,
+					BOP_WireEdgeSet& aWES,
+					TopTools_IndexedMapOfShape& anEMap) 
 {
   const BooleanOperations_ShapesDataStructure& aDS=myDSFiller->DS();
   BOPTools_InterferencePool* pIntrPool=(BOPTools_InterferencePool*)&myDSFiller->InterfPool();
@@ -458,7 +469,24 @@
   default:
     break;
   }
-  
+  //
+  //modified by NIZNHY-PKV Tue Mar  9 12:02:57 2010f
+  // Collect all split edges of nF1 that are CB with 
+  // splis of all SD faces to nFx,
+  // but not included in aWES (RejectedOnParts).
+  // This is necessary to prevent inclusion these splits in 
+  // AddPartsEENonSDSh(...) 
+  // see BOP_SDFWESFiller,  BOP_ShellSolid::DoNewFaces()
+  //  for more details;
+  TopTools_ListIteratorOfListOfShape aIt;
+  //
+  const TopTools_ListOfShape& aLRE=aWESFiller.RejectedOnParts();
+  aIt.Initialize(aLRE);
+  for(; aIt.More(); aIt.Next()) {
+    const TopoDS_Shape& aE=aIt.Value();
+    anEMap.Add(aE);
+  }
+  //modified by NIZNHY-PKV Tue Mar  9 12:03:05 2010t
 }
 //=======================================================================
 // function: AddPartsEFNonSDSh
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid.cdl OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid.cdl
--- OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid.cdl	2010-07-04 20:15:06.046244336 +0200
+++ OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid.cdl	2010-03-09 10:01:42.000000000 +0100
@@ -75,9 +75,7 @@
     	--- see base  classes, please
     	---
     Prepare(me:out)  
-    --modified by NIZNHY-PKV Wed Sep 11 17:55:29 2002  f
    	 is virtual;--protected;   
-    --modified by NIZNHY-PKV Wed Sep 11 17:55:32 2002  t		  
     	---Purpose: 
     	--- Provides some preparing steps of algorithm     
     	--- 1.  Compute the 3D-States 
@@ -122,13 +120,22 @@
 	    anEMap  : out  IndexedMapOfShape from TopTools;	    	    			 
     	    aWES :out WireEdgeSet from BOP) 
     	is protected; 	  	
- 	 
+ 	  
     AddINON2DPartsSh (me:out; 
     	    nF1  :Integer from Standard; 
     	    iFF  :Integer from Standard; 
     	    aWES :out WireEdgeSet from BOP) 
-    	is protected;   	 
-	 
+    	is protected; 
+    --	 
+    --modified by NIZNHY-PKV Tue Mar  9 12:01:31 2010f
+    AddINON2DPartsSh (me:out; 
+    	    nF1  :Integer from Standard; 
+    	    iFF  :Integer from Standard; 
+    	    aWES :out WireEdgeSet from BOP; 
+    	    anEMap  : out  IndexedMapOfShape from TopTools) 
+    	is protected;    
+    --modified by NIZNHY-PKV Tue Mar  9 12:01:37 2010t
+    --		  
     AddPartsEFNonSDSh (me:out; 
     	    nF1  :Integer from Standard; 
     	    iFF  :Integer from Standard; 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid.cxx OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOP/BOP_ShellSolid.cxx	2010-07-04 20:15:06.046244336 +0200
+++ OpenCASCADE6.3.0/ros/src/BOP/BOP_ShellSolid.cxx	2010-03-09 10:02:48.000000000 +0100
@@ -333,18 +333,26 @@
 	  AddSectionPartsSo(nF1, iFF, aWES);
 	}
       }
-      // 3. Add IN2D, ON2D Parts to the WES 
+      // 3. Add IN2D, ON2D Parts to the WES
+      //modified by NIZNHY-PKV Tue Mar  9 12:01:50 2010f
+      anEMap.Clear(); 
+      //modified by NIZNHY-PKV Tue Mar  9 12:01:53 2010t
       for (j=1; j<=aNbj; j++) {
 	iFF=aFFIndicesMap(j);
 	BOPTools_SSInterference& aFF=aFFs(iFF);
 	bIsTouch=aFF.IsTangentFaces();
 	if (bIsTouch) {
-	  AddINON2DPartsSh(nF1, iFF, aWES);
+	  //modified by NIZNHY-PKV Tue Mar  9 12:02:01 2010f
+	  //AddINON2DPartsSh(nF1, iFF, aWES);
+	  AddINON2DPartsSh(nF1, iFF, aWES, anEMap);
+	  //modified by NIZNHY-PKV Tue Mar  9 12:02:04 2010t
 	}
       }
       // 4. Add EF parts (E (from F2) on F1 ),
       // where F2 is non-same-domain face to F1
-      anEMap.Clear();
+      //modified by NIZNHY-PKV Tue Mar  9 12:02:22 2010f
+      //anEMap.Clear();
+      //modified by NIZNHY-PKV Tue Mar  9 12:02:26 2010t
       //
       // anEMap will contain all Split parts that has already in aWES
       const TopTools_ListOfShape& aLE=aWES.StartElements();
@@ -385,6 +393,7 @@
       
     }// end of (bIsTouchCase)'s else
     //
+    
     //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     // Display the WES
     if (myDraw)  {
@@ -1337,4 +1346,24 @@
 
   return Standard_True;
 }
-
+/*
+//modified by NIZNHY-PKV Tue Mar  9 12:02:37 2010f
+{
+  Standard_Integer aNbE;
+  TopoDS_Compound aCx;
+  BRep_Builder aBB;
+  TopTools_ListIteratorOfListOfShape aIt;
+  //
+  aBB.MakeCompound(aCx);
+  //
+  const TopTools_ListOfShape& aWESL=aWES.StartElements();
+  aNbE=aWESL.Extent();
+  aIt.Initialize(aWESL);
+  for (; aIt.More(); aIt.Next()) {
+    const TopoDS_Shape& aE=aIt.Value();
+    aBB.Add(aCx, aE);
+  }
+  int a=0;
+}
+//modified by NIZNHY-PKV Tue Mar  9 12:02:44 2010t
+*/
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_PaveFiller_3.cxx OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_PaveFiller_3.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_PaveFiller_3.cxx	2010-07-04 20:15:31.275963572 +0200
+++ OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_PaveFiller_3.cxx	2010-03-01 11:26:16.000000000 +0100
@@ -16,7 +16,6 @@
 #include <TColStd_ListOfInteger.hxx>
 #include <TColStd_IndexedMapOfInteger.hxx>
 #include <TColStd_ListIteratorOfListOfInteger.hxx>
-// modified by NIZHNY-MKK  Tue Oct 18 12:37:02 2005
 #include <TColStd_MapIteratorOfMapOfInteger.hxx>
 
 #include <TopoDS.hxx>
@@ -84,7 +83,6 @@
 #include <BOPTools_ESInterference.hxx>
 #include <BOPTools_ShapeShapeInterference.hxx>
 
-// modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005
 #include <IntSurf_ListOfPntOn2S.hxx>
 
 #include <GeomAPI_ProjectPointOnSurf.hxx>
@@ -129,6 +127,7 @@
 				 const BOPTools_PaveSet& aPSF,
 				 BOPTools_SequenceOfCurves& aSCvs,
 				 const BOPTools_InterferencePool& anIntrPool,
+				 BOPTools_PaveFiller& aPF,
 				 TColStd_SequenceOfInteger& aSeqVx,
 				 TColStd_SequenceOfReal& aSeqTolVx);
  
@@ -252,9 +251,6 @@
       nF2=iTmp;
     }
 
-//     const TopoDS_Face& aF1=TopoDS::Face(myDS->GetShape(nF1));
-//     const TopoDS_Face& aF2=TopoDS::Face(myDS->GetShape(nF2));
-    // modified by NIZHNY-MKK  Tue Oct 18 12:33:59 2005.BEGIN
     TopoDS_Face aF1=TopoDS::Face(myDS->GetShape(nF1));
     TopoDS_Face aF2=TopoDS::Face(myDS->GetShape(nF2));
     IntSurf_ListOfPntOn2S aListOfPnts;
@@ -343,7 +339,6 @@
 		}
 	      }              
 	      else {
-		// modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.BEGIN
 		aProj1.Perform(aPoint);
 		aProj2.Perform(aPoint);
 		if(aProj1.IsDone() && aProj2.IsDone()){
@@ -352,15 +347,12 @@
 		  aPnt.SetValue(U1,V1,U2,V2);
 		  aListOfPnts.Append(aPnt);                
 		}
-		// modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
 	      }
 	    }
 	  }
 	}
       }
     }
-    // modified by NIZHNY-MKK  Tue Oct 18 12:34:07 2005.END
-
     //
     // FF
     Standard_Boolean bToApproxC3d, bToApproxC2dOnS1, bToApproxC2dOnS2, bIsDone;
@@ -377,10 +369,9 @@
 		       bToApproxC2dOnS1, 
 		       bToApproxC2dOnS2,
 		       anApproxTol);
-    // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.BEGIN
     if (!aListOfPnts.IsEmpty())
       aFF.SetList(aListOfPnts);
-    // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
+
     aFF.Perform(aF1, aF2);
 
     bIsDone=aFF.IsDone();
@@ -1341,12 +1332,9 @@
   const IntTools_Curve& aC=aBC.Curve();
   Handle (Geom_Curve) aC3D= aC.Curve();
   //
-  //modified by NIZNHY-PKV Tue Oct 19 11:11:40 2004 f
   aTolVExt=BRep_Tool::Tolerance(aV);
   ExtendedTolerance(nV, aTolVExt);
   bIsVertexOnLine=myContext.IsVertexOnLine(aV, aTolVExt, aC, aTolR3D, aT);
-  //bIsVertexOnLine=myContext.IsVertexOnLine(aV, aC, aTolR3D, aT);
-  //modified by NIZNHY-PKV Tue Oct 19 11:12:39 2004 t
   //
   if (bIsVertexOnLine) {
     BOPTools_Pave aPaveNew(nV, aT, BooleanOperations_SurfaceSurface);
@@ -1357,7 +1345,6 @@
   }
 }
 //
-//modified by NIZNHY-PKV Tue Oct 19 11:36:34 2004 f
 //=======================================================================
 // function: ExtendedTolerance
 // purpose: 
@@ -1416,7 +1403,6 @@
   //
   return bFound;
 }
-//modified by NIZNHY-PKV Tue Oct 19 11:36:40 2004 t
 //
 //=======================================================================
 // function: PutPavesOnCurves
@@ -1495,10 +1481,8 @@
       BOPTools_ListOfPave anOldList;
       anOldList = aBC.Set().Set();
 
-//  Modified by skv - Mon Sep 26 14:58:30 2005 Begin
       if (aBC.NewPaveBlocks().IsEmpty())
 	continue;
-//  Modified by skv - Mon Sep 26 14:58:30 2005 End
       //
       
       BOPTools_CArray1OfESInterference& aESs = myIntrPool->ESInterferences();
@@ -1628,7 +1612,7 @@
       TColStd_SequenceOfInteger aSeqVx;
       TColStd_SequenceOfReal    aSeqTolVx;
       //
-      ProcessAloneStickVertices(nF1, nF2, aPSF, aSCvs, *myIntrPool, aSeqVx, aSeqTolVx);
+      ProcessAloneStickVertices(nF1, nF2, aPSF, aSCvs, *myIntrPool, *this,  aSeqVx, aSeqTolVx);
       //
       aNbVtx=aSeqVx.Length();
       for (jx=1; jx<=aNbVtx; ++jx) {
@@ -1801,6 +1785,7 @@
 #include <GeomAbs_SurfaceType.hxx>
 #include <Geom_Surface.hxx>
 #include <GeomAdaptor_Surface.hxx>
+#include <GeomAPI_ProjectPointOnCurve.hxx>
 
 //=======================================================================
 // function: ProcessAloneStickVertices
@@ -1811,6 +1796,9 @@
 			       const BOPTools_PaveSet& aPSF,
 			       BOPTools_SequenceOfCurves& aSCvs,
 			       const BOPTools_InterferencePool& anIntrPool,
+			       //modified by NIZNHY-PKV Mon Mar  1 08:44:52 2010f
+			       BOPTools_PaveFiller& aPF, 
+			       //modified by NIZNHY-PKV Mon Mar  1 08:44:54 2010t
 			       TColStd_SequenceOfInteger& aSeqVx,
 			       TColStd_SequenceOfReal& aSeqTolVx)
 {
@@ -1850,6 +1838,49 @@
       }
     }
   }
+  //
+  //modified by NIZNHY-PKV Mon Mar  1 08:38:57 2010f
+  //wkar  pkv/904/F1
+  if((aType1==GeomAbs_Torus && aType2==GeomAbs_Plane) ||
+     (aType1==GeomAbs_Plane && aType2==GeomAbs_Torus)) {
+    Standard_Integer aNbSCvs, aNbPoints;
+    Standard_Real aDist, aTolV;
+    gp_Pnt aPV;
+    //
+    UnUsedMap(aSCvs, aPSF, aMapUnUsed);
+    aNbVtx=aMapUnUsed.Extent();
+    if (aNbVtx) {
+      IntTools_Context& aCtx=aPF.ChangeContext();
+      //
+      aNbSCvs=aSCvs.Length();
+      if (aNbSCvs==1) {
+	BOPTools_Curve& aBC=aSCvs(1);
+	const IntTools_Curve& aC=aBC.Curve();
+	Handle (Geom_Curve) aC3D= aC.Curve();
+	GeomAPI_ProjectPointOnCurve& aProjPT=aCtx.ProjPT(aC3D);
+	//
+	for (jx=1; jx<=aNbVtx; ++jx) {
+	  nV=aMapUnUsed(jx);
+	  if (pDS->IsNewShape(nV)) {
+	    const TopoDS_Vertex& aV=*((TopoDS_Vertex*)&pDS->Shape(nV));
+	    aTolV=BRep_Tool::Tolerance(aV);
+	    aPV=BRep_Tool::Pnt(aV);
+	    //
+	    aProjPT.Perform(aPV);
+	    aNbPoints=aProjPT.NbPoints();
+	    if (aNbPoints) {
+	      aDist=aProjPT.LowerDistance();
+	      aDist=(aDist>aTolV)?  aDist : aTolV;
+	      aSeqVx.Append(nV);
+	      aSeqTolVx.Append(aDist);
+	    }
+	  }
+	}
+      }
+    }
+  }
+  //modified by NIZNHY-PKV Mon Mar  1 08:38:59 2010t
+  //
 }
 //=======================================================================
 // function: UnUsedMap
@@ -2904,18 +2935,25 @@
   theTF = 2* (t1 + t2);
   BRepAdaptor_Surface BAS1(theF1);
   BRepAdaptor_Surface BAS2(theF2);
+  //
   Standard_Boolean isAna1 = (BAS1.GetType() == GeomAbs_Plane ||
                              BAS1.GetType() == GeomAbs_Cylinder ||
                              BAS1.GetType() == GeomAbs_Cone ||
                              BAS1.GetType() == GeomAbs_Sphere);
+  //
   Standard_Boolean isAna2 = (BAS2.GetType() == GeomAbs_Plane ||
                              BAS2.GetType() == GeomAbs_Cylinder ||
                              BAS2.GetType() == GeomAbs_Cone ||
                              BAS2.GetType() == GeomAbs_Sphere);
-
-  if(isAna1 && isAna2)
+  //
+  //modified by NIZNHY-PKV Thu Feb 25 11:35:11 2010f
+  isAna1=isAna1||(BAS1.GetType() == GeomAbs_Torus);
+  isAna2=isAna2||(BAS2.GetType() == GeomAbs_Torus);
+  //modified by NIZNHY-PKV Thu Feb 25 11:35:14 2010t
+  //
+  if(isAna1 && isAna2) {
     return Standard_False;
-
+  }
   theTF = Max(theTF, 5.e-6);
   return Standard_True;
 }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools2D.cxx OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools2D.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools2D.cxx	2010-07-04 20:15:31.302581420 +0200
+++ OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools2D.cxx	2010-02-24 06:36:14.000000000 +0100
@@ -467,12 +467,25 @@
   // dv
   dv = 0.;
   if (aBAS.IsVPeriodic()) {
-    //     mincond = (VMin - v2 > -aDelta);
+    Standard_Real aVPeriod, aVm, aVr, aVmid, dVm, dVr;
+    //
+    aVPeriod=aBAS.VPeriod();
     mincond = (VMin - v2 > aDelta);
     maxcond = (v2 - VMax > aDelta);
     decalv = mincond || maxcond;
     if (decalv) {
-      dv = ( mincond ) ? aBAS.VPeriod() : -aBAS.VPeriod();
+      dv = ( mincond ) ? aVPeriod : -aVPeriod;
+    }
+    //
+    if ((VMax-VMin<aVPeriod) && dv) {
+      aVm=v2;
+      aVr=v2+dv;
+      aVmid=0.5*(VMin+VMax);
+      dVm=fabs(aVm-aVmid);
+      dVr=fabs(aVr-aVmid);
+      if (dVm<dVr) {
+	dv=0.;
+      }
     }
   }
   //
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools3D_1.cxx OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools3D_1.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools3D_1.cxx	2010-07-04 20:15:31.285897222 +0200
+++ OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools3D_1.cxx	2009-03-19 12:15:34.000000000 +0100
@@ -106,7 +106,6 @@
   //
   aETol = BRep_Tool::Tolerance(aE);
   aFTol = BRep_Tool::Tolerance(aF);
-  //modified by NIZNHY-PKV Fri Mar 28 15:09:30 2008f
   // pkv NPAL19220
   GeomAdaptor_Surface aGAS(aS);
   aTS=aGAS.GetType();
@@ -115,12 +114,10 @@
       aFTol=aETol;
     }
   }
-  //modified by NIZNHY-PKV Fri Mar 28 15:09:43 2008t
-  if( aETol > 1.e-5 && aFTol > 1.e-5 ) {
-    //modified by NIZNHY-PKV Fri Mar 28 15:09:52 2008f
-    //GeomAdaptor_Surface aGAS(aS);
-    //aTS=aGAS.GetType();
-    //modified by NIZNHY-PKV Fri Mar 28 15:10:01 2008t
+  //modified by NIZNHY-PKV Thu Mar 19 14:15:15 2009f
+  if( aETol > 1.e-5 || aFTol > 1.e-5 ) {
+  //if( aETol > 1.e-5 && aFTol > 1.e-5 ) {
+    //modified by NIZNHY-PKV Thu Mar 19 14:15:24 2009t
     //pkv/103/D7
     if(aTS!=GeomAbs_Sphere) {
       gp_Vec2d transVec( aDP );
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools.cxx OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BOPTools/BOPTools_Tools.cxx	2010-07-04 20:15:31.249235864 +0200
+++ OpenCASCADE6.3.0/ros/src/BOPTools/BOPTools_Tools.cxx	2009-02-10 06:50:16.000000000 +0100
@@ -464,16 +464,27 @@
   //
   aNewSR=aSR;
   //
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:03 2009f
+  aBC.Initialize(aE1);
+  aCT=aBC.GetType();
+  if (aCT==GeomAbs_Line) {
+    return;
+  }
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:06 2009t
+  //
   dT=Precision::PConfusion();
   aTF=aSR.First();
   aTL=aSR.Last();
   //
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:39 2009f
+  /*
   aBC.Initialize(aE1);
   aCT=aBC.GetType();
+  */
+  //modified by NIZNHY-PKV Tue Feb 10 08:47:43 2009t
   //
   aTolE1=BRep_Tool::Tolerance(aE1);
   aTolE2=BRep_Tool::Tolerance(aE2);
-  
   //
   for(i=0; i<2; ++i) {
     aRes = 2.*(aTolE1 + aTolE2);
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRep/BRep_Tool.cxx OpenCASCADE6.3.0/ros/src/BRep/BRep_Tool.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BRep/BRep_Tool.cxx	2010-07-04 20:15:11.619661827 +0200
+++ OpenCASCADE6.3.0/ros/src/BRep/BRep_Tool.cxx	2008-11-25 15:37:15.000000000 +0100
@@ -28,6 +28,7 @@
 #include <ElSLib.hxx>
 #include <Geom_Plane.hxx>
 #include <Geom_RectangularTrimmedSurface.hxx>
+#include <Geom_OffsetSurface.hxx>
 #include <Geom_TrimmedCurve.hxx>
 #include <Geom2d_TrimmedCurve.hxx>
 #include <ProjLib_ProjectedCurve.hxx>
@@ -41,6 +42,11 @@
 #include <Poly_Polygon2D.hxx>
 #include <Poly_PolygonOnTriangulation.hxx>
 
+//modified by NIZNHY-PKV Fri Oct 17 14:13:29 2008f
+static 
+  Standard_Boolean IsPlane(const Handle(Geom_Surface)& aS);
+//modified by NIZNHY-PKV Fri Oct 17 14:13:33 2008t
+//
 //=======================================================================
 //function : Surface
 //purpose  : Returns the geometric surface of the face. Returns
@@ -698,6 +704,12 @@
 				     const Handle(Geom_Surface)& S,
 				     const TopLoc_Location& L)
 {
+  //modified by NIZNHY-PKV Fri Oct 17 12:16:58 2008f
+  if (IsPlane(S)) {
+    return Standard_False;
+  }
+  //modified by NIZNHY-PKV Fri Oct 17 12:16:54 2008t
+  //
   TopLoc_Location      l = L.Predivided(E.Location());
 
   // find the representation
@@ -1496,13 +1508,11 @@
   Standard_NoSuchObject::Raise("BRep_Tool:: no parameters on surface");
   return gp_Pnt2d(0,0);
 }
-
 //=======================================================================
 //function : IsClosed
 //purpose  : Returns <True>  if S if flaged Closed, if S is a
 //           Solid,Shell or Compound  returns <True> is S has no free boundaries.
 //=======================================================================
-
 Standard_Boolean BRep_Tool::IsClosed(const TopoDS_Shape& S)
 {
   if (S.ShapeType() == TopAbs_SHELL || S.ShapeType() == TopAbs_SOLID ||
@@ -1519,3 +1529,33 @@
   }
   return (S.Closed());
 }
+
+//modified by NIZNHY-PKV Fri Oct 17 14:09:58 2008 f 
+//=======================================================================
+//function : IsPlane
+//purpose  : 
+//=======================================================================
+Standard_Boolean IsPlane(const Handle(Geom_Surface)& aS)
+{
+  Standard_Boolean bRet;
+  Handle(Geom_Plane) aGP;
+  Handle(Geom_RectangularTrimmedSurface) aGRTS;
+  Handle(Geom_OffsetSurface) aGOFS;
+  //
+  aGRTS=Handle(Geom_RectangularTrimmedSurface)::DownCast(aS);
+  aGOFS=Handle(Geom_OffsetSurface)::DownCast(aS);
+  //
+  if(!aGOFS.IsNull()) {
+    aGP=Handle(Geom_Plane)::DownCast(aGOFS->BasisSurface());
+  }
+  else if(!aGRTS.IsNull()) {
+    aGP=Handle(Geom_Plane)::DownCast(aGRTS->BasisSurface());
+  }
+  else {
+    aGP=Handle(Geom_Plane)::DownCast(aS);
+  }
+  //
+  bRet=!aGP.IsNull();
+  //
+  return bRet;
+}
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx OpenCASCADE6.3.0/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx	2010-07-04 20:15:20.586318997 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepBuilderAPI/BRepBuilderAPI_Sewing.cxx	2009-04-08 12:46:11.000000000 +0200
@@ -1,4447 +1,4457 @@
-// File:        BRepBuilderAPI_Sewing.cxx
-// Created:        Fri Mar 24 09:45:44 1995
-// Author:        Jing Cheng MEI
-//                <mei@junon>
-// dcl          CCI60011 : Correction of degeneratedSection
-//              Improvement of SameParameter Edge to treat case of failure in BRepLib::SameParameter
-// dcl          Thu Aug 20 09:24:49 1998
-//              Suppression of little faces.
-// dcl          Fri Aug  7 15:27:46 1998
-//                Refection of function SameParameter Edge.
-//              Merge on the edge which has the less of poles.
-//              Suppression of the Connected Edge function.
-// dcl          Tue Jun  9 14:21:53 1998
-//              Do not merge edge if they belong the same face
-//              Tolerance management in VerticesAssembling
-//              Tolerance management in Cutting
-// dcl          Thu May 14 15:51:46 1998
-//              optimization of cutting
-// dcl          Thu May 7  15:51:46 1998
-//              Add of cutting option
-//              Add of SameParameter call
-
-
-//-- lbr le 1er avril 97
-//-- dpf le 10 decembre 1997 Traitement des collections de pcurve
-
-//rln 02.02.99 BUC60449 Making compilable on NT in DEB mode 
-//rln 02.02.99 BUC60449 Protection against exception on NT
-
-#define TEST 1
-
-#include <BRepBuilderAPI_Sewing.ixx>
-
-#include <Bnd_Box.hxx>
-#include <Bnd_Box2d.hxx>
-#include <Bnd_HArray1OfBox.hxx>
-#include <BndLib_Add2dCurve.hxx>
-#include <BndLib_Add3dCurve.hxx>
-#include <BRep_Builder.hxx>
-#include <BRep_Tool.hxx>
-#include <BRepLib.hxx>
-#include <BRepTools_Quilt.hxx>
-#include <BSplCLib.hxx>
-#include <Extrema_ExtPC.hxx>
-#include <GCPnts_AbscissaPoint.hxx>
-#include <GCPnts_UniformAbscissa.hxx>
-#include <GCPnts_UniformDeflection.hxx>
-#include <Geom2d_BezierCurve.hxx>
-#include <Geom2d_BSplineCurve.hxx>
-#include <Geom2d_Curve.hxx>
-#include <Geom2d_Line.hxx>
-#include <Geom2d_TrimmedCurve.hxx>
-#include <Geom2dAdaptor_Curve.hxx>
-#include <Geom2dConvert.hxx>
-#include <Geom_BezierCurve.hxx>
-#include <Geom_BSplineCurve.hxx>
-#include <Geom_Curve.hxx>
-#include <Geom_Line.hxx>
-#include <Geom_Surface.hxx>
-#include <GeomAdaptor_Curve.hxx>
-#include <GeomAdaptor_Surface.hxx>
-#include <GeomLib.hxx>
-#include <gp_Pnt.hxx>
-#include <gp_Vec.hxx>
-//#include <LocalAnalysis_SurfaceContinuity.hxx>
-#include <Precision.hxx>
-#include <Standard_ErrorHandler.hxx>
-#include <Standard_Failure.hxx>
-#include <TColgp_Array1OfVec.hxx>
-#include <TColgp_SequenceOfPnt.hxx>
-#include <TColStd_Array1OfInteger.hxx>
-#include <TColStd_Array1OfReal.hxx>
-#include <TColStd_DataMapIteratorOfDataMapOfIntegerListOfInteger.hxx>
-#include <TColStd_DataMapOfIntegerListOfInteger.hxx>
-#include <TColStd_IndexedMapOfInteger.hxx>
-#include <TColStd_ListIteratorOfListOfInteger.hxx>
-#include <TColStd_ListOfInteger.hxx>
-#include <TColStd_MapOfInteger.hxx>
-#include <TColStd_SequenceOfReal.hxx>
-#include <TopAbs.hxx>
-#include <TopExp.hxx>
-#include <TopExp_Explorer.hxx>
-#include <TopLoc_Location.hxx>
-#include <TopoDS.hxx>
-#include <TopoDS_Edge.hxx>
-#include <TopoDS_Iterator.hxx>
-#include <TopoDS_Shape.hxx>
-#include <TopoDS_Vertex.hxx>
-#include <TopoDS_Wire.hxx>
-#include <TopoDS_Shell.hxx>
-#include <TopTools_Array1OfShape.hxx>
-#include <TopTools_DataMapIteratorOfDataMapOfShapeListOfShape.hxx>
-#include <TopTools_DataMapIteratorOfDataMapOfShapeShape.hxx>
-#include <TopTools_DataMapOfShapeInteger.hxx>
-#include <TopTools_DataMapOfShapeListOfShape.hxx>
-#include <TopTools_ListIteratorOfListOfShape.hxx>
-#include <TopTools_ListOfShape.hxx>
-#include <TopTools_MapIteratorOfMapOfShape.hxx>
-#include <TopTools_MapOfShape.hxx>
-#include <TopTools_SequenceOfShape.hxx>
-#include <TopoDS_Compound.hxx>
-#include <TColStd_Array2OfReal.hxx>
-#include <TColStd_MapIteratorOfMapOfInteger.hxx>
-#include <BRepTools.hxx>
-#include <Geom_RectangularTrimmedSurface.hxx>
-#include <Geom_OffsetSurface.hxx>
-#include <BRep_PointOnCurve.hxx>
-#include <BRep_ListOfPointRepresentation.hxx>
-#include <BRep_TVertex.hxx>
-
-static void SortBox (const Handle(Bnd_HArray1OfBox) hSetBoxes,
-		     const Bnd_Box& aBox,
-		     TColStd_ListOfInteger& listIndex)
-{
-  Standard_Integer i, nbBoxes = hSetBoxes->Length();
-  for (i = 1; i <= nbBoxes; i++)
-    if (!aBox.IsOut(hSetBoxes->Value(i)))
-      listIndex.Append(i);
-}
-
-//=======================================================================
-//function : SameRange
-//purpose  : 
-//=======================================================================
-
-Handle(Geom2d_Curve) BRepBuilderAPI_Sewing::SameRange(const Handle(Geom2d_Curve)& CurvePtr,
-						const Standard_Real FirstOnCurve,
-						const Standard_Real LastOnCurve,
-						const Standard_Real RequestedFirst,
-						const Standard_Real RequestedLast) const
-{
-  Handle(Geom2d_Curve) NewCurvePtr;
-  try {
-    
-    GeomLib::SameRange(Precision::PConfusion(),CurvePtr,FirstOnCurve,LastOnCurve,
-		       RequestedFirst,RequestedLast,NewCurvePtr);
-  }
-  catch (Standard_Failure) {
-#ifdef DEB
-    cout << "Exception in BRepBuilderAPI_Sewing::SameRange: ";
-    Standard_Failure::Caught()->Print(cout); cout << endl;
-#endif
-  }
-  return NewCurvePtr;
-}
-
-//=======================================================================
-//function : WhichFace
-//purpose  : Give the face dont ledge est le bord
-//=======================================================================
-
-TopoDS_Face BRepBuilderAPI_Sewing::WhichFace(const TopoDS_Edge& theEdg, const Standard_Integer index) const
-{
-  TopoDS_Shape bound = theEdg;
-  if (mySectionBound.IsBound(bound)) bound = mySectionBound(bound);
-  if (myBoundFaces.Contains(bound)) {
-    Standard_Integer i = 1;
-    TopTools_ListIteratorOfListOfShape itf(myBoundFaces.FindFromKey(bound));
-    for (; itf.More(); itf.Next(), i++)
-      if (i == index) return TopoDS::Face(itf.Value());
-  }
-  return TopoDS_Face();
-}
-
-//=======================================================================
-//function : IsClosedShape
-//purpose  : 
-//=======================================================================
-
-static Standard_Boolean IsClosedShape(const TopoDS_Shape& theshape,
-				      const TopoDS_Shape& v1, const TopoDS_Shape& v2)
-{
-  Standard_Real TotLength = 0.0;
-  TopExp_Explorer aexp;
-  for (aexp.Init(theshape,TopAbs_EDGE); aexp.More(); aexp.Next()) {
-    TopoDS_Edge aedge = TopoDS::Edge(aexp.Current());
-    if (aedge.IsNull()) continue;
-    TopoDS_Vertex ve1,ve2;
-    TopExp::Vertices(aedge,ve1,ve2);
-    if (!ve1.IsSame(v1) && !ve1.IsSame(v2)) continue;
-    if (BRep_Tool::Degenerated(aedge)) continue;
-    Standard_Real first,last;
-    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(aedge), first, last);
-    if (!c3d.IsNull()) {
-      GeomAdaptor_Curve cAdapt(c3d);
-      Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
-      TotLength += length;
-      if (ve2.IsSame(v1) || ve2.IsSame(v2)) break;
-    }
-  }
-  if (TotLength > 0.0) {
-    gp_Pnt p1 = BRep_Tool::Pnt(TopoDS::Vertex(v1));
-    gp_Pnt p2 = BRep_Tool::Pnt(TopoDS::Vertex(v2));
-    return (p1.Distance(p2) < TotLength/(1.2 * PI));
-  }
-  return Standard_False;
-}
-
-//=======================================================================
-//function : IsClosedByIsos
-//purpose  : 
-//=======================================================================
-static Standard_Boolean IsClosedByIsos(const Handle(Geom_Surface)& thesurf,
-                                       const Handle(Geom2d_Curve)& acrv2d,
-                                       const Standard_Real f2d,
-                                       const  Standard_Real l2d,
-                                       const Standard_Boolean isUIsos) 
-{
-  Standard_Boolean isClosed = Standard_False;
- 
-  gp_Pnt2d psurf1 = (acrv2d->IsPeriodic() ? 
-                     acrv2d->Value(f2d) :  acrv2d->Value(Max(f2d,acrv2d->FirstParameter())));
-  gp_Pnt2d psurf2 = (acrv2d->IsPeriodic() ? 
-                     acrv2d->Value(l2d) :  acrv2d->Value(Min(l2d,acrv2d->LastParameter())));
-  Handle(Geom_Curve) aCrv1;
-  Handle(Geom_Curve) aCrv2;
-  if(isUIsos) {
-    aCrv1 = thesurf->UIso(psurf1.X());
-    aCrv2 = thesurf->UIso(psurf2.X());
-  }
-  else {
-    aCrv1 = thesurf->VIso(psurf1.Y());
-    aCrv2 = thesurf->VIso(psurf2.Y());
-  }
-  gp_Pnt p11,p1m,p12,p21,p2m,p22;
-  Standard_Real af1 = aCrv1->FirstParameter();
-  Standard_Real al1 = aCrv1->LastParameter();
-  Standard_Real af2 = aCrv2->FirstParameter();
-  Standard_Real al2 = aCrv2->LastParameter();
-  aCrv1->D0(af1,p11);
-  aCrv1->D0((af1+al1)*0.5,p1m);
-  aCrv1->D0(al1,p12);
-  aCrv2->D0(af2,p21);
-  aCrv2->D0((af2+al2)*0.5,p2m);
-  aCrv2->D0(al2,p22);
-  isClosed = (((p11.XYZ() - p12.XYZ()).Modulus() < 
-               (p11.XYZ() - p1m.XYZ()).Modulus() - Precision::Confusion()) &&
-              ((p21.XYZ() - p22.XYZ()).Modulus() < 
-               (p21.XYZ() - p2m.XYZ()).Modulus() - Precision::Confusion())) ;
-  return isClosed;
-}
-//=======================================================================
-//function : IsUClosedSurface
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsUClosedSurface(const Handle(Geom_Surface)& surf,
-                                                   const TopoDS_Shape& theEdge,
-                                                   const TopLoc_Location& theloc) const
-{
-  Handle(Geom_Surface) tmpsurf = surf;
-  if(tmpsurf->IsKind(STANDARD_TYPE(Geom_RectangularTrimmedSurface))) 
-    tmpsurf = Handle(Geom_RectangularTrimmedSurface)::DownCast(surf)->BasisSurface();
-  else if(tmpsurf->IsKind(STANDARD_TYPE(Geom_OffsetSurface))) 
-    tmpsurf = Handle(Geom_OffsetSurface)::DownCast(surf)->BasisSurface();
-  else {
-    Standard_Boolean isClosed = tmpsurf->IsUClosed();
-    if(!isClosed) {
-      Standard_Real f2d, l2d;
-      Handle(Geom2d_Curve) acrv2d = BRep_Tool::CurveOnSurface(TopoDS::Edge(theEdge), surf,theloc, f2d, l2d);
-      if(!acrv2d.IsNull())
-        isClosed = IsClosedByIsos(tmpsurf,acrv2d,f2d, l2d,Standard_False );
-      
-    }
-    return isClosed;
-  }
-  return IsUClosedSurface(tmpsurf,theEdge,theloc);
-  //return surf->IsUClosed();
-}
-
-//=======================================================================
-//function : IsVClosedSurface
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsVClosedSurface(const Handle(Geom_Surface)& surf,
-                                                   const TopoDS_Shape& theEdge,
-                                                   const TopLoc_Location& theloc) const
-{
-  Handle(Geom_Surface) tmpsurf = surf;
-  if(tmpsurf->IsKind(STANDARD_TYPE(Geom_RectangularTrimmedSurface))) 
-    tmpsurf = Handle(Geom_RectangularTrimmedSurface)::DownCast(surf)->BasisSurface();
-  else if(tmpsurf->IsKind(STANDARD_TYPE(Geom_OffsetSurface))) 
-    tmpsurf = Handle(Geom_OffsetSurface)::DownCast(surf)->BasisSurface();
-  else {
-    Standard_Boolean isClosed = tmpsurf->IsVClosed();
-    if(!isClosed) {
-      Standard_Real f2d, l2d;
-      Handle(Geom2d_Curve) acrv2d = BRep_Tool::CurveOnSurface(TopoDS::Edge(theEdge), surf,theloc, f2d, l2d);
-      if(!acrv2d.IsNull())
-        isClosed = IsClosedByIsos(tmpsurf,acrv2d,f2d, l2d,Standard_True );
-    }
-    return isClosed;
-  }
-  return IsVClosedSurface(tmpsurf,theEdge,theloc);
-  //return surf->IsVClosed();
-}
-
-//=======================================================================
-//function : SameParameter
-//purpose  : internal use
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::SameParameter(const TopoDS_Edge& edge) const
-{
-  try {
-    
-    BRepLib::SameParameter(edge);
-  }
-  catch (Standard_Failure) {
-#ifdef DEB
-    cout << "Exception in BRepBuilderAPI_Sewing::SameParameter: ";
-    Standard_Failure::Caught()->Print(cout); cout << endl;
-#endif
-  }
-}
-
-//=======================================================================
-//function : SameParameterEdge
-//purpose  : internal use
-//           Merge the Sequence Of Section on one edge.
-//           This function keep the curve3d,curve2d,range and parametrization
-//           from the first section, and report and made sameparameter the
-//           pcurves of the other function.
-//           This function works when the are not more than two Pcurves
-//           on a same face.
-//=======================================================================
-
-TopoDS_Edge BRepBuilderAPI_Sewing::SameParameterEdge(const TopoDS_Shape& edge,
-					       const TopTools_SequenceOfShape& seqEdges,
-					       const TColStd_SequenceOfInteger& seqForward,
-					       TopTools_MapOfShape& mapMerged,
-					       const Handle(BRepTools_ReShape)& locReShape)
-{
-  // Retrieve reference section
-  TopoDS_Shape aTmpShape = myReShape->Apply(edge); //for porting
-  TopoDS_Edge Edge1 = TopoDS::Edge(aTmpShape);
-  aTmpShape = locReShape->Apply(Edge1);
-  if (locReShape != myReShape) Edge1 = TopoDS::Edge(aTmpShape);
-  Standard_Boolean isDone = Standard_False;
-
-  // Create data structures for temporary merged edges
-  TopTools_ListOfShape listFaces1;
-  TopTools_MapOfShape MergedFaces;
-
-  if (mySewing) {
-
-    // Fill MergedFaces with faces of Edge1
-    TopoDS_Shape bnd1 = edge;
-    if (mySectionBound.IsBound(bnd1)) bnd1 = mySectionBound(bnd1);
-    if (myBoundFaces.Contains(bnd1)) {
-      TopTools_ListIteratorOfListOfShape itf(myBoundFaces.FindFromKey(bnd1));
-      for (; itf.More(); itf.Next())
-	if (MergedFaces.Add(itf.Value()))
-	  listFaces1.Append(itf.Value());
-    }
-  }
-  else {
-
-    // Create presentation edge
-    TopoDS_Vertex V1, V2;
-    TopExp::Vertices(Edge1,V1,V2);
-    if (myVertexNode.Contains(V1)) V1 = TopoDS::Vertex(myVertexNode.FindFromKey(V1));
-    if (myVertexNode.Contains(V2)) V2 = TopoDS::Vertex(myVertexNode.FindFromKey(V2));
-
-    TopoDS_Edge NewEdge = Edge1;
-    NewEdge.EmptyCopy();
-
-    // Add the vertices
-    BRep_Builder aBuilder;
-    TopoDS_Shape anEdge = NewEdge.Oriented(TopAbs_FORWARD);
-    aBuilder.Add(anEdge,V1.Oriented(TopAbs_FORWARD));
-    aBuilder.Add(anEdge,V2.Oriented(TopAbs_REVERSED));
-
-    Edge1 = NewEdge;
-  }
-
-  Standard_Boolean isForward = Standard_True;
-
-  // Merge candidate sections
-  for (Standard_Integer i = 1; i <= seqEdges.Length(); i++) {
-
-    // Retrieve candidate section
-    TopoDS_Shape oedge2 = seqEdges(i);
-
-    if (mySewing) {
-
-      aTmpShape = myReShape->Apply(oedge2); //for porting
-      TopoDS_Edge Edge2 = TopoDS::Edge(aTmpShape);
-      aTmpShape = locReShape->Apply(Edge2);
-      if (locReShape != myReShape) Edge2 = TopoDS::Edge(aTmpShape);
-
-      // Calculate relative orientation
-      Standard_Integer Orientation = seqForward(i);
-      if (!isForward) Orientation = (Orientation? 0 : 1);
-
-      // Retrieve faces information for the second edge
-      TopoDS_Shape bnd2 = oedge2;
-      if (mySectionBound.IsBound(bnd2)) bnd2 = mySectionBound(bnd2);
-      if (!myBoundFaces.Contains(bnd2)) continue; // Skip floating edge
-      const TopTools_ListOfShape& listFaces2 = myBoundFaces.FindFromKey(bnd2);
-
-      Standard_Integer whichSec = 1; // Indicates on which edge the pCurve has been reported
-      TopoDS_Edge NewEdge = SameParameterEdge(Edge1,Edge2,listFaces1,listFaces2,Orientation,whichSec);
-      if (NewEdge.IsNull()) continue;
-
-      // Record faces information for the temporary merged edge
-      TopTools_ListIteratorOfListOfShape itf(listFaces2);
-      for (; itf.More(); itf.Next())
-	if (MergedFaces.Add(itf.Value()))
-	  listFaces1.Append(itf.Value());
-
-      // Record merged section orientation
-      if (!Orientation && whichSec != 1)
-	isForward = isForward? Standard_False : Standard_True;
-      Edge1 = NewEdge;
-    }
-
-    // Append actually merged edge
-    mapMerged.Add(oedge2);
-    isDone = Standard_True;
-
-    if (!myNonmanifold) break;
-  }
-
-  if (isDone) {
-    // Change result orientation
-    Edge1.Orientation(isForward? TopAbs_FORWARD : TopAbs_REVERSED);
-  }
-  else Edge1.Nullify();
-
-  return Edge1;
-}
-
-//=======================================================================
-//function : SameParameterEdge
-//purpose  : internal use
-//=======================================================================
-static Standard_Boolean findNMVertices(const TopoDS_Edge& theEdge,
-                                       TopTools_SequenceOfShape& theSeqNMVert,
-                                       TColStd_SequenceOfReal& theSeqPars)
-{
-  TopoDS_Iterator aItV(theEdge,Standard_False);
-  for( ; aItV.More(); aItV.Next()) {
-    if(aItV.Value().Orientation() == TopAbs_INTERNAL || 
-        aItV.Value().Orientation() == TopAbs_EXTERNAL)
-    theSeqNMVert.Append(aItV.Value());
-  }
-  Standard_Integer nbV = theSeqNMVert.Length();
-  if(!nbV)
-    return Standard_False;
-  Standard_Real first, last;
-  Handle(Geom_Curve) c3d = BRep_Tool::Curve(theEdge,first, last);
-  GeomAdaptor_Curve GAC(c3d);
-  Extrema_ExtPC locProj;
-  locProj.Initialize(GAC, first, last);
-  gp_Pnt pfirst = GAC.Value(first), plast = GAC.Value(last);
-
-  
-  for (Standard_Integer i = 1; i <= nbV; i++) {
-    TopoDS_Vertex aV = TopoDS::Vertex(theSeqNMVert.Value(i));
-    gp_Pnt pt = BRep_Tool::Pnt(aV);
-    
-    Standard_Real distF = pfirst.Distance(pt);
-    Standard_Real distL = plast.Distance(pt);
-    Standard_Real apar = (distF > distL ? last : first);
-    Standard_Boolean isProjected = Standard_False;
-    // Project current point on curve
-    locProj.Perform(pt);
-    if (locProj.IsDone() && locProj.NbExt() > 0) {
-	  Standard_Real distMin = Min(distF,distL);
-	  Standard_Integer ind, indMin = 0;
-	  for (ind = 1; ind <= locProj.NbExt(); ind++) {
-	    Standard_Real dProj = locProj.Value(ind);
-	    if (dProj < distMin) { 
-          indMin = ind; distMin = dProj; 
-        }
-      }
-      if(indMin) 
-        apar = locProj.Point(indMin).Parameter();
-         
-      theSeqPars.Append(apar);  
-        
-    }
-  }
-  return Standard_True;
-}
-
-static Standard_Real ComputeToleranceVertex(Standard_Real dist, Standard_Real Tol1, Standard_Real Tol2)
-{
-  Standard_Real resTol =0;
-  if((dist + Tol1) <= Tol2)
-    resTol = Tol2;
-  else if((dist + Tol2) <= Tol1)
-    resTol = Tol1;
-  else 
-    resTol =(dist + Tol1 + Tol2)*0.5;
-  return resTol;
-  
-}
-TopoDS_Edge BRepBuilderAPI_Sewing::SameParameterEdge(const TopoDS_Edge& edgeFirst,
-					       const TopoDS_Edge& edgeLast,
-					       const TopTools_ListOfShape& listFacesFirst,
-					       const TopTools_ListOfShape& listFacesLast,
-					       const Standard_Boolean secForward, 
-					       Standard_Integer& whichSec,
-					       const Standard_Boolean firstCall)
-{
-  // Do not process floating edges
-  if (!listFacesFirst.Extent() || !listFacesLast.Extent()) return TopoDS_Edge();
-
-  // Sort input edges
-  TopoDS_Edge edge1, edge2;
-  if (firstCall) {
-    // Take the longest edge as first
-    Standard_Real f, l;
-    Handle(Geom_Curve) c3d1 = BRep_Tool::Curve(TopoDS::Edge(edgeFirst), f, l);
-    GeomAdaptor_Curve cAdapt1(c3d1);
-    Standard_Real len1 = GCPnts_AbscissaPoint::Length(cAdapt1, f, l);
-    Handle(Geom_Curve) c3d2 = BRep_Tool::Curve(TopoDS::Edge(edgeLast), f, l);
-    GeomAdaptor_Curve cAdapt2(c3d2);
-    Standard_Real len2 = GCPnts_AbscissaPoint::Length(cAdapt2, f, l);
-    if (len1 < len2) {
-      edge1 = edgeLast;
-      edge2 = edgeFirst;
-      whichSec = 2;
-    }
-    else {
-      edge1 = edgeFirst;
-      edge2 = edgeLast;
-      whichSec = 1;
-    }
-  }
-  else {
-    if (whichSec == 1) {
-      edge1 = edgeLast;
-      edge2 = edgeFirst;
-      whichSec = 2;
-    }
-    else {
-      edge1 = edgeFirst;
-      edge2 = edgeLast;
-      whichSec = 1;
-    }
-  }
-
-  Standard_Real first, last;
-  BRep_Tool::Range(edge1, first, last);
-  BRep_Builder aBuilder;
-
-  //To keep NM vertices on edge
-  TopTools_SequenceOfShape aSeqNMVert;
-  TColStd_SequenceOfReal aSeqNMPars;
-  findNMVertices(edge1,aSeqNMVert,aSeqNMPars);
-  findNMVertices(edge2,aSeqNMVert,aSeqNMPars);
-
-  // Create new edge
-  TopoDS_Edge edge;
-  aBuilder.MakeEdge(edge);
-  edge.Orientation( edge1.Orientation());
- 
-
-  // Retrieve edge curve
-  TopLoc_Location loc3d;
-  Standard_Real first3d, last3d;
-  Handle(Geom_Curve) c3d = BRep_Tool::Curve(edge1, loc3d, first3d, last3d);
-  if (!loc3d.IsIdentity()) {
-    c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-    c3d->Transform(loc3d.Transformation());
-  }
-  aBuilder.UpdateEdge(edge,c3d,BRep_Tool::Tolerance(edge1));
-  aBuilder.Range(edge, first, last);
-  aBuilder.SameRange(edge, Standard_False); //Standard_True
-  aBuilder.SameParameter(edge, Standard_False);
-  // Create and add new vertices
-  {
-    TopoDS_Vertex V1New, V2New;
-
-    // Retrieve original vertices from edges
-    TopoDS_Vertex V11,V12,V21,V22;
-    TopExp::Vertices(edge1,V11,V12);
-    TopExp::Vertices(edge2,V21,V22);
-
-    //szv: do not reshape here!!!
-    //V11 = TopoDS::Vertex(myReShape->Apply(V11));
-    //V12 = TopoDS::Vertex(myReShape->Apply(V12));
-    //V21 = TopoDS::Vertex(myReShape->Apply(V21));
-    //V22 = TopoDS::Vertex(myReShape->Apply(V22));
-
-    gp_Pnt p11 = BRep_Tool::Pnt(V11);
-    gp_Pnt p12 = BRep_Tool::Pnt(V12);
-    gp_Pnt p21 = BRep_Tool::Pnt(V21); 
-    gp_Pnt p22 = BRep_Tool::Pnt(V22);
-
-    // Check if edges are closed
-    Standard_Boolean isClosed1 = V11.IsSame(V12);
-    Standard_Boolean isClosed2 = V21.IsSame(V22);
-
-    //Standard_Boolean isRev = Standard_False;
-    gp_Pnt pfirst;
-    Standard_Real Tol1 = 0.;
-    if (isClosed1 || isClosed2) {
-      // at least one of the edges is closed
-      if (isClosed1 && isClosed2) {
-	// both edges are closed
-	pfirst.SetXYZ(0.5*(p11.XYZ() + p21.XYZ()));
-        gp_Vec v1 =  p21.XYZ() - p11.XYZ();
-        Standard_Real d1 = v1.Magnitude();
-        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21));
-	//Tol1 = Max(pfirst.Distance(p11),pfirst.Distance(p21));
-      }
-      else if (isClosed1) {
-	// only first edge is closed
-        gp_XYZ pt =0.5*(p21.XYZ()+ p22.XYZ());
-  	    pfirst.SetXYZ(0.5*(p11.XYZ() + pt));
-        gp_Vec v1 =  p22.XYZ() - p21.XYZ();
-        Standard_Real d1 = v1.Magnitude();
-        Tol1= ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V22),BRep_Tool::Tolerance(V21));
-        gp_Vec v2 =  p11.XYZ() - pt;
-        Standard_Real d2 = v2.Magnitude();
-        Tol1= ComputeToleranceVertex(d2,Tol1,BRep_Tool::Tolerance(V11));
-	//Tol1 = Max(pfirst.Distance(p21),pfirst.Distance(p22));
-	//Tol1 = Max(pfirst.Distance(p11),Tol1);
-      }
-      else {
-	// only second edge is closed
-        gp_XYZ pt = 0.5*(p11.XYZ()+ p12.XYZ());
-	    pfirst.SetXYZ(0.5*(p21.XYZ() + pt));
-        gp_Vec v1 =  p11.XYZ() - p12.XYZ();
-        Standard_Real d1 = v1.Magnitude();
-        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V12));
-        gp_Vec v2 =  p21.XYZ() - pt;
-        Standard_Real d2 = v2.Magnitude();
-        Tol1 = ComputeToleranceVertex(d2,Tol1,BRep_Tool::Tolerance(V21));
-	//Tol1 = Max(pfirst.Distance(p11),pfirst.Distance(p12));
-	//Tol1 = Max(pfirst.Distance(p21),Tol1);
-      }
-      aBuilder.MakeVertex(V1New,pfirst,Tol1);
-      V2New = V1New;
-    }
-    else {
-      // both edges are open
-      gp_Pnt plast;
-      Standard_Real Tol2 = 0.;
-      if (secForward) {
-	    pfirst.SetXYZ(0.5*(p11.XYZ() + p21.XYZ()));
-	    plast.SetXYZ(0.5*(p12.XYZ() + p22.XYZ()));
-        gp_Vec v1 =  p21.XYZ() - p11.XYZ();
-        Standard_Real d1 = v1.Magnitude();
-        gp_Vec v2 =  p22.XYZ() - p12.XYZ();
-        Standard_Real d2 = v2.Magnitude();
-        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21));
-        Tol2 = ComputeToleranceVertex(d2,BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V22));
-
-//	Tol1 = Max(Max(pfirst.Distance(p11),pfirst.Distance(p21)),
-//		   Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21)));
-//	Tol2 = Max(Max(plast.Distance(p12),plast.Distance(p22)),
-//		   Max(BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V22)));
-      }
-      else {
-	    pfirst.SetXYZ(0.5*(p11.XYZ() + p22.XYZ()));
-	    plast.SetXYZ(0.5*(p12.XYZ() + p21.XYZ()));
-        
-        gp_Vec v1 =  p22.XYZ() - p11.XYZ();
-        Standard_Real d1 = v1.Magnitude();
-        gp_Vec v2 =  p21.XYZ() - p12.XYZ();
-        Standard_Real d2 = v2.Magnitude();
-        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22));
-        Tol2 = ComputeToleranceVertex(d2,BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V21));
-//        Tol1 = Max(Max(pfirst.Distance(p11),pfirst.Distance(p22)),
-//		   Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22)));
-//	Tol2 = Max(Max(plast.Distance(p12),plast.Distance(p21)),
-//		   Max(BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V21)));
-      }
-      //gp_Pnt pcu;
-      ///c3d->D0(first3d,pcu);
-      //Tol1 = Max(pfirst.Distance(pcu) + Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22));
-      aBuilder.MakeVertex(V1New,pfirst,Tol1);
-      //c3d->D0(last3d,pcu);
-      //Tol2 = plast.Distance(pcu);
-      aBuilder.MakeVertex(V2New,plast,Tol2);
-    }
-
-    // Add the vertices in the good sense
-    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
-    TopoDS_Shape aLocalEdge = V1New.Oriented(TopAbs_FORWARD); //(listNode.First()).Oriented(TopAbs_FORWARD);
-    aBuilder.Add(anEdge,aLocalEdge);
-    aLocalEdge = V2New.Oriented(TopAbs_REVERSED); //(listNode.Last()).Oriented(TopAbs_REVERSED);
-    aBuilder.Add(anEdge,aLocalEdge);
-
-    Standard_Integer k =1;
-    for( ; k <= aSeqNMVert.Length(); k++)
-      aBuilder.Add(anEdge,aSeqNMVert.Value(k));
-
-  }
-
-  // Retrieve second PCurves
-  TopLoc_Location loc2;
-  Handle(Geom_Surface) surf2;
-  //Handle(Geom2d_Curve) c2d2, c2d21;
-  //  Standard_Real firstOld, lastOld;
-
-  TopTools_ListIteratorOfListOfShape itf2;
-  if (whichSec == 1) itf2.Initialize(listFacesLast);
-  else               itf2.Initialize(listFacesFirst);
-  Standard_Boolean isResEdge = Standard_False;
-  for (; itf2.More(); itf2.Next()) {
-    Handle(Geom2d_Curve) c2d2, c2d21;
-    Standard_Real firstOld, lastOld;
-    const TopoDS_Face& fac2 = TopoDS::Face(itf2.Value());
-
-    surf2 = BRep_Tool::Surface(fac2, loc2);
-    Standard_Boolean isSeam2 = ((IsUClosedSurface(surf2,edge2,loc2) || IsVClosedSurface(surf2,edge2,loc2)) &&
-				BRep_Tool::IsClosed(TopoDS::Edge(edge2),fac2));
-    if (isSeam2) {
-      if (!myNonmanifold) return TopoDS_Edge();
-      TopoDS_Shape aTmpShape = edge2.Reversed(); //for porting
-      c2d21 = BRep_Tool::CurveOnSurface(TopoDS::Edge(aTmpShape), fac2, firstOld, lastOld);
-    }
-    c2d2 = BRep_Tool::CurveOnSurface(edge2, fac2, firstOld, lastOld);
-    if (c2d2.IsNull() && c2d21.IsNull()) continue;
-
-    if (!c2d21.IsNull()) {
-      c2d21 = Handle(Geom2d_Curve)::DownCast(c2d21->Copy());
-      if (!secForward) {
-	if (c2d21->IsKind(STANDARD_TYPE(Geom2d_Line)))
-	  c2d21 = new Geom2d_TrimmedCurve(c2d21, firstOld, lastOld);
-	Standard_Real first2d = firstOld; //c2dTmp->FirstParameter(); BUG USA60321
-	Standard_Real last2d = lastOld;   //c2dTmp->LastParameter();
-	firstOld = c2d21->ReversedParameter(last2d);
-	lastOld = c2d21->ReversedParameter(first2d);
-	c2d21->Reverse();
-      }
-      c2d21 = SameRange(c2d21,firstOld,lastOld,first,last);
-    }
-
-    // Make second PCurve sameRange with the 3d curve
-    c2d2 = Handle(Geom2d_Curve)::DownCast(c2d2->Copy());
-
-    if (!secForward) {
-      if (c2d2->IsKind(STANDARD_TYPE(Geom2d_Line)))
-	c2d2 = new Geom2d_TrimmedCurve(c2d2, firstOld, lastOld);
-      Standard_Real first2d = firstOld; //c2dTmp->FirstParameter(); BUG USA60321
-      Standard_Real last2d = lastOld;   //c2dTmp->LastParameter();
-      firstOld = c2d2->ReversedParameter(last2d);
-      lastOld = c2d2->ReversedParameter(first2d);
-      c2d2->Reverse();
-    }
-
-    c2d2 = SameRange(c2d2,firstOld,lastOld,first,last);
-    if (c2d2.IsNull()) continue;
-    
-    // Add second PCurve
-    Standard_Boolean isSeam = Standard_False;
-    TopAbs_Orientation Ori = TopAbs_FORWARD;
-    //Handle(Geom2d_Curve) c2d1, c2d11;
-
-    TopTools_ListIteratorOfListOfShape itf1;
-    if (whichSec == 1) itf1.Initialize(listFacesFirst);
-    else               itf1.Initialize(listFacesLast);
-    for (; itf1.More() && !isSeam; itf1.Next()) {
-      Handle(Geom2d_Curve) c2d1, c2d11;
-      const TopoDS_Face& fac1 = TopoDS::Face(itf1.Value());
-
-      TopLoc_Location loc1;
-      Handle(Geom_Surface) surf1 = BRep_Tool::Surface(fac1, loc1);
-      Standard_Real first2d, last2d;
-      Standard_Boolean isSeam1 = ((IsUClosedSurface(surf1,edge1,loc1) || IsVClosedSurface(surf1,edge1,loc1)) &&
-				  BRep_Tool::IsClosed(TopoDS::Edge(edge1),fac1));
-      c2d1 = BRep_Tool::CurveOnSurface(edge1, fac1, first2d, last2d);
-      Ori = edge1.Orientation();
-      if (fac1.Orientation() == TopAbs_REVERSED) 
-        Ori = TopAbs::Reverse(Ori);
-      
-      if (isSeam1) {
-	if (!myNonmanifold) return TopoDS_Edge();
-        TopoDS_Shape aTmpShape = edge1.Reversed(); //for porting
-        c2d11 = BRep_Tool::CurveOnSurface(TopoDS::Edge(aTmpShape), fac1, first2d, last2d);
-        //if(fac1.Orientation() == TopAbs_REVERSED) //
-        if(Ori == TopAbs_FORWARD)
-          aBuilder.UpdateEdge(edge,c2d1,c2d11,fac1,0);
-        else
-          aBuilder.UpdateEdge(edge,c2d11,c2d1,fac1,0);
-      }
-      else  aBuilder.UpdateEdge(edge,c2d1,fac1,0);
-      
-      if (c2d1.IsNull() && c2d11.IsNull()) continue;
-
-      //Ori = edge1.Orientation();
-      //if (fac1.Orientation() == TopAbs_REVERSED) TopAbs::Reverse(Ori);
-
-      if (surf2 == surf1) {
-	// Merge sections which are on the same face
-	if (!loc2.IsDifferent(loc1)) {
-	  Standard_Boolean uclosed = IsUClosedSurface(surf2,edge2,loc2);
-	  Standard_Boolean vclosed = IsVClosedSurface(surf2,edge2,loc2);
-	  if (uclosed || vclosed) {
-	    Standard_Real pf = c2d1->FirstParameter();
-//	    Standard_Real pl = c2d1->LastParameter();
-	    gp_Pnt2d p1n = c2d1->Value(Max(first,pf));
-//	    gp_Pnt2d p2n = c2d1->Value(Min(pl,last));
-            gp_Pnt2d p21n = c2d2->Value(Max(first,c2d2->FirstParameter()));
-            gp_Pnt2d p22n = c2d2->Value(Min(last,c2d2->LastParameter()));
-            Standard_Real aDist = Min(p1n.Distance(p21n), p1n.Distance(p22n));
-	    Standard_Real U1, U2, V1, V2;
-	    surf2->Bounds(U1, U2, V1, V2);
-	    isSeam = ((uclosed && aDist > 0.75*(fabs(U2-U1))) ||
-		      (vclosed && aDist > 0.75*(fabs(V2-V1))));
-            if( !isSeam && BRep_Tool::IsClosed(TopoDS::Edge(edge),fac1)) continue;
-	  }
-	}
-      }
-     
-      isResEdge = Standard_True;
-      if (isSeam) {
-        if (Ori == TopAbs_FORWARD)
-          aBuilder.UpdateEdge(edge, c2d1, c2d2, surf2, loc2, Precision::Confusion());
-        else
-          aBuilder.UpdateEdge(edge, c2d2, c2d1, surf2, loc2, Precision::Confusion());
-      }
-      else if (isSeam2) {
-        TopAbs_Orientation InitOri  = edge2.Orientation();
-         TopAbs_Orientation SecOri  = edge.Orientation();
-        if (fac2.Orientation() == TopAbs_REVERSED) {
-          
-          InitOri = TopAbs::Reverse(InitOri);
-          SecOri = TopAbs::Reverse(SecOri);
-        }
-        if(!secForward)
-          InitOri = TopAbs::Reverse(InitOri);
-        
-        if (InitOri == TopAbs_FORWARD)
-          aBuilder.UpdateEdge(edge, c2d2,c2d21, surf2, loc2, Precision::Confusion());
-        else
-          aBuilder.UpdateEdge(edge, c2d21,c2d2, surf2, loc2, Precision::Confusion());
-      } 
-      else {
-        aBuilder.UpdateEdge(edge, c2d2, surf2, loc2, Precision::Confusion());
-      }
-      
-    }
-  }
-  if(isResEdge)
-  // Try to make the edge sameparameter
-    SameParameter(edge);
-
-  //  Standard_Real tolReached = BRep_Tool::Tolerance(edge);
-  //if (!BRep_Tool::SameParameter(edge)) return edge; //gka ????????
-
-  if (firstCall && (!BRep_Tool::SameParameter(edge) || !isResEdge)) {
-    Standard_Integer whichSecn = whichSec;
-    // Try to merge on the second section
-    Standard_Boolean second_ok = Standard_True;
-    TopoDS_Edge s_edge = SameParameterEdge(edgeFirst,edgeLast,listFacesFirst,listFacesLast,
-					   secForward,whichSecn,Standard_False);
-    //if (s_edge.IsNull()) return s_edge; // gka version for free edges
-    if (s_edge.IsNull()) second_ok = Standard_False;
-    else if (!BRep_Tool::SameParameter(s_edge)) second_ok = Standard_False;
-    else {
-      edge = s_edge;
-      whichSec = whichSecn;
-    }
-
-    if (!second_ok) {
-
-      GeomAdaptor_Curve c3dAdapt(c3d);
-
-      // Discretize edge curve
-      Standard_Integer i, j, nbp = 15;
-      Standard_Real deltaT = (last3d - first3d) / (nbp + 1);
-      TColgp_Array1OfPnt c3dpnt(1,nbp);
-      for (i = 1; i <= nbp; i++) c3dpnt(i) = c3dAdapt.Value(first3d + i*deltaT);
-
-      Standard_Real u, v, dist, maxTol = -1.0;
-      Standard_Boolean more = Standard_True;
-
-      for (j = 1; more; j++) {
-        Handle(Geom2d_Curve) c2d2;
-	BRep_Tool::CurveOnSurface(edge, c2d2, surf2, loc2, first, last, j);
-	more = !c2d2.IsNull();
-	if (more) {
-
-	  deltaT = (last - first) / (nbp + 1);
-	  for (i = 1; i <= nbp; i++) {
-	    c2d2->Value(first + i*deltaT).Coord(u,v);
-	    dist = surf2->Value(u,v).Distance(c3dpnt(i));
-	    if (dist > maxTol) maxTol = dist;
-	  }
-	}
-      }
-
-      if (maxTol >= 0.) aBuilder.UpdateEdge(edge, maxTol);
-      aBuilder.SameParameter(edge,Standard_True);
-    }
-  }
-
-  BRepLib::EncodeRegularity(edge,0.01);
-  Standard_Real tolEdge1 = BRep_Tool::Tolerance(edge);
-  if (tolEdge1 > MaxTolerance()) edge.Nullify();
-  return edge;
-}
-
-//=======================================================================
-// function : EvaluateAngulars
-// purpose  : internal use
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::EvaluateAngulars(TopTools_SequenceOfShape& sequenceSec,
-				       TColStd_Array1OfBoolean& secForward,
-				       TColStd_Array1OfReal& tabAng,
-				       const Standard_Integer indRef) const
-{
-  tabAng.Init(-1.0);
-
-  Standard_Integer i, j, npt = 4, lengSec = sequenceSec.Length();
-
-  TopoDS_Edge edge;
-  TopoDS_Face face;
-  TopLoc_Location loc;
-  Standard_Real first, last;
-  Handle(Geom_Curve) c3d;
-  Handle(Geom2d_Curve) c2d;
-  Handle(Geom_Surface) surf;
-  TColgp_Array1OfVec normRef(1,npt);
-
-  for (i = indRef; i <= lengSec; i++) {
-
-    edge = TopoDS::Edge(sequenceSec(i));
-
-    TopoDS_Shape bnd = edge;
-    if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
-    if (myBoundFaces.Contains(bnd)) {
-      face = TopoDS::Face(myBoundFaces.FindFromKey(bnd).First());
-      surf = BRep_Tool::Surface(face,loc);
-      if (!loc.IsIdentity()) {
-	surf = Handle(Geom_Surface)::DownCast(surf->Copy());
-	surf->Transform(loc.Transformation());
-      }
-      c2d = BRep_Tool::CurveOnSurface(edge, face, first, last);
-    }
-    else if (i == indRef) return;
-    else continue;
-
-    c3d = BRep_Tool::Curve(edge, loc, first, last);
-    if (!loc.IsIdentity()) {
-      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-      c3d->Transform(loc.Transformation());
-    }
-
-    GeomAdaptor_Curve adapt(c3d);
-    GCPnts_UniformAbscissa uniAbs(adapt, npt, first, last);
-
-    Standard_Real cumulateAngular = 0.0;
-    Standard_Integer nbComputedAngle = 0;
-
-    for (j = 1; j <= npt; j++) {
-      gp_Pnt2d P;
-      c2d->D0(uniAbs.Parameter((secForward(i) || i == indRef)? j : npt-j+1),P);
-      gp_Vec w1, w2;
-      gp_Pnt unused;
-      surf->D1(P.X(), P.Y(), unused, w1, w2);
-      gp_Vec n = w1^w2; // Compute the normal vector
-      if (i == indRef) normRef(j) = n;
-      else if ((n.Magnitude()>gp::Resolution()) && (normRef(j).Magnitude()>gp::Resolution())) {
-	nbComputedAngle++;
-	Standard_Real angular = n.Angle(normRef(j));
-	if (angular > PI/2.) angular = PI - angular;
-	cumulateAngular += angular;
-      }
-    }
-
-    if (nbComputedAngle)
-      tabAng(i) = cumulateAngular/((Standard_Real)nbComputedAngle);
-  }
-}
-
-//=======================================================================
-// function : EvaluateDistances
-// purpose  : internal use
-// Evaluate distance beetween edges with indice indRef and the following edges in the list
-// Remarks (lengSec - indRef) must be >= 1 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::EvaluateDistances(TopTools_SequenceOfShape& sequenceSec,
-					TColStd_Array1OfBoolean& secForward,
-					TColStd_Array1OfReal& tabDst,
-					const Standard_Integer indRef) const
-{
-  tabDst.Init(-1.0);
-
-  const Standard_Integer npt = 8; // Number of points for curve discretization
-  TColgp_Array1OfPnt ptsRef(1, npt), ptsSec(1, npt);
-
-  Standard_Integer i, j, lengSec = sequenceSec.Length();
-  TColgp_SequenceOfPnt seqSec;
-
-  Handle(Geom_Curve) c3dRef;
-  Standard_Real firstRef=0., lastRef=0.;
-
-  for (i = indRef; i <= lengSec; i++) {
-
-    // reading of the edge (attention for the first one: reference)
-    const TopoDS_Edge& sec = TopoDS::Edge(sequenceSec(i));
-
-    TopLoc_Location loc;
-    Standard_Real first, last;
-    Handle(Geom_Curve) c3d = BRep_Tool::Curve(sec, loc, first, last);
-    if (!loc.IsIdentity()) {
-      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-      c3d->Transform(loc.Transformation());
-    }
-
-    if (i == indRef) {
-      c3dRef = c3d; firstRef = first; lastRef = last;
-    }
-
-    Standard_Real dist, distFor = -1.0, distRev = -1.0;
-
-    Standard_Real T, deltaT = (last - first) / (npt - 1);
-    for (j = 1; j <= npt; j++) {
-
-      // Uniform parameter on curve
-      if (j == 1) T = first;
-      else if (j == npt) T = last;
-      else T = first + (j - 1) * deltaT;
-
-      // Take point on curve
-      gp_Pnt pt = c3d->Value(T);
-
-      if (i == indRef) {
-	ptsRef(j) = pt;
-      }
-      else {
-	ptsSec(j) = pt;
-	// To evaluate mutual orientation and distance
-	dist = pt.Distance(ptsRef(j));
-	if (distFor < dist) distFor = dist;
-	dist = pt.Distance(ptsRef(npt-j+1));
-	if (distRev < dist) distRev = dist;
-      }
-    }
-
-    // Record mutual orientation
-    Standard_Boolean isForward = (distFor < distRev); //szv debug: <=
-    secForward(i) = isForward;
-
-    dist = (isForward? distFor : distRev);
-    if (dist < /*Precision::Confusion()*/ myTolerance) {
-      // Section is close - record distance
-      tabDst(i) = dist;
-    }
-    else {
-      // Section is distant - record points
-      for (j = 1; j <= npt; j++) seqSec.Append(ptsSec(j));
-    }
-  }
-
-  // Project distant points
-  Standard_Integer nbFailed = seqSec.Length();
-  if (!nbFailed) return;
-
-  TColgp_Array1OfPnt arrPnt(1, nbFailed), arrProj(1, nbFailed);
-  for (i = 1; i <= nbFailed; i++) arrPnt(i) = seqSec(i); seqSec.Clear();
-  TColStd_Array1OfReal arrDist(1, nbFailed), arrPara(1, nbFailed);
-
-  ProjectPointsOnCurve(arrPnt,c3dRef,firstRef,lastRef,arrDist,arrPara,arrProj);
-
-  // Process distant sections
-  Standard_Integer idx1 = 1;
-  for (i = indRef + 1; i <= lengSec; i++) {
-
-    // Skip section if already evaluated
-    if (tabDst(i) >= 0.0) continue;
-
-    Standard_Real dist, distMax = -1.0;
-
-    Standard_Integer idx2 = (idx1 - 1)*npt;
-
-    for (j = 1; j <= npt; j++) {
-
-      dist = arrDist(idx2 + j);
-      // If point is not projected - stop evaluation
-      if (dist < 0.0) { distMax = -1.0; break; }
-      if (distMax < dist) distMax = dist;
-    }
-
-    // If section is close - record distance
-    if (distMax >= 0.0) {
-      if (secForward(i)) {
-	dist = arrPnt(idx2+1).Distance(ptsRef(1));
-	if (distMax < dist) distMax = dist;
-	dist = arrPnt(idx2+npt).Distance(ptsRef(npt));
-	if (distMax < dist) distMax = dist;
-      }
-      else {
-	dist = arrPnt(idx2+1).Distance(ptsRef(npt));
-	if (distMax < dist) distMax = dist;
-	dist = arrPnt(idx2+npt).Distance(ptsRef(1));
-	if (distMax < dist) distMax = dist;
-      }
-
-      if (distMax < myTolerance) tabDst(i) = distMax;
-    }
-
-    idx1++; // To the next distant curve
-  }
-}
-
-//=======================================================================
-//function : IsMergedClosed
-//purpose  :  internal use
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsMergedClosed(const TopoDS_Edge& Edge1,
-						 const TopoDS_Edge& Edge2,
-						 const TopoDS_Face& face) const
-{
-  // Check for closed surface
-  TopLoc_Location loc;
-  Handle(Geom_Surface) surf = BRep_Tool::Surface(face,loc);
-  Standard_Boolean isUClosed = IsUClosedSurface(surf,Edge1,loc);
-  Standard_Boolean isVClosed = IsVClosedSurface(surf,Edge1,loc);
-  if (!isUClosed && !isVClosed) return Standard_False;
-  // Check condition on closed surface
-  /*
-  Standard_Real first1,last1,first2,last2;
-  Handle(Geom_Curve) C3d1 = BRep_Tool::Curve(Edge1,first1,last1);
-  Handle(Geom_Curve) C3d2 = BRep_Tool::Curve(Edge2,first2,last2);
-  if (C3d1.IsNull() || C3d2.IsNull()) return Standard_False;
-  */
-  Standard_Real first2d1,last2d1,first2d2,last2d2;
-  Handle(Geom2d_Curve) C2d1 = BRep_Tool::CurveOnSurface(Edge1,face,first2d1,last2d1);
-  Handle(Geom2d_Curve) C2d2 = BRep_Tool::CurveOnSurface(Edge2,face,first2d2,last2d2);
-  if (C2d1.IsNull() || C2d2.IsNull()) return Standard_False;
-  /*
-  gp_Pnt p1 = C3d1->Value(0.5*(first1 + last1));
-  gp_Pnt p2 = C3d1->Value(0.5*(first2 + last2));
-  Standard_Real dist = p1.Distance(p2);
-  gp_Pnt2d p12d = C2d1->Value(0.5*(first2d1 + last2d1));
-  gp_Pnt2d p22d = C2d1->Value(0.5*(first2d2 + last2d2));
-  Standard_Real dist2d = p12d.Distance(p22d);
-  GeomAdaptor_Surface Ads(BRep_Tool::Surface(face));
-  Standard_Real distSurf = Max(Ads.UResolution(dist), Ads.VResolution(dist));
-  return (dist2d*0.2 >= distSurf);
-  */
-  Standard_Integer isULongC1, isULongC2, isVLongC1, isVLongC2;
-  Standard_Real SUmin, SUmax, SVmin, SVmax;
-  Standard_Real C1Umin, C1Vmin, C1Umax, C1Vmax;
-  Standard_Real C2Umin, C2Vmin, C2Umax, C2Vmax;
-  { //szv: Use brackets to destroy local variables
-    Bnd_Box2d B1, B2;
-    Geom2dAdaptor_Curve aC2d1(C2d1), aC2d2(C2d2);
-    BndLib_Add2dCurve::Add(aC2d1,first2d1,last2d1,Precision::PConfusion(),B1);
-    BndLib_Add2dCurve::Add(aC2d2,first2d2,last2d2,Precision::PConfusion(),B2);
-    B1.Get(C1Umin,C1Vmin,C1Umax,C1Vmax);
-    B2.Get(C2Umin,C2Vmin,C2Umax,C2Vmax);
-    Standard_Real du, dv;
-    du = (C1Umax - C1Umin); dv = (C1Vmax - C1Vmin);
-    isULongC1 = (dv <= du); isVLongC1 = (du <= dv);
-    du = (C2Umax - C2Umin); dv = (C2Vmax - C2Vmin);
-    isULongC2 = (dv <= du); isVLongC2 = (du <= dv);
-    surf->Bounds(SUmin,SUmax,SVmin,SVmax);
-  }
-  if (isUClosed && isVLongC1 && isVLongC2) {
-    // Do not merge if not overlapped by V
-    Standard_Real dist = Max((C2Vmin - C1Vmax),(C1Vmin - C2Vmax));
-    if (dist < 0.0) {
-      Standard_Real distInner = Max((C2Umin - C1Umax),(C1Umin - C2Umax));
-      Standard_Real distOuter = (SUmax - SUmin) - Max((C2Umax - C1Umin),(C1Umax - C2Umin));
-      if (distOuter <= distInner) return Standard_True;
-    }
-  }
-  if (isVClosed && isULongC1 && isULongC2) {
-    // Do not merge if not overlapped by U
-    Standard_Real dist = Max((C2Umin - C1Umax),(C1Umin - C2Umax));
-    if (dist < 0.0) {
-      Standard_Real distInner = Max((C2Vmin - C1Vmax),(C1Vmin - C2Vmax));
-      Standard_Real distOuter = (SVmax - SVmin) - Max((C2Vmax - C1Vmin),(C1Vmax - C2Vmin));
-      if (distOuter <= distInner) return Standard_True;
-    }
-  }
-  return Standard_False;
-}
-
-//=======================================================================
-//function : AnalysisNearestEdges
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::AnalysisNearestEdges(const TopTools_SequenceOfShape& sequenceSec,
-                                           TColStd_SequenceOfInteger& seqIndCandidate,
-                                           TColStd_SequenceOfInteger& seqOrientations,
-                                           const Standard_Boolean evalDist)
-{
-  
-  Standard_Integer workIndex = seqIndCandidate.First();
-  TopoDS_Shape workedge = sequenceSec.Value(workIndex);
-  TopoDS_Shape bnd = workedge;
-  TopTools_ListOfShape workfaces;
-  if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
-  if (myBoundFaces.Contains(bnd)) 
-    workfaces = myBoundFaces.FindFromKey(bnd);
-  if(workfaces.IsEmpty()) return;
-  TopTools_MapOfShape mapFaces;
-  TopTools_ListIteratorOfListOfShape lIt;
-  for (lIt.Initialize(workfaces); lIt.More(); lIt.Next())
-    mapFaces.Add(lIt.Value());
-  TColStd_SequenceOfInteger seqNotCandidate;
-  TColStd_SequenceOfInteger seqNewForward;
-  // Separates edges belonging the same face as work edge 
-  // for exception of edges belonging closed faces 
-  
-  seqNotCandidate.Append(workIndex);
-  for(Standard_Integer i = 1; i<= seqIndCandidate.Length(); ) {
-    Standard_Integer index = seqIndCandidate.Value(i);
-    Standard_Boolean isRemove = Standard_False;
-    if(index == workIndex) {
-      seqIndCandidate.Remove(i);
-      seqOrientations.Remove(i);
-      isRemove = Standard_True;
-    }
-    if(!isRemove) {
-      TopoDS_Shape bnd2 = sequenceSec.Value(index);
-      if (mySectionBound.IsBound(bnd2)) bnd2 = mySectionBound(bnd2);
-    
-      if(myBoundFaces.Contains(bnd2)) {
-        const TopTools_ListOfShape& listfaces = myBoundFaces.FindFromKey(bnd2);
-        Standard_Boolean isMerged = Standard_True;
-        for (lIt.Initialize(listfaces); lIt.More() && isMerged; lIt.Next()) {
-          if(mapFaces.Contains(lIt.Value())) {
-            TopLoc_Location loc;
-            Handle(Geom_Surface) surf = BRep_Tool::Surface(TopoDS::Face(lIt.Value()),loc);
-            isMerged = ((IsUClosedSurface(surf,bnd2,loc) ||  IsVClosedSurface(surf,bnd2,loc)) && 
-                        IsMergedClosed(TopoDS::Edge(sequenceSec.Value(index)),TopoDS::Edge(workedge),TopoDS::Face(lIt.Value())));
-          }
-        }
-        if(!isMerged) {
-          seqNotCandidate.Append(index);
-          seqIndCandidate.Remove(i);
-          seqOrientations.Remove(i);
-          isRemove = Standard_True;
-        }
-      }
-      else {
-        seqIndCandidate.Remove(i);
-        seqOrientations.Remove(i);
-        isRemove = Standard_True;
-      }
-    }
-    if(!isRemove) i++;  
-  }
-  if(seqIndCandidate.Length() == 0 || seqNotCandidate.Length() == 1) return;
-  if(!evalDist) return;
-  TColStd_Array2OfReal TotTabDist(1,seqNotCandidate.Length(),1,seqIndCandidate.Length());
-  TColStd_MapOfInteger MapIndex;
-  TColStd_SequenceOfInteger seqForward;
-  
-  // Definition and removing edges wich are not candidate for work edge 
-  // ( they have other nearest edges belonging to the work face) 
-  for(Standard_Integer k = 1; k<= seqNotCandidate.Length(); k++) {
-    Standard_Integer index1 = seqNotCandidate.Value(k);
-    TopoDS_Shape edge = sequenceSec.Value(index1);
-    TopTools_SequenceOfShape tmpSeq;
-    tmpSeq.Append(edge);
-    for(Standard_Integer kk = 1; kk <= seqIndCandidate.Length();kk++) 
-      tmpSeq.Append(sequenceSec.Value(seqIndCandidate.Value(kk)));
-    
-    Standard_Integer lengSec = tmpSeq.Length();
-    TColStd_Array1OfBoolean tabForward(1,lengSec);
-    TColStd_Array1OfReal tabDist(1,lengSec);
-    for (Standard_Integer i1 = 1 ; i1 <= lengSec; i1++) 
-      tabDist(i1) =-1;
-    
-    EvaluateDistances(tmpSeq,tabForward, tabDist,1 );
-    if(k == 1) {
-      for(Standard_Integer n = 1; n < lengSec; n++) {
-	if(tabDist(n+1) == -1 || tabDist(n+1) > myTolerance) {
-	  MapIndex.Add(n);
-	  continue;
-	}
-	TotTabDist(k,n) = tabDist(n+1 );
-	seqForward.Append(tabForward(n+1) ? 1:0);
-      }
-    }
-    else {
-      for(Standard_Integer n = 1; n < lengSec; n++) {
-	if(tabDist(n) == -1 || tabDist(n) > myTolerance) continue;
-	if(tabDist(n+1) < TotTabDist(1,n)) {
-	  MapIndex.Add(n);
-	}
-      }
-    }
-     
-  }
-  for(TColStd_MapIteratorOfMapOfInteger IMap(MapIndex); IMap.More(); IMap.Next()) {
-    seqIndCandidate.Remove(IMap.Key());
-    seqOrientations.Remove(IMap.Key());
-  }
-}
-
-//=======================================================================
-//function : FindCandidates
-//purpose  : internal use
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::FindCandidates(TopTools_SequenceOfShape& seqSections,
-						 TColStd_IndexedMapOfInteger& mapReference,
-						 TColStd_SequenceOfInteger& seqCandidates,
-						 TColStd_SequenceOfInteger& seqOrientations)
-{
-  Standard_Integer i, nbSections = seqSections.Length();
-
-  // Retrieve last reference index
-  Standard_Integer indReference = mapReference(mapReference.Extent());
-  Standard_Integer nbCandidates = 0;
-
-  if (nbSections > 1) {
-
-    TopoDS_Edge Edge1 = TopoDS::Edge(seqSections(indReference));
-
-    // Retrieve faces for reference section
-    TopTools_MapOfShape Faces1;
-    { //szv: Use brackets to destroy local variables
-      TopoDS_Shape bnd = Edge1;
-      if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
-      if (myBoundFaces.Contains(bnd)) {
-	TopTools_ListIteratorOfListOfShape itf1(myBoundFaces.FindFromKey(bnd));
-	for (; itf1.More(); itf1.Next()) Faces1.Add(itf1.Value());
-      }
-    }
-
-    // Check merging conditions for candidates and remove unsatisfactory
-    TopTools_SequenceOfShape seqSectionsNew;
-    TColStd_SequenceOfInteger seqCandidatesNew;
-    for (i = 1; i <= nbSections; i++) {
-      if (i == indReference) {
-	seqSectionsNew.Prepend(Edge1);
-	seqCandidatesNew.Prepend(i);
-      }
-      else {
-	const TopoDS_Edge& Edge2 = TopoDS::Edge(seqSections(i));
-	TopoDS_Shape bnd = Edge2;
-	if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
-	if (myBoundFaces.Contains(bnd)) {
-	  Standard_Boolean isOK = Standard_True;
-	  TopTools_ListIteratorOfListOfShape itf2(myBoundFaces.FindFromKey(bnd));
-	  for (; itf2.More() && isOK; itf2.Next()) {
-	    const TopoDS_Face& Face2 = TopoDS::Face(itf2.Value());
-	    // Check whether condition is satisfied
-	    isOK = !Faces1.Contains(Face2);
-	    if (!isOK) isOK = IsMergedClosed(Edge1,Edge2,Face2);
-	  }
-	  if (isOK) {
-	    seqSectionsNew.Append(Edge2);
-	    seqCandidatesNew.Append(i);
-	  }
-	}
-      }
-    }
-
-    Standard_Integer nbSectionsNew = seqSectionsNew.Length();
-    if (nbSectionsNew > 1) {
-
-      // Evaluate distances between reference and other sections
-      TColStd_Array1OfBoolean arrForward(1,nbSectionsNew);
-      TColStd_Array1OfReal arrDistance(1,nbSectionsNew);
-      EvaluateDistances(seqSectionsNew,arrForward,arrDistance,1);
-
-      // Fill sequence of candidate indices sorted by distance
-      for (i = 2; i <= nbSectionsNew; i++) {
-	if (arrDistance(i) >= 0.0) {
-	  // Reference section is connected to section #i
-	  Standard_Boolean isInserted = Standard_False;
-	  Standard_Integer j, ori = (arrForward(i)? 1 : 0);
-	  for (j = 1; (j <= seqCandidates.Length()) && !isInserted; j++) {
-	    if (arrDistance(i) <= arrDistance(seqCandidates.Value(j))) {
-	      seqCandidates.InsertBefore(j,i);
-	      seqOrientations.InsertBefore(j,ori);
-	      isInserted = Standard_True;
-	    }
-	  }
-	  if (!isInserted) {
-	    seqCandidates.Append(i);
-	    seqOrientations.Append(ori);
-	  }
-	}
-      }
-
-      // Replace candidate indices
-      nbCandidates = seqCandidates.Length();
-      for (i = 1; i <= nbCandidates; i++)
-	seqCandidates(i) = seqCandidatesNew(seqCandidates(i));
-    }
-  }
-
-  if (!nbCandidates) return Standard_False; // Section has no candidates to merge
-
-  if (myNonmanifold && nbCandidates >1) {
-    TColStd_SequenceOfInteger seqNewCandidates;
-    TColStd_SequenceOfInteger seqOrientationsNew;
-    seqCandidates.Prepend(1);
-    seqOrientations.Prepend(1);
-    for(Standard_Integer k = 1; k <= seqSections.Length() && seqCandidates.Length() > 1 ; k++) {
-      AnalysisNearestEdges(seqSections,seqCandidates,seqOrientations,(k==1));
-      if(k == 1 && !seqCandidates.Length()) return Standard_False;
-      if(seqCandidates.Length()) {
-        seqNewCandidates.Append(seqCandidates.First());
-        seqOrientationsNew.Append(seqOrientations.First()); 
-      }
-    }
-    seqCandidates.Prepend(seqNewCandidates);
-    seqOrientations.Prepend(seqOrientationsNew);
-    return Standard_True;
-  }
-  else {
-
-    // For manifold case leave only one candidate from equidistant candidates
-    /*Standard_Integer minIndex = seqCandidateIndex.First();
-    Standard_Real minDistance = arrDistance(minIndex);
-
-    // Find equidistant candidates
-    TColStd_SequenceOfInteger seqEqDistantIndex; seqEqDistantIndex.Append(1);
-    for (i = 2; i <= nbCandidates; i++) {
-      Standard_Integer index = seqCandidateIndex(i);
-      if (Abs(minDistance - arrDistance(index)) <= Precision::Confusion())
-	seqEqDistantIndex.Append(index);
-    }
-
-    Standard_Integer eqLen = seqEqDistantIndex.Length();
-    if (eqLen > 2) {
-
-      // Fill map of faces which equidistant sections belong to
-      TopTools_MapOfShape mapFace;
-      for (i = 1; i <= eqLen; i++) {
-	Standard_Integer index = seqEqDistantIndex.Value(i);
-	if (isCandidate(index)) {
-	  mapFace.Add(arrFace(index));
-	}
-      }
-
-      // Non Manifold case
-      // Edges are merged by pair among a face continuity C1 criterion
-      if (mapFace.Extent() == eqLen) {
-
-	tabDist.Init(-1);
-	tabMinInd.Init(-1);
-	min=10000000.;
-	//indMin = -1;
-	Standard_Integer indMin = -1;// To check if the edge can be merged.
-	// Computation of distances between the edges.
-	TopTools_SequenceOfShape seqSh;
-	Standard_Integer nbInd = EqDistSeq.Length();
-	TColStd_Array1OfBoolean tmptabForward(1,nbInd);
-	seqSh.Append(sequenceSec.Value(1));
-	for (j = 2; j <= EqDistSeq.Length(); j++) {
-	  Standard_Integer index = EqDistSeq.Value(j);
-	  tmptabForward(j) = tabForward(index);
-	  seqSh.Append(sequenceSec.Value(index));
-	}
-
-	EvaluateAngulars(seqSh, tmptabForward, tabDist,1);
-
-	for(j=2; j <= seqSh.Length(); j++) {
-	  if (tabDist(j) > -1.) {  // if edge(j) is connected to edge(i)
-	    if (min > tabDist(j)) {
-	      min = tabDist(j);
-	      indMin = j;
-	    }
-	  }
-	}
-
-	//  Construct minDist, tabMinInd , tabMinForward(i) = tabForward(j);
-	if (indMin > 0) {
-	  seqSh.Remove(indMin);
-	  for(j =2; j <= tmpSeq.Length(); ) {
-	    TopoDS_Shape sh = tmpSeq.Value(j);
-	    Standard_Boolean isRem = Standard_False;
-	    for(Standard_Integer k = 1; k<= seqSh.Length();k++) {
-	      if(seqSh.Value(k) == sh) {
-		isRem = Standard_True;
-		break;
-	      }
-	    }
-	    if(isRem) {
-	      tmpSeq.Remove(j);
-	      tabMinForward.Remove(j); // = -1;
-	    } 
-	    else j++;
-	  }
-	}
-      }
-    }*/
-
-    // Find the best approved candidate
-    while (nbCandidates) {
-      // Retrieve first candidate
-      Standard_Integer indCandidate = seqCandidates.First();
-      // Candidate is approved if it is in the map
-      if (mapReference.Contains(indCandidate)) break;
-      // Find candidates for candidate #indCandidate
-      mapReference.Add(indCandidate); // Push candidate in the map
-      TColStd_SequenceOfInteger seqCandidates1, seqOrientations1;
-      Standard_Boolean isFound =
-	FindCandidates(seqSections,mapReference,seqCandidates1,seqOrientations1);
-      mapReference.RemoveLast(); // Pop candidate from the map
-      if (isFound) isFound = (seqCandidates1.Length() > 0);
-      if (isFound) {
-	Standard_Integer indCandidate1 = seqCandidates1.First();
-	// If indReference is the best candidate for indCandidate
-	// then indCandidate is the best candidate for indReference
-	if (indCandidate1 == indReference) break;
-	// If some other reference in the map is the best candidate for indCandidate
-	// then assume that reference is the best candidate for indReference
-	if (mapReference.Contains(indCandidate1)) {
-	  seqCandidates.Prepend(indCandidate1);
-	  nbCandidates++;
-	  break;
-	}
-	isFound = Standard_False;
-      }
-      if (!isFound) {
-	// Remove candidate #1
-	seqCandidates.Remove(1);
-	seqOrientations.Remove(1);
-	nbCandidates--;
-      }
-    }
-  }
-
-  return (nbCandidates > 0);
-}
-
-//=======================================================================
-//function : Constructor
-//purpose  : 
-//=======================================================================
-
-BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(const Standard_Real tolerance,
-				 const Standard_Boolean optionSewing,
-				 const Standard_Boolean optionAnalysis,
-				 const Standard_Boolean optionCutting,
-				 const Standard_Boolean optionNonmanifold)
-{
-  myReShape = new BRepTools_ReShape;
-  Init(tolerance, optionSewing, optionAnalysis, optionCutting, optionNonmanifold);
-}
-
-//=======================================================================
-//function : Init
-//purpose  : Initialise Talerance, and options sewing, faceAnalysis and cutting
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Init(const Standard_Real tolerance,
-			   const Standard_Boolean optionSewing,
-			   const Standard_Boolean optionAnalysis,
-			   const Standard_Boolean optionCutting,
-			   const Standard_Boolean optionNonmanifold)
-{
-  // Set tolerance and Perform options
-  myTolerance      = tolerance;
-  mySewing         = optionSewing;
-  myAnalysis       = optionAnalysis;
-  myCutting        = optionCutting;
-  myNonmanifold    = optionNonmanifold;
-  // Set min and max tolerances
-  myMinTolerance   = tolerance*1e-4; //szv: proposal
-  if (myMinTolerance < Precision::Confusion()) myMinTolerance = Precision::Confusion();
-  myMaxTolerance   = Precision::Infinite();
-  // Set other modes
-  myFaceMode           = Standard_True;
-  myFloatingEdgesMode  = Standard_False;
-  //myCuttingFloatingEdgesMode = Standard_False; //gka
-  mySameParameterMode  = Standard_True;
-  myLocalToleranceMode = Standard_False;
-  mySewedShape.Nullify();
-  // Load empty shape
-  Load(TopoDS_Shape());
-}
-
-//=======================================================================
-//function : Load
-//purpose  : Loads the context shape
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Load(const TopoDS_Shape& theShape)
-{
-  myReShape->Clear();
-  if (theShape.IsNull()) myShape.Nullify();
-  else myShape = myReShape->Apply(theShape);
-  mySewedShape.Nullify();
-  // Nullify flags and counters
-  myNbShapes = myNbEdges = myNbVertices = 0;
-  // Clear all maps
-  myOldShapes.Clear();
-  //myOldFaces.Clear();
-  myDegenerated.Clear();
-  myFreeEdges.Clear();
-  myMultipleEdges.Clear();
-  myContigousEdges.Clear();
-  myContigSecBound.Clear();
-  myBoundFaces.Clear();
-  myBoundSections.Clear();
-  myVertexNode.Clear();
-  myVertexNodeFree.Clear();
-  myNodeSections.Clear();
-  myCuttingNode.Clear();
-  mySectionBound.Clear();
-  myLittleFace.Clear();
-}
-
-//=======================================================================
-//function : Add
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Add(const TopoDS_Shape& aShape)
-{
-  if (aShape.IsNull()) return;
-  TopoDS_Shape oShape = myReShape->Apply(aShape);
-  myOldShapes.Add(aShape,oShape);
-  myNbShapes = myOldShapes.Extent();
-}
-
-//=======================================================================
-//function : Perform
-//purpose  : 
-//=======================================================================
-
-#ifdef DEB
-#include <OSD_Timer.hxx>
-#endif
-
-void BRepBuilderAPI_Sewing::Perform()
-{
-#ifdef DEB
-  Standard_Real t_total = 0., t_analysis = 0., t_assembling = 0., t_cutting = 0., t_merging = 0.;
-  OSD_Chronometer chr_total, chr_local;
-  chr_total.Reset();
-  chr_total.Start();
-#endif
-
-  // face analysis
-  if (myAnalysis) {
-#if DEB
-    cout << "Begin face analysis..." << endl;
-    chr_local.Reset();
-    chr_local.Start();
-#endif
-    FaceAnalysis();
-#if DEB
-    chr_local.Stop();
-    chr_local.Show(t_analysis);
-    cout << "Face analysis finished after " << t_analysis << " s" << endl;
-#endif
-  }
-
-  if (myNbShapes || !myShape.IsNull()) {
-
-    FindFreeBoundaries();
-
-    if (myBoundFaces.Extent()) {
-
-#if DEB
-      cout << "Begin vertices assembling..." << endl;
-      chr_local.Reset();
-      chr_local.Start();
-#endif
-      VerticesAssembling();
-#if DEB
-      chr_local.Stop();
-      chr_local.Show(t_assembling);
-      cout << "Vertices assembling finished after " << t_assembling << " s" << endl;
-#endif
-      if (myCutting) {
-#if DEB
-	cout << "Begin cutting..." << endl;
-	chr_local.Reset();
-	chr_local.Start();
-#endif
-	Cutting();
-#if DEB
-	chr_local.Stop();
-	chr_local.Show(t_cutting);
-	cout << "Cutting finished after " << t_cutting << " s" << endl;
-#endif
-      }
-#if DEB
-      cout << "Begin merging..." << endl;
-      chr_local.Reset();
-      chr_local.Start();
-#endif
-      Merging(Standard_True);
-#if DEB
-      chr_local.Stop();
-      chr_local.Show(t_merging);
-      cout << "Merging finished after " << t_merging << " s" << endl;
-#endif
-    }
-
-    if (mySewing) {
-
-#if DEB
-      cout << "Creating sewed shape..." << endl;
-#endif
-      // examine the multiple edges if any and process sameparameter for edges if necessary
-      EdgeProcessing();
-      CreateSewedShape();
-      if (mySameParameterMode && myFaceMode) SameParameterShape();
-#if DEB
-      cout << "Sewed shape created" << endl;
-#endif
-    }
-    
-    // create edge informations for output
-    CreateOutputInformations();
-  }
-#if DEB
-  chr_total.Stop();
-  chr_total.Show(t_total);
-  cout << "Sewing finished!" << endl;
-  cout << " analysis time   : " << t_analysis << " s" << endl;
-  cout << " assembling time : " << t_assembling << " s" << endl;
-  cout << " cutting time    : " << t_cutting << " s" << endl;
-  cout << " merging time    : " << t_merging << " s" << endl;
-  cout << "Total time       : " << t_total << " s" << endl;
-#endif
-}
-
-//=======================================================================
-//function : SewedShape
-//purpose  : give the sewed shape
-//           if a null shape, reasons:
-//             -- no useable input shapes : all input shapes are degenerated
-//             -- has multiple edges
-//=======================================================================
-
-const TopoDS_Shape& BRepBuilderAPI_Sewing::SewedShape() const
-{
-  return mySewedShape;
-}
-
-//=======================================================================
-//function : NbFreeEdges
-//purpose  : 
-//=======================================================================
-
-Standard_Integer BRepBuilderAPI_Sewing::NbFreeEdges() const
-{
-  return myFreeEdges.Extent();
-}
-
-//=======================================================================
-//function : FreeEdge
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Edge& BRepBuilderAPI_Sewing::FreeEdge(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbFreeEdges(), "BRepBuilderAPI_Sewing::FreeEdge");
-  return TopoDS::Edge(myFreeEdges(index));
-}
-
-//=======================================================================
-//function : NbMultipleEdges
-//purpose  : 
-//=======================================================================
-
-Standard_Integer BRepBuilderAPI_Sewing::NbMultipleEdges() const
-{
-  return myMultipleEdges.Extent();
-}
-
-//=======================================================================
-//function : MultipleEdge
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Edge& BRepBuilderAPI_Sewing::MultipleEdge(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbMultipleEdges(), "BRepBuilderAPI_Sewing::MultipleEdge");
-  return TopoDS::Edge(myMultipleEdges(index));
-}
-
-//=======================================================================
-//function : NbContigousEdges
-//purpose  : 
-//=======================================================================
-
-Standard_Integer BRepBuilderAPI_Sewing::NbContigousEdges() const
-{
-  return myContigousEdges.Extent();
-}
-
-//=======================================================================
-//function : ContigousEdge
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Edge& BRepBuilderAPI_Sewing::ContigousEdge(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbContigousEdges(), "BRepBuilderAPI_Sewing::ContigousEdge");
-  return TopoDS::Edge(myContigousEdges.FindKey(index));
-}
-
-//=======================================================================
-//function : ContigousEdgeCouple
-//purpose  : 
-//=======================================================================
-
-const TopTools_ListOfShape& BRepBuilderAPI_Sewing::ContigousEdgeCouple(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbContigousEdges(), "BRepBuilderAPI_Sewing::ContigousEdgeCouple");
-  return myContigousEdges(index);
-}
-
-//=======================================================================
-//function : IsSectionBound
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsSectionBound(const TopoDS_Edge& section) const
-{
-  if(myContigSecBound.IsBound(section)) {
-    return Standard_True;
-  }
-  else {
-    return Standard_False;
-  }
-}
-
-//=======================================================================
-//function : SectionToBoundary
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Edge& BRepBuilderAPI_Sewing::SectionToBoundary(const TopoDS_Edge& section) const
-{
-  Standard_NoSuchObject_Raise_if(!IsSectionBound(section), "BRepBuilderAPI_Sewing::SectionToBoundary");
-  return TopoDS::Edge(myContigSecBound(section));
-}
-//=======================================================================
-//function : NbDeletedFaces
-//purpose  : 
-//=======================================================================
- Standard_Integer BRepBuilderAPI_Sewing::NbDeletedFaces() const
-{
-  return myLittleFace.Extent();
-}
-
-//=======================================================================
-//function : DeletedFace
-//purpose  : 
-//=======================================================================
-const TopoDS_Face& BRepBuilderAPI_Sewing::DeletedFace(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbDeletedFaces(), "BRepBuilderAPI_Sewing::DeletedFace");
-  return TopoDS::Face(myLittleFace(index));
-}
-
-//=======================================================================
-//function : NbDegeneratedShapes
-//purpose  : 
-//=======================================================================
-
-Standard_Integer BRepBuilderAPI_Sewing::NbDegeneratedShapes() const
-{
-  return myDegenerated.Extent();
-}
-
-//=======================================================================
-//function : DegeneratedShape
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Shape& BRepBuilderAPI_Sewing::DegeneratedShape(const Standard_Integer index) const
-{
-  Standard_OutOfRange_Raise_if(index < 0 || index > NbDegeneratedShapes(), "BRepBuilderAPI_Sewing::DegereratedShape");
-  return myDegenerated(index);
-}
-
-//=======================================================================
-//function : IsDegenerated
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsDegenerated(const TopoDS_Shape& aShape) const
-{
-  TopoDS_Shape NewShape = myReShape->Apply(aShape);
-  // Degenerated face
-  if (aShape.ShapeType() == TopAbs_FACE)
-    return NewShape.IsNull();
-  if (NewShape.IsNull()) return Standard_False;
-  // Degenerated edge
-  if (NewShape.ShapeType() == TopAbs_EDGE)
-    return BRep_Tool::Degenerated(TopoDS::Edge(NewShape));
-  // Degenerated wire
-  if (NewShape.ShapeType() == TopAbs_WIRE) {
-    Standard_Boolean isDegenerated = Standard_True;
-    for (TopoDS_Iterator aIt(NewShape); aIt.More() && isDegenerated; aIt.Next())
-      isDegenerated = BRep_Tool::Degenerated(TopoDS::Edge(aIt.Value()));
-    return isDegenerated;
-  }
-  return Standard_False;
-}
-  
-//=======================================================================
-//function : IsModified
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsModified(const TopoDS_Shape& aShape) const
-{
-  TopoDS_Shape NewShape = aShape;
-  if (myOldShapes.Contains(aShape)) 
-    NewShape = myOldShapes.FindFromKey(aShape);
-  if(!NewShape.IsSame(aShape)) return Standard_True;
-  return Standard_False;
-}
-
-//=======================================================================
-//function : Modified
-//purpose  : 
-//=======================================================================
-
-const TopoDS_Shape& BRepBuilderAPI_Sewing::Modified(const TopoDS_Shape& aShape) const
-{ 
-  if (myOldShapes.Contains(aShape)) return myOldShapes.FindFromKey(aShape);
-  //if (myOldFaces.Contains(aShape)) return myOldFaces.FindFromKey(aShape);
-  return aShape;
-}
-
-//=======================================================================
-//function : IsModifiedSubShape
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::IsModifiedSubShape(const TopoDS_Shape& aShape) const
-{
-  TopoDS_Shape NewShape = myReShape->Apply(aShape);
-  if(!NewShape.IsSame(aShape)) return Standard_True;
-  return Standard_False;
-}
-
-//=======================================================================
-//function : ModifiedSubShape
-//purpose  : 
-//=======================================================================
-
-TopoDS_Shape BRepBuilderAPI_Sewing::ModifiedSubShape(const TopoDS_Shape& aShape) const
-{ 
-  return myReShape->Apply(aShape);
-}
-
-//=======================================================================
-//function : Dump
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Dump() const
-{
-  Standard_Integer i, NbBounds = myBoundFaces.Extent(), NbSections = 0;
-  TopTools_MapOfShape mapVertices, mapEdges;
-  for (i = 1; i <= NbBounds; i++) {
-    TopoDS_Shape bound = myBoundFaces.FindKey(i);
-    if (myBoundSections.IsBound(bound)) NbSections += myBoundSections(bound).Extent();
-    else NbSections++;
-    TopExp_Explorer aExp(myReShape->Apply(bound),TopAbs_EDGE);
-    for (; aExp.More(); aExp.Next()) {
-      TopoDS_Edge E = TopoDS::Edge(aExp.Current());
-      mapEdges.Add(E);
-      TopoDS_Vertex V1, V2;
-      TopExp::Vertices(E,V1,V2);
-      mapVertices.Add(V1);
-      mapVertices.Add(V2);
-    }
-  }
-  cout << " " << endl;
-  cout << "                        Informations                        " << endl;
-  cout << " ===========================================================" << endl;
-  cout << " " << endl;
-  cout << " Number of input shapes      : " << myOldShapes.Extent() << endl;
-  cout << " Number of actual shapes     : " << myNbShapes << endl;
-  cout << " Number of Bounds            : " << NbBounds << endl;
-  cout << " Number of Sections          : " << NbSections << endl;
-  cout << " Number of Edges             : " << mapEdges.Extent() << endl;
-  cout << " Number of Vertices          : " << myNbVertices << endl;
-  cout << " Number of Nodes             : " << mapVertices.Extent() << endl;
-  cout << " Number of Free Edges        : " << myFreeEdges.Extent() << endl;
-  cout << " Number of Contigous Edges   : " << myContigousEdges.Extent() << endl;
-  cout << " Number of Multiple Edges    : " << myMultipleEdges.Extent() << endl;
-  cout << " Number of Degenerated Edges : " << myDegenerated.Extent() << endl;
-  cout << " ===========================================================" << endl;
-  cout << " " << endl;
-}
-
-//=======================================================================
-//function : FaceAnalysis
-//purpose  : Remove
-//	     Modifies:
-//                      myNbShapes
-//                      myOldShapes
-//
-//           Constructs:
-//                      myDegenerated
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::FaceAnalysis()
-{
-  if (!myShape.IsNull() && myOldShapes.IsEmpty()) {
-    Add(myShape);
-    myShape.Nullify();
-  }
-
-  BRep_Builder B;
-  TopTools_MapOfShape SmallEdges;
-  TopTools_DataMapOfShapeListOfShape GluedVertices;
-  Standard_Integer i = 1;
-  for (i = 1; i <= myOldShapes.Extent(); i++) {
-    for (TopExp_Explorer fexp(myOldShapes(i),TopAbs_FACE); fexp.More(); fexp.Next()) {
-
-      // Retrieve current face
-      TopoDS_Shape aTmpShape = fexp.Current(); //for porting
-      TopoDS_Face face = TopoDS::Face(aTmpShape);
-      Standard_Integer nbEdges = 0, nbSmall = 0;
-
-      // Build replacing face
-      aTmpShape = face.EmptyCopied().Oriented(TopAbs_FORWARD); //for porting
-      TopoDS_Face nface = TopoDS::Face(aTmpShape);
-      Standard_Boolean isFaceChanged = Standard_False;
-
-      TopoDS_Iterator witer(face.Oriented(TopAbs_FORWARD));
-      for (; witer.More(); witer.Next()) {
-
-	// Retrieve current wire
-        aTmpShape = witer.Value(); //for porting
-        if( aTmpShape.ShapeType() != TopAbs_WIRE) continue;
-	TopoDS_Wire wire = TopoDS::Wire(aTmpShape);
-
-	// Build replacing wire
-        aTmpShape = wire.EmptyCopied().Oriented(TopAbs_FORWARD);
-	TopoDS_Wire nwire = TopoDS::Wire(aTmpShape);
-	Standard_Boolean isWireChanged = Standard_False;
-
-	TopoDS_Iterator eiter(wire.Oriented(TopAbs_FORWARD));
-	for (; eiter.More(); eiter.Next()) {
-
-	  // Retrieve current edge
-          aTmpShape = eiter.Value(); //for porting
-	  TopoDS_Edge edge = TopoDS::Edge(aTmpShape);
-	  nbEdges++;
-
-	  // Process degenerated edge
-	  if (BRep_Tool::Degenerated(edge)) {
-	    B.Add(nwire,edge); // Old edge kept
-	    myDegenerated.Add(edge);
-	    nbSmall++;
-	    continue;
-	  }
-
-	  Standard_Boolean isSmall = SmallEdges.Contains(edge);
-	  if (!isSmall) {
-
-	    // Check for small edge
-	    Standard_Real first, last;
-	    Handle(Geom_Curve) c3d = BRep_Tool::Curve(edge,first,last);
-	    if (c3d.IsNull()) {
-#ifdef DEB
-	      cout << "Warning: Possibly small edge can be sewed: No 3D curve" << endl;
-#endif
-	    }
-	    else {
-	      // Evaluate curve compactness
-	      const Standard_Integer npt = 5;
-	      gp_Pnt cp((c3d->Value(first).XYZ()+c3d->Value(last).XYZ())*0.5);
-	      Standard_Real dist, maxdist = 0.0;
-	      Standard_Real delta = (last - first)/(npt - 1);
-	      for (Standard_Integer idx = 0; idx < npt; idx++) {
-		dist = cp.Distance(c3d->Value(first + idx*delta));
-		if (maxdist < dist) maxdist = dist;
-	      }
-	      isSmall = (2.*maxdist <= MinTolerance());
-	      /*try {
-		GeomAdaptor_Curve cAdapt(c3d);
-		Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt,first,last);
-		isSmall = (length <= MinTolerance());
-	      }
-	      catch (Standard_Failure) {
-#ifdef DEB
-		cout << "Warning: Possibly small edge can be sewed: ";
-		Standard_Failure::Caught()->Print(cout); cout << endl;
-#endif
-	      }*/
-	    }
-
-	    if (isSmall) {
-
-	      // Store small edge in the map
-	      SmallEdges.Add(edge);
-
-	      TopoDS_Vertex v1, v2;
-	      TopExp::Vertices(edge,v1,v2);
-	      TopoDS_Shape nv1 = myReShape->Apply(v1), nv2 = myReShape->Apply(v2);
-
-	      // Store glued vertices
-	      if (!nv1.IsSame(v1)) {
-		TopTools_ListOfShape& vlist1 = GluedVertices(nv1);
-		// First vertex was already glued
-		if (!nv2.IsSame(v2)) {
-		  // Merge lists of glued vertices
-		  if (!nv1.IsSame(nv2)) {
-		    TopTools_ListIteratorOfListOfShape liter(GluedVertices(nv2));
-		    for (; liter.More(); liter.Next()) {
-		      TopoDS_Shape v = liter.Value();
-		      myReShape->Replace(v,nv1.Oriented(v.Orientation()));
-		      vlist1.Append(v);
-		    }
-		    GluedVertices.UnBind(nv2);
-		  }
-		}
-		else {
-		  // Add second vertex to the existing list
-		  vlist1.Append(v2);
-		  myReShape->Replace(v2,nv1.Oriented(v2.Orientation()));
-		}
-	      }
-	      else if (!nv2.IsSame(v2)) {
-		// Add first vertex to the existing list
-		GluedVertices(nv2).Append(v1);
-		myReShape->Replace(v1,nv2.Oriented(v1.Orientation()));
-	      }
-	      else if (!v1.IsSame(v2)) {
-		// Record new glued vertices
-		TopoDS_Vertex nv;
-		B.MakeVertex(nv);
-		TopTools_ListOfShape vlist;
-		vlist.Append(v1);
-		vlist.Append(v2);
-		GluedVertices.Bind(nv,vlist);
-		myReShape->Replace(v1,nv.Oriented(v1.Orientation()));
-		myReShape->Replace(v2,nv.Oriented(v2.Orientation()));
-	      }
-	    }
-	  }
-
-	  // Replace small edge
-	  if (isSmall) {
-#ifdef DEB
-	    cout << "Warning: Small edge made degenerated by FaceAnalysis" << endl;
-#endif
-	    nbSmall++;
-	    // Create new degenerated edge
-            aTmpShape = edge.Oriented(TopAbs_FORWARD);
-	    TopoDS_Edge fedge = TopoDS::Edge(aTmpShape);
-	    Standard_Real pfirst, plast;
-	    Handle(Geom2d_Curve) c2d = BRep_Tool::CurveOnSurface(fedge,face,pfirst,plast);
-	    if (!c2d.IsNull()) {
-	      TopoDS_Edge nedge;
-	      B.MakeEdge(nedge);
-	      B.UpdateEdge(nedge,c2d,face,Precision::Confusion());
-	      B.Range(nedge,pfirst,plast);
-	      B.Degenerated(nedge,Standard_True);
-	      TopoDS_Vertex v1, v2;
-	      TopExp::Vertices(fedge,v1,v2);
-	      B.Add(nedge,myReShape->Apply(v1).Oriented(v1.Orientation()));
-	      B.Add(nedge,myReShape->Apply(v2).Oriented(v2.Orientation()));
-	      B.Add(nwire,nedge.Oriented(edge.Orientation()));
-	      myDegenerated.Add(nedge);
-	    }
-	    isWireChanged = Standard_True;
-	  }
-	  else B.Add(nwire,edge); // Old edge kept
-	}
-
-	// Record wire in the new face
-	if (isWireChanged) {
-	  B.Add(nface,nwire.Oriented(wire.Orientation()));
-	  isFaceChanged = Standard_True;
-	}
-	else B.Add(nface,wire);
-      }
-
-      // Remove small face
-      if (nbSmall == nbEdges) {
-#ifdef DEB
-	cout << "Warning: Small face removed by FaceAnalysis" << endl;
-#endif
-	myLittleFace.Add(face);
-	myReShape->Remove(face);
-      }
-      else if (isFaceChanged) {
-
-	myReShape->Replace(face,nface.Oriented(face.Orientation()));
-      }
-    }
-  }
-
-  // Update glued vertices
-  TopTools_DataMapIteratorOfDataMapOfShapeListOfShape miter(GluedVertices);
-  for (; miter.More(); miter.Next()) {
-    TopoDS_Vertex vnew = TopoDS::Vertex(miter.Key());
-    gp_XYZ coord(0.,0.,0.);
-    Standard_Integer nbPoints = 0;
-    const TopTools_ListOfShape& vlist = miter.Value();
-    TopTools_ListIteratorOfListOfShape liter1(vlist);
-    for (; liter1.More(); liter1.Next()) {
-      coord += BRep_Tool::Pnt(TopoDS::Vertex(liter1.Value())).XYZ();
-      nbPoints++;
-    }
-    if (nbPoints) {
-      gp_Pnt vp(coord / nbPoints);
-      Standard_Real tol = 0.0, mtol = 0.0;
-      TopTools_ListIteratorOfListOfShape liter2(vlist);
-      for (; liter2.More(); liter2.Next()) {
-	Standard_Real vtol = BRep_Tool::Tolerance(TopoDS::Vertex(liter2.Value()));
-	if (mtol < vtol) mtol = vtol;
-	vtol = vp.Distance(BRep_Tool::Pnt(TopoDS::Vertex(liter2.Value())));
-	if (tol < vtol) tol = vtol;
-      }
-      B.UpdateVertex(vnew,vp,tol+mtol);
-    }
-  }
-
-  // Update input shapes
-  for (i = 1; i <= myOldShapes.Extent(); i++)
-    myOldShapes(i) = myReShape->Apply(myOldShapes(i));
-}
-
-//=======================================================================
-//function : FindFreeBoundaries
-//purpose  : Constructs :
-//                      myBoundFaces     (bound = list of faces) - REFERENCE
-//                      myVertexNode     (vertex = node)
-//                      myVertexNodeFree (floating vertex = node)
-//
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::FindFreeBoundaries()
-{
-  // Take into account the context shape if needed
-  TopTools_IndexedMapOfShape NewShapes;
-  if (!myShape.IsNull()) {
-    if (myOldShapes.IsEmpty()) {
-      Add(myShape);
-      myShape.Nullify();
-    }
-    else {
-      TopoDS_Shape newShape = myReShape->Apply(myShape);
-      if (!newShape.IsNull()) NewShapes.Add(newShape);
-    }
-  }
-  // Create map Edge -> Faces
-  TopTools_IndexedDataMapOfShapeListOfShape EdgeFaces;
-  Standard_Integer i, nbShapes = myOldShapes.Extent();
-  for (i = 1; i <= nbShapes; i++) {
-    // Retrieve new shape
-    TopoDS_Shape shape = myOldShapes(i);
-    if (shape.IsNull()) continue;
-    NewShapes.Add(shape);
-    // Explore shape to find all boundaries
-    for (TopExp_Explorer eExp(shape,TopAbs_EDGE); eExp.More(); eExp.Next()) {
-      TopoDS_Shape edge = eExp.Current();
-      if (!EdgeFaces.Contains(edge)) {
-	TopTools_ListOfShape listFaces;
-	EdgeFaces.Add(edge,listFaces);
-      }
-    }
-  }
-  // Fill map Edge -> Faces
-  nbShapes = NewShapes.Extent();
-   TopTools_MapOfShape mapFaces;
-  for (i = 1; i <= nbShapes; i++) {
-    // Explore shape to find all faces
-    TopExp_Explorer fExp(NewShapes.FindKey(i),TopAbs_FACE);
-    for (; fExp.More(); fExp.Next()) {
-      TopoDS_Shape face = fExp.Current();
-      if(mapFaces.Contains(face)) continue;
-      else 
-        mapFaces.Add(face);
-      // Explore face to find all boundaries
-      for (TopoDS_Iterator aIw(face); aIw.More(); aIw.Next()) {
-        if(aIw.Value().ShapeType() != TopAbs_WIRE) continue;
-        for (TopoDS_Iterator aIIe(aIw.Value()); aIIe.More(); aIIe.Next()) {
-          
-          TopoDS_Shape edge = aIIe.Value();
-          
-          if (EdgeFaces.Contains(edge)) {
-            EdgeFaces.ChangeFromKey(edge).Append(face);
-            //TopTools_ListOfShape& listFaces = EdgeFaces.ChangeFromKey(edge);
-            //Standard_Boolean isContained = Standard_False;
-            //TopTools_ListIteratorOfListOfShape itf(listFaces);
-            //for (; itf.More() && !isContained; itf.Next())
-            //  isContained = face.IsSame(itf.Value());
-            //if (!isContained) listFaces.Append(face);
-          }
-        }
-      }
-    }
-  }
-  // Find free boundaries
-  nbShapes = EdgeFaces.Extent();
-  for (i = 1; i <= nbShapes; i++) {
-    TopTools_ListOfShape& listFaces = EdgeFaces(i);
-    Standard_Integer nbFaces = listFaces.Extent();
-    TopoDS_Shape edge = EdgeFaces.FindKey(i);
-    if(edge.Orientation() == TopAbs_INTERNAL)
-          continue;
-    Standard_Boolean isSeam = Standard_False;
-    if (nbFaces == 1) {
-      TopoDS_Face face = TopoDS::Face(listFaces.First());
-      isSeam = BRep_Tool::IsClosed(TopoDS::Edge(edge),face);
-      if (isSeam) {
-	///Handle(Geom_Surface) surf = BRep_Tool::Surface(face);
-	//isSeam = (IsUClosedSurface(surf) || IsVClosedSurface(surf));
-        //if(!isSeam) {
-          Standard_Real first,last;
-          Handle(Geom2d_Curve) c2dold = BRep_Tool::CurveOnSurface(TopoDS::Edge(edge),TopoDS::Face(listFaces.First()),first,last);
-          Handle(Geom2d_Curve) c2d;
-          BRep_Builder B;
-          B.UpdateEdge(TopoDS::Edge(edge),c2d,c2d,TopoDS::Face(listFaces.First()),0);
-          B.UpdateEdge(TopoDS::Edge(edge),c2dold,TopoDS::Face(listFaces.First()),0);
-        //}
-           isSeam = Standard_False;
-      }
-    }
-    Standard_Boolean isBoundFloat = (myFloatingEdgesMode && !nbFaces);
-    Standard_Boolean isBound = (myFaceMode && ((myNonmanifold && nbFaces) || (nbFaces == 1 && !isSeam)));
-    if (isBound || isBoundFloat) {
-      // Ignore degenerated edge
-      if (BRep_Tool::Degenerated(TopoDS::Edge(edge))) continue;
-      // Ignore edge with internal vertices
-     // Standard_Integer nbVtx = 0;
-     // for (TopExp_Explorer vExp(edge,TopAbs_VERTEX); vExp.More(); vExp.Next()) nbVtx++;
-     // if (nbVtx != 2) continue;
-      // Add to BoundFaces
-      TopTools_ListOfShape listFacesCopy;
-      listFacesCopy.Append(listFaces);
-      myBoundFaces.Add(edge,listFacesCopy);
-      // Process edge vertices
-      TopoDS_Vertex vFirst, vLast;
-      TopExp::Vertices(TopoDS::Edge(edge), vFirst, vLast);
-      if(vFirst.IsNull() || vLast.IsNull()) continue;
-      if(vFirst.Orientation() == TopAbs_INTERNAL || vLast.Orientation() == TopAbs_INTERNAL)
-        continue;
-      if (isBound) {
-	// Add to VertexNode
-	if (!myVertexNode.Contains(vFirst))
-	  myVertexNode.Add(vFirst,vFirst);
-	if (!myVertexNode.Contains(vLast))
-	  myVertexNode.Add(vLast,vLast);
-      }
-      else {
-	// Add to VertexNodeFree
-	if (!myVertexNodeFree.Contains(vFirst))
-	  myVertexNodeFree.Add(vFirst,vFirst);
-	if (!myVertexNodeFree.Contains(vLast))
-	  myVertexNodeFree.Add(vLast,vLast);
-      }
-    }
-  }
-}
-
-//=======================================================================
-//function : VerticesAssembling
-//purpose  : Modifies :
-//                      myVertexNode     (nodes glued)
-//                      myVertexNodeFree (nodes glued)
-//                      myNodeSections   (lists of sections merged for glued nodes)
-//
-//=======================================================================
-
-static Standard_Boolean CreateNewNodes(const TopTools_IndexedDataMapOfShapeShape& NodeNearestNode,
-				       const TopTools_IndexedDataMapOfShapeListOfShape& NodeVertices,
-				       TopTools_IndexedDataMapOfShapeShape& aVertexNode,
-				       TopTools_DataMapOfShapeListOfShape& aNodeEdges)
-{
-  Standard_Integer i, nbNearest = NodeNearestNode.Extent();
-
-  // Create new nodes
-  BRep_Builder B;
-  TopTools_DataMapOfShapeShape OldNodeNewNode;
-  TopTools_DataMapOfShapeListOfShape NewNodeOldNodes;
-  for (i = 1; i <= nbNearest; i++) {
-    // Retrieve a pair of nodes to merge
-    TopoDS_Shape oldnode1 = NodeNearestNode.FindKey(i);
-    TopoDS_Shape oldnode2 = NodeNearestNode(i);
-    // Second node should also be in the map
-    if (!NodeNearestNode.Contains(oldnode2)) continue;
-    // Get new node for old node #1
-    if (OldNodeNewNode.IsBound(oldnode1)) {
-      TopoDS_Shape newnode1 = OldNodeNewNode(oldnode1);
-      if (OldNodeNewNode.IsBound(oldnode2)) {
-	TopoDS_Shape newnode2 = OldNodeNewNode(oldnode2);
-	if (!newnode1.IsSame(newnode2)) {
-	  // Change data for new node #2
-	  TopTools_ListOfShape& lnode1 = NewNodeOldNodes(newnode1);
-	  TopTools_ListIteratorOfListOfShape itn(NewNodeOldNodes(newnode2));
-	  for (; itn.More(); itn.Next()) {
-	    TopoDS_Shape node2 = itn.Value();
-	    lnode1.Append(node2);
-	    OldNodeNewNode(node2) = newnode1;
-	  }
-	  NewNodeOldNodes.UnBind(newnode2);
-	}
-      }
-      else {
-	// Old node #2 is not bound - add to old node #1
-	OldNodeNewNode.Bind(oldnode2,newnode1);
-	NewNodeOldNodes(newnode1).Append(oldnode2);
-      }
-    }
-    else {
-      if (OldNodeNewNode.IsBound(oldnode2)) {
-	// Old node #1 is not bound - add to old node #2
-	TopoDS_Shape newnode2 = OldNodeNewNode(oldnode2);
-	OldNodeNewNode.Bind(oldnode1,newnode2);
-	NewNodeOldNodes(newnode2).Append(oldnode1);
-      }
-      else {
-	// Nodes are not bound - create new node
-	TopoDS_Vertex newnode;
-	B.MakeVertex(newnode);
-	OldNodeNewNode.Bind(oldnode1,newnode);
-	OldNodeNewNode.Bind(oldnode2,newnode);
-	TopTools_ListOfShape lnodes;
-	lnodes.Append(oldnode1);
-	lnodes.Append(oldnode2);
-	NewNodeOldNodes.Bind(newnode,lnodes);
-      }
-    }
-  }
-
-  // Stop if no new nodes created
-  if (!NewNodeOldNodes.Extent()) return Standard_False;
-
-  TopTools_DataMapIteratorOfDataMapOfShapeListOfShape iter1(NewNodeOldNodes);
-  for (; iter1.More(); iter1.Next()) {
-    const TopoDS_Vertex& newnode = TopoDS::Vertex(iter1.Key());
-    // Calculate new node center point
-    gp_XYZ theCoordinates(0.,0.,0.);
-    TopTools_ListOfShape lvert; // Accumulate node vertices
-    TopTools_MapOfShape medge;
-    TopTools_ListOfShape ledge; // Accumulate node edges
-    // Iterate on old nodes
-    TopTools_ListIteratorOfListOfShape itn(iter1.Value());
-    for (; itn.More(); itn.Next()) {
-      const TopoDS_Shape& oldnode = itn.Value();
-      // Iterate on node vertices
-      TopTools_ListIteratorOfListOfShape itv(NodeVertices.FindFromKey(oldnode));
-      for (; itv.More(); itv.Next()) {
-	TopoDS_Vertex vertex = TopoDS::Vertex(itv.Value());
-	// Change node for vertex
-	aVertexNode.ChangeFromKey(vertex) = newnode;
-	// Accumulate coordinates
-	theCoordinates += BRep_Tool::Pnt(vertex).XYZ();
-	lvert.Append(vertex);
-      }
-      // Iterate on node edges
-      const TopTools_ListOfShape& edges = aNodeEdges(oldnode);
-      TopTools_ListIteratorOfListOfShape ite(edges);
-      for (; ite.More(); ite.Next()) {
-	TopoDS_Shape edge = ite.Value();
-	if (!medge.Contains(edge)) { medge.Add(edge); ledge.Append(edge); }
-      }
-      // Unbind old node edges
-      aNodeEdges.UnBind(oldnode);
-    }
-    // Bind new node edges
-    aNodeEdges.Bind(newnode,ledge);
-    gp_Pnt center(theCoordinates / lvert.Extent());
-    // Calculate new node tolerance
-    Standard_Real toler = 0.0;
-    TopTools_ListIteratorOfListOfShape itv(lvert);
-    for (; itv.More(); itv.Next()) {
-      const TopoDS_Vertex& vertex = TopoDS::Vertex(itv.Value());
-      Standard_Real t = center.Distance(BRep_Tool::Pnt(vertex)) + BRep_Tool::Tolerance(vertex);
-      if (toler < t) toler = t;
-    }
-    // Update new node parameters
-    B.UpdateVertex(newnode,center,toler);
-  }
-
-  return Standard_True;
-}
-
-static Standard_Integer IsMergedVertices(const TopoDS_Shape& face1,
-					 const TopoDS_Shape& e1, const TopoDS_Shape& e2,
-					 const TopoDS_Shape& vtx1, const TopoDS_Shape& vtx2)
-{
-  //Case of floating edges
-  if (face1.IsNull())
-    return (!IsClosedShape(e1,vtx1,vtx2));
-
-  // Find wires containing given edges
-  TopoDS_Shape wire1, wire2;
-  TopExp_Explorer itw(face1,TopAbs_WIRE);
-  for (; itw.More() && (wire1.IsNull() || wire2.IsNull()); itw.Next()) {
-    TopoDS_Iterator ite(itw.Current(),Standard_False);
-    for (; ite.More() && (wire1.IsNull() || wire2.IsNull()); ite.Next()) {
-      if (wire1.IsNull() && e1.IsSame(ite.Value())) wire1 = itw.Current();
-      if (wire2.IsNull() && e2.IsSame(ite.Value())) wire2 = itw.Current();
-    }
-  }
-  Standard_Integer Status = 0;
-  if (!wire1.IsNull() && !wire2.IsNull()) {
-    if (wire1.IsSame(wire2)) {
-      for (TopoDS_Iterator aIte(wire1,Standard_False); aIte.More(); aIte.Next()) {
-	TopoDS_Vertex ve1,ve2;
-	TopExp::Vertices(TopoDS::Edge(aIte.Value()),ve1,ve2);
-	if ((ve1.IsSame(vtx1) && ve2.IsSame(vtx2)) ||
-	    (ve2.IsSame(vtx1) && ve1.IsSame(vtx2)))
-	  return (IsClosedShape(aIte.Value(),vtx1,vtx2)? 0 : 1);
-      }
-      if (IsClosedShape(wire1,vtx1,vtx2)) {
-	TopoDS_Vertex V1, V2;
-	TopExp::Vertices(TopoDS::Wire(wire1),V1,V2);
-	Standard_Boolean isEndVertex = ((V1.IsSame(vtx1) && V2.IsSame(vtx2)) ||
-					(V2.IsSame(vtx1) && V1.IsSame(vtx2)));
-	if (!isEndVertex) Status = 1;
-      }
-      else Status = 1;
-    }
-    else Status = -1;
-  }
-  return Status;
-}
-
-static Standard_Boolean GlueVertices(TopTools_IndexedDataMapOfShapeShape& aVertexNode,
-				     TopTools_DataMapOfShapeListOfShape& aNodeEdges,
-				     const TopTools_IndexedDataMapOfShapeListOfShape& aBoundFaces,
-				     const Standard_Real Tolerance)
-{
-  Standard_Integer i, nbVertices = aVertexNode.Extent();
-  // Create map of node -> vertices
-  TopTools_IndexedDataMapOfShapeListOfShape NodeVertices;
-  for (i = 1; i <= nbVertices; i++) {
-    TopoDS_Shape vertex = aVertexNode.FindKey(i);
-    TopoDS_Vertex node = TopoDS::Vertex(aVertexNode(i));
-    if (NodeVertices.Contains(node)) {
-      NodeVertices.ChangeFromKey(node).Append(vertex);
-    }
-    else {
-      TopTools_ListOfShape vlist;
-      vlist.Append(vertex);
-      NodeVertices.Add(node,vlist);
-    }
-  }
-  Standard_Integer nbNodes = NodeVertices.Extent();
-#ifdef DEB
-  cout << "Glueing " << nbNodes << " nodes..." << endl;
-#endif
-  // Create array of boxes with nodes
-  Handle(Bnd_HArray1OfBox) hSetBoxes = new Bnd_HArray1OfBox(1,nbNodes);
-  Bnd_Box aBox;
-  Standard_Real eps = Tolerance*0.5;
-  for (i = 1; i <= nbNodes; i++) {
-    gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(NodeVertices.FindKey(i)));
-    aBox.Set(pt);
-    aBox.Enlarge(eps);
-    hSetBoxes->SetValue(i,aBox);
-  }
-  // Merge nearest nodes
-  TopTools_IndexedDataMapOfShapeShape NodeNearestNode;
-  for (i = 1; i <= nbNodes; i++) {
-    TopoDS_Vertex node1 = TopoDS::Vertex(NodeVertices.FindKey(i));
-    // Find near nodes
-    TColStd_ListOfInteger listIndex;
-    SortBox(hSetBoxes,hSetBoxes->Value(i),listIndex);
-    if (listIndex.IsEmpty()) continue;
-    // Retrieve list of edges for the first node
-    const TopTools_ListOfShape& ledges1 = aNodeEdges(node1);
-    // Explore list of near nodes and fill the sequence of glued nodes
-    TopTools_SequenceOfShape SeqNodes;
-    TopTools_ListOfShape listNodesSameEdge;
-    gp_Pnt pt1 = BRep_Tool::Pnt(node1);
-    TColStd_ListIteratorOfListOfInteger iter1(listIndex);
-    for (; iter1.More(); iter1.Next()) {
-      TopoDS_Vertex node2 = TopoDS::Vertex(NodeVertices.FindKey(iter1.Value()));
-      if (node1 == node2) continue;
-      // Retrieve list of edges for the second node
-      const TopTools_ListOfShape& ledges2 = aNodeEdges(node2);
-      // Check merging condition for the pair of nodes
-      Standard_Integer Status = 0, isSameEdge = Standard_False;
-      // Explore edges of the first node
-      TopTools_ListIteratorOfListOfShape Ie1(ledges1);
-      for (; Ie1.More() && !Status && !isSameEdge; Ie1.Next()) {
-	const TopoDS_Shape& e1 = Ie1.Value();
-	// Obtain real vertex from edge
-	TopoDS_Shape v1 = node1;
-	{ //szv: Use brackets to destroy local variables
-	  TopoDS_Vertex ov1, ov2;
-	  TopExp::Vertices(TopoDS::Edge(e1),ov1,ov2);
-	  if (aVertexNode.Contains(ov1)) {
-	    if (node1.IsSame(aVertexNode.FindFromKey(ov1))) v1 = ov1;
-	  }
-	  if (aVertexNode.Contains(ov2)) {
-	    if (node1.IsSame(aVertexNode.FindFromKey(ov2))) v1 = ov2;
-	  }
-	}
-	// Create map of faces for e1
-	TopTools_MapOfShape Faces1;
-	const TopTools_ListOfShape& lfac1 = aBoundFaces.FindFromKey(e1);
-	if (lfac1.Extent()) {
-	  TopTools_ListIteratorOfListOfShape itf(lfac1);
-	  for (; itf.More(); itf.Next())
-	    if (!itf.Value().IsNull())
-	      Faces1.Add(itf.Value());
-	}
-	// Explore edges of the second node
-        TopTools_ListIteratorOfListOfShape Ie2(ledges2);
-	for (; Ie2.More() && !Status && !isSameEdge; Ie2.Next()) {
-	  const TopoDS_Shape& e2 = Ie2.Value();
-	  // Obtain real vertex from edge
-	  TopoDS_Shape v2 = node2;
-	  { //szv: Use brackets to destroy local variables
-	    TopoDS_Vertex ov1, ov2;
-	    TopExp::Vertices(TopoDS::Edge(e2),ov1,ov2);
-	    if (aVertexNode.Contains(ov1)) {
-	      if (node2.IsSame(aVertexNode.FindFromKey(ov1))) v2 = ov1;
-	    }
-	    if (aVertexNode.Contains(ov2)) {
-	      if (node2.IsSame(aVertexNode.FindFromKey(ov2))) v2 = ov2;
-	    }
-	  }
-	  // Explore faces for e2
-	  const TopTools_ListOfShape& lfac2 = aBoundFaces.FindFromKey(e2);
-	  if (lfac2.Extent()) {
-	    TopTools_ListIteratorOfListOfShape itf(lfac2);
-	    for (; itf.More() && !Status && !isSameEdge; itf.Next()) {
-	      // Check merging conditions for the same face
-	      if (Faces1.Contains(itf.Value())) {
-		Standard_Integer stat = IsMergedVertices(itf.Value(),e1,e2,v1,v2);
-		if (stat == 1) isSameEdge = Standard_True;
-		else Status = stat;
-	      }
-	    }
-	  }
-          else if (Faces1.IsEmpty() && e1 == e2) {
-            Standard_Integer stat = IsMergedVertices(TopoDS_Face(),e1,e1,v1,v2);
-            if (stat == 1) isSameEdge = Standard_True;
-            else Status = stat;
-            break;
-          }
-	}
-      }
-      if (Status) continue;
-      if (isSameEdge) listNodesSameEdge.Append(node2);
-      // Append near node to the sequence
-      gp_Pnt pt2 = BRep_Tool::Pnt(node2);
-      Standard_Real dist = pt1.Distance(pt2);
-      if (dist < Tolerance) {
-	Standard_Boolean isIns = Standard_False;
-	for (Standard_Integer kk = 1; kk <= SeqNodes.Length() && !isIns; kk++) {
-	  gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(SeqNodes.Value(kk)));
-	  if (dist < pt1.Distance(pt)) {
-	    SeqNodes.InsertBefore(kk,node2);
-	    isIns = Standard_True;
-	  }
-	}
-	if (!isIns) SeqNodes.Append(node2);
-      }
-    }
-    if (SeqNodes.Length()) {
-      // Remove nodes near to some other from the same edge
-      if (listNodesSameEdge.Extent()) {
-	TopTools_ListIteratorOfListOfShape lInt(listNodesSameEdge);
-	for (; lInt.More(); lInt.Next()) {
-	  const TopoDS_Vertex& n2 = TopoDS::Vertex(lInt.Value());
-	  gp_Pnt p2 = BRep_Tool::Pnt(n2);
-	  for (Standard_Integer k = 1; k <= SeqNodes.Length(); ) {
-	    const TopoDS_Vertex& n1 = TopoDS::Vertex(SeqNodes.Value(k));
-	    if (n1 != n2) {
-	      gp_Pnt p1 = BRep_Tool::Pnt(n1);
-	      if (p2.Distance(p1) >= pt1.Distance(p1)) { k++; continue; }
-	    }
-	    SeqNodes.Remove(k);
-	  }
-	}
-      }
-      // Bind nearest node if at least one exists
-      if (SeqNodes.Length())
-	NodeNearestNode.Add(node1,SeqNodes.First());
-    }
-  }
-
-  // Create new nodes for chained nearest nodes
-  if (NodeNearestNode.IsEmpty()) return Standard_False;
-  hSetBoxes.Nullify();
-
-  return CreateNewNodes(NodeNearestNode,NodeVertices,aVertexNode,aNodeEdges);
-}
-
-void BRepBuilderAPI_Sewing::VerticesAssembling()
-{
-  Standard_Integer nbVert = myVertexNode.Extent();
-  Standard_Integer nbVertFree = myVertexNodeFree.Extent();
-  if (nbVert || nbVertFree) {
-    // Fill map node -> sections
-    Standard_Integer i;
-    for (i = 1; i <= myBoundFaces.Extent(); i++) {
-      TopoDS_Shape bound = myBoundFaces.FindKey(i);
-      for (TopoDS_Iterator itv(bound,Standard_False); itv.More(); itv.Next()) {
-	TopoDS_Shape node = itv.Value();
-	if (myNodeSections.IsBound(node))
-	  myNodeSections(node).Append(bound);
-	else {
-	  TopTools_ListOfShape lbnd;
-	  lbnd.Append(bound);
-	  myNodeSections.Bind(node,lbnd);
-	}
-      }
-    }
-    // Glue vertices
-    if (nbVert) {
-#ifdef DEB
-      cout << "Assemble " << nbVert << " vertices on faces..." << endl;
-#endif
-      while (GlueVertices(myVertexNode,myNodeSections,myBoundFaces,myTolerance));
-    }
-    if (nbVertFree) {
-#ifdef DEB
-      cout << "Assemble " << nbVertFree << " vertices on floating edges..." << endl;
-#endif
-      while (GlueVertices(myVertexNodeFree,myNodeSections,myBoundFaces,myTolerance));
-    }
-  }
-}
-
-//=======================================================================
-//function : replaceNMVertices
-//purpose  : internal use (static)
-//=======================================================================
-static void replaceNMVertices(const TopoDS_Edge& theEdge, 
-                              const TopoDS_Vertex& theV1,
-                              const TopoDS_Vertex& theV2,
-                              const Handle(BRepTools_ReShape)& theReShape)
-{
-  //To keep NM vertices on edge
-  TopTools_SequenceOfShape aSeqNMVert;
-  TColStd_SequenceOfReal aSeqNMPars;
-  Standard_Boolean hasNMVert = findNMVertices(theEdge,aSeqNMVert,aSeqNMPars);
-  if(!hasNMVert)
-    return;
-  Standard_Real first, last;
-  BRep_Tool::Range(theEdge, first, last);
-  TopLoc_Location aLoc;
-  Handle(Geom_Curve) c3d = BRep_Tool::Curve(theEdge,aLoc,first, last);
-  if(c3d.IsNull())
-    return;
-  TopTools_SequenceOfShape aEdVert;
-  TColStd_SequenceOfReal aEdParams;
-  Standard_Boolean isCopyEdge = Standard_False;
-  Standard_Integer i =1, nb = aSeqNMPars.Length();
-    
-  for( ; i <= nb;i++) {
-    Standard_Real apar = aSeqNMPars.Value(i);
-    if(fabs(apar - first) <= Precision::PConfusion()) {
-      theReShape->Replace(aSeqNMVert.Value(i),theV1);
-      continue;
-    }
-    if(fabs(apar - last) <= Precision::PConfusion()) {
-      theReShape->Replace(aSeqNMVert.Value(i),theV2);
-      continue;
-    }
-    TopoDS_Shape aV = aSeqNMVert.Value(i);
-    Standard_Integer j =1;
-    for( ; j <= aEdParams.Length();j++) {
-      Standard_Real apar2 = aEdParams.Value(j);
-      if(fabs(apar - apar2) <= Precision::PConfusion()) {
-        theReShape->Replace(aV,aEdVert.Value(j));
-        break;
-      }
-      else if(apar < apar2) {
-        TopoDS_Shape anewV = aV.EmptyCopied();
-        aEdVert.InsertBefore(j,anewV);
-        aEdParams.InsertBefore(j,apar);
-        BRep_ListOfPointRepresentation& alistrep = 
-          (*((Handle(BRep_TVertex)*)&anewV.TShape()))->ChangePoints();
-        Handle(BRep_PointOnCurve) aPRep = new BRep_PointOnCurve(apar,c3d,aLoc);
-        alistrep.Append(aPRep);
-        theReShape->Replace(aV,anewV);
-        break;
-      }
-    }
-    if (j > aEdParams.Length()) {
-      TopoDS_Shape anewV = aV.EmptyCopied();
-      aEdVert.Append(anewV);
-      aEdParams.Append(apar);
-      BRep_ListOfPointRepresentation& alistrep = 
-        (*((Handle(BRep_TVertex)*) &anewV.TShape()))->ChangePoints();
-      Handle(BRep_PointOnCurve) aPRep = new BRep_PointOnCurve(apar,c3d,aLoc);
-      alistrep.Append(aPRep);
-      theReShape->Replace(aV,anewV);
-    }
-  }
-  
-  Standard_Integer newnb = aEdParams.Length();
-  if(newnb < nb) {
-    
-    TopoDS_Shape anewEdge = theEdge.EmptyCopied();
-    TopAbs_Orientation anOri = theEdge.Orientation();
-    anewEdge.Orientation(TopAbs_FORWARD);
-    BRep_Builder aB;
-    aB.Add(anewEdge,theV1);
-    aB.Add(anewEdge,theV2);
-    
-    for( i =1; i <= aEdVert.Length();i++) 
-      aB.Add(anewEdge,aEdVert.Value(i));
-    anewEdge.Orientation(anOri);
-    theReShape->Replace(theEdge,anewEdge);
-  }
- 
-}
-
-//=======================================================================
-//function : ReplaceEdge
-//purpose  : internal use (static)
-//=======================================================================
-
-static void ReplaceEdge(const TopoDS_Shape& oldEdge,
-			const TopoDS_Shape& theNewShape,
-			const Handle(BRepTools_ReShape)& aReShape)
-{
-  TopoDS_Shape oldShape = aReShape->Apply(oldEdge);
-  TopoDS_Shape newShape = aReShape->Apply(theNewShape);
-  if (oldShape.IsSame(newShape)|| aReShape->IsRecorded(newShape)) return;
-  
-
-  aReShape->Replace(oldShape,newShape);
-  TopoDS_Vertex V1old,V2old,V1new,V2new;
-  TopExp::Vertices(TopoDS::Edge(oldShape),V1old,V2old);
-  TopAbs_Orientation Orold = oldShape.Orientation();
-  TopAbs_Orientation Ornew = Orold;
-  if (newShape.ShapeType() == TopAbs_EDGE) {
-    TopoDS_Edge aEn = TopoDS::Edge(newShape);
-    TopExp::Vertices(aEn,V1new,V2new);
-    Ornew = aEn.Orientation();
-    replaceNMVertices(aEn,V1new,V2new,aReShape);
-  }
-  else if (newShape.ShapeType() == TopAbs_WIRE) {
-    for (TopExp_Explorer aex(newShape,TopAbs_EDGE); aex.More(); aex.Next()) {
-      TopoDS_Edge ed = TopoDS::Edge(aex.Current());
-      Ornew = ed.Orientation();
-      TopoDS_Vertex aV1,aV2;
-      TopExp::Vertices(ed,aV1,aV2);
-      replaceNMVertices(ed,aV1,aV2,aReShape);
-      if (V1new.IsNull()) 
-        V1new = aV1;
-      V2new =aV2;
-    }
-  }
-  
-  V1new.Orientation(V1old.Orientation());
-  V2new.Orientation(V2old.Orientation());
-  if (V1old.IsSame(V2old) && !V1old.IsSame(V1new)&& !aReShape->IsRecorded(V1new)) {
-    aReShape->Replace(V1old,V1new);
-    return;
-  }
-  if (Orold == Ornew) {
-    V1new.Orientation(V1old.Orientation());
-    V2new.Orientation(V2old.Orientation());
-    if (!V1old.IsSame(V1new) && !V1old.IsSame(V2new)&& !aReShape->IsRecorded(V1new))
-      aReShape->Replace(V1old,V1new);
-    if (!V2old.IsSame(V2new) && !V2old.IsSame(V1new)&& !aReShape->IsRecorded(V2new))
-      aReShape->Replace(V2old,V2new);
-  }
-  else {
-    V1new.Orientation(V2old.Orientation());
-    V2new.Orientation(V1old.Orientation());
-    if (!V1old.IsSame(V2new) && !V1old.IsSame(V1new)&& !aReShape->IsRecorded(V2new)) 
-      aReShape->Replace(V1old,V2new);
-    if (!V2old.IsSame(V2new) && !V2old.IsSame(V1new)&& !aReShape->IsRecorded(V1new))
-      aReShape->Replace(V2old,V1new);
-  }
-}
-
-//=======================================================================
-//function : Merging
-//purpose  : Modifies :
-//                   myHasFreeBound
-//
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Merging(const Standard_Boolean /* firstTime */)
-{
-  BRep_Builder B;
-//  TopTools_MapOfShape MergedEdges;
-  for (Standard_Integer i = 1; i <= myBoundFaces.Extent(); i++) {
-
-    TopoDS_Shape bound = myBoundFaces.FindKey(i);
-
-    // If bound was already merged - continue
-    if (myMergedEdges.Contains(bound)) continue;
-
-    if (!myBoundFaces(i).Extent()) {
-      // Merge free edge - only vertices
-      TopoDS_Vertex no1, no2;
-      TopExp::Vertices(TopoDS::Edge(bound),no1,no2);
-      TopoDS_Shape nno1 = no1, nno2 = no2;
-      if (myVertexNodeFree.Contains(no1))
-	nno1 = myVertexNodeFree.FindFromKey(no1);
-      if (myVertexNodeFree.Contains(no2))
-	nno2 = myVertexNodeFree.FindFromKey(no2);
-      if (!no1.IsSame(nno1)) {
-        nno1.Orientation(no1.Orientation());
-	myReShape->Replace(no1,nno1);
-      }
-      if (!no2.IsSame(nno2)) {
-        nno2.Orientation(no2.Orientation());
-	myReShape->Replace(no2,nno2);
-      }
-      myMergedEdges.Add(bound);
-      continue;
-    }
-
-    // Check for previous splitting, build replacing wire
-    TopoDS_Wire BoundWire;
-    Standard_Boolean isPrevSplit = Standard_False;
-    Standard_Boolean hasCuttingSections = myBoundSections.IsBound(bound);
-    if (hasCuttingSections) {
-      B.MakeWire(BoundWire);
-      BoundWire.Orientation(bound.Orientation());
-      // Iterate on cutting sections
-      TopTools_ListIteratorOfListOfShape its(myBoundSections(bound));
-      for (; its.More(); its.Next()) {
-	TopoDS_Shape section = its.Value();
-	B.Add(BoundWire,section);
-	if (myMergedEdges.Contains(section)) isPrevSplit = Standard_True;
-      }
-    }
-
-    // Merge with bound
-    TopTools_DataMapOfShapeShape MergedWithBound;
-    if (!isPrevSplit) {
-      // Obtain sequence of edges merged with bound
-      TopTools_SequenceOfShape seqMergedWithBound;
-      TColStd_SequenceOfInteger seqMergedWithBoundOri;
-      if (MergedNearestEdges(bound,seqMergedWithBound,seqMergedWithBoundOri)) {
-	// Store bound in the map
-	MergedWithBound.Bind(bound,bound);
-	// Iterate on edges merged with bound
-	Standard_Integer ii = 1;
-	while (ii <= seqMergedWithBound.Length()) {
-	  TopoDS_Shape iedge = seqMergedWithBound.Value(ii);
-	  // Remove edge if recorded as merged
-	  Standard_Boolean isRejected = (myMergedEdges.Contains(iedge) || MergedWithBound.IsBound(iedge));
-	  if (!isRejected) {
-	    if (myBoundSections.IsBound(iedge)) {
-	      // Edge is splitted - check sections
-	      TopTools_ListIteratorOfListOfShape lit(myBoundSections(iedge));
-	      for (; lit.More() && !isRejected; lit.Next()) {
-		const TopoDS_Shape& sec = lit.Value();
-		// Remove edge (bound) if at least one of its sections already merged
-		isRejected = (myMergedEdges.Contains(sec) || MergedWithBound.IsBound(sec));
-	      }
-	    }
-	    if (!isRejected) {
-	      if (mySectionBound.IsBound(iedge)) {
-		// Edge is a section - check bound
-		const TopoDS_Shape& bnd = mySectionBound(iedge);
-		// Remove edge (section) if its bound already merged
-		isRejected = (myMergedEdges.Contains(bnd) || MergedWithBound.IsBound(bnd));
-	      }
-	    }
-	  }
-	  // To the next merged edge
-	  if (isRejected) {
-	    // Remove rejected edge
-	    seqMergedWithBound.Remove(ii);
-	    seqMergedWithBoundOri.Remove(ii);
-	  }
-	  else {
-	    // Process accepted edge
-	    MergedWithBound.Bind(iedge,iedge);
-	    ii++;
-	  }
-	}
-	Standard_Integer nbMerged = seqMergedWithBound.Length();
-	if (nbMerged) {
-	  // Create same parameter edge
-	  TopTools_MapOfShape ActuallyMerged;
-	  TopoDS_Edge MergedEdge = SameParameterEdge(bound,seqMergedWithBound,
-						     seqMergedWithBoundOri,
-						     ActuallyMerged,myReShape);
-	  Standard_Boolean isForward = Standard_False;
-	  if (!MergedEdge.IsNull()) isForward = (MergedEdge.Orientation() == TopAbs_FORWARD);
-	  // Process actually merged edges
-	  Standard_Integer nbActuallyMerged = 0;
-	  for (ii = 1; ii <= nbMerged; ii++) {
-	    TopoDS_Shape iedge = seqMergedWithBound(ii);
-	    if (ActuallyMerged.Contains(iedge)) {
-	      nbActuallyMerged++;
-	      // Record merged edge in the map
-	      TopAbs_Orientation orient = iedge.Orientation();
-	      if (!isForward) orient = TopAbs::Reverse(orient);
-	      if (!seqMergedWithBoundOri(ii)) orient = TopAbs::Reverse(orient);
-	      MergedWithBound.ChangeFind(iedge) = MergedEdge.Oriented(orient);
-	    }
-	    else MergedWithBound.UnBind(iedge);
-	  }
-	  if (nbActuallyMerged) {
-	    // Record merged bound in the map
-	    TopAbs_Orientation orient = bound.Orientation();
-	    if (!isForward) orient = TopAbs::Reverse(orient);
-	    MergedWithBound.ChangeFind(bound) = MergedEdge.Oriented(orient);
-	  }
-	  nbMerged = nbActuallyMerged;
-	}
-	// Remove bound from the map if not finally merged
-	if (!nbMerged) MergedWithBound.UnBind(bound);
-      }
-    }
-    Standard_Boolean isMerged = MergedWithBound.Extent();
-
-    // Merge with cutting sections
-    Handle(BRepTools_ReShape) SectionsReShape = new BRepTools_ReShape;
-    TopTools_DataMapOfShapeShape MergedWithSections;
-    if (hasCuttingSections) {
-      // Iterate on cutting sections
-      TopTools_ListIteratorOfListOfShape its(myBoundSections(bound));
-      for (; its.More(); its.Next()) {
-	// Retrieve cutting section
-	TopoDS_Shape section = its.Value();
-	// Skip section if already merged
-	if (myMergedEdges.Contains(section)) continue;
-	// Merge cutting section
-	TopTools_SequenceOfShape seqMergedWithSection;
-	TColStd_SequenceOfInteger seqMergedWithSectionOri;
-	if (MergedNearestEdges(section,seqMergedWithSection,seqMergedWithSectionOri)) {
-	  // Store section in the map
-	  MergedWithSections.Bind(section,section);
-	  // Iterate on edges merged with section
-	  Standard_Integer ii = 1;
-	  while (ii <= seqMergedWithSection.Length()) {
-	    TopoDS_Shape iedge = seqMergedWithSection.Value(ii);
-	    // Remove edge if recorded as merged
-	    Standard_Boolean isRejected = (myMergedEdges.Contains(iedge) || MergedWithSections.IsBound(iedge));
-	    if (!isRejected) {
-	      if (myBoundSections.IsBound(iedge)) {
-		// Edge is splitted - check sections
-		TopTools_ListIteratorOfListOfShape lit(myBoundSections(iedge));
-		for (; lit.More() && !isRejected; lit.Next()) {
-		  const TopoDS_Shape& sec = lit.Value();
-		  // Remove edge (bound) if at least one of its sections already merged
-		  isRejected = (myMergedEdges.Contains(sec) || MergedWithSections.IsBound(sec));
-		}
-	      }
-	      if (!isRejected) {
-		if (mySectionBound.IsBound(iedge)) {
-		  // Edge is a section - check bound
-		  const TopoDS_Shape& bnd = mySectionBound(iedge);
-		  // Remove edge (section) if its bound already merged
-		  isRejected = (myMergedEdges.Contains(bnd) || MergedWithSections.IsBound(bnd));
-		}
-	      }
-	    }
-	    // To the next merged edge
-	    if (isRejected) {
-	      // Remove rejected edge
-	      seqMergedWithSection.Remove(ii);
-	      seqMergedWithSectionOri.Remove(ii);
-	    }
-	    else {
-	      // Process accepted edge
-	      MergedWithSections.Bind(iedge,iedge);
-	      ii++;
-	    }
-	  }
-	  Standard_Integer nbMerged = seqMergedWithSection.Length();
-	  if (nbMerged) {
-	    // Create same parameter edge
-	    TopTools_MapOfShape ActuallyMerged;
-	    TopoDS_Edge MergedEdge = SameParameterEdge(section,seqMergedWithSection,
-						       seqMergedWithSectionOri,
-						       ActuallyMerged,SectionsReShape);
-	    Standard_Boolean isForward = Standard_False;
-	    if (!MergedEdge.IsNull()) isForward = (MergedEdge.Orientation() == TopAbs_FORWARD);
-	    // Process actually merged edges
-	    Standard_Integer nbActuallyMerged = 0;
-	    for (ii = 1; ii <= nbMerged; ii++) {
-	      TopoDS_Shape iedge = seqMergedWithSection(ii);
-	      if (ActuallyMerged.Contains(iedge)) {
-		nbActuallyMerged++;
-		// Record merged edge in the map
-		TopAbs_Orientation orient = iedge.Orientation();
-		if (!isForward) orient = TopAbs::Reverse(orient);
-		if (!seqMergedWithSectionOri(ii)) orient = TopAbs::Reverse(orient);
-		TopoDS_Shape oedge = MergedEdge.Oriented(orient);
-		MergedWithSections.ChangeFind(iedge) = oedge;
-		ReplaceEdge(myReShape->Apply(iedge),oedge,SectionsReShape);
-	      }
-	      else MergedWithSections.UnBind(iedge);
-	    }
-	    if (nbActuallyMerged) {
-	      // Record merged section in the map
-	      TopAbs_Orientation orient = section.Orientation();
-	      if (!isForward) orient = TopAbs::Reverse(orient);
-	      TopoDS_Shape oedge = MergedEdge.Oriented(orient);
-	      MergedWithSections.ChangeFind(section) = oedge;
-	      ReplaceEdge(myReShape->Apply(section),oedge,SectionsReShape);
-	    }
-	    nbMerged = nbActuallyMerged;
-	  }
-	  // Remove section from the map if not finally merged
-	  if (!nbMerged) MergedWithSections.UnBind(section);
-	}
-	else if (isMerged) {
-	  // Reject merging of sections
-	  MergedWithSections.Clear();
-	  break;
-	}
-      }
-    }
-    Standard_Boolean isMergedSplit = MergedWithSections.Extent();
-
-    if (!isMerged && !isMergedSplit) {
-      // Nothing was merged in this iteration
-      if (isPrevSplit) {
-	// Replace previously splitted bound
-	myReShape->Replace(myReShape->Apply(bound),myReShape->Apply(BoundWire));
-      }
-//      else if (hasCuttingSections) {
-//	myBoundSections.UnBind(bound); //szv: are you sure ???
-//      }
-      continue;
-    }
-
-    // Set splitting flag
-    Standard_Boolean isSplitted = ((!isMerged && isMergedSplit) || isPrevSplit);
-
-    // Choose between bound and sections merging
-    if (isMerged && isMergedSplit && !isPrevSplit) {
-      // Fill map of merged cutting sections
-      TopTools_MapOfShape MapSplitEdges;
-      TopTools_DataMapIteratorOfDataMapOfShapeShape itm;
-      for (itm.Initialize(MergedWithSections); itm.More(); itm.Next()) {
-	TopoDS_Shape edge = itm.Key();
-	MapSplitEdges.Add(edge);
-      }
-      // Iterate on edges merged with bound
-      for (itm.Initialize(MergedWithBound); itm.More(); itm.Next()) {
-	// Retrieve edge merged with bound
-	TopoDS_Shape edge = itm.Key();
-	// Remove edge from the map
-	if (MapSplitEdges.Contains(edge)) MapSplitEdges.Remove(edge);
-	if (myBoundSections.IsBound(edge)) {
-	  // Edge has cutting sections
-	  TopTools_ListIteratorOfListOfShape its(myBoundSections(edge));
-	  for (; its.More(); its.Next()) {
-	    TopoDS_Shape sec = its.Value();
-	    // Remove section from the map
-	    if (MapSplitEdges.Contains(sec)) MapSplitEdges.Remove(sec);
-	  }
-	}
-      }
-      // Calculate section merging tolerance
-      Standard_Real MinSplitTol = RealLast();
-      TopTools_MapIteratorOfMapOfShape im(MapSplitEdges);
-      for (; im.More(); im.Next()) {
-        TopoDS_Edge edge = TopoDS::Edge(MergedWithSections(im.Key()));
-	MinSplitTol = Min(MinSplitTol,BRep_Tool::Tolerance(edge));
-      }
-      // Calculate bound merging tolerance
-      TopoDS_Edge BoundEdge = TopoDS::Edge(MergedWithBound(bound));
-      Standard_Real BoundEdgeTol = BRep_Tool::Tolerance(BoundEdge);
-      isSplitted = ((MinSplitTol < BoundEdgeTol+MinTolerance()) || myNonmanifold);
-      isSplitted = (!MapSplitEdges.IsEmpty() && isSplitted);
-    }
-
-    if (isSplitted) {
-      // Merging of cutting sections
-      //myMergedEdges.Add(bound);
-      myReShape->Replace(myReShape->Apply(bound),myReShape->Apply(BoundWire));
-      TopTools_DataMapIteratorOfDataMapOfShapeShape itm(MergedWithSections);
-      for (; itm.More(); itm.Next()) {
-	TopoDS_Shape oldedge = itm.Key();
-	TopoDS_Shape newedge = SectionsReShape->Apply(itm.Value());
-	ReplaceEdge(myReShape->Apply(oldedge),newedge,myReShape);
-	myMergedEdges.Add(oldedge);
-        if (myBoundSections.IsBound(oldedge)) myBoundSections.UnBind(oldedge);
-       
-      }
-    }
-    else {
-      // Merging of initial bound
-      TopTools_DataMapIteratorOfDataMapOfShapeShape itm(MergedWithBound);
-      //myMergedEdges.Add(bound);
-      for (; itm.More(); itm.Next()) {
-	TopoDS_Shape oldedge = itm.Key();
-	TopoDS_Shape newedge = itm.Value();
-	ReplaceEdge(myReShape->Apply(oldedge),newedge,myReShape);
-	myMergedEdges.Add(oldedge);
-        if (myBoundSections.IsBound(oldedge)) myBoundSections.UnBind(oldedge);
-      }
-      if (myBoundSections.IsBound(bound)) myBoundSections.UnBind(bound);
-      if(!myMergedEdges.Contains(bound))
-          myMergedEdges.Add(bound);
-    }
-  }
-
-  myNbVertices = myVertexNode.Extent() + myVertexNodeFree.Extent();
-  myNodeSections.Clear();
-  myVertexNode.Clear();
-  myVertexNodeFree.Clear();
-  myCuttingNode.Clear();
-}
-
-//=======================================================================
-//function : MergedNearestEdges
-//purpose  : 
-//=======================================================================
-
-Standard_Boolean BRepBuilderAPI_Sewing::MergedNearestEdges(const TopoDS_Shape& edge,
-						     TopTools_SequenceOfShape& SeqMergedEdge,
-						     TColStd_SequenceOfInteger& SeqMergedOri)
-{
-  // Retrieve edge nodes
-  TopoDS_Vertex no1, no2;
-  TopExp::Vertices(TopoDS::Edge(edge),no1,no2);
-  TopoDS_Shape nno1 = no1, nno2 = no2;
-  Standard_Boolean isNode1 = myVertexNode.Contains(no1);
-  Standard_Boolean isNode2 = myVertexNode.Contains(no2);
-  if (isNode1) nno1 = myVertexNode.FindFromKey(no1);
-  if (isNode2) nno2 = myVertexNode.FindFromKey(no2);
-
-  // Fill map of nodes connected to the node #1
-  TopTools_MapOfShape mapVert1;
-  mapVert1.Add(nno1);
-  if (myCuttingNode.IsBound(nno1)) {
-    TopTools_ListIteratorOfListOfShape ilv(myCuttingNode(nno1));
-    for (; ilv.More(); ilv.Next()) {
-      TopoDS_Shape v1 = ilv.Value();
-      mapVert1.Add(v1);
-      if (!isNode1 && myCuttingNode.IsBound(v1)) {
-	TopTools_ListIteratorOfListOfShape ilvn(myCuttingNode(v1));
-	for (; ilvn.More(); ilvn.Next()) {
-	  TopoDS_Shape vn = ilvn.Value();
-	  mapVert1.Add(vn);
-	}
-      }
-    }
-  }
-
-  // Fill map of nodes connected to the node #2
-  TopTools_MapOfShape mapVert2;
-  mapVert2.Add(nno2);
-  if (myCuttingNode.IsBound(nno2)) {
-    TopTools_ListIteratorOfListOfShape ilv(myCuttingNode(nno2));
-    for (; ilv.More(); ilv.Next()) {
-      TopoDS_Shape v1 = ilv.Value();
-      mapVert2.Add(v1);
-      if (!isNode2 && myCuttingNode.IsBound(v1)) {
-	TopTools_ListIteratorOfListOfShape ilvn(myCuttingNode(v1));
-	for (; ilvn.More(); ilvn.Next()) {
-	  TopoDS_Shape vn = ilvn.Value();
-	  mapVert2.Add(vn);
-	}
-      }
-    }
-  }
-
-  // Find all possible contigous edges
-  TopTools_SequenceOfShape seqEdges;
-  seqEdges.Append(edge);
-  TopTools_MapOfShape mapEdges;
-  mapEdges.Add(edge);
-  for (TopTools_MapIteratorOfMapOfShape imv1(mapVert1); imv1.More(); imv1.Next()) {
-    TopoDS_Shape node1 = imv1.Key();
-    if (!myNodeSections.IsBound(node1)) continue;
-    TopTools_ListIteratorOfListOfShape ilsec(myNodeSections(node1));
-    for (; ilsec.More(); ilsec.Next()) {
-      TopoDS_Shape sec = ilsec.Value();
-      if (sec.IsSame(edge)) continue;
-      // Retrieve section nodes
-      TopoDS_Vertex vs1, vs2;
-      TopExp::Vertices(TopoDS::Edge(sec),vs1,vs2);
-      TopoDS_Shape vs1n = vs1, vs2n = vs2;
-      if (myVertexNode.Contains(vs1)) vs1n = myVertexNode.FindFromKey(vs1);
-      if (myVertexNode.Contains(vs2)) vs2n = myVertexNode.FindFromKey(vs2);
-      if ((mapVert1.Contains(vs1n) && mapVert2.Contains(vs2n)) ||
-	  (mapVert1.Contains(vs2n) && mapVert2.Contains(vs1n)))
-	if (mapEdges.Add(sec)) {
-	  // Check for rejected cutting
-	  Standard_Boolean isRejected = Standard_False;
-	  if (mySectionBound.IsBound(sec)) {
-	    const TopoDS_Shape& bnd = mySectionBound(sec);
-	    isRejected = !myBoundSections.IsBound(bnd);
-	  }
-	  if (!isRejected) seqEdges.Append(sec);
-	}
-    }
-  }
-  mapEdges.Clear();
-
-  Standard_Boolean success = Standard_False;
-
-  Standard_Integer nbSection = seqEdges.Length();
-  if (nbSection > 1) {
-    // Find the longest edge CCI60011
-    Standard_Integer i, indRef = 1;
-    if (myNonmanifold) {
-      Standard_Real lenRef = 0.;
-      for (i = 1; i <= nbSection; i++) {
-	Standard_Real f, l;
-	Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(seqEdges(i)), f, l);
-	GeomAdaptor_Curve cAdapt(c3d);
-	Standard_Real len = GCPnts_AbscissaPoint::Length(cAdapt, f, l);
-	if (len > lenRef) { indRef = i; lenRef = len; }
-      }
-      if (indRef != 1) {
-	TopoDS_Shape longEdge = seqEdges(indRef);
-	seqEdges(indRef) = seqEdges(1);
-	seqEdges(1) = longEdge;
-      }
-    }
-
-    // Find merging candidates
-    TColStd_SequenceOfInteger seqForward;
-    TColStd_SequenceOfInteger seqCandidates;
-    TColStd_IndexedMapOfInteger mapReference;
-    mapReference.Add(1); // Add index of reference section
-    if (FindCandidates(seqEdges,mapReference,seqCandidates,seqForward)) {
-      Standard_Integer nbCandidates = seqCandidates.Length();
-      // Check if reference section is merged reversed
-      Standard_Boolean toReverse = Standard_False;
-      if (indRef != 1) {
-	// Find reference edge in candidates
-	Standard_Boolean isFound = Standard_False;
-	for (i = 1; i <= nbCandidates && !isFound; i++) {
-	  isFound = (seqCandidates(i) == indRef);
-	  if (isFound) {
-	    // Record orientation
-	    toReverse = !seqForward(i);
-	    // Restore first edge
-	    seqCandidates(i) = 1;
-	    seqForward(i) = 1;
-	  }
-	}
-	// Fail if reference is not in candidates
-	if (!isFound) return Standard_False;
-      }
-      // Record candidate sections
-      for (i = 1; i <= nbCandidates; i++) {
-	// Retrieve merged edge
-	TopoDS_Shape iedge = seqEdges(seqCandidates(i));
-	Standard_Integer ori =
-	  ((seqForward(i) && toReverse) || (!seqForward(i) && !toReverse))? 0 : 1;
-	SeqMergedEdge.Append(iedge);
-	SeqMergedOri.Append(ori);
-	if (!myNonmanifold) break;
-      }
-      success = nbCandidates;
-    }
-  }
-
-  return success;
-}
-
-//=======================================================================
-//function : Cutting
-//purpose  : Modifies :
-//                     myBoundSections
-//                     myNodeSections
-//                     myCuttingNode
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::Cutting()
-{
-  Standard_Integer i, nbVertices = myVertexNode.Extent();
-  if (!nbVertices) return;
-  // Create a sort box with vertices
-  Standard_Real eps = myTolerance*0.5;
-  Handle(Bnd_HArray1OfBox) hSetBoxes = new Bnd_HArray1OfBox(1,nbVertices);
-  for (i = 1; i <= nbVertices; i++) {
-    gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(myVertexNode.FindKey(i)));
-    Bnd_Box aBox;
-    aBox.Set(pt);
-    aBox.Enlarge(eps);
-    hSetBoxes->ChangeValue(i) = aBox;
-  }
-  Handle(Geom_Curve) c3d;
-  TopLoc_Location loc;
-  Standard_Real first, last;
-  // Iterate on all boundaries
-  Standard_Integer nbBounds = myBoundFaces.Extent();
-  for (i = 1; i <= nbBounds; i++) {
-    const TopoDS_Edge& bound = TopoDS::Edge(myBoundFaces.FindKey(i));
-    // Do not cut floating edges
-    if (!myBoundFaces(i).Extent()) continue;
-    // Create cutting sections
-    TopTools_ListOfShape listSections;
-    { //szv: Use brackets to destroy local variables
-      // Obtain bound curve
-      c3d = BRep_Tool::Curve(bound, loc, first, last);
-      if (!loc.IsIdentity()) {
-	c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-	c3d->Transform(loc.Transformation());
-      }
-      // Obtain candidate vertices
-      TopoDS_Vertex V1, V2;
-      TopTools_IndexedMapOfShape CandidateVertices;
-      { //szv: Use brackets to destroy local variables
-	// Create bounding box around curve
-	Bnd_Box aGlobalBox;
-	GeomAdaptor_Curve adptC(c3d,first,last);
-	BndLib_Add3dCurve::Add(adptC,myTolerance,aGlobalBox);
-	// Sort vertices to find candidates
-	TColStd_ListOfInteger listIndex;
-	SortBox(hSetBoxes,aGlobalBox,listIndex);
-	// Skip bound if no node is in the boundind box
-	if (!listIndex.Extent()) continue;
-	// Retrieve bound nodes
-	TopExp::Vertices(bound,V1,V2);
-	const TopoDS_Shape& Node1 = myVertexNode.FindFromKey(V1);
-	const TopoDS_Shape& Node2 = myVertexNode.FindFromKey(V2);
-	// Fill map of candidate vertices
-	TColStd_ListIteratorOfListOfInteger itl(listIndex);
-	for (; itl.More(); itl.Next()) {
-	  const Standard_Integer index = itl.Value();
-	  const TopoDS_Shape& Node = myVertexNode.FindFromIndex(index);
-	  if (!Node.IsSame(Node1) && !Node.IsSame(Node2)) {
-	    TopoDS_Shape vertex = myVertexNode.FindKey(index);
-	    CandidateVertices.Add(vertex);
-	  }
-	}
-      }
-      Standard_Integer nbCandidates = CandidateVertices.Extent();
-      if (!nbCandidates) continue;
-      // Project vertices on curve
-      TColStd_Array1OfReal arrPara(1,nbCandidates), arrDist(1,nbCandidates);
-      TColgp_Array1OfPnt arrPnt(1,nbCandidates), arrProj(1,nbCandidates);
-      for (Standard_Integer j = 1; j <= nbCandidates; j++)
-	arrPnt(j) = BRep_Tool::Pnt(TopoDS::Vertex(CandidateVertices(j)));
-      ProjectPointsOnCurve(arrPnt,c3d,first,last,arrDist,arrPara,arrProj);
-      // Create cutting nodes
-      TopTools_SequenceOfShape seqNode;
-      TColStd_SequenceOfReal seqPara;
-      CreateCuttingNodes(CandidateVertices,bound,
-			 V1,V2,arrDist,arrPara,arrProj,seqNode,seqPara);
-      if (!seqPara.Length()) continue;
-      // Create cutting sections
-      CreateSections(bound, seqNode, seqPara, listSections);
-    }
-    if (listSections.Extent() > 1) {
-      // modification of maps:
-      //                     myBoundSections
-      TopTools_ListIteratorOfListOfShape its(listSections);
-      for (; its.More(); its.Next()) {
-	TopoDS_Shape section = its.Value();
-	// Iterate on section vertices
-	for (TopoDS_Iterator itv(section); itv.More(); itv.Next()) {
-	  TopoDS_Shape vertex = itv.Value();
-	  // Convert vertex to node
-	  if (myVertexNode.Contains(vertex))
-	    vertex = TopoDS::Vertex(myVertexNode.FindFromKey(vertex));
-	  // Update node sections
-	  if (myNodeSections.IsBound(vertex))
-	    myNodeSections.ChangeFind(vertex).Append(section);
-	  else {
-	    TopTools_ListOfShape lsec;
-	    lsec.Append(section);
-	    myNodeSections.Bind(vertex,lsec);
-	  }
-	}
-	// Store bound for section
-	mySectionBound.Bind(section,bound);
-      }
-      // Store splitted bound
-      myBoundSections.Bind(bound,listSections);
-    }
-  }
-#ifdef DEB
-  cout << "From " << nbBounds << " bounds " << myBoundSections.Extent()
-       << " were cut into " << mySectionBound.Extent() << " sections" << endl;
-#endif
-}
-
-//=======================================================================
-//function : GetSeqEdges
-//purpose  : 
-//=======================================================================
-
-static void GetSeqEdges(const TopoDS_Shape& edge,
-			TopTools_SequenceOfShape& seqEdges,
-			TopTools_DataMapOfShapeListOfShape& VertEdge)
-{
-  Standard_Integer numV = 0;
-  for (TopoDS_Iterator Iv(edge,Standard_False); Iv.More(); Iv.Next()) {
-    TopoDS_Vertex V1 = TopoDS::Vertex(Iv.Value());
-    numV++;
-    if (VertEdge.IsBound(V1)) {
-      const TopTools_ListOfShape& listEdges = VertEdge.Find(V1);
-      for (TopTools_ListIteratorOfListOfShape lIt(listEdges); lIt.More(); lIt.Next()) {
-	TopoDS_Shape edge1 = lIt.Value();
-	if (edge1.IsSame(edge)) continue;
-	Standard_Boolean isContained = Standard_False;
-	Standard_Integer i, index = 1;
-	for (i = 1; i <= seqEdges.Length() && !isContained; i++) {
-	  isContained = seqEdges.Value(i).IsSame(edge1);
-	  if (!isContained && seqEdges.Value(i).IsSame(edge)) index = i;
-	}
-	if (!isContained) {
-	  if (numV == 1) seqEdges.InsertBefore(index,edge1);
-	  else seqEdges.InsertAfter(index,edge1);
-	  GetSeqEdges(edge1,seqEdges,VertEdge);
-	}
-      }
-    }
-  }
-}
-
-//=======================================================================
-//function : GetFreeWires
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::GetFreeWires(TopTools_MapOfShape& MapFreeEdges, TopTools_SequenceOfShape& seqWires)
-{
-  TopTools_DataMapOfShapeListOfShape VertEdge;
-  TopTools_MapIteratorOfMapOfShape itMap(MapFreeEdges);
-  TopTools_SequenceOfShape seqFreeEdges;
-  for (; itMap.More(); itMap.Next()) {
-    TopoDS_Shape edge = itMap.Key();
-    seqFreeEdges.Append(edge);
-    for (TopoDS_Iterator Iv(edge,Standard_False); Iv.More(); Iv.Next()) {
-      TopoDS_Vertex V1 = TopoDS::Vertex(Iv.Value());
-      if (VertEdge.IsBound(V1))
-	VertEdge.ChangeFind(V1).Append(edge);
-      else {
-	TopTools_ListOfShape ls;
-	ls.Append(edge);
-	VertEdge.Bind(V1,ls);
-      }
-    }
-  }
-  BRep_Builder B;
-  Standard_Integer i, j;
-  for (i = 1; i <= seqFreeEdges.Length(); i++) {
-    TopTools_SequenceOfShape seqEdges;
-    TopoDS_Shape edge = seqFreeEdges.Value(i);
-    if (!MapFreeEdges.Contains(edge)) continue;
-    seqEdges.Append(edge);
-    GetSeqEdges(edge,seqEdges,VertEdge);
-    TopoDS_Wire wire;
-    B.MakeWire(wire);
-    for (j = 1; j <= seqEdges.Length(); j++) {
-      B.Add(wire,seqEdges.Value(j));
-      MapFreeEdges.Remove(seqEdges.Value(j));
-    }
-    seqWires.Append(wire);
-    if (MapFreeEdges.IsEmpty()) break;
-  }
-}
-
-//=======================================================================
-//function :  IsDegeneratedWire
-//purpose  :  internal use
-//=======================================================================
-
-static Standard_Boolean IsDegeneratedWire(const TopoDS_Shape& wire)
-{
-  if (wire.ShapeType() != TopAbs_WIRE) return Standard_False;
-  // Get maximal vertices tolerance
-  TopoDS_Vertex V1,V2;
-  //TopExp::Vertices(TopoDS::Wire(wire),V1,V2);
-  //Standard_Real tol = Max(BRep_Tool::Tolerance(V1),BRep_Tool::Tolerance(V2));
-  Standard_Real wireLength = 0.0;
-  TopLoc_Location loc;
-  Standard_Real first, last;
-  Standard_Integer nume = 0;
-  Standard_Integer isSmall = 0;
-  for (TopoDS_Iterator aIt(wire,Standard_False); aIt.More(); aIt.Next()) {
-    nume++;
-    TopoDS_Shape edge = aIt.Value();
-    TopoDS_Vertex Ve1,Ve2;
-    TopExp::Vertices(TopoDS::Edge(edge),Ve1,Ve2);
-    if(nume == 1) {
-       V1 = Ve1;
-       V2 = Ve2;
-    }
-    else {
-      if(Ve1.IsSame(V1))
-         V1 = Ve2;
-      else if(Ve1.IsSame(V2))
-        V2 = Ve2;
-      if(Ve2.IsSame(V1))
-         V1 = Ve1;
-      else if(Ve2.IsSame(V2))
-        V2 = Ve1;
-    }
-    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(aIt.Value()),loc,first,last);
-    if (!c3d.IsNull()) {
-      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-      if (!loc.IsIdentity()) {
-        //c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-	c3d->Transform(loc.Transformation());
-      }
-      gp_Pnt pfirst = c3d->Value(first);
-      gp_Pnt plast = c3d->Value(last);
-      gp_Pnt pmid = c3d->Value((first +last)*0.5);
-      Standard_Real length =0;
-      if(pfirst.Distance(plast) > pfirst.Distance(pmid)) {
-        length = pfirst.Distance(plast);
-      }
-      else {
-        GeomAdaptor_Curve cAdapt(c3d);
-        length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
-      }
-      Standard_Real tole = BRep_Tool::Tolerance(Ve1)+BRep_Tool::Tolerance(Ve2);
-      if(length <= tole) isSmall++;
-      wireLength += length;
-    }
-  }
-  if(isSmall == nume) return Standard_True;
-  Standard_Real tol = BRep_Tool::Tolerance(V1)+BRep_Tool::Tolerance(V2);//Max(BRep_Tool::Tolerance(V1),BRep_Tool::Tolerance(V2));
-  if (wireLength > tol) return Standard_False;
-  return Standard_True;
-}
-
-//=======================================================================
-//function :  DegeneratedSection
-//purpose  :  internal use
-//            create a new degenerated edge if the section is degenerated
-//=======================================================================
-
-static TopoDS_Edge DegeneratedSection(const TopoDS_Shape& section, const TopoDS_Shape& face)
-{
-  // Return if section is already degenerated
-  if (BRep_Tool::Degenerated(TopoDS::Edge(section))) return TopoDS::Edge(section);
-
-  // Retrieve edge curve
-  TopLoc_Location loc;
-  Standard_Real first, last;
-  Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(section), loc, first, last);
-  if (c3d.IsNull()) { //gka
-    BRep_Builder aB;
-    TopoDS_Edge edge1 = TopoDS::Edge(section);
-    aB.Degenerated(edge1, Standard_True);
-    return edge1;
-  }
-  if (!loc.IsIdentity()) {
-    c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-    c3d->Transform(loc.Transformation());
-  }
-
-  // Test if the new edge is degenerated
-  TopoDS_Vertex v1,v2;
-  TopExp::Vertices(TopoDS::Edge(section),v1,v2);
-  //Standard_Real tol = Max(BRep_Tool::Tolerance(v1),BRep_Tool::Tolerance(v2));
-  //tol = Max(tolerance,tol);
-
-  gp_Pnt p1, p2, p3;
-  p1 = BRep_Tool::Pnt(v1);
-  p3 = BRep_Tool::Pnt(v2);
-  c3d->D0(0.5*(first + last),p2);
-
-  //Standard_Boolean isDegenerated = Standard_False;
-  //if (p1.Distance(p3) < tol) {
-    //GeomAdaptor_Curve cAdapt(c3d);
-    //Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
-    //isDegenerated =  Standard_True; //(length < tol);
-  //}
-
-  TopoDS_Edge edge;
-  //if (!isDegenerated) return edge;
-
-  // processing
-  BRep_Builder aBuilder;
-  edge = TopoDS::Edge(section);
-  edge.EmptyCopy();
-  if (v1.IsSame(v2)) {      
-    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
-    aBuilder.Add(anEdge, v1.Oriented(TopAbs_FORWARD));
-    aBuilder.Add(anEdge, v2.Oriented(TopAbs_REVERSED));
-  }
-  else {
-    TopoDS_Vertex newVertex;
-    if (p1.Distance(p3) < BRep_Tool::Tolerance(v1))
-      newVertex = v1;
-    else if (p1.Distance(p3) < BRep_Tool::Tolerance(v2))
-      newVertex = v2;
-    else {
-      Standard_Real d1 = BRep_Tool::Tolerance(v1) + p2.Distance(p1);
-      Standard_Real d2 = BRep_Tool::Tolerance(v2) + p2.Distance(p3);
-      Standard_Real newTolerance = Max(d1,d2);
-      aBuilder.MakeVertex(newVertex, p2, newTolerance);
-    }
-    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
-    aBuilder.Add(anEdge, newVertex.Oriented(TopAbs_FORWARD));
-    aBuilder.Add(anEdge, newVertex.Oriented(TopAbs_REVERSED));
-  }
-
-  BRep_Tool::Range(TopoDS::Edge(section), first, last);
-  TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
-  aBuilder.Range(TopoDS::Edge(anEdge), first, last);
-  aBuilder.Degenerated(edge, Standard_True);
-  Handle(Geom_Curve) aC3dNew;
-  if (!face.IsNull()) {
-    Standard_Real af,al;
-    Handle(Geom2d_Curve) aC2dt = BRep_Tool::CurveOnSurface(TopoDS::Edge(section),TopoDS::Face(face),af,al);
-    aBuilder.UpdateEdge(edge,aC3dNew,0);
-    Handle(Geom2d_Curve) aC2dn = BRep_Tool::CurveOnSurface(edge,TopoDS::Face(face),af,al);
-    if (aC2dn.IsNull())
-      aBuilder.UpdateEdge(edge,aC2dt,TopoDS::Face(face),0);
-  }
-
-  return edge;
-}
-
-//=======================================================================
-//function : EdgeProcessing
-//purpose  : modifies :
-//                       myNbEdges
-//                       myHasMultipleEdge
-//                       myHasFreeBound
-//           . if multiple edge
-//              - length < 100.*myTolerance -> several free edge
-//           . if no multiple edge
-//              - make the contigous edges sameparameter
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::EdgeProcessing()
-{
-  // constructs sectionEdge
-  TopTools_MapOfShape MapFreeEdges;
-  TopTools_DataMapOfShapeShape EdgeFace;
-  for (Standard_Integer i = 1; i <= myBoundFaces.Extent(); i++) {
-    const TopoDS_Shape& bound = myBoundFaces.FindKey(i);
-    const TopTools_ListOfShape& listFaces = myBoundFaces(i);
-    if (listFaces.Extent() == 1) {
-      if (myBoundSections.IsBound(bound)) {
-	TopTools_ListIteratorOfListOfShape liter(myBoundSections(bound));
-	for (; liter.More(); liter.Next()) {
-	  if (!myMergedEdges.Contains(liter.Value())) { //myReShape->IsRecorded(liter.Value())) {
-	    TopoDS_Shape edge = myReShape->Apply(liter.Value());
-	    if (!MapFreeEdges.Contains(edge)) {
-	      TopoDS_Shape face = listFaces.First();
-	      EdgeFace.Bind(edge,face);
-	      MapFreeEdges.Add(edge);
-	    }
-	  }
-	}
-      }
-      else {
-	if (!myMergedEdges.Contains(bound)) {
-	  TopoDS_Shape edge = myReShape->Apply(bound);
-	  if (!MapFreeEdges.Contains(edge)) {
-	    TopoDS_Shape face = listFaces.First();
-	    EdgeFace.Bind(edge,face);
-	    MapFreeEdges.Add(edge);
-	  }
-	}
-      }
-    }
-  }
-
-  if (!MapFreeEdges.IsEmpty()) {
-    TopTools_SequenceOfShape seqWires;
-    GetFreeWires(MapFreeEdges,seqWires);
-    for (Standard_Integer j = 1; j <= seqWires.Length(); j++) {
-      TopoDS_Wire wire = TopoDS::Wire(seqWires.Value(j));
-      if (!IsDegeneratedWire(wire)) continue;
-      for (TopoDS_Iterator Ie(wire,Standard_False); Ie.More(); Ie.Next()) {
-        TopoDS_Shape aTmpShape = myReShape->Apply(Ie.Value()); //for porting
-	TopoDS_Edge edge = TopoDS::Edge(aTmpShape);
-	TopoDS_Shape face;
-	if (EdgeFace.IsBound(edge))
-	  face = EdgeFace.Find(edge);
-	TopoDS_Shape degedge = DegeneratedSection(edge,face);
-	if (degedge.IsNull()) continue;
-	if (!degedge.IsSame(edge))
-	  ReplaceEdge(edge,degedge,myReShape);
-	if (BRep_Tool::Degenerated(TopoDS::Edge(degedge)))
-	  myDegenerated.Add(degedge);
-      }
-    }
-  }
-  myMergedEdges.Clear();
-}
-
-//=======================================================================
-//function : CreateSewedShape
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::CreateSewedShape()
-{
-  // ---------------------
-  // create the new shapes
-  // ---------------------
-  BRepTools_Quilt aQuilt;
-  Standard_Boolean isLocal = !myShape.IsNull();
-  if (isLocal) {
-    // Local sewing
-    TopoDS_Shape ns = myReShape->Apply(myShape);
-    aQuilt.Add(ns);
-  }
-  Standard_Integer i;
-  for (i = 1; i <= myOldShapes.Extent(); i++) {
-    TopoDS_Shape sh = myOldShapes(i);
-    if (!sh.IsNull()) {
-      sh = myReShape->Apply(sh);
-      myOldShapes(i) = sh;
-      if (!isLocal) aQuilt.Add(sh);
-    }
-  }
-  TopoDS_Shape aNewShape = aQuilt.Shells();
-  Standard_Integer numsh = 0;
-
-  TopTools_IndexedMapOfShape OldShells;
-
-  BRep_Builder aB;
-  TopoDS_Compound aComp;
-  aB.MakeCompound(aComp);
-  for (TopoDS_Iterator aExpSh(aNewShape,Standard_False); aExpSh.More(); aExpSh.Next()) {
-    TopoDS_Shape sh = aExpSh.Value();
-    Standard_Boolean hasEdges = Standard_False;
-    if (sh.ShapeType() == TopAbs_SHELL) {
-      if (myNonmanifold)
-	hasEdges = !OldShells.Contains(sh);
-      else {
-	TopoDS_Shape face;
-	Standard_Integer numf = 0;
-	for (TopExp_Explorer aExpF(sh,TopAbs_FACE); aExpF.More() && (numf < 2); aExpF.Next()) {
-	  face = aExpF.Current();
-	  numf++;
-	}
-	if (numf == 1) aB.Add(aComp,face);
-	else if (numf > 1) aB.Add(aComp,sh);
-	if (numf) numsh++;
-      }
-    }
-    else if (sh.ShapeType() == TopAbs_FACE) {
-      if (myNonmanifold) {
-	TopoDS_Shell ss;
-	aB.MakeShell(ss);
-	aB.Add(ss,sh);
-	sh = ss;
-	hasEdges = Standard_True;
-      }
-      else { aB.Add(aComp,sh); numsh++; }
-    }
-    else { aB.Add(aComp,sh); numsh++; }
-    if (hasEdges) OldShells.Add(sh);
-  }
-  // Process collected shells
-  if (myNonmanifold) {
-    Standard_Integer nbOldShells = OldShells.Extent();
-    if (nbOldShells == 1) {
-      // Single shell - check for single face
-      TopoDS_Shape sh = OldShells.FindKey(1);
-      TopoDS_Shape face;
-      Standard_Integer numf = 0;
-      for (TopExp_Explorer aExpF(sh,TopAbs_FACE); aExpF.More() && (numf < 2); aExpF.Next()) {
-	face = aExpF.Current();
-	numf++;
-      }
-      if (numf == 1) aB.Add(aComp,face);
-      else if (numf > 1) aB.Add(aComp,sh);
-      if (numf) numsh++;
-    }
-    else if (nbOldShells) {
-      // Several shells should be merged
-      TColStd_MapOfInteger IndexMerged;
-      while (IndexMerged.Extent() < nbOldShells) {
-	TopoDS_Shell NewShell;
-	TopTools_MapOfShape NewEdges;
-	for (i = 1; i <= nbOldShells; i++) {
-	  if (IndexMerged.Contains(i)) continue;
-	  TopoDS_Shell shell = TopoDS::Shell(OldShells.FindKey(i));
-	  if (NewShell.IsNull()) {
-            BRep_Builder aB;
-            aB.MakeShell(NewShell);
-            TopoDS_Iterator aItSS(shell) ;
-            for( ; aItSS.More(); aItSS.Next())
-              aB.Add(NewShell,aItSS.Value())
-;
-	    // Fill map of edges
-	    for (TopExp_Explorer eexp(shell,TopAbs_EDGE); eexp.More(); eexp.Next()) {
-	      TopoDS_Shape edge = eexp.Current();
-	      NewEdges.Add(edge);
-	    }
-	    IndexMerged.Add(i);
-	  }
-	  else {
-	    Standard_Boolean hasSharedEdge = Standard_False;
-	    TopExp_Explorer eexp(shell,TopAbs_EDGE);
-	    for (; eexp.More() && !hasSharedEdge; eexp.Next())
-	      hasSharedEdge = NewEdges.Contains(eexp.Current());
-	    if (hasSharedEdge) {
-	      // Add edges to the map
-	      for (TopExp_Explorer eexp1(shell,TopAbs_EDGE); eexp1.More(); eexp1.Next()) {
-		TopoDS_Shape edge = eexp1.Current();
-		NewEdges.Add(edge);
-	      }
-	      // Add faces to the shell
-	      for (TopExp_Explorer fexp(shell,TopAbs_FACE); fexp.More(); fexp.Next()) {
-		TopoDS_Shape face = fexp.Current();
-		aB.Add(NewShell,face);
-	      }
-	      IndexMerged.Add(i);
-	    }
-	  }
-	}
-	// Process new shell
-	TopoDS_Shape face;
-	Standard_Integer numf = 0;
-	TopExp_Explorer aExpF(NewShell,TopAbs_FACE);
-	for (; aExpF.More() && (numf < 2); aExpF.Next()) {
-	  face = aExpF.Current();
-	  numf++;
-	}
-	if (numf == 1) aB.Add(aComp,face);
-	else if (numf > 1) aB.Add(aComp,NewShell);
-	if (numf) numsh++;
-      }
-    }
-  }
-  if (numsh == 1) {
-    // Extract single component
-    TopoDS_Iterator aIt(aComp,Standard_False);
-    mySewedShape = aIt.Value();
-  }
-  else
-    mySewedShape = aComp;
-}
-
-//=======================================================================
-//function : CreateOutputInformations
-//purpose  : constructs :
-//                       myEdgeSections
-//                       mySectionBound
-//                       myNbFreeEdges
-//                       myNbContigousEdges
-//                       myNbMultipleEdges
-//                       myNbDegenerated
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::CreateOutputInformations()
-{
-  // Construct edgeSections
-  Standard_Integer i;
-  //TopTools_DataMapOfShapeListOfShape edgeSections;
-  TopTools_IndexedDataMapOfShapeListOfShape edgeSections; //use index map for regulating free edges
-  for (i = 1; i <= myBoundFaces.Extent(); i++) {
-    const TopoDS_Shape& bound = myBoundFaces.FindKey(i);
-    TopTools_ListOfShape lsect;
-    if (myBoundSections.IsBound(bound)) lsect = myBoundSections(bound);
-    TopExp_Explorer aExp(myReShape->Apply(bound),TopAbs_EDGE);
-    for (; aExp.More(); aExp.Next()) {
-      TopoDS_Shape sec = bound, edge = aExp.Current();
-      TopTools_ListIteratorOfListOfShape aI(lsect);
-      for (; aI.More(); aI.Next()) {
-	const TopoDS_Shape& section = aI.Value();
-	if (edge.IsSame(myReShape->Apply(section))) { sec = section; break; }
-      }
-      if (edgeSections.Contains(edge))
-	 edgeSections.ChangeFromKey(edge).Append(sec);
-      else {
- 	TopTools_ListOfShape listSec;
-	listSec.Append(sec);
-	edgeSections.Add(edge,listSec);
-      }
-    }
-  }
-
-  // Fill maps of Free, Contigous and Multiple edges
-  //TopTools_DataMapIteratorOfDataMapOfShapeListOfShape iter2(edgeSections);
-  for (i = 1; i <= edgeSections.Extent(); i++) {
-    const TopoDS_Shape& edge = edgeSections.FindKey(i);
-    const TopTools_ListOfShape& listSection = edgeSections(i);
-    if (listSection.Extent() == 1) {
-      if (BRep_Tool::Degenerated(TopoDS::Edge(edge)))
-	myDegenerated.Add(edge);
-      else
-	myFreeEdges.Add(edge);
-    }
-    else if (listSection.Extent() == 2) {
-      myContigousEdges.Add(edge,listSection);
-    }
-    else {
-      myMultipleEdges.Add(edge);
-    }
-  }
-
-  // constructs myContigSectBound
-  TopTools_DataMapOfShapeListOfShape aEdgeMap; //gka
-  for (i = 1; i <= myBoundFaces.Extent(); i++) {
-    TopoDS_Shape bound = myBoundFaces.FindKey(i);
-    if (myBoundSections.IsBound(bound)) {
-      TopTools_ListIteratorOfListOfShape iter(myBoundSections(bound));
-      for (; iter.More(); iter.Next()) {
-	TopoDS_Shape section = iter.Value();
-        if(!myMergedEdges.Contains(section)) continue;
-	//if (!myReShape->IsRecorded(section)) continue; // section is free
-	TopoDS_Shape nedge = myReShape->Apply(section);
-	if (nedge.IsNull()) continue; //szv debug
-	if (!bound.IsSame(section))
-	  if (myContigousEdges.Contains(nedge))
-	    myContigSecBound.Bind(section, bound);
-      }
-    }
-  }
-}
-
-//=======================================================================
-//function : ProjectPointsOnCurve
-//purpose  : internal use
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::ProjectPointsOnCurve(const TColgp_Array1OfPnt& arrPnt,
-					   const Handle(Geom_Curve)& c3d,
-					   const Standard_Real first,
-					   const Standard_Real last,
-					   TColStd_Array1OfReal& arrDist,
-					   TColStd_Array1OfReal& arrPara,
-					   TColgp_Array1OfPnt& arrProj) const
-{
-  arrDist.Init(-1.0);
-
-  GeomAdaptor_Curve GAC(c3d);
-  Extrema_ExtPC locProj;
-  locProj.Initialize(GAC, first, last);
-  gp_Pnt pfirst = GAC.Value(first), plast = GAC.Value(last);
-
-  for (Standard_Integer i1 = 1; i1 <= arrPnt.Length(); i1++) {
-    gp_Pnt pt = arrPnt(i1);
-    Standard_Real worktol = myTolerance;
-    Standard_Real distF = pfirst.Distance(pt);
-    Standard_Real distL = plast.Distance(pt);
-    Standard_Boolean isProjected = Standard_False;
-    try {
-      
-      // Project current point on curve
-      locProj.Perform(pt);
-      if (locProj.IsDone() && locProj.NbExt() > 0) {
-	Standard_Real distMin = Min(distF,distL);
-	Standard_Integer ind, indMin = 0;
-	for (ind = 1; ind <= locProj.NbExt(); ind++) {
-	  Standard_Real dProj = locProj.Value(ind);
-	  if (dProj < distMin) { indMin = ind; distMin = dProj; }
-	}
-	if (indMin) {
-	  isProjected = Standard_True;
-	  Extrema_POnCurv pOnC = locProj.Point(indMin);
-	  Standard_Real paramProj = pOnC.Parameter();
-	  gp_Pnt ptProj = GAC.Value(paramProj);
-	  Standard_Real distProj = ptProj.Distance(pt);
-	  if (!locProj.IsMin(indMin)) {
-	    if (Min(distF,distL) < distMin) {
-	      if (distF < distL) {
-		paramProj = first;
-		distProj = distF;
-		ptProj = pfirst;
-	      }
-	      else {
-		paramProj = last;
-		distProj = distL;
-		ptProj = plast;
-	      }
-	    }
-	  }
-	  if (distProj < worktol) {
-	    arrDist(i1) = distProj;
-	    arrPara(i1) = paramProj;
-	    arrProj(i1) = ptProj;
-	  }
-	}
-      }
-    }
-    catch (Standard_Failure) {
-      worktol = MinTolerance();
-#ifdef DEB
-      cout << "Exception in BRepBuilderAPI_Sewing::ProjectPointsOnCurve: ";
-      Standard_Failure::Caught()->Print(cout); cout << endl;
-#endif
-    }
-    if (!isProjected) {
-      if (Min(distF,distL) < worktol) {
-	if (distF < distL) {
-	  arrDist(i1) = distF;
-	  arrPara(i1) = first;
-	  arrProj(i1) = pfirst;
-	}
-	else {
-	  arrDist(i1) = distL;
-	  arrPara(i1) = last;
-	  arrProj(i1) = plast;
-	}
-      }
-    }
-  }
-}
-
-//=======================================================================
-//function : CreateCuttingNodes
-//purpose  : internal use
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::CreateCuttingNodes(const TopTools_IndexedMapOfShape& MapVert,
-					 const TopoDS_Shape& bound,
-					 const TopoDS_Shape& vfirst,
-					 const TopoDS_Shape& vlast,
-					 const TColStd_Array1OfReal& arrDist,
-					 const TColStd_Array1OfReal& arrPara,
-					 const TColgp_Array1OfPnt& arrPnt,
-					 TopTools_SequenceOfShape& seqVert,
-					 TColStd_SequenceOfReal& seqPara)
-{
-  Standard_Integer i, j, nbProj = MapVert.Extent();
-
-  // Reorder projections by distance
-  TColStd_SequenceOfInteger seqOrderedIndex;
-  { //szv: Use brackets to destroy local variables
-    TColStd_SequenceOfReal seqOrderedDistance;
-    for (i = 1; i <= nbProj; i++) {
-      Standard_Real distProj = arrDist(i);
-      if (distProj < 0.0) continue; // Skip vertex if not projected
-      Standard_Boolean isInserted = Standard_False;
-      for (j = 1; j <= seqOrderedIndex.Length() && !isInserted; j++) {
-	isInserted = (distProj < seqOrderedDistance(j));
-	if (isInserted) {
-	  seqOrderedIndex.InsertBefore(j,i);
-	  seqOrderedDistance.InsertBefore(j,distProj);
-	}
-      }
-      if (!isInserted) {
-	seqOrderedIndex.Append(i);
-	seqOrderedDistance.Append(distProj);
-      }
-    }
-  }
-  nbProj = seqOrderedIndex.Length();
-  if (!nbProj) return;
-
-  BRep_Builder aBuilder;
-
-  // Insert two initial vertices (to be removed later)
-  TColStd_SequenceOfReal seqDist;
-  TColgp_SequenceOfPnt seqPnt;
-  { //szv: Use brackets to destroy local variables
-    // Retrieve bound curve
-    TopLoc_Location loc;
-    Standard_Real first,last;
-    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(bound), loc, first, last);
-    if (!loc.IsIdentity()) {
-      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
-      c3d->Transform(loc.Transformation());
-    }
-    GeomAdaptor_Curve GAC(c3d);
-    seqVert.Prepend(vfirst); seqVert.Append(vlast);
-    seqPara.Prepend(first); seqPara.Append(last);
-    seqDist.Prepend(-1.0); seqDist.Append(-1.0);
-    seqPnt.Prepend(GAC.Value(first)); seqPnt.Append(GAC.Value(last));
-  }
-
-  TopTools_DataMapOfShapeShape NodeCuttingVertex;
-  for (i = 1; i <= nbProj; i++) {
-
-    const Standard_Integer index = seqOrderedIndex(i);
-    Standard_Real disProj = arrDist(index);
-    gp_Pnt pntProj = arrPnt(index);
-
-    // Skip node if already bound to cutting vertex
-    TopoDS_Shape node = myVertexNode.FindFromKey(MapVert(index));
-    if (NodeCuttingVertex.IsBound(node)) continue;
-
-    // Find the closest vertex
-    Standard_Integer indexMin = 1;
-    Standard_Real dist, distMin = pntProj.Distance(seqPnt(1));
-    for (j = 2; j <= seqPnt.Length(); j++) {
-      dist = pntProj.Distance(seqPnt(j));
-      if (dist < distMin) { distMin = dist; indexMin = j; }
-    }
-
-    // Check if current point is close to one of the existent
-    if (distMin <= Max(disProj*0.1,MinTolerance())) {
-      // Check distance if close
-      Standard_Real jdist = seqDist.Value(indexMin);
-      if (jdist < 0.0) {
-	// Bind new cutting node (end vertex only)
-	seqDist.SetValue(indexMin,disProj);
-	TopoDS_Shape cvertex = seqVert.Value(indexMin);
-	NodeCuttingVertex.Bind(node,cvertex);
-      }
-      else {
-	// Bind secondary cutting nodes
-	NodeCuttingVertex.Bind(node,TopoDS_Vertex());
-      }
-    }
-    else {
-      // Build new cutting vertex
-      TopoDS_Vertex cvertex;
-      aBuilder.MakeVertex(cvertex, pntProj, Precision::Confusion());
-      // Bind new cutting vertex
-      NodeCuttingVertex.Bind(node,cvertex);
-      // Insert cutting vertex in the sequences
-      Standard_Real parProj = arrPara(index);
-      for (j = 2; j <= seqPara.Length(); j++) {
-	if (parProj <= seqPara.Value(j)) {
-	  seqVert.InsertBefore(j,cvertex);
-	  seqPara.InsertBefore(j,parProj);
-	  seqDist.InsertBefore(j,disProj);
-	  seqPnt.InsertBefore (j,pntProj);
-	  break;
-	}
-      }
-    }
-  }
-
-  // filling map for cutting nodes
-  TopTools_DataMapIteratorOfDataMapOfShapeShape mit(NodeCuttingVertex);
-  for (; mit.More(); mit.Next()) {
-    TopoDS_Shape cnode = mit.Value();
-    // Skip secondary nodes
-    if (cnode.IsNull()) continue;
-    // Obtain vertex node
-    TopoDS_Shape node = mit.Key();
-    if (myVertexNode.Contains(cnode)) {
-      // This is an end vertex
-      cnode = myVertexNode.FindFromKey(cnode);
-    }
-    else {
-      // Create link: cutting vertex -> node
-      TopTools_ListOfShape ls;
-      ls.Append(node);
-      myCuttingNode.Bind(cnode,ls);
-    }
-    // Create link: node -> cutting vertex
-    if (myCuttingNode.IsBound(node)) {
-      myCuttingNode.ChangeFind(node).Append(cnode);
-    }
-    else {
-      TopTools_ListOfShape ls;
-      ls.Append(cnode);
-      myCuttingNode.Bind(node,ls);
-    }
-  }
-
-  // Remove two initial vertices
-  seqVert.Remove(1); seqVert.Remove(seqVert.Length());
-  seqPara.Remove(1); seqPara.Remove(seqPara.Length());
-}
-
-//=======================================================================
-//function : CreateSections
-//purpose  : internal use
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::CreateSections(const TopoDS_Shape& section,
-				     const TopTools_SequenceOfShape& seqNode,
-				     const TColStd_SequenceOfReal& seqPara,
-				     TopTools_ListOfShape& listEdge)
-{
-  const TopoDS_Edge& sec = TopoDS::Edge(section);
-//  TopAbs_Orientation aInitOr = sec.Orientation();
-
-  
-//To keep NM vertices on edge
-  TopTools_SequenceOfShape aSeqNMVert;
-  TColStd_SequenceOfReal aSeqNMPars;
-  Standard_Boolean hasNMVert = findNMVertices(sec,aSeqNMVert,aSeqNMPars);
-  BRep_Builder aBuilder;
-
-  Standard_Real first, last;
-  BRep_Tool::Range(sec, first, last);
-
-  // Create cutting sections
-  Standard_Real par1, par2;
-  TopoDS_Shape V1, V2;
-  Standard_Integer i, len = seqPara.Length() + 1;
-  for (i = 1; i <= len; i++) {
-
-    TopoDS_Edge edge = sec;
-    edge.EmptyCopy();
-
-    if (i == 1) {
-      par1 = first;
-      par2 = seqPara(i);
-      V1 = TopExp::FirstVertex(sec);
-      V2 = seqNode(i);
-    }
-    else if (i == len) {
-      par1 = seqPara(i-1);
-      par2 = last;
-      V1 = seqNode(i-1);
-      V2 = TopExp::LastVertex(sec);
-    }
-    else {
-      par1 = seqPara(i-1);
-      par2 = seqPara(i);
-      V1 = seqNode(i-1);
-      V2 = seqNode(i);
-    }
-
-    TopoDS_Shape aTmpShape = edge.Oriented(TopAbs_FORWARD);
-    TopoDS_Edge aTmpEdge = TopoDS::Edge (aTmpShape); // for porting
-    aTmpShape = V1.Oriented(TopAbs_FORWARD);
-    aBuilder.Add(aTmpEdge, aTmpShape);
-    aTmpShape = V2.Oriented(TopAbs_REVERSED);
-    aBuilder.Add(aTmpEdge, aTmpShape);
-    aBuilder.Range(aTmpEdge, par1, par2);
-//    if(aInitOr == TopAbs_REVERSED)
-//      listEdge.Prepend(edge);
-//    else
-    
-    Standard_Integer k =1;
-    for( ; k <=  aSeqNMPars.Length() ; k++) {
-      Standard_Real apar = aSeqNMPars.Value(k);
-      if(apar >= par1 && apar <= par2) {
-        aBuilder.Add(aTmpEdge,aSeqNMVert.Value(k));
-        aSeqNMVert.Remove(k);
-        aSeqNMPars.Remove(k);
-        k--;
-      }
-     }
-     listEdge.Append(edge);
-  }
-
-  const TopTools_ListOfShape& listFaces = myBoundFaces.FindFromKey(sec);
-  if (!listFaces.Extent()) return;
-
-  Standard_Real tolEdge = BRep_Tool::Tolerance(sec);
-
-  // Add cutting pcurves
-  TopTools_ListIteratorOfListOfShape itf(listFaces);
-  for (; itf.More(); itf.Next()) {
-
-    const TopoDS_Face& fac = TopoDS::Face(itf.Value());
-    
-    // Retrieve curve on surface
-    Standard_Real first2d=0., last2d=0.,first2d1=0,last2d1=0.;
-    Handle(Geom2d_Curve) c2d = BRep_Tool::CurveOnSurface(sec, fac, first2d, last2d);
-    if (c2d.IsNull()) continue;
-
-    Standard_Boolean isSeam = BRep_Tool::IsClosed(sec,fac);
-
-    // Convert pcurve to BSpline
-    Handle(Geom2d_BSplineCurve) c2dBSP,c2dBSP1;
-    if (c2d->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
-      c2dBSP = Handle(Geom2d_BSplineCurve)::DownCast(c2d);
-    }
-    else {
-      if (first > (c2d->FirstParameter() + Precision::PConfusion()) ||
-	  last < (c2d->LastParameter() - Precision::PConfusion())) {
-	Handle(Geom2d_TrimmedCurve) TC = new Geom2d_TrimmedCurve(c2d, first, last);
-	c2dBSP = Geom2dConvert::CurveToBSplineCurve(TC);
-      }
-      else c2dBSP = Geom2dConvert::CurveToBSplineCurve(c2d);
-    }
-    if (c2dBSP.IsNull()) continue;
-    //gka fix for bug OCC12203 21.04.06 addition second curve for seam edges
-    if(isSeam)
-    {
-      TopoDS_Edge secRev = TopoDS::Edge(sec.Reversed());
-      
-      Handle(Geom2d_Curve) c2d1 = BRep_Tool::CurveOnSurface(secRev, fac, first2d1, last2d1);
-      if (c2d1.IsNull()) continue;
-      if (c2d1->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
-        c2dBSP1 = Handle(Geom2d_BSplineCurve)::DownCast(c2d1);
-      }
-      else {
-        if (first > (c2d1->FirstParameter() + Precision::PConfusion()) ||
-            last < (c2d1->LastParameter() - Precision::PConfusion())) {
-          Handle(Geom2d_TrimmedCurve) TC = new Geom2d_TrimmedCurve(c2d1, first, last);
-          c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(TC);
-        }
-        else c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(c2d);
-      
-      }
-    }
-
-    first2d = c2dBSP->FirstParameter();
-    last2d = c2dBSP->LastParameter();
-    if(!c2dBSP1.IsNull()) {
-      first2d1 = c2dBSP1->FirstParameter();
-      last2d1 = c2dBSP1->LastParameter();
-    }
-      
-    // Update cutting sections
-    Handle(Geom2d_Curve) c2dNew,c2d1New;
-    TopTools_ListIteratorOfListOfShape ite(listEdge);
-    for (; ite.More(); ite.Next()) {
-
-      // Retrieve cutting section
-      const TopoDS_Edge& edge = TopoDS::Edge(ite.Value());
-      BRep_Tool::Range(edge, par1, par2);
-
-      // Cut BSpline pcurve
-      try {
-        
-	c2dNew = Handle(Geom2d_Curve)::DownCast(c2dBSP->Copy());
-	Handle(Geom2d_BSplineCurve)::DownCast(c2dNew)->Segment(Max(first2d,par1),Min(par2,last2d));
-        if(!c2dBSP1.IsNull()) {
-          c2d1New = Handle(Geom2d_Curve)::DownCast(c2dBSP1->Copy());
-          Handle(Geom2d_BSplineCurve)::DownCast(c2d1New)->Segment(Max(first2d1,par1),Min(par2,last2d1));
-        }
-      }
-      catch (Standard_Failure) {
-#ifdef DEB
-	cout << "Exception in CreateSections: segment [" << par1 << "," << par2 << "]: ";
-	Standard_Failure::Caught()->Print(cout); cout << endl;
-#endif
-	Handle(Geom2d_TrimmedCurve) c2dT = new Geom2d_TrimmedCurve(c2dNew,Max(first2d,par1),Min(par2,last2d));
-	c2dNew = c2dT;
-      }
-              
-
-      if(!isSeam && c2d1New.IsNull())
-        aBuilder.UpdateEdge(edge, c2dNew, fac, tolEdge);
-      else {
-        TopAbs_Orientation Ori = edge.Orientation();
-        if(fac.Orientation() == TopAbs_REVERSED)
-          Ori = TopAbs::Reverse(Ori);
-        
-        if(Ori == TopAbs_FORWARD)
-          aBuilder.UpdateEdge(edge, c2dNew,c2d1New ,fac, tolEdge);
-        else
-          aBuilder.UpdateEdge(edge, c2d1New,c2dNew ,fac, tolEdge);
-      }
-    }
-  }
-}
-		
-//=======================================================================
-//function : SameParameterShape
-//purpose  : 
-//=======================================================================
-
-void BRepBuilderAPI_Sewing::SameParameterShape()
-{
-  if (!mySameParameterMode) return;
-  TopExp_Explorer exp(mySewedShape, TopAbs_EDGE);
-  // Le flag sameparameter est a false pour chaque edge cousue
-  for (; exp.More(); exp.Next()) {
-    const TopoDS_Edge& sec = TopoDS::Edge(exp.Current());
-    try {
-      
-      BRepLib::SameParameter(sec, BRep_Tool::Tolerance(sec));
-    }
-    catch (Standard_Failure) {
-#ifdef DEB
-      cout << "Fail: BRepBuilderAPI_Sewing::SameParameterShape exception in BRepLib::SameParameter" << endl;
-#endif
-      continue;
-    }
-  }
-}
+// File:        BRepBuilderAPI_Sewing.cxx
+// Created:        Fri Mar 24 09:45:44 1995
+// Author:        Jing Cheng MEI
+//                <mei@junon>
+// dcl          CCI60011 : Correction of degeneratedSection
+//              Improvement of SameParameter Edge to treat case of failure in BRepLib::SameParameter
+// dcl          Thu Aug 20 09:24:49 1998
+//              Suppression of little faces.
+// dcl          Fri Aug  7 15:27:46 1998
+//                Refection of function SameParameter Edge.
+//              Merge on the edge which has the less of poles.
+//              Suppression of the Connected Edge function.
+// dcl          Tue Jun  9 14:21:53 1998
+//              Do not merge edge if they belong the same face
+//              Tolerance management in VerticesAssembling
+//              Tolerance management in Cutting
+// dcl          Thu May 14 15:51:46 1998
+//              optimization of cutting
+// dcl          Thu May 7  15:51:46 1998
+//              Add of cutting option
+//              Add of SameParameter call
+
+
+//-- lbr le 1er avril 97
+//-- dpf le 10 decembre 1997 Traitement des collections de pcurve
+
+//rln 02.02.99 BUC60449 Making compilable on NT in DEB mode 
+//rln 02.02.99 BUC60449 Protection against exception on NT
+
+#define TEST 1
+
+#include <BRepBuilderAPI_Sewing.ixx>
+
+#include <Bnd_Box.hxx>
+#include <Bnd_Box2d.hxx>
+#include <Bnd_HArray1OfBox.hxx>
+#include <BndLib_Add2dCurve.hxx>
+#include <BndLib_Add3dCurve.hxx>
+#include <BRep_Builder.hxx>
+#include <BRep_Tool.hxx>
+#include <BRepLib.hxx>
+#include <BRepTools_Quilt.hxx>
+#include <BSplCLib.hxx>
+#include <Extrema_ExtPC.hxx>
+#include <GCPnts_AbscissaPoint.hxx>
+#include <GCPnts_UniformAbscissa.hxx>
+#include <GCPnts_UniformDeflection.hxx>
+#include <Geom2d_BezierCurve.hxx>
+#include <Geom2d_BSplineCurve.hxx>
+#include <Geom2d_Curve.hxx>
+#include <Geom2d_Line.hxx>
+#include <Geom2d_TrimmedCurve.hxx>
+#include <Geom2dAdaptor_Curve.hxx>
+#include <Geom2dConvert.hxx>
+#include <Geom_BezierCurve.hxx>
+#include <Geom_BSplineCurve.hxx>
+#include <Geom_Curve.hxx>
+#include <Geom_Line.hxx>
+#include <Geom_Surface.hxx>
+#include <GeomAdaptor_Curve.hxx>
+#include <GeomAdaptor_Surface.hxx>
+#include <GeomLib.hxx>
+#include <gp_Pnt.hxx>
+#include <gp_Vec.hxx>
+//#include <LocalAnalysis_SurfaceContinuity.hxx>
+#include <Precision.hxx>
+#include <Standard_ErrorHandler.hxx>
+#include <Standard_Failure.hxx>
+#include <TColgp_Array1OfVec.hxx>
+#include <TColgp_SequenceOfPnt.hxx>
+#include <TColStd_Array1OfInteger.hxx>
+#include <TColStd_Array1OfReal.hxx>
+#include <TColStd_DataMapIteratorOfDataMapOfIntegerListOfInteger.hxx>
+#include <TColStd_DataMapOfIntegerListOfInteger.hxx>
+#include <TColStd_IndexedMapOfInteger.hxx>
+#include <TColStd_ListIteratorOfListOfInteger.hxx>
+#include <TColStd_ListOfInteger.hxx>
+#include <TColStd_MapOfInteger.hxx>
+#include <TColStd_SequenceOfReal.hxx>
+#include <TopAbs.hxx>
+#include <TopExp.hxx>
+#include <TopExp_Explorer.hxx>
+#include <TopLoc_Location.hxx>
+#include <TopoDS.hxx>
+#include <TopoDS_Edge.hxx>
+#include <TopoDS_Iterator.hxx>
+#include <TopoDS_Shape.hxx>
+#include <TopoDS_Vertex.hxx>
+#include <TopoDS_Wire.hxx>
+#include <TopoDS_Shell.hxx>
+#include <TopTools_Array1OfShape.hxx>
+#include <TopTools_DataMapIteratorOfDataMapOfShapeListOfShape.hxx>
+#include <TopTools_DataMapIteratorOfDataMapOfShapeShape.hxx>
+#include <TopTools_DataMapOfShapeInteger.hxx>
+#include <TopTools_DataMapOfShapeListOfShape.hxx>
+#include <TopTools_ListIteratorOfListOfShape.hxx>
+#include <TopTools_ListOfShape.hxx>
+#include <TopTools_MapIteratorOfMapOfShape.hxx>
+#include <TopTools_MapOfShape.hxx>
+#include <TopTools_SequenceOfShape.hxx>
+#include <TopoDS_Compound.hxx>
+#include <TColStd_Array2OfReal.hxx>
+#include <TColStd_MapIteratorOfMapOfInteger.hxx>
+#include <BRepTools.hxx>
+#include <Geom_RectangularTrimmedSurface.hxx>
+#include <Geom_OffsetSurface.hxx>
+#include <BRep_PointOnCurve.hxx>
+#include <BRep_ListOfPointRepresentation.hxx>
+#include <BRep_TVertex.hxx>
+
+static void SortBox (const Handle(Bnd_HArray1OfBox) hSetBoxes,
+		     const Bnd_Box& aBox,
+		     TColStd_ListOfInteger& listIndex)
+{
+  Standard_Integer i, nbBoxes = hSetBoxes->Length();
+  for (i = 1; i <= nbBoxes; i++)
+    if (!aBox.IsOut(hSetBoxes->Value(i)))
+      listIndex.Append(i);
+}
+
+//=======================================================================
+//function : SameRange
+//purpose  : 
+//=======================================================================
+
+Handle(Geom2d_Curve) BRepBuilderAPI_Sewing::SameRange(const Handle(Geom2d_Curve)& CurvePtr,
+						const Standard_Real FirstOnCurve,
+						const Standard_Real LastOnCurve,
+						const Standard_Real RequestedFirst,
+						const Standard_Real RequestedLast) const
+{
+  Handle(Geom2d_Curve) NewCurvePtr;
+  try {
+    
+    GeomLib::SameRange(Precision::PConfusion(),CurvePtr,FirstOnCurve,LastOnCurve,
+		       RequestedFirst,RequestedLast,NewCurvePtr);
+  }
+  catch (Standard_Failure) {
+#ifdef DEB
+    cout << "Exception in BRepBuilderAPI_Sewing::SameRange: ";
+    Standard_Failure::Caught()->Print(cout); cout << endl;
+#endif
+  }
+  return NewCurvePtr;
+}
+
+//=======================================================================
+//function : WhichFace
+//purpose  : Give the face dont ledge est le bord
+//=======================================================================
+
+TopoDS_Face BRepBuilderAPI_Sewing::WhichFace(const TopoDS_Edge& theEdg, const Standard_Integer index) const
+{
+  TopoDS_Shape bound = theEdg;
+  if (mySectionBound.IsBound(bound)) bound = mySectionBound(bound);
+  if (myBoundFaces.Contains(bound)) {
+    Standard_Integer i = 1;
+    TopTools_ListIteratorOfListOfShape itf(myBoundFaces.FindFromKey(bound));
+    for (; itf.More(); itf.Next(), i++)
+      if (i == index) return TopoDS::Face(itf.Value());
+  }
+  return TopoDS_Face();
+}
+
+//=======================================================================
+//function : IsClosedShape
+//purpose  : 
+//=======================================================================
+
+static Standard_Boolean IsClosedShape(const TopoDS_Shape& theshape,
+				      const TopoDS_Shape& v1, const TopoDS_Shape& v2)
+{
+  Standard_Real TotLength = 0.0;
+  TopExp_Explorer aexp;
+  for (aexp.Init(theshape,TopAbs_EDGE); aexp.More(); aexp.Next()) {
+    TopoDS_Edge aedge = TopoDS::Edge(aexp.Current());
+    if (aedge.IsNull()) continue;
+    TopoDS_Vertex ve1,ve2;
+    TopExp::Vertices(aedge,ve1,ve2);
+    if (!ve1.IsSame(v1) && !ve1.IsSame(v2)) continue;
+    if (BRep_Tool::Degenerated(aedge)) continue;
+    Standard_Real first,last;
+    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(aedge), first, last);
+    if (!c3d.IsNull()) {
+      GeomAdaptor_Curve cAdapt(c3d);
+      Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
+      TotLength += length;
+      if (ve2.IsSame(v1) || ve2.IsSame(v2)) break;
+    }
+  }
+  if (TotLength > 0.0) {
+    gp_Pnt p1 = BRep_Tool::Pnt(TopoDS::Vertex(v1));
+    gp_Pnt p2 = BRep_Tool::Pnt(TopoDS::Vertex(v2));
+    return (p1.Distance(p2) < TotLength/(1.2 * PI));
+  }
+  return Standard_False;
+}
+
+//=======================================================================
+//function : IsClosedByIsos
+//purpose  : 
+//=======================================================================
+static Standard_Boolean IsClosedByIsos(const Handle(Geom_Surface)& thesurf,
+                                       const Handle(Geom2d_Curve)& acrv2d,
+                                       const Standard_Real f2d,
+                                       const  Standard_Real l2d,
+                                       const Standard_Boolean isUIsos) 
+{
+  Standard_Boolean isClosed = Standard_False;
+ 
+  gp_Pnt2d psurf1 = (acrv2d->IsPeriodic() ? 
+                     acrv2d->Value(f2d) :  acrv2d->Value(Max(f2d,acrv2d->FirstParameter())));
+  gp_Pnt2d psurf2 = (acrv2d->IsPeriodic() ? 
+                     acrv2d->Value(l2d) :  acrv2d->Value(Min(l2d,acrv2d->LastParameter())));
+  Handle(Geom_Curve) aCrv1;
+  Handle(Geom_Curve) aCrv2;
+  if(isUIsos) {
+    aCrv1 = thesurf->UIso(psurf1.X());
+    aCrv2 = thesurf->UIso(psurf2.X());
+  }
+  else {
+    aCrv1 = thesurf->VIso(psurf1.Y());
+    aCrv2 = thesurf->VIso(psurf2.Y());
+  }
+  gp_Pnt p11,p1m,p12,p21,p2m,p22;
+  Standard_Real af1 = aCrv1->FirstParameter();
+  Standard_Real al1 = aCrv1->LastParameter();
+  Standard_Real af2 = aCrv2->FirstParameter();
+  Standard_Real al2 = aCrv2->LastParameter();
+  aCrv1->D0(af1,p11);
+  aCrv1->D0((af1+al1)*0.5,p1m);
+  aCrv1->D0(al1,p12);
+  aCrv2->D0(af2,p21);
+  aCrv2->D0((af2+al2)*0.5,p2m);
+  aCrv2->D0(al2,p22);
+  isClosed = (((p11.XYZ() - p12.XYZ()).Modulus() < 
+               (p11.XYZ() - p1m.XYZ()).Modulus() - Precision::Confusion()) &&
+              ((p21.XYZ() - p22.XYZ()).Modulus() < 
+               (p21.XYZ() - p2m.XYZ()).Modulus() - Precision::Confusion())) ;
+  return isClosed;
+}
+//=======================================================================
+//function : IsUClosedSurface
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsUClosedSurface(const Handle(Geom_Surface)& surf,
+                                                   const TopoDS_Shape& theEdge,
+                                                   const TopLoc_Location& theloc) const
+{
+  Handle(Geom_Surface) tmpsurf = surf;
+  if(tmpsurf->IsKind(STANDARD_TYPE(Geom_RectangularTrimmedSurface))) 
+    tmpsurf = Handle(Geom_RectangularTrimmedSurface)::DownCast(surf)->BasisSurface();
+  else if(tmpsurf->IsKind(STANDARD_TYPE(Geom_OffsetSurface))) 
+    tmpsurf = Handle(Geom_OffsetSurface)::DownCast(surf)->BasisSurface();
+  else {
+    Standard_Boolean isClosed = tmpsurf->IsUClosed();
+    if(!isClosed) {
+      Standard_Real f2d, l2d;
+      Handle(Geom2d_Curve) acrv2d = BRep_Tool::CurveOnSurface(TopoDS::Edge(theEdge), surf,theloc, f2d, l2d);
+      if(!acrv2d.IsNull())
+        isClosed = IsClosedByIsos(tmpsurf,acrv2d,f2d, l2d,Standard_False );
+      
+    }
+    return isClosed;
+  }
+  return IsUClosedSurface(tmpsurf,theEdge,theloc);
+  //return surf->IsUClosed();
+}
+
+//=======================================================================
+//function : IsVClosedSurface
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsVClosedSurface(const Handle(Geom_Surface)& surf,
+                                                   const TopoDS_Shape& theEdge,
+                                                   const TopLoc_Location& theloc) const
+{
+  Handle(Geom_Surface) tmpsurf = surf;
+  if(tmpsurf->IsKind(STANDARD_TYPE(Geom_RectangularTrimmedSurface))) 
+    tmpsurf = Handle(Geom_RectangularTrimmedSurface)::DownCast(surf)->BasisSurface();
+  else if(tmpsurf->IsKind(STANDARD_TYPE(Geom_OffsetSurface))) 
+    tmpsurf = Handle(Geom_OffsetSurface)::DownCast(surf)->BasisSurface();
+  else {
+    Standard_Boolean isClosed = tmpsurf->IsVClosed();
+    if(!isClosed) {
+      Standard_Real f2d, l2d;
+      Handle(Geom2d_Curve) acrv2d = BRep_Tool::CurveOnSurface(TopoDS::Edge(theEdge), surf,theloc, f2d, l2d);
+      if(!acrv2d.IsNull())
+        isClosed = IsClosedByIsos(tmpsurf,acrv2d,f2d, l2d,Standard_True );
+    }
+    return isClosed;
+  }
+  return IsVClosedSurface(tmpsurf,theEdge,theloc);
+  //return surf->IsVClosed();
+}
+
+//=======================================================================
+//function : SameParameter
+//purpose  : internal use
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::SameParameter(const TopoDS_Edge& edge) const
+{
+  try {
+    
+    BRepLib::SameParameter(edge);
+  }
+  catch (Standard_Failure) {
+#ifdef DEB
+    cout << "Exception in BRepBuilderAPI_Sewing::SameParameter: ";
+    Standard_Failure::Caught()->Print(cout); cout << endl;
+#endif
+  }
+}
+
+//=======================================================================
+//function : SameParameterEdge
+//purpose  : internal use
+//           Merge the Sequence Of Section on one edge.
+//           This function keep the curve3d,curve2d,range and parametrization
+//           from the first section, and report and made sameparameter the
+//           pcurves of the other function.
+//           This function works when the are not more than two Pcurves
+//           on a same face.
+//=======================================================================
+
+TopoDS_Edge BRepBuilderAPI_Sewing::SameParameterEdge(const TopoDS_Shape& edge,
+					       const TopTools_SequenceOfShape& seqEdges,
+					       const TColStd_SequenceOfInteger& seqForward,
+					       TopTools_MapOfShape& mapMerged,
+					       const Handle(BRepTools_ReShape)& locReShape)
+{
+  // Retrieve reference section
+  TopoDS_Shape aTmpShape = myReShape->Apply(edge); //for porting
+  TopoDS_Edge Edge1 = TopoDS::Edge(aTmpShape);
+  aTmpShape = locReShape->Apply(Edge1);
+  if (locReShape != myReShape) Edge1 = TopoDS::Edge(aTmpShape);
+  Standard_Boolean isDone = Standard_False;
+
+  // Create data structures for temporary merged edges
+  TopTools_ListOfShape listFaces1;
+  TopTools_MapOfShape MergedFaces;
+
+  if (mySewing) {
+
+    // Fill MergedFaces with faces of Edge1
+    TopoDS_Shape bnd1 = edge;
+    if (mySectionBound.IsBound(bnd1)) bnd1 = mySectionBound(bnd1);
+    if (myBoundFaces.Contains(bnd1)) {
+      TopTools_ListIteratorOfListOfShape itf(myBoundFaces.FindFromKey(bnd1));
+      for (; itf.More(); itf.Next())
+	if (MergedFaces.Add(itf.Value()))
+	  listFaces1.Append(itf.Value());
+    }
+  }
+  else {
+
+    // Create presentation edge
+    TopoDS_Vertex V1, V2;
+    TopExp::Vertices(Edge1,V1,V2);
+    if (myVertexNode.Contains(V1)) V1 = TopoDS::Vertex(myVertexNode.FindFromKey(V1));
+    if (myVertexNode.Contains(V2)) V2 = TopoDS::Vertex(myVertexNode.FindFromKey(V2));
+
+    TopoDS_Edge NewEdge = Edge1;
+    NewEdge.EmptyCopy();
+
+    // Add the vertices
+    BRep_Builder aBuilder;
+    TopoDS_Shape anEdge = NewEdge.Oriented(TopAbs_FORWARD);
+    aBuilder.Add(anEdge,V1.Oriented(TopAbs_FORWARD));
+    aBuilder.Add(anEdge,V2.Oriented(TopAbs_REVERSED));
+
+    Edge1 = NewEdge;
+  }
+
+  Standard_Boolean isForward = Standard_True;
+
+  // Merge candidate sections
+  for (Standard_Integer i = 1; i <= seqEdges.Length(); i++) {
+
+    // Retrieve candidate section
+    TopoDS_Shape oedge2 = seqEdges(i);
+
+    if (mySewing) {
+
+      aTmpShape = myReShape->Apply(oedge2); //for porting
+      TopoDS_Edge Edge2 = TopoDS::Edge(aTmpShape);
+      aTmpShape = locReShape->Apply(Edge2);
+      if (locReShape != myReShape) Edge2 = TopoDS::Edge(aTmpShape);
+
+      // Calculate relative orientation
+      Standard_Integer Orientation = seqForward(i);
+      if (!isForward) Orientation = (Orientation? 0 : 1);
+
+      // Retrieve faces information for the second edge
+      TopoDS_Shape bnd2 = oedge2;
+      if (mySectionBound.IsBound(bnd2)) bnd2 = mySectionBound(bnd2);
+      if (!myBoundFaces.Contains(bnd2)) continue; // Skip floating edge
+      const TopTools_ListOfShape& listFaces2 = myBoundFaces.FindFromKey(bnd2);
+
+      Standard_Integer whichSec = 1; // Indicates on which edge the pCurve has been reported
+      TopoDS_Edge NewEdge = SameParameterEdge(Edge1,Edge2,listFaces1,listFaces2,Orientation,whichSec);
+      if (NewEdge.IsNull()) continue;
+
+      // Record faces information for the temporary merged edge
+      TopTools_ListIteratorOfListOfShape itf(listFaces2);
+      for (; itf.More(); itf.Next())
+	if (MergedFaces.Add(itf.Value()))
+	  listFaces1.Append(itf.Value());
+
+      // Record merged section orientation
+      if (!Orientation && whichSec != 1)
+	isForward = isForward? Standard_False : Standard_True;
+      Edge1 = NewEdge;
+    }
+
+    // Append actually merged edge
+    mapMerged.Add(oedge2);
+    isDone = Standard_True;
+
+    if (!myNonmanifold) break;
+  }
+
+  if (isDone) {
+    // Change result orientation
+    Edge1.Orientation(isForward? TopAbs_FORWARD : TopAbs_REVERSED);
+  }
+  else Edge1.Nullify();
+
+  return Edge1;
+}
+
+//=======================================================================
+//function : SameParameterEdge
+//purpose  : internal use
+//=======================================================================
+static Standard_Boolean findNMVertices(const TopoDS_Edge& theEdge,
+                                       TopTools_SequenceOfShape& theSeqNMVert,
+                                       TColStd_SequenceOfReal& theSeqPars)
+{
+  TopoDS_Iterator aItV(theEdge,Standard_False);
+  for( ; aItV.More(); aItV.Next()) {
+    if(aItV.Value().Orientation() == TopAbs_INTERNAL || 
+        aItV.Value().Orientation() == TopAbs_EXTERNAL)
+    theSeqNMVert.Append(aItV.Value());
+  }
+  Standard_Integer nbV = theSeqNMVert.Length();
+  if(!nbV)
+    return Standard_False;
+  Standard_Real first, last;
+  Handle(Geom_Curve) c3d = BRep_Tool::Curve(theEdge,first, last);
+  GeomAdaptor_Curve GAC(c3d);
+  Extrema_ExtPC locProj;
+  locProj.Initialize(GAC, first, last);
+  gp_Pnt pfirst = GAC.Value(first), plast = GAC.Value(last);
+
+  
+  for (Standard_Integer i = 1; i <= nbV; i++) {
+    TopoDS_Vertex aV = TopoDS::Vertex(theSeqNMVert.Value(i));
+    gp_Pnt pt = BRep_Tool::Pnt(aV);
+    
+    Standard_Real distF = pfirst.Distance(pt);
+    Standard_Real distL = plast.Distance(pt);
+    Standard_Real apar = (distF > distL ? last : first);
+    Standard_Boolean isProjected = Standard_False;
+    // Project current point on curve
+    locProj.Perform(pt);
+    if (locProj.IsDone() && locProj.NbExt() > 0) {
+	  Standard_Real distMin = Min(distF,distL);
+	  Standard_Integer ind, indMin = 0;
+	  for (ind = 1; ind <= locProj.NbExt(); ind++) {
+	    Standard_Real dProj = locProj.Value(ind);
+	    if (dProj < distMin) { 
+          indMin = ind; distMin = dProj; 
+        }
+      }
+      if(indMin) 
+        apar = locProj.Point(indMin).Parameter();
+         
+      theSeqPars.Append(apar);  
+        
+    }
+  }
+  return Standard_True;
+}
+
+static Standard_Real ComputeToleranceVertex(Standard_Real dist, Standard_Real Tol1, Standard_Real Tol2)
+{
+  Standard_Real resTol =0;
+  if((dist + Tol1) <= Tol2)
+    resTol = Tol2;
+  else if((dist + Tol2) <= Tol1)
+    resTol = Tol1;
+  else 
+    resTol =(dist + Tol1 + Tol2)*0.5;
+  return resTol;
+  
+}
+TopoDS_Edge BRepBuilderAPI_Sewing::SameParameterEdge(const TopoDS_Edge& edgeFirst,
+					       const TopoDS_Edge& edgeLast,
+					       const TopTools_ListOfShape& listFacesFirst,
+					       const TopTools_ListOfShape& listFacesLast,
+					       const Standard_Boolean secForward, 
+					       Standard_Integer& whichSec,
+					       const Standard_Boolean firstCall)
+{
+  // Do not process floating edges
+  if (!listFacesFirst.Extent() || !listFacesLast.Extent()) return TopoDS_Edge();
+
+  // Sort input edges
+  TopoDS_Edge edge1, edge2;
+  if (firstCall) {
+    // Take the longest edge as first
+    Standard_Real f, l;
+    Handle(Geom_Curve) c3d1 = BRep_Tool::Curve(TopoDS::Edge(edgeFirst), f, l);
+    GeomAdaptor_Curve cAdapt1(c3d1);
+    Standard_Real len1 = GCPnts_AbscissaPoint::Length(cAdapt1, f, l);
+    Handle(Geom_Curve) c3d2 = BRep_Tool::Curve(TopoDS::Edge(edgeLast), f, l);
+    GeomAdaptor_Curve cAdapt2(c3d2);
+    Standard_Real len2 = GCPnts_AbscissaPoint::Length(cAdapt2, f, l);
+    if (len1 < len2) {
+      edge1 = edgeLast;
+      edge2 = edgeFirst;
+      whichSec = 2;
+    }
+    else {
+      edge1 = edgeFirst;
+      edge2 = edgeLast;
+      whichSec = 1;
+    }
+  }
+  else {
+    if (whichSec == 1) {
+      edge1 = edgeLast;
+      edge2 = edgeFirst;
+      whichSec = 2;
+    }
+    else {
+      edge1 = edgeFirst;
+      edge2 = edgeLast;
+      whichSec = 1;
+    }
+  }
+
+  Standard_Real first, last;
+  BRep_Tool::Range(edge1, first, last);
+  BRep_Builder aBuilder;
+
+  //To keep NM vertices on edge
+  TopTools_SequenceOfShape aSeqNMVert;
+  TColStd_SequenceOfReal aSeqNMPars;
+  findNMVertices(edge1,aSeqNMVert,aSeqNMPars);
+  findNMVertices(edge2,aSeqNMVert,aSeqNMPars);
+
+  // Create new edge
+  TopoDS_Edge edge;
+  aBuilder.MakeEdge(edge);
+  edge.Orientation( edge1.Orientation());
+ 
+
+  // Retrieve edge curve
+  TopLoc_Location loc3d;
+  Standard_Real first3d, last3d;
+  Handle(Geom_Curve) c3d = BRep_Tool::Curve(edge1, loc3d, first3d, last3d);
+  if (!loc3d.IsIdentity()) {
+    c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+    c3d->Transform(loc3d.Transformation());
+  }
+  aBuilder.UpdateEdge(edge,c3d,BRep_Tool::Tolerance(edge1));
+  aBuilder.Range(edge, first, last);
+  aBuilder.SameRange(edge, Standard_False); //Standard_True
+  aBuilder.SameParameter(edge, Standard_False);
+  // Create and add new vertices
+  {
+    TopoDS_Vertex V1New, V2New;
+
+    // Retrieve original vertices from edges
+    TopoDS_Vertex V11,V12,V21,V22;
+    TopExp::Vertices(edge1,V11,V12);
+    TopExp::Vertices(edge2,V21,V22);
+
+    //szv: do not reshape here!!!
+    //V11 = TopoDS::Vertex(myReShape->Apply(V11));
+    //V12 = TopoDS::Vertex(myReShape->Apply(V12));
+    //V21 = TopoDS::Vertex(myReShape->Apply(V21));
+    //V22 = TopoDS::Vertex(myReShape->Apply(V22));
+
+    gp_Pnt p11 = BRep_Tool::Pnt(V11);
+    gp_Pnt p12 = BRep_Tool::Pnt(V12);
+    gp_Pnt p21 = BRep_Tool::Pnt(V21); 
+    gp_Pnt p22 = BRep_Tool::Pnt(V22);
+
+    // Check if edges are closed
+    Standard_Boolean isClosed1 = V11.IsSame(V12);
+    Standard_Boolean isClosed2 = V21.IsSame(V22);
+
+    //Standard_Boolean isRev = Standard_False;
+    gp_Pnt pfirst;
+    Standard_Real Tol1 = 0.;
+    if (isClosed1 || isClosed2) {
+      // at least one of the edges is closed
+      if (isClosed1 && isClosed2) {
+	// both edges are closed
+	pfirst.SetXYZ(0.5*(p11.XYZ() + p21.XYZ()));
+        gp_Vec v1 =  p21.XYZ() - p11.XYZ();
+        Standard_Real d1 = v1.Magnitude();
+        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21));
+	//Tol1 = Max(pfirst.Distance(p11),pfirst.Distance(p21));
+      }
+      else if (isClosed1) {
+	// only first edge is closed
+        gp_XYZ pt =0.5*(p21.XYZ()+ p22.XYZ());
+  	    pfirst.SetXYZ(0.5*(p11.XYZ() + pt));
+        gp_Vec v1 =  p22.XYZ() - p21.XYZ();
+        Standard_Real d1 = v1.Magnitude();
+        Tol1= ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V22),BRep_Tool::Tolerance(V21));
+        gp_Vec v2 =  p11.XYZ() - pt;
+        Standard_Real d2 = v2.Magnitude();
+        Tol1= ComputeToleranceVertex(d2,Tol1,BRep_Tool::Tolerance(V11));
+	//Tol1 = Max(pfirst.Distance(p21),pfirst.Distance(p22));
+	//Tol1 = Max(pfirst.Distance(p11),Tol1);
+      }
+      else {
+	// only second edge is closed
+        gp_XYZ pt = 0.5*(p11.XYZ()+ p12.XYZ());
+	    pfirst.SetXYZ(0.5*(p21.XYZ() + pt));
+        gp_Vec v1 =  p11.XYZ() - p12.XYZ();
+        Standard_Real d1 = v1.Magnitude();
+        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V12));
+        gp_Vec v2 =  p21.XYZ() - pt;
+        Standard_Real d2 = v2.Magnitude();
+        Tol1 = ComputeToleranceVertex(d2,Tol1,BRep_Tool::Tolerance(V21));
+	//Tol1 = Max(pfirst.Distance(p11),pfirst.Distance(p12));
+	//Tol1 = Max(pfirst.Distance(p21),Tol1);
+      }
+      aBuilder.MakeVertex(V1New,pfirst,Tol1);
+      V2New = V1New;
+    }
+    else {
+      // both edges are open
+      gp_Pnt plast;
+      Standard_Real Tol2 = 0.;
+      if (secForward) {
+	    pfirst.SetXYZ(0.5*(p11.XYZ() + p21.XYZ()));
+	    plast.SetXYZ(0.5*(p12.XYZ() + p22.XYZ()));
+        gp_Vec v1 =  p21.XYZ() - p11.XYZ();
+        Standard_Real d1 = v1.Magnitude();
+        gp_Vec v2 =  p22.XYZ() - p12.XYZ();
+        Standard_Real d2 = v2.Magnitude();
+        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21));
+        Tol2 = ComputeToleranceVertex(d2,BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V22));
+
+//	Tol1 = Max(Max(pfirst.Distance(p11),pfirst.Distance(p21)),
+//		   Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V21)));
+//	Tol2 = Max(Max(plast.Distance(p12),plast.Distance(p22)),
+//		   Max(BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V22)));
+      }
+      else {
+	    pfirst.SetXYZ(0.5*(p11.XYZ() + p22.XYZ()));
+	    plast.SetXYZ(0.5*(p12.XYZ() + p21.XYZ()));
+        
+        gp_Vec v1 =  p22.XYZ() - p11.XYZ();
+        Standard_Real d1 = v1.Magnitude();
+        gp_Vec v2 =  p21.XYZ() - p12.XYZ();
+        Standard_Real d2 = v2.Magnitude();
+        Tol1 = ComputeToleranceVertex(d1,BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22));
+        Tol2 = ComputeToleranceVertex(d2,BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V21));
+//        Tol1 = Max(Max(pfirst.Distance(p11),pfirst.Distance(p22)),
+//		   Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22)));
+//	Tol2 = Max(Max(plast.Distance(p12),plast.Distance(p21)),
+//		   Max(BRep_Tool::Tolerance(V12),BRep_Tool::Tolerance(V21)));
+      }
+      //gp_Pnt pcu;
+      ///c3d->D0(first3d,pcu);
+      //Tol1 = Max(pfirst.Distance(pcu) + Max(BRep_Tool::Tolerance(V11),BRep_Tool::Tolerance(V22));
+      aBuilder.MakeVertex(V1New,pfirst,Tol1);
+      //c3d->D0(last3d,pcu);
+      //Tol2 = plast.Distance(pcu);
+      aBuilder.MakeVertex(V2New,plast,Tol2);
+    }
+
+    // Add the vertices in the good sense
+    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
+    TopoDS_Shape aLocalEdge = V1New.Oriented(TopAbs_FORWARD); //(listNode.First()).Oriented(TopAbs_FORWARD);
+    aBuilder.Add(anEdge,aLocalEdge);
+    aLocalEdge = V2New.Oriented(TopAbs_REVERSED); //(listNode.Last()).Oriented(TopAbs_REVERSED);
+    aBuilder.Add(anEdge,aLocalEdge);
+
+    Standard_Integer k =1;
+    for( ; k <= aSeqNMVert.Length(); k++)
+      aBuilder.Add(anEdge,aSeqNMVert.Value(k));
+
+  }
+
+  // Retrieve second PCurves
+  TopLoc_Location loc2;
+  Handle(Geom_Surface) surf2;
+  //Handle(Geom2d_Curve) c2d2, c2d21;
+  //  Standard_Real firstOld, lastOld;
+
+  TopTools_ListIteratorOfListOfShape itf2;
+  if (whichSec == 1) itf2.Initialize(listFacesLast);
+  else               itf2.Initialize(listFacesFirst);
+  Standard_Boolean isResEdge = Standard_False;
+  for (; itf2.More(); itf2.Next()) {
+    Handle(Geom2d_Curve) c2d2, c2d21;
+    Standard_Real firstOld, lastOld;
+    const TopoDS_Face& fac2 = TopoDS::Face(itf2.Value());
+
+    surf2 = BRep_Tool::Surface(fac2, loc2);
+    Standard_Boolean isSeam2 = ((IsUClosedSurface(surf2,edge2,loc2) || IsVClosedSurface(surf2,edge2,loc2)) &&
+				BRep_Tool::IsClosed(TopoDS::Edge(edge2),fac2));
+    if (isSeam2) {
+      if (!myNonmanifold) return TopoDS_Edge();
+      TopoDS_Shape aTmpShape = edge2.Reversed(); //for porting
+      c2d21 = BRep_Tool::CurveOnSurface(TopoDS::Edge(aTmpShape), fac2, firstOld, lastOld);
+    }
+    c2d2 = BRep_Tool::CurveOnSurface(edge2, fac2, firstOld, lastOld);
+    if (c2d2.IsNull() && c2d21.IsNull()) continue;
+
+    if (!c2d21.IsNull()) {
+      c2d21 = Handle(Geom2d_Curve)::DownCast(c2d21->Copy());
+      if (!secForward) {
+	if (c2d21->IsKind(STANDARD_TYPE(Geom2d_Line)))
+	  c2d21 = new Geom2d_TrimmedCurve(c2d21, firstOld, lastOld);
+	Standard_Real first2d = firstOld; //c2dTmp->FirstParameter(); BUG USA60321
+	Standard_Real last2d = lastOld;   //c2dTmp->LastParameter();
+	firstOld = c2d21->ReversedParameter(last2d);
+	lastOld = c2d21->ReversedParameter(first2d);
+	c2d21->Reverse();
+      }
+      c2d21 = SameRange(c2d21,firstOld,lastOld,first,last);
+    }
+
+    // Make second PCurve sameRange with the 3d curve
+    c2d2 = Handle(Geom2d_Curve)::DownCast(c2d2->Copy());
+
+    if (!secForward) {
+      if (c2d2->IsKind(STANDARD_TYPE(Geom2d_Line)))
+	c2d2 = new Geom2d_TrimmedCurve(c2d2, firstOld, lastOld);
+      Standard_Real first2d = firstOld; //c2dTmp->FirstParameter(); BUG USA60321
+      Standard_Real last2d = lastOld;   //c2dTmp->LastParameter();
+      firstOld = c2d2->ReversedParameter(last2d);
+      lastOld = c2d2->ReversedParameter(first2d);
+      c2d2->Reverse();
+    }
+
+    c2d2 = SameRange(c2d2,firstOld,lastOld,first,last);
+    if (c2d2.IsNull()) continue;
+    
+    // Add second PCurve
+    Standard_Boolean isSeam = Standard_False;
+    TopAbs_Orientation Ori = TopAbs_FORWARD;
+    //Handle(Geom2d_Curve) c2d1, c2d11;
+
+    TopTools_ListIteratorOfListOfShape itf1;
+    if (whichSec == 1) itf1.Initialize(listFacesFirst);
+    else               itf1.Initialize(listFacesLast);
+    for (; itf1.More() && !isSeam; itf1.Next()) {
+      Handle(Geom2d_Curve) c2d1, c2d11;
+      const TopoDS_Face& fac1 = TopoDS::Face(itf1.Value());
+
+      TopLoc_Location loc1;
+      Handle(Geom_Surface) surf1 = BRep_Tool::Surface(fac1, loc1);
+      Standard_Real first2d, last2d;
+      Standard_Boolean isSeam1 = ((IsUClosedSurface(surf1,edge1,loc1) || IsVClosedSurface(surf1,edge1,loc1)) &&
+				  BRep_Tool::IsClosed(TopoDS::Edge(edge1),fac1));
+      c2d1 = BRep_Tool::CurveOnSurface(edge1, fac1, first2d, last2d);
+      Ori = edge1.Orientation();
+      if (fac1.Orientation() == TopAbs_REVERSED) 
+        Ori = TopAbs::Reverse(Ori);
+      
+      if (isSeam1) {
+	if (!myNonmanifold) return TopoDS_Edge();
+        TopoDS_Shape aTmpShape = edge1.Reversed(); //for porting
+        c2d11 = BRep_Tool::CurveOnSurface(TopoDS::Edge(aTmpShape), fac1, first2d, last2d);
+        //if(fac1.Orientation() == TopAbs_REVERSED) //
+        if(Ori == TopAbs_FORWARD)
+          aBuilder.UpdateEdge(edge,c2d1,c2d11,fac1,0);
+        else
+          aBuilder.UpdateEdge(edge,c2d11,c2d1,fac1,0);
+      }
+      else  aBuilder.UpdateEdge(edge,c2d1,fac1,0);
+      
+      if (c2d1.IsNull() && c2d11.IsNull()) continue;
+
+      //Ori = edge1.Orientation();
+      //if (fac1.Orientation() == TopAbs_REVERSED) TopAbs::Reverse(Ori);
+
+      if (surf2 == surf1) {
+	// Merge sections which are on the same face
+	if (!loc2.IsDifferent(loc1)) {
+	  Standard_Boolean uclosed = IsUClosedSurface(surf2,edge2,loc2);
+	  Standard_Boolean vclosed = IsVClosedSurface(surf2,edge2,loc2);
+	  if (uclosed || vclosed) {
+	    Standard_Real pf = c2d1->FirstParameter();
+//	    Standard_Real pl = c2d1->LastParameter();
+	    gp_Pnt2d p1n = c2d1->Value(Max(first,pf));
+//	    gp_Pnt2d p2n = c2d1->Value(Min(pl,last));
+            gp_Pnt2d p21n = c2d2->Value(Max(first,c2d2->FirstParameter()));
+            gp_Pnt2d p22n = c2d2->Value(Min(last,c2d2->LastParameter()));
+            Standard_Real aDist = Min(p1n.Distance(p21n), p1n.Distance(p22n));
+	    Standard_Real U1, U2, V1, V2;
+	    surf2->Bounds(U1, U2, V1, V2);
+	    isSeam = ((uclosed && aDist > 0.75*(fabs(U2-U1))) ||
+		      (vclosed && aDist > 0.75*(fabs(V2-V1))));
+            if( !isSeam && BRep_Tool::IsClosed(TopoDS::Edge(edge),fac1)) continue;
+	  }
+	}
+      }
+     
+      isResEdge = Standard_True;
+      if (isSeam) {
+        if (Ori == TopAbs_FORWARD)
+          aBuilder.UpdateEdge(edge, c2d1, c2d2, surf2, loc2, Precision::Confusion());
+        else
+          aBuilder.UpdateEdge(edge, c2d2, c2d1, surf2, loc2, Precision::Confusion());
+      }
+      else if (isSeam2) {
+        TopAbs_Orientation InitOri  = edge2.Orientation();
+         TopAbs_Orientation SecOri  = edge.Orientation();
+        if (fac2.Orientation() == TopAbs_REVERSED) {
+          
+          InitOri = TopAbs::Reverse(InitOri);
+          SecOri = TopAbs::Reverse(SecOri);
+        }
+        if(!secForward)
+          InitOri = TopAbs::Reverse(InitOri);
+        
+        if (InitOri == TopAbs_FORWARD)
+          aBuilder.UpdateEdge(edge, c2d2,c2d21, surf2, loc2, Precision::Confusion());
+        else
+          aBuilder.UpdateEdge(edge, c2d21,c2d2, surf2, loc2, Precision::Confusion());
+      } 
+      else {
+        aBuilder.UpdateEdge(edge, c2d2, surf2, loc2, Precision::Confusion());
+      }
+      
+    }
+  }
+  if(isResEdge)
+  // Try to make the edge sameparameter
+    SameParameter(edge);
+
+  //  Standard_Real tolReached = BRep_Tool::Tolerance(edge);
+  //if (!BRep_Tool::SameParameter(edge)) return edge; //gka ????????
+
+  if (firstCall && (!BRep_Tool::SameParameter(edge) || !isResEdge)) {
+    Standard_Integer whichSecn = whichSec;
+    // Try to merge on the second section
+    Standard_Boolean second_ok = Standard_True;
+    TopoDS_Edge s_edge = SameParameterEdge(edgeFirst,edgeLast,listFacesFirst,listFacesLast,
+					   secForward,whichSecn,Standard_False);
+    //if (s_edge.IsNull()) return s_edge; // gka version for free edges
+    if (s_edge.IsNull()) second_ok = Standard_False;
+    else if (!BRep_Tool::SameParameter(s_edge)) second_ok = Standard_False;
+    else {
+      edge = s_edge;
+      whichSec = whichSecn;
+    }
+
+    if (!second_ok) {
+
+      GeomAdaptor_Curve c3dAdapt(c3d);
+
+      // Discretize edge curve
+      Standard_Integer i, j, nbp = 15;
+      Standard_Real deltaT = (last3d - first3d) / (nbp + 1);
+      TColgp_Array1OfPnt c3dpnt(1,nbp);
+      for (i = 1; i <= nbp; i++) c3dpnt(i) = c3dAdapt.Value(first3d + i*deltaT);
+
+      Standard_Real u, v, dist, maxTol = -1.0;
+      Standard_Boolean more = Standard_True;
+
+      for (j = 1; more; j++) {
+        Handle(Geom2d_Curve) c2d2;
+	BRep_Tool::CurveOnSurface(edge, c2d2, surf2, loc2, first, last, j);
+	more = !c2d2.IsNull();
+	if (more) {
+
+	  deltaT = (last - first) / (nbp + 1);
+	  for (i = 1; i <= nbp; i++) {
+	    c2d2->Value(first + i*deltaT).Coord(u,v);
+	    dist = surf2->Value(u,v).Distance(c3dpnt(i));
+	    if (dist > maxTol) maxTol = dist;
+	  }
+	}
+      }
+
+      if (maxTol >= 0.) aBuilder.UpdateEdge(edge, maxTol);
+      aBuilder.SameParameter(edge,Standard_True);
+    }
+  }
+
+  BRepLib::EncodeRegularity(edge,0.01);
+  Standard_Real tolEdge1 = BRep_Tool::Tolerance(edge);
+  if (tolEdge1 > MaxTolerance()) edge.Nullify();
+  return edge;
+}
+
+//=======================================================================
+// function : EvaluateAngulars
+// purpose  : internal use
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::EvaluateAngulars(TopTools_SequenceOfShape& sequenceSec,
+				       TColStd_Array1OfBoolean& secForward,
+				       TColStd_Array1OfReal& tabAng,
+				       const Standard_Integer indRef) const
+{
+  tabAng.Init(-1.0);
+
+  Standard_Integer i, j, npt = 4, lengSec = sequenceSec.Length();
+
+  TopoDS_Edge edge;
+  TopoDS_Face face;
+  TopLoc_Location loc;
+  Standard_Real first, last;
+  Handle(Geom_Curve) c3d;
+  Handle(Geom2d_Curve) c2d;
+  Handle(Geom_Surface) surf;
+  TColgp_Array1OfVec normRef(1,npt);
+
+  for (i = indRef; i <= lengSec; i++) {
+
+    edge = TopoDS::Edge(sequenceSec(i));
+
+    TopoDS_Shape bnd = edge;
+    if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
+    if (myBoundFaces.Contains(bnd)) {
+      face = TopoDS::Face(myBoundFaces.FindFromKey(bnd).First());
+      surf = BRep_Tool::Surface(face,loc);
+      if (!loc.IsIdentity()) {
+	surf = Handle(Geom_Surface)::DownCast(surf->Copy());
+	surf->Transform(loc.Transformation());
+      }
+      c2d = BRep_Tool::CurveOnSurface(edge, face, first, last);
+    }
+    else if (i == indRef) return;
+    else continue;
+
+    c3d = BRep_Tool::Curve(edge, loc, first, last);
+    if (!loc.IsIdentity()) {
+      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+      c3d->Transform(loc.Transformation());
+    }
+
+    GeomAdaptor_Curve adapt(c3d);
+    GCPnts_UniformAbscissa uniAbs(adapt, npt, first, last);
+
+    Standard_Real cumulateAngular = 0.0;
+    Standard_Integer nbComputedAngle = 0;
+
+    for (j = 1; j <= npt; j++) {
+      gp_Pnt2d P;
+      c2d->D0(uniAbs.Parameter((secForward(i) || i == indRef)? j : npt-j+1),P);
+      gp_Vec w1, w2;
+      gp_Pnt unused;
+      surf->D1(P.X(), P.Y(), unused, w1, w2);
+      gp_Vec n = w1^w2; // Compute the normal vector
+      if (i == indRef) normRef(j) = n;
+      else if ((n.Magnitude()>gp::Resolution()) && (normRef(j).Magnitude()>gp::Resolution())) {
+	nbComputedAngle++;
+	Standard_Real angular = n.Angle(normRef(j));
+	if (angular > PI/2.) angular = PI - angular;
+	cumulateAngular += angular;
+      }
+    }
+
+    if (nbComputedAngle)
+      tabAng(i) = cumulateAngular/((Standard_Real)nbComputedAngle);
+  }
+}
+
+//=======================================================================
+// function : EvaluateDistances
+// purpose  : internal use
+// Evaluate distance beetween edges with indice indRef and the following edges in the list
+// Remarks (lengSec - indRef) must be >= 1 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::EvaluateDistances(TopTools_SequenceOfShape& sequenceSec,
+					TColStd_Array1OfBoolean& secForward,
+					TColStd_Array1OfReal& tabDst,
+					const Standard_Integer indRef) const
+{
+  tabDst.Init(-1.0);
+
+  const Standard_Integer npt = 8; // Number of points for curve discretization
+  TColgp_Array1OfPnt ptsRef(1, npt), ptsSec(1, npt);
+
+  Standard_Integer i, j, lengSec = sequenceSec.Length();
+  TColgp_SequenceOfPnt seqSec;
+
+  Handle(Geom_Curve) c3dRef;
+  Standard_Real firstRef=0., lastRef=0.;
+
+  for (i = indRef; i <= lengSec; i++) {
+
+    // reading of the edge (attention for the first one: reference)
+    const TopoDS_Edge& sec = TopoDS::Edge(sequenceSec(i));
+
+    TopLoc_Location loc;
+    Standard_Real first, last;
+    Handle(Geom_Curve) c3d = BRep_Tool::Curve(sec, loc, first, last);
+    if (!loc.IsIdentity()) {
+      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+      c3d->Transform(loc.Transformation());
+    }
+
+    if (i == indRef) {
+      c3dRef = c3d; firstRef = first; lastRef = last;
+    }
+
+    Standard_Real dist, distFor = -1.0, distRev = -1.0;
+
+    Standard_Real T, deltaT = (last - first) / (npt - 1);
+    for (j = 1; j <= npt; j++) {
+
+      // Uniform parameter on curve
+      if (j == 1) T = first;
+      else if (j == npt) T = last;
+      else T = first + (j - 1) * deltaT;
+
+      // Take point on curve
+      gp_Pnt pt = c3d->Value(T);
+
+      if (i == indRef) {
+	ptsRef(j) = pt;
+      }
+      else {
+	ptsSec(j) = pt;
+	// To evaluate mutual orientation and distance
+	dist = pt.Distance(ptsRef(j));
+	if (distFor < dist) distFor = dist;
+	dist = pt.Distance(ptsRef(npt-j+1));
+	if (distRev < dist) distRev = dist;
+      }
+    }
+
+    // Record mutual orientation
+    Standard_Boolean isForward = (distFor < distRev); //szv debug: <=
+    secForward(i) = isForward;
+
+    dist = (isForward? distFor : distRev);
+    if (dist < /*Precision::Confusion()*/ myTolerance) {
+      // Section is close - record distance
+      tabDst(i) = dist;
+    }
+    else {
+      // Section is distant - record points
+      for (j = 1; j <= npt; j++) seqSec.Append(ptsSec(j));
+    }
+  }
+
+  // Project distant points
+  Standard_Integer nbFailed = seqSec.Length();
+  if (!nbFailed) return;
+
+  TColgp_Array1OfPnt arrPnt(1, nbFailed), arrProj(1, nbFailed);
+  for (i = 1; i <= nbFailed; i++) arrPnt(i) = seqSec(i); seqSec.Clear();
+  TColStd_Array1OfReal arrDist(1, nbFailed), arrPara(1, nbFailed);
+
+  ProjectPointsOnCurve(arrPnt,c3dRef,firstRef,lastRef,arrDist,arrPara,arrProj);
+
+  // Process distant sections
+  Standard_Integer idx1 = 1;
+  for (i = indRef + 1; i <= lengSec; i++) {
+
+    // Skip section if already evaluated
+    if (tabDst(i) >= 0.0) continue;
+
+    Standard_Real dist, distMax = -1.0;
+
+    Standard_Integer idx2 = (idx1 - 1)*npt;
+
+    for (j = 1; j <= npt; j++) {
+
+      dist = arrDist(idx2 + j);
+      // If point is not projected - stop evaluation
+      if (dist < 0.0) { distMax = -1.0; break; }
+      if (distMax < dist) distMax = dist;
+    }
+
+    // If section is close - record distance
+    if (distMax >= 0.0) {
+      if (secForward(i)) {
+	dist = arrPnt(idx2+1).Distance(ptsRef(1));
+	if (distMax < dist) distMax = dist;
+	dist = arrPnt(idx2+npt).Distance(ptsRef(npt));
+	if (distMax < dist) distMax = dist;
+      }
+      else {
+	dist = arrPnt(idx2+1).Distance(ptsRef(npt));
+	if (distMax < dist) distMax = dist;
+	dist = arrPnt(idx2+npt).Distance(ptsRef(1));
+	if (distMax < dist) distMax = dist;
+      }
+
+      if (distMax < myTolerance) tabDst(i) = distMax;
+    }
+
+    idx1++; // To the next distant curve
+  }
+}
+
+//=======================================================================
+//function : IsMergedClosed
+//purpose  :  internal use
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsMergedClosed(const TopoDS_Edge& Edge1,
+						 const TopoDS_Edge& Edge2,
+						 const TopoDS_Face& face) const
+{
+  // Check for closed surface
+  TopLoc_Location loc;
+  Handle(Geom_Surface) surf = BRep_Tool::Surface(face,loc);
+  Standard_Boolean isUClosed = IsUClosedSurface(surf,Edge1,loc);
+  Standard_Boolean isVClosed = IsVClosedSurface(surf,Edge1,loc);
+  if (!isUClosed && !isVClosed) return Standard_False;
+  // Check condition on closed surface
+  /*
+  Standard_Real first1,last1,first2,last2;
+  Handle(Geom_Curve) C3d1 = BRep_Tool::Curve(Edge1,first1,last1);
+  Handle(Geom_Curve) C3d2 = BRep_Tool::Curve(Edge2,first2,last2);
+  if (C3d1.IsNull() || C3d2.IsNull()) return Standard_False;
+  */
+  Standard_Real first2d1,last2d1,first2d2,last2d2;
+  Handle(Geom2d_Curve) C2d1 = BRep_Tool::CurveOnSurface(Edge1,face,first2d1,last2d1);
+  Handle(Geom2d_Curve) C2d2 = BRep_Tool::CurveOnSurface(Edge2,face,first2d2,last2d2);
+  if (C2d1.IsNull() || C2d2.IsNull()) return Standard_False;
+  /*
+  gp_Pnt p1 = C3d1->Value(0.5*(first1 + last1));
+  gp_Pnt p2 = C3d1->Value(0.5*(first2 + last2));
+  Standard_Real dist = p1.Distance(p2);
+  gp_Pnt2d p12d = C2d1->Value(0.5*(first2d1 + last2d1));
+  gp_Pnt2d p22d = C2d1->Value(0.5*(first2d2 + last2d2));
+  Standard_Real dist2d = p12d.Distance(p22d);
+  GeomAdaptor_Surface Ads(BRep_Tool::Surface(face));
+  Standard_Real distSurf = Max(Ads.UResolution(dist), Ads.VResolution(dist));
+  return (dist2d*0.2 >= distSurf);
+  */
+  Standard_Integer isULongC1, isULongC2, isVLongC1, isVLongC2;
+  Standard_Real SUmin, SUmax, SVmin, SVmax;
+  Standard_Real C1Umin, C1Vmin, C1Umax, C1Vmax;
+  Standard_Real C2Umin, C2Vmin, C2Umax, C2Vmax;
+  { //szv: Use brackets to destroy local variables
+    Bnd_Box2d B1, B2;
+    Geom2dAdaptor_Curve aC2d1(C2d1), aC2d2(C2d2);
+    BndLib_Add2dCurve::Add(aC2d1,first2d1,last2d1,Precision::PConfusion(),B1);
+    BndLib_Add2dCurve::Add(aC2d2,first2d2,last2d2,Precision::PConfusion(),B2);
+    B1.Get(C1Umin,C1Vmin,C1Umax,C1Vmax);
+    B2.Get(C2Umin,C2Vmin,C2Umax,C2Vmax);
+    Standard_Real du, dv;
+    du = (C1Umax - C1Umin); dv = (C1Vmax - C1Vmin);
+    isULongC1 = (dv <= du); isVLongC1 = (du <= dv);
+    du = (C2Umax - C2Umin); dv = (C2Vmax - C2Vmin);
+    isULongC2 = (dv <= du); isVLongC2 = (du <= dv);
+    surf->Bounds(SUmin,SUmax,SVmin,SVmax);
+  }
+  if (isUClosed && isVLongC1 && isVLongC2) {
+    // Do not merge if not overlapped by V
+    Standard_Real dist = Max((C2Vmin - C1Vmax),(C1Vmin - C2Vmax));
+    if (dist < 0.0) {
+      Standard_Real distInner = Max((C2Umin - C1Umax),(C1Umin - C2Umax));
+      Standard_Real distOuter = (SUmax - SUmin) - Max((C2Umax - C1Umin),(C1Umax - C2Umin));
+      if (distOuter <= distInner) return Standard_True;
+    }
+  }
+  if (isVClosed && isULongC1 && isULongC2) {
+    // Do not merge if not overlapped by U
+    Standard_Real dist = Max((C2Umin - C1Umax),(C1Umin - C2Umax));
+    if (dist < 0.0) {
+      Standard_Real distInner = Max((C2Vmin - C1Vmax),(C1Vmin - C2Vmax));
+      Standard_Real distOuter = (SVmax - SVmin) - Max((C2Vmax - C1Vmin),(C1Vmax - C2Vmin));
+      if (distOuter <= distInner) return Standard_True;
+    }
+  }
+  return Standard_False;
+}
+
+//=======================================================================
+//function : AnalysisNearestEdges
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::AnalysisNearestEdges(const TopTools_SequenceOfShape& sequenceSec,
+                                           TColStd_SequenceOfInteger& seqIndCandidate,
+                                           TColStd_SequenceOfInteger& seqOrientations,
+                                           const Standard_Boolean evalDist)
+{
+  
+  Standard_Integer workIndex = seqIndCandidate.First();
+  TopoDS_Shape workedge = sequenceSec.Value(workIndex);
+  TopoDS_Shape bnd = workedge;
+  TopTools_ListOfShape workfaces;
+  if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
+  if (myBoundFaces.Contains(bnd)) 
+    workfaces = myBoundFaces.FindFromKey(bnd);
+  if(workfaces.IsEmpty()) return;
+  TopTools_MapOfShape mapFaces;
+  TopTools_ListIteratorOfListOfShape lIt;
+  for (lIt.Initialize(workfaces); lIt.More(); lIt.Next())
+    mapFaces.Add(lIt.Value());
+  TColStd_SequenceOfInteger seqNotCandidate;
+  TColStd_SequenceOfInteger seqNewForward;
+  // Separates edges belonging the same face as work edge 
+  // for exception of edges belonging closed faces 
+  
+  seqNotCandidate.Append(workIndex);
+  for(Standard_Integer i = 1; i<= seqIndCandidate.Length(); ) {
+    Standard_Integer index = seqIndCandidate.Value(i);
+    Standard_Boolean isRemove = Standard_False;
+    if(index == workIndex) {
+      seqIndCandidate.Remove(i);
+      seqOrientations.Remove(i);
+      isRemove = Standard_True;
+    }
+    if(!isRemove) {
+      TopoDS_Shape bnd2 = sequenceSec.Value(index);
+      if (mySectionBound.IsBound(bnd2)) bnd2 = mySectionBound(bnd2);
+    
+      if(myBoundFaces.Contains(bnd2)) {
+        const TopTools_ListOfShape& listfaces = myBoundFaces.FindFromKey(bnd2);
+        Standard_Boolean isMerged = Standard_True;
+        for (lIt.Initialize(listfaces); lIt.More() && isMerged; lIt.Next()) {
+          if(mapFaces.Contains(lIt.Value())) {
+            TopLoc_Location loc;
+            Handle(Geom_Surface) surf = BRep_Tool::Surface(TopoDS::Face(lIt.Value()),loc);
+            isMerged = ((IsUClosedSurface(surf,bnd2,loc) ||  IsVClosedSurface(surf,bnd2,loc)) && 
+                        IsMergedClosed(TopoDS::Edge(sequenceSec.Value(index)),TopoDS::Edge(workedge),TopoDS::Face(lIt.Value())));
+          }
+        }
+        if(!isMerged) {
+          seqNotCandidate.Append(index);
+          seqIndCandidate.Remove(i);
+          seqOrientations.Remove(i);
+          isRemove = Standard_True;
+        }
+      }
+      else {
+        seqIndCandidate.Remove(i);
+        seqOrientations.Remove(i);
+        isRemove = Standard_True;
+      }
+    }
+    if(!isRemove) i++;  
+  }
+  if(seqIndCandidate.Length() == 0 || seqNotCandidate.Length() == 1) return;
+  if(!evalDist) return;
+  TColStd_Array2OfReal TotTabDist(1,seqNotCandidate.Length(),1,seqIndCandidate.Length());
+  TColStd_MapOfInteger MapIndex;
+  TColStd_SequenceOfInteger seqForward;
+  
+  // Definition and removing edges wich are not candidate for work edge 
+  // ( they have other nearest edges belonging to the work face) 
+  for(Standard_Integer k = 1; k<= seqNotCandidate.Length(); k++) {
+    Standard_Integer index1 = seqNotCandidate.Value(k);
+    TopoDS_Shape edge = sequenceSec.Value(index1);
+    TopTools_SequenceOfShape tmpSeq;
+    tmpSeq.Append(edge);
+    for(Standard_Integer kk = 1; kk <= seqIndCandidate.Length();kk++) 
+      tmpSeq.Append(sequenceSec.Value(seqIndCandidate.Value(kk)));
+    
+    Standard_Integer lengSec = tmpSeq.Length();
+    TColStd_Array1OfBoolean tabForward(1,lengSec);
+    TColStd_Array1OfReal tabDist(1,lengSec);
+    for (Standard_Integer i1 = 1 ; i1 <= lengSec; i1++) 
+      tabDist(i1) =-1;
+    
+    EvaluateDistances(tmpSeq,tabForward, tabDist,1 );
+    if(k == 1) {
+      for(Standard_Integer n = 1; n < lengSec; n++) {
+	if(tabDist(n+1) == -1 || tabDist(n+1) > myTolerance) {
+	  MapIndex.Add(n);
+	  continue;
+	}
+	TotTabDist(k,n) = tabDist(n+1 );
+	seqForward.Append(tabForward(n+1) ? 1:0);
+      }
+    }
+    else {
+      for(Standard_Integer n = 1; n < lengSec; n++) {
+	if(tabDist(n) == -1 || tabDist(n) > myTolerance) continue;
+	if(tabDist(n+1) < TotTabDist(1,n)) {
+	  MapIndex.Add(n);
+	}
+      }
+    }
+     
+  }
+  for(TColStd_MapIteratorOfMapOfInteger IMap(MapIndex); IMap.More(); IMap.Next()) {
+    seqIndCandidate.Remove(IMap.Key());
+    seqOrientations.Remove(IMap.Key());
+  }
+}
+
+//=======================================================================
+//function : FindCandidates
+//purpose  : internal use
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::FindCandidates(TopTools_SequenceOfShape& seqSections,
+						 TColStd_IndexedMapOfInteger& mapReference,
+						 TColStd_SequenceOfInteger& seqCandidates,
+						 TColStd_SequenceOfInteger& seqOrientations)
+{
+  Standard_Integer i, nbSections = seqSections.Length();
+
+  // Retrieve last reference index
+  Standard_Integer indReference = mapReference(mapReference.Extent());
+  Standard_Integer nbCandidates = 0;
+
+  if (nbSections > 1) {
+
+    TopoDS_Edge Edge1 = TopoDS::Edge(seqSections(indReference));
+
+    // Retrieve faces for reference section
+    TopTools_MapOfShape Faces1;
+    { //szv: Use brackets to destroy local variables
+      TopoDS_Shape bnd = Edge1;
+      if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
+      if (myBoundFaces.Contains(bnd)) {
+	TopTools_ListIteratorOfListOfShape itf1(myBoundFaces.FindFromKey(bnd));
+	for (; itf1.More(); itf1.Next()) Faces1.Add(itf1.Value());
+      }
+    }
+
+    // Check merging conditions for candidates and remove unsatisfactory
+    TopTools_SequenceOfShape seqSectionsNew;
+    TColStd_SequenceOfInteger seqCandidatesNew;
+    for (i = 1; i <= nbSections; i++) {
+      if (i == indReference) {
+	seqSectionsNew.Prepend(Edge1);
+	seqCandidatesNew.Prepend(i);
+      }
+      else {
+	const TopoDS_Edge& Edge2 = TopoDS::Edge(seqSections(i));
+	TopoDS_Shape bnd = Edge2;
+	if (mySectionBound.IsBound(bnd)) bnd = mySectionBound(bnd);
+	if (myBoundFaces.Contains(bnd)) {
+	  Standard_Boolean isOK = Standard_True;
+	  TopTools_ListIteratorOfListOfShape itf2(myBoundFaces.FindFromKey(bnd));
+	  for (; itf2.More() && isOK; itf2.Next()) {
+	    const TopoDS_Face& Face2 = TopoDS::Face(itf2.Value());
+	    // Check whether condition is satisfied
+	    isOK = !Faces1.Contains(Face2);
+	    if (!isOK) isOK = IsMergedClosed(Edge1,Edge2,Face2);
+	  }
+	  if (isOK) {
+	    seqSectionsNew.Append(Edge2);
+	    seqCandidatesNew.Append(i);
+	  }
+	}
+      }
+    }
+
+    Standard_Integer nbSectionsNew = seqSectionsNew.Length();
+    if (nbSectionsNew > 1) {
+
+      // Evaluate distances between reference and other sections
+      TColStd_Array1OfBoolean arrForward(1,nbSectionsNew);
+      TColStd_Array1OfReal arrDistance(1,nbSectionsNew);
+      EvaluateDistances(seqSectionsNew,arrForward,arrDistance,1);
+
+      // Fill sequence of candidate indices sorted by distance
+      for (i = 2; i <= nbSectionsNew; i++) {
+	if (arrDistance(i) >= 0.0) {
+	  // Reference section is connected to section #i
+	  Standard_Boolean isInserted = Standard_False;
+	  Standard_Integer j, ori = (arrForward(i)? 1 : 0);
+	  for (j = 1; (j <= seqCandidates.Length()) && !isInserted; j++) {
+	    if (arrDistance(i) <= arrDistance(seqCandidates.Value(j))) {
+	      seqCandidates.InsertBefore(j,i);
+	      seqOrientations.InsertBefore(j,ori);
+	      isInserted = Standard_True;
+	    }
+	  }
+	  if (!isInserted) {
+	    seqCandidates.Append(i);
+	    seqOrientations.Append(ori);
+	  }
+	}
+      }
+
+      // Replace candidate indices
+      nbCandidates = seqCandidates.Length();
+      for (i = 1; i <= nbCandidates; i++)
+	seqCandidates(i) = seqCandidatesNew(seqCandidates(i));
+    }
+  }
+
+  if (!nbCandidates) return Standard_False; // Section has no candidates to merge
+
+  if (myNonmanifold && nbCandidates >1) {
+    TColStd_SequenceOfInteger seqNewCandidates;
+    TColStd_SequenceOfInteger seqOrientationsNew;
+    seqCandidates.Prepend(1);
+    seqOrientations.Prepend(1);
+    for(Standard_Integer k = 1; k <= seqSections.Length() && seqCandidates.Length() > 1 ; k++) {
+      AnalysisNearestEdges(seqSections,seqCandidates,seqOrientations,(k==1));
+      if(k == 1 && !seqCandidates.Length()) return Standard_False;
+      if(seqCandidates.Length()) {
+        seqNewCandidates.Append(seqCandidates.First());
+        seqOrientationsNew.Append(seqOrientations.First()); 
+      }
+    }
+    seqCandidates.Prepend(seqNewCandidates);
+    seqOrientations.Prepend(seqOrientationsNew);
+    return Standard_True;
+  }
+  else {
+
+    // For manifold case leave only one candidate from equidistant candidates
+    /*Standard_Integer minIndex = seqCandidateIndex.First();
+    Standard_Real minDistance = arrDistance(minIndex);
+
+    // Find equidistant candidates
+    TColStd_SequenceOfInteger seqEqDistantIndex; seqEqDistantIndex.Append(1);
+    for (i = 2; i <= nbCandidates; i++) {
+      Standard_Integer index = seqCandidateIndex(i);
+      if (Abs(minDistance - arrDistance(index)) <= Precision::Confusion())
+	seqEqDistantIndex.Append(index);
+    }
+
+    Standard_Integer eqLen = seqEqDistantIndex.Length();
+    if (eqLen > 2) {
+
+      // Fill map of faces which equidistant sections belong to
+      TopTools_MapOfShape mapFace;
+      for (i = 1; i <= eqLen; i++) {
+	Standard_Integer index = seqEqDistantIndex.Value(i);
+	if (isCandidate(index)) {
+	  mapFace.Add(arrFace(index));
+	}
+      }
+
+      // Non Manifold case
+      // Edges are merged by pair among a face continuity C1 criterion
+      if (mapFace.Extent() == eqLen) {
+
+	tabDist.Init(-1);
+	tabMinInd.Init(-1);
+	min=10000000.;
+	//indMin = -1;
+	Standard_Integer indMin = -1;// To check if the edge can be merged.
+	// Computation of distances between the edges.
+	TopTools_SequenceOfShape seqSh;
+	Standard_Integer nbInd = EqDistSeq.Length();
+	TColStd_Array1OfBoolean tmptabForward(1,nbInd);
+	seqSh.Append(sequenceSec.Value(1));
+	for (j = 2; j <= EqDistSeq.Length(); j++) {
+	  Standard_Integer index = EqDistSeq.Value(j);
+	  tmptabForward(j) = tabForward(index);
+	  seqSh.Append(sequenceSec.Value(index));
+	}
+
+	EvaluateAngulars(seqSh, tmptabForward, tabDist,1);
+
+	for(j=2; j <= seqSh.Length(); j++) {
+	  if (tabDist(j) > -1.) {  // if edge(j) is connected to edge(i)
+	    if (min > tabDist(j)) {
+	      min = tabDist(j);
+	      indMin = j;
+	    }
+	  }
+	}
+
+	//  Construct minDist, tabMinInd , tabMinForward(i) = tabForward(j);
+	if (indMin > 0) {
+	  seqSh.Remove(indMin);
+	  for(j =2; j <= tmpSeq.Length(); ) {
+	    TopoDS_Shape sh = tmpSeq.Value(j);
+	    Standard_Boolean isRem = Standard_False;
+	    for(Standard_Integer k = 1; k<= seqSh.Length();k++) {
+	      if(seqSh.Value(k) == sh) {
+		isRem = Standard_True;
+		break;
+	      }
+	    }
+	    if(isRem) {
+	      tmpSeq.Remove(j);
+	      tabMinForward.Remove(j); // = -1;
+	    } 
+	    else j++;
+	  }
+	}
+      }
+    }*/
+
+    // Find the best approved candidate
+    while (nbCandidates) {
+      // Retrieve first candidate
+      Standard_Integer indCandidate = seqCandidates.First();
+      // Candidate is approved if it is in the map
+      if (mapReference.Contains(indCandidate)) break;
+      // Find candidates for candidate #indCandidate
+      mapReference.Add(indCandidate); // Push candidate in the map
+      TColStd_SequenceOfInteger seqCandidates1, seqOrientations1;
+      Standard_Boolean isFound =
+	FindCandidates(seqSections,mapReference,seqCandidates1,seqOrientations1);
+      mapReference.RemoveLast(); // Pop candidate from the map
+      if (isFound) isFound = (seqCandidates1.Length() > 0);
+      if (isFound) {
+	Standard_Integer indCandidate1 = seqCandidates1.First();
+	// If indReference is the best candidate for indCandidate
+	// then indCandidate is the best candidate for indReference
+	if (indCandidate1 == indReference) break;
+	// If some other reference in the map is the best candidate for indCandidate
+	// then assume that reference is the best candidate for indReference
+	if (mapReference.Contains(indCandidate1)) {
+	  seqCandidates.Prepend(indCandidate1);
+	  nbCandidates++;
+	  break;
+	}
+	isFound = Standard_False;
+      }
+      if (!isFound) {
+	// Remove candidate #1
+	seqCandidates.Remove(1);
+	seqOrientations.Remove(1);
+	nbCandidates--;
+      }
+    }
+  }
+
+  return (nbCandidates > 0);
+}
+
+//=======================================================================
+//function : Constructor
+//purpose  : 
+//=======================================================================
+
+BRepBuilderAPI_Sewing::BRepBuilderAPI_Sewing(const Standard_Real tolerance,
+				 const Standard_Boolean optionSewing,
+				 const Standard_Boolean optionAnalysis,
+				 const Standard_Boolean optionCutting,
+				 const Standard_Boolean optionNonmanifold)
+{
+  myReShape = new BRepTools_ReShape;
+  Init(tolerance, optionSewing, optionAnalysis, optionCutting, optionNonmanifold);
+}
+
+//=======================================================================
+//function : Init
+//purpose  : Initialise Talerance, and options sewing, faceAnalysis and cutting
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Init(const Standard_Real tolerance,
+			   const Standard_Boolean optionSewing,
+			   const Standard_Boolean optionAnalysis,
+			   const Standard_Boolean optionCutting,
+			   const Standard_Boolean optionNonmanifold)
+{
+  // Set tolerance and Perform options
+  myTolerance      = tolerance;
+  mySewing         = optionSewing;
+  myAnalysis       = optionAnalysis;
+  myCutting        = optionCutting;
+  myNonmanifold    = optionNonmanifold;
+  // Set min and max tolerances
+  myMinTolerance   = tolerance*1e-4; //szv: proposal
+  if (myMinTolerance < Precision::Confusion()) myMinTolerance = Precision::Confusion();
+  myMaxTolerance   = Precision::Infinite();
+  // Set other modes
+  myFaceMode           = Standard_True;
+  myFloatingEdgesMode  = Standard_False;
+  //myCuttingFloatingEdgesMode = Standard_False; //gka
+  mySameParameterMode  = Standard_True;
+  myLocalToleranceMode = Standard_False;
+  mySewedShape.Nullify();
+  // Load empty shape
+  Load(TopoDS_Shape());
+}
+
+//=======================================================================
+//function : Load
+//purpose  : Loads the context shape
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Load(const TopoDS_Shape& theShape)
+{
+  myReShape->Clear();
+  if (theShape.IsNull()) myShape.Nullify();
+  else myShape = myReShape->Apply(theShape);
+  mySewedShape.Nullify();
+  // Nullify flags and counters
+  myNbShapes = myNbEdges = myNbVertices = 0;
+  // Clear all maps
+  myOldShapes.Clear();
+  //myOldFaces.Clear();
+  myDegenerated.Clear();
+  myFreeEdges.Clear();
+  myMultipleEdges.Clear();
+  myContigousEdges.Clear();
+  myContigSecBound.Clear();
+  myBoundFaces.Clear();
+  myBoundSections.Clear();
+  myVertexNode.Clear();
+  myVertexNodeFree.Clear();
+  myNodeSections.Clear();
+  myCuttingNode.Clear();
+  mySectionBound.Clear();
+  myLittleFace.Clear();
+}
+
+//=======================================================================
+//function : Add
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Add(const TopoDS_Shape& aShape)
+{
+  if (aShape.IsNull()) return;
+  TopoDS_Shape oShape = myReShape->Apply(aShape);
+  myOldShapes.Add(aShape,oShape);
+  myNbShapes = myOldShapes.Extent();
+}
+
+//=======================================================================
+//function : Perform
+//purpose  : 
+//=======================================================================
+
+#ifdef DEB
+#include <OSD_Timer.hxx>
+#endif
+
+void BRepBuilderAPI_Sewing::Perform()
+{
+#ifdef DEB
+  Standard_Real t_total = 0., t_analysis = 0., t_assembling = 0., t_cutting = 0., t_merging = 0.;
+  OSD_Chronometer chr_total, chr_local;
+  chr_total.Reset();
+  chr_total.Start();
+#endif
+
+  // face analysis
+  if (myAnalysis) {
+#if DEB
+    cout << "Begin face analysis..." << endl;
+    chr_local.Reset();
+    chr_local.Start();
+#endif
+    FaceAnalysis();
+#if DEB
+    chr_local.Stop();
+    chr_local.Show(t_analysis);
+    cout << "Face analysis finished after " << t_analysis << " s" << endl;
+#endif
+  }
+
+  if (myNbShapes || !myShape.IsNull()) {
+
+    FindFreeBoundaries();
+
+    if (myBoundFaces.Extent()) {
+
+#if DEB
+      cout << "Begin vertices assembling..." << endl;
+      chr_local.Reset();
+      chr_local.Start();
+#endif
+      VerticesAssembling();
+#if DEB
+      chr_local.Stop();
+      chr_local.Show(t_assembling);
+      cout << "Vertices assembling finished after " << t_assembling << " s" << endl;
+#endif
+      if (myCutting) {
+#if DEB
+	cout << "Begin cutting..." << endl;
+	chr_local.Reset();
+	chr_local.Start();
+#endif
+	Cutting();
+#if DEB
+	chr_local.Stop();
+	chr_local.Show(t_cutting);
+	cout << "Cutting finished after " << t_cutting << " s" << endl;
+#endif
+      }
+#if DEB
+      cout << "Begin merging..." << endl;
+      chr_local.Reset();
+      chr_local.Start();
+#endif
+      Merging(Standard_True);
+#if DEB
+      chr_local.Stop();
+      chr_local.Show(t_merging);
+      cout << "Merging finished after " << t_merging << " s" << endl;
+#endif
+    }
+
+    if (mySewing) {
+
+#if DEB
+      cout << "Creating sewed shape..." << endl;
+#endif
+      // examine the multiple edges if any and process sameparameter for edges if necessary
+      EdgeProcessing();
+      CreateSewedShape();
+      if (mySameParameterMode && myFaceMode) SameParameterShape();
+#if DEB
+      cout << "Sewed shape created" << endl;
+#endif
+    }
+    
+    // create edge informations for output
+    CreateOutputInformations();
+  }
+#if DEB
+  chr_total.Stop();
+  chr_total.Show(t_total);
+  cout << "Sewing finished!" << endl;
+  cout << " analysis time   : " << t_analysis << " s" << endl;
+  cout << " assembling time : " << t_assembling << " s" << endl;
+  cout << " cutting time    : " << t_cutting << " s" << endl;
+  cout << " merging time    : " << t_merging << " s" << endl;
+  cout << "Total time       : " << t_total << " s" << endl;
+#endif
+}
+
+//=======================================================================
+//function : SewedShape
+//purpose  : give the sewed shape
+//           if a null shape, reasons:
+//             -- no useable input shapes : all input shapes are degenerated
+//             -- has multiple edges
+//=======================================================================
+
+const TopoDS_Shape& BRepBuilderAPI_Sewing::SewedShape() const
+{
+  return mySewedShape;
+}
+
+//=======================================================================
+//function : NbFreeEdges
+//purpose  : 
+//=======================================================================
+
+Standard_Integer BRepBuilderAPI_Sewing::NbFreeEdges() const
+{
+  return myFreeEdges.Extent();
+}
+
+//=======================================================================
+//function : FreeEdge
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Edge& BRepBuilderAPI_Sewing::FreeEdge(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbFreeEdges(), "BRepBuilderAPI_Sewing::FreeEdge");
+  return TopoDS::Edge(myFreeEdges(index));
+}
+
+//=======================================================================
+//function : NbMultipleEdges
+//purpose  : 
+//=======================================================================
+
+Standard_Integer BRepBuilderAPI_Sewing::NbMultipleEdges() const
+{
+  return myMultipleEdges.Extent();
+}
+
+//=======================================================================
+//function : MultipleEdge
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Edge& BRepBuilderAPI_Sewing::MultipleEdge(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbMultipleEdges(), "BRepBuilderAPI_Sewing::MultipleEdge");
+  return TopoDS::Edge(myMultipleEdges(index));
+}
+
+//=======================================================================
+//function : NbContigousEdges
+//purpose  : 
+//=======================================================================
+
+Standard_Integer BRepBuilderAPI_Sewing::NbContigousEdges() const
+{
+  return myContigousEdges.Extent();
+}
+
+//=======================================================================
+//function : ContigousEdge
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Edge& BRepBuilderAPI_Sewing::ContigousEdge(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbContigousEdges(), "BRepBuilderAPI_Sewing::ContigousEdge");
+  return TopoDS::Edge(myContigousEdges.FindKey(index));
+}
+
+//=======================================================================
+//function : ContigousEdgeCouple
+//purpose  : 
+//=======================================================================
+
+const TopTools_ListOfShape& BRepBuilderAPI_Sewing::ContigousEdgeCouple(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbContigousEdges(), "BRepBuilderAPI_Sewing::ContigousEdgeCouple");
+  return myContigousEdges(index);
+}
+
+//=======================================================================
+//function : IsSectionBound
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsSectionBound(const TopoDS_Edge& section) const
+{
+  if(myContigSecBound.IsBound(section)) {
+    return Standard_True;
+  }
+  else {
+    return Standard_False;
+  }
+}
+
+//=======================================================================
+//function : SectionToBoundary
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Edge& BRepBuilderAPI_Sewing::SectionToBoundary(const TopoDS_Edge& section) const
+{
+  Standard_NoSuchObject_Raise_if(!IsSectionBound(section), "BRepBuilderAPI_Sewing::SectionToBoundary");
+  return TopoDS::Edge(myContigSecBound(section));
+}
+//=======================================================================
+//function : NbDeletedFaces
+//purpose  : 
+//=======================================================================
+ Standard_Integer BRepBuilderAPI_Sewing::NbDeletedFaces() const
+{
+  return myLittleFace.Extent();
+}
+
+//=======================================================================
+//function : DeletedFace
+//purpose  : 
+//=======================================================================
+const TopoDS_Face& BRepBuilderAPI_Sewing::DeletedFace(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbDeletedFaces(), "BRepBuilderAPI_Sewing::DeletedFace");
+  return TopoDS::Face(myLittleFace(index));
+}
+
+//=======================================================================
+//function : NbDegeneratedShapes
+//purpose  : 
+//=======================================================================
+
+Standard_Integer BRepBuilderAPI_Sewing::NbDegeneratedShapes() const
+{
+  return myDegenerated.Extent();
+}
+
+//=======================================================================
+//function : DegeneratedShape
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Shape& BRepBuilderAPI_Sewing::DegeneratedShape(const Standard_Integer index) const
+{
+  Standard_OutOfRange_Raise_if(index < 0 || index > NbDegeneratedShapes(), "BRepBuilderAPI_Sewing::DegereratedShape");
+  return myDegenerated(index);
+}
+
+//=======================================================================
+//function : IsDegenerated
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsDegenerated(const TopoDS_Shape& aShape) const
+{
+  TopoDS_Shape NewShape = myReShape->Apply(aShape);
+  // Degenerated face
+  if (aShape.ShapeType() == TopAbs_FACE)
+    return NewShape.IsNull();
+  if (NewShape.IsNull()) return Standard_False;
+  // Degenerated edge
+  if (NewShape.ShapeType() == TopAbs_EDGE)
+    return BRep_Tool::Degenerated(TopoDS::Edge(NewShape));
+  // Degenerated wire
+  if (NewShape.ShapeType() == TopAbs_WIRE) {
+    Standard_Boolean isDegenerated = Standard_True;
+    for (TopoDS_Iterator aIt(NewShape); aIt.More() && isDegenerated; aIt.Next())
+      isDegenerated = BRep_Tool::Degenerated(TopoDS::Edge(aIt.Value()));
+    return isDegenerated;
+  }
+  return Standard_False;
+}
+  
+//=======================================================================
+//function : IsModified
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsModified(const TopoDS_Shape& aShape) const
+{
+  TopoDS_Shape NewShape = aShape;
+  if (myOldShapes.Contains(aShape)) 
+    NewShape = myOldShapes.FindFromKey(aShape);
+  if(!NewShape.IsSame(aShape)) return Standard_True;
+  return Standard_False;
+}
+
+//=======================================================================
+//function : Modified
+//purpose  : 
+//=======================================================================
+
+const TopoDS_Shape& BRepBuilderAPI_Sewing::Modified(const TopoDS_Shape& aShape) const
+{ 
+  if (myOldShapes.Contains(aShape)) return myOldShapes.FindFromKey(aShape);
+  //if (myOldFaces.Contains(aShape)) return myOldFaces.FindFromKey(aShape);
+  return aShape;
+}
+
+//=======================================================================
+//function : IsModifiedSubShape
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::IsModifiedSubShape(const TopoDS_Shape& aShape) const
+{
+  TopoDS_Shape NewShape = myReShape->Apply(aShape);
+  if(!NewShape.IsSame(aShape)) return Standard_True;
+  return Standard_False;
+}
+
+//=======================================================================
+//function : ModifiedSubShape
+//purpose  : 
+//=======================================================================
+
+TopoDS_Shape BRepBuilderAPI_Sewing::ModifiedSubShape(const TopoDS_Shape& aShape) const
+{ 
+  return myReShape->Apply(aShape);
+}
+
+//=======================================================================
+//function : Dump
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Dump() const
+{
+  Standard_Integer i, NbBounds = myBoundFaces.Extent(), NbSections = 0;
+  TopTools_MapOfShape mapVertices, mapEdges;
+  for (i = 1; i <= NbBounds; i++) {
+    TopoDS_Shape bound = myBoundFaces.FindKey(i);
+    if (myBoundSections.IsBound(bound)) NbSections += myBoundSections(bound).Extent();
+    else NbSections++;
+    TopExp_Explorer aExp(myReShape->Apply(bound),TopAbs_EDGE);
+    for (; aExp.More(); aExp.Next()) {
+      TopoDS_Edge E = TopoDS::Edge(aExp.Current());
+      mapEdges.Add(E);
+      TopoDS_Vertex V1, V2;
+      TopExp::Vertices(E,V1,V2);
+      mapVertices.Add(V1);
+      mapVertices.Add(V2);
+    }
+  }
+  cout << " " << endl;
+  cout << "                        Informations                        " << endl;
+  cout << " ===========================================================" << endl;
+  cout << " " << endl;
+  cout << " Number of input shapes      : " << myOldShapes.Extent() << endl;
+  cout << " Number of actual shapes     : " << myNbShapes << endl;
+  cout << " Number of Bounds            : " << NbBounds << endl;
+  cout << " Number of Sections          : " << NbSections << endl;
+  cout << " Number of Edges             : " << mapEdges.Extent() << endl;
+  cout << " Number of Vertices          : " << myNbVertices << endl;
+  cout << " Number of Nodes             : " << mapVertices.Extent() << endl;
+  cout << " Number of Free Edges        : " << myFreeEdges.Extent() << endl;
+  cout << " Number of Contigous Edges   : " << myContigousEdges.Extent() << endl;
+  cout << " Number of Multiple Edges    : " << myMultipleEdges.Extent() << endl;
+  cout << " Number of Degenerated Edges : " << myDegenerated.Extent() << endl;
+  cout << " ===========================================================" << endl;
+  cout << " " << endl;
+}
+
+//=======================================================================
+//function : FaceAnalysis
+//purpose  : Remove
+//	     Modifies:
+//                      myNbShapes
+//                      myOldShapes
+//
+//           Constructs:
+//                      myDegenerated
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::FaceAnalysis()
+{
+  if (!myShape.IsNull() && myOldShapes.IsEmpty()) {
+    Add(myShape);
+    myShape.Nullify();
+  }
+
+  BRep_Builder B;
+  TopTools_MapOfShape SmallEdges;
+  TopTools_DataMapOfShapeListOfShape GluedVertices;
+  Standard_Integer i = 1;
+  for (i = 1; i <= myOldShapes.Extent(); i++) {
+    for (TopExp_Explorer fexp(myOldShapes(i),TopAbs_FACE); fexp.More(); fexp.Next()) {
+
+      // Retrieve current face
+      TopoDS_Shape aTmpShape = fexp.Current(); //for porting
+      TopoDS_Face face = TopoDS::Face(aTmpShape);
+      Standard_Integer nbEdges = 0, nbSmall = 0;
+
+      // Build replacing face
+      aTmpShape = face.EmptyCopied().Oriented(TopAbs_FORWARD); //for porting
+      TopoDS_Face nface = TopoDS::Face(aTmpShape);
+      Standard_Boolean isFaceChanged = Standard_False;
+
+      TopoDS_Iterator witer(face.Oriented(TopAbs_FORWARD));
+      for (; witer.More(); witer.Next()) {
+
+	// Retrieve current wire
+        aTmpShape = witer.Value(); //for porting
+        if( aTmpShape.ShapeType() != TopAbs_WIRE) continue;
+	TopoDS_Wire wire = TopoDS::Wire(aTmpShape);
+
+	// Build replacing wire
+        aTmpShape = wire.EmptyCopied().Oriented(TopAbs_FORWARD);
+	TopoDS_Wire nwire = TopoDS::Wire(aTmpShape);
+	Standard_Boolean isWireChanged = Standard_False;
+
+	TopoDS_Iterator eiter(wire.Oriented(TopAbs_FORWARD));
+	for (; eiter.More(); eiter.Next()) {
+
+	  // Retrieve current edge
+          aTmpShape = eiter.Value(); //for porting
+	  TopoDS_Edge edge = TopoDS::Edge(aTmpShape);
+	  nbEdges++;
+
+	  // Process degenerated edge
+	  if (BRep_Tool::Degenerated(edge)) {
+	    B.Add(nwire,edge); // Old edge kept
+	    myDegenerated.Add(edge);
+	    nbSmall++;
+	    continue;
+	  }
+
+	  Standard_Boolean isSmall = SmallEdges.Contains(edge);
+	  if (!isSmall) {
+
+	    // Check for small edge
+	    Standard_Real first, last;
+	    Handle(Geom_Curve) c3d = BRep_Tool::Curve(edge,first,last);
+	    if (c3d.IsNull()) {
+#ifdef DEB
+	      cout << "Warning: Possibly small edge can be sewed: No 3D curve" << endl;
+#endif
+	    }
+	    else {
+	      // Evaluate curve compactness
+	      const Standard_Integer npt = 5;
+	      gp_Pnt cp((c3d->Value(first).XYZ()+c3d->Value(last).XYZ())*0.5);
+	      Standard_Real dist, maxdist = 0.0;
+	      Standard_Real delta = (last - first)/(npt - 1);
+	      for (Standard_Integer idx = 0; idx < npt; idx++) {
+		dist = cp.Distance(c3d->Value(first + idx*delta));
+		if (maxdist < dist) maxdist = dist;
+	      }
+	      isSmall = (2.*maxdist <= MinTolerance());
+	      /*try {
+		GeomAdaptor_Curve cAdapt(c3d);
+		Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt,first,last);
+		isSmall = (length <= MinTolerance());
+	      }
+	      catch (Standard_Failure) {
+#ifdef DEB
+		cout << "Warning: Possibly small edge can be sewed: ";
+		Standard_Failure::Caught()->Print(cout); cout << endl;
+#endif
+	      }*/
+	    }
+
+	    if (isSmall) {
+
+	      // Store small edge in the map
+	      SmallEdges.Add(edge);
+
+	      TopoDS_Vertex v1, v2;
+	      TopExp::Vertices(edge,v1,v2);
+	      TopoDS_Shape nv1 = myReShape->Apply(v1), nv2 = myReShape->Apply(v2);
+
+	      // Store glued vertices
+	      if (!nv1.IsSame(v1)) {
+		TopTools_ListOfShape& vlist1 = GluedVertices(nv1);
+		// First vertex was already glued
+		if (!nv2.IsSame(v2)) {
+		  // Merge lists of glued vertices
+		  if (!nv1.IsSame(nv2)) {
+		    TopTools_ListIteratorOfListOfShape liter(GluedVertices(nv2));
+		    for (; liter.More(); liter.Next()) {
+		      TopoDS_Shape v = liter.Value();
+		      myReShape->Replace(v,nv1.Oriented(v.Orientation()));
+		      vlist1.Append(v);
+		    }
+		    GluedVertices.UnBind(nv2);
+		  }
+		}
+		else {
+		  // Add second vertex to the existing list
+		  vlist1.Append(v2);
+		  myReShape->Replace(v2,nv1.Oriented(v2.Orientation()));
+		}
+	      }
+	      else if (!nv2.IsSame(v2)) {
+		// Add first vertex to the existing list
+		GluedVertices(nv2).Append(v1);
+		myReShape->Replace(v1,nv2.Oriented(v1.Orientation()));
+	      }
+	      else if (!v1.IsSame(v2)) {
+		// Record new glued vertices
+		TopoDS_Vertex nv;
+		B.MakeVertex(nv);
+		TopTools_ListOfShape vlist;
+		vlist.Append(v1);
+		vlist.Append(v2);
+		GluedVertices.Bind(nv,vlist);
+		myReShape->Replace(v1,nv.Oriented(v1.Orientation()));
+		myReShape->Replace(v2,nv.Oriented(v2.Orientation()));
+	      }
+	    }
+	  }
+
+	  // Replace small edge
+	  if (isSmall) {
+#ifdef DEB
+	    cout << "Warning: Small edge made degenerated by FaceAnalysis" << endl;
+#endif
+	    nbSmall++;
+	    // Create new degenerated edge
+            aTmpShape = edge.Oriented(TopAbs_FORWARD);
+	    TopoDS_Edge fedge = TopoDS::Edge(aTmpShape);
+	    Standard_Real pfirst, plast;
+	    Handle(Geom2d_Curve) c2d = BRep_Tool::CurveOnSurface(fedge,face,pfirst,plast);
+	    if (!c2d.IsNull()) {
+	      TopoDS_Edge nedge;
+	      B.MakeEdge(nedge);
+	      B.UpdateEdge(nedge,c2d,face,Precision::Confusion());
+	      B.Range(nedge,pfirst,plast);
+	      B.Degenerated(nedge,Standard_True);
+	      TopoDS_Vertex v1, v2;
+	      TopExp::Vertices(fedge,v1,v2);
+	      B.Add(nedge,myReShape->Apply(v1).Oriented(v1.Orientation()));
+	      B.Add(nedge,myReShape->Apply(v2).Oriented(v2.Orientation()));
+	      B.Add(nwire,nedge.Oriented(edge.Orientation()));
+	      myDegenerated.Add(nedge);
+	    }
+	    isWireChanged = Standard_True;
+	  }
+	  else B.Add(nwire,edge); // Old edge kept
+	}
+
+	// Record wire in the new face
+	if (isWireChanged) {
+	  B.Add(nface,nwire.Oriented(wire.Orientation()));
+	  isFaceChanged = Standard_True;
+	}
+	else B.Add(nface,wire);
+      }
+
+      // Remove small face
+      if (nbSmall == nbEdges) {
+#ifdef DEB
+	cout << "Warning: Small face removed by FaceAnalysis" << endl;
+#endif
+	myLittleFace.Add(face);
+	myReShape->Remove(face);
+      }
+      else if (isFaceChanged) {
+
+	myReShape->Replace(face,nface.Oriented(face.Orientation()));
+      }
+    }
+  }
+
+  // Update glued vertices
+  TopTools_DataMapIteratorOfDataMapOfShapeListOfShape miter(GluedVertices);
+  for (; miter.More(); miter.Next()) {
+    TopoDS_Vertex vnew = TopoDS::Vertex(miter.Key());
+    gp_XYZ coord(0.,0.,0.);
+    Standard_Integer nbPoints = 0;
+    const TopTools_ListOfShape& vlist = miter.Value();
+    TopTools_ListIteratorOfListOfShape liter1(vlist);
+    for (; liter1.More(); liter1.Next()) {
+      coord += BRep_Tool::Pnt(TopoDS::Vertex(liter1.Value())).XYZ();
+      nbPoints++;
+    }
+    if (nbPoints) {
+      gp_Pnt vp(coord / nbPoints);
+      Standard_Real tol = 0.0, mtol = 0.0;
+      TopTools_ListIteratorOfListOfShape liter2(vlist);
+      for (; liter2.More(); liter2.Next()) {
+	Standard_Real vtol = BRep_Tool::Tolerance(TopoDS::Vertex(liter2.Value()));
+	if (mtol < vtol) mtol = vtol;
+	vtol = vp.Distance(BRep_Tool::Pnt(TopoDS::Vertex(liter2.Value())));
+	if (tol < vtol) tol = vtol;
+      }
+      B.UpdateVertex(vnew,vp,tol+mtol);
+    }
+  }
+
+  // Update input shapes
+  for (i = 1; i <= myOldShapes.Extent(); i++)
+    myOldShapes(i) = myReShape->Apply(myOldShapes(i));
+}
+
+//=======================================================================
+//function : FindFreeBoundaries
+//purpose  : Constructs :
+//                      myBoundFaces     (bound = list of faces) - REFERENCE
+//                      myVertexNode     (vertex = node)
+//                      myVertexNodeFree (floating vertex = node)
+//
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::FindFreeBoundaries()
+{
+  // Take into account the context shape if needed
+  TopTools_IndexedMapOfShape NewShapes;
+  if (!myShape.IsNull()) {
+    if (myOldShapes.IsEmpty()) {
+      Add(myShape);
+      myShape.Nullify();
+    }
+    else {
+      TopoDS_Shape newShape = myReShape->Apply(myShape);
+      if (!newShape.IsNull()) NewShapes.Add(newShape);
+    }
+  }
+  // Create map Edge -> Faces
+  TopTools_IndexedDataMapOfShapeListOfShape EdgeFaces;
+  Standard_Integer i, nbShapes = myOldShapes.Extent();
+  for (i = 1; i <= nbShapes; i++) {
+    // Retrieve new shape
+    TopoDS_Shape shape = myOldShapes(i);
+    if (shape.IsNull()) continue;
+    NewShapes.Add(shape);
+    // Explore shape to find all boundaries
+    for (TopExp_Explorer eExp(shape,TopAbs_EDGE); eExp.More(); eExp.Next()) {
+      TopoDS_Shape edge = eExp.Current();
+      if (!EdgeFaces.Contains(edge)) {
+	TopTools_ListOfShape listFaces;
+	EdgeFaces.Add(edge,listFaces);
+      }
+    }
+  }
+  // Fill map Edge -> Faces
+  nbShapes = NewShapes.Extent();
+   TopTools_MapOfShape mapFaces;
+  for (i = 1; i <= nbShapes; i++) {
+    // Explore shape to find all faces
+    TopExp_Explorer fExp(NewShapes.FindKey(i),TopAbs_FACE);
+    for (; fExp.More(); fExp.Next()) {
+      TopoDS_Shape face = fExp.Current();
+      if(mapFaces.Contains(face)) continue;
+      else 
+        mapFaces.Add(face);
+      // Explore face to find all boundaries
+      for (TopoDS_Iterator aIw(face); aIw.More(); aIw.Next()) {
+        if(aIw.Value().ShapeType() != TopAbs_WIRE) continue;
+        for (TopoDS_Iterator aIIe(aIw.Value()); aIIe.More(); aIIe.Next()) {
+          
+          TopoDS_Shape edge = aIIe.Value();
+          
+          if (EdgeFaces.Contains(edge)) {
+            EdgeFaces.ChangeFromKey(edge).Append(face);
+            //TopTools_ListOfShape& listFaces = EdgeFaces.ChangeFromKey(edge);
+            //Standard_Boolean isContained = Standard_False;
+            //TopTools_ListIteratorOfListOfShape itf(listFaces);
+            //for (; itf.More() && !isContained; itf.Next())
+            //  isContained = face.IsSame(itf.Value());
+            //if (!isContained) listFaces.Append(face);
+          }
+        }
+      }
+    }
+  }
+  // Find free boundaries
+  nbShapes = EdgeFaces.Extent();
+  for (i = 1; i <= nbShapes; i++) {
+    TopTools_ListOfShape& listFaces = EdgeFaces(i);
+    Standard_Integer nbFaces = listFaces.Extent();
+    TopoDS_Shape edge = EdgeFaces.FindKey(i);
+    if(edge.Orientation() == TopAbs_INTERNAL)
+          continue;
+    Standard_Boolean isSeam = Standard_False;
+    if (nbFaces == 1) {
+      TopoDS_Face face = TopoDS::Face(listFaces.First());
+      isSeam = BRep_Tool::IsClosed(TopoDS::Edge(edge),face);
+      if (isSeam) {
+	///Handle(Geom_Surface) surf = BRep_Tool::Surface(face);
+	//isSeam = (IsUClosedSurface(surf) || IsVClosedSurface(surf));
+        //if(!isSeam) {
+          Standard_Real first,last;
+          Handle(Geom2d_Curve) c2dold = BRep_Tool::CurveOnSurface(TopoDS::Edge(edge),TopoDS::Face(listFaces.First()),first,last);
+          Handle(Geom2d_Curve) c2d;
+          BRep_Builder B;
+          B.UpdateEdge(TopoDS::Edge(edge),c2d,c2d,TopoDS::Face(listFaces.First()),0);
+          B.UpdateEdge(TopoDS::Edge(edge),c2dold,TopoDS::Face(listFaces.First()),0);
+        //}
+           isSeam = Standard_False;
+      }
+    }
+    Standard_Boolean isBoundFloat = (myFloatingEdgesMode && !nbFaces);
+    Standard_Boolean isBound = (myFaceMode && ((myNonmanifold && nbFaces) || (nbFaces == 1 && !isSeam)));
+    if (isBound || isBoundFloat) {
+      // Ignore degenerated edge
+      if (BRep_Tool::Degenerated(TopoDS::Edge(edge))) continue;
+      // Ignore edge with internal vertices
+     // Standard_Integer nbVtx = 0;
+     // for (TopExp_Explorer vExp(edge,TopAbs_VERTEX); vExp.More(); vExp.Next()) nbVtx++;
+     // if (nbVtx != 2) continue;
+      // Add to BoundFaces
+      TopTools_ListOfShape listFacesCopy;
+      listFacesCopy.Append(listFaces);
+      myBoundFaces.Add(edge,listFacesCopy);
+      // Process edge vertices
+      TopoDS_Vertex vFirst, vLast;
+      TopExp::Vertices(TopoDS::Edge(edge), vFirst, vLast);
+      if(vFirst.IsNull() || vLast.IsNull()) continue;
+      if(vFirst.Orientation() == TopAbs_INTERNAL || vLast.Orientation() == TopAbs_INTERNAL)
+        continue;
+      if (isBound) {
+	// Add to VertexNode
+	if (!myVertexNode.Contains(vFirst))
+	  myVertexNode.Add(vFirst,vFirst);
+	if (!myVertexNode.Contains(vLast))
+	  myVertexNode.Add(vLast,vLast);
+      }
+      else {
+	// Add to VertexNodeFree
+	if (!myVertexNodeFree.Contains(vFirst))
+	  myVertexNodeFree.Add(vFirst,vFirst);
+	if (!myVertexNodeFree.Contains(vLast))
+	  myVertexNodeFree.Add(vLast,vLast);
+      }
+    }
+  }
+}
+
+//=======================================================================
+//function : VerticesAssembling
+//purpose  : Modifies :
+//                      myVertexNode     (nodes glued)
+//                      myVertexNodeFree (nodes glued)
+//                      myNodeSections   (lists of sections merged for glued nodes)
+//
+//=======================================================================
+
+static Standard_Boolean CreateNewNodes(const TopTools_IndexedDataMapOfShapeShape& NodeNearestNode,
+				       const TopTools_IndexedDataMapOfShapeListOfShape& NodeVertices,
+				       TopTools_IndexedDataMapOfShapeShape& aVertexNode,
+				       TopTools_DataMapOfShapeListOfShape& aNodeEdges)
+{
+  Standard_Integer i, nbNearest = NodeNearestNode.Extent();
+
+  // Create new nodes
+  BRep_Builder B;
+  TopTools_DataMapOfShapeShape OldNodeNewNode;
+  TopTools_DataMapOfShapeListOfShape NewNodeOldNodes;
+  for (i = 1; i <= nbNearest; i++) {
+    // Retrieve a pair of nodes to merge
+    TopoDS_Shape oldnode1 = NodeNearestNode.FindKey(i);
+    TopoDS_Shape oldnode2 = NodeNearestNode(i);
+    // Second node should also be in the map
+    if (!NodeNearestNode.Contains(oldnode2)) continue;
+    // Get new node for old node #1
+    if (OldNodeNewNode.IsBound(oldnode1)) {
+      TopoDS_Shape newnode1 = OldNodeNewNode(oldnode1);
+      if (OldNodeNewNode.IsBound(oldnode2)) {
+	TopoDS_Shape newnode2 = OldNodeNewNode(oldnode2);
+	if (!newnode1.IsSame(newnode2)) {
+	  // Change data for new node #2
+	  TopTools_ListOfShape& lnode1 = NewNodeOldNodes(newnode1);
+	  TopTools_ListIteratorOfListOfShape itn(NewNodeOldNodes(newnode2));
+	  for (; itn.More(); itn.Next()) {
+	    TopoDS_Shape node2 = itn.Value();
+	    lnode1.Append(node2);
+	    OldNodeNewNode(node2) = newnode1;
+	  }
+	  NewNodeOldNodes.UnBind(newnode2);
+	}
+      }
+      else {
+	// Old node #2 is not bound - add to old node #1
+	OldNodeNewNode.Bind(oldnode2,newnode1);
+	NewNodeOldNodes(newnode1).Append(oldnode2);
+      }
+    }
+    else {
+      if (OldNodeNewNode.IsBound(oldnode2)) {
+	// Old node #1 is not bound - add to old node #2
+	TopoDS_Shape newnode2 = OldNodeNewNode(oldnode2);
+	OldNodeNewNode.Bind(oldnode1,newnode2);
+	NewNodeOldNodes(newnode2).Append(oldnode1);
+      }
+      else {
+	// Nodes are not bound - create new node
+	TopoDS_Vertex newnode;
+	B.MakeVertex(newnode);
+	OldNodeNewNode.Bind(oldnode1,newnode);
+	OldNodeNewNode.Bind(oldnode2,newnode);
+	TopTools_ListOfShape lnodes;
+	lnodes.Append(oldnode1);
+	lnodes.Append(oldnode2);
+	NewNodeOldNodes.Bind(newnode,lnodes);
+      }
+    }
+  }
+
+  // Stop if no new nodes created
+  if (!NewNodeOldNodes.Extent()) return Standard_False;
+
+  TopTools_DataMapIteratorOfDataMapOfShapeListOfShape iter1(NewNodeOldNodes);
+  for (; iter1.More(); iter1.Next()) {
+    const TopoDS_Vertex& newnode = TopoDS::Vertex(iter1.Key());
+    // Calculate new node center point
+    gp_XYZ theCoordinates(0.,0.,0.);
+    TopTools_ListOfShape lvert; // Accumulate node vertices
+    TopTools_MapOfShape medge;
+    TopTools_ListOfShape ledge; // Accumulate node edges
+    // Iterate on old nodes
+    TopTools_ListIteratorOfListOfShape itn(iter1.Value());
+    for (; itn.More(); itn.Next()) {
+      const TopoDS_Shape& oldnode = itn.Value();
+      // Iterate on node vertices
+      TopTools_ListIteratorOfListOfShape itv(NodeVertices.FindFromKey(oldnode));
+      for (; itv.More(); itv.Next()) {
+	TopoDS_Vertex vertex = TopoDS::Vertex(itv.Value());
+	// Change node for vertex
+	aVertexNode.ChangeFromKey(vertex) = newnode;
+	// Accumulate coordinates
+	theCoordinates += BRep_Tool::Pnt(vertex).XYZ();
+	lvert.Append(vertex);
+      }
+      // Iterate on node edges
+      const TopTools_ListOfShape& edges = aNodeEdges(oldnode);
+      TopTools_ListIteratorOfListOfShape ite(edges);
+      for (; ite.More(); ite.Next()) {
+	TopoDS_Shape edge = ite.Value();
+	if (!medge.Contains(edge)) { medge.Add(edge); ledge.Append(edge); }
+      }
+      // Unbind old node edges
+      aNodeEdges.UnBind(oldnode);
+    }
+    // Bind new node edges
+    aNodeEdges.Bind(newnode,ledge);
+    gp_Pnt center(theCoordinates / lvert.Extent());
+    // Calculate new node tolerance
+    Standard_Real toler = 0.0;
+    TopTools_ListIteratorOfListOfShape itv(lvert);
+    for (; itv.More(); itv.Next()) {
+      const TopoDS_Vertex& vertex = TopoDS::Vertex(itv.Value());
+      Standard_Real t = center.Distance(BRep_Tool::Pnt(vertex)) + BRep_Tool::Tolerance(vertex);
+      if (toler < t) toler = t;
+    }
+    // Update new node parameters
+    B.UpdateVertex(newnode,center,toler);
+  }
+
+  return Standard_True;
+}
+
+static Standard_Integer IsMergedVertices(const TopoDS_Shape& face1,
+					 const TopoDS_Shape& e1, const TopoDS_Shape& e2,
+					 const TopoDS_Shape& vtx1, const TopoDS_Shape& vtx2)
+{
+  //Case of floating edges
+  if (face1.IsNull())
+    return (!IsClosedShape(e1,vtx1,vtx2));
+
+  // Find wires containing given edges
+  TopoDS_Shape wire1, wire2;
+  TopExp_Explorer itw(face1,TopAbs_WIRE);
+  for (; itw.More() && (wire1.IsNull() || wire2.IsNull()); itw.Next()) {
+    TopoDS_Iterator ite(itw.Current(),Standard_False);
+    for (; ite.More() && (wire1.IsNull() || wire2.IsNull()); ite.Next()) {
+      if (wire1.IsNull() && e1.IsSame(ite.Value())) wire1 = itw.Current();
+      if (wire2.IsNull() && e2.IsSame(ite.Value())) wire2 = itw.Current();
+    }
+  }
+  Standard_Integer Status = 0;
+  if (!wire1.IsNull() && !wire2.IsNull()) {
+    if (wire1.IsSame(wire2)) {
+      for (TopoDS_Iterator aIte(wire1,Standard_False); aIte.More(); aIte.Next()) {
+	TopoDS_Vertex ve1,ve2;
+	TopExp::Vertices(TopoDS::Edge(aIte.Value()),ve1,ve2);
+	if ((ve1.IsSame(vtx1) && ve2.IsSame(vtx2)) ||
+	    (ve2.IsSame(vtx1) && ve1.IsSame(vtx2)))
+	  return (IsClosedShape(aIte.Value(),vtx1,vtx2)? 0 : 1);
+      }
+      if (IsClosedShape(wire1,vtx1,vtx2)) {
+	TopoDS_Vertex V1, V2;
+	TopExp::Vertices(TopoDS::Wire(wire1),V1,V2);
+	Standard_Boolean isEndVertex = ((V1.IsSame(vtx1) && V2.IsSame(vtx2)) ||
+					(V2.IsSame(vtx1) && V1.IsSame(vtx2)));
+	if (!isEndVertex) Status = 1;
+      }
+      else Status = 1;
+    }
+    else Status = -1;
+  }
+  return Status;
+}
+
+static Standard_Boolean GlueVertices(TopTools_IndexedDataMapOfShapeShape& aVertexNode,
+				     TopTools_DataMapOfShapeListOfShape& aNodeEdges,
+				     const TopTools_IndexedDataMapOfShapeListOfShape& aBoundFaces,
+				     const Standard_Real Tolerance)
+{
+  Standard_Integer i, nbVertices = aVertexNode.Extent();
+  // Create map of node -> vertices
+  TopTools_IndexedDataMapOfShapeListOfShape NodeVertices;
+  for (i = 1; i <= nbVertices; i++) {
+    TopoDS_Shape vertex = aVertexNode.FindKey(i);
+    TopoDS_Vertex node = TopoDS::Vertex(aVertexNode(i));
+    if (NodeVertices.Contains(node)) {
+      NodeVertices.ChangeFromKey(node).Append(vertex);
+    }
+    else {
+      TopTools_ListOfShape vlist;
+      vlist.Append(vertex);
+      NodeVertices.Add(node,vlist);
+    }
+  }
+  Standard_Integer nbNodes = NodeVertices.Extent();
+#ifdef DEB
+  cout << "Glueing " << nbNodes << " nodes..." << endl;
+#endif
+  // Create array of boxes with nodes
+  Handle(Bnd_HArray1OfBox) hSetBoxes = new Bnd_HArray1OfBox(1,nbNodes);
+  Bnd_Box aBox;
+  Standard_Real eps = Tolerance*0.5;
+  for (i = 1; i <= nbNodes; i++) {
+    gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(NodeVertices.FindKey(i)));
+    aBox.Set(pt);
+    aBox.Enlarge(eps);
+    hSetBoxes->SetValue(i,aBox);
+  }
+  // Merge nearest nodes
+  TopTools_IndexedDataMapOfShapeShape NodeNearestNode;
+  for (i = 1; i <= nbNodes; i++) {
+    TopoDS_Vertex node1 = TopoDS::Vertex(NodeVertices.FindKey(i));
+    // Find near nodes
+    TColStd_ListOfInteger listIndex;
+    SortBox(hSetBoxes,hSetBoxes->Value(i),listIndex);
+    if (listIndex.IsEmpty()) continue;
+    // Retrieve list of edges for the first node
+    const TopTools_ListOfShape& ledges1 = aNodeEdges(node1);
+    // Explore list of near nodes and fill the sequence of glued nodes
+    TopTools_SequenceOfShape SeqNodes;
+    TopTools_ListOfShape listNodesSameEdge;
+    gp_Pnt pt1 = BRep_Tool::Pnt(node1);
+    TColStd_ListIteratorOfListOfInteger iter1(listIndex);
+    for (; iter1.More(); iter1.Next()) {
+      TopoDS_Vertex node2 = TopoDS::Vertex(NodeVertices.FindKey(iter1.Value()));
+      if (node1 == node2) continue;
+      // Retrieve list of edges for the second node
+      const TopTools_ListOfShape& ledges2 = aNodeEdges(node2);
+      // Check merging condition for the pair of nodes
+      Standard_Integer Status = 0, isSameEdge = Standard_False;
+      // Explore edges of the first node
+      TopTools_ListIteratorOfListOfShape Ie1(ledges1);
+      for (; Ie1.More() && !Status && !isSameEdge; Ie1.Next()) {
+	const TopoDS_Shape& e1 = Ie1.Value();
+	// Obtain real vertex from edge
+	TopoDS_Shape v1 = node1;
+	{ //szv: Use brackets to destroy local variables
+	  TopoDS_Vertex ov1, ov2;
+	  TopExp::Vertices(TopoDS::Edge(e1),ov1,ov2);
+	  if (aVertexNode.Contains(ov1)) {
+	    if (node1.IsSame(aVertexNode.FindFromKey(ov1))) v1 = ov1;
+	  }
+	  if (aVertexNode.Contains(ov2)) {
+	    if (node1.IsSame(aVertexNode.FindFromKey(ov2))) v1 = ov2;
+	  }
+	}
+	// Create map of faces for e1
+	TopTools_MapOfShape Faces1;
+	const TopTools_ListOfShape& lfac1 = aBoundFaces.FindFromKey(e1);
+	if (lfac1.Extent()) {
+	  TopTools_ListIteratorOfListOfShape itf(lfac1);
+	  for (; itf.More(); itf.Next())
+	    if (!itf.Value().IsNull())
+	      Faces1.Add(itf.Value());
+	}
+	// Explore edges of the second node
+        TopTools_ListIteratorOfListOfShape Ie2(ledges2);
+	for (; Ie2.More() && !Status && !isSameEdge; Ie2.Next()) {
+	  const TopoDS_Shape& e2 = Ie2.Value();
+	  // Obtain real vertex from edge
+	  TopoDS_Shape v2 = node2;
+	  { //szv: Use brackets to destroy local variables
+	    TopoDS_Vertex ov1, ov2;
+	    TopExp::Vertices(TopoDS::Edge(e2),ov1,ov2);
+	    if (aVertexNode.Contains(ov1)) {
+	      if (node2.IsSame(aVertexNode.FindFromKey(ov1))) v2 = ov1;
+	    }
+	    if (aVertexNode.Contains(ov2)) {
+	      if (node2.IsSame(aVertexNode.FindFromKey(ov2))) v2 = ov2;
+	    }
+	  }
+	  // Explore faces for e2
+	  const TopTools_ListOfShape& lfac2 = aBoundFaces.FindFromKey(e2);
+	  if (lfac2.Extent()) {
+	    TopTools_ListIteratorOfListOfShape itf(lfac2);
+	    for (; itf.More() && !Status && !isSameEdge; itf.Next()) {
+	      // Check merging conditions for the same face
+	      if (Faces1.Contains(itf.Value())) {
+		Standard_Integer stat = IsMergedVertices(itf.Value(),e1,e2,v1,v2);
+		if (stat == 1) isSameEdge = Standard_True;
+		else Status = stat;
+	      }
+	    }
+	  }
+          else if (Faces1.IsEmpty() && e1 == e2) {
+            Standard_Integer stat = IsMergedVertices(TopoDS_Face(),e1,e1,v1,v2);
+            if (stat == 1) isSameEdge = Standard_True;
+            else Status = stat;
+            break;
+          }
+	}
+      }
+      if (Status) continue;
+      if (isSameEdge) listNodesSameEdge.Append(node2);
+      // Append near node to the sequence
+      gp_Pnt pt2 = BRep_Tool::Pnt(node2);
+      Standard_Real dist = pt1.Distance(pt2);
+      if (dist < Tolerance) {
+	Standard_Boolean isIns = Standard_False;
+	for (Standard_Integer kk = 1; kk <= SeqNodes.Length() && !isIns; kk++) {
+	  gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(SeqNodes.Value(kk)));
+	  if (dist < pt1.Distance(pt)) {
+	    SeqNodes.InsertBefore(kk,node2);
+	    isIns = Standard_True;
+	  }
+	}
+	if (!isIns) SeqNodes.Append(node2);
+      }
+    }
+    if (SeqNodes.Length()) {
+      // Remove nodes near to some other from the same edge
+      if (listNodesSameEdge.Extent()) {
+	TopTools_ListIteratorOfListOfShape lInt(listNodesSameEdge);
+	for (; lInt.More(); lInt.Next()) {
+	  const TopoDS_Vertex& n2 = TopoDS::Vertex(lInt.Value());
+	  gp_Pnt p2 = BRep_Tool::Pnt(n2);
+	  for (Standard_Integer k = 1; k <= SeqNodes.Length(); ) {
+	    const TopoDS_Vertex& n1 = TopoDS::Vertex(SeqNodes.Value(k));
+	    if (n1 != n2) {
+	      gp_Pnt p1 = BRep_Tool::Pnt(n1);
+	      if (p2.Distance(p1) >= pt1.Distance(p1)) { k++; continue; }
+	    }
+	    SeqNodes.Remove(k);
+	  }
+	}
+      }
+      // Bind nearest node if at least one exists
+      if (SeqNodes.Length())
+	NodeNearestNode.Add(node1,SeqNodes.First());
+    }
+  }
+
+  // Create new nodes for chained nearest nodes
+  if (NodeNearestNode.IsEmpty()) return Standard_False;
+  hSetBoxes.Nullify();
+
+  return CreateNewNodes(NodeNearestNode,NodeVertices,aVertexNode,aNodeEdges);
+}
+
+void BRepBuilderAPI_Sewing::VerticesAssembling()
+{
+  Standard_Integer nbVert = myVertexNode.Extent();
+  Standard_Integer nbVertFree = myVertexNodeFree.Extent();
+  if (nbVert || nbVertFree) {
+    // Fill map node -> sections
+    Standard_Integer i;
+    for (i = 1; i <= myBoundFaces.Extent(); i++) {
+      TopoDS_Shape bound = myBoundFaces.FindKey(i);
+      for (TopoDS_Iterator itv(bound,Standard_False); itv.More(); itv.Next()) {
+	TopoDS_Shape node = itv.Value();
+	if (myNodeSections.IsBound(node))
+	  myNodeSections(node).Append(bound);
+	else {
+	  TopTools_ListOfShape lbnd;
+	  lbnd.Append(bound);
+	  myNodeSections.Bind(node,lbnd);
+	}
+      }
+    }
+    // Glue vertices
+    if (nbVert) {
+#ifdef DEB
+      cout << "Assemble " << nbVert << " vertices on faces..." << endl;
+#endif
+      while (GlueVertices(myVertexNode,myNodeSections,myBoundFaces,myTolerance));
+    }
+    if (nbVertFree) {
+#ifdef DEB
+      cout << "Assemble " << nbVertFree << " vertices on floating edges..." << endl;
+#endif
+      while (GlueVertices(myVertexNodeFree,myNodeSections,myBoundFaces,myTolerance));
+    }
+  }
+}
+
+//=======================================================================
+//function : replaceNMVertices
+//purpose  : internal use (static)
+//=======================================================================
+static void replaceNMVertices(const TopoDS_Edge& theEdge, 
+                              const TopoDS_Vertex& theV1,
+                              const TopoDS_Vertex& theV2,
+                              const Handle(BRepTools_ReShape)& theReShape)
+{
+  //To keep NM vertices on edge
+  TopTools_SequenceOfShape aSeqNMVert;
+  TColStd_SequenceOfReal aSeqNMPars;
+  Standard_Boolean hasNMVert = findNMVertices(theEdge,aSeqNMVert,aSeqNMPars);
+  if(!hasNMVert)
+    return;
+  Standard_Real first, last;
+  BRep_Tool::Range(theEdge, first, last);
+  TopLoc_Location aLoc;
+  Handle(Geom_Curve) c3d = BRep_Tool::Curve(theEdge,aLoc,first, last);
+  if(c3d.IsNull())
+    return;
+  TopTools_SequenceOfShape aEdVert;
+  TColStd_SequenceOfReal aEdParams;
+  Standard_Boolean isCopyEdge = Standard_False;
+  Standard_Integer i =1, nb = aSeqNMPars.Length();
+    
+  for( ; i <= nb;i++) {
+    Standard_Real apar = aSeqNMPars.Value(i);
+    if(fabs(apar - first) <= Precision::PConfusion()) {
+      theReShape->Replace(aSeqNMVert.Value(i),theV1);
+      continue;
+    }
+    if(fabs(apar - last) <= Precision::PConfusion()) {
+      theReShape->Replace(aSeqNMVert.Value(i),theV2);
+      continue;
+    }
+    TopoDS_Shape aV = aSeqNMVert.Value(i);
+    Standard_Integer j =1;
+    for( ; j <= aEdParams.Length();j++) {
+      Standard_Real apar2 = aEdParams.Value(j);
+      if(fabs(apar - apar2) <= Precision::PConfusion()) {
+        theReShape->Replace(aV,aEdVert.Value(j));
+        break;
+      }
+      else if(apar < apar2) {
+        TopoDS_Shape anewV = aV.EmptyCopied();
+        aEdVert.InsertBefore(j,anewV);
+        aEdParams.InsertBefore(j,apar);
+        BRep_ListOfPointRepresentation& alistrep = 
+          (*((Handle(BRep_TVertex)*)&anewV.TShape()))->ChangePoints();
+        Handle(BRep_PointOnCurve) aPRep = new BRep_PointOnCurve(apar,c3d,aLoc);
+        alistrep.Append(aPRep);
+        theReShape->Replace(aV,anewV);
+        break;
+      }
+    }
+    if (j > aEdParams.Length()) {
+      TopoDS_Shape anewV = aV.EmptyCopied();
+      aEdVert.Append(anewV);
+      aEdParams.Append(apar);
+      BRep_ListOfPointRepresentation& alistrep = 
+        (*((Handle(BRep_TVertex)*) &anewV.TShape()))->ChangePoints();
+      Handle(BRep_PointOnCurve) aPRep = new BRep_PointOnCurve(apar,c3d,aLoc);
+      alistrep.Append(aPRep);
+      theReShape->Replace(aV,anewV);
+    }
+  }
+  
+  Standard_Integer newnb = aEdParams.Length();
+  if(newnb < nb) {
+    
+    TopoDS_Shape anewEdge = theEdge.EmptyCopied();
+    TopAbs_Orientation anOri = theEdge.Orientation();
+    anewEdge.Orientation(TopAbs_FORWARD);
+    BRep_Builder aB;
+    aB.Add(anewEdge,theV1);
+    aB.Add(anewEdge,theV2);
+    
+    for( i =1; i <= aEdVert.Length();i++) 
+      aB.Add(anewEdge,aEdVert.Value(i));
+    anewEdge.Orientation(anOri);
+    theReShape->Replace(theEdge,anewEdge);
+  }
+ 
+}
+
+//=======================================================================
+//function : ReplaceEdge
+//purpose  : internal use (static)
+//=======================================================================
+
+static void ReplaceEdge(const TopoDS_Shape& oldEdge,
+			const TopoDS_Shape& theNewShape,
+			const Handle(BRepTools_ReShape)& aReShape)
+{
+  TopoDS_Shape oldShape = aReShape->Apply(oldEdge);
+  TopoDS_Shape newShape = aReShape->Apply(theNewShape);
+  if (oldShape.IsSame(newShape)|| aReShape->IsRecorded(newShape)) return;
+  
+
+  aReShape->Replace(oldShape,newShape);
+  TopoDS_Vertex V1old,V2old,V1new,V2new;
+  TopExp::Vertices(TopoDS::Edge(oldShape),V1old,V2old);
+  TopAbs_Orientation Orold = oldShape.Orientation();
+  TopAbs_Orientation Ornew = Orold;
+  if (newShape.ShapeType() == TopAbs_EDGE) {
+    TopoDS_Edge aEn = TopoDS::Edge(newShape);
+    TopExp::Vertices(aEn,V1new,V2new);
+    Ornew = aEn.Orientation();
+    replaceNMVertices(aEn,V1new,V2new,aReShape);
+  }
+  else if (newShape.ShapeType() == TopAbs_WIRE) {
+    for (TopExp_Explorer aex(newShape,TopAbs_EDGE); aex.More(); aex.Next()) {
+      TopoDS_Edge ed = TopoDS::Edge(aex.Current());
+      Ornew = ed.Orientation();
+      TopoDS_Vertex aV1,aV2;
+      TopExp::Vertices(ed,aV1,aV2);
+      replaceNMVertices(ed,aV1,aV2,aReShape);
+      if (V1new.IsNull()) 
+        V1new = aV1;
+      V2new =aV2;
+    }
+  }
+  
+  V1new.Orientation(V1old.Orientation());
+  V2new.Orientation(V2old.Orientation());
+  if (V1old.IsSame(V2old) && !V1old.IsSame(V1new)&& !aReShape->IsRecorded(V1new)) {
+    aReShape->Replace(V1old,V1new);
+    return;
+  }
+  if (Orold == Ornew) {
+    V1new.Orientation(V1old.Orientation());
+    V2new.Orientation(V2old.Orientation());
+    if (!V1old.IsSame(V1new) && !V1old.IsSame(V2new)&& !aReShape->IsRecorded(V1new))
+      aReShape->Replace(V1old,V1new);
+    if (!V2old.IsSame(V2new) && !V2old.IsSame(V1new)&& !aReShape->IsRecorded(V2new))
+      aReShape->Replace(V2old,V2new);
+  }
+  else {
+    V1new.Orientation(V2old.Orientation());
+    V2new.Orientation(V1old.Orientation());
+    if (!V1old.IsSame(V2new) && !V1old.IsSame(V1new)&& !aReShape->IsRecorded(V2new)) 
+      aReShape->Replace(V1old,V2new);
+    if (!V2old.IsSame(V2new) && !V2old.IsSame(V1new)&& !aReShape->IsRecorded(V1new))
+      aReShape->Replace(V2old,V1new);
+  }
+}
+
+//=======================================================================
+//function : Merging
+//purpose  : Modifies :
+//                   myHasFreeBound
+//
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Merging(const Standard_Boolean /* firstTime */)
+{
+  BRep_Builder B;
+//  TopTools_MapOfShape MergedEdges;
+  for (Standard_Integer i = 1; i <= myBoundFaces.Extent(); i++) {
+
+    TopoDS_Shape bound = myBoundFaces.FindKey(i);
+
+    // If bound was already merged - continue
+    if (myMergedEdges.Contains(bound)) continue;
+
+    if (!myBoundFaces(i).Extent()) {
+      // Merge free edge - only vertices
+      TopoDS_Vertex no1, no2;
+      TopExp::Vertices(TopoDS::Edge(bound),no1,no2);
+      TopoDS_Shape nno1 = no1, nno2 = no2;
+      if (myVertexNodeFree.Contains(no1))
+	nno1 = myVertexNodeFree.FindFromKey(no1);
+      if (myVertexNodeFree.Contains(no2))
+	nno2 = myVertexNodeFree.FindFromKey(no2);
+      if (!no1.IsSame(nno1)) {
+        nno1.Orientation(no1.Orientation());
+	myReShape->Replace(no1,nno1);
+      }
+      if (!no2.IsSame(nno2)) {
+        nno2.Orientation(no2.Orientation());
+	myReShape->Replace(no2,nno2);
+      }
+      myMergedEdges.Add(bound);
+      continue;
+    }
+
+    // Check for previous splitting, build replacing wire
+    TopoDS_Wire BoundWire;
+    Standard_Boolean isPrevSplit = Standard_False;
+    Standard_Boolean hasCuttingSections = myBoundSections.IsBound(bound);
+    if (hasCuttingSections) {
+      B.MakeWire(BoundWire);
+      BoundWire.Orientation(bound.Orientation());
+      // Iterate on cutting sections
+      TopTools_ListIteratorOfListOfShape its(myBoundSections(bound));
+      for (; its.More(); its.Next()) {
+	TopoDS_Shape section = its.Value();
+	B.Add(BoundWire,section);
+	if (myMergedEdges.Contains(section)) isPrevSplit = Standard_True;
+      }
+    }
+
+    // Merge with bound
+    TopTools_DataMapOfShapeShape MergedWithBound;
+    if (!isPrevSplit) {
+      // Obtain sequence of edges merged with bound
+      TopTools_SequenceOfShape seqMergedWithBound;
+      TColStd_SequenceOfInteger seqMergedWithBoundOri;
+      if (MergedNearestEdges(bound,seqMergedWithBound,seqMergedWithBoundOri)) {
+	// Store bound in the map
+	MergedWithBound.Bind(bound,bound);
+	// Iterate on edges merged with bound
+	Standard_Integer ii = 1;
+	while (ii <= seqMergedWithBound.Length()) {
+	  TopoDS_Shape iedge = seqMergedWithBound.Value(ii);
+	  // Remove edge if recorded as merged
+	  Standard_Boolean isRejected = (myMergedEdges.Contains(iedge) || MergedWithBound.IsBound(iedge));
+	  if (!isRejected) {
+	    if (myBoundSections.IsBound(iedge)) {
+	      // Edge is splitted - check sections
+	      TopTools_ListIteratorOfListOfShape lit(myBoundSections(iedge));
+	      for (; lit.More() && !isRejected; lit.Next()) {
+		const TopoDS_Shape& sec = lit.Value();
+		// Remove edge (bound) if at least one of its sections already merged
+		isRejected = (myMergedEdges.Contains(sec) || MergedWithBound.IsBound(sec));
+	      }
+	    }
+	    if (!isRejected) {
+	      if (mySectionBound.IsBound(iedge)) {
+		// Edge is a section - check bound
+		const TopoDS_Shape& bnd = mySectionBound(iedge);
+		// Remove edge (section) if its bound already merged
+		isRejected = (myMergedEdges.Contains(bnd) || MergedWithBound.IsBound(bnd));
+	      }
+	    }
+	  }
+	  // To the next merged edge
+	  if (isRejected) {
+	    // Remove rejected edge
+	    seqMergedWithBound.Remove(ii);
+	    seqMergedWithBoundOri.Remove(ii);
+	  }
+	  else {
+	    // Process accepted edge
+	    MergedWithBound.Bind(iedge,iedge);
+	    ii++;
+	  }
+	}
+	Standard_Integer nbMerged = seqMergedWithBound.Length();
+	if (nbMerged) {
+	  // Create same parameter edge
+	  TopTools_MapOfShape ActuallyMerged;
+	  TopoDS_Edge MergedEdge = SameParameterEdge(bound,seqMergedWithBound,
+						     seqMergedWithBoundOri,
+						     ActuallyMerged,myReShape);
+	  Standard_Boolean isForward = Standard_False;
+	  if (!MergedEdge.IsNull()) isForward = (MergedEdge.Orientation() == TopAbs_FORWARD);
+	  // Process actually merged edges
+	  Standard_Integer nbActuallyMerged = 0;
+	  for (ii = 1; ii <= nbMerged; ii++) {
+	    TopoDS_Shape iedge = seqMergedWithBound(ii);
+	    if (ActuallyMerged.Contains(iedge)) {
+	      nbActuallyMerged++;
+	      // Record merged edge in the map
+	      TopAbs_Orientation orient = iedge.Orientation();
+	      if (!isForward) orient = TopAbs::Reverse(orient);
+	      if (!seqMergedWithBoundOri(ii)) orient = TopAbs::Reverse(orient);
+	      MergedWithBound.ChangeFind(iedge) = MergedEdge.Oriented(orient);
+	    }
+	    else MergedWithBound.UnBind(iedge);
+	  }
+	  if (nbActuallyMerged) {
+	    // Record merged bound in the map
+	    TopAbs_Orientation orient = bound.Orientation();
+	    if (!isForward) orient = TopAbs::Reverse(orient);
+	    MergedWithBound.ChangeFind(bound) = MergedEdge.Oriented(orient);
+	  }
+	  nbMerged = nbActuallyMerged;
+	}
+	// Remove bound from the map if not finally merged
+	if (!nbMerged) MergedWithBound.UnBind(bound);
+      }
+    }
+    Standard_Boolean isMerged = MergedWithBound.Extent();
+
+    // Merge with cutting sections
+    Handle(BRepTools_ReShape) SectionsReShape = new BRepTools_ReShape;
+    TopTools_DataMapOfShapeShape MergedWithSections;
+    if (hasCuttingSections) {
+      // Iterate on cutting sections
+      TopTools_ListIteratorOfListOfShape its(myBoundSections(bound));
+      for (; its.More(); its.Next()) {
+	// Retrieve cutting section
+	TopoDS_Shape section = its.Value();
+	// Skip section if already merged
+	if (myMergedEdges.Contains(section)) continue;
+	// Merge cutting section
+	TopTools_SequenceOfShape seqMergedWithSection;
+	TColStd_SequenceOfInteger seqMergedWithSectionOri;
+	if (MergedNearestEdges(section,seqMergedWithSection,seqMergedWithSectionOri)) {
+	  // Store section in the map
+	  MergedWithSections.Bind(section,section);
+	  // Iterate on edges merged with section
+	  Standard_Integer ii = 1;
+	  while (ii <= seqMergedWithSection.Length()) {
+	    TopoDS_Shape iedge = seqMergedWithSection.Value(ii);
+	    // Remove edge if recorded as merged
+	    Standard_Boolean isRejected = (myMergedEdges.Contains(iedge) || MergedWithSections.IsBound(iedge));
+	    if (!isRejected) {
+	      if (myBoundSections.IsBound(iedge)) {
+		// Edge is splitted - check sections
+		TopTools_ListIteratorOfListOfShape lit(myBoundSections(iedge));
+		for (; lit.More() && !isRejected; lit.Next()) {
+		  const TopoDS_Shape& sec = lit.Value();
+		  // Remove edge (bound) if at least one of its sections already merged
+		  isRejected = (myMergedEdges.Contains(sec) || MergedWithSections.IsBound(sec));
+		}
+	      }
+	      if (!isRejected) {
+		if (mySectionBound.IsBound(iedge)) {
+		  // Edge is a section - check bound
+		  const TopoDS_Shape& bnd = mySectionBound(iedge);
+		  // Remove edge (section) if its bound already merged
+		  isRejected = (myMergedEdges.Contains(bnd) || MergedWithSections.IsBound(bnd));
+		}
+	      }
+	    }
+	    // To the next merged edge
+	    if (isRejected) {
+	      // Remove rejected edge
+	      seqMergedWithSection.Remove(ii);
+	      seqMergedWithSectionOri.Remove(ii);
+	    }
+	    else {
+	      // Process accepted edge
+	      MergedWithSections.Bind(iedge,iedge);
+	      ii++;
+	    }
+	  }
+	  Standard_Integer nbMerged = seqMergedWithSection.Length();
+	  if (nbMerged) {
+	    // Create same parameter edge
+	    TopTools_MapOfShape ActuallyMerged;
+	    TopoDS_Edge MergedEdge = SameParameterEdge(section,seqMergedWithSection,
+						       seqMergedWithSectionOri,
+						       ActuallyMerged,SectionsReShape);
+	    Standard_Boolean isForward = Standard_False;
+	    if (!MergedEdge.IsNull()) isForward = (MergedEdge.Orientation() == TopAbs_FORWARD);
+	    // Process actually merged edges
+	    Standard_Integer nbActuallyMerged = 0;
+	    for (ii = 1; ii <= nbMerged; ii++) {
+	      TopoDS_Shape iedge = seqMergedWithSection(ii);
+	      if (ActuallyMerged.Contains(iedge)) {
+		nbActuallyMerged++;
+		// Record merged edge in the map
+		TopAbs_Orientation orient = iedge.Orientation();
+		if (!isForward) orient = TopAbs::Reverse(orient);
+		if (!seqMergedWithSectionOri(ii)) orient = TopAbs::Reverse(orient);
+		TopoDS_Shape oedge = MergedEdge.Oriented(orient);
+		MergedWithSections.ChangeFind(iedge) = oedge;
+		ReplaceEdge(myReShape->Apply(iedge),oedge,SectionsReShape);
+	      }
+	      else MergedWithSections.UnBind(iedge);
+	    }
+	    if (nbActuallyMerged) {
+	      // Record merged section in the map
+	      TopAbs_Orientation orient = section.Orientation();
+	      if (!isForward) orient = TopAbs::Reverse(orient);
+	      TopoDS_Shape oedge = MergedEdge.Oriented(orient);
+	      MergedWithSections.ChangeFind(section) = oedge;
+	      ReplaceEdge(myReShape->Apply(section),oedge,SectionsReShape);
+	    }
+	    nbMerged = nbActuallyMerged;
+	  }
+	  // Remove section from the map if not finally merged
+	  if (!nbMerged) MergedWithSections.UnBind(section);
+	}
+	else if (isMerged) {
+	  // Reject merging of sections
+	  MergedWithSections.Clear();
+	  break;
+	}
+      }
+    }
+    Standard_Boolean isMergedSplit = MergedWithSections.Extent();
+
+    if (!isMerged && !isMergedSplit) {
+      // Nothing was merged in this iteration
+      if (isPrevSplit) {
+	// Replace previously splitted bound
+	myReShape->Replace(myReShape->Apply(bound),myReShape->Apply(BoundWire));
+      }
+//      else if (hasCuttingSections) {
+//	myBoundSections.UnBind(bound); //szv: are you sure ???
+//      }
+      continue;
+    }
+
+    // Set splitting flag
+    Standard_Boolean isSplitted = ((!isMerged && isMergedSplit) || isPrevSplit);
+
+    // Choose between bound and sections merging
+    if (isMerged && isMergedSplit && !isPrevSplit) {
+      // Fill map of merged cutting sections
+      TopTools_MapOfShape MapSplitEdges;
+      TopTools_DataMapIteratorOfDataMapOfShapeShape itm;
+      for (itm.Initialize(MergedWithSections); itm.More(); itm.Next()) {
+	TopoDS_Shape edge = itm.Key();
+	MapSplitEdges.Add(edge);
+      }
+      // Iterate on edges merged with bound
+      for (itm.Initialize(MergedWithBound); itm.More(); itm.Next()) {
+	// Retrieve edge merged with bound
+	TopoDS_Shape edge = itm.Key();
+	// Remove edge from the map
+	if (MapSplitEdges.Contains(edge)) MapSplitEdges.Remove(edge);
+	if (myBoundSections.IsBound(edge)) {
+	  // Edge has cutting sections
+	  TopTools_ListIteratorOfListOfShape its(myBoundSections(edge));
+	  for (; its.More(); its.Next()) {
+	    TopoDS_Shape sec = its.Value();
+	    // Remove section from the map
+	    if (MapSplitEdges.Contains(sec)) MapSplitEdges.Remove(sec);
+	  }
+	}
+      }
+      // Calculate section merging tolerance
+      Standard_Real MinSplitTol = RealLast();
+      TopTools_MapIteratorOfMapOfShape im(MapSplitEdges);
+      for (; im.More(); im.Next()) {
+        TopoDS_Edge edge = TopoDS::Edge(MergedWithSections(im.Key()));
+	MinSplitTol = Min(MinSplitTol,BRep_Tool::Tolerance(edge));
+      }
+      // Calculate bound merging tolerance
+      TopoDS_Edge BoundEdge = TopoDS::Edge(MergedWithBound(bound));
+      Standard_Real BoundEdgeTol = BRep_Tool::Tolerance(BoundEdge);
+      isSplitted = ((MinSplitTol < BoundEdgeTol+MinTolerance()) || myNonmanifold);
+      isSplitted = (!MapSplitEdges.IsEmpty() && isSplitted);
+    }
+
+    if (isSplitted) {
+      // Merging of cutting sections
+      //myMergedEdges.Add(bound);
+      myReShape->Replace(myReShape->Apply(bound),myReShape->Apply(BoundWire));
+      TopTools_DataMapIteratorOfDataMapOfShapeShape itm(MergedWithSections);
+      for (; itm.More(); itm.Next()) {
+	TopoDS_Shape oldedge = itm.Key();
+	TopoDS_Shape newedge = SectionsReShape->Apply(itm.Value());
+	ReplaceEdge(myReShape->Apply(oldedge),newedge,myReShape);
+	myMergedEdges.Add(oldedge);
+        if (myBoundSections.IsBound(oldedge)) myBoundSections.UnBind(oldedge);
+       
+      }
+    }
+    else {
+      // Merging of initial bound
+      TopTools_DataMapIteratorOfDataMapOfShapeShape itm(MergedWithBound);
+      //myMergedEdges.Add(bound);
+      for (; itm.More(); itm.Next()) {
+	TopoDS_Shape oldedge = itm.Key();
+	TopoDS_Shape newedge = itm.Value();
+	ReplaceEdge(myReShape->Apply(oldedge),newedge,myReShape);
+	myMergedEdges.Add(oldedge);
+        if (myBoundSections.IsBound(oldedge)) myBoundSections.UnBind(oldedge);
+      }
+      if (myBoundSections.IsBound(bound)) myBoundSections.UnBind(bound);
+      if(!myMergedEdges.Contains(bound))
+          myMergedEdges.Add(bound);
+    }
+  }
+
+  myNbVertices = myVertexNode.Extent() + myVertexNodeFree.Extent();
+  myNodeSections.Clear();
+  myVertexNode.Clear();
+  myVertexNodeFree.Clear();
+  myCuttingNode.Clear();
+}
+
+//=======================================================================
+//function : MergedNearestEdges
+//purpose  : 
+//=======================================================================
+
+Standard_Boolean BRepBuilderAPI_Sewing::MergedNearestEdges(const TopoDS_Shape& edge,
+						     TopTools_SequenceOfShape& SeqMergedEdge,
+						     TColStd_SequenceOfInteger& SeqMergedOri)
+{
+  // Retrieve edge nodes
+  TopoDS_Vertex no1, no2;
+  TopExp::Vertices(TopoDS::Edge(edge),no1,no2);
+  TopoDS_Shape nno1 = no1, nno2 = no2;
+  Standard_Boolean isNode1 = myVertexNode.Contains(no1);
+  Standard_Boolean isNode2 = myVertexNode.Contains(no2);
+  if (isNode1) nno1 = myVertexNode.FindFromKey(no1);
+  if (isNode2) nno2 = myVertexNode.FindFromKey(no2);
+
+  // Fill map of nodes connected to the node #1
+  TopTools_MapOfShape mapVert1;
+  mapVert1.Add(nno1);
+  if (myCuttingNode.IsBound(nno1)) {
+    TopTools_ListIteratorOfListOfShape ilv(myCuttingNode(nno1));
+    for (; ilv.More(); ilv.Next()) {
+      TopoDS_Shape v1 = ilv.Value();
+      mapVert1.Add(v1);
+      if (!isNode1 && myCuttingNode.IsBound(v1)) {
+	TopTools_ListIteratorOfListOfShape ilvn(myCuttingNode(v1));
+	for (; ilvn.More(); ilvn.Next()) {
+	  TopoDS_Shape vn = ilvn.Value();
+	  mapVert1.Add(vn);
+	}
+      }
+    }
+  }
+
+  // Fill map of nodes connected to the node #2
+  TopTools_MapOfShape mapVert2;
+  mapVert2.Add(nno2);
+  if (myCuttingNode.IsBound(nno2)) {
+    TopTools_ListIteratorOfListOfShape ilv(myCuttingNode(nno2));
+    for (; ilv.More(); ilv.Next()) {
+      TopoDS_Shape v1 = ilv.Value();
+      mapVert2.Add(v1);
+      if (!isNode2 && myCuttingNode.IsBound(v1)) {
+	TopTools_ListIteratorOfListOfShape ilvn(myCuttingNode(v1));
+	for (; ilvn.More(); ilvn.Next()) {
+	  TopoDS_Shape vn = ilvn.Value();
+	  mapVert2.Add(vn);
+	}
+      }
+    }
+  }
+
+  // Find all possible contigous edges
+  TopTools_SequenceOfShape seqEdges;
+  seqEdges.Append(edge);
+  TopTools_MapOfShape mapEdges;
+  mapEdges.Add(edge);
+  for (TopTools_MapIteratorOfMapOfShape imv1(mapVert1); imv1.More(); imv1.Next()) {
+    TopoDS_Shape node1 = imv1.Key();
+    if (!myNodeSections.IsBound(node1)) continue;
+    TopTools_ListIteratorOfListOfShape ilsec(myNodeSections(node1));
+    for (; ilsec.More(); ilsec.Next()) {
+      TopoDS_Shape sec = ilsec.Value();
+      if (sec.IsSame(edge)) continue;
+      // Retrieve section nodes
+      TopoDS_Vertex vs1, vs2;
+      TopExp::Vertices(TopoDS::Edge(sec),vs1,vs2);
+      TopoDS_Shape vs1n = vs1, vs2n = vs2;
+      if (myVertexNode.Contains(vs1)) vs1n = myVertexNode.FindFromKey(vs1);
+      if (myVertexNode.Contains(vs2)) vs2n = myVertexNode.FindFromKey(vs2);
+      if ((mapVert1.Contains(vs1n) && mapVert2.Contains(vs2n)) ||
+	  (mapVert1.Contains(vs2n) && mapVert2.Contains(vs1n)))
+	if (mapEdges.Add(sec)) {
+	  // Check for rejected cutting
+	  Standard_Boolean isRejected = Standard_False;
+	  if (mySectionBound.IsBound(sec)) {
+	    const TopoDS_Shape& bnd = mySectionBound(sec);
+	    isRejected = !myBoundSections.IsBound(bnd);
+	  }
+	  if (!isRejected) seqEdges.Append(sec);
+	}
+    }
+  }
+  mapEdges.Clear();
+
+  Standard_Boolean success = Standard_False;
+
+  Standard_Integer nbSection = seqEdges.Length();
+  if (nbSection > 1) {
+    // Find the longest edge CCI60011
+    Standard_Integer i, indRef = 1;
+    if (myNonmanifold) {
+      Standard_Real lenRef = 0.;
+      for (i = 1; i <= nbSection; i++) {
+	Standard_Real f, l;
+	Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(seqEdges(i)), f, l);
+	GeomAdaptor_Curve cAdapt(c3d);
+	Standard_Real len = GCPnts_AbscissaPoint::Length(cAdapt, f, l);
+	if (len > lenRef) { indRef = i; lenRef = len; }
+      }
+      if (indRef != 1) {
+	TopoDS_Shape longEdge = seqEdges(indRef);
+	seqEdges(indRef) = seqEdges(1);
+	seqEdges(1) = longEdge;
+      }
+    }
+
+    // Find merging candidates
+    TColStd_SequenceOfInteger seqForward;
+    TColStd_SequenceOfInteger seqCandidates;
+    TColStd_IndexedMapOfInteger mapReference;
+    mapReference.Add(1); // Add index of reference section
+    if (FindCandidates(seqEdges,mapReference,seqCandidates,seqForward)) {
+      Standard_Integer nbCandidates = seqCandidates.Length();
+      // Check if reference section is merged reversed
+      Standard_Boolean toReverse = Standard_False;
+      if (indRef != 1) {
+	// Find reference edge in candidates
+	Standard_Boolean isFound = Standard_False;
+	for (i = 1; i <= nbCandidates && !isFound; i++) {
+	  isFound = (seqCandidates(i) == indRef);
+	  if (isFound) {
+	    // Record orientation
+	    toReverse = !seqForward(i);
+	    // Restore first edge
+	    seqCandidates(i) = 1;
+	    seqForward(i) = 1;
+	  }
+	}
+	// Fail if reference is not in candidates
+	if (!isFound) return Standard_False;
+      }
+      // Record candidate sections
+      for (i = 1; i <= nbCandidates; i++) {
+	// Retrieve merged edge
+	TopoDS_Shape iedge = seqEdges(seqCandidates(i));
+	Standard_Integer ori =
+	  ((seqForward(i) && toReverse) || (!seqForward(i) && !toReverse))? 0 : 1;
+	SeqMergedEdge.Append(iedge);
+	SeqMergedOri.Append(ori);
+	if (!myNonmanifold) break;
+      }
+      success = nbCandidates;
+    }
+  }
+
+  return success;
+}
+
+//=======================================================================
+//function : Cutting
+//purpose  : Modifies :
+//                     myBoundSections
+//                     myNodeSections
+//                     myCuttingNode
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::Cutting()
+{
+  Standard_Integer i, nbVertices = myVertexNode.Extent();
+  if (!nbVertices) return;
+  // Create a sort box with vertices
+  Standard_Real eps = myTolerance*0.5;
+  Handle(Bnd_HArray1OfBox) hSetBoxes = new Bnd_HArray1OfBox(1,nbVertices);
+  for (i = 1; i <= nbVertices; i++) {
+    gp_Pnt pt = BRep_Tool::Pnt(TopoDS::Vertex(myVertexNode.FindKey(i)));
+    Bnd_Box aBox;
+    aBox.Set(pt);
+    aBox.Enlarge(eps);
+    hSetBoxes->ChangeValue(i) = aBox;
+  }
+  Handle(Geom_Curve) c3d;
+  TopLoc_Location loc;
+  Standard_Real first, last;
+  // Iterate on all boundaries
+  Standard_Integer nbBounds = myBoundFaces.Extent();
+  for (i = 1; i <= nbBounds; i++) {
+    const TopoDS_Edge& bound = TopoDS::Edge(myBoundFaces.FindKey(i));
+    // Do not cut floating edges
+    if (!myBoundFaces(i).Extent()) continue;
+    // Create cutting sections
+    TopTools_ListOfShape listSections;
+    { //szv: Use brackets to destroy local variables
+      // Obtain bound curve
+      c3d = BRep_Tool::Curve(bound, loc, first, last);
+      if (!loc.IsIdentity()) {
+	c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+	c3d->Transform(loc.Transformation());
+      }
+      // Obtain candidate vertices
+      TopoDS_Vertex V1, V2;
+      TopTools_IndexedMapOfShape CandidateVertices;
+      { //szv: Use brackets to destroy local variables
+	// Create bounding box around curve
+	Bnd_Box aGlobalBox;
+	GeomAdaptor_Curve adptC(c3d,first,last);
+	BndLib_Add3dCurve::Add(adptC,myTolerance,aGlobalBox);
+	// Sort vertices to find candidates
+	TColStd_ListOfInteger listIndex;
+	SortBox(hSetBoxes,aGlobalBox,listIndex);
+	// Skip bound if no node is in the boundind box
+	if (!listIndex.Extent()) continue;
+	// Retrieve bound nodes
+	TopExp::Vertices(bound,V1,V2);
+	const TopoDS_Shape& Node1 = myVertexNode.FindFromKey(V1);
+	const TopoDS_Shape& Node2 = myVertexNode.FindFromKey(V2);
+	// Fill map of candidate vertices
+	TColStd_ListIteratorOfListOfInteger itl(listIndex);
+	for (; itl.More(); itl.Next()) {
+	  const Standard_Integer index = itl.Value();
+	  const TopoDS_Shape& Node = myVertexNode.FindFromIndex(index);
+	  if (!Node.IsSame(Node1) && !Node.IsSame(Node2)) {
+	    TopoDS_Shape vertex = myVertexNode.FindKey(index);
+	    CandidateVertices.Add(vertex);
+	  }
+	}
+      }
+      Standard_Integer nbCandidates = CandidateVertices.Extent();
+      if (!nbCandidates) continue;
+      // Project vertices on curve
+      TColStd_Array1OfReal arrPara(1,nbCandidates), arrDist(1,nbCandidates);
+      TColgp_Array1OfPnt arrPnt(1,nbCandidates), arrProj(1,nbCandidates);
+      for (Standard_Integer j = 1; j <= nbCandidates; j++)
+	arrPnt(j) = BRep_Tool::Pnt(TopoDS::Vertex(CandidateVertices(j)));
+      ProjectPointsOnCurve(arrPnt,c3d,first,last,arrDist,arrPara,arrProj);
+      // Create cutting nodes
+      TopTools_SequenceOfShape seqNode;
+      TColStd_SequenceOfReal seqPara;
+      CreateCuttingNodes(CandidateVertices,bound,
+			 V1,V2,arrDist,arrPara,arrProj,seqNode,seqPara);
+      if (!seqPara.Length()) continue;
+      // Create cutting sections
+      CreateSections(bound, seqNode, seqPara, listSections);
+    }
+    if (listSections.Extent() > 1) {
+      // modification of maps:
+      //                     myBoundSections
+      TopTools_ListIteratorOfListOfShape its(listSections);
+      for (; its.More(); its.Next()) {
+	TopoDS_Shape section = its.Value();
+	// Iterate on section vertices
+	for (TopoDS_Iterator itv(section); itv.More(); itv.Next()) {
+	  TopoDS_Shape vertex = itv.Value();
+	  // Convert vertex to node
+	  if (myVertexNode.Contains(vertex))
+	    vertex = TopoDS::Vertex(myVertexNode.FindFromKey(vertex));
+	  // Update node sections
+	  if (myNodeSections.IsBound(vertex))
+	    myNodeSections.ChangeFind(vertex).Append(section);
+	  else {
+	    TopTools_ListOfShape lsec;
+	    lsec.Append(section);
+	    myNodeSections.Bind(vertex,lsec);
+	  }
+	}
+	// Store bound for section
+	mySectionBound.Bind(section,bound);
+      }
+      // Store splitted bound
+      myBoundSections.Bind(bound,listSections);
+    }
+  }
+#ifdef DEB
+  cout << "From " << nbBounds << " bounds " << myBoundSections.Extent()
+       << " were cut into " << mySectionBound.Extent() << " sections" << endl;
+#endif
+}
+
+//=======================================================================
+//function : GetSeqEdges
+//purpose  : 
+//=======================================================================
+
+static void GetSeqEdges(const TopoDS_Shape& edge,
+			TopTools_SequenceOfShape& seqEdges,
+			TopTools_DataMapOfShapeListOfShape& VertEdge)
+{
+  Standard_Integer numV = 0;
+  for (TopoDS_Iterator Iv(edge,Standard_False); Iv.More(); Iv.Next()) {
+    TopoDS_Vertex V1 = TopoDS::Vertex(Iv.Value());
+    numV++;
+    if (VertEdge.IsBound(V1)) {
+      const TopTools_ListOfShape& listEdges = VertEdge.Find(V1);
+      for (TopTools_ListIteratorOfListOfShape lIt(listEdges); lIt.More(); lIt.Next()) {
+	TopoDS_Shape edge1 = lIt.Value();
+	if (edge1.IsSame(edge)) continue;
+	Standard_Boolean isContained = Standard_False;
+	Standard_Integer i, index = 1;
+	for (i = 1; i <= seqEdges.Length() && !isContained; i++) {
+	  isContained = seqEdges.Value(i).IsSame(edge1);
+	  if (!isContained && seqEdges.Value(i).IsSame(edge)) index = i;
+	}
+	if (!isContained) {
+	  if (numV == 1) seqEdges.InsertBefore(index,edge1);
+	  else seqEdges.InsertAfter(index,edge1);
+	  GetSeqEdges(edge1,seqEdges,VertEdge);
+	}
+      }
+    }
+  }
+}
+
+//=======================================================================
+//function : GetFreeWires
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::GetFreeWires(TopTools_MapOfShape& MapFreeEdges, TopTools_SequenceOfShape& seqWires)
+{
+  TopTools_DataMapOfShapeListOfShape VertEdge;
+  TopTools_MapIteratorOfMapOfShape itMap(MapFreeEdges);
+  TopTools_SequenceOfShape seqFreeEdges;
+  for (; itMap.More(); itMap.Next()) {
+    TopoDS_Shape edge = itMap.Key();
+    seqFreeEdges.Append(edge);
+    for (TopoDS_Iterator Iv(edge,Standard_False); Iv.More(); Iv.Next()) {
+      TopoDS_Vertex V1 = TopoDS::Vertex(Iv.Value());
+      if (VertEdge.IsBound(V1))
+	VertEdge.ChangeFind(V1).Append(edge);
+      else {
+	TopTools_ListOfShape ls;
+	ls.Append(edge);
+	VertEdge.Bind(V1,ls);
+      }
+    }
+  }
+  BRep_Builder B;
+  Standard_Integer i, j;
+  for (i = 1; i <= seqFreeEdges.Length(); i++) {
+    TopTools_SequenceOfShape seqEdges;
+    TopoDS_Shape edge = seqFreeEdges.Value(i);
+    if (!MapFreeEdges.Contains(edge)) continue;
+    seqEdges.Append(edge);
+    GetSeqEdges(edge,seqEdges,VertEdge);
+    TopoDS_Wire wire;
+    B.MakeWire(wire);
+    for (j = 1; j <= seqEdges.Length(); j++) {
+      B.Add(wire,seqEdges.Value(j));
+      MapFreeEdges.Remove(seqEdges.Value(j));
+    }
+    seqWires.Append(wire);
+    if (MapFreeEdges.IsEmpty()) break;
+  }
+}
+
+//=======================================================================
+//function :  IsDegeneratedWire
+//purpose  :  internal use
+//=======================================================================
+
+static Standard_Boolean IsDegeneratedWire(const TopoDS_Shape& wire)
+{
+  if (wire.ShapeType() != TopAbs_WIRE) return Standard_False;
+  // Get maximal vertices tolerance
+  TopoDS_Vertex V1,V2;
+  //TopExp::Vertices(TopoDS::Wire(wire),V1,V2);
+  //Standard_Real tol = Max(BRep_Tool::Tolerance(V1),BRep_Tool::Tolerance(V2));
+  Standard_Real wireLength = 0.0;
+  TopLoc_Location loc;
+  Standard_Real first, last;
+  Standard_Integer nume = 0;
+  Standard_Integer isSmall = 0;
+  for (TopoDS_Iterator aIt(wire,Standard_False); aIt.More(); aIt.Next()) {
+    nume++;
+    TopoDS_Shape edge = aIt.Value();
+    TopoDS_Vertex Ve1,Ve2;
+    TopExp::Vertices(TopoDS::Edge(edge),Ve1,Ve2);
+    if(nume == 1) {
+       V1 = Ve1;
+       V2 = Ve2;
+    }
+    else {
+      if(Ve1.IsSame(V1))
+         V1 = Ve2;
+      else if(Ve1.IsSame(V2))
+        V2 = Ve2;
+      if(Ve2.IsSame(V1))
+         V1 = Ve1;
+      else if(Ve2.IsSame(V2))
+        V2 = Ve1;
+    }
+    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(aIt.Value()),loc,first,last);
+    if (!c3d.IsNull()) {
+      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+      if (!loc.IsIdentity()) {
+        //c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+	c3d->Transform(loc.Transformation());
+      }
+      gp_Pnt pfirst = c3d->Value(first);
+      gp_Pnt plast = c3d->Value(last);
+      gp_Pnt pmid = c3d->Value((first +last)*0.5);
+      Standard_Real length =0;
+      if(pfirst.Distance(plast) > pfirst.Distance(pmid)) {
+        length = pfirst.Distance(plast);
+      }
+      else {
+        GeomAdaptor_Curve cAdapt(c3d);
+        length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
+      }
+      Standard_Real tole = BRep_Tool::Tolerance(Ve1)+BRep_Tool::Tolerance(Ve2);
+      if(length <= tole) isSmall++;
+      wireLength += length;
+    }
+  }
+  if(isSmall == nume) return Standard_True;
+  Standard_Real tol = BRep_Tool::Tolerance(V1)+BRep_Tool::Tolerance(V2);//Max(BRep_Tool::Tolerance(V1),BRep_Tool::Tolerance(V2));
+  if (wireLength > tol) return Standard_False;
+  return Standard_True;
+}
+
+//=======================================================================
+//function :  DegeneratedSection
+//purpose  :  internal use
+//            create a new degenerated edge if the section is degenerated
+//=======================================================================
+
+static TopoDS_Edge DegeneratedSection(const TopoDS_Shape& section, const TopoDS_Shape& face)
+{
+  // Return if section is already degenerated
+  if (BRep_Tool::Degenerated(TopoDS::Edge(section))) return TopoDS::Edge(section);
+
+  // Retrieve edge curve
+  TopLoc_Location loc;
+  Standard_Real first, last;
+  Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(section), loc, first, last);
+  if (c3d.IsNull()) { //gka
+    BRep_Builder aB;
+    TopoDS_Edge edge1 = TopoDS::Edge(section);
+    aB.Degenerated(edge1, Standard_True);
+    return edge1;
+  }
+  if (!loc.IsIdentity()) {
+    c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+    c3d->Transform(loc.Transformation());
+  }
+
+  // Test if the new edge is degenerated
+  TopoDS_Vertex v1,v2;
+  TopExp::Vertices(TopoDS::Edge(section),v1,v2);
+  //Standard_Real tol = Max(BRep_Tool::Tolerance(v1),BRep_Tool::Tolerance(v2));
+  //tol = Max(tolerance,tol);
+
+  gp_Pnt p1, p2, p3;
+  p1 = BRep_Tool::Pnt(v1);
+  p3 = BRep_Tool::Pnt(v2);
+  c3d->D0(0.5*(first + last),p2);
+
+  //Standard_Boolean isDegenerated = Standard_False;
+  //if (p1.Distance(p3) < tol) {
+    //GeomAdaptor_Curve cAdapt(c3d);
+    //Standard_Real length = GCPnts_AbscissaPoint::Length(cAdapt, first, last);
+    //isDegenerated =  Standard_True; //(length < tol);
+  //}
+
+  TopoDS_Edge edge;
+  //if (!isDegenerated) return edge;
+
+  // processing
+  BRep_Builder aBuilder;
+  edge = TopoDS::Edge(section);
+  edge.EmptyCopy();
+  if (v1.IsSame(v2)) {      
+    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
+    aBuilder.Add(anEdge, v1.Oriented(TopAbs_FORWARD));
+    aBuilder.Add(anEdge, v2.Oriented(TopAbs_REVERSED));
+  }
+  else {
+    TopoDS_Vertex newVertex;
+    if (p1.Distance(p3) < BRep_Tool::Tolerance(v1))
+      newVertex = v1;
+    else if (p1.Distance(p3) < BRep_Tool::Tolerance(v2))
+      newVertex = v2;
+    else {
+      Standard_Real d1 = BRep_Tool::Tolerance(v1) + p2.Distance(p1);
+      Standard_Real d2 = BRep_Tool::Tolerance(v2) + p2.Distance(p3);
+      Standard_Real newTolerance = Max(d1,d2);
+      aBuilder.MakeVertex(newVertex, p2, newTolerance);
+    }
+    TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
+    aBuilder.Add(anEdge, newVertex.Oriented(TopAbs_FORWARD));
+    aBuilder.Add(anEdge, newVertex.Oriented(TopAbs_REVERSED));
+  }
+
+  BRep_Tool::Range(TopoDS::Edge(section), first, last);
+  TopoDS_Shape anEdge = edge.Oriented(TopAbs_FORWARD);
+  aBuilder.Range(TopoDS::Edge(anEdge), first, last);
+  aBuilder.Degenerated(edge, Standard_True);
+  Handle(Geom_Curve) aC3dNew;
+  if (!face.IsNull()) {
+    Standard_Real af,al;
+    Handle(Geom2d_Curve) aC2dt = BRep_Tool::CurveOnSurface(TopoDS::Edge(section),TopoDS::Face(face),af,al);
+    aBuilder.UpdateEdge(edge,aC3dNew,0);
+    Handle(Geom2d_Curve) aC2dn = BRep_Tool::CurveOnSurface(edge,TopoDS::Face(face),af,al);
+    if (aC2dn.IsNull())
+      aBuilder.UpdateEdge(edge,aC2dt,TopoDS::Face(face),0);
+  }
+
+  return edge;
+}
+
+//=======================================================================
+//function : EdgeProcessing
+//purpose  : modifies :
+//                       myNbEdges
+//                       myHasMultipleEdge
+//                       myHasFreeBound
+//           . if multiple edge
+//              - length < 100.*myTolerance -> several free edge
+//           . if no multiple edge
+//              - make the contigous edges sameparameter
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::EdgeProcessing()
+{
+  // constructs sectionEdge
+  TopTools_MapOfShape MapFreeEdges;
+  TopTools_DataMapOfShapeShape EdgeFace;
+  for (Standard_Integer i = 1; i <= myBoundFaces.Extent(); i++) {
+    const TopoDS_Shape& bound = myBoundFaces.FindKey(i);
+    const TopTools_ListOfShape& listFaces = myBoundFaces(i);
+    if (listFaces.Extent() == 1) {
+      if (myBoundSections.IsBound(bound)) {
+	TopTools_ListIteratorOfListOfShape liter(myBoundSections(bound));
+	for (; liter.More(); liter.Next()) {
+	  if (!myMergedEdges.Contains(liter.Value())) { //myReShape->IsRecorded(liter.Value())) {
+	    TopoDS_Shape edge = myReShape->Apply(liter.Value());
+	    if (!MapFreeEdges.Contains(edge)) {
+	      TopoDS_Shape face = listFaces.First();
+	      EdgeFace.Bind(edge,face);
+	      MapFreeEdges.Add(edge);
+	    }
+	  }
+	}
+      }
+      else {
+	if (!myMergedEdges.Contains(bound)) {
+	  TopoDS_Shape edge = myReShape->Apply(bound);
+	  if (!MapFreeEdges.Contains(edge)) {
+	    TopoDS_Shape face = listFaces.First();
+	    EdgeFace.Bind(edge,face);
+	    MapFreeEdges.Add(edge);
+	  }
+	}
+      }
+    }
+  }
+
+  if (!MapFreeEdges.IsEmpty()) {
+    TopTools_SequenceOfShape seqWires;
+    GetFreeWires(MapFreeEdges,seqWires);
+    for (Standard_Integer j = 1; j <= seqWires.Length(); j++) {
+      TopoDS_Wire wire = TopoDS::Wire(seqWires.Value(j));
+      if (!IsDegeneratedWire(wire)) continue;
+      for (TopoDS_Iterator Ie(wire,Standard_False); Ie.More(); Ie.Next()) {
+        TopoDS_Shape aTmpShape = myReShape->Apply(Ie.Value()); //for porting
+	TopoDS_Edge edge = TopoDS::Edge(aTmpShape);
+	TopoDS_Shape face;
+	if (EdgeFace.IsBound(edge))
+	  face = EdgeFace.Find(edge);
+	TopoDS_Shape degedge = DegeneratedSection(edge,face);
+	if (degedge.IsNull()) continue;
+	if (!degedge.IsSame(edge))
+	  ReplaceEdge(edge,degedge,myReShape);
+	if (BRep_Tool::Degenerated(TopoDS::Edge(degedge)))
+	  myDegenerated.Add(degedge);
+      }
+    }
+  }
+  myMergedEdges.Clear();
+}
+
+//=======================================================================
+//function : CreateSewedShape
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::CreateSewedShape()
+{
+  // ---------------------
+  // create the new shapes
+  // ---------------------
+  BRepTools_Quilt aQuilt;
+  Standard_Boolean isLocal = !myShape.IsNull();
+  if (isLocal) {
+    // Local sewing
+    TopoDS_Shape ns = myReShape->Apply(myShape);
+    aQuilt.Add(ns);
+  }
+  Standard_Integer i;
+  for (i = 1; i <= myOldShapes.Extent(); i++) {
+    TopoDS_Shape sh = myOldShapes(i);
+    if (!sh.IsNull()) {
+      sh = myReShape->Apply(sh);
+      myOldShapes(i) = sh;
+      if (!isLocal) aQuilt.Add(sh);
+    }
+  }
+  TopoDS_Shape aNewShape = aQuilt.Shells();
+  Standard_Integer numsh = 0;
+
+  TopTools_IndexedMapOfShape OldShells;
+
+  BRep_Builder aB;
+  TopoDS_Compound aComp;
+  aB.MakeCompound(aComp);
+  for (TopoDS_Iterator aExpSh(aNewShape,Standard_False); aExpSh.More(); aExpSh.Next()) {
+    TopoDS_Shape sh = aExpSh.Value();
+    Standard_Boolean hasEdges = Standard_False;
+    if (sh.ShapeType() == TopAbs_SHELL) {
+      if (myNonmanifold)
+	hasEdges = !OldShells.Contains(sh);
+      else {
+	TopoDS_Shape face;
+	Standard_Integer numf = 0;
+	for (TopExp_Explorer aExpF(sh,TopAbs_FACE); aExpF.More() && (numf < 2); aExpF.Next()) {
+	  face = aExpF.Current();
+	  numf++;
+	}
+	if (numf == 1) aB.Add(aComp,face);
+	else if (numf > 1) aB.Add(aComp,sh);
+	if (numf) numsh++;
+      }
+    }
+    else if (sh.ShapeType() == TopAbs_FACE) {
+      if (myNonmanifold) {
+	TopoDS_Shell ss;
+	aB.MakeShell(ss);
+	aB.Add(ss,sh);
+	sh = ss;
+	hasEdges = Standard_True;
+      }
+      else { aB.Add(aComp,sh); numsh++; }
+    }
+    else { aB.Add(aComp,sh); numsh++; }
+    if (hasEdges) OldShells.Add(sh);
+  }
+  // Process collected shells
+  if (myNonmanifold) {
+    Standard_Integer nbOldShells = OldShells.Extent();
+    if (nbOldShells == 1) {
+      // Single shell - check for single face
+      TopoDS_Shape sh = OldShells.FindKey(1);
+      TopoDS_Shape face;
+      Standard_Integer numf = 0;
+      for (TopExp_Explorer aExpF(sh,TopAbs_FACE); aExpF.More() && (numf < 2); aExpF.Next()) {
+	face = aExpF.Current();
+	numf++;
+      }
+      if (numf == 1) aB.Add(aComp,face);
+      else if (numf > 1) aB.Add(aComp,sh);
+      if (numf) numsh++;
+    }
+    else if (nbOldShells) {
+      // Several shells should be merged
+      TColStd_MapOfInteger IndexMerged;
+      while (IndexMerged.Extent() < nbOldShells) {
+	TopoDS_Shell NewShell;
+	TopTools_MapOfShape NewEdges;
+	for (i = 1; i <= nbOldShells; i++) {
+	  if (IndexMerged.Contains(i)) continue;
+	  TopoDS_Shell shell = TopoDS::Shell(OldShells.FindKey(i));
+	  if (NewShell.IsNull()) {
+            BRep_Builder aB;
+            aB.MakeShell(NewShell);
+            TopoDS_Iterator aItSS(shell) ;
+            for( ; aItSS.More(); aItSS.Next())
+              aB.Add(NewShell,aItSS.Value())
+;
+	    // Fill map of edges
+	    for (TopExp_Explorer eexp(shell,TopAbs_EDGE); eexp.More(); eexp.Next()) {
+	      TopoDS_Shape edge = eexp.Current();
+	      NewEdges.Add(edge);
+	    }
+	    IndexMerged.Add(i);
+	  }
+	  else {
+	    Standard_Boolean hasSharedEdge = Standard_False;
+	    TopExp_Explorer eexp(shell,TopAbs_EDGE);
+	    for (; eexp.More() && !hasSharedEdge; eexp.Next())
+	      hasSharedEdge = NewEdges.Contains(eexp.Current());
+	    if (hasSharedEdge) {
+	      // Add edges to the map
+	      for (TopExp_Explorer eexp1(shell,TopAbs_EDGE); eexp1.More(); eexp1.Next()) {
+		TopoDS_Shape edge = eexp1.Current();
+		NewEdges.Add(edge);
+	      }
+	      // Add faces to the shell
+	      for (TopExp_Explorer fexp(shell,TopAbs_FACE); fexp.More(); fexp.Next()) {
+		TopoDS_Shape face = fexp.Current();
+		aB.Add(NewShell,face);
+	      }
+	      IndexMerged.Add(i);
+	    }
+	  }
+	}
+	// Process new shell
+	TopoDS_Shape face;
+	Standard_Integer numf = 0;
+	TopExp_Explorer aExpF(NewShell,TopAbs_FACE);
+	for (; aExpF.More() && (numf < 2); aExpF.Next()) {
+	  face = aExpF.Current();
+	  numf++;
+	}
+	if (numf == 1) aB.Add(aComp,face);
+	else if (numf > 1) aB.Add(aComp,NewShell);
+	if (numf) numsh++;
+      }
+    }
+  }
+  if (numsh == 1) {
+    // Extract single component
+    TopoDS_Iterator aIt(aComp,Standard_False);
+    mySewedShape = aIt.Value();
+  }
+  else
+    mySewedShape = aComp;
+}
+
+//=======================================================================
+//function : CreateOutputInformations
+//purpose  : constructs :
+//                       myEdgeSections
+//                       mySectionBound
+//                       myNbFreeEdges
+//                       myNbContigousEdges
+//                       myNbMultipleEdges
+//                       myNbDegenerated
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::CreateOutputInformations()
+{
+  // Construct edgeSections
+  Standard_Integer i;
+  //TopTools_DataMapOfShapeListOfShape edgeSections;
+  TopTools_IndexedDataMapOfShapeListOfShape edgeSections; //use index map for regulating free edges
+  for (i = 1; i <= myBoundFaces.Extent(); i++) {
+    const TopoDS_Shape& bound = myBoundFaces.FindKey(i);
+    TopTools_ListOfShape lsect;
+    if (myBoundSections.IsBound(bound)) lsect = myBoundSections(bound);
+    TopExp_Explorer aExp(myReShape->Apply(bound),TopAbs_EDGE);
+    for (; aExp.More(); aExp.Next()) {
+      TopoDS_Shape sec = bound, edge = aExp.Current();
+      TopTools_ListIteratorOfListOfShape aI(lsect);
+      for (; aI.More(); aI.Next()) {
+	const TopoDS_Shape& section = aI.Value();
+	if (edge.IsSame(myReShape->Apply(section))) { sec = section; break; }
+      }
+      if (edgeSections.Contains(edge))
+	 edgeSections.ChangeFromKey(edge).Append(sec);
+      else {
+ 	TopTools_ListOfShape listSec;
+	listSec.Append(sec);
+	edgeSections.Add(edge,listSec);
+      }
+    }
+  }
+
+  // Fill maps of Free, Contigous and Multiple edges
+  //TopTools_DataMapIteratorOfDataMapOfShapeListOfShape iter2(edgeSections);
+  for (i = 1; i <= edgeSections.Extent(); i++) {
+    const TopoDS_Shape& edge = edgeSections.FindKey(i);
+    const TopTools_ListOfShape& listSection = edgeSections(i);
+    if (listSection.Extent() == 1) {
+      if (BRep_Tool::Degenerated(TopoDS::Edge(edge)))
+	myDegenerated.Add(edge);
+      else
+	myFreeEdges.Add(edge);
+    }
+    else if (listSection.Extent() == 2) {
+      myContigousEdges.Add(edge,listSection);
+    }
+    else {
+      myMultipleEdges.Add(edge);
+    }
+  }
+
+  // constructs myContigSectBound
+  TopTools_DataMapOfShapeListOfShape aEdgeMap; //gka
+  for (i = 1; i <= myBoundFaces.Extent(); i++) {
+    TopoDS_Shape bound = myBoundFaces.FindKey(i);
+    if (myBoundSections.IsBound(bound)) {
+      TopTools_ListIteratorOfListOfShape iter(myBoundSections(bound));
+      for (; iter.More(); iter.Next()) {
+	TopoDS_Shape section = iter.Value();
+        if(!myMergedEdges.Contains(section)) continue;
+	//if (!myReShape->IsRecorded(section)) continue; // section is free
+	TopoDS_Shape nedge = myReShape->Apply(section);
+	if (nedge.IsNull()) continue; //szv debug
+	if (!bound.IsSame(section))
+	  if (myContigousEdges.Contains(nedge))
+	    myContigSecBound.Bind(section, bound);
+      }
+    }
+  }
+}
+
+//=======================================================================
+//function : ProjectPointsOnCurve
+//purpose  : internal use
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::ProjectPointsOnCurve(const TColgp_Array1OfPnt& arrPnt,
+					   const Handle(Geom_Curve)& c3d,
+					   const Standard_Real first,
+					   const Standard_Real last,
+					   TColStd_Array1OfReal& arrDist,
+					   TColStd_Array1OfReal& arrPara,
+					   TColgp_Array1OfPnt& arrProj) const
+{
+  arrDist.Init(-1.0);
+
+  GeomAdaptor_Curve GAC(c3d);
+  Extrema_ExtPC locProj;
+  locProj.Initialize(GAC, first, last);
+  gp_Pnt pfirst = GAC.Value(first), plast = GAC.Value(last);
+
+  for (Standard_Integer i1 = 1; i1 <= arrPnt.Length(); i1++) {
+    gp_Pnt pt = arrPnt(i1);
+    Standard_Real worktol = myTolerance;
+    Standard_Real distF = pfirst.Distance(pt);
+    Standard_Real distL = plast.Distance(pt);
+    Standard_Boolean isProjected = Standard_False;
+    try {
+      
+      // Project current point on curve
+      locProj.Perform(pt);
+      if (locProj.IsDone() && locProj.NbExt() > 0) {
+	Standard_Real distMin = Min(distF,distL);
+	Standard_Integer ind, indMin = 0;
+	for (ind = 1; ind <= locProj.NbExt(); ind++) {
+	  Standard_Real dProj = locProj.Value(ind);
+	  if (dProj < distMin) { indMin = ind; distMin = dProj; }
+	}
+	if (indMin) {
+	  isProjected = Standard_True;
+	  Extrema_POnCurv pOnC = locProj.Point(indMin);
+	  Standard_Real paramProj = pOnC.Parameter();
+	  gp_Pnt ptProj = GAC.Value(paramProj);
+	  Standard_Real distProj = ptProj.Distance(pt);
+	  if (!locProj.IsMin(indMin)) {
+	    if (Min(distF,distL) < distMin) {
+	      if (distF < distL) {
+		paramProj = first;
+		distProj = distF;
+		ptProj = pfirst;
+	      }
+	      else {
+		paramProj = last;
+		distProj = distL;
+		ptProj = plast;
+	      }
+	    }
+	  }
+	  if (distProj < worktol) {
+	    arrDist(i1) = distProj;
+	    arrPara(i1) = paramProj;
+	    arrProj(i1) = ptProj;
+	  }
+	}
+      }
+    }
+    catch (Standard_Failure) {
+      worktol = MinTolerance();
+#ifdef DEB
+      cout << "Exception in BRepBuilderAPI_Sewing::ProjectPointsOnCurve: ";
+      Standard_Failure::Caught()->Print(cout); cout << endl;
+#endif
+    }
+    if (!isProjected) {
+      if (Min(distF,distL) < worktol) {
+	if (distF < distL) {
+	  arrDist(i1) = distF;
+	  arrPara(i1) = first;
+	  arrProj(i1) = pfirst;
+	}
+	else {
+	  arrDist(i1) = distL;
+	  arrPara(i1) = last;
+	  arrProj(i1) = plast;
+	}
+      }
+    }
+  }
+}
+
+//=======================================================================
+//function : CreateCuttingNodes
+//purpose  : internal use
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::CreateCuttingNodes(const TopTools_IndexedMapOfShape& MapVert,
+					 const TopoDS_Shape& bound,
+					 const TopoDS_Shape& vfirst,
+					 const TopoDS_Shape& vlast,
+					 const TColStd_Array1OfReal& arrDist,
+					 const TColStd_Array1OfReal& arrPara,
+					 const TColgp_Array1OfPnt& arrPnt,
+					 TopTools_SequenceOfShape& seqVert,
+					 TColStd_SequenceOfReal& seqPara)
+{
+  Standard_Integer i, j, nbProj = MapVert.Extent();
+
+  // Reorder projections by distance
+  TColStd_SequenceOfInteger seqOrderedIndex;
+  { //szv: Use brackets to destroy local variables
+    TColStd_SequenceOfReal seqOrderedDistance;
+    for (i = 1; i <= nbProj; i++) {
+      Standard_Real distProj = arrDist(i);
+      if (distProj < 0.0) continue; // Skip vertex if not projected
+      Standard_Boolean isInserted = Standard_False;
+      for (j = 1; j <= seqOrderedIndex.Length() && !isInserted; j++) {
+	isInserted = (distProj < seqOrderedDistance(j));
+	if (isInserted) {
+	  seqOrderedIndex.InsertBefore(j,i);
+	  seqOrderedDistance.InsertBefore(j,distProj);
+	}
+      }
+      if (!isInserted) {
+	seqOrderedIndex.Append(i);
+	seqOrderedDistance.Append(distProj);
+      }
+    }
+  }
+  nbProj = seqOrderedIndex.Length();
+  if (!nbProj) return;
+
+  BRep_Builder aBuilder;
+
+  // Insert two initial vertices (to be removed later)
+  TColStd_SequenceOfReal seqDist;
+  TColgp_SequenceOfPnt seqPnt;
+  { //szv: Use brackets to destroy local variables
+    // Retrieve bound curve
+    TopLoc_Location loc;
+    Standard_Real first,last;
+    Handle(Geom_Curve) c3d = BRep_Tool::Curve(TopoDS::Edge(bound), loc, first, last);
+    if (!loc.IsIdentity()) {
+      c3d = Handle(Geom_Curve)::DownCast(c3d->Copy());
+      c3d->Transform(loc.Transformation());
+    }
+    GeomAdaptor_Curve GAC(c3d);
+    seqVert.Prepend(vfirst); seqVert.Append(vlast);
+    seqPara.Prepend(first); seqPara.Append(last);
+    seqDist.Prepend(-1.0); seqDist.Append(-1.0);
+    seqPnt.Prepend(GAC.Value(first)); seqPnt.Append(GAC.Value(last));
+  }
+
+  TopTools_DataMapOfShapeShape NodeCuttingVertex;
+  for (i = 1; i <= nbProj; i++) {
+
+    const Standard_Integer index = seqOrderedIndex(i);
+    Standard_Real disProj = arrDist(index);
+    gp_Pnt pntProj = arrPnt(index);
+
+    // Skip node if already bound to cutting vertex
+    TopoDS_Shape node = myVertexNode.FindFromKey(MapVert(index));
+    if (NodeCuttingVertex.IsBound(node)) continue;
+
+    // Find the closest vertex
+    Standard_Integer indexMin = 1;
+    Standard_Real dist, distMin = pntProj.Distance(seqPnt(1));
+    for (j = 2; j <= seqPnt.Length(); j++) {
+      dist = pntProj.Distance(seqPnt(j));
+      if (dist < distMin) { distMin = dist; indexMin = j; }
+    }
+
+    // Check if current point is close to one of the existent
+    if (distMin <= Max(disProj*0.1,MinTolerance())) {
+      // Check distance if close
+      Standard_Real jdist = seqDist.Value(indexMin);
+      if (jdist < 0.0) {
+	// Bind new cutting node (end vertex only)
+	seqDist.SetValue(indexMin,disProj);
+	TopoDS_Shape cvertex = seqVert.Value(indexMin);
+	NodeCuttingVertex.Bind(node,cvertex);
+      }
+      else {
+	// Bind secondary cutting nodes
+	NodeCuttingVertex.Bind(node,TopoDS_Vertex());
+      }
+    }
+    else {
+      // Build new cutting vertex
+      TopoDS_Vertex cvertex;
+      aBuilder.MakeVertex(cvertex, pntProj, Precision::Confusion());
+      // Bind new cutting vertex
+      NodeCuttingVertex.Bind(node,cvertex);
+      // Insert cutting vertex in the sequences
+      Standard_Real parProj = arrPara(index);
+      for (j = 2; j <= seqPara.Length(); j++) {
+	if (parProj <= seqPara.Value(j)) {
+	  seqVert.InsertBefore(j,cvertex);
+	  seqPara.InsertBefore(j,parProj);
+	  seqDist.InsertBefore(j,disProj);
+	  seqPnt.InsertBefore (j,pntProj);
+	  break;
+	}
+      }
+    }
+  }
+
+  // filling map for cutting nodes
+  TopTools_DataMapIteratorOfDataMapOfShapeShape mit(NodeCuttingVertex);
+  for (; mit.More(); mit.Next()) {
+    TopoDS_Shape cnode = mit.Value();
+    // Skip secondary nodes
+    if (cnode.IsNull()) continue;
+    // Obtain vertex node
+    TopoDS_Shape node = mit.Key();
+    if (myVertexNode.Contains(cnode)) {
+      // This is an end vertex
+      cnode = myVertexNode.FindFromKey(cnode);
+    }
+    else {
+      // Create link: cutting vertex -> node
+      TopTools_ListOfShape ls;
+      ls.Append(node);
+      myCuttingNode.Bind(cnode,ls);
+    }
+    // Create link: node -> cutting vertex
+    if (myCuttingNode.IsBound(node)) {
+      myCuttingNode.ChangeFind(node).Append(cnode);
+    }
+    else {
+      TopTools_ListOfShape ls;
+      ls.Append(cnode);
+      myCuttingNode.Bind(node,ls);
+    }
+  }
+
+  // Remove two initial vertices
+  seqVert.Remove(1); seqVert.Remove(seqVert.Length());
+  seqPara.Remove(1); seqPara.Remove(seqPara.Length());
+}
+
+//=======================================================================
+//function : CreateSections
+//purpose  : internal use
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::CreateSections(const TopoDS_Shape& section,
+				     const TopTools_SequenceOfShape& seqNode,
+				     const TColStd_SequenceOfReal& seqPara,
+				     TopTools_ListOfShape& listEdge)
+{
+  const TopoDS_Edge& sec = TopoDS::Edge(section);
+//  TopAbs_Orientation aInitOr = sec.Orientation();
+
+  
+//To keep NM vertices on edge
+  TopTools_SequenceOfShape aSeqNMVert;
+  TColStd_SequenceOfReal aSeqNMPars;
+  Standard_Boolean hasNMVert = findNMVertices(sec,aSeqNMVert,aSeqNMPars);
+  BRep_Builder aBuilder;
+
+  Standard_Real first, last;
+  BRep_Tool::Range(sec, first, last);
+
+  // Create cutting sections
+  Standard_Real par1, par2;
+  TopoDS_Shape V1, V2;
+  Standard_Integer i, len = seqPara.Length() + 1;
+  for (i = 1; i <= len; i++) {
+
+    TopoDS_Edge edge = sec;
+    edge.EmptyCopy();
+
+    if (i == 1) {
+      par1 = first;
+      par2 = seqPara(i);
+      V1 = TopExp::FirstVertex(sec);
+      V2 = seqNode(i);
+    }
+    else if (i == len) {
+      par1 = seqPara(i-1);
+      par2 = last;
+      V1 = seqNode(i-1);
+      V2 = TopExp::LastVertex(sec);
+    }
+    else {
+      par1 = seqPara(i-1);
+      par2 = seqPara(i);
+      V1 = seqNode(i-1);
+      V2 = seqNode(i);
+    }
+
+    TopoDS_Shape aTmpShape = edge.Oriented(TopAbs_FORWARD);
+    TopoDS_Edge aTmpEdge = TopoDS::Edge (aTmpShape); // for porting
+    aTmpShape = V1.Oriented(TopAbs_FORWARD);
+    aBuilder.Add(aTmpEdge, aTmpShape);
+    aTmpShape = V2.Oriented(TopAbs_REVERSED);
+    aBuilder.Add(aTmpEdge, aTmpShape);
+    aBuilder.Range(aTmpEdge, par1, par2);
+//    if(aInitOr == TopAbs_REVERSED)
+//      listEdge.Prepend(edge);
+//    else
+    
+    Standard_Integer k =1;
+    for( ; k <=  aSeqNMPars.Length() ; k++) {
+      Standard_Real apar = aSeqNMPars.Value(k);
+      if(apar >= par1 && apar <= par2) {
+        aBuilder.Add(aTmpEdge,aSeqNMVert.Value(k));
+        aSeqNMVert.Remove(k);
+        aSeqNMPars.Remove(k);
+        k--;
+      }
+     }
+     listEdge.Append(edge);
+  }
+
+  const TopTools_ListOfShape& listFaces = myBoundFaces.FindFromKey(sec);
+  if (!listFaces.Extent()) return;
+
+  Standard_Real tolEdge = BRep_Tool::Tolerance(sec);
+
+  // Add cutting pcurves
+  TopTools_ListIteratorOfListOfShape itf(listFaces);
+  for (; itf.More(); itf.Next()) {
+
+    const TopoDS_Face& fac = TopoDS::Face(itf.Value());
+    
+    // Retrieve curve on surface
+    Standard_Real first2d=0., last2d=0.,first2d1=0,last2d1=0.;
+    Handle(Geom2d_Curve) c2d = BRep_Tool::CurveOnSurface(sec, fac, first2d, last2d);
+    if (c2d.IsNull()) continue;
+    Handle(Geom2d_Curve) c2d1;
+    Standard_Boolean isSeam = BRep_Tool::IsClosed(sec,fac);
+   
+    //gka  - Convert to BSpline was commented because
+    //it is not necessary to create BSpline instead of Lines or cIrcles.
+    //Besides after conversion circles to BSpline
+    //it is necessary to recompute parameters of cutting because paramerization of created
+    //BSpline curve differs from parametrization of circle.
+
+    // Convert pcurve to BSpline
+    /*Handle(Geom2d_BSplineCurve) c2dBSP,c2dBSP1;
+    if (c2d->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
+      c2dBSP = Handle(Geom2d_BSplineCurve)::DownCast(c2d);
+    }
+    else {
+      if (first > (c2d->FirstParameter() + Precision::PConfusion()) ||
+	  last < (c2d->LastParameter() - Precision::PConfusion())) {
+	Handle(Geom2d_TrimmedCurve) TC = new Geom2d_TrimmedCurve(c2d, first, last);
+	c2dBSP = Geom2dConvert::CurveToBSplineCurve(TC);
+      }
+      else c2dBSP = Geom2dConvert::CurveToBSplineCurve(c2d);
+    }
+    if (c2dBSP.IsNull()) continue;*/
+    //gka fix for bug OCC12203 21.04.06 addition second curve for seam edges
+    
+    if(isSeam)
+    {
+      TopoDS_Edge secRev = TopoDS::Edge(sec.Reversed());
+      
+      c2d1 = BRep_Tool::CurveOnSurface(secRev, fac, first2d1, last2d1);
+      if (c2d1.IsNull()) continue;
+    
+      /*if (c2d1->IsKind(STANDARD_TYPE(Geom2d_BSplineCurve))) {
+        c2dBSP1 = Handle(Geom2d_BSplineCurve)::DownCast(c2d1);
+      }
+      else {
+        if (first > (c2d1->FirstParameter() + Precision::PConfusion()) ||
+            last < (c2d1->LastParameter() - Precision::PConfusion())) {
+          Handle(Geom2d_TrimmedCurve) TC = new Geom2d_TrimmedCurve(c2d1, first, last);
+          //c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(TC);
+        }
+        //else c2dBSP1 = Geom2dConvert::CurveToBSplineCurve(c2d);
+      
+      }*/
+    }
+
+    /*first2d = c2dBSP->FirstParameter();
+    last2d = c2dBSP->LastParameter();
+       
+    if(!c2dBSP1.IsNull()) {
+      first2d1 = c2dBSP1->FirstParameter();
+      last2d1 = c2dBSP1->LastParameter();
+    }*/
+      
+    // Update cutting sections
+    Handle(Geom2d_Curve) c2dNew,c2d1New;
+    TopTools_ListIteratorOfListOfShape ite(listEdge);
+    for (; ite.More(); ite.Next()) {
+
+      // Retrieve cutting section
+      const TopoDS_Edge& edge = TopoDS::Edge(ite.Value());
+      BRep_Tool::Range(edge, par1, par2);
+
+      // Cut BSpline pcurve
+     // try {
+        c2dNew = Handle(Geom2d_Curve)::DownCast(c2d->Copy());
+        //c2dNew = Handle(Geom2d_Curve)::DownCast(c2dBSP->Copy());
+	//Handle(Geom2d_BSplineCurve)::DownCast(c2dNew)->Segment(Max(first2d,par1),Min(par2,last2d));
+        if(!c2d1.IsNull()) { //if(!c2dBSP1.IsNull()) {
+          c2d1New = Handle(Geom2d_Curve)::DownCast(c2d1->Copy()); 
+          //c2d1New = Handle(Geom2d_Curve)::DownCast(c2dBSP1->Copy());
+          //Handle(Geom2d_BSplineCurve)::DownCast(c2d1New)->Segment(Max(first2d1,par1),Min(par2,last2d1));
+        }
+      //}
+      /*catch (Standard_Failure) {
+#ifdef DEB
+	cout << "Exception in CreateSections: segment [" << par1 << "," << par2 << "]: ";
+	Standard_Failure::Caught()->Print(cout); cout << endl;
+#endif
+	Handle(Geom2d_TrimmedCurve) c2dT = new Geom2d_TrimmedCurve(c2dNew,Max(first2d,par1),Min(par2,last2d));
+	c2dNew = c2dT;
+      }*/
+              
+
+      if(!isSeam && c2d1New.IsNull())
+        aBuilder.UpdateEdge(edge, c2dNew, fac, tolEdge);
+      else {
+        TopAbs_Orientation Ori = edge.Orientation();
+        if(fac.Orientation() == TopAbs_REVERSED)
+          Ori = TopAbs::Reverse(Ori);
+        
+        if(Ori == TopAbs_FORWARD)
+          aBuilder.UpdateEdge(edge, c2dNew,c2d1New ,fac, tolEdge);
+        else
+          aBuilder.UpdateEdge(edge, c2d1New,c2dNew ,fac, tolEdge);
+      }
+    }
+  }
+}
+		
+//=======================================================================
+//function : SameParameterShape
+//purpose  : 
+//=======================================================================
+
+void BRepBuilderAPI_Sewing::SameParameterShape()
+{
+  if (!mySameParameterMode) return;
+  TopExp_Explorer exp(mySewedShape, TopAbs_EDGE);
+  // Le flag sameparameter est a false pour chaque edge cousue
+  for (; exp.More(); exp.Next()) {
+    const TopoDS_Edge& sec = TopoDS::Edge(exp.Current());
+    try {
+      
+      BRepLib::SameParameter(sec, BRep_Tool::Tolerance(sec));
+    }
+    catch (Standard_Failure) {
+#ifdef DEB
+      cout << "Fail: BRepBuilderAPI_Sewing::SameParameterShape exception in BRepLib::SameParameter" << endl;
+#endif
+      continue;
+    }
+  }
+}
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_CompatibleWires.cxx OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_CompatibleWires.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_CompatibleWires.cxx	2010-07-04 20:15:22.235897711 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_CompatibleWires.cxx	2009-11-09 15:37:12.000000000 +0100
@@ -562,7 +562,38 @@
   }
 }
 
-
+static void BuildConnectedEdges(const TopoDS_Wire& aWire,
+				const TopoDS_Edge& StartEdge,
+				const TopoDS_Vertex& StartVertex,
+				TopTools_ListOfShape& ConnectedEdges)
+{
+  TopTools_IndexedDataMapOfShapeListOfShape MapVE;
+  TopExp::MapShapesAndAncestors(aWire, TopAbs_VERTEX, TopAbs_EDGE, MapVE);
+  TopoDS_Edge CurEdge = StartEdge;
+  TopoDS_Vertex CurVertex = StartVertex;
+  TopoDS_Vertex Origin, V1, V2;
+  TopExp::Vertices(StartEdge, V1, V2);
+  Origin = (V1.IsSame(StartVertex))? V2 : V1;
+
+  for (;;)
+    {
+      TopTools_ListIteratorOfListOfShape itE( MapVE.FindFromKey(CurVertex) );
+      for (; itE.More(); itE.Next())
+	{
+	  TopoDS_Edge anEdge = TopoDS::Edge(itE.Value());
+	  if (!anEdge.IsSame(CurEdge))
+	    {
+	      ConnectedEdges.Append(anEdge);
+	      TopExp::Vertices(anEdge, V1, V2);
+	      CurVertex = (V1.IsSame(CurVertex))? V2 : V1;
+	      CurEdge = anEdge;
+	      break;
+	    }
+	}
+      if (CurVertex.IsSame(Origin))
+	break;
+    }
+}
 				      
 //=======================================================================
 //function : BRepFill_CompatibleWires
@@ -994,34 +1025,32 @@
 
     BRepLib_MakeWire MW;
 
-    for(anExp.Init(wire); anExp.More(); anExp.Next()) {
-      
-      TopoDS_Edge ECur = anExp.Current();
-      TopoDS_Vertex VF,VL;
-      TopExp::Vertices(ECur,VF,VL,Standard_True);
-      Standard_Real U1 = BRep_Tool::Parameter(VF,ECur);
-      Standard_Real U2 = BRep_Tool::Parameter(VL,ECur);
-      BRepAdaptor_Curve Curve(ECur);
-      gp_Pnt PPs = Curve.Value(0.1*(U1+9*U2));
-      TopTools_ListIteratorOfListOfShape itF(MapVLV(VF)),itL(MapVLV(VL));
-      Standard_Integer rang = ideb;
-      while (rang < i) {
-	itF.Next();
-	itL.Next();
-	rang++;
-      }
-      TopoDS_Vertex V1 = TopoDS::Vertex(itF.Value()), 
-                    V2 = TopoDS::Vertex(itL.Value());
-      TopoDS_Edge Esol;
-      Standard_Real scalmax=0.;
-      BRepTools_WireExplorer anExp2;
-  
-      for(anExp2.Init(TopoDS::Wire(myWork(i))); anExp2.More(); anExp2.Next()) {
-
-	TopoDS_Edge E = TopoDS::Edge(anExp2.Current());
+    anExp.Init(wire);
+    TopoDS_Edge ECur = anExp.Current();
+    TopoDS_Vertex VF,VL;
+    TopExp::Vertices(ECur,VF,VL,Standard_True);
+    Standard_Real U1 = BRep_Tool::Parameter(VF,ECur);
+    Standard_Real U2 = BRep_Tool::Parameter(VL,ECur);
+    BRepAdaptor_Curve Curve(ECur);
+    gp_Pnt PPs = Curve.Value(0.1*(U1+9*U2));
+    TopTools_ListIteratorOfListOfShape itF(MapVLV(VF)),itL(MapVLV(VL));
+    Standard_Integer rang = ideb;
+    while (rang < i) {
+      itF.Next();
+      itL.Next();
+      rang++;
+    }
+    TopoDS_Vertex V1 = TopoDS::Vertex(itF.Value()), V2 = TopoDS::Vertex(itL.Value());
+    TopoDS_Edge Esol;
+    Standard_Real scalmax=0.;
+    TopoDS_Iterator itW( myWork(i) );
+    
+    for(; itW.More(); itW.Next())
+      {
+	TopoDS_Edge E = TopoDS::Edge(itW.Value());
 	TopoDS_Vertex VVF,VVL;
 	TopExp::Vertices(E,VVF,VVL,Standard_True);
-
+	
 	// tri des edges candidates
 	Standard_Real scal1,scal2;
 	if ( (V1.IsSame(VVF)&&V2.IsSame(VVL)) || (V2.IsSame(VVF)&&V1.IsSame(VVL)) ) {
@@ -1055,17 +1084,57 @@
 	    scalmax = scal2;
 	    TopoDS_Shape aLocalShape = E.Reversed();
 	    Esol = TopoDS::Edge(aLocalShape);
-//	    Esol = TopoDS::Edge(E.Reversed());
 	  }
-
 	}
-      }
-      MW.Add(Esol);
+      } //end of for(; itW.More(); itW.Next())
+    MW.Add(Esol);
+
+    TopTools_ListOfShape ConnectedEdges;
+    BuildConnectedEdges( TopoDS::Wire(myWork(i)), Esol, V2, ConnectedEdges );
+
+    TopTools_ListIteratorOfListOfShape itCE(ConnectedEdges);
+    for(; anExp.More(), itCE.More(); anExp.Next(), itCE.Next())
+      {
+	ECur = anExp.Current();
+	TopExp::Vertices(ECur,VF,VL,Standard_True);
+	U1 = BRep_Tool::Parameter(VF,ECur);
+	U2 = BRep_Tool::Parameter(VL,ECur);
+	Curve.Initialize(ECur);
+	PPs = Curve.Value(0.1*(U1+9*U2));
 	
-    }
+	TopoDS_Edge E = TopoDS::Edge(itCE.Value());
+	TopoDS_Vertex VVF,VVL;
+	TopExp::Vertices(E,VVF,VVL,Standard_True);
 
+	// tri des edges candidates
+	Standard_Real scal1,scal2;
+	U1 = BRep_Tool::Parameter(VVF,E);
+	U2 = BRep_Tool::Parameter(VVL,E);
+	Curve.Initialize(E);
+	gp_Pnt PP1 = Curve.Value(0.1*(U1+9*U2));
+	gp_Pnt PP2 = Curve.Value(0.1*(9*U1+U2));
+	
+	for (rang=i;rang>ideb;rang--) {
+	  Transform(WithRotation, PP1,
+		    Pos->Value(rang), Axe->Value(rang),
+		    Pos->Value(rang-1), Axe->Value(rang-1), PP1);
+	  Transform(WithRotation, PP2,
+		    Pos->Value(rang), Axe->Value(rang),
+		    Pos->Value(rang-1), Axe->Value(rang-1), PP2);
+	}
+	gp_Vec Ns(Pos->Value(ideb),PPs);
+	Ns = Ns.Normalized();
+	gp_Vec N1(Pos->Value(ideb),PP1);
+	N1 = N1.Normalized();
+	gp_Vec N2(Pos->Value(ideb),PP2);
+	N2 = N2.Normalized();
+	scal1 = N1.Dot(Ns);
+	scal2 = N2.Dot(Ns);
+	if (scal2>scal1)
+	  E.Reverse();
+	MW.Add(E);
+      }
     myWork(i) = MW.Wire();
-
   }
   
   // sections bouclantes ?
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_Sweep.cdl OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cdl
--- OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_Sweep.cdl	2010-07-04 20:15:22.235897711 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cdl	2009-03-03 12:28:00.000000000 +0100
@@ -69,7 +69,7 @@
          Transition : TransitionStyle  =  BRepFill_Modified;    
          Approx     : ApproxStyle = GeomFill_Location; 
          Continuity : Shape  from  GeomAbs   = GeomAbs_C2;
-	 Degmax     : Integer = 10;
+	 Degmax     : Integer = 11;
          Segmax     : Integer = 30); 
 	 
    ---Purpose: Build the Sweeep  Surface
@@ -87,19 +87,16 @@
    --    Segmax     : The maximum number of span in v requiered on 
    --                 the surface.
     
+   CorrectApproxParameters(me:  in  out)
+   returns  Boolean  is  private; 
+   
    BuildWire(me : in  out; 
-         Transition : TransitionStyle;     
-         Approx     : ApproxStyle; 
-         Continuity : Shape  from  GeomAbs;
-	 Degmax,  Segmax  : Integer)   
+             Transition : TransitionStyle)
    returns  Boolean  is  private; 
 	  
    BuildShell(me : in  out;   
             Transition : TransitionStyle;              
             Vf,  Vl    : Integer;    
-            Approx     : ApproxStyle; 
-            Continuity : Shape  from  GeomAbs;
-	    Degmax,  Segmax  : Integer; 
             ExtendFirst :  Real  =  0.0; 
             ExtendLast  :  Real  =  0.0)  
    returns Boolean is  private;
@@ -153,7 +150,11 @@
   myTol2d          :  Real;   
   myTolAngular     :  Real; 
   myAngMin         :  Real; 
-  myAngMax         :  Real;
+  myAngMax         :  Real; 
+  myApproxStyle    :  ApproxStyle from GeomFill; 
+  myContinuity     :  Shape from  GeomAbs; 
+  myDegmax         :  Integer; 
+  mySegmax         :  Integer;
   myShape          :  Shape from  TopoDS; 
   myLoc            :  LocationLaw  from  BRepFill; 
   mySec            :  SectionLaw   from  BRepFill; 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_Sweep.cxx OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BRepFill/BRepFill_Sweep.cxx	2010-07-04 20:15:22.235897711 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepFill/BRepFill_Sweep.cxx	2009-03-03 12:28:00.000000000 +0100
@@ -1667,6 +1667,11 @@
  SetTolerance(1.e-4);
  SetAngularControl();
  myAuxShape.Clear();
+
+ myApproxStyle = GeomFill_Location;
+ myContinuity  = GeomAbs_C2;
+ myDegmax      = 11;
+ mySegmax      = 30;
 }
 
 //=======================================================================
@@ -1734,16 +1739,43 @@
   myAngMax = Min (MaxAngle, 6.28);
 }
 
+///=======================================================================
+//function : CorrectApproxParameters
+//purpose  : 
+//=======================================================================
+ Standard_Boolean BRepFill_Sweep::CorrectApproxParameters()
+{
+  TopoDS_Wire thePath = myLoc->Wire();
+  GeomAbs_Shape    NewCont   = myContinuity;
+  Standard_Integer NewSegmax = mySegmax;
+
+  TopoDS_Iterator iter(thePath);
+  for (; iter.More(); iter.Next())
+    {
+      TopoDS_Edge anEdge = TopoDS::Edge(iter.Value());
+      BRepAdaptor_Curve aBAcurve(anEdge);
+      GeomAbs_Shape aContinuity = aBAcurve.Continuity();
+      Standard_Integer aNbInterv = aBAcurve.NbIntervals(GeomAbs_CN);
+      if (aContinuity < NewCont)
+	NewCont = aContinuity;
+      if (aNbInterv > NewSegmax)
+	NewSegmax = aNbInterv;
+    }
+
+  Standard_Boolean Corrected = Standard_False;
+  if (NewCont != myContinuity || NewSegmax != mySegmax)
+    Corrected = Standard_True;
+  myContinuity = NewCont;
+  mySegmax     = NewSegmax;
+  return Corrected;
+}
+
 //=======================================================================
 //function : BuildWire
 //purpose  : Construit un wire par balayage
 //======================================================================
- Standard_Boolean 
- BRepFill_Sweep::BuildWire(const BRepFill_TransitionStyle Transition,
-			   const GeomFill_ApproxStyle Approx,
-			   const GeomAbs_Shape Continuity,
-			   const Standard_Integer Degmax,
-			   const Standard_Integer Segmax) 
+ Standard_Boolean BRepFill_Sweep::
+ BuildWire(const BRepFill_TransitionStyle Transition)
 {
   Standard_Integer ipath, isec = 1;
   gp_Pnt P1;//, P2;
@@ -1775,7 +1807,7 @@
     // Courbe par iso valeur
     GeomFill_Sweep Sweep(myLoc->Law(ipath), KPart);
     Sweep.SetTolerance(myTol3d, myBoundTol, myTol2d, myTolAngular);
-    Sweep.Build(mySec->Law(isec), Approx, Continuity, Degmax, Segmax);
+    Sweep.Build(mySec->Law(isec), myApproxStyle, myContinuity, myDegmax, mySegmax);
     if (!Sweep.IsDone())  
       return Standard_False;
     S = Sweep.Surface();
@@ -1871,10 +1903,6 @@
  BuildShell(const BRepFill_TransitionStyle Transition,
 	    const Standard_Integer IFirst,
 	    const Standard_Integer ILast,
-	    const GeomFill_ApproxStyle Approx,
-	    const GeomAbs_Shape Continuity,
-	    const Standard_Integer Degmax,
-	    const Standard_Integer Segmax,
 	    const Standard_Real ExtendFirst,
 	    const Standard_Real ExtendLast) 
 {
@@ -1955,7 +1983,7 @@
     }
     
     for(isec=1; isec<=NbLaw; isec++) {
-      Sweep.Build(mySec->Law(isec), Approx, Continuity, Degmax, Segmax);
+      Sweep.Build(mySec->Law(isec), myApproxStyle, myContinuity, myDegmax, mySegmax);
       if (!Sweep.IsDone()) 
 	return Standard_False;
       TabS(isec,ipath) = Sweep.Surface();
@@ -2448,9 +2476,16 @@
 			    const Standard_Integer Degmax,
 			    const Standard_Integer Segmax) 
 {
+  myApproxStyle = Approx;
+  myContinuity  = Continuity;
+  myDegmax = Degmax;
+  mySegmax = Segmax;
+
+  CorrectApproxParameters();
+
   // Wire
-  if (mySec->IsVertex()) isDone = BuildWire(Transition, Approx, Continuity, 
-					    Degmax, Segmax);   
+  if (mySec->IsVertex()) isDone = BuildWire(Transition);
+
   else { // Shell   
     Standard_Integer NbTrous = myLoc->NbHoles(myTol3d),
                      NbPath   = myLoc->NbLaw(),
@@ -2476,8 +2511,7 @@
       if (NbTrous==1)  Extend = EvalExtrapol(1, Transition);
       isDone = BuildShell(Transition, 
 			  1, NbPath+1,
-			  Approx, Continuity, 
-			  Degmax, Segmax, Extend, Extend);
+			  Extend, Extend);
     }
     else { //  On le fait bout par bout
       Standard_Integer IFirst = 1, ILast;
@@ -2487,8 +2521,6 @@
 	else ILast = Trous->Value(ii);
 	isDone = BuildShell(Transition, 
 			    IFirst, ILast,
-			    Approx, Continuity, 
-			    Degmax, Segmax,
 			    EvalExtrapol(IFirst, Transition),
 			    EvalExtrapol(ILast,  Transition));
 	if (IFirst>1) {
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepMesh/BRepMesh_FastDiscret.cdl OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl
--- OpenCASCADE6.3.0.orig//ros/src/BRepMesh/BRepMesh_FastDiscret.cdl	2010-07-04 20:15:22.272647140 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cdl	2008-11-25 15:37:31.000000000 +0100
@@ -145,16 +145,6 @@
     	returns Boolean;
 	
 
-    	InternalVerticesForRectangle
-    	       (me         : mutable;
-	       	caro       : HSurface            from BRepAdaptor;
-    	    	inter      : in out ListOfVertex from BRepMesh;
-    	        u1pars     : ListOfReal  from  TColStd;
-    	        u2pars     : ListOfReal  from  TColStd;
-    	        v1pars     : ListOfReal  from  TColStd;
-    	        v2pars     : ListOfReal  from  TColStd)
-	is static private;
- 
     	InternalVertices
     	       (me         : mutable;
 	       	caro       : HSurface            from BRepAdaptor;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/BRepMesh/BRepMesh_FastDiscret.cxx OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx
--- OpenCASCADE6.3.0.orig//ros/src/BRepMesh/BRepMesh_FastDiscret.cxx	2010-07-04 20:15:22.272647140 +0200
+++ OpenCASCADE6.3.0/ros/src/BRepMesh/BRepMesh_FastDiscret.cxx	2010-03-24 14:40:54.000000000 +0100
@@ -280,6 +280,7 @@
   TopTools_SequenceOfShape aShSeq;
 
   TopoDS_Iterator exW(face);
+
   for (; exW.More(); exW.Next()) {
     const TopoDS_Shape& aWire = exW.Value();
     if (aWire.ShapeType() != TopAbs_WIRE)
@@ -623,39 +624,14 @@
     myUParam.Clear(); myVParam.Clear();
   
     BRepMesh_IDMapOfNodeOfDataStructureOfDelaun aMoveNodes(myvemap.Extent());
-    //cout << "UVparam" << endl;
-    Standard_Real eps = Precision::PConfusion();
-    Standard_Integer nbu1 = 0, nbu2 = 0, nbv1 = 0, nbv2 = 0, nbtot = 0;
-    Standard_Boolean IsRectangle = Standard_False;
-    TColStd_ListOfReal U1Params, U2Params, V1Params, V2Params;
 
     for (i = 1; i <= structure->NbNodes(); i++)
     {
       const BRepMesh_Vertex& v = structure->GetNode(i);
       p2d = v.Coord();
       if (useUVParam) {
-	//cout << p2d.X() << " " << p2d.Y() << endl;
-	Standard_Real u = p2d.X(), v = p2d.Y();
-        myUParam.Add(u);
-        myVParam.Add(v);
-
-	++nbtot;
-	if(Abs(u - myumin) <= eps) {
-	  ++nbu1;
-	  V1Params.Append(v);
-	}
-	if(Abs(u - myumax) <= eps) {
-	  ++nbu2;
-	  V2Params.Append(v);
-	}
-	if(Abs(v - myvmin) <= eps) {
-	  ++nbv1;
-	  U1Params.Append(u);
-	}
-	if(Abs(v - myvmax) <= eps) {
-	  ++nbv2;
-	  U2Params.Append(u);
-	}
+        myUParam.Add(p2d.X());
+        myVParam.Add(p2d.Y());
       }
       gp_XY res;
       res.SetCoord((p2d.X()-minX)/deltaX,(p2d.Y()-minY)/deltaY);
@@ -666,12 +642,6 @@
     }    
     structure->ReplaceNodes(aMoveNodes);
     
-    if(useUVParam) {
-      Standard_Integer nb = nbu1 + nbu2 + nbv1 + nbv2 - 4;
-      if((nbu1 == nbu2) && (nbv1 == nbv2) && (nbtot == nb)) IsRectangle = Standard_True;
-    }
-
-
     Standard_Boolean rajout;
 
      switch (thetype)
@@ -719,14 +689,9 @@
       }
 
       if(rajout){
-	if(IsRectangle) {
-	  InternalVerticesForRectangle(gFace, mylistver, U1Params, U2Params, V1Params, V2Params);
-	}
-	else {
-	  InternalVertices(gFace, mylistver, defface,*classifier);
-	}
+        InternalVertices(gFace, mylistver, defface,*classifier);
 
-        if (mylistver.Extent() > 0) {
+      if (mylistver.Extent() > 0) {
 	  BRepMesh_Array1OfVertexOfDelaun verttab(1, mylistver.Extent());
 	  BRepMesh_ListIteratorOfListOfVertex itVer(mylistver);
 	  ipn = 1;
@@ -1909,78 +1874,73 @@
 
     // Sort sequence of U parameters
     TColStd_SequenceOfReal ParamU;
-    ParamU.Append(myumin); ParamU.Append(myumax);
-    Standard_Integer ParamULength = 2;
+    Standard_Integer ParamULength = 1;
     const Standard_Integer LenU = myUParam.Extent();
-    const Standard_Real ddu = 0.02*(myumax-myumin);
+
+    Standard_Real ddu = caro->UResolution(defface);
     
     Standard_Real U1, U2;
 
+    TColStd_Array1OfReal uprs(1, LenU);
     for (j = 1; j <= LenU; j++)
     {
-      pp = myUParam(j);
+      uprs(j) = myUParam(j);
+    }
+    SortTools_ShellSortOfReal aSorter;
+    TCollection_CompareOfReal aCompare;
+    aSorter.Sort(uprs, aCompare);
 
-      U1 = ParamU.Value(1);
-      for (i = 2; i <= ParamULength; i++)
+    U1 = uprs(1);
+    ParamU.Append(U1);
+    for (j = 2; j <= LenU; j++)
+    {
+      U2 = uprs(j);
+      if ((U2-U1) > ddu)
       {
-	U2 = ParamU.Value(i);
-	if (pp < U2)
-        {
-	  if ((U2-pp) < ddu)
-          {
-	    ParamU(i) = pp;
-	  }
-	  else if ((pp-U1) > ddu)
-          {
-	    ParamU.InsertBefore(i, pp);
-	    ParamULength++;
-	  }
-	  else if (i != 2)
-          {
-	    ParamU(i-1) = pp;
-	  }
-	  break;
-	}
+        ParamU.Append(U2);
         U1 = U2;
+        ParamULength++;
       }
     }
-    
+    if(uprs(LenU)-ParamU(ParamULength)>Precision::Confusion())
+    {
+      ParamU.Append(uprs(LenU));        
+      ParamULength++;
+    }
+
     // Sort sequence of V parameters
     TColStd_SequenceOfReal ParamV;
-    ParamV.Append(myvmin); ParamV.Append(myvmax);
-    Standard_Integer ParamVLength = 2;
+    Standard_Integer ParamVLength = 1;
     const Standard_Integer LenV = myVParam.Extent();
-    const Standard_Real ddv = 0.02*(myvmax-myvmin);
+
+    Standard_Real ddv = caro->VResolution(defface);
 
     Standard_Real V1, V2;
+
+    TColStd_Array1OfReal vprs(1, LenV);
     for (j = 1; j <= LenV; j++)
     {
-      pp = myVParam(j);
+      vprs(j) = myVParam(j);
+    }
+    aSorter.Sort(vprs, aCompare);
 
-      V1 = ParamV.Value(1);
-      for (i = 2; i <= ParamVLength; i++)
+    V1 = vprs(1);
+    ParamV.Append(V1);
+    for (j = 2; j <= LenV; j++)
+    {
+      V2 = vprs(j);
+      if ((V2-V1) > ddv)
       {
-	V2 = ParamV.Value(i);
-	if (pp < V2)
-        {
-	  if ((V2-pp) < ddv)
-          {
-	    ParamV(i) = pp;
-	  }
-	  else if ((pp-V1) > ddv)
-          {
-	    ParamV.InsertBefore(i, pp);
-	    ParamVLength++;
-	  }
-	  else if (i != 2)
-          {
-	    ParamV(i-1) = pp;
-	  }
-	  break;
-	}
+        ParamV.Append(V2);
         V1 = V2;
+        ParamVLength++;
       }
     }
+    if(vprs(LenV)-ParamV(ParamVLength)>Precision::Confusion())
+    {
+      ParamV.Append(vprs(LenV));        
+      ParamVLength++;
+    }
 
     // controle des isos U et insertion eventuelle:
 
@@ -1995,6 +1955,9 @@
     gp_Pnt P1, P2, PControl;
     Standard_Real u, v, dist;
 
+    // precision for compare square distances
+    double dPreci = Precision::Confusion()*Precision::Confusion();
+
     // Insert V parameters by deflection criterion
     for (i = 1; i <= ParamULength; i++)
     {
@@ -2007,7 +1970,7 @@
 	P2 = IsoU->Value(V2);
 	v = 0.5*(V1+V2);
 	PControl = IsoU->Value(v);
-	if (P1.SquareDistance(P2) > 1.e-5)
+	if (P1.SquareDistance(P2) > dPreci)
         {
 	  gp_Lin L (P1, gp_Dir(gp_Vec(P1, P2)));
 	  dist = L.Distance(PControl);
@@ -2043,7 +2006,7 @@
 	P2 = IsoV->Value(U2);
 	u = 0.5*(U1+U2);
 	PControl = IsoV->Value(u);
-	if (P1.SquareDistance(P2) > 1.e-5)
+	if (P1.SquareDistance(P2) > dPreci)
         {
 	  gp_Lin L (P1, gp_Dir(gp_Vec(P1, P2)));
 	  dist = L.Distance(PControl);
@@ -2192,84 +2155,6 @@
 }
 
 //=======================================================================
-//function : InternalVerticesForRectangle
-//purpose  : 
-//=======================================================================
-void BRepMesh_FastDiscret::
-  InternalVerticesForRectangle(const Handle(BRepAdaptor_HSurface)& caro,
-			       BRepMesh_ListOfVertex&              InternalV,
-			       const TColStd_ListOfReal&           U1Params,
-			       const TColStd_ListOfReal&           U2Params,
-			       const TColStd_ListOfReal&           V1Params,
-			       const TColStd_ListOfReal&           V2Params)
-{
-  BRepMesh_Vertex newV;
-  gp_XY p2d;
-  gp_Pnt p3d;
-
-
-  Standard_Integer i, j, nbu = U1Params.Extent(), 
-                         nbv = V1Params.Extent();
-  TColStd_Array1OfReal u1prs(1, nbu), u2prs(1, nbu), 
-                       v1prs(1, nbv), v2prs(1,nbv);
-  TColStd_ListIteratorOfListOfReal Itu1(U1Params), Itu2(U2Params), 
-                                   Itv1(V1Params), Itv2(V2Params);
-  for(i = 1; Itu1.More(); Itu1.Next(), Itu2.Next(),++i) {
-    u1prs(i) = Itu1.Value();
-    u2prs(i) = Itu2.Value();
-  }
-  for(i = 1; Itv1.More(); Itv1.Next(), Itv2.Next(),++i) {
-    v1prs(i) = Itv1.Value();
-    v2prs(i) = Itv2.Value();
-  }
-  
-  SortTools_ShellSortOfReal aSorter;
-  TCollection_CompareOfReal aCompare;
-  aSorter.Sort(u1prs, aCompare);
-  aSorter.Sort(u2prs, aCompare);
-  aSorter.Sort(v1prs, aCompare);
-  aSorter.Sort(v2prs, aCompare);
-
-  gp_XY f00(u1prs(1), v1prs(1));
-  gp_XY f01(u2prs(1), v1prs(nbv));
-  gp_XY f10(u1prs(nbu), v2prs(1));
-  gp_XY f11(u2prs(nbu), v2prs(nbv));
-
-  Standard_Real cu = 1./(nbu-1), cv = 1./(nbv-1);
-
-  //Linear Coons-Gordon interpolation for inner points
-  Standard_Real x, y, x1, y1;
-  for(i = 2, x = cu; i < nbu; ++i, x += cu) {
-    x1 = 1.-x;
-    gp_XY fx0(u1prs(i), v1prs(1));
-    gp_XY fx1(u2prs(i), v1prs(nbv));
- 
-    for(j = 2, y = cv; j < nbv; ++j, y += cv) {
-      y1 = 1.-y;
-
-      gp_XY f0y(u1prs(1), v1prs(j));
-      gp_XY f1y(u1prs(nbu), v2prs(j));
-		
-      gp_XY fxy = y1*fx0 + y*fx1 + x1*f0y + x*f1y -
-                  (x1*(y1*f00 + y*f01) + x*(y1*f10 + y*f11));
-
-      // Record 3d point
-      BRepMesh_GeomTool::D0(caro, fxy.X(), fxy.Y(), p3d);
-      nbLocat++;
-      Location3d.Bind(nbLocat, p3d);
-      // Record 2d point
-      p2d.SetCoord((fxy.X()-myumin)/deltaX, (fxy.Y()-myvmin)/deltaY);
-      newV.Initialize(p2d, nbDomains, nbLocat, MeshDS_Free);
-      InternalV.Append(newV);
-    }
-  }
-      
-
-
-}
-
-
-//=======================================================================
 //function : Control
 //purpose  : 
 //=======================================================================
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Extrema/Extrema_ExtPElC.cxx OpenCASCADE6.3.0/ros/src/Extrema/Extrema_ExtPElC.cxx
--- OpenCASCADE6.3.0.orig//ros/src/Extrema/Extrema_ExtPElC.cxx	2010-07-04 20:15:42.229236841 +0200
+++ OpenCASCADE6.3.0/ros/src/Extrema/Extrema_ExtPElC.cxx	2009-02-17 06:00:14.000000000 +0100
@@ -107,15 +107,13 @@
   Usol[1] = Usol[0] + PI;
 
   Standard_Real myuinf = Uinf;
-  //modified by NIZNHY-PKV Fri Apr 20 15:03:28 2001 f
-  //Standard_Real TolU = Tol*C.Radius();
   Standard_Real TolU, aR;
   aR=C.Radius();
   TolU=Precision::Infinite();
   if (aR > gp::Resolution()) {
     TolU= Tol/aR;
   }
-  //modified by NIZNHY-PKV Fri Apr 20 15:03:32 2001 t
+  //
   ElCLib::AdjustPeriodic(Uinf, Uinf+2*PI, Precision::PConfusion(), myuinf, Usol[0]);
   ElCLib::AdjustPeriodic(Uinf, Uinf+2*PI, Precision::PConfusion(), myuinf, Usol[1]);
   if (((Usol[0]-2*PI-Uinf) < TolU) && ((Usol[0]-2*PI-Uinf) > -TolU)) Usol[0] = Uinf;
@@ -140,6 +138,10 @@
 }
 //=============================================================================
 
+//=======================================================================
+//function : Extrema_ExtPElC
+//purpose  : 
+//=======================================================================
 Extrema_ExtPElC::Extrema_ExtPElC (const gp_Pnt&       P,
 				  const gp_Elips&     C,
 				  const Standard_Real Tol,
@@ -151,6 +153,10 @@
 
 
 
+//=======================================================================
+//function : Perform
+//purpose  : 
+//=======================================================================
 void Extrema_ExtPElC::Perform (const gp_Pnt&       P, 
 			       const gp_Elips&     C,
 			       const Standard_Real Tol,
@@ -176,31 +182,57 @@
     cette equation.
 -----------------------------------------------------------------------------*/
 {
+  Standard_Integer NoSol, NbSol;
+  Standard_Real A, B, OPpMagn, aTx, aD2x, aTol2;
+  gp_Pnt aPx;
+  //
   myDone = Standard_False;
   myNbExt = 0;
-
-// 1- Projection du point P dans le plan de l ellipse -> Pp ...
-
+  //
+  aTol2=Tol*Tol;
+  //
+  // 0-
+  //modified by NIZNHY-PKV Fri Feb 13 09:37:33 2009f
+  aTx=ElCLib::Parameter(C, P);
+  aPx=ElCLib::Value(aTx, C);
+  aD2x=P.SquareDistance(aPx);
+  if (aD2x < aTol2) {
+    myDone = Standard_True;
+    myValue[myNbExt]=sqrt(aD2x);
+    myIsMin[myNbExt]=Standard_True;
+    myPoint[myNbExt]=Extrema_POnCurv(aTx ,aPx);
+    myNbExt=1;
+    return;
+  }
+  //modified by NIZNHY-PKV Fri Feb 13 09:37:37 2009t
+  //
+  // 1- Projection du point P dans le plan de l ellipse -> Pp ...
   gp_Pnt O = C.Location();
   gp_Vec Axe (C.Axis().Direction());
   gp_Vec Trsl = Axe.Multiplied(-(gp_Vec(O,P).Dot(Axe)));
   gp_Pnt Pp = P.Translated(Trsl);
-
-// 2- Calculs des solutions ...
-
-  Standard_Integer NoSol, NbSol;
-  Standard_Real A = C.MajorRadius();
-  Standard_Real B = C.MinorRadius();
+  //
+  // 2- Calculs des solutions ...
+  
+  //
+  A = C.MajorRadius();
+  B = C.MinorRadius();
+  
   gp_Vec OPp (O,Pp);
-  Standard_Real OPpMagn = OPp.Magnitude();
-  if (OPpMagn < Tol) { if (Abs(A-B) < Tol) { return; } }
+  OPpMagn = OPp.SquareMagnitude();
+  if (OPpMagn < aTol2) { 
+    if (Abs(A-B) < Tol) { 
+      return; 
+    } 
+  }
   Standard_Real X = OPp.Dot(gp_Vec(C.XAxis().Direction()));
   Standard_Real Y = OPp.Dot(gp_Vec(C.YAxis().Direction()));
   //  Standard_Real Y = Sqrt(OPpMagn*OPpMagn-X*X);
 
   Standard_Real ko2 = (B*B-A*A)/2., ko3 = -B*Y, ko4 = A*X;
-  if(Abs(ko3) < 1.e-16*Max(Abs(ko2), Abs(ko3))) ko3 = 0.0;
-
+  if(Abs(ko3) < 1.e-16*Max(Abs(ko2), Abs(ko3))) {
+    ko3 = 0.;
+  }
 //  math_TrigonometricFunctionRoots Sol(0.,(B*B-A*A)/2.,-B*Y,A*X,0.,Uinf,Usup);
   math_TrigonometricFunctionRoots Sol(0.,ko2, ko3, ko4, 0.,Uinf,Usup);
 
@@ -313,10 +345,7 @@
 	if (!DejaEnr) {
 	  TbExt[myNbExt] = Cu;
 	  myValue[myNbExt] = Cu.Distance(P);
-//  modified by NIZHNY-EAP Fri Oct 29 12:53:37 1999 ___BEGIN___
-//	  myIsMin[myNbExt] = (NoSol == 0);
 	  myIsMin[myNbExt] = myValue[myNbExt] < P.Distance(ElCLib::Value(Us+1,C));
-//  modified by NIZHNY-EAP Fri Oct 29 12:53:39 1999 ___END___
 	  myPoint[myNbExt] = Extrema_POnCurv(Us,Cu);
 	  myNbExt++;
 	}
@@ -407,10 +436,7 @@
       if (!DejaEnr) {
 	TbExt[myNbExt] = Cu;
 	myValue[myNbExt] = Cu.Distance(P);
-//  modified by NIZHNY-EAP Fri Oct 29 12:55:16 1999 ___BEGIN___
-//	myIsMin[myNbExt] = (NoSol == 0);
 	myIsMin[myNbExt] = myValue[myNbExt] < P.Distance(ElCLib::Value(Us+1,C));
-//  modified by NIZHNY-EAP Fri Oct 29 12:55:18 1999 ___END___
 	myPoint[myNbExt] = Extrema_POnCurv(Us,Cu);
 	myNbExt++;
       }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/GeomAPI/GeomAPI_ProjectPointOnCurve.cxx OpenCASCADE6.3.0/ros/src/GeomAPI/GeomAPI_ProjectPointOnCurve.cxx
--- OpenCASCADE6.3.0.orig//ros/src/GeomAPI/GeomAPI_ProjectPointOnCurve.cxx	2010-07-04 20:15:43.072579044 +0200
+++ OpenCASCADE6.3.0/ros/src/GeomAPI/GeomAPI_ProjectPointOnCurve.cxx	2009-11-11 11:34:27.000000000 +0100
@@ -48,10 +48,12 @@
    const Handle(Geom_Curve)& Curve)
 {
   myC.Load(Curve);
-
+/*
   Extrema_ExtPC theExtPC(P, myC);
-  
   myExtPC = theExtPC;
+*/  
+  myExtPC.Initialize(myC, myC.FirstParameter(), myC.LastParameter());
+  myExtPC.Perform(P);
   
   myIsDone = myExtPC.IsDone() && ( myExtPC.NbExt() > 0);
 
@@ -81,8 +83,12 @@
 					 const Standard_Real       Usup )
 {
   myC.Load(Curve,Umin,Usup);
+/*
   Extrema_ExtPC theExtPC(P, myC);
   myExtPC = theExtPC;
+*/
+  myExtPC.Initialize(myC, myC.FirstParameter(), myC.LastParameter());
+  myExtPC.Perform(P);
   
   myIsDone = myExtPC.IsDone() && ( myExtPC.NbExt() > 0);
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/GeomFill/GeomFill_NSections.cxx OpenCASCADE6.3.0/ros/src/GeomFill/GeomFill_NSections.cxx
--- OpenCASCADE6.3.0.orig//ros/src/GeomFill/GeomFill_NSections.cxx	2010-07-04 20:15:18.536327936 +0200
+++ OpenCASCADE6.3.0/ros/src/GeomFill/GeomFill_NSections.cxx	2009-03-03 12:28:38.000000000 +0100
@@ -942,6 +942,12 @@
         sameaxis = (C1.Axis().IsParallel(D,1.e-4));
       }
       isconic = samedir && linearrad && sameaxis;
+      //// Modified by jgv, 18.02.2009 for OCC20866 ////
+      Standard_Real first1 = AC1.FirstParameter(), last1 = AC1.LastParameter();
+      Standard_Real first2 = AC2.FirstParameter(), last2 = AC2.LastParameter();
+      isconic = (Abs(first1-first2) <= Precision::PConfusion() &&
+		 Abs(last1-last2)   <= Precision::PConfusion());
+      //////////////////////////////////////////////////
     }
   }
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Graphic3d/Graphic3d_GraphicDevice.cxx OpenCASCADE6.3.0/ros/src/Graphic3d/Graphic3d_GraphicDevice.cxx
--- OpenCASCADE6.3.0.orig//ros/src/Graphic3d/Graphic3d_GraphicDevice.cxx	2010-07-04 20:15:22.799660781 +0200
+++ OpenCASCADE6.3.0/ros/src/Graphic3d/Graphic3d_GraphicDevice.cxx	2009-08-19 13:21:06.000000000 +0200
@@ -32,6 +32,7 @@
 #include <Graphic3d_GraphicDevice.ixx>
 #include <Graphic3d_GraphicDriver.hxx>
 #include <OSD_Function.hxx>
+#include <TCollection_AsciiString.hxx>
 
 #include <Xw_Cextern.hxx>
 
@@ -196,7 +197,7 @@
 
   char *glso, *glul, *pkno;
   char *glshr, *casroot;
- 
+
   casroot = getenv("CASROOT");
   glso = getenv("CSF_GraphicShr");
   glul = getenv("GRAPHICHOME");
@@ -205,24 +206,22 @@
   if (! BAD(glso)) {
     glshr = getenv("CSF_GraphicShr");
   } else if (! BAD(casroot)) {
-    glshr = (char *) malloc (128);
-    /* Pour faire plaisir a Purify */
-    glshr[0] = '\0';
-    strcat(glshr, casroot);
+    TCollection_AsciiString buffString(casroot);
     struct utsname info; 
     uname (&info);
-    strcat(glshr,"/");
-    strcat(glshr,info.sysname);   
+    buffString = buffString + "/";
+    buffString = buffString + info.sysname;
 #if defined(__hpux) || defined(HPUX)
-    strcat (glshr, "/lib/libTKOpenGl.sl");
+    buffString = buffString + "/lib/libTKOpenGl.sl";
 #elif defined(WNT)
-    strcat (glshr, "/TKOpenGl.dll");
+    buffString = buffString + "/TKOpenGl.dll";
 #elif defined(__APPLE__)
-    strcat (glshr, "/lib/libTKOpenGl.dylib");
+    buffString = buffString + "/lib/libTKOpenGl.dylib";
 #else
-    strcat (glshr, "/lib/libTKOpenGl.so");
+    buffString = buffString + "/lib/libTKOpenGl.so";
 #endif
-//    printf("You have not defined CSF_GraphicShr, defaulting to %s",glshr);
+    glshr = (char *) malloc (buffString.Length() + 1);
+    memcpy(glshr, buffString.ToCString(), buffString.Length() + 1);
   } else {
     aShr = NULL;
     printf("You have not defined CSF_GraphicShr or CASROOT, aborting...");
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Graphic3d/Graphic3d_Structure.cxx OpenCASCADE6.3.0/ros/src/Graphic3d/Graphic3d_Structure.cxx
--- OpenCASCADE6.3.0.orig//ros/src/Graphic3d/Graphic3d_Structure.cxx	2010-07-04 20:15:22.832997816 +0200
+++ OpenCASCADE6.3.0/ros/src/Graphic3d/Graphic3d_Structure.cxx	2010-02-17 16:51:22.000000000 +0100
@@ -1713,81 +1713,68 @@
 
 void Graphic3d_Structure::MinMaxValues (Standard_Real& XMin, Standard_Real& YMin, Standard_Real& ZMin, Standard_Real& XMax, Standard_Real& YMax, Standard_Real& ZMax) const {
 
-Standard_Real RL        = RealLast ();
-Standard_Real RF        = RealFirst ();
+  Standard_Real RL = RealLast ();
+  Standard_Real RF = RealFirst ();
 
-Standard_Real XTMin, YTMin, ZTMin, XTMax, YTMax, ZTMax, U, V, W;
-
-        if (IsEmpty () || IsInfinite ()) {
-                XMin    = RF;
-                YMin    = RF;
-                ZMin    = RF;
-
-                XMax    = RL;
-                YMax    = RL;
-                ZMax    = RL;
-        }
-        else {
-                MinMaxCoord (XTMin, YTMin, ZTMin, XTMax, YTMax, ZTMax);
-                if ((XTMin == RF) && (YTMin == RF) &&
-                    (ZTMin == RF) && (XTMax == RL) &&
-                    (YTMax == RL) && (ZTMax == RL)) {
-                        // Cas impossible car cela voudrait dire
-                        // que la structure est vide
-                        XMin    = RF;
-                        YMin    = RF;
-                        ZMin    = RF;
-
-                        XMax    = RL;
-                        YMax    = RL;
-                        ZMax    = RL;
-                }
-                else {
-Standard_Integer i, j;
-TColStd_Array2OfReal TheTrsf (0, 3, 0, 3);
-
-                    for (i=0; i<=3; i++)
-                        for (j=0; j<=3; j++)
-                            TheTrsf (i, j) = MyCStructure.Transformation[i][j];
-
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMin, YTMin, ZTMin, XMin, YMin, ZMin);
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMax, YTMax, ZTMax, XMax, YMax, ZMax);
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMin, YTMin, ZTMax, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMax, YTMin, ZTMax, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMax, YTMin, ZTMin, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMax, YTMax, ZTMin, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMin, YTMax, ZTMax, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                    Graphic3d_Structure::Transforms
-                        (TheTrsf, XTMin, YTMax, ZTMin, U, V, W);
-                    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
-                    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
-                    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
-                }
-
-        }
+  Standard_Real XTMin, YTMin, ZTMin, XTMax, YTMax, ZTMax, U, V, W;
 
+  MinMaxCoord (XTMin, YTMin, ZTMin, XTMax, YTMax, ZTMax);
+  if ((XTMin == RF) && (YTMin == RF) &&
+      (ZTMin == RF) && (XTMax == RL) &&
+      (YTMax == RL) && (ZTMax == RL)) {
+      // Cas impossible car cela voudrait dire
+      // que la structure est vide
+      XMin = RF; 
+      YMin = RF; 
+      ZMin = RF;
+      
+      XMax = RL;
+      YMax = RL;
+      ZMax = RL;
+    }
+  else {
+    Standard_Integer i, j;
+    TColStd_Array2OfReal TheTrsf (0, 3, 0, 3);
+
+    for (i=0; i<=3; i++)
+      for (j=0; j<=3; j++)
+        TheTrsf (i, j) = MyCStructure.Transformation[i][j];
+
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMin, YTMin, ZTMin, XMin, YMin, ZMin);
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMax, YTMax, ZTMax, XMax, YMax, ZMax);
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMin, YTMin, ZTMax, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMax, YTMin, ZTMax, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMax, YTMin, ZTMin, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMax, YTMax, ZTMin, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMin, YTMax, ZTMax, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+    Graphic3d_Structure::Transforms
+      (TheTrsf, XTMin, YTMax, ZTMin, U, V, W);
+    XMin = Min(U,XMin) ; XMax = Max(U,XMax) ;
+    YMin = Min(V,YMin) ; YMax = Max(V,YMax) ;
+    ZMin = Min(W,ZMin) ; ZMax = Max(W,ZMax) ;
+  }
 }
 
 void Graphic3d_Structure::GroupLabels (Standard_Integer& LB, Standard_Integer& LE) {
@@ -1952,76 +1939,89 @@
 
 void Graphic3d_Structure::MinMaxCoord (Standard_Real& XMin, Standard_Real& YMin, Standard_Real& ZMin, Standard_Real& XMax, Standard_Real& YMax, Standard_Real& ZMax) const {
 
-Standard_Real RL        = RealLast ();
-Standard_Real RF        = RealFirst ();
+  Standard_Real RL = RealLast ();
+  Standard_Real RF = RealFirst ();
 
-Standard_Real Xm, Ym, Zm, XM, YM, ZM;
+  Standard_Real Xm, Ym, Zm, XM, YM, ZM;
 
-        if (IsEmpty () || IsInfinite ()) {
-                XMin    = RF;
-                YMin    = RF;
-                ZMin    = RF;
-
-                XMax    = RL;
-                YMax    = RL;
-                ZMax    = RL;
+  //Bounding borders of infinite line has been calculated as own point
+  //in center of this line
+  if (IsEmpty () || IsInfinite ()) {
+    if( IsInfinite ()){
+      for (int i=1; i<=MyGroups.Length (); i++)
+        if (! (MyGroups.Value (i))->IsEmpty () ) {
+          (MyGroups.Value (i))->MinMaxValues(Xm, Ym, Zm, XM, YM, ZM);
+          Graphic3d_Vertex vertex1(Xm, Ym, Zm);
+          Graphic3d_Vertex vertex2(XM, YM, ZM);
+          Standard_Real distance = vertex1.Distance( vertex1,vertex2 );
+          if( distance >= 500000.0){
+            XMin = XMax = (Xm+ XM)/2.0;
+            YMin = YMax = (Ym+ YM)/2.0;
+            ZMin = ZMax = (Zm+ ZM)/2.0;
+            return;
+          }  
         }
-        else {
-                XMin    = RL;
-                YMin    = RL;
-                ZMin    = RL;
-
-                XMax    = RF;
-                YMax    = RF;
-                ZMax    = RF;
-
-Standard_Integer i, Length;
-
-                Length  = MyGroups.Length ();
-                for (i=1; i<=Length; i++)
-                        if (! (MyGroups.Value (i))->IsEmpty () ) {
-                                (MyGroups.Value (i))->MinMaxValues
-                                                (Xm, Ym, Zm, XM, YM, ZM);
-
-                                if (Xm < XMin) XMin     = Xm;
-                                if (Ym < YMin) YMin     = Ym;
-                                if (Zm < ZMin) ZMin     = Zm;
-                                if (XM > XMax) XMax     = XM;
-                                if (YM > YMax) YMax     = YM;
-                                if (ZM > ZMax) ZMax     = ZM;
-                        }
-
-                Length  = MyDescendants.Length ();
-                for (i=1; i<=Length; i++)
-                    if (! ((Graphic3d_Structure *)
-                        (MyDescendants.Value (i)))->IsEmpty () ) {
-                        ((Graphic3d_Structure *)
-                                (MyDescendants.Value (i)))->MinMaxValues
-                                        (Xm, Ym, Zm, XM, YM, ZM);
-
-                                if (Xm < XMin) XMin     = Xm;
-                                if (Ym < YMin) YMin     = Ym;
-                                if (Zm < ZMin) ZMin     = Zm;
-                                if (XM > XMax) XMax     = XM;
-                                if (YM > YMax) YMax     = YM;
-                                if (ZM > ZMax) ZMax     = ZM;
-                        }
-
-                if ((XMin == RL) && (YMin == RL) &&
-                    (ZMin == RL) && (XMax == RF) &&
-                    (YMax == RF) && (ZMax == RF)) {
-                        // Cas impossible car cela voudrait dire
-                        // que la structure est vide
-                        XMin    = RF;
-                        YMin    = RF;
-                        ZMin    = RF;
-
-                        XMax    = RL;
-                        YMax    = RL;
-                        ZMax    = RL;
-                }
+    }
+    XMin = RF;
+    YMin = RF;
+    ZMin = RF;
+
+    XMax = RL;
+    YMax = RL;
+    ZMax = RL;
+  }
+  else {
+    XMin = RL;
+    YMin = RL;
+    ZMin = RL;
+
+    XMax = RF;
+    YMax = RF;
+    ZMax = RF;
+    Standard_Integer i, Length;
+
+    Length  = MyGroups.Length ();
+    for (i=1; i<=Length; i++)
+      if (! (MyGroups.Value (i))->IsEmpty () ) {
+        (MyGroups.Value (i))->MinMaxValues(Xm, Ym, Zm, XM, YM, ZM);
+        if (Xm < XMin) XMin = Xm;
+        if (Ym < YMin) YMin = Ym;
+        if (Zm < ZMin) ZMin = Zm;
+        if (XM > XMax) XMax = XM;
+        if (YM > YMax) YMax = YM;
+        if (ZM > ZMax) ZMax = ZM;
+      }
+
+      Length  = MyDescendants.Length ();
+      for (i=1; i<=Length; i++)
+        if (! ((Graphic3d_Structure *)
+          (MyDescendants.Value (i)))->IsEmpty () ) {
+            ((Graphic3d_Structure *)
+              (MyDescendants.Value (i)))->MinMaxValues (Xm, Ym, Zm, XM, YM, ZM);
+
+            if (Xm < XMin) XMin = Xm;
+            if (Ym < YMin) YMin = Ym;
+            if (Zm < ZMin) ZMin = Zm;
+            if (XM > XMax) XMax = XM;
+            if (YM > YMax) YMax = YM;
+            if (ZM > ZMax) ZMax = ZM;
+          }
+
+          if ((XMin == RL) && (YMin == RL) &&
+              (ZMin == RL) && (XMax == RF) &&
+              (YMax == RF) && (ZMax == RF)) {
+              // Cas impossible car cela voudrait dire
+              // que la structure est vide
+              XMin    = RF;
+              YMin    = RF;
+              ZMin    = RF;
+
+              XMax    = RL;
+              YMax    = RL;
+              ZMax    = RL;
+            }
 
-        }
+  }
 
 }
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IGESControl/IGESControl_IGESBoundary.cxx OpenCASCADE6.3.0/ros/src/IGESControl/IGESControl_IGESBoundary.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IGESControl/IGESControl_IGESBoundary.cxx	2010-07-04 20:15:26.539235653 +0200
+++ OpenCASCADE6.3.0/ros/src/IGESControl/IGESControl_IGESBoundary.cxx	2010-03-17 13:08:30.000000000 +0100
@@ -28,7 +28,9 @@
 #include <BRep_Tool.hxx>
 #include <ShapeBuild_Edge.hxx>
 #include <ShapeAnalysis_Wire.hxx>
+#include <ShapeAnalysis_ShapeTolerance.hxx>
 #include <ShapeFix_Edge.hxx>
+#include <ShapeFix_Wire.hxx>
 #include <ShapeFix_ShapeTolerance.hxx>
 #include <IGESToBRep.hxx>
 #include <IGESToBRep_TopoCurve.hxx>
@@ -40,7 +42,6 @@
 #include <IGESGeom_BSplineCurve.hxx>
 
 
-
 //=======================================================================
 //function : IGESControl_IGESBoundary
 //purpose  : 
@@ -109,16 +110,16 @@
 //=======================================================================
 
  Standard_Boolean IGESControl_IGESBoundary::Transfer(Standard_Boolean& okCurve,
-						       Standard_Boolean& okCurve3d,
-						       Standard_Boolean& okCurve2d,
-						       const Handle(IGESData_IGESEntity)& icurve3d,
-						       const Handle(ShapeExtend_WireData)& scurve3d,
-						       const Standard_Boolean usescurve,
-						       const Standard_Boolean toreverse3d,
-						       const Handle(IGESData_HArray1OfIGESEntity)& curves2d,
-						       const Standard_Boolean toreverse2d,
-						       const Standard_Integer number,
-						       Handle(ShapeExtend_WireData)& Gsewd) 
+                                                     Standard_Boolean& okCurve3d,
+                                                     Standard_Boolean& okCurve2d,
+                                                     const Handle(IGESData_IGESEntity)& icurve3d,
+                                                     const Handle(ShapeExtend_WireData)& scurve3d,
+                                                     const Standard_Boolean usescurve,
+                                                     const Standard_Boolean toreverse3d,
+                                                     const Handle(IGESData_HArray1OfIGESEntity)& curves2d,
+                                                     const Standard_Boolean toreverse2d,
+                                                     const Standard_Integer number,
+                                                     Handle(ShapeExtend_WireData)& Gsewd) 
 {
   Gsewd                                = new ShapeExtend_WireData;//local translation (for mysewd)
   Handle(ShapeExtend_WireData) Gsewd3d = new ShapeExtend_WireData;//local translation (for mysewd3d)
@@ -143,7 +144,7 @@
     len3d = scurve3d->NbEdges();
   else {
     IGESToBRep::IGESCurveToSequenceOfIGESCurve (icurve3d, seq3d);
-    len3d = seq3d->Length();
+      len3d = seq3d->Length();
   }
   if (!curves2d.IsNull()) {
     for (Standard_Integer i = 1; i <= curves2d->Length(); i++)
@@ -153,9 +154,9 @@
 
   Standard_Integer surfcurv = myCS.GetSurfaceCurve();
   if ((surfcurv == -2 && len2d > 0) || len3d == 0)
-      GTranslate3d = Standard_False;
+    GTranslate3d = Standard_False;
   else if (( surfcurv == -3 && len3d > 0) || len2d == 0)
-      GTranslate2d = Standard_False;
+    GTranslate2d = Standard_False;
  
   if (GTranslate3d && GTranslate2d)
     //Setting preference in the case of inconsitency between 3D and 2D
@@ -173,8 +174,9 @@
   IGESToBRep_TopoCurve TC (myCS);
   
   if (GTranslate3d && !GTranslate2d) {
-    if (usescurve)
-      Gsewd->Add (scurve3d->Wire());
+    if (usescurve) {
+      Gsewd->Add(scurve3d->Wire());
+    }
     else {
       TopoDS_Shape Sh = TC.TransferTopoCurve (icurve3d);
       if (!Sh.IsNull()) {
@@ -198,7 +200,7 @@
     }
     Gsewd->Add (Gsewd2d->Wire());
   }
-  else if (GTranslate3d && GTranslate2d) {
+  else if( GTranslate3d && GTranslate2d ) {
     //Translate both curves 3D and 2D
     //Suppose that i-th segment in 2D curve corresponds to i-th segment in 3D curve
     for (Standard_Integer i = 1; i <= len3d; i++) {
@@ -308,17 +310,65 @@
 #ifdef DEB
 	cout << "Warning: IGESToBRep_IGESBoundary: Curves " << i - 1 << " and " << i << " cannot be connected" << endl;
 #endif
+        Gsewd3d = new ShapeExtend_WireData;
+        for (Standard_Integer i = 1; i <= len3d; i++) {
+          if (usescurve)
+            Gsewd3d->Add (scurve3d->Edge (i));
+          else {
+            TopoDS_Shape Sh =
+              TC.TransferTopoCurve (Handle(IGESData_IGESEntity)::DownCast (seq3d->Value (i)));
+            if (!Sh.IsNull()) Gsewd3d->Add (Sh);
+          }
+        }
+        if (toreverse3d) {
+          ReverseCurves3d(Gsewd3d);
+        }
+        Gsewd2d = new ShapeExtend_WireData;
+        for (Standard_Integer i = 1; i <= len2d; i++) {
+          TopoDS_Shape Sh = TC.Transfer2dTopoCurve (Handle(IGESData_IGESEntity)::DownCast (seq2d->Value (i)),
+                                                    myface, mytrsf, myuFact);
+          if (!Sh.IsNull()) Gsewd2d->Add (Sh);
+        }
+        if (toreverse2d) {
+          ReverseCurves2d (Gsewd2d, myface);
+        }
+        Handle(ShapeFix_Wire) sfw3 = new ShapeFix_Wire(Gsewd3d->Wire(),myface,precision);
+        sfw3->Perform();
+        TopoDS_Wire w3 = sfw3->Wire();
+        Handle(ShapeFix_Wire) sfw2 = new ShapeFix_Wire(Gsewd2d->Wire(),myface,precision);
+        sfw2->Perform();
+        TopoDS_Wire w2 = sfw2->Wire();
+        ShapeAnalysis_ShapeTolerance ST;
+        double tol3 = ST.Tolerance(w3,1);
+        double tol2 = ST.Tolerance(w2,1);
+        Gsewd3d = new ShapeExtend_WireData;
+        Gsewd2d = new ShapeExtend_WireData;
+        Gsewd3d->Add(w3);
+        Gsewd2d->Add(w3);
+        if(tol3<tol2)
+          Gsewd->Add(w3);
+        else
+          Gsewd->Add(w2);
+        okCurve = Standard_True;
+        okCurve2d = Standard_True;
+        okCurve3d = Standard_True;
       }
     }
   }
   
   if (number > 1) {
     saw->Load (mysewd);
-    okCurve   = okCurve   && ShapeAlgo::AlgoContainer()->ConnectNextWire (saw,   Gsewd,   maxtol, distmin, revsewd, revnextsewd);
+    okCurve   = okCurve &&
+      ShapeAlgo::AlgoContainer()->ConnectNextWire (saw, Gsewd, maxtol,
+                                                   distmin, revsewd, revnextsewd);
     saw3d->Load (mysewd3d);
-    okCurve3d = okCurve3d && ShapeAlgo::AlgoContainer()->ConnectNextWire (saw3d, Gsewd3d, maxtol, distmin, revsewd, revnextsewd);
+    okCurve3d = okCurve3d &&
+      ShapeAlgo::AlgoContainer()->ConnectNextWire (saw3d, Gsewd3d, maxtol,
+                                                   distmin, revsewd, revnextsewd);
     saw2d->Load (mysewd2d);
-    okCurve2d = okCurve2d && ShapeAlgo::AlgoContainer()->ConnectNextWire (saw2d, Gsewd2d, maxtol, distmin, revsewd, revnextsewd);
+    okCurve2d = okCurve2d &&
+      ShapeAlgo::AlgoContainer()->ConnectNextWire (saw2d, Gsewd2d, maxtol,
+                                                   distmin, revsewd, revnextsewd);
   }
   else {
     mysewd   = Gsewd;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h OpenCASCADE6.3.0/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h
--- OpenCASCADE6.3.0.orig//ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h	2010-07-04 20:15:32.566318577 +0200
+++ OpenCASCADE6.3.0/ros/src/InterfaceGraphic/InterfaceGraphic_tgl_all.h	2008-11-14 15:39:54.000000000 +0100
@@ -9,11 +9,16 @@
 #ifndef  INTERFACEGRAPHIC_TGL_ALL_H
 #define  INTERFACEGRAPHIC_TGL_ALL_H
 
-typedef  int   Tint;
-typedef  float Tfloat;
-typedef  char  Tchar;
-typedef  char  Tbool;
-typedef unsigned int    Tuint;
+typedef  int          Tint;
+typedef  float        Tfloat;
+/* PCD 04/07/07  */
+typedef	 double       Tdouble;
+/* Tchar is treated as a signed char in visualization code,
+therefore it should be made signed explicitly, as on Linux 
+-funsigned-char option is specified when building OCCT */
+typedef  signed char  Tchar;
+typedef  char         Tbool;
+typedef  unsigned int Tuint;
 
 #define  TGL_SP   1
 #define  TGL_DP   0
@@ -37,6 +42,7 @@
 #define  TNotDone  0
 
 typedef  Tfloat  Tmatrix3[4][4];
+
 typedef  enum    
 { 
   TPreConcatenate, 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_ALineToWLine.gxx OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_ALineToWLine.gxx
--- OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_ALineToWLine.gxx	2010-07-04 20:15:36.930132700 +0200
+++ OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_ALineToWLine.gxx	2009-09-21 13:32:24.000000000 +0200
@@ -47,6 +47,16 @@
 			  Standard_Real& u2,
 			  const Standard_Real anu1,
 			  const Standard_Real anu2);
+
+static
+  void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
+			      const IntSurf_Quadric aQuad1,
+			      const IntSurf_Quadric aQuad2,
+			      const Standard_Real ref_u1,
+			      const Standard_Real ref_u2,
+			      Standard_Real& new_u1,
+			      Standard_Real& new_u2);
+
 //
 static
   void RefineParameters(const Handle(TheALine)& aALine,
@@ -278,6 +288,17 @@
   Handle(IntSurf_LineOn2S) LinOn2S;
   //
   LinOn2S = new IntSurf_LineOn2S;
+
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  Standard_Real refpar = RealLast(), ref_u1, ref_u2;
+  if (nbvtx)
+    {
+      const ThePoint& FirstVertex = aline->Vertex(1);
+      refpar = FirstVertex.ParameterOnLine();
+      FirstVertex.Parameters(ref_u1, v1, ref_u2, v2);
+    }
+  ////////////////////////////////////////////////
+
   //-----------------------------------------------------
   //-- Estimation Grossiere de la longueur de la courbe
   //-- 
@@ -362,6 +383,9 @@
   //
   // the loop
   DeltaU=0.;
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  Standard_Boolean Corrected = Standard_False;
+  ////////////////////////////////////////////////
   while(U<lastparam) { 
     Standard_Integer NbCalculD1;
     Standard_Real UPourCalculD1, pvavant, pvapres;
@@ -450,6 +474,13 @@
       }
     }
     //
+    //// Modified by jgv, 17.09.09 for OCC21255 ////
+    if (!Corrected && U >= refpar)
+      {
+	CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+	Corrected = Standard_True;
+      }
+    ////////////////////////////////////////////////
     U+=DeltaU;
     if(U < lastparam) { 
       nbpwline++;
@@ -492,6 +523,13 @@
   POn2S.SetValue(Pnt3d,u1,v1,u2,v2);
   LinOn2S->Add(POn2S);
   nbpwline++;
+
+  //// Modified by jgv, 17.09.09 for OCC21255 ////
+  if (!Corrected && 
+      (lastparam >= refpar || refpar-lastparam < Precision::Confusion()))
+    CorrectFirstPartOfLine(LinOn2S, quad1, quad2, ref_u1, ref_u2, anu1, anu2);
+  ////////////////////////////////////////////////
+
   //
   //-----------------------------------------------------------------
   //--  Calcul de la transition de la ligne sur les surfaces      ---
@@ -895,6 +933,7 @@
   }
   while(u1-anu1 > 5.0) { 
     //
+    /*
     if (!bBothCylinders) {//cfe900/H6
       // this check on Cylinder/Cylinder intersection is probably 
       // because of pbs with ALine on it.
@@ -908,6 +947,7 @@
 	break;
       }
     }
+    */
     //
     u1-=PI+PI;
   }
@@ -916,15 +956,54 @@
   }
   while(u2-anu2 > 5.0) {
     //
+    /*
     if (!bBothCylinders) {//cfe900/H6
       if (u2-PI-PI<0.) {
 	break;
       }
     }
+    */
     //
     u2-=PI+PI;
   }
 }
+
+//=======================================================================
+//function : CorrectFirstPartOfLine
+//purpose  : 
+//=======================================================================
+void CorrectFirstPartOfLine(Handle(IntSurf_LineOn2S)& LinOn2S,
+			    const IntSurf_Quadric aQuad1,
+			    const IntSurf_Quadric aQuad2,
+			    const Standard_Real ref_u1,
+			    const Standard_Real ref_u2,
+			    Standard_Real& new_u1,
+			    Standard_Real& new_u2)
+{
+  Standard_Integer nbp = LinOn2S->NbPoints();
+  Standard_Real u1, v1, u2, v2, OffsetOnS1, OffsetOnS2;
+
+  IntSurf_PntOn2S aPoint = LinOn2S->Value(nbp);
+  aPoint.Parameters(u1, v1, u2, v2);
+
+  new_u1 = u1;
+  new_u2 = u2;
+  RecadreMemePeriode(aQuad1, aQuad2, new_u1, new_u2, ref_u1, ref_u2);
+  OffsetOnS1 = new_u1 - u1;
+  OffsetOnS2 = new_u2 - u2;
+  if (Abs(OffsetOnS1) > 1. || Abs(OffsetOnS2) > 1.) //recadre on n*2*PI is done
+    {
+      Standard_Integer i;
+      for (i = 1; i <= nbp; i++)
+	{
+	  aPoint = LinOn2S->Value(i);
+	  aPoint.Parameters(u1, v1, u2, v2);
+	  LinOn2S->SetUV( i, Standard_True,  u1 + OffsetOnS1, v1 );
+	  LinOn2S->SetUV( i, Standard_False, u2 + OffsetOnS2, v2 );
+	}
+    }
+}
+
 //
 //=======================================================================
 //function : IsApex
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx
--- OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx	2010-07-04 20:15:37.676312572 +0200
+++ OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_ImpImpIntersection_4.gxx	2010-02-12 04:56:52.000000000 +0100
@@ -10,6 +10,11 @@
 				const Standard_Real aTol,
 				IntAna_ListOfCurve& aLC);
 
+static
+  Standard_Boolean IsToReverse(const gp_Cylinder& Cy1,
+			       const gp_Cylinder& Cy2,
+			       const Standard_Real Tol);
+
 //
 
 //=======================================================================
@@ -152,10 +157,10 @@
   }
 }
 
-
-
-
-
+//=======================================================================
+//function : IntCyCy
+//purpose  : 
+//=======================================================================
 Standard_Boolean IntCyCy(const IntSurf_Quadric& Quad1,
 			 const IntSurf_Quadric& Quad2,
 			 const Standard_Real Tol,
@@ -425,6 +430,15 @@
     {
       gp_Pnt psol;
       Standard_Real U1,V1,U2,V2;
+      //xf
+      Standard_Boolean bReverse;
+      //
+      bReverse=IsToReverse(Cy1, Cy2, Tol);
+      if (bReverse){
+	Cy2=Quad1.Cylinder();
+	Cy1=Quad2.Cylinder();
+      }
+      //xt
       IntAna_IntQuadQuad anaint(Cy1,Cy2,Tol);
       if (!anaint.IsDone()) {
 	return Standard_False;
@@ -739,9 +753,6 @@
   }
   return Standard_True;
 }
-
-
-
 //=======================================================================
 //function : IntCyCo
 //purpose  : 
@@ -1003,3 +1014,46 @@
   //
   return bFind;
 }
+//=======================================================================
+//function : IsToReverse
+//purpose  : 
+//=======================================================================
+Standard_Boolean IsToReverse(const gp_Cylinder& Cy1,
+			     const gp_Cylinder& Cy2,
+			     const Standard_Real Tol)
+{
+  Standard_Boolean bRet;
+  Standard_Real aR1,aR2, dR, aSc1, aSc2;
+  //
+  bRet=Standard_False;
+  //
+  aR1=Cy1.Radius();
+  aR2=Cy2.Radius();
+  dR=aR1-aR2;
+  if (dR<0.) {
+    dR=-dR;
+  }
+  if (dR>Tol) {
+    bRet=aR1>aR2;
+  }
+  else {
+    gp_Dir aDZ(0.,0.,1.);
+    //
+    const gp_Dir& aDir1=Cy1.Axis().Direction();
+    aSc1=aDir1*aDZ;
+    if (aSc1<0.) {
+      aSc1=-aSc1;
+    }
+    //
+    const gp_Dir& aDir2=Cy2.Axis().Direction();
+    aSc2=aDir2*aDZ;
+    if (aSc2<0.) {
+      aSc2=-aSc2;
+    }
+    //
+    if (aSc2<aSc1) {
+      bRet=!bRet;
+    }
+  }//if (dR<Tol) {
+  return bRet;
+}
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_Point.gxx OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_Point.gxx
--- OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_Point.gxx	2010-07-04 20:15:37.576099624 +0200
+++ OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_Point.gxx	2009-11-11 11:35:06.000000000 +0100
@@ -2,8 +2,23 @@
 
 #include <stdio.h>
 
-IntPatch_Point::IntPatch_Point () {}
-
+IntPatch_Point::IntPatch_Point()
+{
+  para = 0.;
+  tol  = 0.;
+  tgt     = Standard_False;
+  mult    = Standard_False;
+  onS1    = Standard_False;
+  onS2    = Standard_False;
+  vtxonS1 = Standard_False;
+  vS1   = NULL;
+  arcS1 = NULL;
+  vtxonS2 = Standard_False;
+  vS2   = NULL;
+  arcS2 = NULL;
+  prm1 = 0.;
+  prm2 = 0.;
+}
 
 void IntPatch_Point::SetValue (const gp_Pnt& Pt,
 			       const Standard_Real Tol,
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx
--- OpenCASCADE6.3.0.orig//ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx	2010-07-04 20:15:37.525896873 +0200
+++ OpenCASCADE6.3.0/ros/src/IntPatch/IntPatch_PrmPrmIntersection.gxx	2008-11-25 15:37:21.000000000 +0100
@@ -32,14 +32,14 @@
 				     Standard_Real& u2,
 				     Standard_Real& v2);
 
-//xf
+
 static 
   void AdjustOnPeriodic(const TheSurface& Surf1,
 			const TheSurface& Surf2,
 			IntPatch_SequenceOfLine& aSLin);
-//xt
+
 //==================================================================================
-// function : Constructor
+// function : 
 // purpose  : 
 //==================================================================================
 IntPatch_PrmPrmIntersection::IntPatch_PrmPrmIntersection(): done(Standard_False)
@@ -1677,8 +1677,7 @@
 	    }
 	  }
 	}
-	//--printf("\n\n1 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//--       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U1_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V1_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1712,8 +1711,7 @@
 	    }
 	  }
 	}
-	//printf("\n2 Dist3[0]=%5.5g,u3[0]=%5.5g,v3[0]=%5.5g ,  Dist3[1]=%5.5g,u3[1]=%5.5g,v3[1]=%5.5g  ,Dist3[2]=%5.5g,u3[2]=%5.5g,v3[2]=%5.5g\n",
-	//       Dist3[0],u3[0],v3[0] ,  Dist3[1],u3[1],v3[1]  ,Dist3[2],u3[2],v3[2]);
+	//
 	Standard_Real U2_3 = (u3[0]+u3[1]+u3[2])/3.0;
 	Standard_Real V2_3 = (v3[0]+v3[1]+v3[2])/3.0;
 	
@@ -1725,7 +1723,6 @@
     }
   }
   while(ok);
-  //-- cout<<"\n *** "<<Compt<<" Points de *1  ** 2* ds la grille UVP"<<ComptTrouve<<endl; Compt=0;
 }
 
 //==================================================================================
@@ -1764,7 +1761,7 @@
     if (ClearFlag)
       SLin.Clear();
     // modified by NIZHNY-AMV  Tue Oct 18 12:37:02 2005.END
-
+    //
     //IntPolyh_Intersection Interference(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     //     IntPolyh_Intersection Interference(Surf1, anUpars1, aVpars1, 
     // 				       Surf2, anUpars2, aVpars2);
@@ -1775,15 +1772,16 @@
       pInterference = new IntPolyh_Intersection(Surf1,NbU1,NbV1,Surf2,NbU2,NbV2);
     }
     else {
-      pInterference = new IntPolyh_Intersection( Surf1, anUpars1, aVpars1, 
+      pInterference = new IntPolyh_Intersection(Surf1, anUpars1, aVpars1, 
 						Surf2, anUpars2, aVpars2 );
     }
     if ( !pInterference ) {
       done = Standard_False;
       return;
     }
+    //
     IntPolyh_Intersection& Interference = *pInterference;
-
+    //
     done = Interference.IsDone();
     if( !done ) {
       if ( pInterference ) {
@@ -1792,7 +1790,7 @@
       }
       return;
     }
-
+    
     Standard_Real Deflection2 = Deflection*Deflection;
     Standard_Integer nbLigSec = Interference.NbSectionLines();
     Standard_Integer nbTanZon = Interference.NbTangentZones();
@@ -1828,11 +1826,18 @@
 	  }
 	}
       } while(triok==Standard_False);
-
+      //
       for( ls = 1; ls <= nbLigSec; ls++) {
-	Standard_Integer nbp = Interference.NbPointsInLine(TabL[ls]);
-	Standard_Integer *TabPtDep = new Standard_Integer [nbp+1];
-	Standard_Integer ilig;
+	Standard_Integer nbp, ilig, *TabPtDep;
+	//
+	nbp = Interference.NbPointsInLine(TabL[ls]);
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:28 2008f
+	if (!nbp) {
+	  continue;
+	}
+	//modified by NIZNHY-PKV Fri Sep  5 15:19:31 2008t
+	TabPtDep = new Standard_Integer [nbp+1];
+	//
 	for( ilig = 1; ilig <= nbp; ilig++ )
 	  TabPtDep[ilig]=0;
 
@@ -1864,9 +1869,8 @@
 	Standard_Integer nbps2 = (nbp>3)? (nbp/2) :  1;
 	Standard_Integer NombreDePointsDeDepartDuCheminement = 0;
 	Standard_Boolean lignetrouvee=Standard_False;
-	// const Standard_Integer NbDePointsDeDepartDuChmLimit = 3;
 	const Standard_Integer NbDePointsDeDepartDuChmLimit = 5;
-
+	//
 	do { 
 	  NombreDePointsDeDepartDuCheminement++;
 	  switch (NombreDePointsDeDepartDuCheminement) {
@@ -1891,7 +1895,7 @@
 	    nbps2 = NombreDePointsDeDepartDuCheminement-3;
 	    NombreDePointsDeDepartDuCheminement++;
 	  }
-
+	  //
 	  if(TabPtDep[nbps2] == 0) {
 	    TabPtDep[nbps2] = 1;
 	    Interference.GetLinePoint(TabL[ls],nbps2,_x,_y,_z,U1,V1,U2,V2,incidence);
@@ -1966,7 +1970,6 @@
 		Standard_Boolean bPWIsDone;
 		Standard_Integer iPWNbPoints, aNbPointsVer;
 		Standard_Real aD11, aD12, aD21, aD22, aDx;
-
 		//
 		bPWIsDone=PW.IsDone();
 		//xt
@@ -2023,12 +2026,8 @@
 			  }
 			}
 		      }
-// 		      if(Point3dDebut.Distance(verPointDebut.Value()) <= TolTangency) { 
-// 			if(Point3dFin.Distance(verPointFin.Value()) <= TolTangency)
-// 			  RejetLigne = Standard_True; 
-// 		      }
 		    }
-		    
+		    //
 		    if(!RejetLigne) {
 		      IntSurf_TypeTrans trans1,trans2;
 		      Standard_Real locu,locv;
@@ -2227,10 +2226,9 @@
       delete [] TabL;
 
     }// if nbLigSec >= 1
-
-    //xf
+    //
     AdjustOnPeriodic(Surf1, Surf2, SLin);
-    //xt
+    //
 
     //--------------------------------------------------------------------
     //-- Calcul des parametres approches a partir des Zones De Tangence --
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_BeanBeanIntersector.cxx OpenCASCADE6.3.0/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_BeanBeanIntersector.cxx	2010-07-04 20:15:38.719259890 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_BeanBeanIntersector.cxx	2009-03-24 11:59:12.000000000 +0100
@@ -297,6 +297,41 @@
   aCriteria2=myCriteria*myCriteria;
   aNbRanges=myRangeManager.Length();
   //
+  //modified by NIZNHY-PKV Tue Mar 24 11:13:42 2009f
+  {
+    GeomAbs_CurveType aCT1, aCT2;
+    //
+    aCT1=myCurve1.GetType();
+    aCT2=myCurve2.GetType();
+    
+    if (aCT1==GeomAbs_BSplineCurve &&
+	aCT2==GeomAbs_BSplineCurve) {
+      Standard_Real aST, aST1, aSx, aSz;
+      //
+      aST1=myLastParameter1-myFirstParameter1;
+      if (aST1>aPPC) {
+	aSz=1.e-4;
+	aST=0.;
+	for(i=1; i<=aNbRanges; ++i) {
+	  iFlag=myRangeManager.Flag(i);
+	  if(iFlag==4) {
+	    aRange=myRangeManager.Range(i);
+	    aST=aST+aRange.Last()-aRange.First();
+	  }
+	}
+	aSx=1.-aST/aST1;
+	if (aSx<aSz) {
+	  aRange.SetFirst(myFirstParameter1);
+	  aRange.SetLast(myLastParameter1);
+	  myResults.Append(aRange);
+	  myIsDone = Standard_True;
+	  return;
+	}
+      }
+    }
+  }
+  //modified by NIZNHY-PKV Tue Mar 24 11:13:44 2009t
+  //
   for(i=1; i<=aNbRanges; ++i) {
     iFlag=myRangeManager.Flag(i);
     //
@@ -621,18 +656,10 @@
 	      anExtrema.Points(k, P1, P2);
 	      aPrm1=P1.Parameter();
 	      aPrm2=P2.Parameter();
-	      //modified by NIZNHY-PKV Tue Jun  5 15:47:13 2007f
-	      /*
-	      if((aPrm1 >= 0.) && (aPrm1 <= aDistance) &&
-		 (aPrm2 >= 0.) && (aPrm2 <= aD)) {
-		isintersection = Standard_True;
-	      }
-	      */
 	      if((aPrm1 >= -aMaxDistance) && (aPrm1 <= aDistance+aMaxDistance) &&
 		 (aPrm2 >= -aMaxDistance) && (aPrm2 <= aD+aMaxDistance)) {
 		isintersection = Standard_True;
 	      }
-	      //modified by NIZNHY-PKV Tue Jun  5 15:47:17 2007t
 	      else { // 2
 		Extrema_ExtPElC aPointProjector;
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Context.cdl OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Context.cdl
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Context.cdl	2010-07-04 20:15:38.709258631 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Context.cdl	2009-12-28 05:49:42.000000000 +0100
@@ -28,7 +28,6 @@
     ProjectPointOnSurf  from GeomAPI,
     Curve from Geom, 
     SolidClassifier from BRepClass3d,
-    --modified by NIZHNY-MKK  Fri Oct 21 14:59:36 2005
     SurfaceRangeLocalizeData from IntTools,
 ---    
     Pnt2d from  gp,
@@ -85,7 +84,7 @@
 	--- Returns a reference to point projector
 	--- for given curve
 	---
---modified by NIZHNY-MKK  Fri Oct 21 14:59:21 2005.BEGIN
+
     SurfaceData(me: in out; 
 		aF: Face from TopoDS)
 	returns SurfaceRangeLocalizeData from IntTools;
@@ -93,7 +92,7 @@
 	---Purpose:
 	--- Returns a reference to surface localization data
 	--- for given face
---modified by NIZHNY-MKK  Fri Oct 21 14:59:25 2005.END
+
 
     SolidClassifier(me: in out;  
     	    	    aSolid: Solid from TopoDS) 
@@ -105,11 +104,30 @@
 	---
 
     ---         API  Block
-    ---
+    --- 
+    ComputeVE  (me:out;  
+    	    	aV   : Vertex from  TopoDS; 
+    	    	aE   : Edge   from  TopoDS; 
+                aT   :out Real from Standard)
+    	returns Integer from Standard;
+	---Purpose:
+	--- Computes parameter of the vertex aV on
+	--- the edge aE.
+	--- Returns zero if the distance between vertex
+	--- and edge is less than sum of tolerances,
+	--- otherwise and for following conditions returns
+	--- negative value
+	--- 1. the edge is degenerated (-1)
+	--- 2. the edge does not contain 3d curve and pcurves (-2)
+	--- 3. projection algorithm failed (-3) 
+    --
+    --modified by NIZNHY-PKV Mon Dec 28 07:45:21 2009f
     ComputeVE  (me:out;  
     	    	aV   : Vertex from  TopoDS; 
     	    	aE   : Edge   from  TopoDS; 
-                aT   :out Real from Standard) 
+                aT   :out Real from Standard; 
+    	    	bToUpdateVertex:out Boolean from Standard; 
+		aDist          :out Real from Standard)  
     	returns Integer from Standard;
 	---Purpose:
 	--- Computes parameter of the vertex aV on
@@ -121,8 +139,9 @@
 	--- 1. the edge is degenerated (-1)
 	--- 2. the edge does not contain 3d curve and pcurves (-2)
 	--- 3. projection algorithm failed (-3)
-	---
-	
+	--- 
+	--modified by NIZNHY-PKV Mon Dec 28 07:45:30 2009t
+	--    	
     ComputeVS  (me:out;  
     	    	aV  :     Vertex from  TopoDS; 
     	    	aF  :     Face   from  TopoDS; 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Context.cxx OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Context.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Context.cxx	2010-07-04 20:15:38.709258631 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Context.cxx	2009-12-29 06:40:16.000000000 +0100
@@ -283,8 +283,8 @@
   //
   //==
 }
-
-
+//modified by NIZNHY-PKV Mon Dec 28 07:46:46 2009f
+/*
 //=======================================================================
 //function : ComputeVE
 //purpose  : 
@@ -299,35 +299,110 @@
   if (!BRep_Tool::IsGeometric(aE2)) { 
     return -2;
   }
+  //
   Standard_Real aDist, aTolV1, aTolE2, aTolSum;
   Standard_Integer aNbProj;
   gp_Pnt aP;
   //
+  bToUpdate=Standard_False;
   aP=BRep_Tool::Pnt(aV1);
   //
   GeomAPI_ProjectPointOnCurve& aProjector=ProjPC(aE2);
+  //
   aProjector.Perform(aP);
-
   aNbProj=aProjector.NbPoints();
-
   if (!aNbProj) {
     return -3;
   }
-  
+  //
   aDist=aProjector.LowerDistance();
-  
   aTolV1=BRep_Tool::Tolerance(aV1);
   aTolE2=BRep_Tool::Tolerance(aE2);
   aTolSum=aTolV1+aTolE2;
-
+  //
   aT=aProjector.LowerDistanceParameter();
-
+  //
   if (aDist > aTolSum) {
     return -4;
   }
-  
   return 0;
 }
+*/
+//=======================================================================
+//function : ComputeVE
+//purpose  : 
+//=======================================================================
+  Standard_Integer IntTools_Context::ComputeVE(const TopoDS_Vertex& aV1, 
+					       const TopoDS_Edge&   aE2,
+					       Standard_Real& aT)
+{
+  Standard_Boolean bToUpdate;
+  Standard_Integer iFlag;
+  Standard_Real aDist;
+  //
+  iFlag= ComputeVE(aV1, aE2, aT, bToUpdate, aDist);
+  //
+  return iFlag;
+}
+//modified by NIZNHY-PKV Mon Dec 28 07:46:46 2009f
+//=======================================================================
+//function : ComputeVE
+//purpose  : 
+//=======================================================================
+  Standard_Integer IntTools_Context::ComputeVE(const TopoDS_Vertex& aV1, 
+					       const TopoDS_Edge&   aE2,
+					       Standard_Real& aT,
+					       Standard_Boolean& bToUpdateVertex, 
+					       Standard_Real& aDist)
+{
+  if (BRep_Tool::Degenerated(aE2)) {
+    return -1;
+  }
+  if (!BRep_Tool::IsGeometric(aE2)) { 
+    return -2;
+  }
+  //
+  Standard_Real aTolV1, aTolE2, aTolSum, aTolVx;//aDist,
+  Standard_Integer aNbProj;
+  gp_Pnt aP;
+  //
+  bToUpdateVertex=Standard_False;
+  aP=BRep_Tool::Pnt(aV1);
+  //
+  GeomAPI_ProjectPointOnCurve& aProjector=ProjPC(aE2);
+  //
+  aProjector.Perform(aP);
+  aNbProj=aProjector.NbPoints();
+  if (!aNbProj) {
+    return -3;
+  }
+  //
+  aDist=aProjector.LowerDistance();
+  aTolV1=BRep_Tool::Tolerance(aV1);
+  aTolE2=BRep_Tool::Tolerance(aE2);
+  aTolSum=aTolV1+aTolE2;
+  //
+  aT=aProjector.LowerDistanceParameter();
+  //
+  if (aDist > aTolSum) {
+    return -4;
+  }
+  //
+  /*
+  if (aTolE2>aTolV1) {
+    bToUpdateVertex=!bToUpdateVertex;
+    aDist=aDist+aTolE2;
+  }
+  */
+  aTolVx=aDist+aTolE2;
+  if (aTolVx>aTolV1) {
+    bToUpdateVertex=!bToUpdateVertex;
+    aDist=aTolVx;
+  }
+  //
+  return 0;
+}
+//modified by NIZNHY-PKV Mon Dec 28 07:47:02 2009t
 //=======================================================================
 //function : ComputeVS
 //purpose  : 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_FaceFace.cxx OpenCASCADE6.3.0/ros/src/IntTools/IntTools_FaceFace.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_FaceFace.cxx	2010-07-04 20:15:38.735977121 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_FaceFace.cxx	2010-02-25 09:37:48.000000000 +0100
@@ -1,8 +1,4 @@
-//  Modified by skv - Tue Jul 11 16:41:33 2006 OCC12627
-//  Modified by skv - Mon Jul 12 16:16:15 2004 OCC6277
-//  Modified by ofv - Mon Nov  9 16:31:15 2004 OCC6766 fix
-//  Modified by ofv - Mon Dec 23 16:31:15 2004 OCC6766 fix reg
-
+ 
 #include <IntTools_FaceFace.ixx>
 #include <BRep_Tool.hxx>
 #include <IntTools_Curve.hxx>
@@ -101,6 +97,7 @@
 #include <TColgp_SequenceOfPnt2d.hxx>
 #include <TColStd_HArray1OfReal.hxx>
 #include <GeomAdaptor_Curve.hxx>
+#include <IntSurf_PntOn2S.hxx>
 
 static
   void TolR3d(const TopoDS_Face& ,
@@ -341,7 +338,7 @@
   void IntTools_FaceFace::Perform(const TopoDS_Face& F1,
 				  const TopoDS_Face& F2)
 {
-  Standard_Boolean hasCone, RestrictLine, bIsDone;
+  Standard_Boolean RestrictLine, bIsDone, hasCone;
   Standard_Integer aNbLin, aNbPnts, i;
   Standard_Real TolArc, TolTang, Deflection, UVMaxStep;
   Standard_Real umin, umax, vmin, vmax;
@@ -374,7 +371,13 @@
   aType2=aBAS2.GetType();
   hasCone = Standard_False;
   //
-  if (aType1==GeomAbs_Plane && (aType2==GeomAbs_Cylinder||aType2==GeomAbs_Cone)) {
+  //modified by NIZNHY-PKV Thu Feb 25 11:02:44 2010f
+  if (aType1==GeomAbs_Plane && 
+      (aType2==GeomAbs_Cylinder||
+       aType2==GeomAbs_Cone||
+       aType2==GeomAbs_Torus)) {
+  //if (aType1==GeomAbs_Plane && 
+  //   (aType2==GeomAbs_Cylinder||aType2==GeomAbs_Cone)) {
     Standard_Real dU, dV;
     // F1
     BRepTools::UVBounds(F1, umin, umax, vmin, vmax);
@@ -396,7 +399,13 @@
     }
   }
   //
-  else if ((aType1==GeomAbs_Cylinder||aType1==GeomAbs_Cone) && aType2==GeomAbs_Plane) {
+  //modified by NIZNHY-PKV Thu Feb 25 11:37:00 2010f
+  else if ((aType1==GeomAbs_Cylinder||
+	    aType1==GeomAbs_Cone||
+	    aType1==GeomAbs_Torus) && 
+	   aType2==GeomAbs_Plane) {
+  //else if ((aType1==GeomAbs_Cylinder||aType1==GeomAbs_Cone) && aType2==GeomAbs_Plane) {  
+  //modified by NIZNHY-PKV Thu Feb 25 11:37:08 2010t  
     Standard_Real dU, dV;
     //F1
     BRepTools::UVBounds(F1, umin, umax, vmin, vmax);
@@ -426,25 +435,11 @@
     // 
     myHS1->ChangeSurface().Load(S1, umin, umax, vmin, vmax);
     //
-    //modified by NIZNHY-PKV Thu Jul  3 14:50:28 2008f
-    /*
-    if(S1==S2) { 
-      myHS2 = myHS1; 
-    }
-    else {
-      BRepTools::UVBounds(F2, umin, umax, vmin, vmax);
-	// 
-      CorrectSurfaceBoundaries(F2, (aTolF1 + aTolF2) * 2., umin, umax, vmin, vmax);
-	//   
-      myHS2->ChangeSurface().Load(S2, umin, umax, vmin, vmax);
-    }
-    */
     BRepTools::UVBounds(F2, umin, umax, vmin, vmax);
     // 
     CorrectSurfaceBoundaries(F2, (aTolF1 + aTolF2) * 2., umin, umax, vmin, vmax);
     //   
     myHS2->ChangeSurface().Load(S2, umin, umax, vmin, vmax);
-    //modified by NIZNHY-PKV Thu Jul  3 14:50:36 2008t
   }
   //
   dom1 = new IntTools_TopolTool(myHS1);
@@ -452,7 +447,17 @@
   //
   myLConstruct.Load(dom1, dom2, myHS1, myHS2);
   //
+  //Deflection = 0.085;
   Deflection = (hasCone) ? 0.085 : 0.1;
+  //modified by NIZNHY-PKV Fri Feb 20 09:10:17 2009f
+  if (aType1==GeomAbs_BSplineSurface &&
+      aType2==GeomAbs_BSplineSurface) {
+    if (myHS1->IsUClosed() && myHS1->IsUPeriodic() &&
+	myHS2->IsUClosed() && myHS2->IsUPeriodic()) {
+      Deflection=0.085;
+    }
+  }
+  //modified by NIZNHY-PKV Fri Feb 20 09:12:11 2009t
   UVMaxStep  = 0.001;
   //
   myIntersector.SetTolerances(TolArc, TolTang, UVMaxStep, Deflection);
@@ -496,18 +501,7 @@
       }
     }
   }
-  //
-  //modified by NIZNHY-PKV Thu Jul  3 14:51:04 2008f
-  /*
-  if(myHS1 == myHS2) { 
-    myIntersector.Perform(myHS1, dom1, TolArc, TolTang);
-  }
-  else {
-    myIntersector.Perform(myHS1, dom1, myHS2, dom2, TolArc, TolTang, myListOfPnts, RestrictLine);
-  }
-  */
   myIntersector.Perform(myHS1, dom1, myHS2, dom2, TolArc, TolTang, myListOfPnts, RestrictLine);
-  //modified by NIZNHY-PKV Thu Jul  3 14:51:09 2008t
   //
   bIsDone=myIntersector.IsDone();
   if (bIsDone) {
@@ -648,6 +642,18 @@
     if(!myListOfPnts.IsEmpty()) {
       bAvoidLineConstructor = Standard_True;
     }
+
+    Standard_Integer nbp = aWLine->NbPnts();
+    const IntSurf_PntOn2S& p1 = aWLine->Point(1);
+    const IntSurf_PntOn2S& p2 = aWLine->Point(nbp);
+
+    const gp_Pnt& P1 = p1.Value();
+    const gp_Pnt& P2 = p2.Value();
+
+    if(P1.SquareDistance(P2) < 1.e-14) {
+      bAvoidLineConstructor = Standard_False;
+    }
+
   }
   //
   // Line Constructor
@@ -1320,14 +1326,14 @@
 	GeomAbs_SurfaceType typs1, typs2;
 	typs1 = myHS1->Surface().GetType();
 	typs2 = myHS2->Surface().GetType();
-	
+	//
 	if(typs1 == GeomAbs_Plane) { 
 	  theapp3d.Perform(myHS1, myHS2, WL, Standard_False,Standard_True, myApprox2,ifprm,ilprm);
 	}	  
 	else if(typs2 == GeomAbs_Plane) { 
 	  theapp3d.Perform(myHS1,myHS2,WL,Standard_False,myApprox1,Standard_True,ifprm,ilprm);
 	}
-	else { 
+	else {
 	  //
 	  if (myHS1 != myHS2){
 	    if ((typs1==GeomAbs_BezierSurface || typs1==GeomAbs_BSplineSurface) &&
@@ -2321,76 +2327,7 @@
   return !bFlag;
 }
 
-//=========================================================================
-// static function : ComputePurgedWLine
-// purpose : Removes equal points (leave one of equal points) from theWLine
-//           and recompute vertex parameters.
-//           Returns new WLine or null WLine if the number
-//           of the points is less than 2.
-//=========================================================================
-Handle(IntPatch_TheWLineOfIntersection) ComputePurgedWLine(const Handle(IntPatch_TheWLineOfIntersection)& theWLine) {
-  Handle(IntPatch_TheWLineOfIntersection) aResult;
-  Handle(IntPatch_TheWLineOfIntersection) aLocalWLine;
-  Handle(IntPatch_TheWLineOfIntersection) aTmpWLine = theWLine;
-
-  Handle(IntSurf_LineOn2S) aLineOn2S = new IntSurf_LineOn2S();
-  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
-  Standard_Integer i, k, v, nb, nbvtx;
-  nbvtx = theWLine->NbVertex();
-  nb = theWLine->NbPnts();
-
-  for(i = 1; i <= nb; i++) {
-    aLineOn2S->Add(theWLine->Point(i));
-  }
-
-  for(v = 1; v <= nbvtx; v++) {
-    aLocalWLine->AddVertex(theWLine->Vertex(v));
-  }
-  
-  for(i = 1; i <= aLineOn2S->NbPoints(); i++) {
-    Standard_Integer aStartIndex = i + 1;
-    Standard_Integer anEndIndex = i + 5;
-    nb = aLineOn2S->NbPoints();
-    anEndIndex = (anEndIndex > nb) ? nb : anEndIndex;
-
-    if((aStartIndex >= nb) || (anEndIndex <= 1)) {
-      continue;
-    }
-    k = aStartIndex;
-
-    while(k <= anEndIndex) {
-      
-      if(i != k) {
-	IntSurf_PntOn2S p1 = aLineOn2S->Value(i);
-	IntSurf_PntOn2S p2 = aLineOn2S->Value(k);
-	
-	if(p1.Value().IsEqual(p2.Value(), gp::Resolution())) {
-	  aTmpWLine = aLocalWLine;
-	  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
-
-	  for(v = 1; v <= aTmpWLine->NbVertex(); v++) {
-	    IntPatch_ThePointOfIntersection aVertex = aTmpWLine->Vertex(v);
-	    Standard_Integer avertexindex = (Standard_Integer)aVertex.ParameterOnLine();
-
-	    if(avertexindex >= k) {
-	      aVertex.SetParameter(aVertex.ParameterOnLine() - 1.);
-	    }
-	    aLocalWLine->AddVertex(aVertex);
-	  }
-	  aLineOn2S->RemovePoint(k);
-	  anEndIndex--;
-	  continue;
-	}
-      }
-      k++;
-    }
-  }
 
-  if(aLineOn2S->NbPoints() > 1) {
-    aResult = aLocalWLine;
-  }
-  return aResult;
-}
 
 //=======================================================================
 //function : TolR3d
@@ -3711,3 +3648,86 @@
 
   return Standard_True;
 }
+//modified by NIZNHY-PKV Thu Feb 12 11:54:18 2009f
+//=========================================================================
+// static function : ComputePurgedWLine
+// purpose : Removes equal points (leave one of equal points) from theWLine
+//           and recompute vertex parameters.
+//           Returns new WLine or null WLine if the number
+//           of the points is less than 2.
+//=========================================================================
+Handle(IntPatch_TheWLineOfIntersection) 
+     ComputePurgedWLine(const Handle(IntPatch_TheWLineOfIntersection)& theWLine) 
+{
+  Standard_Integer i, k, v, nbvtx, aStartIndex, anEndIndex, avertexindex, aNbP;
+  Standard_Real aD2, aTol2;
+  Handle(IntPatch_TheWLineOfIntersection) aResult, aLocalWLine, aTmpWLine;
+  Handle(IntSurf_LineOn2S) aLineOn2S;
+  IntSurf_PntOn2S p1, p2;
+  //
+  aTol2=gp::Resolution();// ? but it was so
+  //
+  aLineOn2S = new IntSurf_LineOn2S();
+  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
+  //
+  aNbP = theWLine->NbPnts();
+  for(i = 1; i <= aNbP; i++) {
+    aLineOn2S->Add(theWLine->Point(i));
+  }
+  //
+  nbvtx = theWLine->NbVertex();
+  for(v = 1; v <= nbvtx; v++) {
+    aLocalWLine->AddVertex(theWLine->Vertex(v));
+  }
+  //
+  aTmpWLine = theWLine;
+  aNbP=aLineOn2S->NbPoints();
+  for(i = 1; i <= aNbP; i++) {
+    aStartIndex = i + 1;
+    anEndIndex = i + 5;
+    //
+    anEndIndex = (anEndIndex > aNbP) ? aNbP : anEndIndex;
+    //if((aStartIndex >= aNbP) || (anEndIndex <= 1)) {//ft
+    if((aStartIndex > aNbP) || (anEndIndex <= 1)) {
+      continue;
+    }
+    //
+    k = aStartIndex;
+    while(k <= anEndIndex) {
+      if(i != k) {
+	p1 = aLineOn2S->Value(i);
+	p2 = aLineOn2S->Value(k);
+	const gp_Pnt& aP1=p1.Value();
+	const gp_Pnt& aP2=p2.Value();
+	aD2=aP1.SquareDistance(aP2);
+	if (aD2<aTol2) {
+	  aTmpWLine = aLocalWLine;
+	  aLocalWLine = new IntPatch_TheWLineOfIntersection(aLineOn2S, Standard_False);
+
+	  for(v = 1; v <= aTmpWLine->NbVertex(); v++) {
+	    IntPatch_ThePointOfIntersection aVertex = aTmpWLine->Vertex(v);
+	    avertexindex = (Standard_Integer)aVertex.ParameterOnLine();
+
+	    if(avertexindex >= k) {
+	      aVertex.SetParameter(aVertex.ParameterOnLine() - 1.);
+	    }
+	    aLocalWLine->AddVertex(aVertex);
+	  }
+	  //
+	  aLineOn2S->RemovePoint(k);
+	  aNbP=aLineOn2S->NbPoints();
+	  anEndIndex--;
+	  continue;
+	} //if (aD2<aTol2) 
+      } //if(i != k)
+      k++;
+    } //while(k <= anEndIndex) 
+  } //
+  //
+  aNbP=aLineOn2S->NbPoints();
+  if(aNbP>1) {
+    aResult = aLocalWLine;
+  }
+  return aResult;
+}
+//modified by NIZNHY-PKV Thu Feb 12 11:54:21 2009t
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_ShrunkRange.cxx OpenCASCADE6.3.0/ros/src/IntTools/IntTools_ShrunkRange.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_ShrunkRange.cxx	2010-07-04 20:15:38.785963083 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_ShrunkRange.cxx	2010-03-19 08:52:54.000000000 +0100
@@ -19,6 +19,8 @@
 #include <BndLib_Add3dCurve.hxx>
 
 #include <IntTools_Tools.hxx>
+#include <ElCLib.hxx>
+#include <gp_Lin.hxx>
 
 //=======================================================================
 //function : IntTools_ShrunkRange
@@ -94,39 +96,68 @@
   void IntTools_ShrunkRange::Perform()
 {
   Standard_Real aCF, aCL, aTolE, aTolV1, aTolV2, t1, t11, t1C, t2, t12, t2C;
-  Standard_Real aCoeff=2., dt1, dt2, aR;
+  Standard_Real aCoeff, dt1, dt2, aR;
   Standard_Integer pri;
   Standard_Boolean bInf1, bInf2;
-  
-
+  GeomAbs_CurveType aCurveType;
+  Handle(Geom_Curve) aC;
+  //
   aTolE =BRep_Tool::Tolerance(myEdge);
   aTolV1=BRep_Tool::Tolerance(myV1);
   aTolV2=BRep_Tool::Tolerance(myV2);
-
-  dt1=aCoeff*(aTolV1+aTolE);
-  dt2=aCoeff*(aTolV2+aTolE);
-
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:17 2010f
+  //dt1=aCoeff*(aTolV1+aTolE);
+  //dt2=aCoeff*(aTolV2+aTolE);
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:23 2010t
   myRange.Range (t1, t2);
-
   BRepAdaptor_Curve aBAC(myEdge);
-  GeomAbs_CurveType aCurveType=aBAC.GetType();
-
-  Handle(Geom_Curve) aC=BRep_Tool::Curve(myEdge, aCF, aCL);
+  aCurveType=aBAC.GetType();
+  //
+  aC=BRep_Tool::Curve(myEdge, aCF, aCL);
   BRep_Tool::Range(myEdge, aCF, aCL);
-  
+  //
   if (t1 < aCF || t2 > aCL) {
     myErrorStatus=2;
     return;
   }
-
+  //
   if (t1 > t2 ) {
     myErrorStatus=3;
     return;
   }
   //
+  aCoeff=2.;
+  //
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:30 2010f
+  if (aCurveType==GeomAbs_Line) {
+    Standard_Real aTV1, aTV2, aEps;
+    gp_Pnt aPV1, aPV2, aPC1, aPC2;
+    gp_Lin aL;
+    //
+    aEps=Precision::Confusion();
+    aEps=aEps*aEps;//1.e-14;
+    aL=aBAC.Line();
+    //
+    aPV1=BRep_Tool::Pnt(myV1);
+    aTV1=ElCLib::Parameter(aL, aPV1);
+    //
+    aPV2=BRep_Tool::Pnt(myV2);
+    aTV2=ElCLib::Parameter(aL, aPV2);
+    //
+    if (fabs(aTV1-aCF)<aEps && fabs(aTV2-aCL)<aEps) {
+      aCoeff=1.;
+    }
+  }
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:38 2010t
+  //
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:43 2010f
+  dt1=aCoeff*(aTolV1+aTolE);
+  dt2=aCoeff*(aTolV2+aTolE);
+  //modified by NIZNHY-PKV Fri Mar 19 10:52:48 2010t
+  //
   if (aCurveType==GeomAbs_Line) {
     Standard_Real dt1x, dt2x;
-
+    //
     dt1x = aBAC.Resolution(dt1);
     t11=t1+dt1x;
     
diff -Naur OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Tools.cxx OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Tools.cxx
--- OpenCASCADE6.3.0.orig//ros/src/IntTools/IntTools_Tools.cxx	2010-07-04 20:15:38.742631775 +0200
+++ OpenCASCADE6.3.0/ros/src/IntTools/IntTools_Tools.cxx	2009-02-05 10:17:06.000000000 +0100
@@ -199,7 +199,7 @@
   Standard_Integer IntTools_Tools::SplitCurve(const IntTools_Curve& IC,
 					      IntTools_SequenceOfCurves& aCvs)
 {
-  Handle (Geom_Curve)   aC3D =IC.Curve();
+  Handle (Geom_Curve) aC3D =IC.Curve();
   if(aC3D.IsNull())
     return 0;
   //
@@ -213,11 +213,21 @@
   }
 
   Standard_Real aF, aL, aMid;
-
+  
+  //
   aF=aC3D->FirstParameter();
-  aL=aC3D-> LastParameter();
+  aL=aC3D->LastParameter();
   aMid=0.5*(aF+aL);
-
+  //modified by NIZNHY-PKV Thu Feb  5 08:26:58 2009 f
+  GeomAdaptor_Curve aGAC(aC3D);
+  GeomAbs_CurveType aCT=aGAC.GetType();
+  if (aCT==GeomAbs_BSplineCurve ||
+      aCT==GeomAbs_BezierCurve) {
+    //aMid=0.5*aMid;
+    aMid=IntTools_Tools::IntermediatePoint(aF, aL);
+  }
+  //modified by NIZNHY-PKV Thu Feb  5 08:27:00 2009 t
+  //
   Handle(Geom_Curve) aC3DNewF, aC3DNewL;
   aC3DNewF =new Geom_TrimmedCurve  (aC3D, aF, aMid);
   aC3DNewL =new Geom_TrimmedCurve  (aC3D, aMid, aL);
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_attri.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_attri.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_attri.c	2010-07-04 20:15:21.113003891 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_attri.c	2008-11-07 12:34:24.000000000 +0100
@@ -57,11 +57,11 @@
 ************************************************************************/
 
 #define BUC60577        /*GG_101099     Enable to compute correctly
-//                      transparency with more than one object in the view.
+                      transparency with more than one object in the view.  
 */
 
 #define IMP190100       /*GG     Push and Pop polyline type and width
-//                      attributes correctly.
+                      attributes correctly.
 */
 
 #define G003            /*EUG   degeneration mode management
@@ -192,8 +192,8 @@
     TEL_ALIGN_DATA  TextAlign;
 /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
     Tint            PolymarkerType;
-    Tint            InteriorReflectanceEquation;
-    Tint            BackInteriorReflectanceEquation;
+    Tint   InteriorReflectanceEquation;
+    Tint   BackInteriorReflectanceEquation;
     TEL_SURF_PROP   SurfaceAreaProperties;
     TEL_SURF_PROP   BackSurfaceAreaProperties;
     TelCullMode     FaceCullingMode;
@@ -267,8 +267,8 @@
       0 }, /*Vertical Text Alignment*/
     /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
     TEL_PM_PLUS,            /* PolymarkerType */
-    CALL_PHIGS_REFL_NONE,      /* InteriorReflectanceEquation */
-    CALL_PHIGS_REFL_NONE,      /* BackInteriorReflectanceEquation */
+    CALL_PHIGS_REFL_NONE,          /* InteriorReflectanceEquation */
+    CALL_PHIGS_REFL_NONE,          /* BackInteriorReflectanceEquation */
     { 0.2F, 0.8F, 0.1F, 0.0F,  /* Coef d eclairage */
       1.0F, 10.0F, 0.0F,  
       1,  1,  1,  0, 0,          /* Etat des eclairage */
@@ -849,7 +849,7 @@
 #ifdef GER61394
                         if( antiAliasingMode & 2 ) glEnable(GL_POLYGON_SMOOTH);
 #endif
-                        glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
+						glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); 
                         glEnable (GL_BLEND);
                     }
                 }
@@ -1454,7 +1454,7 @@
 	    /* ABD 29/10/04  Transform Persistence of Presentation( pan, zoom, rotate ) */
 	    /*case TelTransformPersistenceFlag:	      
 	      k[ i ] -> data.ldata = attri_tail->TransPersFlag;
-              //transform_persistence_begin( attri_tail->TransPersFlag );
+              transform_persistence_begin( attri_tail->TransPersFlag );     
 	      break;
             */
             case  TelTransformPersistence:
@@ -1539,7 +1539,7 @@
     printf(" controle mode rm == CALL_PHIGS_REFL_NONE : %d\n",  rm == CALL_PHIGS_REFL_NONE);
 #endif
 
-    if( rm == CALL_PHIGS_REFL_NONE ) return;
+    if( rm == CALL_PHIGS_REFL_NONE ) return; 
 
     /* 
      * Gestion de la transparence 
@@ -1785,7 +1785,7 @@
         }
         else
         {
-            newDiff3 = 1.0F;
+                      newDiff3 = 1.0F;
             if (SecondPassDo)
             {
                 newDiff3 = prop->env_reflexion; 
@@ -1803,11 +1803,24 @@
 	       differs from the previous value  */
             if (  mDiff[0] != 0.0 || mDiff[1] != 0.0 || mDiff[2] != 0.0 
                   || fabs(mDiff[3] - newDiff3) > 0.01 )
+
             {
                 mDiff[0] = 0.0F;
                 mDiff[1] = 0.0F;
                 mDiff[2] = 0.0F;
                 mDiff[3] = newDiff3;
+            
+                if (SecondPassDo)
+                {
+                    mDiff[3] = prop->env_reflexion; 
+                }
+                else
+                {
+                    if (need_trans) mDiff[3] = prop->trans;
+                    /* si le materiau reflechi la scene environnante,
+                       alors il faudra faire une seconde passe */
+                    if (prop->env_reflexion != 0.0) SecondPassNeeded = 1;
+                }
 
                 glMaterialfv(face, GL_DIFFUSE, mDiff);
 #ifdef TRACE_MATERIAL
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_execstruct.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_execstruct.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_execstruct.c	2010-07-04 20:15:21.522994253 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_execstruct.c	2008-11-07 12:38:30.000000000 +0100
@@ -28,8 +28,11 @@
   	   16-06-2000 : ATS,GG : G005 : Some conditions for execution of PARRAY  primitives
 
 ************************************************************************/
+#ifdef DEBUG
+#define TRACE
+#define TRACE_EXEC
+#endif
 
-#define xTRACE
 #define G003	/* EUG 16-09-99 G003 ZBufferAuto treatment 
 */
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_GraphicDriver.cxx OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_GraphicDriver.cxx
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_GraphicDriver.cxx	2010-07-04 20:15:21.429652468 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_GraphicDriver.cxx	2008-11-07 12:35:24.000000000 +0100
@@ -1,38 +1,38 @@
+/*
+ File         OpenGl_GraphicDriver.cxx
+ Created      Mardi 28 janvier 1997
+ Author       CAL
 
-// File         OpenGl_GraphicDriver.cxx
-// Created      Mardi 28 janvier 1997
-// Author       CAL
+-Copyright    MatraDatavision 1997
 
-//-Copyright    MatraDatavision 1997
+-Version      
 
-//-Version      
+-Design       Declaration des variables specifiques aux Drivers
+-Warning      Un driver encapsule les Pex, Phigs et OpenGl drivers
 
-//-Design       Declaration des variables specifiques aux Drivers
+-References   
 
-//-Warning      Un driver encapsule les Pex, Phigs et OpenGl drivers
+-Language     C++ 2.0
 
-//-References   
+-Declarations
 
-//-Language     C++ 2.0
-
-//-Declarations
-
-// for the class
+ for the class
+*/
 #include <OpenGl_GraphicDriver.ixx>
 
 #ifdef WNT
 #include <malloc.h>
 #endif
-
-//-Aliases
-
-//-Global data definitions
-
-// Pour eviter de "mangler" MetaGraphicDriverFactory, le nom de la
-// fonction qui cree un Graphic3d_GraphicDriver.
-// En effet, ce nom est recherche par la methode DlSymb de la
-// classe OSD_SharedLibrary dans la methode SetGraphicDriver de la
-// classe Graphic3d_GraphicDevice
+/*
+-Aliases
+-Global data definitions
+
+ Pour eviter de "mangler" MetaGraphicDriverFactory, le nom de la
+ fonction qui cree un Graphic3d_GraphicDriver.
+ En effet, ce nom est recherche par la methode DlSymb de la
+ classe OSD_SharedLibrary dans la methode SetGraphicDriver de la
+ classe Graphic3d_GraphicDevice
+*/
 extern "C" {
 #ifdef WNT /* disable MS VC++ warning on C-style function returning C++ object */
 #pragma warning(push)
@@ -44,22 +44,25 @@
                 (const Standard_CString AShrName) {
                   Handle(OpenGl_GraphicDriver)  aOpenDriver = new OpenGl_GraphicDriver (AShrName);
                   return aOpenDriver;
-//              return new OpenGl_GraphicDriver (AShrName);
+/*              return new OpenGl_GraphicDriver (AShrName);  */
         }
 #ifdef WNT
 #pragma warning(pop)
 #endif
 }
 
-//-Constructors
+/*-Constructors   */
 
 OpenGl_GraphicDriver::OpenGl_GraphicDriver (const Standard_CString AShrName):Graphic3d_GraphicDriver (AShrName) 
 {
-
+  /* Change this if traceing OpenGl_GraphicDriver method calls is needed      */
+#if 0
+	SetTrace(1);
+#endif
+	
 #ifdef WNT
     _set_sbh_threshold(1016);
 #endif
-  
 }
 
-//-Methods, in order
+/*-Methods, in order    */
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_initelem.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_initelem.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_initelem.c	2010-07-04 20:15:21.236328494 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_initelem.c	2008-11-07 12:35:42.000000000 +0100
@@ -982,14 +982,14 @@
    Tint         i, k1, k2, offset;
    unsigned     char raster[] = {
 
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0xff,0x80,
-                                          0x08,0x00,
-                                          0x08,0x00,
-                                          0x08,0x00,
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0xff,0x80,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
+                                          0x08,0x00,  
                                           0x08,0x00,  /* PLUS 9x9 = 1.0 */
 
                                           0x04,0x00,
@@ -2193,8 +2193,6 @@
 #ifdef OCC7667
       GLsizei w, h, size, j;
 #endif
-
-
       k1 = i / TEL_NO_OF_SIZES;
       k2 = i % TEL_NO_OF_SIZES;
       offset = array[k1][k2].offset;
@@ -2207,9 +2205,14 @@
       glNewList( (GLuint) array[k1][k2].str[0]+markerBase, GL_COMPILE);
 
 #ifdef OCC7667
-      glBitmap( w, h, (float)(array[k1][k2].width) / ( float )2.0,
+
+#if 1
+	  glBitmap( w, h, (float)(array[k1][k2].width) / ( float )2.0,
                       (float)(array[k1][k2].height) / ( float )2.0,
                       ( float )30.0,  ( float )30.0, (const GLubyte *) &raster[offset]);
+#else
+      glBitmap( w, h, (float) (w / 2), (float) (h / 2), 30.0f, 30.0f, (const GLubyte *) &raster[offset]);
+#endif
 
       glPassThrough( GL2PS_MARKER );
       glPassThrough( ( GLfloat ) array[k1][k2].width );
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_LightBox.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_LightBox.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_LightBox.c	2010-07-04 20:15:21.216331079 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_LightBox.c	2008-11-07 12:35:54.000000000 +0100
@@ -56,8 +56,10 @@
 /*
  * Constantes
  */
-
+#ifndef DEBUG
 #define DEBUG 0
+#endif
+
 #define NO_PRINT_DEBUG
 
 #define GROW_SIZE_WKS 10
@@ -554,16 +556,12 @@
 void LightOn(void)
 {
 #ifdef PRINT_DEBUG
-    if (!lightOn)
-	printf("LightOn() \n");
-    else
-	printf("LightOn() inutile \n");
+  if(IsLightOn())
+    printf("LightOn(): lighting already enabled!");
+  else
+    printf("LightOn() succeeded");
 #endif
-    if (!lightOn)
-    {
-	glEnable(GL_LIGHTING);
-	lightOn = GL_TRUE;
-    }
+  glEnable(GL_LIGHTING);
 }
 
 
@@ -574,16 +572,12 @@
 void LightOff(void)
 {
 #ifdef PRINT_DEBUG
-    if (lightOn)
-	printf("LightOff() \n");
-    else
-	printf("LightOff() inutile \n");
+  if(!IsLightOn())
+    printf("LightOff(): lighting already disabled!");
+  else
+    printf("LightOff() succeeded");
 #endif
-    if (lightOn)
-    {
-	glDisable(GL_LIGHTING);
-	lightOn = GL_FALSE;
-    }
+  glDisable(GL_LIGHTING);
 }
 /*-----------------------------------------------------------------*/
 
@@ -593,6 +587,6 @@
  
 GLboolean IsLightOn(void)
 {
-   return (lightOn);
+   return glIsEnabled(GL_LIGHTING);
 }
 /*-----------------------------------------------------------------*/
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_PrimitiveArray.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_PrimitiveArray.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_PrimitiveArray.c	2010-07-04 20:15:21.496328286 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_PrimitiveArray.c	2008-11-14 13:51:42.000000000 +0100
@@ -473,7 +473,7 @@
 				if( pfc ) glColor3fv  ( pfc[i].rgb  );
 				if( renderMode == GL_FEEDBACK )
 					draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                 GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                 GL_UNSIGNED_INT,(GLenum*) &p->edges[n]);
 				else
 					glDrawElements( draw_mode, p->bounds[i], 
                                GL_UNSIGNED_INT, &p->edges[n]);
@@ -493,7 +493,7 @@
 	  } else if( p->num_edges > 0 ) {
 			if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                  GL_UNSIGNED_INT, (GLenum*) &p->edges[0]);
+                                  GL_UNSIGNED_INT,(GLenum*) &p->edges[0]);
 			else
 				glDrawElements( draw_mode, p->num_edges, 
                                 GL_UNSIGNED_INT, p->edges);
@@ -809,8 +809,8 @@
 {
     Tint    i, j, n;
     Tint    edge_type=0, line_type_preserve=0;
-    Tfloat  edge_width=0, line_width_preserve=0;
-    /*GLboolean texture_on;*/
+    Tfloat  edge_width=0, line_width_preserve=0; 
+    /* GLboolean texture_on;*/
 
 	GLint renderMode;
     
@@ -875,7 +875,7 @@
 #endif
 		  if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                 GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                 GL_UNSIGNED_INT, (GLenum*)&p->edges[n]);
 		  else
 				glDrawElements( draw_mode, p->bounds[i], 
                                 GL_UNSIGNED_INT, &p->edges[n]);
@@ -903,7 +903,7 @@
 #endif
 	  if( renderMode == GL_FEEDBACK )
 			draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                GL_UNSIGNED_INT, (GLenum*) p->edges);
+                                GL_UNSIGNED_INT,(GLenum*) p->edges);
 	  else
 			glDrawElements( draw_mode, p->num_edges, 
                                 GL_UNSIGNED_INT, p->edges);
@@ -1641,7 +1641,7 @@
           for( i=n=0 ; i<p->num_bounds ; i++ ) {
 			if( renderMode == GL_FEEDBACK )
 				draw_primitive_elements( p, draw_mode, p->bounds[i], 
-                                GL_UNSIGNED_INT, (GLenum*) &p->edges[n]);
+                                GL_UNSIGNED_INT,(GLenum*) &p->edges[n]);
 			else
 				glDrawElements( draw_mode, p->bounds[i],
                                 GL_UNSIGNED_INT, &p->edges[n]);
@@ -1659,7 +1659,7 @@
       } else if( p->num_edges > 0 ) {
 		if( renderMode == GL_FEEDBACK )
 			draw_primitive_elements( p, draw_mode, p->num_edges, 
-                                GL_UNSIGNED_INT, (GLenum*) p->edges);
+                                GL_UNSIGNED_INT,(GLenum*) p->edges);
 		else
 			glDrawElements( draw_mode, p->num_edges,
                                 GL_UNSIGNED_INT, p->edges);
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_subrvis.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_subrvis.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_subrvis.c	2010-07-04 20:15:21.609660780 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_subrvis.c	2008-11-07 12:36:32.000000000 +0100
@@ -60,17 +60,17 @@
 
 #ifdef WNT
 #define BUC60579        /*GG_240999 Under WNT,resets the ws attributes for each
-//                        created view-manager and not only for the first
+                        created view-manager and not only for the first
 */
 #endif
 
 #define IMP190100	/*GG Reverse the front & back depth cueing planes
-//			position.
+			position.
 */
 
 #define RIC120302	/*GG Use TxglSetWindow instead TxglCreateWindow
-//			when a GLXContext is given
-//			Add call_subr_displayCB function
+			when a GLXContext is given
+			Add call_subr_displayCB function
 */
 
 #define  BUC61044    /* 25/10/01 SAV ; added functionality to control gl depth testing
@@ -735,8 +735,17 @@
 call_subr_close_ws( CALL_DEF_VIEW * aview )
 {
     CMN_KEY_DATA key;
+
+/* PCD 26/06/07 ------ Starts */
 #ifdef OCC1188
     tsm_bg_texture texture;
+#endif
+    /* make sure the proper rendering context is current */
+    TsmGetWSAttri( aview->WsId, WSWindow, &key );
+    TxglWinset( call_thedisplay, (Window) key.ldata );
+
+#ifdef OCC1188
+/* PCD 26/06/07 ------ Ends */
 
     TsmGetWSAttri( aview->WsId, WSBgTexture, &key );
     texture = key.pdata;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_telem_util.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_telem_util.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_telem_util.c	2010-07-04 20:15:21.009648210 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_telem_util.c	2008-11-07 12:36:46.000000000 +0100
@@ -3,18 +3,18 @@
      FONCTION :
      ----------
         File OpenGl_telem_util :
- 
+
 
      REMARQUES:
-     ---------- 
-      
+     ----------
+
 
      HISTORIQUE DES MODIFICATIONS   :
      --------------------------------
        xx-xx-xx : xxx ; Creation.
        07-02-96 : FMN ; - Ajout trace
 			- Suppression code inutile
-       08-03-96 : FMN ; - Ajout include manquant 
+       08-03-96 : FMN ; - Ajout include manquant
        01-04-96 : CAL ; Integration MINSK portage WNT
        15-04-96 : CAL ; Integration travail PIXMAP de Jim ROTH
        22-04-96 : FMN ; Ajout TelReadImage TelDrawImage
@@ -35,7 +35,7 @@
        18-07-97 : FMN ; Utilisation de la toolkit sur les lights
        07-10-97 : FMN ; Simplification WNT + correction Transient
        05-12-97 : FMN ; PRO11168: Suppression TglActiveWs pour project/unproject
-       23-12-97 : FMN ; Suppression TelSetFrontFaceAttri et TelSetBackFaceAttri 
+       23-12-97 : FMN ; Suppression TelSetFrontFaceAttri et TelSetBackFaceAttri
        30-12-97 : FMN ; CTS18312: Correction back material
        04-05-98 : CAL ; Contournement bug SGI octane bavure de pixels (PRO12899)
        30-09-98 : CAL ; Optimisation pour eviter de charger inutilement
@@ -49,8 +49,9 @@
 ************************************************************************/
 
 #define IMP190100	/*GG To avoid too many REDRAW in immediat mode,
-//			Add TelMakeFrontAndBackBufCurrent() function
+			Add TelMakeFrontAndBackBufCurrent() function
 */
+#define QTOCC_PATCH
 
 /*----------------------------------------------------------------------*/
 /*
@@ -104,7 +105,7 @@
 /*
  * Variables statiques
  */
- 
+
 static Tint call_back_buffer_restored = TOff;
 
 #ifndef WNT
@@ -233,10 +234,10 @@
 TelRemdupnames(Tint *ls, Tint num )
 {
     register  Tint  *ap, *bp, n;
-    
+
     if( num < 2 )
     return num;
-    
+
     ap = bp = ls+1;
     n = num-1;
     while( n-- )
@@ -246,7 +247,7 @@
     else
     bp++;
     }
-    
+
     return ap-ls;
 }
 
@@ -255,9 +256,9 @@
 #define GPRECIS 0.000001
 Tint TelGetPolygonNormal(tel_point pnts, Tint* indexs, Tint npnt, Tfloat *norm ) {
     Tint status=0;
-   
+
     norm[0] = norm[1] = norm[2] = 0.;
-    if( npnt > 2 ) { 
+    if( npnt > 2 ) {
       Tfloat a[3], b[3], c[3];
       Tint i,j,i0,ii=0,jj;
 
@@ -314,7 +315,7 @@
 void
 TelGetNormal(Tfloat *data1, Tfloat *data2, Tfloat *data3, Tfloat *norm ) {
     Tfloat a[3], b[3];
-    
+
     vecsub( a, data2, data1 );
     vecsub( b, data3, data2 );
     veccrs( norm, a, b );
@@ -326,12 +327,12 @@
 TelIsBackFace(Tmatrix3 n, Tfloat *nrm )
 {
     Tfloat    r[4], m[4];
-    
+
     veccpy(m,nrm);
     m[3] = ( float )1.0;
-    
+
     TelTranpt3( r, m, n );
-    
+
     return r[2] < 0.0;
 }
 
@@ -384,7 +385,7 @@
 {
     register  long  i, j;
     Tfloat    sum;
-    
+
     for( i = 0; i < 4; i++ )
     {
     for( j = 0, sum = ( float )0.0; j < 4; j++ )
@@ -428,15 +429,15 @@
 	}
 	else
 	{
-	    glDrawBuffer(GL_FRONT_AND_BACK);
-	    glClearColor(bgcolr, bgcolg, bgcolb, ( float )1.0);
-	    glClear(GL_COLOR_BUFFER_BIT);
+		/* QTOCC_PATCH by PCD: the frame buffer should not be cleared here
+		   to avoid flicker. It is cleared properly in TelClearViews() 
+		   called by call_func_redraw_all_structs_begin() */
 	    glDrawBuffer(GL_BACK);
 	}
 #else
-	glDrawBuffer(GL_FRONT_AND_BACK);
-	glClearColor(bgcolr, bgcolg, bgcolb, ( float )1.0);
-	glClear(GL_COLOR_BUFFER_BIT);
+	/* QTOCC_PATCH by PCD: the frame buffer should not be cleared here
+	   to avoid flicker. It is cleared properly in TelClearViews() 
+	   called by call_func_redraw_all_structs_begin() */
 	glDrawBuffer(GL_BACK);
 #endif /* WNT */
     }
@@ -446,6 +447,7 @@
 	glClear(GL_COLOR_BUFFER_BIT);
     }
     return;
+
 }
 
 
@@ -455,7 +457,7 @@
 #ifndef WNT
 
     CMN_KEY_DATA data;
-   
+
     if (TelTestPixmapDB())
     {
         glFlush();
@@ -468,9 +470,9 @@
 	TsmGetWSAttri( ws, WSWindow, &data );
         glXSwapBuffers ( call_thedisplay, data.ldata );
     }
- 
+
 #else
-    
+
     SwapBuffers ( wglGetCurrentDC () );
     TelFlush(0);
 
@@ -545,7 +547,7 @@
 	glLoadIdentity ();
 
 	TelDisable (ws);
-	if (flag) 
+	if (flag)
 	{
 	    /*
 	     * calcul de la projection de la boite
@@ -565,7 +567,7 @@
 	    &&  (TelProjectionRaster (ws, xm, ym, ZM, &xr[4], &yr[4]) == TSuccess)
 	    &&  (TelProjectionRaster (ws, xm, YM, ZM, &xr[5], &yr[5]) == TSuccess)
 	    &&  (TelProjectionRaster (ws, XM, YM, ZM, &xr[6], &yr[6]) == TSuccess)
-	    &&  (TelProjectionRaster (ws, XM, ym, ZM, &xr[7], &yr[7]) == TSuccess)) 
+	    &&  (TelProjectionRaster (ws, XM, ym, ZM, &xr[7], &yr[7]) == TSuccess))
 	    {
 		xmr = ymr = (float ) shortreallast ();
 		XMR = YMR = (float ) shortrealfirst ();
@@ -581,7 +583,7 @@
 		/* pour eviter les bavures de pixels ! */
 		xmr--;ymr--;
 		XMR++;YMR++;
-    
+
 		/*
 		 * Ajout CAL : 10/05/96
 		 * Si les MinMax viennent d'un ensemble de markers
@@ -594,7 +596,7 @@
 		 */
 		xmr -= CALL_DEF_DELTA; ymr -= CALL_DEF_DELTA;
 		XMR += CALL_DEF_DELTA; YMR += CALL_DEF_DELTA;
-    
+
 		/*
 		 * Le rectangle projete peut-etre clippe
 		 */
@@ -619,7 +621,7 @@
 		if (ymr < 0) { height = (GLsizei) (YMR+1); ymr = 0; }
 		if (XMR > w) { width  = (GLsizei) (w-xmr+1); }
 		if (YMR > h) { height = (GLsizei) (h-ymr+1); }
-    
+
 		/* cas ou les 2 coins sont en dehors de la fenetre */
 		if (XMR < 0) { xmr = 0; width = height = 1; }
 		if (YMR < 0) { ymr = 0; width = height = 1; }
@@ -639,7 +641,7 @@
 		glCopyPixels ((GLint) xmr, (GLint) ymr, width, height, GL_COLOR);
 		/* TelFlush (1); */
 	    }
-	    else 
+	    else
 	    {
 		glDrawBuffer (to);
 		/* TelClearViews (ws); */
@@ -650,7 +652,7 @@
 		/* TelFlush (1); */
 	    }
 	}
-	else 
+	else
 	{
 	    glDrawBuffer (to);
 	    /* TelClearViews (ws); */
@@ -666,7 +668,7 @@
 	glPopMatrix ();
 	glMatrixMode (GL_MODELVIEW);
 	glPopMatrix ();
-    
+
 	glDrawBuffer (GL_BACK);
 	return;
 }
@@ -694,17 +696,17 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
-	glReadBuffer(from); 
-	
+
+	glReadBuffer(from);
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glReadPixels (posx, posy, width, height, GL_RGBA, GL_UNSIGNED_BYTE, image);
 	TelEnable (ws);
-    
-	glReadBuffer(GL_BACK);        
+
+	glReadBuffer(GL_BACK);
     }
-    
+
     return;
 }
 
@@ -731,16 +733,16 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
+
 	glDrawBuffer(to);
-	
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glDrawPixels (width, height, GL_RGBA, GL_UNSIGNED_BYTE, image);
 	TelEnable (ws);
 
-	glDrawBuffer(GL_BACK);     
-    }	    
+	glDrawBuffer(GL_BACK);
+    }
     return;
 }
 
@@ -769,13 +771,13 @@
 	gluOrtho2D ((GLdouble) 0., (GLdouble) w, 0., (GLdouble) h);
 	glMatrixMode (GL_MODELVIEW);
 	glLoadIdentity ();
-	
+
 	glRasterPos2i (posx, posy);
 	TelDisable (ws);
 	glReadPixels (posx, posy, width, height, GL_DEPTH_COMPONENT, GL_FLOAT, depths);
 	TelEnable (ws);
     }
-    
+
     return;
 }
 
@@ -811,7 +813,7 @@
     glDisable(GL_DEPTH_TEST);
     glDisable(GL_FOG);
     LightOff();
-    
+
     glDisable(GL_LOGIC_OP);
     glDisable(GL_STENCIL_TEST);
     glDisable(GL_TEXTURE_1D);
@@ -825,7 +827,7 @@
     glPixelTransferi(GL_BLUE_BIAS, 0);
     glPixelTransferi(GL_ALPHA_SCALE, 1);
     glPixelTransferi(GL_ALPHA_BIAS, 0);
-    
+
     /*
      * Disable extensions that could slow down glDrawPixels.
      * (Actually, you should check for the presence of the proper
@@ -859,15 +861,15 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     GLint status;
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble modelMatrix[16], projMatrix[16];
     GLint viewport[4];
     GLdouble winx, winy, winz;
-    
+
     vid = ws;
 
     if (TelGetViewRepresentation (ws, vid, &vrep) != TSuccess)
@@ -908,7 +910,7 @@
 	*yr = ( Tfloat )winy;
 	return TSuccess;
     }
-    else 
+    else
     {
 	*xr = 0.0F;
 	*yr = 0.0F;
@@ -924,7 +926,7 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble modelMatrix[16], projMatrix[16];
@@ -965,7 +967,7 @@
 
     status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	    &objx, &objy, &objz);
-    
+
     if (status == GL_TRUE) {
 	    *x = ( Tfloat )objx;
 	    *y = ( Tfloat )objy;
@@ -991,7 +993,7 @@
     CMN_KEY_DATA key;
     Tint vid;          /* View index */
     TEL_VIEW_REP vrep; /* View definition */
-    
+
     int i, j, k;
     GLdouble objx, objy, objz;
     GLdouble objx1, objy1, objz1;
@@ -1033,7 +1035,7 @@
 
     status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	    &objx, &objy, &objz);
-    
+
     if (status == GL_TRUE) {
 	    *x = ( Tfloat )objx;
 	    *y = ( Tfloat )objy;
@@ -1042,7 +1044,7 @@
       winz = ( GLdouble ) -10.0;
       status = gluUnProject (winx, winy, winz, modelMatrix, projMatrix, viewport,
 	      &objx1, &objy1, &objz1);
-    
+
       if (status == GL_TRUE) {
         *dx = ( Tfloat )(objx-objx1);
 	*dy = ( Tfloat )(objy-objy1);
@@ -1075,7 +1077,7 @@
 TelFlush(Tint wait)
 {
     if (wait)
-    {    
+    {
 #ifdef TRACE
 	printf("OPENGL: TelFlush: glFinish \n");
 #endif
@@ -1096,21 +1098,21 @@
 TelIsBackFacePerspective(Tmatrix3 n, Tfloat *p1, Tfloat *p2, Tfloat *p3 )
 {
     Tfloat    r1[4], r2[4], r3[4], m[4], norm[4];
-    
+
     veccpy( m, p1 );
     m[3] = ( float )1.0;
     TelTranpt3( r1, m, n );
     r1[0] /= r1[3];
     r1[1] /= r1[3];
     r1[2] /= r1[3];
-    
+
     veccpy( m, p2 );
     m[3] = ( float )1.0;
     TelTranpt3( r2, m, n );
     r2[0] /= r2[3];
     r2[1] /= r2[3];
     r2[2] /= r2[3];
-    
+
     veccpy( m, p3 );
     m[3] = ( float )1.0;
     TelTranpt3( r3, m, n );
@@ -1118,7 +1120,7 @@
     r3[1] /= r3[3];
     r3[2] /= r3[3];
     TelGetNormal( r1, r2, r3, norm );
-    
+
     return norm[2] < 0.0;
 }
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_inquireplane.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_inquireplane.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_inquireplane.c	2010-07-04 20:15:21.572994113 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_inquireplane.c	2008-11-07 12:37:06.000000000 +0100
@@ -1,7 +1,10 @@
 #define GER61454	/*GG 14-09-99 Activates the model clipping planes
-// GG 110800	UNDER LINUX and MESA 3.2, nothing can be done until
-//		gl context is open first.
+ GG 110800	UNDER LINUX and MESA 3.2, nothing can be done until
+		gl context is open first.
 */
+#ifdef DEBUG
+#include <stdio.h>
+#endif
 
 #include <OpenGl_tgl_all.h>
 #include <OpenGl_tgl.h>
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_markercontextgroup.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_markercontextgroup.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_markercontextgroup.c	2010-07-04 20:15:21.243010876 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_markercontextgroup.c	2009-08-19 08:44:09.000000000 +0200
@@ -101,6 +101,10 @@
 
     UDMS_Marker.IdList[anIndex] = theId;
     UDMS_Marker.DisplayIdList[anIndex] = glGenLists( 1 );
+
+    glPixelStorei( GL_UNPACK_ALIGNMENT, 1 );
+    glPixelStorei( GL_PACK_ALIGNMENT, 1 );
+
     glNewList( UDMS_Marker.DisplayIdList[anIndex], GL_COMPILE );
 
 #ifdef OCC7667
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_redraw.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_redraw.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_redraw.c	2010-07-04 20:15:21.076344139 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_redraw.c	2008-11-07 12:39:30.000000000 +0100
@@ -24,19 +24,21 @@
        02.01.100 : JR : = 0 for Integer and = NULL for pointers
        02.02.100   "    #include <GL/glu.h> for declaration of gluErrorString
        07-03-00 : GG : G004 use the already created pixmap.
-                        Enable two side lighting before redrawing in pixmap.
+		             Enable two side lighting before redrawing in pixmap.
 
 ************************************************************************/
 
-#define G004    /* VKH 15-11-99 redrawing view to a large pixmap
+#define G004	/* VKH 15-11-99 redrawing view to a large pixmap
 */
 
-#define IMP100701       /* GG Enable to display the view in
-                        a pixamp with the required depth.
+#define IMP100701	/*  GG Enable to display the view in
+			      a pixamp with the required depth.
 */
 
-#define RIC120302       /* GG Enable to use the application display
-//                      callback at end of traversal
+#define RIC120302	/*  GG Enable to use the application display
+			          callback at end of traversal
+			          Modified P. Dolbey 09/06/07 to call back
+                           before redrawing the overlayer
 */
 
 /*----------------------------------------------------------------------*/
@@ -62,7 +64,7 @@
    CALL_DEF_LAYER * anunderlayer,
    CALL_DEF_LAYER * anoverlayer
 
-        Redraws all the structures displayed in the specified view.
+	Redraws all the structures displayed in the specified view.
 
    call_togl_redraw_area (aview, anunderlayer, anoverlayer, x, y, width, height)
    CALL_DEF_VIEW * aview,
@@ -70,8 +72,8 @@
    CALL_DEF_LAYER * anoverlayer,
    int x,y,width,height
 
-        Redraws all the structures displayed in the specified view area
-        defined by it upper-left corner and pixel size.
+	Redraws all the structures displayed in the specified view area
+	defined by it upper-left corner and pixel size.
 */
 
 #ifdef G004
@@ -88,17 +90,18 @@
                                        int  nBitsPerPixel);
 
 extern GLboolean OpenGl_AVIWriter_AllowWriting();
+
 #endif
 GLboolean g_fBitmap;
-#endif  /*G004*/
+#endif	/*G004*/
 
 
 void EXPORT
 call_togl_redraw
 (
-        CALL_DEF_VIEW * aview,
-        CALL_DEF_LAYER * anunderlayer,
-        CALL_DEF_LAYER * anoverlayer
+	CALL_DEF_VIEW * aview,
+	CALL_DEF_LAYER * anunderlayer,
+	CALL_DEF_LAYER * anoverlayer
 )
 {
   CMN_KEY_DATA data;
@@ -106,25 +109,33 @@
 
   if ( TsmGetWSAttri (aview->WsId, WSWindow, &data) != TSuccess ) return;
 #ifdef G004
-  if ( !aview->DefBitmap.bitmap ) { /* redrawing view to the window */
-#endif
-    if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
-      call_func_redraw_all_structs_begin (aview->WsId);
-      if (anunderlayer->ptrLayer)
-        call_togl_redraw_layer2d (aview, anunderlayer);
-      call_func_redraw_all_structs_proc (aview->WsId);
-      if (anoverlayer->ptrLayer)
-        call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-      call_subr_displayCB(aview,OCC_REDRAW_WINDOW);
+  if ( !aview->DefBitmap.bitmap ) {	/* redrawing view to the window */
 #endif
-      call_func_redraw_all_structs_end (aview->WsId, swap);
-      call_togl_redraw_immediat_mode (aview);
-    }
+	if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
+	    call_func_redraw_all_structs_begin (aview->WsId);
+	    if (anunderlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anunderlayer);
+	    call_func_redraw_all_structs_proc (aview->WsId);
+
+		/* Proposed by P.Dolbey and revised to keep also the old callback */
+        #ifdef RIC120302
+			 call_subr_displayCB(aview, OCC_REDRAW_WINDOW | OCC_PRE_OVERLAY );
+		#endif
+
+		if (anoverlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anoverlayer);
+
+		#ifdef RIC120302
+			 call_subr_displayCB(aview,OCC_REDRAW_WINDOW);
+		#endif
+		
+	    call_func_redraw_all_structs_end (aview->WsId, swap);
+	    call_togl_redraw_immediat_mode (aview);
+	}
 #ifdef G004
-  } else {
-    CMN_KEY_DATA          pixdata;
-    GLenum                errorcode = 0;
+   } else {
+     CMN_KEY_DATA          pixdata;
+     GLenum                errorcode = 0;
 #ifndef WNT
     int  n,sdesc[11];
     XVisualInfo*        XVInfo = NULL;
@@ -134,8 +145,8 @@
 
     XGetWindowAttributes ( call_thedisplay, (Window)data.ldata , &wattr );
 #ifdef IMP100701
-    if( aview->DefBitmap.depth > 0 )
-      wattr.depth = aview->DefBitmap.depth;
+   if( aview->DefBitmap.depth > 0 )
+     wattr.depth = aview->DefBitmap.depth;
 #endif
     n = 0;
     sdesc[n] = GLX_RGBA; n++;
@@ -151,33 +162,33 @@
     sdesc[n] = ( wattr.depth <= 8 ) ? 0 : 1; n++;
     sdesc[n] = GLX_BLUE_SIZE; n++;
     sdesc[n] = ( wattr.depth <= 8 ) ? 0 : 1; n++;
-#ifdef BUG      /* Redraw always in single buffer mode and don't swap ! */
+#ifdef BUG	/* Redraw always in single buffer mode and don't swap ! */
     char                string[CALL_DEF_STRING_LENGTH];
     if ( !call_util_osd_getenv ("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH) )
       { sdesc[n] = GLX_DOUBLEBUFFER; n++; }
 #endif
-    sdesc[n] = None; n++;
-
-    XVInfo = glXChooseVisual ( call_thedisplay, DefaultScreen(call_thedisplay), sdesc );
-    if ( !XVInfo ) {
-      fprintf ( stderr, "Visual not available\n" );
-      return;
-    }
+     sdesc[n] = None; n++;
 
-    theContext = glXCreateContext ( call_thedisplay, XVInfo, NULL, GL_FALSE );
-
-    theGLXPixmap = glXCreateGLXPixmap ( call_thedisplay, XVInfo, aview->DefBitmap.bitmap );
-
-    if ( ! glXMakeCurrent (call_thedisplay, theGLXPixmap, theContext) )
-      {
-        errorcode = glGetError ();
-        fprintf ( stderr, "glXMakeCurrent failed: %d %s\n", errorcode, gluErrorString(errorcode) );
-        return;
-      }
+     XVInfo = glXChooseVisual ( call_thedisplay, DefaultScreen(call_thedisplay), sdesc );
+     if ( !XVInfo ) {
+       fprintf ( stderr, "Visual not available\n" );
+       return;
+     }
+
+     theContext = glXCreateContext ( call_thedisplay, XVInfo, NULL, GL_FALSE );
+
+     theGLXPixmap = glXCreateGLXPixmap ( call_thedisplay, XVInfo, aview->DefBitmap.bitmap );
+
+     if ( ! glXMakeCurrent (call_thedisplay, theGLXPixmap, theContext) )
+          {
+             errorcode = glGetError ();
+             fprintf ( stderr, "glXMakeCurrent failed: %d %s\n", errorcode, gluErrorString(errorcode) );
+             return;
+          }
 #else /* WindowsXX code here */
     HGLRC               hglrc_old = wglGetCurrentContext ();
     HDC                 hdc_old = wglGetCurrentDC ();
-    HDC                 hdc = (HDC) aview->DefBitmap.bitmap;
+    HDC		      hdc = (HDC) aview->DefBitmap.bitmap;
     HGLRC               hglrc = wglCreateContext (hdc);
 
     if ( !hglrc || !wglMakeCurrent (hdc, hglrc) )
@@ -187,51 +198,58 @@
         return;
       }
 #endif
-    pixdata.ldata = aview->DefBitmap.width;
-    if ( TsmSetWSAttri (aview->WsId, WSWidth, &pixdata) != TSuccess ) return;
-    pixdata.ldata = aview->DefBitmap.height;
-    if ( TsmSetWSAttri (aview->WsId, WSHeight, &pixdata) != TSuccess ) return;
-
-    /* generate new display lists */
-    TsmInitAttributes();
-
-    glLightModeli((GLenum)GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
-
-    glMatrixMode ( GL_MODELVIEW );
-    glViewport ( 0, 0, aview->DefBitmap.width, aview->DefBitmap.height );
-
-    glDrawBuffer ( GL_FRONT );
-
-    /* redrawing ... */
-    g_fBitmap = GL_TRUE;
-    call_func_redraw_all_structs_begin (aview->WsId);
-    if (anunderlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anunderlayer);
-    call_func_redraw_all_structs_proc (aview->WsId);
-    if (anoverlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-    call_subr_displayCB(aview,OCC_REDRAW_BITMAP);
-#endif
-    call_func_redraw_all_structs_end (aview->WsId, 0);
+          pixdata.ldata = aview->DefBitmap.width;
+          if ( TsmSetWSAttri (aview->WsId, WSWidth, &pixdata) != TSuccess ) return;
+          pixdata.ldata = aview->DefBitmap.height;
+          if ( TsmSetWSAttri (aview->WsId, WSHeight, &pixdata) != TSuccess ) return;
+
+          /* generate new display lists */
+          TsmInitAttributes();
+
+          glLightModeli((GLenum)GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
+
+          glMatrixMode ( GL_MODELVIEW );
+          glViewport ( 0, 0, aview->DefBitmap.width, aview->DefBitmap.height );
+
+          glDrawBuffer ( GL_FRONT );
+
+          /* redrawing ... */
+          g_fBitmap = GL_TRUE;
+          call_func_redraw_all_structs_begin (aview->WsId);
+          if (anunderlayer->ptrLayer)
+          	call_togl_redraw_layer2d (aview, anunderlayer);
+          call_func_redraw_all_structs_proc (aview->WsId);
+
+			/* Proposed by P.Dolbey and revised to keep also the old callback */
+			#ifdef RIC120302
+				 call_subr_displayCB(aview,OCC_REDRAW_BITMAP |OCC_PRE_OVERLAY);
+			#endif
+      
+			if (anoverlayer->ptrLayer)
+          	call_togl_redraw_layer2d (aview, anoverlayer);
+		
+			#ifdef RIC120302
+				 call_subr_displayCB(aview,OCC_REDRAW_BITMAP);
+			#endif
+		
+          call_func_redraw_all_structs_end (aview->WsId, 0);
 
-    call_togl_redraw_immediat_mode (aview);
-    g_fBitmap = GL_FALSE;
+          call_togl_redraw_immediat_mode (aview);
+          g_fBitmap = GL_FALSE;
 
-    glFinish();
+          glFinish();
 
-    /* cleaning up ... */
+          /* cleaning up ... */
 #ifndef WNT
-    glXMakeCurrent ( call_thedisplay, None, NULL );
-    glXDestroyContext ( call_thedisplay, theContext );
-    glXDestroyGLXPixmap ( call_thedisplay, theGLXPixmap );
+          glXMakeCurrent ( call_thedisplay, None, NULL );
+          glXDestroyContext ( call_thedisplay, theContext );
+          glXDestroyGLXPixmap ( call_thedisplay, theGLXPixmap );
 #else
-    wglMakeCurrent ( hdc_old, hglrc_old );
-    wglDeleteContext ( hglrc );
+          wglMakeCurrent ( hdc_old, hglrc_old );
+          wglDeleteContext ( hglrc );
 #endif
-  }
-#endif  /*G004*/
-
+	}
+#endif	/*G004*/
 #ifdef WNT
   if (OpenGl_AVIWriter_AVIWriter &&
       OpenGl_AVIWriter_AllowWriting()  /*aview->Context.ZBufferActivity*/)
@@ -256,16 +274,16 @@
   }
 #endif
 
-  return;
+	return;
 }
 
 void EXPORT
 call_togl_redraw_area
 (
- CALL_DEF_VIEW * aview,
- CALL_DEF_LAYER * anunderlayer,
- CALL_DEF_LAYER * anoverlayer,
- int x, int y, int width, int height
+	CALL_DEF_VIEW * aview,
+	CALL_DEF_LAYER * anunderlayer,
+	CALL_DEF_LAYER * anoverlayer,
+	int x, int y, int width, int height
 )
 {
   CMN_KEY_DATA data;
@@ -273,36 +291,44 @@
 /*
   When the exposure area size is > window size / 2 do a full redraw.
 */
-  if( width*height > 
-      (int)(aview->DefWindow.dx*aview->DefWindow.dy)/2 ) {
-    call_togl_redraw(aview,anunderlayer,anoverlayer);
-    return;
-  }
+	if( width*height > 
+		(int)(aview->DefWindow.dx*aview->DefWindow.dy)/2 ) {
+	  call_togl_redraw(aview,anunderlayer,anoverlayer);
+	  return;
+	}
 /*
   Or redraw only the area in the front buffer
 */
-  TsmGetWSAttri (aview->WsId, WSWindow, &data);
-  if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
-    GLint buffer;
-    glGetIntegerv(GL_DRAW_BUFFER,&buffer);
-    if( buffer != GL_FRONT ) glDrawBuffer (GL_FRONT);
-    glEnable( GL_SCISSOR_TEST );
-    glScissor( (GLint)x, 
-               (GLint)((int)aview->DefWindow.dy - (y+height)), 
-               (GLsizei)width, (GLsizei)height);
-    call_func_redraw_all_structs_begin (aview->WsId);
-    if (anunderlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anunderlayer);
-    call_func_redraw_all_structs_proc (aview->WsId);
-    if (anoverlayer->ptrLayer)
-      call_togl_redraw_layer2d (aview, anoverlayer);
-#ifdef RIC120302
-    call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA);
-#endif
-    call_func_redraw_all_structs_end (aview->WsId, 0);
-    call_togl_redraw_immediat_mode (aview);
-    glFlush();
-    glDisable( GL_SCISSOR_TEST );
-    if( buffer != GL_FRONT ) glDrawBuffer (buffer);
-  }
+	TsmGetWSAttri (aview->WsId, WSWindow, &data);
+	if (TxglWinset (call_thedisplay, (Window) data.ldata) == TSuccess) {
+	    GLint buffer;
+	    glGetIntegerv(GL_DRAW_BUFFER,&buffer);
+	    if( buffer != GL_FRONT ) glDrawBuffer (GL_FRONT);
+	    glEnable( GL_SCISSOR_TEST );
+	    glScissor( (GLint)x, 
+		(GLint)((int)aview->DefWindow.dy - (y+height)), 
+				(GLsizei)width, (GLsizei)height);
+	    call_func_redraw_all_structs_begin (aview->WsId);
+	    if (anunderlayer->ptrLayer)
+		call_togl_redraw_layer2d (aview, anunderlayer);
+	    call_func_redraw_all_structs_proc (aview->WsId);
+
+		/* Proposed by P.Dolbey and revised to keep also the old callback */
+		#ifdef RIC120302
+			call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA|OCC_PRE_OVERLAY);
+		#endif
+
+		if (anoverlayer->ptrLayer)
+			call_togl_redraw_layer2d (aview, anoverlayer);
+
+		#ifdef RIC120302
+			call_subr_displayCB(aview,OCC_REDRAW_WINDOWAREA );
+		#endif
+
+	    call_func_redraw_all_structs_end (aview->WsId, 0);
+	    call_togl_redraw_immediat_mode (aview);
+	    glFlush();
+	    glDisable( GL_SCISSOR_TEST );
+	    if( buffer != GL_FRONT ) glDrawBuffer (buffer);
+	}
 }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_unproject_raster.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_unproject_raster.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_togl_unproject_raster.c	2010-07-04 20:15:21.489712951 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_togl_unproject_raster.c	2008-11-07 12:39:54.000000000 +0100
@@ -41,7 +41,12 @@
 Tint xr, yr;
 
 	xr = ixr;
-	yr = yM-ym-iyr;
+     /* 
+	  Patched by P.Dolbey: the window pixel height decreased by one 
+        in order for yr to remain within valid coordinate range [0; Ym -1]
+	  where Ym means window pixel height.
+	*/
+	yr = (yM-1)-ym-iyr;
 	result = TelUnProjectionRaster (wsid, xr, yr, x, y, z);
 
 	if (result == TSuccess)
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_triedron.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_triedron.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_triedron.c	2010-07-04 20:15:21.226315085 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_triedron.c	2009-02-27 15:36:52.000000000 +0100
@@ -31,7 +31,9 @@
 
 #define OCC2934         /* SAN 22/01/04 Texture-mapped fonts on WNT */
 
-#define OCC7667         /* asl Export to vector graphic file
+#define OCC7667         /* asl Export to vector graphic file */
+
+#define QTOCC_PATCH		/* Active QtOPENCASCADE patches */
 
 /*----------------------------------------------------------------------*/
 /*
@@ -42,6 +44,9 @@
 #include <X11/Xlib.h>
 #endif
 #include <OpenGl_tgl_all.h>
+/* SAN */
+#include <OpenGl_tgl_tox.h>
+/* SAN */
 
 
 #include <stddef.h>
@@ -306,6 +311,18 @@
     GLint mode;
     char AxeName[2]="X\0";
 
+#ifdef QTOCC_PATCH /* PCD 10/02/08 */
+	/* Fix to problem with clipping planes chopping off pieces of the triedron */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	GLboolean isPlaneActive[GL_MAX_CLIP_PLANES ]; 
+
+	/* Backup the clip planes.         */
+	for (ii = 0; ii < GL_MAX_CLIP_PLANES ; ii++) {
+		isPlaneActive[ii] = glIsEnabled(GL_CLIP_PLANE0 + ii);
+		glDisable(GL_CLIP_PLANE0 + ii);
+	}
+#endif /* VSR 27/02/09 */
+#endif /* PCD 10/02/08 */
 
     /* 
      * Lecture des Init. du Triedre 
@@ -480,6 +497,16 @@
     glLineWidth (TriedronWidth);
 #endif
 
+#ifdef QTOCC_PATCH /* Fotis Sioutis 2007-11-14 15:06 
+	 I have also seen in previous posts that the view trihedron in V3d_WIREFRAME mode 
+	 changes colors depending on the state of the view. This behaviour can be easily 
+	 corrected by altering call_triedron_redraw function in OpenGl_triedron.c of TKOpengl.
+	 The only change needed is to erase the LightOff() function that is called before the 
+	 Axis name drawing and move this function call just before the initial axis drawing.
+	 Below is the code portion with the modification.I don't know if this is considered to 
+	 be a bug but anyway i believe it might help some of you out there.*/
+	LightOff();
+#endif
 
     /* dessin des axes */
     glBegin(GL_LINES);
@@ -695,6 +722,17 @@
 #endif
      */
 
+#ifdef QTOCC_PATCH /* PCD 10/02/08 */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	/* Recover the clip planes */
+	 for (ii = 0; ii < GL_MAX_CLIP_PLANES ; ii++) {
+		if (isPlaneActive[ii]) { 
+			glEnable(GL_CLIP_PLANE0 + ii);
+		}
+	}
+#endif /* VSR 27/02/09 */
+#endif /* PCD 10/02/08 */
+
     /* 
      * restauration du contexte des matrices
      */
@@ -763,6 +801,21 @@
     GLdouble aAxisDiametr = 0.05;
     ZBUF_STRUCT* aParam;
 
+#ifdef QTOCC_PATCH 
+	GLint df;                                       /* PCD 17/06/07	*/			
+	GLfloat aNULLColor[] = { 0.0, 0.0, 0.0, 0.0f }; /* FS 21/01/08 */
+	/* Fix to problem with clipping planes chopping off pieces of the triedron   */
+	GLboolean isPlaneActive[GL_MAX_CLIP_PLANES ];   /* PCD 10/02/08 */
+	int i;
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+
+	/* Backup the clip planes. */
+	for (i = 0; i < GL_MAX_CLIP_PLANES ; i++) {
+		isPlaneActive[i] = glIsEnabled(GL_CLIP_PLANE0 + i);
+		glDisable(GL_CLIP_PLANE0 + i);
+	}
+#endif /* VSR 27/02/09 */
+#endif
 
     /* 
      * Lecture des Init. du Triedre 
@@ -830,8 +883,16 @@
 	       (GLdouble *)modelMatrix, (GLdouble *)projMatrix, aViewPort,
 	       &aWinCoord[0], &aWinCoord[1], &aWinCoord[2]);
 
+#ifdef QTOCC_PATCH /* PCD 29/09/2008 */
+	/* Simple code modification recommended by Fotis Sioutis and Peter Dolbey  */
+	/* to remove the irritating default behaviour of triedrons using V3d_ZBUFFER   */
+	/* which causes the glyph to jump around the screen when the origin moves offscreen. */
+	isWithinView = GL_FALSE;
+#else
+	/* Original code */
     isWithinView = !((aWinCoord[0]<aViewPort[0]) || (aWinCoord[0]>aViewPort[2]) ||
 		    (aWinCoord[1]<aViewPort[1]) || (aWinCoord[1]>aViewPort[3]));
+#endif
 
     if (!isWithinView) {
       /* Annulate translation matrix */
@@ -908,9 +969,18 @@
     
     aIsDepthEnabled = glIsEnabled(GL_DEPTH_TEST);
 #ifndef BUG
-    aIsDepthMaskEnabled = glIsEnabled(GL_DEPTH_WRITEMASK);
+
+#ifdef QTOCC_PATCH 	/*PCD 02/07/07   */
+	/* GL_DEPTH_WRITEMASK is not a valid argument to glIsEnabled, the  */
+	/* original code is shown to be broken when run under an OpenGL debugger  */
+	/* like GLIntercept. This is the correct way to retrieve the mask value.  */
+	glGetBooleanv(GL_DEPTH_WRITEMASK, &aIsDepthMaskEnabled); 
+#else
+	aIsDepthMaskEnabled = glIsEnabled(GL_DEPTH_WRITEMASK);
 #endif
 
+#endif 
+
     /* Create cylinder for axis */
     gluQuadricDrawStyle(aQuadric, GLU_FILL); /* smooth shaded */
     gluQuadricNormals(aQuadric, GLU_FLAT);
@@ -924,7 +994,11 @@
     glEndList();
     /* Central sphere */
     glNewList(startList + 2, GL_COMPILE);
-      gluSphere(aQuadric, aCylinderDiametr, NbFacettes, NbFacettes);
+#ifdef QTOCC_PATCH
+      gluSphere(aQuadric, aCylinderDiametr * 2, NbFacettes, NbFacettes);
+#else
+	  gluSphere(aQuadric, aCylinderDiametr, NbFacettes, NbFacettes);
+#endif
     glEndList();
     /* End disk */
     gluQuadricOrientation(aQuadric,GLU_INSIDE); /*szv*/
@@ -932,13 +1006,43 @@
       gluDisk(aQuadric, aCylinderDiametr, aConeDiametr, NbFacettes, 1/*szv:2*/);
     glEndList();
 
+#ifdef QTOCC_PATCH
+    /* Store previous attributes */
+    glPushAttrib(GL_LIGHTING_BIT | GL_POLYGON_BIT);
+	LightOn();
+#else
     LightOn();
 
     /* Store previous attributes */
     glPushAttrib(GL_LIGHTING_BIT | GL_POLYGON_BIT);
+#endif
     
     glCullFace(GL_BACK);
     glEnable(GL_CULL_FACE);
+
+#ifdef QTOCC_PATCH /*Fotis Sioutis | 2008-01-21 10:55 
+	 In the function call_zbuffer_triedron_redraw of TKOpengl, 
+	 the z buffered trihedron changes colors in case there 
+	 is an object in the scene that has an explicit material 
+	 attached to it.In the trihedron display loop, 
+	 GL_COLOR_MATERIAL is enabled, but only the GL_DIFFUSE 
+	 parameter is utilized in glColorMaterial(...).
+	 This causes the last ambient,specular and emission values 
+	 used, to stay at the stack and applied to the trihedron
+	 (which causes the color change).
+	 A fix is proposed , to change GL_DIFFUSE to 
+	 GL_AMBIENT_AND_DIFFUSE in glColorMaterial call in 
+	 line 946.The above of course will leave unchanged 
+	 the SPECULAR and EMISSION values.
+	 Another proposal which would fix 100% the problem 
+	 is to use glMaterial instead of glColor on the trihedron 
+	 drawing loop.               */
+	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, aNULLColor);
+	glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, aNULLColor);
+	glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, aNULLColor);
+
+	glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 0.);
+#endif
  
     glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
     glEnable(GL_COLOR_MATERIAL);
@@ -955,12 +1059,16 @@
 #endif
 #ifndef BUG
     if (!aIsDepthMaskEnabled)  {
-      glEnable(GL_DEPTH_WRITEMASK);
+	/* This is how the depthmask needs to be re-enabled...*/
+	glDepthMask(GL_TRUE);
+	/* ...and not this stuff below */
     }
 #endif
  
     glMatrixMode(GL_MODELVIEW);
-
+#ifdef QTOCC_PATCH /* PCD 17/06/07  */
+	glGetIntegerv (GL_DEPTH_FUNC, &df); 
+#else
     /*szv:if (isWithinView) {*/
       glDepthFunc(GL_GREATER);
       glPushMatrix();
@@ -1010,6 +1118,20 @@
 
       glDepthFunc(GL_LESS);
     /*szv:}*/
+#endif
+
+#ifdef QTOCC_PATCH
+    for (i = 0; i < 2; i++) /* PCD 11/02/08 Two pass method */
+	{
+		if (i == 0) /*  First pass  */
+		{                          
+			glDepthFunc(GL_ALWAYS); 
+		}
+		else
+		{
+			glDepthFunc(GL_LEQUAL); 
+		}
+#endif
 
     glPushMatrix();
     glPushMatrix();
@@ -1043,20 +1165,34 @@
     glCallList(startList + 3);
     glCallList(startList + 1);
     glPopMatrix();
+
+#ifdef QTOCC_PATCH
+	}
+#endif
     
     if (!aIsDepthEnabled) 
       glDisable(GL_DEPTH_TEST);
 #ifndef BUG
     if (!aIsDepthMaskEnabled)
+
+#ifdef QTOCC_PATCH /*PCD 02/07/07   */
+	glDepthMask(GL_FALSE);
+#else
       glDisable(GL_DEPTH_WRITEMASK);
 #endif
 
+#endif
     glDisable(GL_CULL_FACE);
     glDisable(GL_COLOR_MATERIAL);
 
     gluDeleteQuadric(aQuadric);
     glColor3fv (TriedronColor);
 
+#ifdef QTOCC_PATCH /* PCD 11/02/08 */
+	/* Always write the text */
+	glDepthFunc(GL_ALWAYS); 
+#endif
+
     glPopAttrib();
 
      /* fleches au bout des axes (= cones de la couleur demandee) */
@@ -1074,6 +1210,10 @@
 
      /* init font */
 #ifndef WNT
+     /* OCC20802 - Specify explicitly the font of small height to be used for axis names.
+        Otherwise, axis names might become too large if the current font 
+        has unsuitable parameters */
+     tXfmfindfont( call_thedisplay, "Courier-Bold", 1. );
      fontBase = tXfmsetfont (1.0F, 1.0F);
 #else
      fontBase = WNTSetFont (1.0F, 1.0F);
@@ -1165,6 +1305,21 @@
 #endif
      */
 
+#ifdef QTOCC_PATCH 
+	/*PCD 17/06/07    */
+	glDepthFunc(df);
+
+	/* PCD 10/02/08  */
+	/* Recover the clip planes */
+#ifdef QT_OCC_PATCH_ADDON /* VSR 27/02/09 - roll back: performance regression */
+	for (i = 0; i < GL_MAX_CLIP_PLANES ; i++) {
+		if (isPlaneActive[i]) { 
+			glEnable(GL_CLIP_PLANE0 + i);
+		}
+	}
+#endif /* VSR 27/02/09 */
+#endif
+
     if (!isWithinView) { /* restore matrix */
       glMatrixMode (GL_PROJECTION);
       glPopMatrix ();
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_tXfm.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_tXfm.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_tXfm.c	2010-07-04 20:15:21.539660990 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_tXfm.c	2009-01-14 13:50:14.000000000 +0100
@@ -3,24 +3,24 @@
      FONCTION :
      ----------
         File OpenGl_tXfm.c :
- 
+
 
      REMARQUES:
-     ---------- 
-     
-         Dans la methode alloc_new_font() des que l'on depasse 
+     ----------
+
+         Dans la methode alloc_new_font() des que l'on depasse
          (last_font > CACHE_SIZE) les performances s'ecroulent.
-      
+
 
      HISTORIQUE DES MODIFICATIONS   :
      --------------------------------
        xx-xx-xx : xxx ; Creation.
        26-06-96 : FMN ; Correction des textes clippes. On utilise glXUseXFont()
-       27-06-96 : FMN ; Correction hauteur des textes. 
+       27-06-96 : FMN ; Correction hauteur des textes.
        14-02-97 : FMN ; Suppression de MYGLXUSEXFONT
        12-09-97 : CAL ; Protection si tXfmfindfont echoue.
                         modifs dans tXfmfindfont, tXfmsetfont et tXfmprstr
-       02-11-98 : FMN ; PRO12916: Desactivation de la gestion du CharacterExpansionFactor 
+       02-11-98 : FMN ; PRO12916: Desactivation de la gestion du CharacterExpansionFactor
                         qui n'est pas implementee. Ce point sera traite de maniere
                         complete avec l'utilisation d'une librairie specifique
                         de type GLC. Pour le moment il est preferable de le
@@ -89,14 +89,14 @@
 #else
 #define MAX_X11_COORD (1 << 15)
 #endif
-        
+
 #define MAX_GLYPHS_PER_GRAB 512 /* this is big enough for 2^9 glyph character sets */
 
 /*----------------------------------------------------------------------*/
 /*
  * Prototypes fonctions internes
  */
-        
+
 static int getXfontind(float *, float , int );
 static void getXsizefromstr(float *, char **, int );
 static txfmfonthandle alloc_new_font(char *);
@@ -111,77 +111,84 @@
 static txfmfonthandle tXfmfontset[CACHE_SIZE];
 
 static int last_font = 0;
-static FontEntry fontEntry[] = 
+static FontEntry fontEntry[] =
 {
   {"Courier",
    "-adobe-courier-medium-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
+    0},
+  {"Courier-Bold",
+   "-adobe-courier-bold-r-normal--*-*-*-*-*-*-iso8859-1",
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Roman",
    "-adobe-times-medium-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Bold",
    "-adobe-times-bold-r-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-Italic",
    "-adobe-times-medium-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Times-BoldItalic",
    "-adobe-times-bold-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
     0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"ZapfChancery-MediumItalic",
    "-adobe-itc zapf chancery-medium-i-normal--*-*-*-*-*-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"Symbol",
    "-adobe-symbol-medium-r-normal--*-*-*-*-*-*-adobe-fontspecific",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
         0},
   {"ZapfDingbats",
    "-adobe-itc zapf dingbats-medium-r-normal--*-*-*-*-*-*-adobe-fontspecific",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Rock",
    "-sgi-rock-medium-r-normal--*-*-*-*-p-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0},
   {"Iris",
    "--iris-medium-r-normal--*-*-*-*-m-*-iso8859-1",
-    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 
-    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F}, 
+    { 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F,
+    0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0F},
     0}
 };
 
@@ -196,16 +203,16 @@
 {
     int dir = 0, asc = 0, des = 0;
     XCharStruct mes;
-    
+
     if (current_fonthandle != NULL && current_fonthandle->fontInfo != NULL && str != NULL )
     {
        XTextExtents(current_fonthandle->fontInfo, str, strlen(str), &dir, &asc, &des, &mes);
 
 #ifdef TRACE
-        printf("XTextExtents::asc = %d des = %d width = %d \n", asc, des, mes.width); 
+        printf("XTextExtents::asc = %d des = %d width = %d \n", asc, des, mes.width);
 #endif
         *Ascent = current_fonthandle->fontInfo->ascent;
-        *Descent = current_fonthandle->fontInfo->descent; 
+        *Descent = current_fonthandle->fontInfo->descent;
         *Width = mes.width;
     }
     else
@@ -234,10 +241,10 @@
     req_size = bestfont_size*1.36F; /* 98/72 dpi*/
 #endif
 
-    /* 
-     * Verifie que la (fonte,taille) n'ont pas deja ete traite 
+    /*
+     * Verifie que la (fonte,taille) n'ont pas deja ete traite
      */
-     
+
     for (i=0, a=0; i < last_font && !found_font; i++) {
         if(strcmp(tXfmfontset[i]->fontname, fontname) == 0) {
             if((tXfmfontset[i]->charsize) == req_size) {
@@ -254,10 +261,10 @@
     }
     if (found_font) return (current_fonthandle);
 
-    /* 
+    /*
      * Recherche dans les fontes disponibles: fontEntry
      */
-     
+
     for (i=0 ; i< NUM_FONT_ENTRIES ; i++) {
         if(  strcmp(fontname, fontEntry[i].name) == 0 ) {
             found_entry = 1;
@@ -296,7 +303,7 @@
 	  break;
 	}
     }
-    
+
     if (found_font) return (current_fonthandle);
 
     fonthandle = alloc_new_font(fontname);
@@ -328,7 +335,7 @@
 
     fonthandle = current_fonthandle;
 
-    isNeedUpdate = 0; /* = 1 if doesn't exist font or 
+    isNeedUpdate = 0; /* = 1 if doesn't exist font or
                            if needs for regenerate font ( Number of LastFont is exeeds  maxFontSize,
                            i.e.fonthandle->dirty = 1 ) */
     if ( fonthandle->listBase ) {
@@ -337,14 +344,14 @@
 	  isNeedUpdate = 0;
 	  pBase = fonthandle->listBase; /*OCC6247*/
 	  /*return(fonthandle->listBase);*/ /*OCC6247*/
-        } 
+        }
         else  /* dirty , reutilise fonthandle */
-        {  
+        {
 	    isNeedUpdate = 1;
             pBase = fonthandle->listBase;
         }
-    } 
-    else 
+    }
+    else
     {
         isNeedUpdate = 1; /* Nouvelle fonte */
         pBase = glGenLists(NUM_CHAR_FONT);
@@ -371,10 +378,10 @@
     fonthandle->listBase = pBase;
     fonthandle->dirty = 0;
     fonthandle->fontInfo = fontInfo;
-    
+
     fonthandle->xscale = txfmxscale;
     fonthandle->yscale = txfmyscale;
-    
+
 /*    XFreeFont( fonthandle->dpy, fontInfo); */
     return(pBase);
 }
@@ -398,7 +405,7 @@
 
 /* OCC7456 abd 14.12.2004 Text alignment attributes  */
 
- if (Base == 0) 
+ if (Base == 0)
    return;
 
 /* OCC7456 abd 14.12.2004 Text alignment attributes  */
@@ -455,9 +462,9 @@
     glGetIntegerv( GL_VIEWPORT, (GLint*)viewport );
 
     gluProject( x, y, z, (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport, &xw, &yw, &zw );
-    gluUnProject( xw - xdis, yw - ydis, zw, 
+    gluUnProject( xw - xdis, yw - ydis, zw,
                   (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport,
-                  &xv, &yv, &zv );    
+                  &xv, &yv, &zv );
     glRasterPos3d(xv, yv, zv);
 
 /*OCC7456 abd 14.12.2004 Text alignment attributes  */
@@ -466,11 +473,11 @@
     /* SAMTECH modif -- Geoff Levner 19/7/2007 -- added render mode test */
     glGetIntegerv(GL_RENDER_MODE, &renderMode);
     if (renderMode == GL_FEEDBACK) {
-      exportText( (char*) str, current_fontname,
-		  current_fonthandle->charsize * call_tox_getpitchsize(),
-		  x, y, z, GL_FALSE );
-      glRasterPos3f( x, y, z );
-    }
+    exportText((char*) str, current_fontname,
+                current_fonthandle->charsize * call_tox_getpitchsize(),
+                x, y, z, GL_FALSE );
+    glRasterPos3f( x, y, z );
+  }
 #endif
 
     glPushAttrib(GL_LIST_BIT);
@@ -600,7 +607,7 @@
 #endif
 
 typedef struct _font_handle {
-        
+
                     GLuint  listBase;
                     HGLRC   curRC;
                     float   xScale;
@@ -632,7 +639,7 @@
                     float       charRatios[MAX_NB_CHARS];
                } TM_FONT_HANDLE;
 #endif
-                
+
 typedef struct _font_entry {
 
                     char*       name;
@@ -674,9 +681,9 @@
 static int useTexFont = 0;
 static int curTexFont = -1;
 TEL_POINT  char_offsets[4] =
-            { { 0., 0., 0. }, 
-              { 0., 0., 0. }, 
-              { 0., 0., 0. }, 
+            { { 0., 0., 0. },
+              { 0., 0., 0. },
+              { 0., 0., 0. },
               { 0., 0., 0. } };
 
 #endif
@@ -695,13 +702,13 @@
 void sizeString(char *str, GLint *Width, GLint *Ascent, GLint *Descent)
 {
 /*    int       dir, asc, des;*/
-    
+
     if (curFont != -1)
     {
-        *Ascent = (int)fontEntry[ curFont ].fs[ curSize ].lHeight 
+        *Ascent = (int)fontEntry[ curFont ].fs[ curSize ].lHeight
                     - (int)fontEntry[ curFont ].fs[ curSize ].lInternalLeading
                 - (int)fontEntry[ curFont ].fs[ curSize ].lDescent;
-        *Descent = (int)fontEntry[ curFont ].fs[ curSize ].lDescent; 
+        *Descent = (int)fontEntry[ curFont ].fs[ curSize ].lDescent;
         *Width = fontEntry[ curFont ].fs[ curSize ].lWidth * strlen(str);
     }
     else
@@ -711,7 +718,7 @@
         *Width = 0;
     }
 #ifdef TRACE
-        printf("sizeString::asc = %d des = %d width = %d \n", *Ascent, *Descent, *Width); 
+        printf("sizeString::asc = %d des = %d width = %d \n", *Ascent, *Descent, *Width);
 #endif
 }
 
@@ -720,12 +727,18 @@
 
 /* loadTexFont(): Prepares a square texture containing glyphs for the given font */
 
-/* Current limitations: 
+/* Current limitations:
 - texture of fixed size 256 x 256 pixels is used,
 - each glyph occupies a 16 x 16 square in the texture,
 - fixed font height (16) is used for texture creation */
+
+
+
+
 static GLint loadTexFont(char* fontName, TM_FONT_HANDLE* fontHandle)
 {
+	
+
   GLint tex_id = -1;
   HFONT font;
   HDC   hMemDC, hDC = NULL;
@@ -734,13 +747,15 @@
   BITMAPINFO bi;
   HBITMAP hBmp, hOldBmp;
   const int spacing = 2;             /* spacing between characters in a string */
-  GLubyte fontBits [256 * 256 * 3];  /* font bitmap array: RGB */
-  GLubyte ifontBits[256 * 256 * 2];  /* texture array: luminance and alpha */
+  /* DFA 2007-04-17 make these static to prevent stack overflow.  */
+  static GLubyte fontBits [256 * 256 * 3]; /* font bitmap array: RGB */
+  static GLubyte ifontBits[256 * 256 * 2]; /* texture array: luminance and alpha */
   int charWidths[MAX_NB_CHARS];
 
   if ( !fontHandle )
     return tex_id;
 
+ 
   memset(fontHandle, 0, sizeof(TM_FONT_HANDLE));
 
   fontHandle->curRC   = wglGetCurrentContext();
@@ -766,7 +781,7 @@
   hDC       = wglGetCurrentDC();
   hMemDC    = CreateCompatibleDC(hDC);
   hBmp      = CreateCompatibleBitmap(hDC, fontHandle->texSize, fontHandle->texSize);
-  hOldBmp   = (HBITMAP)SelectObject(hMemDC, hBmp);        
+  hOldBmp   = (HBITMAP)SelectObject(hMemDC, hBmp);
   SelectObject(hMemDC, font);
   SetTextColor(hMemDC, RGB(255, 255, 255));
   SetBkColor  (hMemDC, RGB(0, 0, 0));
@@ -791,7 +806,7 @@
   bi.bmiHeader.biHeight      = -fontHandle->texSize;
   bi.bmiHeader.biWidth       = fontHandle->texSize;
   bi.bmiHeader.biCompression = BI_RGB;
-  SelectObject(hMemDC, hOldBmp);        
+  SelectObject(hMemDC, hOldBmp);
   num = GetDIBits(hMemDC, hBmp, 0, fontHandle->texSize, fontBits, &bi, DIB_RGB_COLORS);
 
   /* prepare an array of alpha and luminance values */
@@ -803,38 +818,51 @@
     }
 
   /* create the font texture */
+
+  /*BUG OCC13611 - remember parameters of texture mapping*/
+  glPushAttrib( GL_ENABLE_BIT | GL_TEXTURE_BIT );
+
   glGenTextures(1, &tex_id);
   glBindTexture(GL_TEXTURE_2D, tex_id);
   glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,
     GL_REPEAT);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
     GL_NEAREST);
-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
+  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
     GL_NEAREST);
 
-  glTexImage2D(GL_TEXTURE_2D, 
-               0, 
+  glTexImage2D(GL_TEXTURE_2D,
+               0,
                GL_INTENSITY,
-               fontHandle->texSize, 
-               fontHandle->texSize, 
-               0, 
-               GL_LUMINANCE_ALPHA, 
-               GL_UNSIGNED_BYTE, 
+               fontHandle->texSize,
+               fontHandle->texSize,
+               0,
+               GL_LUMINANCE_ALPHA,
+               GL_UNSIGNED_BYTE,
                ifontBits);
 
   fontHandle->textureId = tex_id;
 
+  glPopAttrib();
+   
+  /*
+   * free windows resources
+   */
+  DeleteObject(font);
+  DeleteObject(hBmp);
+  DeleteDC(hMemDC);
+
   return tex_id;
 }
 
 
-/* texPrint(): displays a string using texture <tex_id>, 
+/* texPrint(): displays a string using texture <tex_id>,
 <offsets> is used to convert quickly 16-pixel offset in viewport co-ordinates
 to offsets in world co-ordinates */
 
-/* Current limitations: 
+/* Current limitations:
 - texture of fixed size 256 x 256 pixels is used */
 static void texPrint( Tchar* data, TM_FONT_HANDLE* fontHandle, TEL_POINT* offsets )
 {
@@ -862,11 +890,11 @@
 
    glBindTexture(GL_TEXTURE_2D, fontHandle->textureId);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
-   
+
    l = strlen(data);
 
    glBegin(GL_QUADS);
-   
+
    for (i = 0; i < l; i++)
    {
      code = data[i];
@@ -880,7 +908,7 @@
      tx1 = b / divisor;
      ty0 = c / divisor;
      ty1 = d / divisor;
-     
+
      glTexCoord2f(tx0, ty0);
      glVertex3f(x, y, z);
      glTexCoord2f(tx1, ty0);
@@ -906,15 +934,17 @@
 void WNTUseTexMappedFont( int flag )
 {
   int i;
-
   if (flag && !useTexFont && curFont != -1)
   {
     FONT_ENTRY* fe = &fontEntry[curFont];
     HGLRC curRC = wglGetCurrentContext();
 
     for (i = 0; i < MAX_FONT_TEXTURES; i++ )
-    {
-      if (fe->tfh[i].curRC == curRC)
+    {                                        		
+		/*BUG OCC15715*/
+		/* Looking for an existing texture for the current RC or the first empty item in
+		the texture cache (with curRC == 0) */
+		if (fe->tfh[i].curRC == curRC ||fe->tfh[i].curRC == 0)  		
         break;
     }
 
@@ -924,10 +954,14 @@
       glDeleteTextures(1, &(fe->tfh[i].textureId));
     }
 
-    if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0)
-      loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+	if ( fe->tfh[i].curRC !=curRC || fe->tfh[i].textureId == 0){
+		loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+	}
+
+
+    
+	curTexFont = i;
 
-    curTexFont = i;
   }
 
   useTexFont = flag;
@@ -958,14 +992,14 @@
 #ifdef OCC2934
     texLoadNeeded = (useTexFont && curFont != i);
 #endif
- 
+
   fs      = &( fontEntry[ i ].fs[ 0 ] );
   curFont = i;
 
   for ( i = 0; i < MAX_FONT_SIZES; ++i ) {
-  
+
    if ( fs[ i ].charSize == 0 ) {
-   
+
         curSize = i;
 
         loadNewFont (  &( fs[ i ].fh[ 0 ] ), bestSize, TRUE  );
@@ -973,36 +1007,36 @@
         break;
 
    } else if ( fs[ i ].charSize == bestSize ) {
-   
+
         curSize = i;
         updateSizeUsage ();
-        
-    break;   
-   
+
+    break;
+
    }  /* end if */
-   
+
   }  /* end for */
 
   if ( i == MAX_FONT_SIZES ) {
-  
+
    min_val = UINT_MAX;
    min_idx = 0;
-   
+
    for ( i = 0; i < MAX_FONT_SIZES; ++i )
-   
+
     if ( fs[ i ].useCount < min_val ) {
-    
+
      min_val = fs -> useCount;
-     min_idx = i;    
-    
+     min_idx = i;
+
     }  /* end if */
 
    curSize = min_idx;
 
    loadNewFont (  &( fs[ min_idx ].fh[ 0 ] ), bestSize, TRUE  );
-  
+
   }  /* end if */
- 
+
  }  /* end else */
 
 #ifdef OCC2934
@@ -1012,8 +1046,11 @@
     HGLRC curRC = wglGetCurrentContext();
 
     for (i = 0; i < MAX_FONT_TEXTURES; i++ )
-    {
-      if (fe->tfh[i].curRC == curRC)
+    {            	
+		/*BUG OCC15715*/
+		/* Looking for an existing texture for the current RC or the first empty item in
+		the texture cache (with curRC == 0) */
+		if (fe->tfh[i].curRC == curRC ||fe->tfh[i].curRC == 0)      		
         break;
     }
 
@@ -1023,8 +1060,11 @@
       glDeleteTextures(1, &(fe->tfh[i].textureId));
     }
 
-    if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0)
-      loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+
+	if ( fe->tfh[i].curRC != curRC || fe->tfh[i].textureId == 0){
+		loadTexFont( fe->lfFaceName, &(fe->tfh[i]) );
+
+	}
 
     curTexFont = i;
  }
@@ -1054,13 +1094,13 @@
         fh[ i ].yScale == yScale &&
             fh[ i ].curRC  == hGLRC
    ) {
-  
+
     retVal = fh[ i ].listBase;
         curScale = i;
         updateScaleUsage ();
-   
-    break;  
-  
+
+    break;
+
    } else if ( fh[ i ].xScale == 0.0F && fh[ i ].yScale == 0.0F ) {
 
     newScale = TRUE;
@@ -1069,7 +1109,7 @@
    }  /* end if */
 
   if ( !retVal ) {
- 
+
    if ( newScale ) {
 
     fh[ i ].xScale = xScale;
@@ -1080,19 +1120,19 @@
     loadNewFont ( &fh[ i ], 0.0F, FALSE );
 
     retVal = fh[ i ].listBase;
-  
+
    } else {
-  
+
     min_val = UINT_MAX;
     min_idx = 0;
-   
-    for ( i = 0; i < MAX_FONT_SCALES; ++i )   
-                                                                                         
-     if ( fh[ i ].useCount < min_val ) {     
-    
+
+    for ( i = 0; i < MAX_FONT_SCALES; ++i )
+
+     if ( fh[ i ].useCount < min_val ) {
+
       min_val = fh -> useCount;
-      min_idx = i;    
-    
+      min_idx = i;
+
      }  /* end if */
 
     fh[ min_idx ].xScale = xScale;
@@ -1101,7 +1141,7 @@
         curScale = i;
 
     loadNewFont ( &fh[ min_idx ], 0.0F, FALSE );
-         
+
     retVal = fh[ min_idx ].listBase;
 
    }  /* end else ( newScale . . . ) */
@@ -1188,10 +1228,10 @@
  /* SAMTECH modif -- Geoff Levner 19/7/2007 -- added render mode test */
  glGetIntegerv(GL_RENDER_MODE, &renderMode);
  if (renderMode == GL_FEEDBACK) {
-   exportText( str, fontEntry[curFont].name,
-	       ( GLfloat )fontEntry[ curFont ].fs[ curSize ].lHeight,
-	       x, y, z, is2d!=0 );
- }
+  exportText( str, fontEntry[curFont].name,
+              ( GLfloat )fontEntry[ curFont ].fs[ curSize ].lHeight,
+              x, y, z, is2d!=0 );
+}
 #endif
 
 #ifdef OCC2934
@@ -1205,7 +1245,7 @@
    glPushMatrix();
 
    glTranslatef(x, y, z);
-   
+
    texPrint( str, &(fontEntry[curFont].tfh[curTexFont]), char_offsets );
 
    /* Restore previous matrices */
@@ -1227,12 +1267,12 @@
     glGetIntegerv( GL_VIEWPORT, (GLint*)viewport );
 
     gluProject( x, y, z, (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport, &xw, &yw, &zw );
-    gluUnProject( xw - xdis, yw - ydis, zw, 
+    gluUnProject( xw - xdis, yw - ydis, zw,
                   (GLdouble*)modelMatrix, (GLdouble*)projMatrix, (GLint*)viewport,
-                  &xv, &yv, &zv );    
+                  &xv, &yv, &zv );
     glRasterPos3d(xv, yv, zv);
 /*OCC7456 abd 14.12.2004 Text alingnment attributes  */
-    //glRasterPos3f(x, y, z);
+    /*glRasterPos3f(x, y, z); */
  }
 #endif
 
@@ -1262,10 +1302,10 @@
  glPixelTransferi ( GL_MAP_COLOR, GL_TRUE );
 
  glCallLists (  lstrlen ( str ), GL_UNSIGNED_BYTE, str );
- 
- /*san -- 12/11/2004 -- OCC7190 Texture-mapped fonts don't work, 
+
+ /*san -- 12/11/2004 -- OCC7190 Texture-mapped fonts don't work,
    as soon as any old-style (bitmap) text is displayed */
- glPixelTransferi(GL_MAP_COLOR, GL_FALSE); 
+ glPixelTransferi(GL_MAP_COLOR, GL_FALSE);
 
  glDisable ( GL_ALPHA_TEST );
 
@@ -1287,18 +1327,18 @@
  ZeroMemory (  ( PVOID )&lf, sizeof ( LOGFONT )  );
 
  if ( newSize ) {
- 
+
   fhTemp = fontEntry[ curFont ].fs[ curSize ].fh;
 
   for ( i = 0; i < MAX_FONT_SCALES; ++i )
-  
+
    if ( fhTemp[ i ].listBase ) {
 
     glDeleteLists (fhTemp[ i ].listBase, fontEntry[ curFont ].fs[ curSize ].listRange);
     ZeroMemory (  ( PVOID )&fhTemp[ i ], sizeof ( FONT_HANDLE )  );
 
    } else
-   
+
     break;
 
   fh -> xScale   = 1.0F;
@@ -1333,14 +1373,14 @@
   fontEntry[ curFont ].fs[ curSize ].lInternalLeading  = tm.tmInternalLeading;
   fontEntry[ curFont ].fs[ curSize ].lDescent = tm.tmDescent;
 
- } 
- else 
+ }
+ else
  {  /* new scale */
- 
+
   if ( fh -> listBase )
 
    glDeleteLists (fh -> listBase, fontEntry[ curFont ].fs[ curSize ].listRange);
-  
+
   lf.lfHeight  = ( LONG )( fontEntry[ curFont ].fs[ curSize ].lHeight * fh -> yScale );
   lf.lfWidth   = ( LONG )( fontEntry[ curFont ].fs[ curSize ].lWidth  * fh -> xScale );
   lf.lfCharSet = ANSI_CHARSET;
@@ -1359,7 +1399,7 @@
   DeleteObject ( hFont );
 
   fh -> curRC = wglGetCurrentContext ();
- 
+
  }  /* end else ( newSize . . . ) */
 
 }  /* end loadNewFont */
@@ -1372,8 +1412,8 @@
 
  if ( fontEntry[ curFont ].fs[ curSize ].useCount == UINT_MAX )
   for ( i = 0; i < MAX_FONT_SIZES; ++i )
-   fontEntry[ curFont ].fs[ i ].useCount >>= 1;   
- 
+   fontEntry[ curFont ].fs[ i ].useCount >>= 1;
+
  ++fontEntry[ curFont ].fs[ curSize ].useCount;
 
 }  /* end updateSizeUsage */
@@ -1386,7 +1426,7 @@
 
  if ( fontEntry[ curFont ].fs[ curSize ].fh[ curScale ].useCount == UINT_MAX )
   for ( i = 0; i < MAX_FONT_SCALES; ++i )
-        fontEntry[ curFont ].fs[ curSize ].fh[ i ].useCount >>= 1;   
+        fontEntry[ curFont ].fs[ curSize ].fh[ i ].useCount >>= 1;
 
  ++fontEntry[ curFont ].fs[ curSize ].fh[ curScale ].useCount;
 
@@ -1424,7 +1464,7 @@
     glRasterPos2f( x, y );
   else
     glRasterPos3f( x, y, z );
-  
+
   glBitmap( 1, 1, 0, 0, 0, 0, &zero );
 
   glPassThrough( height );
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_txgl.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_txgl.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_txgl.c	2010-07-04 20:15:21.566327377 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_txgl.c	2009-08-19 08:39:05.000000000 +0200
@@ -1,1097 +1,1115 @@
-/***********************************************************************
-
-     FONCTION :
-     ----------
-        File OpenGl_txgl :
- 
-
-     REMARQUES:
-     ---------- 
-      
-
-     HISTORIQUE DES MODIFICATIONS   :
-     --------------------------------
-       xx-xx-xx : xxx ; Creation.
-       07-02-96 : FMN ; Suppression code inutile:
-			- TxglLink() et TxglUnlink()
-       08-03-96 : FMN ; Suppression variables globales
-			Ajout cmn_delete_from_htbl() dans TxglDestroyWindow()
-       21-03-96 : CAL ; test sur previous_ctx dans TxglDestroyWindow()
-			et dans TxglSetDbuff()
-       01-04-96 : CAL ; Integration MINSK portage WNT
-       15-04-96 : CAL ; Integration travail PIXMAP de Jim ROTH
-       26-04-96 : FMN ; Correction warning de compilation
-       20-06-96 : CAL ; Retrait du XDestroyWindow dans TxglDestroyWindow
-       18-07-96 : FMN ; Suppression code inutile: TxglSetWindow().
-       27-09-96 : CAL ; Portage WNT
-       16-10-96 : GG  ; Coder le parametre de GLX_DEPTH_SIZE a 1 plutot
-                        que 0 si l'on souhaite accroitre les performances
-                        de 50% en utilisant le ZBuffer hardware !!!
-                        Si la fenetre fournie a deja le bon visual pas
-                        la peine de creer une sous-fenetre.
-       16-10-96 : GG  ; Le dithering doit etre active aussi avec 12 plans
-                        de maniere a ameliorer la qualite
-       17-10-96 : FMN ; Ajout fonction printVisualInfo()
-       06-11-96 : CAL ; Remise a True du BackDitherProp pour < 12 plans
-       12-11-96 : CAL ; BackDitherProp = True pour <= 8 plans
-			BackDitherProp = False pour > 8 plans
-       29-01-97 : FMN ; Amelioration du tests pour le dithering
-			DitherProp = True pour <= 8 plans red
-			DitherProp = False pour > 8 plans red
-			Suppression de TxglSetDbuff()
-       06-06-97 : FMN ; Meilleure gestion glXMakeCurrent (pb avec LightWoks)
-			Suppression de previous_win
-       02-07-97 : FMN ; Suppression variable ESSAI
-       07-10-97 : FMN ; Simplification WNT 
-       13-10-97 : FMN ; Ajout wglShareLists
-       06-02-98 : FMN ; PRO11674: Suppression XSetErrorHandler(0) inutile
-       23-11-98 : CAL ; PRO16603: previous_ctx jamais remis a 0 pour eviter
-			la perte des lists.
-       07-12-98 : CAL ; PRO 16311 et PRO 11821
-       02.14.100 : JR : Warnings on WNT
-       14.07.06 : SAN : OCC12977: update previous_ctx properly in TxglDestroyWindow.
-                        Old code resulted in crashes on some ATI Radeon cards under Linux.
-
-************************************************************************/
-
-#define BUC60691	/*GG 06/06/00 Due to a severe bug in secondary 
-//			table hash-code computation not yet solve,
-//			It's necessary to compute the primary hash-key key
-//			correctly under WNT/W98. The actual method is wrong
-//			because a size 4 is used for this table instead
-//			a conventional prime number as under UNIX system (23).
-//			 Under W98 sometimes the function wglMakeContext() does
-//			not work for an UNKNOWN reason, the number of DC
-//			seems limited to 5 but nothing tell that the limit is
-//			reached !
-//			We try right now to recover this error by creating a new DC.
-*/
-
-#define RIC120303	/*GG Add new function TxglSetWindow using
-//			the GLXContext defined by the user
-//			Add new function TxglGetContext.
-*/
-
-#define OCC954  /*SAV: 13/11/02 - check GLRC before deleting it*/
-
-/*----------------------------------------------------------------------*/
-/*
- * Includes
- */
- 
-#include <stdio.h>
-
-#include <OpenGl_tgl_all.h>
-
-#include <GL/gl.h>
-#include <GL/glu.h>
-
-#ifndef WNT
-# include <X11/Xlib.h>
-# include <X11/Xutil.h>
-# include <GL/glx.h>
-# include <OpenGl_telem_util.h>
-#else
-# include <OpenGl_cmn_memory.h>
-# define STRICT
-# include <InterfaceGraphic_WNT.hxx>
-# include <windows.h>
-
-typedef struct htbl_entry {
-	HDC   hDC;
-	HGLRC hGLRC;
-	int   nUsed;
-
-       } HTBL_ENTRY;
-	       
-int call_util_osd_getenv ( char*, char*, int );
-#endif  /* WNT */
-
-#include <OpenGl_cmn_htbl.h>
-#include <OpenGl_txgl.h>
-int call_util_osd_getenv( char * , char * , int ) ;
-
-/*----------------------------------------------------------------------*/
-/*
- * Variables statiques
- */
-
-static  cmn_htbl  txgltbl;		/* Hash table pour le GLXContext */
-
-#ifndef WNT
-static  int BackDitherProp = False;	/* Dithering pour le background */
-static  int DitherProp = True;		/* Dithering pour le trace	*/
-static	GLXContext previous_ctx = 0;	/* Use for share display list	*/
-static  GLXContext dead_ctx;            /* Context to be destroyed */
-static  Display *dead_dpy;              /* Display associated with dead_ctx */
-#else
-static  int BackDitherProp = FALSE;	/* Dithering pour le background */
-static  int DitherProp = TRUE;		/* Dithering pour le trace	*/
-static  BOOL s_sysPalInUse;             /* Flag to check system colors usage */ 
-static  HGLRC previous_ctx = 0;		/* Use for share display list	*/
-#endif /* WNT */
-
-/*----------------------------------------------------------------------*/
-/*
- * Constantes
- */
-
-#define NO_TRACE
-
-#define CALL_DEF_STRING_LENGTH 132
-
-#define WIN_HTBL_SIZE 23
-
-/*----------------------------------------------------------------------*/
-/*
- * Fonctions statiques
- */
-
-#ifndef WNT
-#ifdef TRACE
-static GLvoid printVisualInfo( Display *, XVisualInfo *glxVisual );
-#endif
-#else
-#ifdef BUC60691
-static BOOL win95 = FALSE;
-#endif
-__declspec( dllexport ) int __fastcall __OpenGl_INIT__ ( 
-                                        unsigned hInstance, unsigned long reason_for_call
-                                       ) {
- if ( reason_for_call == DLL_PROCESS_ATTACH ) {
-
- }
- return 1;
-
-}  /* end __OpenGl_INIT__ */
-#endif  /* WNT */
-
-/*----------------------------------------------------------------------*/
-
-Window
-TxglCreateWindow( Display  *disp, Window par,
-	Tint x, Tint y, Tint w, Tint h, Tint bw,
-	Tfloat bgcolr, Tfloat bgcolg, Tfloat bgcolb )
-{
-
-#ifndef WNT
-
-    GLXContext ctx;
-    static int sdesc[11];
-    Colormap cmap;
-    XVisualInfo* vis=NULL;
-/*    XVisualInfo tmplt;*/
-    XSetWindowAttributes cwa;
-    XColor color;
-/*    Tint i, n, nret;*/
-    Tint n;
-    Tint scr;
-    int value;
-    char string[CALL_DEF_STRING_LENGTH];
-    int DBuffer = True;
-    XWindowAttributes wattr;
-
-    Window win;
-
-    unsigned long mask = 0;
-/*    unsigned long background_pixel = 0;*/
-
-    if (call_util_osd_getenv("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH))
-        DBuffer    = False;
-
-    if (call_util_osd_getenv("JWR_PIXMAP_DB", string, CALL_DEF_STRING_LENGTH))
-        TelSetPixmapDB(1);
-
-    XGetWindowAttributes( disp , par , &wattr );
-
-    n = 0;
-    sdesc[n] = GLX_RGBA;n++;
-
-    sdesc[n] = GLX_DEPTH_SIZE;n++;
-    sdesc[n] = 1;n++;
-
-    sdesc[n] = GLX_RED_SIZE;n++;
-    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
-
-    sdesc[n] = GLX_GREEN_SIZE;n++;
-    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
-
-    sdesc[n] = GLX_BLUE_SIZE;n++;
-    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
-
-    if (DBuffer) {
-      sdesc[n] = GLX_DOUBLEBUFFER;n++;
-    }
-
-    sdesc[n] = None;n++;
-
-    scr = DefaultScreen( disp );
-
-#if defined(__linux) || defined(Linux)
-    {
-      XVisualInfo vinfo;
-      int ninfo;
-      unsigned long vmask = VisualIDMask |  VisualScreenMask;
-      vinfo.visualid = wattr.visual->visualid;
-      vinfo.screen = DefaultScreen( disp );
-      vis = XGetVisualInfo( disp, vmask, &vinfo, &ninfo);
-    }
-#endif
-
-    if( !vis )
-    	vis = glXChooseVisual( disp, scr, sdesc );
-    if( !vis) return TFailure;
-
-#ifdef TRACE
-    printf ("TxglCreateWindow \n");
-    printf ("Informations sur le visual\n");
-    printf ("par visualid %x%x %d\n", wattr.visual->visualid, wattr.visual->visualid);
-    printf ("vis visualid 0x%x %d\n", vis->visualid, vis->visualid);
-    printf ("vis depth %d\n", vis->depth);
-    printf ("vis class %d\n", vis->class);
-    printf ("vis red_mask %ld\n", vis->red_mask);
-    printf ("vis green_mask %ld\n", vis->green_mask);
-    printf ("vis blue_mask %ld\n", vis->blue_mask);
-    printf ("vis colormap_size %d\n", vis->colormap_size);
-    printf ("vis bits_per_rgb %d\n", vis->bits_per_rgb);
-    printVisualInfo( disp, vis );
-#endif
-
-    /*
-     * Le BackDitherProp est utilise pour le clear du background
-     * Pour eviter une difference de couleurs avec la couleur choisie
-     * par l'application (XWindow) il faut desactiver le dithering
-     * au dessus de 8 plans.
-     * 
-     * Pour le DitherProp:
-     * On cherchera a activer le Dithering que si le Visual a au moins
-     * 8 plans pour le GLX_RED_SIZE. Le test est plus sur car on peut
-     * avoir une profondeur superieure a 12 mais avoir besoin du dithering.
-     * (Carte Impact avec GLX_RED_SIZE a 5 par exemple)
-     */
-
-    glXGetConfig( disp, vis, GLX_RED_SIZE, &value );
-
-    if ( value < 8 ) {
-        DitherProp = True;
-    }
-    else
-    {
-        DitherProp = False;
-    }
-
-    if ( vis->depth <= 8 ) {
-        BackDitherProp = True;
-    }
-    else
-    {
-        BackDitherProp = False;
-    }
-
-#ifdef TRACE
-    printf("Dithering %d BackDithering %d \n",DitherProp,BackDitherProp);
-#endif
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
-        DitherProp = False;
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
-        BackDitherProp = False;
-
-    if (dead_ctx) {
-	/* recover display lists from dead_ctx, then destroy it */
-	ctx = glXCreateContext( disp, vis, dead_ctx, GL_TRUE );
-	glXDestroyContext(dead_dpy, dead_ctx);
-	dead_ctx = 0;
-    } else if (previous_ctx == 0) {
-        ctx = glXCreateContext( disp, vis, NULL, GL_TRUE );
-    } else {
-	/* ctx est une copie du previous */
-    	ctx = glXCreateContext( disp, vis, previous_ctx, GL_TRUE );
-    }
-    previous_ctx = ctx;
-
-    if( !ctx) return TFailure;
-
-    cmap = XCreateColormap( disp,  par, vis->visual, AllocNone );
-
-    color.red	= (unsigned short) (bgcolr * 0xFFFF);
-    color.green	= (unsigned short) (bgcolg * 0xFFFF);
-    color.blue	= (unsigned short) (bgcolb * 0xFFFF);
-    color.flags	= DoRed | DoGreen | DoBlue;
-    XAllocColor( disp, cmap, &color );
-
-    cwa.colormap	= cmap;
-    cwa.event_mask	= StructureNotifyMask;
-    cwa.border_pixel	= color.pixel;
-    cwa.background_pixel = color.pixel;
-
-    mask = CWBackPixel | CWColormap | CWBorderPixel | CWEventMask;
-
-    if( vis->visualid == wattr.visual->visualid ) {
-      win = par;
-    } 
-    else 
-    {
-      win = XCreateWindow( disp, par, x, y, w, h, bw,
-                         vis->depth, InputOutput, vis->visual,
-                         mask, &cwa );
-    }
-
-#ifdef TRACE
-    printf ("TxglCreateWindow win %x par %x \n", win, par);
-#endif
-
-    XSetWindowBackground( disp, win, cwa.background_pixel );
-    XClearWindow( disp, win );
-
-    /* if in Pixmap double buffering mode, set up pixmap */
-
-    if (TelTestPixmapDB())
-    {
-        GC gc;
-        Pixmap pixmap;
-        GLXPixmap glxpixmap;
-
-        printf("setting up pixmap double buffering\n");
-
-        gc = XCreateGC(disp, win, 0, NULL);
-
-        pixmap = XCreatePixmap(disp, win, w, h, vis->depth);
-
-        glxpixmap = glXCreateGLXPixmap(disp, vis, pixmap);
-
-        glXMakeCurrent(disp, glxpixmap, ctx);
-
-        glDrawBuffer(GL_FRONT);
-
-        TelSetPixmapDBParams(disp, win, w, h, vis->depth, gc, pixmap, glxpixmap, ctx);
-    }
-
-    XFree((char*)vis);  
-
-    if( !txgltbl )
-    {
-	/*
-	 * PRO 16311 et PRO 11821
-	 * txgltbl = cmn_create_htbl(  sizeof( GLXContext)+1 );
-	 */
-	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
-	if( !txgltbl ) return 0;
-    }
-    cmn_add_in_htbl( txgltbl, win, ctx );
-
-    return win;
-
-#else /* WNT */
-
-    cmn_htbl_elem         rec;
-    HTBL_ENTRY*           hte;
-    PIXELFORMATDESCRIPTOR pfd;
-    BOOL                  DBuffer = TRUE;
-    int                   iPixelFormat;
-    char                  string[ CALL_DEF_STRING_LENGTH ];
-
-#ifdef BUC60691
-    OSVERSIONINFO os;
-    os.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-    GetVersionEx(&os);
-    if( os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) win95 = TRUE; 
-#endif
-
-    if ( txgltbl ) 
-    {
-	rec = cmn_find_in_htbl (  txgltbl, ( Tint )par, ( void** )&hte  );
-	
-	if ( rec ) 
-	{
-	    ++hte -> nUsed;
-	    printf("*TxglCreateWindow.window %d is alreday created\n",par);
-	    return par;
-	}  
-    }  
-
-    hte = ( HTBL_ENTRY* )cmn_getmem (  1, sizeof ( HTBL_ENTRY ), 1  );
-    
-    if ( !hte ) return 0;
-
-    if (  call_util_osd_getenv ("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH)) 
-	DBuffer = FALSE;
-
-    pfd.nSize           = sizeof ( PIXELFORMATDESCRIPTOR );
-    pfd.nVersion        = 1;
-    pfd.dwFlags         = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
-    pfd.dwFlags        |= ( DBuffer ) ? PFD_DOUBLEBUFFER : PFD_SUPPORT_GDI;
-    pfd.iPixelType      = PFD_TYPE_RGBA;
-    pfd.cColorBits      = 24;
-    pfd.cRedBits        = 0;
-    pfd.cRedShift       = 0;
-    pfd.cGreenBits      = 0;
-    pfd.cGreenShift     = 0;
-    pfd.cBlueBits       = 0;
-    pfd.cBlueShift      = 0;
-    pfd.cAlphaBits      = 0;
-    pfd.cAlphaShift     = 0;
-    pfd.cAccumBits      = 0;
-    pfd.cAccumRedBits   = 0;
-    pfd.cAccumGreenBits = 0;
-    pfd.cAccumBlueBits  = 0;
-    pfd.cAccumAlphaBits = 0;
-    pfd.cDepthBits      = 32;
-    pfd.cStencilBits    = 0;
-    pfd.cAuxBuffers     = 0;
-    pfd.iLayerType      = PFD_MAIN_PLANE;
-    pfd.bReserved       = 0;
-    pfd.dwLayerMask     = 0;
-    pfd.dwVisibleMask   = 0;
-    pfd.dwDamageMask    = 0;
-
-    hte -> nUsed = 1;
-    
-    hte -> hDC   = GetDC ( par );
-    iPixelFormat = ChoosePixelFormat ( hte -> hDC, &pfd );
-
-    if ( !iPixelFormat ) 
-    {
-	printf ("*OpenGL interface: ChoosePixelFormat failed. Error code: %d\n",GetLastError ());
-	
-	ReleaseDC ( par, hte -> hDC );
-	cmn_freemem (  ( void* )hte  );
-	
-	return 0;
-    }  
-
-    DescribePixelFormat (hte -> hDC, iPixelFormat, sizeof ( PIXELFORMATDESCRIPTOR ), &pfd);
-
-    if ( pfd.dwFlags & PFD_NEED_PALETTE ) 
-    {
-#ifndef _WIN64
-	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWL_USERDATA );
-#else
-	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWLP_USERDATA );
-#endif
-	
-	InterfaceGraphic_RealizePalette (hte -> hDC, wd -> hPal, FALSE,
-	    s_sysPalInUse = pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE ? TRUE : FALSE); 
-    }  
-
-    if ( pfd.cColorBits <= 8 ) 
-    { 
-	DitherProp     = TRUE;
-	BackDitherProp = TRUE;    
-    }  
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
-	DitherProp = FALSE;
-    
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
-	BackDitherProp = FALSE;
-
-    if (  !SetPixelFormat ( hte -> hDC, iPixelFormat, &pfd )  ) 
-    {
-	printf ("*OpenGL interface: SetPixelFormat failed. Error code %d\n",GetLastError ()); 
-	ReleaseDC ( par, hte -> hDC );
-	cmn_freemem (  ( void* )hte  );   
-	return 0; 
-    }  
-
-    hte -> hGLRC = wglCreateContext ( hte -> hDC );
-    
-    if ( !hte -> hGLRC ) 
-    { 
-	printf ("*OpenGL interface: wglCreateContext failed. Error code: %d\n",GetLastError ());    
-	return 0;  	  
-    }  
-    
-    if (previous_ctx == 0 )    
-    {
-        previous_ctx = hte -> hGLRC;
-    } else
-	wglShareLists(previous_ctx, hte -> hGLRC);
-
-    if ( !txgltbl ) 
-    {
-#ifdef BUC60691
-	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
-#else
-	txgltbl = cmn_create_htbl (  sizeof ( HTBL_ENTRY* )  );
-#endif
-	
-	if ( !txgltbl ) 
-	{
-	    ReleaseDC ( par, hte -> hDC );
-	    cmn_freemem (  ( void* )hte );
-	    printf( "*OpenGL interface: cmn_create_htbl failed\n" );
-	}  
-    }  
-    
-    cmn_add_in_htbl (  txgltbl, ( Tint )par, hte  );
-    
-    return par;
-
-#endif  /* WNT */
-
-}
-
-#ifdef RIC120302
-Window
-TxglSetWindow( Display  *disp, Window par, GLXContext ctx)
-{
-#ifndef WNT
-    XVisualInfo* vis;
-    char string[CALL_DEF_STRING_LENGTH];
-    XWindowAttributes wattr;
-
-    XGetWindowAttributes( disp , par , &wattr );
-    {
-      unsigned long vmask = VisualIDMask |  VisualScreenMask;
-      XVisualInfo vinfo;
-      int ninfo;
-      vinfo.visualid = wattr.visual->visualid;
-      vinfo.screen = DefaultScreen( disp );
-      vis = XGetVisualInfo( disp, vmask, &vinfo, &ninfo);
-    }
-
-    if( !vis) return TFailure;
-
-#ifdef TRACE
-    printf ("TxglSetWindow \n");
-    printf ("Informations sur le visual\n");
-    printf ("par visualid %x%x %d\n", wattr.visual->visualid, wattr.visual->visualid);
-    printf ("vis visualid 0x%x %d\n", vis->visualid, vis->visualid);
-    printf ("vis depth %d\n", vis->depth);
-    printf ("vis class %d\n", vis->class);
-    printf ("vis red_mask %ld\n", vis->red_mask);
-    printf ("vis green_mask %ld\n", vis->green_mask);
-    printf ("vis blue_mask %ld\n", vis->blue_mask);
-    printf ("vis colormap_size %d\n", vis->colormap_size);
-    printf ("vis bits_per_rgb %d\n", vis->bits_per_rgb);
-    printVisualInfo( disp, vis );
-#endif
-
-    /*
-     * Le BackDitherProp est utilise pour le clear du background
-     * Pour eviter une difference de couleurs avec la couleur choisie
-     * par l'application (XWindow) il faut desactiver le dithering
-     * au dessus de 8 plans.
-     * 
-     * Pour le DitherProp:
-     * On cherchera a activer le Dithering que si le Visual a au moins
-     * 8 plans pour le GLX_RED_SIZE. Le test est plus sur car on peut
-     * avoir une profondeur superieure a 12 mais avoir besoin du dithering.
-     * (Carte Impact avec GLX_RED_SIZE a 5 par exemple)
-     */
-
-    {
-      int value;
-      glXGetConfig( disp, vis, GLX_RED_SIZE, &value );
-
-      if ( value < 8 ) {
-        DitherProp = True;
-      } else {
-        DitherProp = False;
-      }
-
-      if ( vis->depth <= 8 ) {
-        BackDitherProp = True;
-      } else {
-        BackDitherProp = False;
-      }
-    }
-
-#ifdef TRACE
-    printf("Dithering %d BackDithering %d \n",DitherProp,BackDitherProp);
-#endif
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
-        DitherProp = False;
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
-        BackDitherProp = False;
-
-    previous_ctx = ctx;
-
-    XFree((char*)vis);  
-
-    if( !txgltbl ) {
-	/*
-	 * PRO 16311 et PRO 11821
-	 * txgltbl = cmn_create_htbl(  sizeof( GLXContext)+1 );
-	 */
-	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
-	if( !txgltbl ) return 0;
-    }
-    cmn_add_in_htbl( txgltbl, par, ctx );
-
-#else /* WNT */
-
-    cmn_htbl_elem         rec;
-    HTBL_ENTRY*           hte;
-    PIXELFORMATDESCRIPTOR pfd;
-    BOOL                  DBuffer = TRUE;
-    int                   iPixelFormat;
-    char                  string[ CALL_DEF_STRING_LENGTH ];
-
-#ifdef BUC60691
-    OSVERSIONINFO os;
-    os.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
-    GetVersionEx(&os);
-    if( os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) win95 = TRUE; 
-#endif
-
-    if ( txgltbl ) 
-    {
-	rec = cmn_find_in_htbl (  txgltbl, ( Tint )par, ( void** )&hte  );
-	
-	if ( rec ) 
-	{
-	    ++hte -> nUsed;
-	    printf("*TxglSetWindow.window %d is alreday created\n",par);
-	    return par;
-	}  
-    }  
-
-    hte = ( HTBL_ENTRY* )cmn_getmem (  1, sizeof ( HTBL_ENTRY ), 1  );
-    
-    if ( !hte ) return 0;
-
-    if (  call_util_osd_getenv ("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH)) 
-	DBuffer = FALSE;
-
-    pfd.nSize           = sizeof ( PIXELFORMATDESCRIPTOR );
-    pfd.nVersion        = 1;
-    pfd.dwFlags         = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
-    pfd.dwFlags        |= ( DBuffer ) ? PFD_DOUBLEBUFFER : PFD_SUPPORT_GDI;
-    pfd.iPixelType      = PFD_TYPE_RGBA;
-    pfd.cColorBits      = 24;
-    pfd.cRedBits        = 0;
-    pfd.cRedShift       = 0;
-    pfd.cGreenBits      = 0;
-    pfd.cGreenShift     = 0;
-    pfd.cBlueBits       = 0;
-    pfd.cBlueShift      = 0;
-    pfd.cAlphaBits      = 0;
-    pfd.cAlphaShift     = 0;
-    pfd.cAccumBits      = 0;
-    pfd.cAccumRedBits   = 0;
-    pfd.cAccumGreenBits = 0;
-    pfd.cAccumBlueBits  = 0;
-    pfd.cAccumAlphaBits = 0;
-    pfd.cDepthBits      = 32;
-    pfd.cStencilBits    = 0;
-    pfd.cAuxBuffers     = 0;
-    pfd.iLayerType      = PFD_MAIN_PLANE;
-    pfd.bReserved       = 0;
-    pfd.dwLayerMask     = 0;
-    pfd.dwVisibleMask   = 0;
-    pfd.dwDamageMask    = 0;
-
-    hte -> nUsed = 1;
-    
-    hte -> hDC   = GetDC ( par );
-    iPixelFormat = ChoosePixelFormat ( hte -> hDC, &pfd );
-
-    if ( !iPixelFormat ) 
-    {
-	printf ("*OpenGL interface: ChoosePixelFormat failed. Error code: %d\n",GetLastError ());
-	
-	ReleaseDC ( par, hte -> hDC );
-	cmn_freemem (  ( void* )hte  );
-	
-	return 0;
-    }  
-
-    DescribePixelFormat (hte -> hDC, iPixelFormat, sizeof ( PIXELFORMATDESCRIPTOR ), &pfd);
-
-    if ( pfd.dwFlags & PFD_NEED_PALETTE ) 
-    {
-#ifndef _WIN64
-	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWL_USERDATA );
-#else
-	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWLP_USERDATA );
-#endif
-	
-	InterfaceGraphic_RealizePalette (hte -> hDC, wd -> hPal, FALSE,
-	    s_sysPalInUse = pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE ? TRUE : FALSE); 
-    }  
-
-    if ( pfd.cColorBits <= 8 ) 
-    { 
-	DitherProp     = TRUE;
-	BackDitherProp = TRUE;    
-    }  
-
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
-	DitherProp = FALSE;
-    
-    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
-	BackDitherProp = FALSE;
-
-    if (  !SetPixelFormat ( hte -> hDC, iPixelFormat, &pfd )  ) 
-    {
-	printf ("*OpenGL interface: SetPixelFormat failed. Error code %d\n",GetLastError ()); 
-	ReleaseDC ( par, hte -> hDC );
-	cmn_freemem (  ( void* )hte  );   
-	return 0; 
-    }  
-
-    hte -> hGLRC = previous_ctx = ctx;
-    
-    if ( !txgltbl ) 
-    {
-#ifdef BUC60691
-	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
-#else
-	txgltbl = cmn_create_htbl (  sizeof ( HTBL_ENTRY* )  );
-#endif
-	
-	if ( !txgltbl ) 
-	{
-	    ReleaseDC ( par, hte -> hDC );
-	    cmn_freemem (  ( void* )hte );
-	    printf( "*OpenGL interface: cmn_create_htbl failed\n" );
-	}  
-    }  
-    
-    cmn_add_in_htbl (  txgltbl, ( Tint )par, hte  );
-
-#endif  /* WNT */
-
-    return par;
-
-}
-#endif /*RIC120302*/
-
-/*----------------------------------------------------------------------*/
-
-TStatus
-TxglWinset( Display *disp, Window win )
-{
-
-#ifndef WNT
-
-    Bool  i;
-    GLXContext ctx;
-    cmn_htbl_elem  rec;
-    GLenum errorcode;
-    const GLubyte *errorstring;
-
-    if( !txgltbl ) return TFailure;
-
-    rec = cmn_find_in_htbl( txgltbl, win, (void**)&ctx );
-    if( !rec ) return TFailure;
-
-#ifdef TRACE
-    printf ("TxglWinset::glXMakeCurrent %x \n", win);
-#endif
-    if (TelTestPixmapDB())
-      {
-        i = glXMakeCurrent(disp, TelGetGLXPixmap(), ctx);
-      }
-    else
-      {
-        i = glXMakeCurrent(disp, win, ctx);  /* TRUE/FALSE */
-      }
-    if (!i)
-      {
-	errorcode = glGetError();
-	errorstring = gluErrorString(errorcode);
-	printf("glXMakeCurrent failed: %d %s\n", errorcode, errorstring);
-      }
-
-    return  i == True ? TSuccess : TFailure;
-
-#else /* WNT */
-
-    HTBL_ENTRY*   hte;
-    cmn_htbl_elem rec;
-    HDC    hdc    = NULL;
-    HGLRC  hglrc  = NULL;
-    TStatus       retVal = TFailure;
-
-    __try {
-    
-	if ( !txgltbl ) __leave;
-		
-	if (    !(   rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&hte  )   )    ) {
-	  printf("OpenGL interface:  TxglWinset failed.UNKNOWN win %x\n",win);
-	  __leave;
-	}
-
-#ifdef BUC60691
-      if( win95 ) {
-	  retVal = ReleaseDC ( win, hte -> hDC );
-	  hte -> hDC   = GetDC ( win );
-      }		
-#endif
-	if (  !wglMakeCurrent ( hte -> hDC, hte -> hGLRC )  ) 
-	{
-#ifdef BUC60691
-    	   GLenum errorcode;
-    	   const GLubyte *errorstring;
-
-	   errorcode = glGetError();
-	   errorstring = gluErrorString(errorcode);
-	   printf("wglMakeCurrent failed: %d %s\n", errorcode, errorstring);
-#else
-	    printf ("OpenGL interface: wglMakeCurrent failed. Error code: %d\n",GetLastError ());
-#endif
-	    retVal = TFailure;	
-	} else retVal = TSuccess;
-    
-    }  /* end __try */
-
-
-    __finally 
-    {    
-    }  
-
-    return retVal;
-
-#endif  /* WNT */
-
-}
-
-/*----------------------------------------------------------------------*/
-
-Window
-TxglGetSubWindow( Display *disp, Window win )
-                               /* This function assumes that there is only
-                                  one child for the parent */
-{
-
-#ifndef WNT
-
-   Window root, parent, *child, w;
-   unsigned int num;
-
-   if( XQueryTree( disp, win, &root, &parent, &child, &num ) )
-   {
-      if (! num) return win;
-      w = child[0];
-      XFree( (char *)child );
-      return w;
-   }
-   else
-      return 0;
-
-#else /* WNT */
-
-   return win;
-
-#endif  /* WNT */
-
-}
-
-/*----------------------------------------------------------------------*/
-
-void
-TxglDestroyWindow( Display *disp, Window win )
-{
-
-#ifndef WNT
-
-    GLXContext ctx;
-    cmn_htbl_elem rec;
-    Tint dummy;
-    
-    if( !txgltbl ) return ;
-    
-    rec = cmn_find_in_htbl( txgltbl, win, (void**)&ctx );
-    if( !rec ) return ;
-
-    /* FSXXX sync necessary if non-direct rendering */
-    glXWaitGL();
-
-    cmn_delete_from_htbl( txgltbl, win, (void**)&ctx );
-
-    if (previous_ctx == ctx) {
-      /* san -- OCC12977: it's important to put some valid GLXContext or null into
-	 previous_ctx here, otherwise next glxCreateContext() will crash on some ATI Radeon cards
-      */
-      cmn_get_from_htbl( txgltbl, &dummy, (void**)&previous_ctx, 0 );
-      /*
-       * if this is the last remaining context, do not destroy it yet, to avoid
-       * losing any shared display lists (fonts...)
-       */
-      if (previous_ctx) {
-	glXDestroyContext(disp, ctx);
-      } else {
-	dead_ctx = ctx;
-	dead_dpy = disp;
-      }
-    } else {
-      glXDestroyContext(disp, ctx);
-    }
-
-#else /* WNT */
-
-    HTBL_ENTRY*   hte;
-    cmn_htbl_elem rec;
-#ifdef _DEBUG 
-    WINDOW_DATA*  wd;
-#endif  /* _DEBUG */
-    
-    if ( !txgltbl ) return;
-
-    rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&hte  );
-    if ( !rec ) return;
-    
-#ifdef _DEBUG 
-    /* In release version of application we need to process    */
-    /*  palette messages in the main application message loop. */
-    /*  In debug version we don't have message loop for most   */
-    /*  cases. So, let's restore system colors here now.       */
-#ifndef _WIN64
-    wd = ( WINDOW_DATA* )GetWindowLong ( win, GWL_USERDATA );
-#else
-    wd = ( WINDOW_DATA* )GetWindowLong ( win, GWLP_USERDATA );
-#endif
-
-    if ( wd != NULL ) InterfaceGraphic_RealizePalette (
-		     hte -> hDC, wd -> hPal, TRUE, s_sysPalInUse);
-#endif  /* _DEBUG */
-
-    if ( --hte -> nUsed == 0 ) 
-    { 
-#ifdef OCC954    
-      if ( wglGetCurrentContext() != NULL )
-#endif
-	wglDeleteContext ( hte -> hGLRC );
-	ReleaseDC ( win, hte -> hDC );
-	cmn_freemem (  ( void* )hte  );
-	cmn_delete_from_htbl (  txgltbl, (Tint ) win, ( void** )&hte  );
-    }  
-
-#endif  /* WNT */
-
-}
-
-/*----------------------------------------------------------------------*/
-
-int
-TxglGetDither(void)
-{
-    return DitherProp;
-}
-
-/*----------------------------------------------------------------------*/
-
-int
-TxglGetBackDither(void)
-{
-    return BackDitherProp;
-}
-
-
-/*----------------------------------------------------------------------*/
-/*RIC120302*/
-GLXContext 
-TxglGetContext( Window win )
-{
-    cmn_htbl_elem  rec;
-    GLXContext ctx;
-
-    rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&ctx  );
-    if( !rec ) return NULL;
-    return ctx;
-}
-/*RIC120302*/
-
-/*----------------------------------------------------------------------*/
-enum { ZERO = 0, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN };
-
-/* Unused :*/
-#ifdef TRACE
-static const char*
-className( int class )
-{
-    static char      *classes[] = {
-	    "StaticGray",
-	    "GrayScale",
-	    "StaticColor",
-	    "PseudoColor",
-	    "TrueColor",
-	    "DirectColor",
-    };
-    
-    if ( class < ZERO || class > FIVE )
-	    return "unknown";
-    else
-	    return classes[class];
-}
-#endif
-/*----------------------------------------------------------------------*/
-#ifndef WNT
-
-#ifdef TRACE
-static GLvoid printVisualInfo( Display  *display, XVisualInfo *glxVisual )
-{
-
-#define TrueFalse(x)  ( x ? "True" : "False" )
-
-    int        tmp;
-
-    printf("\n" );
-    printf("   X Visual Information ...\n\n" );
-    printf("\tvisualid : 0x%x\n", glxVisual->visualid );
-    printf("\tclass    : %s\n\n", className( glxVisual->class ) );
-
-    glXGetConfig(display, glxVisual, GLX_USE_GL, &tmp);
-    printf( "\tSupport GL ( GLX_USE_GL ) : %s\n", TrueFalse(tmp) );
-
-    glXGetConfig(display, glxVisual, GLX_LEVEL, &tmp);
-    printf( "\tFramebuffer ( GLX_LEVEL ) : %s\n\n",
-	    (tmp < ZERO) ? "Underlay" : (tmp == ZERO ? "Normal"  : tmp > ONE ? "Overlay"  : "Popup") );
-
-    glXGetConfig(display, glxVisual, GLX_BUFFER_SIZE, &tmp);
-    printf( "\tFramebuffer depth ( GLX_BUFFER_SIZE )     : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_DOUBLEBUFFER, &tmp);
-    printf( "\tDoublebuffer ( GLX_DOUBLEBUFFER )         : %s\n",
-	    TrueFalse(tmp) );
-
-    glXGetConfig(display, glxVisual, GLX_DEPTH_SIZE, &tmp);
-    printf( "\tDepth buffer depth ( GLX_DEPTH_SIZE )     : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_STENCIL_SIZE, &tmp);
-    printf( "\tStencil buffer depth ( GLX_STENCIL_SIZE ) : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_STEREO, &tmp);
-    printf( "\tStereo Buffer ( GLX_STEREO )              : %s\n",
-	    TrueFalse(tmp) );
-
-    glXGetConfig(display, glxVisual, GLX_AUX_BUFFERS, &tmp);
-    printf( "\tAuxillary Buffers ( GLX_AUX_BUFFERS)      : %d\n\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_RGBA, &tmp);
-    printf( "\tColor mode ( GLX_RGBA )       : %s\n", tmp ? "RGBA" :
-	    "Color Index" );
-
-    glXGetConfig(display, glxVisual, GLX_RED_SIZE, &tmp);
-    printf( "\tRed Bits ( GLX_RED_SIZE )     : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_GREEN_SIZE, &tmp);
-    printf( "\tGreen Bits ( GLX_GREEN_SIZE ) : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_BLUE_SIZE, &tmp);
-    printf( "\tBlue Bits ( GLX_BLUE_SIZE )   : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_ALPHA_SIZE, &tmp);
-    printf( "\tAlpha Bits ( GLX_ALPHA_SIZE ) : %d\n\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_ACCUM_RED_SIZE, &tmp);
-    printf( "\tRed Accumulation Bits ( GLX_ACCUM_RED_SIZE )     : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_ACCUM_GREEN_SIZE, &tmp);
-    printf( "\tGreen Accumulation Bits ( GLX_ACCUM_GREEN_SIZE ) : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_ACCUM_BLUE_SIZE, &tmp);
-    printf( "\tBlue Accumulation Bits ( GLX_ACCUM_BLUE_SIZE )   : %d\n", tmp );
-
-    glXGetConfig(display, glxVisual, GLX_ACCUM_ALPHA_SIZE, &tmp);
-    printf( "\tAlpha Accumulation Bits ( GLX_ACCUM_ALPHA_SIZE ) : %d\n\n", tmp );
-}
-#endif
-#endif  /* WNT */
-/*----------------------------------------------------------------------*/
+/***********************************************************************
+
+     FONCTION :
+     ----------
+        File OpenGl_txgl :
+ 
+
+     REMARQUES:
+     ---------- 
+      
+
+     HISTORIQUE DES MODIFICATIONS   :
+     --------------------------------
+       xx-xx-xx : xxx ; Creation.
+       07-02-96 : FMN ; Suppression code inutile:
+			- TxglLink() et TxglUnlink()
+       08-03-96 : FMN ; Suppression variables globales
+			Ajout cmn_delete_from_htbl() dans TxglDestroyWindow()
+       21-03-96 : CAL ; test sur previous_ctx dans TxglDestroyWindow()
+			et dans TxglSetDbuff()
+       01-04-96 : CAL ; Integration MINSK portage WNT
+       15-04-96 : CAL ; Integration travail PIXMAP de Jim ROTH
+       26-04-96 : FMN ; Correction warning de compilation
+       20-06-96 : CAL ; Retrait du XDestroyWindow dans TxglDestroyWindow
+       18-07-96 : FMN ; Suppression code inutile: TxglSetWindow().
+       27-09-96 : CAL ; Portage WNT
+       16-10-96 : GG  ; Coder le parametre de GLX_DEPTH_SIZE a 1 plutot
+                        que 0 si l'on souhaite accroitre les performances
+                        de 50% en utilisant le ZBuffer hardware !!!
+                        Si la fenetre fournie a deja le bon visual pas
+                        la peine de creer une sous-fenetre.
+       16-10-96 : GG  ; Le dithering doit etre active aussi avec 12 plans
+                        de maniere a ameliorer la qualite
+       17-10-96 : FMN ; Ajout fonction printVisualInfo()
+       06-11-96 : CAL ; Remise a True du BackDitherProp pour < 12 plans
+       12-11-96 : CAL ; BackDitherProp = True pour <= 8 plans
+			BackDitherProp = False pour > 8 plans
+       29-01-97 : FMN ; Amelioration du tests pour le dithering
+			DitherProp = True pour <= 8 plans red
+			DitherProp = False pour > 8 plans red
+			Suppression de TxglSetDbuff()
+       06-06-97 : FMN ; Meilleure gestion glXMakeCurrent (pb avec LightWoks)
+			Suppression de previous_win
+       02-07-97 : FMN ; Suppression variable ESSAI
+       07-10-97 : FMN ; Simplification WNT 
+       13-10-97 : FMN ; Ajout wglShareLists
+       06-02-98 : FMN ; PRO11674: Suppression XSetErrorHandler(0) inutile
+       23-11-98 : CAL ; PRO16603: previous_ctx jamais remis a 0 pour eviter
+			la perte des lists.
+       07-12-98 : CAL ; PRO 16311 et PRO 11821
+       02.14.100 : JR : Warnings on WNT
+       14.07.06 : SAN : OCC12977: update previous_ctx properly in TxglDestroyWindow.
+                        Old code resulted in crashes on some ATI Radeon cards under Linux.
+
+************************************************************************/
+
+#define BUC60691	/*GG 06/06/00 Due to a severe bug in secondary 
+//			table hash-code computation not yet solve,
+//			It's necessary to compute the primary hash-key key
+//			correctly under WNT/W98. The actual method is wrong
+//			because a size 4 is used for this table instead
+//			a conventional prime number as under UNIX system (23).
+//			 Under W98 sometimes the function wglMakeContext() does
+//			not work for an UNKNOWN reason, the number of DC
+//			seems limited to 5 but nothing tell that the limit is
+//			reached !
+//			We try right now to recover this error by creating a new DC.
+*/
+
+#define RIC120303	/*GG Add new function TxglSetWindow using
+//			the GLXContext defined by the user
+//			Add new function TxglGetContext.
+*/
+
+#define OCC954  /*SAV: 13/11/02 - check GLRC before deleting it*/
+
+/*----------------------------------------------------------------------*/
+/*
+ * Includes
+ */
+ 
+#include <stdio.h>
+
+#include <OpenGl_tgl_all.h>
+
+#include <GL/gl.h>
+#include <GL/glu.h>
+
+#ifndef WNT
+# include <X11/Xlib.h>
+# include <X11/Xutil.h>
+# include <GL/glx.h>
+# include <OpenGl_telem_util.h>
+#else
+# include <OpenGl_cmn_memory.h>
+# define STRICT
+# include <InterfaceGraphic_WNT.hxx>
+# include <windows.h>
+
+typedef struct htbl_entry {
+	HDC   hDC;
+	HGLRC hGLRC;
+	int   nUsed;
+
+       } HTBL_ENTRY;
+	       
+int call_util_osd_getenv ( char*, char*, int );
+#endif  /* WNT */
+
+#include <OpenGl_cmn_htbl.h>
+#include <OpenGl_txgl.h>
+int call_util_osd_getenv( char * , char * , int ) ;
+
+/*----------------------------------------------------------------------*/
+/*
+ * Variables statiques
+ */
+
+static  cmn_htbl  txgltbl;		/* Hash table pour le GLXContext */
+
+#ifndef WNT
+static  int BackDitherProp = False;	/* Dithering pour le background */
+static  int DitherProp = True;		/* Dithering pour le trace	*/
+static	GLXContext previous_ctx = 0;	/* Use for share display list	*/
+static  GLXContext dead_ctx;            /* Context to be destroyed */
+static  Display *dead_dpy;              /* Display associated with dead_ctx */
+#else
+static  int BackDitherProp = FALSE;	/* Dithering pour le background */
+static  int DitherProp = TRUE;		/* Dithering pour le trace	*/
+static  BOOL s_sysPalInUse;             /* Flag to check system colors usage */ 
+static  HGLRC previous_ctx = 0;		/* Use for share display list	*/
+#endif /* WNT */
+
+/*----------------------------------------------------------------------*/
+/*
+ * Constantes
+ */
+
+#define NO_TRACE
+
+#define CALL_DEF_STRING_LENGTH 132
+
+#define WIN_HTBL_SIZE 23
+
+/*----------------------------------------------------------------------*/
+/*
+ * Fonctions statiques
+ */
+
+#ifndef WNT
+#ifdef TRACE
+static GLvoid printVisualInfo( Display *, XVisualInfo *glxVisual );
+#endif
+#else
+#ifdef BUC60691
+static BOOL win95 = FALSE;
+#endif
+
+static int find_pixel_format(HTBL_ENTRY * hte, PIXELFORMATDESCRIPTOR * pfd);
+
+__declspec( dllexport ) int __fastcall __OpenGl_INIT__ ( 
+                                        unsigned hInstance, unsigned long reason_for_call
+                                       ) {
+ if ( reason_for_call == DLL_PROCESS_ATTACH ) {
+
+ }
+ return 1;
+
+}  /* end __OpenGl_INIT__ */
+#endif  /* WNT */
+
+/*----------------------------------------------------------------------*/
+
+Window
+TxglCreateWindow( Display  *disp, Window par,
+	Tint x, Tint y, Tint w, Tint h, Tint bw,
+	Tfloat bgcolr, Tfloat bgcolg, Tfloat bgcolb )
+{
+
+#ifndef WNT
+
+    GLXContext ctx;
+    static int sdesc[11];
+    Colormap cmap;
+    XVisualInfo* vis=NULL;
+/*    XVisualInfo tmplt;*/
+    XSetWindowAttributes cwa;
+    XColor color;
+/*    Tint i, n, nret;*/
+    Tint n;
+    Tint scr;
+    int value;
+    char string[CALL_DEF_STRING_LENGTH];
+    int DBuffer = True;
+    XWindowAttributes wattr;
+
+    Window win;
+
+    unsigned long mask = 0;
+/*    unsigned long background_pixel = 0;*/
+
+    if (call_util_osd_getenv("CALL_OPENGL_NO_DBF", string, CALL_DEF_STRING_LENGTH))
+        DBuffer    = False;
+
+    if (call_util_osd_getenv("JWR_PIXMAP_DB", string, CALL_DEF_STRING_LENGTH))
+        TelSetPixmapDB(1);
+
+    XGetWindowAttributes( disp , par , &wattr );
+
+    n = 0;
+    sdesc[n] = GLX_RGBA;n++;
+
+    sdesc[n] = GLX_DEPTH_SIZE;n++;
+    sdesc[n] = 1;n++;
+
+    sdesc[n] = GLX_RED_SIZE;n++;
+    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
+
+    sdesc[n] = GLX_GREEN_SIZE;n++;
+    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
+
+    sdesc[n] = GLX_BLUE_SIZE;n++;
+    sdesc[n] = (wattr.depth <= 8) ? 0 : 1;n++;
+
+    if (DBuffer) {
+      sdesc[n] = GLX_DOUBLEBUFFER;n++;
+    }
+
+    sdesc[n] = None;n++;
+
+    scr = DefaultScreen( disp );
+
+#if defined(__linux) || defined(Linux)
+    {
+      XVisualInfo vinfo;
+      int ninfo;
+      unsigned long vmask = VisualIDMask |  VisualScreenMask;
+      vinfo.visualid = wattr.visual->visualid;
+      vinfo.screen = DefaultScreen( disp );
+      vis = XGetVisualInfo( disp, vmask, &vinfo, &ninfo);
+    }
+#endif
+
+    if( !vis )
+    	vis = glXChooseVisual( disp, scr, sdesc );
+    if( !vis) return TFailure;
+
+#ifdef TRACE
+    printf ("TxglCreateWindow \n");
+    printf ("Informations sur le visual\n");
+    printf ("par visualid %x%x %d\n", wattr.visual->visualid, wattr.visual->visualid);
+    printf ("vis visualid 0x%x %d\n", vis->visualid, vis->visualid);
+    printf ("vis depth %d\n", vis->depth);
+    printf ("vis class %d\n", vis->class);
+    printf ("vis red_mask %ld\n", vis->red_mask);
+    printf ("vis green_mask %ld\n", vis->green_mask);
+    printf ("vis blue_mask %ld\n", vis->blue_mask);
+    printf ("vis colormap_size %d\n", vis->colormap_size);
+    printf ("vis bits_per_rgb %d\n", vis->bits_per_rgb);
+    printVisualInfo( disp, vis );
+#endif
+
+    /*
+     * Le BackDitherProp est utilise pour le clear du background
+     * Pour eviter une difference de couleurs avec la couleur choisie
+     * par l'application (XWindow) il faut desactiver le dithering
+     * au dessus de 8 plans.
+     * 
+     * Pour le DitherProp:
+     * On cherchera a activer le Dithering que si le Visual a au moins
+     * 8 plans pour le GLX_RED_SIZE. Le test est plus sur car on peut
+     * avoir une profondeur superieure a 12 mais avoir besoin du dithering.
+     * (Carte Impact avec GLX_RED_SIZE a 5 par exemple)
+     */
+
+    glXGetConfig( disp, vis, GLX_RED_SIZE, &value );
+
+    if ( value < 8 ) {
+        DitherProp = True;
+    }
+    else
+    {
+        DitherProp = False;
+    }
+
+    if ( vis->depth <= 8 ) {
+        BackDitherProp = True;
+    }
+    else
+    {
+        BackDitherProp = False;
+    }
+
+#ifdef TRACE
+    printf("Dithering %d BackDithering %d \n",DitherProp,BackDitherProp);
+#endif
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
+        DitherProp = False;
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
+        BackDitherProp = False;
+
+    if (dead_ctx) {
+	/* recover display lists from dead_ctx, then destroy it */
+	ctx = glXCreateContext( disp, vis, dead_ctx, GL_TRUE );
+	glXDestroyContext(dead_dpy, dead_ctx);
+	dead_ctx = 0;
+    } else if (previous_ctx == 0) {
+        ctx = glXCreateContext( disp, vis, NULL, GL_TRUE );
+    } else {
+	/* ctx est une copie du previous */
+    	ctx = glXCreateContext( disp, vis, previous_ctx, GL_TRUE );
+    }
+    previous_ctx = ctx;
+
+    if( !ctx) return TFailure;
+
+    cmap = XCreateColormap( disp,  par, vis->visual, AllocNone );
+
+    color.red	= (unsigned short) (bgcolr * 0xFFFF);
+    color.green	= (unsigned short) (bgcolg * 0xFFFF);
+    color.blue	= (unsigned short) (bgcolb * 0xFFFF);
+    color.flags	= DoRed | DoGreen | DoBlue;
+    XAllocColor( disp, cmap, &color );
+
+    cwa.colormap	= cmap;
+    cwa.event_mask	= StructureNotifyMask;
+    cwa.border_pixel	= color.pixel;
+    cwa.background_pixel = color.pixel;
+
+    mask = CWBackPixel | CWColormap | CWBorderPixel | CWEventMask;
+
+    if( vis->visualid == wattr.visual->visualid ) {
+      win = par;
+    } 
+    else 
+    {
+      win = XCreateWindow( disp, par, x, y, w, h, bw,
+                         vis->depth, InputOutput, vis->visual,
+                         mask, &cwa );
+    }
+
+#ifdef TRACE
+    printf ("TxglCreateWindow win %x par %x \n", win, par);
+#endif
+
+    XSetWindowBackground( disp, win, cwa.background_pixel );
+    XClearWindow( disp, win );
+
+    /* if in Pixmap double buffering mode, set up pixmap */
+
+    if (TelTestPixmapDB())
+    {
+        GC gc;
+        Pixmap pixmap;
+        GLXPixmap glxpixmap;
+
+        printf("setting up pixmap double buffering\n");
+
+        gc = XCreateGC(disp, win, 0, NULL);
+
+        pixmap = XCreatePixmap(disp, win, w, h, vis->depth);
+
+        glxpixmap = glXCreateGLXPixmap(disp, vis, pixmap);
+
+        glXMakeCurrent(disp, glxpixmap, ctx);
+
+        glDrawBuffer(GL_FRONT);
+
+        TelSetPixmapDBParams(disp, win, w, h, vis->depth, gc, pixmap, glxpixmap, ctx);
+    }
+
+    XFree((char*)vis);
+
+    if( !txgltbl )
+    {
+	/*
+	 * PRO 16311 et PRO 11821
+	 * txgltbl = cmn_create_htbl(  sizeof( GLXContext)+1 );
+	 */
+	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
+	if( !txgltbl ) return 0;
+    }
+    cmn_add_in_htbl( txgltbl, win, ctx );
+
+    return win;
+
+#else /* WNT */
+
+    cmn_htbl_elem         rec;
+    HTBL_ENTRY*           hte;
+    PIXELFORMATDESCRIPTOR pfd;
+    int                   iPixelFormat;
+    char                  string[ CALL_DEF_STRING_LENGTH ];
+
+#ifdef BUC60691
+    OSVERSIONINFO os;
+    os.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
+    GetVersionEx(&os);
+    if( os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) win95 = TRUE; 
+#endif
+
+    if ( txgltbl ) 
+    {
+	rec = cmn_find_in_htbl (  txgltbl, ( Tint )par, ( void** )&hte  );
+	
+	if ( rec ) 
+	{
+	    ++hte -> nUsed;
+	    printf("*TxglCreateWindow.window %d is alreday created\n",par);
+	    return par;
+	}  
+    }  
+
+    hte = ( HTBL_ENTRY* )cmn_getmem (  1, sizeof ( HTBL_ENTRY ), 1  );
+    
+    if ( !hte ) return 0;
+    hte -> hDC   = GetDC ( par );
+
+    iPixelFormat = find_pixel_format(hte, &pfd);
+
+    if ( !iPixelFormat ) {
+      printf ("*OpenGL interface: ChoosePixelFormat failed. Error code: %d\n",
+              GetLastError ());
+
+      ReleaseDC ( par, hte -> hDC );
+      cmn_freemem (  ( void* )hte  );
+
+      return 0;
+    }
+
+    if ( pfd.dwFlags & PFD_NEED_PALETTE ) 
+    {
+#ifndef _WIN64
+	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWL_USERDATA );
+#else
+	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWLP_USERDATA );
+#endif
+	
+	InterfaceGraphic_RealizePalette (hte -> hDC, wd -> hPal, FALSE,
+	    s_sysPalInUse = pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE ? TRUE : FALSE); 
+    }  
+
+    if ( pfd.cColorBits <= 8 ) 
+    { 
+	DitherProp     = TRUE;
+	BackDitherProp = TRUE;    
+    }  
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
+	DitherProp = FALSE;
+    
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
+	BackDitherProp = FALSE;
+
+    if (  !SetPixelFormat ( hte -> hDC, iPixelFormat, &pfd )  ) 
+    {
+	printf ("*OpenGL interface: SetPixelFormat failed. Error code %d\n",GetLastError ()); 
+	ReleaseDC ( par, hte -> hDC );
+	cmn_freemem (  ( void* )hte  );   
+	return 0; 
+    }  
+
+    hte -> hGLRC = wglCreateContext ( hte -> hDC );
+    
+    if ( !hte -> hGLRC ) 
+    { 
+	printf ("*OpenGL interface: wglCreateContext failed. Error code: %d\n",GetLastError ());    
+	return 0;  	  
+    }  
+
+    if ( previous_ctx != NULL )
+    {
+      wglShareLists ( previous_ctx, hte -> hGLRC );
+    }
+    previous_ctx = hte->hGLRC;
+
+    if ( !txgltbl ) 
+    {
+#ifdef BUC60691
+	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
+#else
+	txgltbl = cmn_create_htbl (  sizeof ( HTBL_ENTRY* )  );
+#endif
+	
+	if ( !txgltbl ) 
+	{
+	    ReleaseDC ( par, hte -> hDC );
+	    cmn_freemem (  ( void* )hte );
+	    printf( "*OpenGL interface: cmn_create_htbl failed\n" );
+	}  
+    }  
+    
+    cmn_add_in_htbl (  txgltbl, ( Tint )par, hte  );
+    
+    return par;
+
+#endif  /* WNT */
+
+}
+
+#ifdef RIC120302
+Window
+TxglSetWindow( Display  *disp, Window par, GLXContext ctx)
+{
+#ifndef WNT
+    XVisualInfo* vis;
+    char string[CALL_DEF_STRING_LENGTH];
+    XWindowAttributes wattr;
+
+    XGetWindowAttributes( disp , par , &wattr );
+    {
+      unsigned long vmask = VisualIDMask |  VisualScreenMask;
+      XVisualInfo vinfo;
+      int ninfo;
+      vinfo.visualid = wattr.visual->visualid;
+      vinfo.screen = DefaultScreen( disp );
+      vis = XGetVisualInfo( disp, vmask, &vinfo, &ninfo);
+    }
+
+    if( !vis) return TFailure;
+
+#ifdef TRACE
+    printf ("TxglSetWindow \n");
+    printf ("Informations sur le visual\n");
+    printf ("par visualid %x%x %d\n", wattr.visual->visualid, wattr.visual->visualid);
+    printf ("vis visualid 0x%x %d\n", vis->visualid, vis->visualid);
+    printf ("vis depth %d\n", vis->depth);
+    printf ("vis class %d\n", vis->class);
+    printf ("vis red_mask %ld\n", vis->red_mask);
+    printf ("vis green_mask %ld\n", vis->green_mask);
+    printf ("vis blue_mask %ld\n", vis->blue_mask);
+    printf ("vis colormap_size %d\n", vis->colormap_size);
+    printf ("vis bits_per_rgb %d\n", vis->bits_per_rgb);
+    printVisualInfo( disp, vis );
+#endif
+
+    /*
+     * Le BackDitherProp est utilise pour le clear du background
+     * Pour eviter une difference de couleurs avec la couleur choisie
+     * par l'application (XWindow) il faut desactiver le dithering
+     * au dessus de 8 plans.
+     * 
+     * Pour le DitherProp:
+     * On cherchera a activer le Dithering que si le Visual a au moins
+     * 8 plans pour le GLX_RED_SIZE. Le test est plus sur car on peut
+     * avoir une profondeur superieure a 12 mais avoir besoin du dithering.
+     * (Carte Impact avec GLX_RED_SIZE a 5 par exemple)
+     */
+
+    {
+      int value;
+      glXGetConfig( disp, vis, GLX_RED_SIZE, &value );
+
+      if ( value < 8 ) {
+        DitherProp = True;
+      } else {
+        DitherProp = False;
+      }
+
+      if ( vis->depth <= 8 ) {
+        BackDitherProp = True;
+      } else {
+        BackDitherProp = False;
+      }
+    }
+
+#ifdef TRACE
+    printf("Dithering %d BackDithering %d \n",DitherProp,BackDitherProp);
+#endif
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
+        DitherProp = False;
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
+        BackDitherProp = False;
+
+    previous_ctx = ctx;
+
+    XFree((char*)vis);  
+
+    if( !txgltbl ) {
+	/*
+	 * PRO 16311 et PRO 11821
+	 * txgltbl = cmn_create_htbl(  sizeof( GLXContext)+1 );
+	 */
+	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
+	if( !txgltbl ) return 0;
+    }
+    cmn_add_in_htbl( txgltbl, par, ctx );
+
+#else /* WNT */
+
+    cmn_htbl_elem         rec;
+    HTBL_ENTRY*           hte;
+    PIXELFORMATDESCRIPTOR pfd;
+    int                   iPixelFormat;
+    char                  string[ CALL_DEF_STRING_LENGTH ];
+
+#ifdef BUC60691
+    OSVERSIONINFO os;
+    os.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
+    GetVersionEx(&os);
+    if( os.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) win95 = TRUE; 
+#endif
+
+    if ( txgltbl ) 
+    {
+	rec = cmn_find_in_htbl (  txgltbl, ( Tint )par, ( void** )&hte  );
+	
+	if ( rec ) 
+	{
+	    ++hte -> nUsed;
+	    printf("*TxglSetWindow.window %d is alreday created\n",par);
+	    return par;
+	}  
+    }  
+
+    hte = ( HTBL_ENTRY* )cmn_getmem (  1, sizeof ( HTBL_ENTRY ), 1  );
+    
+    if ( !hte ) return 0;
+    hte -> hDC   = GetDC ( par );
+
+    iPixelFormat = find_pixel_format(hte, &pfd);
+
+    if ( !iPixelFormat ) {
+      printf ("*OpenGL interface: ChoosePixelFormat failed. Error code: %d\n",
+              GetLastError ());
+
+      ReleaseDC ( par, hte -> hDC );
+      cmn_freemem (  ( void* )hte  );
+
+      return 0;
+    }
+
+
+    if ( pfd.dwFlags & PFD_NEED_PALETTE ) 
+    {
+#ifndef _WIN64
+	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWL_USERDATA );
+#else
+	WINDOW_DATA* wd = ( WINDOW_DATA* )GetWindowLong ( par, GWLP_USERDATA );
+#endif
+	
+	InterfaceGraphic_RealizePalette (hte -> hDC, wd -> hPal, FALSE,
+	    s_sysPalInUse = pfd.dwFlags & PFD_NEED_SYSTEM_PALETTE ? TRUE : FALSE); 
+    }
+
+    if ( pfd.cColorBits <= 8 ) 
+    { 
+	DitherProp     = TRUE;
+	BackDitherProp = TRUE;    
+    }  
+
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_DITHER", string, CALL_DEF_STRING_LENGTH))
+	DitherProp = FALSE;
+    
+    if (call_util_osd_getenv ("CALL_OPENGL_NO_BACKDITHER", string, CALL_DEF_STRING_LENGTH))
+	BackDitherProp = FALSE;
+
+    if (  !SetPixelFormat ( hte -> hDC, iPixelFormat, &pfd )  ) 
+    {
+	printf ("*OpenGL interface: SetPixelFormat failed. Error code %d\n",GetLastError ()); 
+	ReleaseDC ( par, hte -> hDC );
+	cmn_freemem (  ( void* )hte  );   
+	return 0; 
+    }  
+
+    hte -> hGLRC = previous_ctx = ctx;
+    
+    if ( !txgltbl ) 
+    {
+#ifdef BUC60691
+	txgltbl = cmn_create_htbl( WIN_HTBL_SIZE );
+#else
+	txgltbl = cmn_create_htbl (  sizeof ( HTBL_ENTRY* )  );
+#endif
+	
+	if ( !txgltbl ) 
+	{
+	    ReleaseDC ( par, hte -> hDC );
+	    cmn_freemem (  ( void* )hte );
+	    printf( "*OpenGL interface: cmn_create_htbl failed\n" );
+	}  
+    }  
+    
+    cmn_add_in_htbl (  txgltbl, ( Tint )par, hte  );
+
+#endif  /* WNT */
+
+    return par;
+
+}
+#endif /*RIC120302*/
+
+/*----------------------------------------------------------------------*/
+
+TStatus
+TxglWinset( Display *disp, Window win )
+{
+
+#ifndef WNT
+
+    Bool  i;
+    GLXContext ctx;
+    cmn_htbl_elem  rec;
+    GLenum errorcode;
+    const GLubyte *errorstring;
+
+    if( !txgltbl ) return TFailure;
+
+    rec = cmn_find_in_htbl( txgltbl, win, (void**)&ctx );
+    if( !rec ) return TFailure;
+
+#ifdef TRACE
+    printf ("TxglWinset::glXMakeCurrent %x \n", win);
+#endif
+    if (TelTestPixmapDB())
+      {
+        i = glXMakeCurrent(disp, TelGetGLXPixmap(), ctx);
+      }
+    else
+      {
+        i = glXMakeCurrent(disp, win, ctx);  /* TRUE/FALSE */
+      }
+    if (!i)
+      {
+	errorcode = glGetError();
+	errorstring = gluErrorString(errorcode);
+	printf("glXMakeCurrent failed: %d %s\n", errorcode, errorstring);
+      }
+
+    return  i == True ? TSuccess : TFailure;
+
+#else /* WNT */
+
+    HTBL_ENTRY*   hte;
+    cmn_htbl_elem rec;
+    HDC    hdc    = NULL;
+    HGLRC  hglrc  = NULL;
+    TStatus       retVal = TFailure;
+
+    __try {
+    
+	if ( !txgltbl ) __leave;
+		
+	if (    !(   rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&hte  )   )    ) {
+	  printf("OpenGL interface:  TxglWinset failed.UNKNOWN win %x\n",win);
+	  __leave;
+	}
+
+#ifdef BUC60691
+      if( win95 ) {
+	  retVal = ReleaseDC ( win, hte -> hDC );
+	  hte -> hDC   = GetDC ( win );
+      }		
+#endif
+	if (  !wglMakeCurrent ( hte -> hDC, hte -> hGLRC )  ) 
+	{
+#ifdef BUC60691
+    	   GLenum errorcode;
+    	   const GLubyte *errorstring;
+
+	   errorcode = glGetError();
+	   errorstring = gluErrorString(errorcode);
+	   printf("wglMakeCurrent failed: %d %s\n", errorcode, errorstring);
+#else
+	    printf ("OpenGL interface: wglMakeCurrent failed. Error code: %d\n",GetLastError ());
+#endif
+	    retVal = TFailure;	
+	} else retVal = TSuccess;
+    
+    }  /* end __try */
+
+
+    __finally 
+    {    
+    }  
+
+    return retVal;
+
+#endif  /* WNT */
+
+}
+
+/*----------------------------------------------------------------------*/
+
+Window
+TxglGetSubWindow( Display *disp, Window win )
+                               /* This function assumes that there is only
+                                  one child for the parent */
+{
+
+#ifndef WNT
+
+   Window root, parent, *child, w;
+   unsigned int num;
+
+   if( XQueryTree( disp, win, &root, &parent, &child, &num ) )
+   {
+      if (! num) return win;
+      w = child[0];
+      XFree( (char *)child );
+      return w;
+   }
+   else
+      return 0;
+
+#else /* WNT */
+
+   return win;
+
+#endif  /* WNT */
+
+}
+
+/*----------------------------------------------------------------------*/
+
+void
+TxglDestroyWindow( Display *disp, Window win )
+{
+
+#ifndef WNT
+
+    GLXContext ctx;
+    cmn_htbl_elem rec;
+    Tint dummy;
+    
+    if( !txgltbl ) return ;
+    
+    rec = cmn_find_in_htbl( txgltbl, win, (void**)&ctx );
+    if( !rec ) return ;
+
+    /* FSXXX sync necessary if non-direct rendering */
+    glXWaitGL();
+
+    cmn_delete_from_htbl( txgltbl, win, (void**)&ctx );
+
+    if (previous_ctx == ctx) {
+      /* san -- OCC12977: it's important to put some valid GLXContext or null into
+	 previous_ctx here, otherwise next glxCreateContext() will crash on some ATI Radeon cards
+      */
+      cmn_get_from_htbl( txgltbl, &dummy, (void**)&previous_ctx, 0 );
+      /*
+       * if this is the last remaining context, do not destroy it yet, to avoid
+       * losing any shared display lists (fonts...)
+       */
+      if (previous_ctx) {
+	glXDestroyContext(disp, ctx);
+      } else {
+	dead_ctx = ctx;
+	dead_dpy = disp;
+      }
+    } else {
+      glXDestroyContext(disp, ctx);
+    }
+
+#else /* WNT */
+
+    HTBL_ENTRY*   hte;
+    cmn_htbl_elem rec;
+#ifdef _DEBUG 
+    WINDOW_DATA*  wd;
+#endif  /* _DEBUG */
+    
+    if ( !txgltbl ) return;
+
+    rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&hte  );
+    if ( !rec ) return;
+    
+#ifdef _DEBUG 
+    /* In release version of application we need to process    */
+    /*  palette messages in the main application message loop. */
+    /*  In debug version we don't have message loop for most   */
+    /*  cases. So, let's restore system colors here now.       */
+#ifndef _WIN64
+    wd = ( WINDOW_DATA* )GetWindowLong ( win, GWL_USERDATA );
+#else
+    wd = ( WINDOW_DATA* )GetWindowLong ( win, GWLP_USERDATA );
+#endif
+
+    if ( wd != NULL ) InterfaceGraphic_RealizePalette (
+		     hte -> hDC, wd -> hPal, TRUE, s_sysPalInUse);
+#endif  /* _DEBUG */
+
+    if ( --hte -> nUsed == 0 )
+    {
+      cmn_delete_from_htbl( txgltbl, ( Tint )win, (void**)&hte );
+      if ( previous_ctx == hte->hGLRC ) {
+        HTBL_ENTRY* prvHte;
+        Tint dummy;
+        cmn_get_from_htbl ( txgltbl, &dummy, (void**)&prvHte, 0 );
+        if ( prvHte != 0 ) {
+          previous_ctx = prvHte->hGLRC;
+        } else {
+          previous_ctx = NULL;
+        }
+      }
+#ifdef OCC954    
+      if ( wglGetCurrentContext() != NULL )
+#endif
+	wglDeleteContext ( hte -> hGLRC );
+	ReleaseDC ( win, hte -> hDC );
+	cmn_freemem (  ( void* )hte  );
+	cmn_delete_from_htbl (  txgltbl, (Tint ) win, ( void** )&hte  );
+    }  
+
+#endif  /* WNT */
+
+}
+
+/*----------------------------------------------------------------------*/
+
+int
+TxglGetDither(void)
+{
+    return DitherProp;
+}
+
+/*----------------------------------------------------------------------*/
+
+int
+TxglGetBackDither(void)
+{
+    return BackDitherProp;
+}
+
+
+/*----------------------------------------------------------------------*/
+/*RIC120302*/
+GLXContext 
+TxglGetContext( Window win )
+{
+    cmn_htbl_elem  rec;
+    GLXContext ctx;
+
+    rec = cmn_find_in_htbl (  txgltbl, ( Tint )win, ( void** )&ctx  );
+    if( !rec ) return NULL;
+    return ctx;
+}
+/*RIC120302*/
+
+/*----------------------------------------------------------------------*/
+enum { ZERO = 0, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN };
+
+/* Unused :*/
+#ifdef TRACE
+static const char*
+className( int class )
+{
+    static char      *classes[] = {
+	    "StaticGray",
+	    "GrayScale",
+	    "StaticColor",
+	    "PseudoColor",
+	    "TrueColor",
+	    "DirectColor",
+    };
+    
+    if ( class < ZERO || class > FIVE )
+	    return "unknown";
+    else
+	    return classes[class];
+}
+#endif
+/*----------------------------------------------------------------------*/
+#ifndef WNT
+
+#ifdef TRACE
+static GLvoid printVisualInfo( Display  *display, XVisualInfo *glxVisual )
+{
+
+#define TrueFalse(x)  ( x ? "True" : "False" )
+
+    int        tmp;
+
+    printf("\n" );
+    printf("   X Visual Information ...\n\n" );
+    printf("\tvisualid : 0x%x\n", glxVisual->visualid );
+    printf("\tclass    : %s\n\n", className( glxVisual->class ) );
+
+    glXGetConfig(display, glxVisual, GLX_USE_GL, &tmp);
+    printf( "\tSupport GL ( GLX_USE_GL ) : %s\n", TrueFalse(tmp) );
+
+    glXGetConfig(display, glxVisual, GLX_LEVEL, &tmp);
+    printf( "\tFramebuffer ( GLX_LEVEL ) : %s\n\n",
+	    (tmp < ZERO) ? "Underlay" : (tmp == ZERO ? "Normal"  : tmp > ONE ? "Overlay"  : "Popup") );
+
+    glXGetConfig(display, glxVisual, GLX_BUFFER_SIZE, &tmp);
+    printf( "\tFramebuffer depth ( GLX_BUFFER_SIZE )     : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_DOUBLEBUFFER, &tmp);
+    printf( "\tDoublebuffer ( GLX_DOUBLEBUFFER )         : %s\n",
+	    TrueFalse(tmp) );
+
+    glXGetConfig(display, glxVisual, GLX_DEPTH_SIZE, &tmp);
+    printf( "\tDepth buffer depth ( GLX_DEPTH_SIZE )     : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_STENCIL_SIZE, &tmp);
+    printf( "\tStencil buffer depth ( GLX_STENCIL_SIZE ) : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_STEREO, &tmp);
+    printf( "\tStereo Buffer ( GLX_STEREO )              : %s\n",
+	    TrueFalse(tmp) );
+
+    glXGetConfig(display, glxVisual, GLX_AUX_BUFFERS, &tmp);
+    printf( "\tAuxillary Buffers ( GLX_AUX_BUFFERS)      : %d\n\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_RGBA, &tmp);
+    printf( "\tColor mode ( GLX_RGBA )       : %s\n", tmp ? "RGBA" :
+	    "Color Index" );
+
+    glXGetConfig(display, glxVisual, GLX_RED_SIZE, &tmp);
+    printf( "\tRed Bits ( GLX_RED_SIZE )     : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_GREEN_SIZE, &tmp);
+    printf( "\tGreen Bits ( GLX_GREEN_SIZE ) : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_BLUE_SIZE, &tmp);
+    printf( "\tBlue Bits ( GLX_BLUE_SIZE )   : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_ALPHA_SIZE, &tmp);
+    printf( "\tAlpha Bits ( GLX_ALPHA_SIZE ) : %d\n\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_ACCUM_RED_SIZE, &tmp);
+    printf( "\tRed Accumulation Bits ( GLX_ACCUM_RED_SIZE )     : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_ACCUM_GREEN_SIZE, &tmp);
+    printf( "\tGreen Accumulation Bits ( GLX_ACCUM_GREEN_SIZE ) : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_ACCUM_BLUE_SIZE, &tmp);
+    printf( "\tBlue Accumulation Bits ( GLX_ACCUM_BLUE_SIZE )   : %d\n", tmp );
+
+    glXGetConfig(display, glxVisual, GLX_ACCUM_ALPHA_SIZE, &tmp);
+    printf( "\tAlpha Accumulation Bits ( GLX_ACCUM_ALPHA_SIZE ) : %d\n\n", tmp );
+}
+#endif
+
+#else
+int find_pixel_format(HTBL_ENTRY * hte, PIXELFORMATDESCRIPTOR * pfd)
+{
+  int                   iPixelFormat = 0;
+  int                   iGood = 0;
+  int                   i, j;
+  PIXELFORMATDESCRIPTOR pfd0;
+  char                  string[ CALL_DEF_STRING_LENGTH ];
+  BOOL                  DBuffer = TRUE;
+  const int             cBits[] = { 32, 24 };
+  const int             dBits[] = { 32, 24, 16 };
+
+  if (call_util_osd_getenv ("CALL_OPENGL_NO_DBF",
+                            string, CALL_DEF_STRING_LENGTH)) 
+    DBuffer = FALSE;
+
+  pfd0.nSize           = sizeof ( PIXELFORMATDESCRIPTOR );
+  pfd0.nVersion        = 1;
+  pfd0.dwFlags         = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
+  pfd0.dwFlags        |= ( DBuffer ) ? PFD_DOUBLEBUFFER : PFD_SUPPORT_GDI;
+  pfd0.iPixelType      = PFD_TYPE_RGBA;
+  pfd0.cRedBits        = 0;
+  pfd0.cRedShift       = 0;
+  pfd0.cGreenBits      = 0;
+  pfd0.cGreenShift     = 0;
+  pfd0.cBlueBits       = 0;
+  pfd0.cBlueShift      = 0;
+  pfd0.cAlphaBits      = 0;
+  pfd0.cAlphaShift     = 0;
+  pfd0.cAccumBits      = 0;
+  pfd0.cAccumRedBits   = 0;
+  pfd0.cAccumGreenBits = 0;
+  pfd0.cAccumBlueBits  = 0;
+  pfd0.cAccumAlphaBits = 0;
+  pfd0.cStencilBits    = 0;
+  pfd0.cAuxBuffers     = 0;
+  pfd0.iLayerType      = PFD_MAIN_PLANE;
+  pfd0.bReserved       = 0;
+  pfd0.dwLayerMask     = 0;
+  pfd0.dwVisibleMask   = 0;
+  pfd0.dwDamageMask    = 0;
+
+  hte -> nUsed = 1;    
+
+  for (i = 0; i < sizeof(dBits) / sizeof(int); i++) {
+
+    pfd0.cDepthBits = dBits[i];
+    iGood = 0;
+    for (j = 0; j < sizeof(cBits) / sizeof(int); j++) {
+
+      pfd0.cColorBits = cBits[j];
+      iPixelFormat = ChoosePixelFormat ( hte -> hDC, &pfd0 );
+
+      if (iPixelFormat) {
+        pfd->cDepthBits = 0;
+        pfd->cColorBits = 0;
+        DescribePixelFormat (hte -> hDC, iPixelFormat,
+                             sizeof ( PIXELFORMATDESCRIPTOR ), pfd);
+        if (pfd->cColorBits >= cBits[j] && pfd->cDepthBits >= dBits[i])
+          break;
+        if (iGood == 0)
+          iGood = iPixelFormat;
+      }
+    }
+    if (j < sizeof(cBits) / sizeof(int))
+      break;
+  }
+
+  if ( !iPixelFormat )
+    iPixelFormat = iGood;
+
+  return iPixelFormat;
+}
+
+#endif  /* WNT */
+/*----------------------------------------------------------------------*/
diff -Naur OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_view.c OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_view.c
--- OpenCASCADE6.3.0.orig//ros/src/OpenGl/OpenGl_view.c	2010-07-04 20:15:21.572994113 +0200
+++ OpenCASCADE6.3.0/ros/src/OpenGl/OpenGl_view.c	2008-11-07 12:40:32.000000000 +0100
@@ -53,8 +53,8 @@
 ************************************************************************/
 
 #define BUC60920        /* GG 010601
-//                      Change the z buffer comparaison for minimizing
-//                      unavailable or unviewable drawing of pixels in the same plane
+                      Change the z buffer comparaison for minimizing
+                      unavailable or unviewable drawing of pixels in the same plane
 */
 
 #define BUC61044       /* 25/10/01 SAV ; added functionality to control gl depth testing
@@ -104,6 +104,7 @@
 /* OCC18942: The new perspective projection matrix is off by default */
 EXPORT extern GLboolean env_sym_perspective; /* defined in OpenGl_togl_begin.c */
 
+
 /*----------------------------------------------------------------------*/
 /*
  * Constantes
@@ -196,15 +197,16 @@
                           Tlimit3  *clip_limit
                         )
 {
-    Tfloat    gx, gy, xsf, ysf, zsf;
-    Tfloat    fpd, bpd;
-
+    Tdouble    gx, gy, xsf, ysf, zsf;
+    Tdouble    fpd, bpd;
+ 
     /* OCC18942 */
     Tfloat    n, f, r, l, t, b, Zprp, dx, dy, VPD;
 
     /* FSXXX */
     /* GLint gdtmp; */
     Tlimit3   vp = { ( float )-1.0, ( float )1.0, ( float )-1.0, ( float )1.0, ( float )1.0, ( float )-1.0 };
+
     Tmatrix3  pmat = { { ( float )1.0, ( float )0.0, ( float )0.0, ( float )0.0 },
                        { ( float )0.0, ( float )1.0, ( float )0.0, ( float )0.0 },
                        { ( float )0.0, ( float )0.0, ( float )1.0, ( float )0.0 },
@@ -292,21 +294,21 @@
                                            mapping->viewport.ymin, mapping->viewport.ymax);
 #endif
 
+   
     /* projection matrix */
     if( mapping->proj == TelParallel )
     {
-
         pmat[2][0] = -gx; pmat[3][0] = mapping->vpd*gx;
         pmat[2][1] = -gy; pmat[3][1] = mapping->vpd*gy;
     }
-    else if ( !env_sym_perspective )/* TelPerspective */
+    else if ( !env_sym_perspective)/* TelPerspective */
     {
         pmat[0][0] = pmat[1][1] = mapping->prp[2] - mapping->vpd;
-        pmat[2][0] = -gx; 
-        pmat[2][1] = -gy; 
+        pmat[2][0] = -gx;
+        pmat[2][1] = -gy;
         pmat[2][3] = ( float )-1.0;
-        pmat[3][0] = mapping->vpd * gx; 
-        pmat[3][1] = mapping->vpd * gy; 
+        pmat[3][0] = mapping->vpd * gx;
+        pmat[3][1] = mapping->vpd * gy;
         pmat[3][3] = mapping->prp[2];
 
         /* modify the next two cells to change clipping policy */
@@ -316,7 +318,7 @@
         pmat[3][2] = fpd * bpd; 
         }
     }
-    /* OCC18942: New approach to calculation of mapping (projection) matrix */
+   /* OCC18942: New approach to calculation of mapping (projection) matrix */
     else 
     {
       dx = mapping->window.xmax - mapping->window.xmin;
@@ -400,16 +402,18 @@
     zsf = (vp.zmax - vp.zmin) / (fpd - bpd);
 
     /* map matrix */
-    mmat[0][0] = xsf, mmat[1][1] = ysf, mmat[2][2] = zsf;
+    mmat[0][0] = xsf;
+	mmat[1][1] = ysf;
+	mmat[2][2] = zsf;
     mmat[3][0] = vp.xmin - xsf*mapping->window.xmin;
     mmat[3][1] = vp.ymin - ysf*mapping->window.ymin;
     mmat[3][2] = vp.zmin - zsf*bpd;
 
     /* multiply to obtain mapping matrix */
-    TelMultiplymat3( mat, pmat, mmat );
-
+	TelMultiplymat3( mat, pmat, mmat );
+    
 #ifdef PRINT
-    printf( "mapping_matrix :\n" );
+    printf( "mapping_matrix :\n");  
     pr_matrix(mat);
 #endif
 }
@@ -458,10 +462,10 @@
         TsmSetWSAttri( Wsid, WSViews, &key ); /* Set defined view data*/
     }
 
-    /* copy view definition to storage table record */
-    /* NOTE: Use the matrices already calculated and stored in vrep */
-    vptr->vrep = *vrep; 
-
+     /* copy view definition to storage table record */
+     /* NOTE: Use the matrices already calculated and stored in vrep */
+    vptr->vrep = *vrep;
+    
 #ifdef CAL_100498
     /* compute inverse transformation matrix */
     TelEvalInverseMatrix( vrep->extra.vrp, vrep->extra.vpn, vrep->extra.vup,
@@ -551,7 +555,8 @@
                               Tmatrix3  rmat  /* Out: Orientation Matrix  */
                             )
 {
-    Tfloat  u[3], v[3], n[3], f;
+	Tfloat  u[3], v[3], n[3], f;
+
 
     /* view plane normal of zero length */
     if( vecmag(vpn) == 0.0 )
@@ -636,7 +641,7 @@
 void
 TelEvalViewMappingMatrixPick( tel_view_mapping mapping /* View Mapping */,
                           Tint *error_ind          /* Out: Error Indicator */,
-                          Tmatrix3 mat             /* Out: Mapping Matrix */,
+                          Tmatrix3 mat             /* Out: Mapping Matrix */,  
                           Tfloat   cx,
                           Tfloat   cy
                         )
@@ -762,6 +767,7 @@
     Debug tool
 +*/
 
+
 #ifdef DEB
 void
 pr_matrix( Tmatrix3 mat )
@@ -855,7 +861,7 @@
         printf("OpenGl_view.c::TelSetViewIndex::glMatrixMode(GL_PROJECTION) \n"); 
 #endif
     glMatrixMode(GL_PROJECTION);
-    glLoadMatrixf((GLfloat *) vptr->vrep.mapping_matrix );
+	glLoadMatrixf((GLfloat *) vptr->vrep.mapping_matrix );
 
 #ifdef TRACE_MAT
     printf( "\nTelSetViewIndex WS : %d, view : %d", Wsid, Vid );
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ProjLib/ProjLib_ProjectedCurve.cxx OpenCASCADE6.3.0/ros/src/ProjLib/ProjLib_ProjectedCurve.cxx
--- OpenCASCADE6.3.0.orig//ros/src/ProjLib/ProjLib_ProjectedCurve.cxx	2010-07-04 20:15:27.915978587 +0200
+++ OpenCASCADE6.3.0/ros/src/ProjLib/ProjLib_ProjectedCurve.cxx	2010-03-02 05:47:56.000000000 +0100
@@ -1,4 +1,3 @@
- 
 // File:	ProjLib_ProjectedCurve.gxx
 // Created:	Wed Aug 25 15:39:45 1993
 // Author:	Bruno DUMORTIER
@@ -463,7 +462,6 @@
 //function : ProjLib_ProjectedCurve
 //purpose  : 
 //=======================================================================
-
 ProjLib_ProjectedCurve::ProjLib_ProjectedCurve()
 
 {
@@ -475,7 +473,6 @@
 //function : ProjLib_ProjectedCurve
 //purpose  : 
 //=======================================================================
-
 ProjLib_ProjectedCurve::ProjLib_ProjectedCurve
 (const Handle(Adaptor3d_HSurface)& S)
 {
@@ -488,7 +485,6 @@
 //function : ProjLib_ProjectedCurve
 //purpose  : 
 //=======================================================================
-
 ProjLib_ProjectedCurve::ProjLib_ProjectedCurve
 (const Handle(Adaptor3d_HSurface)& S,
  const Handle(Adaptor3d_HCurve)& C)
@@ -497,13 +493,10 @@
   Load(S);
   Load(C);
 }
-
-
 //=======================================================================
 //function : ProjLib_ProjectedCurve
 //purpose  : 
 //=======================================================================
-
 ProjLib_ProjectedCurve::ProjLib_ProjectedCurve
 (const Handle(Adaptor3d_HSurface)& S,
  const Handle(Adaptor3d_HCurve)&   C,
@@ -513,24 +506,18 @@
   Load(S);
   Load(C);
 }
-
-
 //=======================================================================
 //function : Load
 //purpose  : 
 //=======================================================================
-
 void ProjLib_ProjectedCurve::Load(const Handle(Adaptor3d_HSurface)& S)
 {
   mySurface = S ;
 }
-
-
 //=======================================================================
 //function : Load
 //purpose  : 
 //=======================================================================
-
 void ProjLib_ProjectedCurve::Load(const Handle(Adaptor3d_HCurve)& C)
 {
   myTolerance = Max(myTolerance,Precision::PApproximation());
@@ -769,13 +756,41 @@
     // Translate the projected curve to keep the first point
     // In the canonical boundaries of periodic surfaces.
     if (mySurface->IsUPeriodic()) {
-      myResult.UFrame(myCurve->FirstParameter(),
-			 myCurve->LastParameter(),
-			 mySurface->FirstUParameter(),
-			 mySurface->UPeriod());
-//  Modified by skv - Wed Aug 11 15:45:58 2004 OCC6272 Begin
-//  Correct the U isoline in periodical surface
-// to be inside restriction boundaries.
+      Standard_Real aT1, aT2, aU1, aU2, aUPeriod, aUr, aUm, aUmid, dUm, dUr;
+      GeomAbs_CurveType aTypeR;
+      ProjLib_Projector aResult;
+      //
+      aT1=myCurve->FirstParameter();
+      aT2=myCurve->LastParameter();
+      aU1=mySurface->FirstUParameter();
+      aU2=mySurface->LastUParameter();
+      aUPeriod=mySurface->UPeriod();
+      //
+      aTypeR=myResult.GetType();
+      if ((aU2-aU1)<(aUPeriod-myTolerance) && aTypeR == GeomAbs_Line) {
+	aResult=myResult;
+	aResult.UFrame(aT1, aT2, aU1, aUPeriod);
+	//
+	gp_Lin2d &aLr = (gp_Lin2d &) aResult.Line();
+	aUr=aLr.Location().X();
+	gp_Lin2d &aLm = (gp_Lin2d &) myResult.Line();
+	aUm=aLm.Location().X();
+	//
+	aUmid=0.5*(aU2+aU1);
+	dUm=fabs(aUm-aUmid);
+	dUr=fabs(aUr-aUmid);
+	if (dUr<dUm) {
+	  myResult=aResult;
+	}
+      }
+      else {
+	myResult.UFrame(aT1, aT2, aU1, aUPeriod);
+      }
+      //
+      
+      //  Modified by skv - Wed Aug 11 15:45:58 2004 OCC6272 Begin
+      //  Correct the U isoline in periodical surface
+      // to be inside restriction boundaries.
       if (myResult.GetType() == GeomAbs_Line) {
 	gp_Lin2d &aLine = (gp_Lin2d &) myResult.Line();
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Prs3d/Prs3d_ShadedShape.gxx OpenCASCADE6.3.0/ros/src/Prs3d/Prs3d_ShadedShape.gxx
--- OpenCASCADE6.3.0.orig//ros/src/Prs3d/Prs3d_ShadedShape.gxx	2010-07-04 20:15:15.835964550 +0200
+++ OpenCASCADE6.3.0/ros/src/Prs3d/Prs3d_ShadedShape.gxx	2010-03-23 14:26:58.000000000 +0100
@@ -41,6 +41,7 @@
 #include <gp_Vec.hxx>
 #include <StdPrs_WFShape.hxx>
 #include <BRepBndLib.hxx>
+#include <Precision.hxx>
 #ifdef G005
 #include <Graphic3d_ArrayOfTriangles.hxx>
 #endif
@@ -89,6 +90,9 @@
     Standard_Integer t[3], n[3];
     Standard_Integer nbTriangles = 0, nbVertices = 0;
 
+    // precision for compare square distances
+    double dPreci = Precision::Confusion()*Precision::Confusion();
+
     if ( !aDrawer->ShadingAspectGlobal() ) {
 
       Handle(Graphic3d_AspectFillArea3d) Asp = aDrawer->ShadingAspect()->Aspect();
@@ -149,15 +153,15 @@
 	      gp_Pnt P2 = Nodes(n[1]);
 	      gp_Pnt P3 = Nodes(n[2]);
 	      gp_Vec V1(P1,P2);
-	      if (V1.SquareMagnitude() > 1.e-10) {
+	      if ( V1.SquareMagnitude() > dPreci ) {
 	        gp_Vec V2(P2,P3);
-	        if (V2.SquareMagnitude() > 1.e-10) {
-	          gp_Vec V3(P3,P1);
-		  if (V3.SquareMagnitude() > 1.e-10) {
+	        if ( V2.SquareMagnitude() > dPreci ) {
+		  gp_Vec V3(P3,P1);
+		  if ( V3.SquareMagnitude() > dPreci ) {
 		    V1.Normalize();
 		    V2.Normalize();
 		    V1.Cross(V2);
-		    if (V1.SquareMagnitude() > 1.e-10) {
+		    if ( V1.SquareMagnitude() > dPreci ) {
 		      parray->AddEdge(n[0]+decal,t[0] == 0);
 		      parray->AddEdge(n[1]+decal,t[1] == 0);
 		      parray->AddEdge(n[2]+decal,t[2] == 0);
@@ -196,15 +200,15 @@
 	  const gp_Pnt& P2 = Nodes(n2);
 	  const gp_Pnt& P3 = Nodes(n3);
 	  gp_Vec V1(P1,P2);
-	  if (V1.SquareMagnitude() > 1.e-10) {
+	  if ( V1.SquareMagnitude() > dPreci ) {
 	    gp_Vec V2(P2,P3);
-	    if (V2.SquareMagnitude() > 1.e-10) {
+	    if (V2.SquareMagnitude() > dPreci ) {
 	      gp_Vec V3(P3,P1);
-	      if (V3.SquareMagnitude() > 1.e-10) {
+	      if (V3.SquareMagnitude() > dPreci ) {
 		V1.Normalize();
 		V2.Normalize();
 		V1.Cross(V2);
-		if (V1.SquareMagnitude() > 1.e-10) {
+		if (V1.SquareMagnitude() > dPreci ) {
 		  nbTriangles++;
 		}
 	      }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Prs3d/Prs3d_ShapeTool.cxx OpenCASCADE6.3.0/ros/src/Prs3d/Prs3d_ShapeTool.cxx
--- OpenCASCADE6.3.0.orig//ros/src/Prs3d/Prs3d_ShapeTool.cxx	2010-07-04 20:15:15.845915730 +0200
+++ OpenCASCADE6.3.0/ros/src/Prs3d/Prs3d_ShapeTool.cxx	2010-02-26 09:34:10.000000000 +0100
@@ -29,10 +29,10 @@
 //function : Prs3d_ShapeTool
 //purpose  : 
 //=======================================================================
-
 Prs3d_ShapeTool::Prs3d_ShapeTool(const TopoDS_Shape& TheShape):
                                  myShape (TheShape) 
 {
+  
   myEdgeMap.Clear();
   myVertexMap.Clear();
   TopExp::MapShapesAndAncestors(TheShape,TopAbs_EDGE,TopAbs_FACE,myEdgeMap);
@@ -40,8 +40,6 @@
 #ifndef OCC215
   // find vertices not under ancestors.
   TopAbs_ShapeEnum E = TheShape.ShapeType();
-
-
   // this check were done to reduce the number of selectable objects
   // in a local context. By now, there's no noticeable performance improvement.
   if (E != TopAbs_SOLID && E != TopAbs_SHELL)
@@ -49,13 +47,25 @@
     {
       TopExp_Explorer ex(TheShape,TopAbs_VERTEX, TopAbs_EDGE);
       while (ex.More()) {
-	myVertexMap.Add(ex.Current());
+	const TopoDS_Shape& aV=ex.Current();
+	myVertexMap.Add(aV);
 	ex.Next();
       }
     }
 #ifdef OCC598
   TopExp_Explorer edges( TheShape, TopAbs_EDGE );
   while( edges.More() ) {
+    //modified by NIZNHY-PKV Fri Feb 26 11:19:25 2010f
+    const TopoDS_Shape& aE= edges.Current();
+    TopoDS_Iterator aIt(aE, Standard_False, Standard_True);
+    while( aIt.More() ) {
+      const TopoDS_Shape& aV=aIt.Value();
+      if (aV.Orientation()==TopAbs_INTERNAL) {
+	myVertexMap.Add(aV);
+      }
+      aIt.Next();
+    }
+    /*
     TopExp_Explorer vertices( edges.Current(), TopAbs_VERTEX );
     while( vertices.More() ) {
       TopoDS_Vertex current = TopoDS::Vertex( vertices.Current() );
@@ -63,6 +73,8 @@
 	myVertexMap.Add( current );
       vertices.Next();
     }
+    */
+    //modified by NIZNHY-PKV Fri Feb 26 11:23:30 2010t
     edges.Next();
   }
 #endif
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_BoxBndTree.cxx OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_BoxBndTree.cxx
--- OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_BoxBndTree.cxx	2010-07-04 20:15:28.799660501 +0200
+++ OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_BoxBndTree.cxx	2009-12-09 11:16:04.000000000 +0100
@@ -44,8 +44,7 @@
   if (myList.Contains(theObj))
     return Standard_False;
   
-  myStatus = Standard_False;
-  
+   
   TopoDS_Wire W = TopoDS::Wire (mySeq->Value (theObj));
   TopoDS_Vertex V1,V2;                         
   ShapeAnalysis::FindBounds (W,V1,V2);
@@ -65,11 +64,13 @@
           IsAccept = Standard_True;
         }
         else {
-          if (myLVertex.IsSame(V1)){
+          if (myFVertex.IsSame(V1)){
             myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE4);
             IsAccept = Standard_True;
           }
           else myStatus = ShapeExtend::EncodeStatus (ShapeExtend_FAIL2);
+
+          
         }
       }
     }
@@ -77,12 +78,12 @@
     if (IsAccept){
       SetNb(theObj);
       myStop = Standard_True;
+      return Standard_True;
     }
     else myStop = Standard_False;
   }
   
   else{
-    myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE1);
     gp_Pnt p1 = BRep_Tool::Pnt(V1);
     gp_Pnt p2 = BRep_Tool::Pnt(V2);
     
@@ -98,24 +99,39 @@
     Standard_Integer result = res1;
     Standard_Real min3d;
     min3d = Min (dm1, dm2);
-    if (dm1 > dm2) {dm1 = dm2; result = res2 + 2;}
+    if (min3d > myMin3d)
+      return Standard_False;
+
+    myMin3d = min3d;
+    if (min3d > myTol)
+    {
+       myStatus = ShapeExtend::EncodeStatus (ShapeExtend_FAIL2);
+       return Standard_False;
+    }
+   
+    SetNb(theObj);
+    
+    if (min3d == 0)
+      myStop = Standard_True;
+    
+    if (dm1 > dm2) 
+    {
+      dm1 = dm2; 
+      result = res2 + 2;
+    }
+    
+   
     switch (result) {
-      case 1: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE2);  break;
-      case 2: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE3);  break;
-      case 3: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE4);  break;
+        case 0: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE1); break; 
+        case 1: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE2);  break;
+        case 2: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE3);  break;
+        case 3: myStatus = ShapeExtend::EncodeStatus (ShapeExtend_DONE4);  break;
       }
     
-    if (min3d <= myMin3d){
-      SetNb(theObj);
-      myMin3d = min3d;
-      if (min3d == 0)
-        myStop = Standard_True;
-    }
-    else
-      if (min3d > myTol)
-        myStatus = ShapeExtend::EncodeStatus (ShapeExtend_FAIL2);
-  }
-  
-  return LastCheckStatus(ShapeExtend_DONE);
+      return Standard_True;
+    
+  }  
+   
+  return Standard_False;
 }
 
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cdl OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cdl
--- OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cdl	2010-07-04 20:15:28.792980914 +0200
+++ OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cdl	2010-03-16 15:32:52.000000000 +0100
@@ -71,7 +71,8 @@
 	
     Create (shape      : Shape from TopoDS;
     	    splitclosed: Boolean = Standard_False;
-    	    splitopen  : Boolean = Standard_True)
+    	    splitopen  : Boolean = Standard_True;
+    	    checkinternaledges  : Boolean = Standard_False)
     returns FreeBounds from ShapeAnalysis;
     	---Purpose: Builds actual free bounds of the <shape>.
     	--          <shape> should be a compound of shells.
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx
--- OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx	2010-07-04 20:15:28.792980914 +0200
+++ OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_FreeBounds.cxx	2010-03-16 15:32:42.000000000 +0100
@@ -96,7 +96,8 @@
 
 ShapeAnalysis_FreeBounds::ShapeAnalysis_FreeBounds(const TopoDS_Shape& shape,
 						   const Standard_Boolean splitclosed,
-						   const Standard_Boolean splitopen) :
+						   const Standard_Boolean splitopen,
+                                                   const Standard_Boolean checkinternaledges) :
        myTolerance (0.), myShared (Standard_True),
        mySplitClosed (splitclosed), mySplitOpen (splitopen)
 {
@@ -107,7 +108,7 @@
     aB.Add(aTmpShell,aExpFace.Current());
   
   ShapeAnalysis_Shell sas;
-  sas.CheckOrientedShells (aTmpShell, Standard_True);
+  sas.CheckOrientedShells (aTmpShell, Standard_True, checkinternaledges);
   
   if (sas.HasFreeEdges()) {
     ShapeExtend_Explorer see;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cdl OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cdl
--- OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cdl	2010-07-04 20:15:28.776318367 +0200
+++ OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cdl	2010-03-16 15:32:29.000000000 +0100
@@ -24,7 +24,8 @@
     	---Purpose: Adds shells contained in the <shape> to the list of loaded shells
 
     CheckOrientedShells (me : in out; shape   : Shape from TopoDS;
-    	    	    	              alsofree: Boolean = Standard_False)
+    	    	    	              alsofree: Boolean = Standard_False;
+    	    	    	    	      checkinternaledges: Boolean = Standard_False)
     returns Boolean;
     	---Purpose: Checks if shells fulfill orientation condition, i.e. if each
     	--          edge is, either present once (free edge) or twice (connected
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cxx OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cxx
--- OpenCASCADE6.3.0.orig//ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cxx	2010-07-04 20:15:28.776318367 +0200
+++ OpenCASCADE6.3.0/ros/src/ShapeAnalysis/ShapeAnalysis_Shell.cxx	2010-03-16 15:32:18.000000000 +0100
@@ -47,16 +47,17 @@
 //  On utilise pour cela une fonction auxiliaire : CheckEdges
 //    Qui alimente 2 maps auxiliaires : les edges directes et les inverses
 
-static    Standard_Boolean  CheckEdges(const TopoDS_Shape& shape,
-				       TopTools_IndexedMapOfShape& bads,
-				       TopTools_IndexedMapOfShape& dirs,
-				       TopTools_IndexedMapOfShape& revs)
+static  Standard_Boolean CheckEdges(const TopoDS_Shape& shape,
+                                    TopTools_IndexedMapOfShape& bads,
+                                    TopTools_IndexedMapOfShape& dirs,
+                                    TopTools_IndexedMapOfShape& revs,
+                                    TopTools_IndexedMapOfShape& ints)
 {
   Standard_Boolean res = Standard_False;
 
   if (shape.ShapeType() != TopAbs_EDGE) {
     for (TopoDS_Iterator it(shape); it.More(); it.Next()) {
-      if (CheckEdges (it.Value(),bads,dirs,revs)) res = Standard_True;
+      if (CheckEdges (it.Value(),bads,dirs,revs,ints)) res = Standard_True;
     }
   }
   else {
@@ -73,6 +74,10 @@
       if (revs.FindIndex (shape) == 0) revs.Add (shape);
       else { bads.Add (shape); res = Standard_True; }
     }
+    if (shape.Orientation() == TopAbs_INTERNAL) {
+      if (ints.FindIndex (shape) == 0) ints.Add (shape);
+      //else { bads.Add (shape); res = Standard_True; }
+    }
   }
 
   return res;
@@ -84,17 +89,18 @@
 //=======================================================================
 
 Standard_Boolean ShapeAnalysis_Shell::CheckOrientedShells(const TopoDS_Shape& shape,
-							  const Standard_Boolean alsofree) 
+							  const Standard_Boolean alsofree,
+                                                          const Standard_Boolean checkinternaledges)
 {
   myConex = Standard_False;
   if (shape.IsNull()) return Standard_False;
   Standard_Boolean res = Standard_False;
 
-  TopTools_IndexedMapOfShape dirs, revs;
+  TopTools_IndexedMapOfShape dirs, revs, ints;
   for (TopExp_Explorer exs(shape,TopAbs_SHELL); exs.More(); exs.Next()) {
     TopoDS_Shape sh = exs.Current();
     //szv#4:S4163:12Mar99 optimized
-    if (CheckEdges (sh,myBad,dirs,revs))
+    if (CheckEdges (sh,myBad,dirs,revs,ints))
       if (myShells.Add (sh)) res = Standard_True;
   }
 
@@ -108,16 +114,37 @@
   for (i = 1; i <= nb; i ++) {
     TopoDS_Shape sh = dirs.FindKey (i);
     if (!myBad.Contains(sh)) {
-      if (!revs.Contains(sh)) myFree.Add (sh);
+      if (!revs.Contains(sh)) {
+        if(checkinternaledges) {
+          if (!ints.Contains(sh)) {
+            myFree.Add (sh);
+          }
+          else myConex = Standard_True;
+        }
+        else {
+          myFree.Add (sh);
+        }
+      }
       else myConex = Standard_True;
     }
     else myConex = Standard_True;
   }
+
   nb = revs.Extent();
   for (i = 1; i <= nb; i ++) {
     TopoDS_Shape sh = revs.FindKey (i);
     if (!myBad.Contains(sh)) {
-      if (!dirs.Contains(sh)) myFree.Add (sh);
+      if (!dirs.Contains(sh)) {
+        if(checkinternaledges) {
+          if (!ints.Contains(sh)) {
+            myFree.Add (sh);
+          }
+          else myConex = Standard_True;
+        }
+        else {
+          myFree.Add (sh);
+        }
+      }
       else myConex = Standard_True;
     }
     else myConex = Standard_True;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Standard/Standard_Version.hxx OpenCASCADE6.3.0/ros/src/Standard/Standard_Version.hxx
--- OpenCASCADE6.3.0.orig//ros/src/Standard/Standard_Version.hxx	2010-07-04 20:15:28.999259960 +0200
+++ OpenCASCADE6.3.0/ros/src/Standard/Standard_Version.hxx	2010-04-01 15:34:11.000000000 +0200
@@ -10,6 +10,7 @@
 //            OCC_VERSION_MAJOR       : (integer) number identifying major version 
 //            OCC_VERSION_MINOR       : (integer) number identifying minor version 
 //            OCC_VERSION_MAINTENANCE : (integer) number identifying maintenance version 
+//            OCC_VERSION_SERVICEPACK : (integer) number identifying service pack version 
 //            OCC_VERSION             : (real)    complete number (major.minor)
 //            OCC_VERSION_STRING      : (string)  complete number ("major.minor")
 //            OCC_VERSION_HEX         : (hex)     complete number as hex, two positions per each of major, minor, and patch number 
@@ -23,6 +24,7 @@
 #define OCC_VERSION_MAJOR         6
 #define OCC_VERSION_MINOR         3
 #define OCC_VERSION_MAINTENANCE   0
+#define OCC_VERSION_SERVICEPACK   9
 
 // Derived: version as real and string (major.minor)
 #define OCC_VERSION         6.3
diff -Naur OpenCASCADE6.3.0.orig//ros/src/V3d/V3d_ColorScale.cxx OpenCASCADE6.3.0/ros/src/V3d/V3d_ColorScale.cxx
--- OpenCASCADE6.3.0.orig//ros/src/V3d/V3d_ColorScale.cxx	2010-07-04 20:15:10.219465922 +0200
+++ OpenCASCADE6.3.0/ros/src/V3d/V3d_ColorScale.cxx	2008-11-07 12:46:04.000000000 +0100
@@ -1,8 +1,8 @@
-// File:	V3d_ColorScale.cxx
-// Created:	Tue Jun 22 17:44:25 2004
-// Author:	STV
-//Copyright:	Open Cascade 2004
-
+/* File:	V3d_ColorScale.cxx
+   Created:	Tue Jun 22 17:44:25 2004
+   Author:	STV
+   Copyright:	Open Cascade 2004
+*/
 #include <V3d_ColorScale.ixx>
 
 #include <V3d_View.hxx>
@@ -38,8 +38,9 @@
 
 void V3d_ColorScale::Erase()
 {
+
   myDisplay = Standard_False;
-  UpdateColorScale();
+    UpdateColorScale();
 }
 
 Standard_Boolean V3d_ColorScale::IsDisplayed() const
@@ -47,6 +48,7 @@
   return myDisplay;
 }
 
+
 void V3d_ColorScale::UpdateColorScale()
 {
   myLayerMgr->Compute();
@@ -89,24 +91,24 @@
   Standard_Integer aTextH = GetTextHeight();
   Standard_Integer aWidth, anAscent, aDescent;
   TextSize(aText, aTextH, aWidth, anAscent, aDescent);
-//  Standard_Integer anAscent = 3 * aTextH / 4;
+/*  Standard_Integer anAscent = 3 * aTextH / 4;     */
   theLayer->DrawText( theText.ToCString(), X, Y + anAscent, aTextH);
-//  theLayer->DrawText( theText.ToCString(), X, Y, aTextH );
+/*  theLayer->DrawText( theText.ToCString(), X, Y, aTextH );     */
 }
 
 Standard_Integer V3d_ColorScale::TextWidth( const TCollection_ExtendedString& aText ) const
 {
   Standard_Integer aWidth, anAscent, aDescent;
   TextSize(aText, GetTextHeight(), aWidth, anAscent, aDescent);
-//  return 5 * aText.Length();
+/*  return 5 * aText.Length();    */
   return aWidth;
 }
 
 Standard_Integer V3d_ColorScale::TextHeight( const TCollection_ExtendedString& aText ) const
 {
   Standard_Integer aWidth, anAscent, aDescent;
-//  static Standard_Integer TextHeight = 10;
-//  return TextHeight;
+/*  static Standard_Integer TextHeight = 10;       */
+/*  return TextHeight;              */
   TextSize(aText, GetTextHeight(), aWidth, anAscent, aDescent);
   return anAscent+aDescent;
 }
@@ -114,28 +116,27 @@
 void V3d_ColorScale::TextSize (const TCollection_ExtendedString& AText,  const Standard_Integer AHeight, Standard_Integer& AWidth, Standard_Integer& AnAscent, Standard_Integer& ADescent) const 
 {
   const Handle(Visual3d_Layer) &theLayer = myLayerMgr->Overlay();
-  if ( !theLayer.IsNull() ) {
+   if ( !theLayer.IsNull() ) {
     Standard_Real aWidth, anAscent, aDescent;
     TCollection_AsciiString theText( AText.ToExtString(), '?' );
     theLayer->TextSize(theText.ToCString(),AHeight,aWidth,anAscent,aDescent);
-    AWidth = (Standard_Integer)aWidth;
-    AnAscent = (Standard_Integer)anAscent;
-    ADescent = (Standard_Integer)aDescent;
+    AWidth = (Standard_Integer) aWidth;
+    AnAscent = (Standard_Integer) anAscent;
+    ADescent = (Standard_Integer) aDescent;
   } 
   else {
     AWidth=AnAscent=ADescent=0;
   }
 }
 
-void V3d_ColorScale::DrawScale ()
+void V3d_ColorScale::DrawScale()
 {
-  const Handle(V3d_View) &theView = myLayerMgr->View();
+    const Handle(V3d_View) &theView = myLayerMgr->View();
   if ( theView.IsNull() )
     return;
-
   const Handle(Aspect_Window) &theWin = theView->Window();
   if ( theWin.IsNull() )
-    return;
+   return;
 
   Standard_Integer WinWidth( 0 ), WinHeight( 0 );
   theWin->Size( WinWidth, WinHeight );
@@ -147,4 +148,5 @@
   const Standard_Integer H = RealToInt(GetHeight() * WinHeight);
 
   Aspect_ColorScale::DrawScale( theView->BackgroundColor(), X, Y, W, H );
+
 }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/V3d/V3d_View.cxx OpenCASCADE6.3.0/ros/src/V3d/V3d_View.cxx
--- OpenCASCADE6.3.0.orig//ros/src/V3d/V3d_View.cxx	2010-07-04 20:15:10.192798486 +0200
+++ OpenCASCADE6.3.0/ros/src/V3d/V3d_View.cxx	2008-11-05 08:55:56.000000000 +0100
@@ -63,71 +63,71 @@
 
 ************************************************************************/
 
-#define GER61351	//GG_15/12/99 Add SetBackgroundColor()
-//				      and BackgroundColor() methods
+#define GER61351	/*GG_15/12/99 Add SetBackgroundColor()
+				      and BackgroundColor() methods */
 
 
-#define IMP240100	//GG
-//			-> Remove PixToRef() method ,use
-//			  instead the equivalent Convert() method.
-//			-> Rename RefToPix() to Convert() method.
-//		        -> Remove the grid computation in Convert()
-//			  method. Use instead the NEW ConvertToGrid() methods.
-//			  Reason is the Convert() method is call by 
-//			  StdSelect_ViewSelector3d_Pick() from
-//			  AIS_InteractiveContext() and it's not possible
-//			  to select an object vertex when the grid is active!
-//			-> Remove grid echo marker definition 
-//			  (reported in the viewer)
-//			-> Add SetProjModel() methods.
-
-#define G003		//EUG 04-10-99
-//			-> computed mode management
-//			   Add SetComputedMode(..) method
-//			-> animation mode management
-//			   Add SetAnimationMode()
-//			-> backfacing management
-//			   Add SetBackFacingModel() method
-
-#define G004		//VKH 15-11-99
-//			-> Add Dump() methods
-//			-> GG 07/03/00 Use the new MMSize()
-//			   method from Aspect_Window class.
-
-#define IMP210200       //GG Add Transparency() method
-
-#define IMP250200	//GG With SetDepth() method, when the requested 
-//			depth is < 0.,
-//			move the view ref point and the eye,instead
-//			only the eye.
-
-#define IMP020300	//GG Don't use ZFitAll in during Rotation
-//			for perf improvment
-
-#define IMP210600	//GG Avoid to have infinite loop when call Rotation() method 
-//			without call before StartRotation().
-//			This problem occurs when CTRL MB3 is maintain press betwwen 2 views.
-
-#define IMP250900	//GG Enable rotation around screen Z axis when
-//			rotation begin far the center of the screen.
-//			Thanks to Patrick REGINSTER (SAMTECH)
-//			GG 21/12/00 Due to a regression on the previous specifications
-//			this new functionnality is right now deactivated
-//			by default (see StartRotation(...,zRotationThreshold)
-//			method.	
-
-#define BUC60952	//GG Enable to rotate around the view axis
-//			and the required view point
-
-#define RIC120302	//GG Add a NEW SetWindow method which enable
-//			to connect a graphic widget and context to OGL.
+#define IMP240100	/*/GG
+			-> Remove PixToRef() method ,use
+			  instead the equivalent Convert() method.
+			-> Rename RefToPix() to Convert() method.
+		        -> Remove the grid computation in Convert()
+			  method. Use instead the NEW ConvertToGrid() methods.
+			  Reason is the Convert() method is call by 
+			  StdSelect_ViewSelector3d_Pick() from
+			  AIS_InteractiveContext() and it's not possible
+			  to select an object vertex when the grid is active!
+			-> Remove grid echo marker definition 
+			  (reported in the viewer)
+			-> Add SetProjModel() methods.
+                                                          */
+#define G003		/*EUG 04-10-99
+			-> computed mode management
+			   Add SetComputedMode(..) method
+			-> animation mode management
+			   Add SetAnimationMode()
+			-> backfacing management
+			   Add SetBackFacingModel() method  */
+
+#define G004		/*VKH 15-11-99
+			-> Add Dump() methods
+			-> GG 07/03/00 Use the new MMSize()
+			   method from Aspect_Window class.    */
+
+#define IMP210200       /*GG Add Transparency() method   */
+
+#define IMP250200	/*GG With SetDepth() method, when the requested 
+			depth is < 0.,
+			move the view ref point and the eye,instead
+			only the eye.    */
+
+#define IMP020300	/*GG Don't use ZFitAll in during Rotation
+			for perf improvment     */
+
+#define IMP210600	/*GG Avoid to have infinite loop when call Rotation() method 
+			without call before StartRotation().
+			This problem occurs when CTRL MB3 is maintain press betwwen 2 views.  */
+
+#define IMP250900	/*GG Enable rotation around screen Z axis when
+			rotation begin far the center of the screen.
+			Thanks to Patrick REGINSTER (SAMTECH)
+			GG 21/12/00 Due to a regression on the previous specifications
+			this new functionnality is right now deactivated
+			by default (see StartRotation(...,zRotationThreshold)
+			method.	
+                                                                        */
+#define BUC60952	/*GG Enable to rotate around the view axis
+			and the required view point         */
+
+#define RIC120302	/*GG Add a NEW SetWindow method which enable
+			to connect a graphic widget and context to OGL.*/
 
-#define IMP260302	//GG To avoid conflicting in Window destructor
-//			nullify this handle in Remove method
+#define IMP260302	/*GG To avoid conflicting in Window destructor
+			nullify this handle in Remove method      */
 
-#define OCC280          //SAV fix for FitAll problem in the perspective view.
+#define OCC280          /*SAV fix for FitAll problem in the perspective view.    */
 
-#define OCC1188         //SAV Added methods to set background image
+#define OCC1188         /*SAV Added methods to set background image */
 
 /*----------------------------------------------------------------------*/
 /*
@@ -150,11 +150,10 @@
 #include <TColStd_Array2OfReal.hxx>
 #include <Visual3d_TransientManager.hxx>
 #include <Precision.hxx>
-
-// S3892
+/* S3892     */
 #include <Graphic3d_AspectMarker3d.hxx>
 
-// S3603
+/* S3603*/
 #include <Aspect_GenericColorMap.hxx>
 #include <Aspect_TypeMap.hxx>
 #include <Aspect_WidthMap.hxx>
@@ -172,13 +171,13 @@
 # define V3d_FLAG_ANIMATION    	0x00000001
 # define V3d_FLAG_DEGENERATION 	0x00000002
 # define V3d_FLAG_COMPUTATION 	0x00000004
-#endif  // G003
+#endif  /* G003  */
 
-// Tumble
+/* Tumble*/
 #include <OSD_Timer.hxx>
 static OSD_Timer FullTimer;
 
-// Perspective
+/* Perspective  */
 #include <OSD_Environment.hxx>
 
 /*----------------------------------------------------------------------*/
@@ -189,8 +188,8 @@
 #define Zmargin 1.
 #define DEUXPI (2.*Standard_PI)
 
-// en cas NO_TRACE_ECHO et de NO_TRACE_POINTS, dans V3d_View_4.cxx ET dans
-// V3d_View.cxx, virer MyGridEchoStructure et MyGridEchoGroup dans le cdl
+/* en cas NO_TRACE_ECHO et de NO_TRACE_POINTS, dans V3d_View_4.cxx ET dans  */
+/* V3d_View.cxx, virer MyGridEchoStructure et MyGridEchoGroup dans le cdl  */
 #define NO_TRACE_ECHO 
 #define NO_TRACE_POINTS
 
@@ -270,10 +269,10 @@
 return MyProjReferencePoint;
 }
 #define MyProjReferencePoint _MyProjReferencePoint()
-#endif // LOPTIM
+#endif /* LOPTIM    */
 
 /*----------------------------------------------------------------------*/
-//-Constructors
+/*-Constructors*/
 
 V3d_View::V3d_View(const Handle(V3d_Viewer)& VM, const V3d_TypeOfView Type ) :
 MyType ( Type ),
@@ -284,33 +283,33 @@
 myActiveLightsIterator(),
 myActivePlanesIterator(),
 SwitchSetFront(Standard_False),
-MyTrsf (1, 4, 1, 4),                                    // S3892
+MyTrsf (1, 4, 1, 4),                                    /* S3892 */
 MyProjModel(V3d_TPM_SCREEN)
 #if defined(TRACE_POINTS)
-,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  // S3892
-MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))            // S3892
+,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  /* S3892    */
+MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))            /* S3892  */
 #endif
 {
 
   myImmediateUpdate = Standard_False;
   MyView = new Visual3d_View(MyViewer->Viewer());
   
-  // { Debut de recuperation de la definition du ViewContext.
-  // Pas de MyViewContext = MyView->Context() ;
-  // pour permettre a MyView->SetContext de comparer
-  // l'ancien contexte et le nouveau.
-  // Pas de probleme pour MyViewMapping, MyViewOrientation
-  // car MyView->SetViewMapping et MyView->SetViewOrientation
-  // ne cherchent pas a optimiser les modifications apportees
-  // au viewmapping et au vieworientation.
+  /* { Debut de recuperation de la definition du ViewContext.
+   Pas de MyViewContext = MyView->Context() ;
+   pour permettre a MyView->SetContext de comparer
+   l'ancien contexte et le nouveau.
+   Pas de probleme pour MyViewMapping, MyViewOrientation
+   car MyView->SetViewMapping et MyView->SetViewOrientation
+   ne cherchent pas a optimiser les modifications apportees
+   au viewmapping et au vieworientation.   */
   
-  // Aliasing
+  /* Aliasing*/
   if ((MyView->Context ()).AliasingIsOn ())
     MyViewContext.SetAliasingOn ();
   else
     MyViewContext.SetAliasingOff ();
   
-  // DepthCueing
+  /* DepthCueing   */
   MyViewContext.SetDepthCueingBackPlane
     ((MyView->Context ()).DepthCueingBackPlane ());
   MyViewContext.SetDepthCueingFrontPlane
@@ -321,7 +320,7 @@
   else
     MyViewContext.SetDepthCueingOff ();
   
-  // ZClipping
+  /* ZClipping  */
   MyViewContext.SetZClippingBackPlane
     ((MyView->Context ()).ZClippingBackPlane ());
   MyViewContext.SetZClippingFrontPlane
@@ -337,14 +336,14 @@
   else
     MyViewContext.SetBackZClippingOff ();
   
-  // Visualisation et Shading Model
+  /* Visualisation et Shading Model   */
   MyViewContext.SetModel ((MyView->Context ()).Model ());
   MyViewContext.SetVisualization ((MyView->Context ()).Visualization ());
   
-  // Texture Mapping
+  /* Texture Mapping
   MyViewContext.SetSurfaceDetail (MyView->Context ().SurfaceDetail ());
   MyViewContext.SetTextureEnv (MyView->Context ().TextureEnv ());
-  // } Fin de recuperation de la definition du ViewContext.
+  /* } Fin de recuperation de la definition du ViewContext.     */
   
   MyViewMapping = MyView->ViewMapping() ;
   MyViewOrientation = MyView->ViewOrientation() ;
@@ -371,7 +370,7 @@
   Init();
   myImmediateUpdate = Standard_True;
 
-  // S3892
+  /* S3892  */
 #ifndef IMP240100
 #if defined(TRACE_POINTS)
 Handle(Graphic3d_AspectMarker3d) MarkerAttrib = new Graphic3d_AspectMarker3d ();
@@ -380,11 +379,11 @@
   MarkerAttrib->SetType (Aspect_TOM_STAR);
   MyGridEchoStructure->SetPrimitivesAspect (MarkerAttrib);
 #endif
-#endif	//IMP240100
+#endif	/*IMP240100  */
 
 #ifdef G003
   MyAnimationFlags = 0;
-#endif  // G003
+#endif  /* G003     */
 
 #ifdef IMP210200
   MyTransparencyFlag = Standard_False;
@@ -402,11 +401,11 @@
 myActiveLightsIterator(),
 myActivePlanesIterator(),
 SwitchSetFront(Standard_False),
-MyTrsf (1, 4, 1, 4),                                    // S3892
+MyTrsf (1, 4, 1, 4),                                    /* S3892    */
 MyProjModel(V3d_TPM_SCREEN)
 #if defined(TRACE_POINTS)
-,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  // S3892
-MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))             // S3892
+,MyGridEchoStructure (new Graphic3d_Structure (VM->Viewer ())),  /* S3892 */
+MyGridEchoGroup (new Graphic3d_Group (MyGridEchoStructure))             /* S3892 */
 #endif
 {
 
@@ -432,7 +431,7 @@
   Init();
   myImmediateUpdate = Standard_True;
 
-  // S3892
+  /* S3892   */
 #ifndef IMP240100
 #if defined(TRACE_ECHO)
 Handle(Graphic3d_AspectMarker3d) MarkerAttrib = new Graphic3d_AspectMarker3d ();
@@ -441,7 +440,7 @@
   MarkerAttrib->SetType (Aspect_TOM_STAR);
   MyGridEchoStructure->SetPrimitivesAspect (MarkerAttrib);
 #endif
-#endif	//IMP240100
+#endif	/*IMP240100  */
 
 #ifdef G003
   MyAnimationFlags = 0;
@@ -450,7 +449,7 @@
 
 /*----------------------------------------------------------------------*/
 
-//-Methods, in order
+/*-Methods, in order   */
 
 void V3d_View::SetMagnify(const Handle(Aspect_Window)& TheWindow,
                           const Handle(V3d_View)& aPreviousView,
@@ -483,34 +482,34 @@
                                     "V3d_View::SetWindow, window of view already defined");
 
   MyView->SetWindow(TheWindow) ;
-  // SetWindow effectue un SetRatio et modifie le
-  // ViewMapping et ViewMappingDefault de MyView.
+  /* SetWindow effectue un SetRatio et modifie le  */
+  /* ViewMapping et ViewMappingDefault de MyView.  */
   MyViewMapping = MyView->ViewMapping() ;
   MyView->SetContext(MyViewContext) ;
   MyView->SetViewMapping(MyViewMapping) ;
   MyView->SetViewOrientation(MyViewOrientation) ;
   MyView->SetBackground(MyBackground) ;
   MyViewer->SetViewOn(this) ;            
-  //MyView->SetViewMappingDefault();            
+  /*MyView->SetViewMappingDefault();   */         
 #ifdef TRACE_POINTS
-  MyGridEchoStructure->SetInfiniteState (Standard_True);        // S3892
-  MyGridEchoStructure->Display ();                              // S3892
+  MyGridEchoStructure->SetInfiniteState (Standard_True);        /* S3892*/
+  MyGridEchoStructure->Display ();                              /* S3892*/
 #endif
   MyView->Redraw() ;
   MyWindow = TheWindow;
 }
 
-// RIC120302
+/* RIC120302     */
 /*----------------------------------------------------------------------*/
 
-void V3d_View::SetWindow(const Handle(Aspect_Window)&      aWindow,
-			 const Aspect_RenderingContext     aContext,
+void V3d_View::SetWindow(const Handle(Aspect_Window)& aWindow,
+			 const Aspect_RenderingContext aContext,
 			 const Aspect_GraphicCallbackProc& aDisplayCB,
-			 const Standard_Address            aClientData)
-{
+			 const Standard_Address            aClientData) {
+
   Standard_MultiplyDefined_Raise_if( MyView->IsDefined(),
-                                    "V3d_View::SetWindow, "
-                                     "window of view already defined");
+                                    "V3d_View::SetWindow, " 
+				              "window of view already defined");
   MyView->SetWindow(aWindow, aContext, aDisplayCB, aClientData) ;
   MyViewMapping = MyView->ViewMapping() ;
   MyView->SetContext(MyViewContext) ;
@@ -521,7 +520,7 @@
   MyView->Redraw() ;
   MyWindow = aWindow;
 }
-// RIC120302
+/* RIC120302  */
 
 /*----------------------------------------------------------------------*/
 
@@ -557,8 +556,8 @@
   Standard_Boolean TheStatus = Standard_True ;
   
   if( MyView->IsDefined() ) {
-    // CAL 6/11/98
-    // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+    /* CAL 6/11/98  */
+    /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ; */
     Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
     if( Nstruct > 0 ) TheStatus = Standard_False ;
   }
@@ -583,13 +582,13 @@
 /*----------------------------------------------------------------------*/
 
 void V3d_View::MustBeResized() {
-  if ( !MyLayerMgr.IsNull() )
+ if ( !MyLayerMgr.IsNull() )
     MyLayerMgr->Resized();
 
   if( MyView->IsDefined() ) {
     MyView->Resized() ;
     MyViewMapping = MyView->ViewMapping();
-    // MyView->SetViewMappingDefault();
+   /*  MyView->SetViewMappingDefault();  */
     MyView->Redraw();
   }
 }
@@ -609,7 +608,7 @@
   MyBackground.SetColor( C );
   if ( MyView->IsDefined() )
     MyView->SetBackground( MyBackground );
-  if ( !MyLayerMgr.IsNull() )
+   if ( !MyLayerMgr.IsNull() )
     MyLayerMgr->Resized();
 #endif
 }
@@ -622,9 +621,9 @@
   MyBackground.SetColor( Color );
   if ( MyView->IsDefined() )
     MyView->SetBackground( MyBackground );
-  //szv: Why?
+ /*szv: Why?*/
   if ( !MyLayerMgr.IsNull() )
-    MyLayerMgr->Resized();
+    MyLayerMgr->Resized();  
 }
 #endif
 
@@ -906,7 +905,7 @@
 void V3d_View::Rotate(const Standard_Real angle, const Standard_Boolean Start) {
 
   Standard_Real Angle = angle ;
-//  Graphic3d_Vertex Vrp ;
+/*  Graphic3d_Vertex Vrp ;*/
   Graphic3d_Vector Vpn,Vup ;
   TColStd_Array2OfReal Matrix(0,3,0,3) ;
   
@@ -990,7 +989,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-  // Check ZClipping planes
+  /* Check ZClipping planes */
   Standard_Real Zmax ;
   Vrp.Coord(Xat,Yat,Zat) ;
   Zmax = Sqrt( Xat*Xat + Yat*Yat + Zat*Zat) ;
@@ -1051,7 +1050,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-  // Check ZClipping planes
+  /* Check ZClipping planes   */
   Standard_Real Zmax ;
   Vrp.Coord(Xat,Yat,Zat) ;
   Zmax = Sqrt( Xat*Xat + Yat*Yat + Zat*Zat ) ;
@@ -1129,8 +1128,8 @@
   Standard_Boolean update = myImmediateUpdate;
   myImmediateUpdate = Standard_False;
   if( MyProjModel == V3d_TPM_WALKTHROUGH ) {
-      //FMN desactivation temp SetTwist(Angle) ;
-      // Set des infos.
+      /*FMN desactivation temp SetTwist(Angle) ;       */
+      /* Set des infos.                          */
       MyView->SetViewOrientation(MyViewOrientation) ; 
       MyView->SetViewMapping(MyViewMapping) ; 
   } else {
@@ -1139,7 +1138,7 @@
 #ifdef IMP020300
   SetZSize(0.) ;
 #else
-    // Check ZClipping planes
+    /* Check ZClipping planes  */
   Standard_Real Zmax = Sqrt( X*X + Y*Y + Z*Z ) ;
   if( Zmax > MyViewMapping.FrontPlaneDistance() &&
 	MyProjModel == V3d_TPM_SCREEN ) {
@@ -1178,12 +1177,12 @@
     MyViewMapping.SetProjectionReferencePoint(MyProjReferencePoint);
   }
   
-  // Check ZClipping planes
+  /* Check ZClipping planes */
   Standard_Real Xat,Yat,Zat,Xpn,Ypn,Zpn,Xeye,Yeye,Zeye ;
   MyViewReferencePoint.Coord(Xat,Yat,Zat) ;
   MyViewReferencePlane.Coord(Xpn,Ypn,Zpn) ;
 #ifdef IMP250200
-  if( Depth < 0. ) {	// Move the view ref point instead the eye.
+  if( Depth < 0. ) {	/* Move the view ref point instead the eye. */
     Xeye = Xpn*Zrp + Xat ; Yeye = Ypn*Zrp + Yat ; Zeye = Zpn*Zrp + Zat ;
     Zrp = Abs(Depth) ;
     Xat = Xeye - Xpn*Zrp ; Yat = Yeye - Ypn*Zrp ; Zat = Zeye - Zpn*Zrp;
@@ -1240,7 +1239,7 @@
 
   MyViewReferencePlane = V3d::GetProjAxis(Orientation) ; 
   MyViewOrientation.SetViewReferencePlane(MyViewReferencePlane) ;
-  // MSV 14.03.2007: reset ViewReferencePoint to debug LH3D14955
+  /* MSV 14.03.2007: reset ViewReferencePoint to debug LH3D14955 */
   MyViewOrientation.SetViewReferencePoint(Graphic3d_Vertex(0,0,0));
   Standard_Real Xpn=0;
   Standard_Real Ypn=0;
@@ -1290,8 +1289,8 @@
   Standard_Boolean update = myImmediateUpdate;
   myImmediateUpdate = Standard_False;
   if( MyProjModel == V3d_TPM_WALKTHROUGH ) {
-  //FMN desactivation temp SetTwist(Angle) ;  
-  // Set des infos.
+  /*FMN desactivation temp SetTwist(Angle) ;   */
+  /* Set des infos.        */
     MyView->SetViewOrientation(MyViewOrientation) ; 
     MyView->SetViewMapping(MyViewMapping) ; 
   } else {
@@ -1302,7 +1301,7 @@
   SetZSize(0.) ;
 #else
   ImmediateUpdate();
-    // Check ZClipping planes
+    /* Check ZClipping planes  */
   Standard_Real Zmax = Sqrt( X*X + Y*Y + Z*Z ) ;
   if( Zmax > MyViewMapping.FrontPlaneDistance() &&
 	MyProjModel == V3d_TPM_SCREEN ) {
@@ -1397,13 +1396,13 @@
 
   MyView->ViewOrientationReset() ;
   MyViewOrientation = MyView->ViewOrientation() ;
-//OCC4844
-//#ifdef IMP020300
-//  Update();
-//#else
+/*OCC4844 */
+/*#ifdef IMP020300
+  Update();
+#else   */
   ImmediateUpdate();
-//#endif
-//OCC4844
+/*#endif
+OCC4844 */
 }
 
 void V3d_View::Reset( const Standard_Boolean update ) {
@@ -1529,7 +1528,7 @@
   MyViewMapping.SetFrontPlaneDistance(Zmax) ;
   MyViewMapping.SetBackPlaneDistance(-Zmax) ;
 
-  // OCC18942
+  /* OCC18942 */
   if( MyProjModel != V3d_TPM_WALKTHROUGH ) {
     MyViewMapping.SetViewPlaneDistance(MyType == V3d_PERSPECTIVE ? 0. : Zmax) ;
   }
@@ -1541,7 +1540,7 @@
     MyViewContext.SetZClippingBackPlane(Back) ;
     MyView->SetContext(MyViewContext) ;
   }
-//printf(" *** SetZSize(%f)\n",Zmax);
+/*printf(" *** SetZSize(%f)\n",Zmax); */
 }
 
 void V3d_View::SetZoom(const Standard_Real Coef,const Standard_Boolean Start) {
@@ -1556,8 +1555,8 @@
     MyWindowWidth = Abs(Umax - Umin) ;
     MyWindowHeight = Abs(Vmax - Vmin) ;
   }
-
-  // ensure that zoom will not be too small or too big
+  
+  /* ensure that zoom will not be too small or too big  */
   Standard_Real coef = Coef;
   if ( MyWindowWidth < coef * Precision::Confusion() )
     coef = MyWindowWidth / Precision::Confusion();
@@ -1567,7 +1566,7 @@
     coef = MyWindowHeight / Precision::Confusion();
   else if ( MyWindowHeight > coef * 1e12 )
     coef = MyWindowHeight / 1e12;
-
+  
   Dxv = MyWindowWidth/coef; 
   Dyv = MyWindowHeight/coef;
   Umin = MyXwindowCenter - Dxv/2. ; Umax = MyXwindowCenter + Dxv/2. ;
@@ -1607,7 +1606,7 @@
   MyView->ViewManager()->SetUpdateMode(updateMode);
 
   MyView->MinMaxValues(Xmin,Ymin,Zmin,Xmax,Ymax,Zmax) ;
-
+ 
   Standard_Real LIM = ShortRealLast() -1.;
   if     (Abs(Xmin) > LIM || Abs(Ymin) > LIM || Abs(Zmin) > LIM 
       ||  Abs(Xmax) > LIM || Abs(Ymax) > LIM || Abs(Zmax) > LIM ) {
@@ -1650,10 +1649,10 @@
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax ;
   Standard_Real DxvOld,DyvOld,DxvNew,DyvNew,RapOld,RapNew ;
   Standard_Integer Xpixel,Ypixel;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98      */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;  */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
-  //Standard_Integer Xleft,Yup,Xright,Ylow ;
+  /*Standard_Integer Xleft,Yup,Xright,Ylow ;    */
   Standard_Integer nbPasse = 2;
 
   if( (Nstruct <= 0) || (Coef < 0.) || (Coef > 1.) ) {
@@ -1662,12 +1661,12 @@
 #endif
     return ;
   }
-  //    Update() ;
+  /*    Update() ;  */
   MyProjReferencePoint = MyViewMapping.ProjectionReferencePoint() ;
   MyProjReferencePoint.Coord(Xrp,Yrp,Zrp) ;
   if( MyView->IsDefined() ) {
-    //MyWindow->Position(Xleft,Yup,Xright,Ylow) ;
-    //DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;
+    /*MyWindow->Position(Xleft,Yup,Xright,Ylow) ;   */
+    /*DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;*/
     MyWindow->Size(Xpixel,Ypixel);
     DxvOld = Xpixel; DyvOld = Ypixel;
   } else {
@@ -1742,7 +1741,7 @@
   } 
       
     nbPasse--;    
-  } // while
+  } /* while  */
   
   if(FitZ) {
     ZFitAll(Zmargin);
@@ -1760,8 +1759,8 @@
 
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax,U,V,W ;
   Standard_Real Umin,Vmin,Wmin,Umax,Vmax,Wmax ;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98           */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;   */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( MyType == V3d_PERSPECTIVE ) {
@@ -1782,8 +1781,8 @@
     ImmediateUpdate();
     return ;
   }
-  // CAL 6/11/98
-  // Cas ou la vue ne contient qu'un point
+  /* CAL 6/11/98  */
+  /* Cas ou la vue ne contient qu'un point */
   if (Xmin == Xmax && Ymin == Ymax && Zmin == Zmax) {
     ImmediateUpdate();
     return ;
@@ -1869,12 +1868,12 @@
   Vmin = Min(V,Vmin) ; Vmax = Max(V,Vmax) ;
   Wmin = Min(W,Wmin) ; Wmax = Max(W,Wmax) ;
   
-  // Adjust Z size
+  /* Adjust Z size */
   Wmax = Max(Abs(Wmin),Abs(Wmax)) ;
   Dz = 2.*Wmax + Margin * Wmax;
 
-  // Compute depth value
-  Dx = Abs(Umax - Umin) ; Dy = Abs(Vmax - Vmin) ; // Dz = Abs(Wmax - Wmin);
+  /* Compute depth value  */
+  Dx = Abs(Umax - Umin) ; Dy = Abs(Vmax - Vmin) ; /* Dz = Abs(Wmax - Wmin);  */
   Dx += Margin * Dx; Dy += Margin * Dy;
   Size = Sqrt(Dx*Dx + Dy*Dy + Dz*Dz);
   if( Size > 0. ) {
@@ -1885,6 +1884,7 @@
   ImmediateUpdate();
 }
 
+
 void V3d_View::FitAll(const Standard_Real Xmin, const Standard_Real Ymin, const Standard_Real Xmax, const Standard_Real Ymax) {
   FitAll(MyWindow,Xmin,Ymin,Xmax,Ymax);
 #ifndef IMP020300
@@ -1906,9 +1906,9 @@
 void V3d_View::SetViewMapping(const Visual3d_ViewMapping& VM)
 {
   MyViewMapping = VM;
-  // ajust view type according to mapping projection
-  // NOTE: Might be dangerous, potentially conflicts with the C++ view class
-  // (orthographic or perspective)! Use with care!
+  /* ajust view type according to mapping projection  */
+  /* NOTE: Might be dangerous, potentially conflicts with the C++ view class */
+  /* (orthographic or perspective)! Use with care!*/
   if ( VM.Projection() == Visual3d_TOP_PERSPECTIVE )
     MyType = V3d_PERSPECTIVE;
   else MyType = V3d_ORTHOGRAPHIC;
@@ -1917,6 +1917,7 @@
   ImmediateUpdate();
 }
 
+
 void V3d_View::SetViewMappingDefault() {
   MyView->SetViewMapping(MyViewMapping) ;
   MyView->SetViewMappingDefault();            
@@ -1962,34 +1963,36 @@
   Yv = Vmin + Dyv*(Standard_Real)(Dyw-Yp)/(Standard_Real)Dyw ;
 }
 
-Standard_Integer V3d_View::Convert(const Standard_Real Vv) const 
+Standard_Integer V3d_View::Convert(const Standard_Real Vv) const
 {
+  
   V3d_UnMapped_Raise_if( !MyView->IsDefined(), "view has no window");
 
   Standard_Integer Dxw, Dyw;
   MyWindow->Size(Dxw,Dyw);
-
+  
   Standard_Real Umin,Umax,Vmin,Vmax;
   MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
   Standard_Real Dxv = Umax - Umin;
   return RealToInt ( Dxw * Vv / Dxv );
+  
 }
 
-void V3d_View::Convert(const Standard_Real Xv, const Standard_Real Yv, Standard_Integer& Xp, Standard_Integer& Yp) const 
+void V3d_View::Convert(const Standard_Real Xv, const Standard_Real Yv, Standard_Integer& Xp, Standard_Integer& Yp) const
 {
   V3d_UnMapped_Raise_if( !MyView->IsDefined(), "view has no window");
 
   Standard_Integer Dxw, Dyw;
   MyWindow->Size(Dxw,Dyw);
-
+  
   Standard_Real Umin,Umax,Vmin,Vmax;
   MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
   Standard_Real Dxv = Umax - Umin; 
   Standard_Real Dyv = Vmax - Vmin;
 
-  // CAL 15/12/93 warning:  double  assigned to  int
+  /* CAL 15/12/93 warning:  double  assigned to  int     */
   Xp = RealToInt (Dxw*(Xv - Umin)/Dxv);
-  // CAL 15/12/93 warning:  double  assigned to  int
+  /* CAL 15/12/93 warning:  double  assigned to  int    */
   Yp = Dyw - RealToInt (Dyw*(Yv - Vmin)/Dyv);
 }
 
@@ -2068,22 +2071,22 @@
   (MyViewer->Viewer())->ConvertCoord(MyWindow,Vrp,Xp,Yp) ;
 }
 
-void V3d_View::Project(const Standard_Real X, const Standard_Real Y, const Standard_Real Z, Standard_Real &Xp, Standard_Real &Yp) const
-{
-  if ( MyType != V3d_PERSPECTIVE )
+void V3d_View::Project(const Standard_Real X, const Standard_Real Y, const Standard_Real Z, Standard_Real &Xp, Standard_Real &Yp) const {
+ 
+   if ( MyType != V3d_PERSPECTIVE )
   {
-    // use old implementation
+    /* use old implementation        */
     Standard_Real Zp;
     MyView->Projects( X, Y, Z, Xp, Yp, Zp );
   }
   else
   {
-    // NKV - Using raster projection
+    /* NKV - Using raster projection   */
     Standard_Integer Xpx, Ypx;
     Convert(X, Y, Z, Xpx, Ypx);
     Convert(Xpx, Ypx, Xp, Yp);
   }
-} 
+}
 
 void V3d_View::BackgroundColor(const Quantity_TypeOfColor Type,Standard_Real& V1, Standard_Real& V2, Standard_Real& V3)const  {
  
@@ -2151,8 +2154,8 @@
 
   Standard_Real Wmin,Wmax,U,V,W ;
   Standard_Real Xmin,Ymin,Zmin,Xmax,Ymax,Zmax ;
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98    */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;  */
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( Nstruct ) {
@@ -2188,8 +2191,8 @@
 }
 
 Standard_Integer V3d_View::MinMax(Standard_Real& Xmin, Standard_Real& Ymin, Standard_Real& Zmin, Standard_Real& Xmax, Standard_Real& Ymax, Standard_Real& Zmax) const {
-  // CAL 6/11/98
-  // Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;
+  /* CAL 6/11/98      */
+  /* Standard_Integer Nstruct = (MyView->DisplayedStructures())->Extent() ;*/
   Standard_Integer Nstruct = MyView->NumberOfDisplayedStructures() ;
 
   if( Nstruct ) {
@@ -2206,8 +2209,8 @@
   Graphic3d_MapOfStructure MySetOfStructures;
   
   MyView->DisplayedStructures (MySetOfStructures);
-  //JMB  MySetOfStructures.Clear ();
-  //JMBMySetOfStructures.Union (()->Set ());
+  /*JMB  MySetOfStructures.Clear ();   */
+  /*JMBMySetOfStructures.Union (()->Set ());   */
   Nstruct = MySetOfStructures.Extent() ;
   
   Graphic3d_MapIteratorOfMapOfStructure MyIterator(MySetOfStructures) ;
@@ -2489,15 +2492,15 @@
   MyViewMapping.SetFrontPlaneDistance(size);
   MyViewMapping.SetBackPlaneDistance(-size);
 
-  // keep view plane at front plane distance
+  /* keep view plane at front plane distance    */
   MyViewMapping.SetViewPlaneDistance(MyType == V3d_PERSPECTIVE ? 0. : size);
 
-  // set window limits
+  /* set window limits   */
   Umin = Left; Umax = Right;
   Vmin = Bottom; Vmax = Top;
   MyViewMapping.SetWindowLimit(Left, Bottom, Right, Top);
 
-  // Update window center
+  /* Update window center */
   if ( MyType == V3d_PERSPECTIVE ) {
     Xrp = Yrp = 0.0;
   }
@@ -2508,10 +2511,11 @@
   MyViewMapping.SetProjectionReferencePoint(MyProjReferencePoint);
 
   MyView->SetViewMapping(MyViewMapping) ;
-//  SetZSize(0.);
+/*  SetZSize(0.);     */
   ImmediateUpdate();
 }
 
+
 Handle(Visual3d_View) V3d_View::View() const {
 
   return MyView ;
@@ -2527,6 +2531,7 @@
   return MyViewOrientation;
 }
 
+
 Standard_Boolean V3d_View::ScreenAxis( const Graphic3d_Vector &Vpn, const Graphic3d_Vector &Vup, Graphic3d_Vector &Xaxe, Graphic3d_Vector &Yaxe, Graphic3d_Vector &Zaxe) {
   Standard_Real Xpn,Ypn,Zpn,Xup,Yup,Zup ;
   Standard_Real dx1,dy1,dz1,dx2,dy2,dz2,xx,yy,zz ;
@@ -2570,14 +2575,14 @@
 Standard_Boolean V3d_View::Multiply (const TColStd_Array2OfReal& Left, const TColStd_Array2OfReal& Right, TColStd_Array2OfReal& Matrix) {
 
 Standard_Integer llr = Left.LowerRow ();
-//Standard_Integer lur = Left.UpperRow ();
+/*Standard_Integer lur = Left.UpperRow ();   */
 Standard_Integer llc = Left.LowerCol ();
 Standard_Integer luc = Left.UpperCol ();
 
 Standard_Integer rlr = Right.LowerRow ();
 Standard_Integer rur = Right.UpperRow ();
 Standard_Integer rlc = Right.LowerCol ();
-//Standard_Integer ruc = Right.UpperCol ();
+/*Standard_Integer ruc = Right.UpperCol (); */
 
 Standard_Integer mlr = Matrix.LowerRow ();
 Standard_Integer mur = Matrix.UpperRow ();
@@ -2588,7 +2593,7 @@
 
         InitMatrix (Result);
 
-        // Left et Right incompatibles
+        /* Left et Right incompatibles   */
         if (luc - llc + 1 != rur - rlr + 1)
                 return Standard_False;
 
@@ -2681,7 +2686,7 @@
   Graphic3d_Vertex PP ;
   Standard_Real X,Y,Z,XX,YY,ZZ ;
 
-  // CAL. S3892
+  /* CAL. S3892   */
 Standard_Integer lr, ur, lc, uc;
   lr    = Matrix.LowerRow ();
   ur    = Matrix.UpperRow ();
@@ -2709,7 +2714,7 @@
   Graphic3d_Vector VV ;
   Standard_Real X,Y,Z,XX,YY,ZZ ;
 
-  // CAL. S3892
+  /* CAL. S3892  */
 Standard_Integer lr, ur, lc, uc;
   lr    = Matrix.LowerRow ();
   ur    = Matrix.UpperRow ();
@@ -2782,15 +2787,15 @@
   Standard_Real Umin,Umax,Vmin,Vmax,Xrp,Yrp,Zrp ;
   Standard_Real DxvOld,DyvOld,DxvNew,DyvNew,RapOld,RapNew ;
   Standard_Integer Xpixel,Ypixel;
-  //Standard_Integer Xleft,Yup,Xright,Ylow ;
+  /*Standard_Integer Xleft,Yup,Xright,Ylow ;   */
   
   Viewer_BadValue_Raise_if( (Xmin == Xmax) || (Ymin == Ymax) ,
                           "V3d_View::FitAll, Window Size is NULL");
                         
   MyProjReferencePoint = MyViewMapping.ProjectionReferencePoint() ;
   MyProjReferencePoint.Coord(Xrp,Yrp,Zrp) ;
-  //aWindow->Position(Xleft,Yup,Xright,Ylow) ;
-  //DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;
+  /*aWindow->Position(Xleft,Yup,Xright,Ylow) ; */
+  /*DxvOld = Abs(Xright - Xleft) ; DyvOld = Abs(Yup - Ylow) ;*/
   aWindow->Size(Xpixel,Ypixel);
   DxvOld = Xpixel; DyvOld = Ypixel;
 
@@ -2838,7 +2843,7 @@
   if( zRotationThreshold > 0. ) {
     Standard_Real dx = Abs(sx - rx/2.);
     Standard_Real dy = Abs(sy - ry/2.);
-//  if( dx > rx/3. || dy > ry/3. ) zRotation = Standard_True;
+/*  if( dx > rx/3. || dy > ry/3. ) zRotation = Standard_True;     */
     Standard_Real dd = zRotationThreshold * (rx + ry)/2.;
     if( dx > dd || dy > dd ) zRotation = Standard_True;
   }
@@ -2875,7 +2880,7 @@
 #else
   myImmediateUpdate = Standard_False;
   Rotate(dx/rx, dy/ry, 0., gx, gy, gz, Standard_False);
-  ZFitAll (Zmargin);		//Don't do that, perf improvment
+  ZFitAll (Zmargin);		/*Don't do that, perf improvment */
   myImmediateUpdate = Standard_True;
   ImmediateUpdate();
 #endif
@@ -2884,7 +2889,7 @@
 void V3d_View::SetAnimationModeOn () {
 #ifdef G003
   if ( MyAnimationFlags & V3d_FLAG_ANIMATION ) {
-    if( ComputedMode() ) {	// Deactivates computed mode during animation
+    if( ComputedMode() ) {	/* Deactivates computed mode during animation  */
       MyAnimationFlags |= V3d_FLAG_COMPUTATION;
       Standard_Boolean immediatUpdate = myImmediateUpdate;
       myImmediateUpdate = Standard_False;
@@ -2903,7 +2908,7 @@
  if ( MyAnimationFlags & V3d_FLAG_ANIMATION ) {
    MyView -> SetAnimationModeOff ();
    if ( MyAnimationFlags & V3d_FLAG_COMPUTATION ) {
-				// Reactivates computed mode after animation
+				/* Reactivates computed mode after animation */
      MyAnimationFlags &= ~V3d_FLAG_COMPUTATION;
      SetComputedMode(Standard_True);
    } else if( MyAnimationFlags & V3d_FLAG_DEGENERATION ) {
@@ -2935,7 +2940,7 @@
  else
   MyAnimationFlags &= ~V3d_FLAG_DEGENERATION;
 
-}  // end V3d_View :: SetAnimationMode
+}  /* end V3d_View :: SetAnimationMode    */
 
 Standard_Boolean V3d_View::AnimationMode( Standard_Boolean& isDegenerate ) const {
 
@@ -2985,13 +2990,13 @@
     Update ();
   }
 
-}  // end V3d_View :: SetComputedMode
+}  /* end V3d_View :: SetComputedMode  */
 
 Standard_Boolean V3d_View :: ComputedMode () const {
 
  return MyView -> ComputedMode ();
 
-}  // end V3d_View :: ComputedMode
+}  /* end V3d_View :: ComputedMode    */
 
 void V3d_View :: SetBackFacingModel (
                   const V3d_TypeOfBackfacingModel aModel
@@ -2999,13 +3004,13 @@
 
  MyView -> SetBackFacingModel ( Visual3d_TypeOfBackfacingModel(aModel) );
  Redraw();
-}  // end V3d_View :: SetBackFacingModel
+}  /* end V3d_View :: SetBackFacingModel   */
 
 V3d_TypeOfBackfacingModel V3d_View :: BackFacingModel () const {
 
  return V3d_TypeOfBackfacingModel(MyView -> BackFacingModel ());
 
-}  // end V3d_View :: BackFacingModel
+}  /* end V3d_View :: BackFacingModel */
 #endif
 
 Standard_Boolean V3d_View::TransientManagerBeginDraw(const Standard_Boolean DoubleBuffer,const Standard_Boolean RetainMode) const {
@@ -3047,7 +3052,7 @@
 }
 
 void V3d_View::Plot() {
-//  cout << "Appel a Plot de Visual3d_View" << endl;
+/*  cout << "Appel a Plot de Visual3d_View" << endl; */
   
   Viewer_BadValue_Raise_if( !MyPlotter.IsNull(), "view has no plotter");
 
@@ -3102,7 +3107,7 @@
     new WNT_WDriver (Handle(WNT_Window)::DownCast(MyWindow));
 #else
     new Xw_Driver (Handle(Xw_Window)::DownCast(MyWindow));
-#endif // WNT
+#endif /* WNT  */
   Quantity_Factor    aScale;
   Quantity_Length    thePixel;
   Quantity_Parameter theWWidth, theWHeight;
@@ -3115,18 +3120,18 @@
     if (aPlotScale == 0.) {
       aScale = Min (thePWidth / theWWidth, thePHeight / theWHeight);
     } else {
-      // To be changed !!!!!!!!!!!!!!!
+      /* To be changed !!!!!!!!!!!!!!! */
       aScale = Min (thePWidth / theWWidth, thePHeight / theWHeight);
     }
 
-    // Set default maps (color, type, etc) for plotter driver
+    /* Set default maps (color, type, etc) for plotter driver*/
     aPlotterDriver -> SetColorMap ( new Aspect_GenericColorMap () );
     aPlotterDriver -> SetTypeMap  ( new Aspect_TypeMap         () );
     aPlotterDriver -> SetWidthMap ( new Aspect_WidthMap        () );
     aPlotterDriver -> SetFontMap  ( new Aspect_FontMap         () );
     aPlotterDriver -> SetMarkMap  ( new Aspect_MarkMap         () );
 
-    // Set backgroung to white, unihiglight if any
+    /* Set backgroung to white, unihiglight if any   */
     Quantity_Parameter theRed, theGreen, theBlue;
     Handle(TColStd_HSequenceOfInteger) theFlags;
     Graphic3d_MapOfStructure  theStructures;
@@ -3148,7 +3153,7 @@
     }
     Redraw ();
 
-    // Dump the view
+    /* Dump the view */
     if (aPlotterDriver->IsKind(STANDARD_TYPE(PlotMgt_ImageDriver))) {
       aFileToDump  = aPlotterDriver->PlotFileName();
     } else {
@@ -3169,7 +3174,7 @@
       SetBackgroundColor (Quantity_TOC_RGB, theRed, theGreen, theBlue);
     Redraw ();
 
-    // Draw imagefile by plotter driver
+    /* Draw imagefile by plotter driver  */
     aPlotterDriver -> SetPixelSize (thePixel);
     aPlotterDriver -> BeginDraw ();
     aPlotterDriver -> DrawImageFile (
@@ -3189,7 +3194,7 @@
 #include <Graphic3d_GraphicDriver.hxx>
 #include <Visual3d_Layer.hxx>
 
-////////////////////////////////////////////////////////////////
+/*//////////////////////////////////////////////////////////////*/
 Standard_Boolean V3d_View::Dump ( const Standard_CString aFile )
 {
 Standard_Boolean isDone;
@@ -3205,16 +3210,16 @@
   return isDone;
 }
 
-////////////////////////////////////////////////////////////////
+/*///////////////////////////////////////////////////////////////*/
 Standard_Boolean V3d_View::Dump ( const Standard_CString aFile,
                       const Aspect_FormatOfSheetPaper aFormat)
 {
 Standard_Boolean isDone = Standard_False;
-  // convert Aspect_FormatOfSheetPaper size to pixel ...
+  /* convert Aspect_FormatOfSheetPaper size to pixel ...*/
   Quantity_Length theSPWidth, theSPHeight;
   Aspect::ValuesOfFOSP ( aFormat, theSPWidth, theSPHeight );
 
-  // adjusting to the ratio width/height ...
+  /* adjusting to the ratio width/height ...*/
   Quantity_Length theWinWidth, theWinHeight;
   MyWindow->MMSize ( theWinWidth, theWinHeight );
   Standard_Integer thePixelWidth, thePixelHeight;
@@ -3236,18 +3241,18 @@
     Xw_PixMap aBitmap ( MyWindow, thePixelWidth, thePixelHeight );
 #endif
 
-    // add bitmap ID and size to the MyCView structure ...
+    /* add bitmap ID and size to the MyCView structure ...*/
     cView->DefBitmap.bitmap = aBitmap.PixmapID();
     cView->DefBitmap.width  = thePixelWidth;
     cView->DefBitmap.height = thePixelHeight;
 
     Redraw ();
 
-    // deactivate the bitmap ID in the MyCView structure ...
+    /* deactivate the bitmap ID in the MyCView structure ...*/
     cView->DefBitmap.bitmap = Aspect_Handle(NULL);
     cView->DefBitmap.width  = 0;
     cView->DefBitmap.height = 0;
-#endif // IMP100701
+#endif /* IMP100701*/
 
     Standard_Real gammaValue = 1.0; 
     OSD_Environment envGamma("CSF_GAMMA_CORRECTION");
@@ -3258,7 +3263,7 @@
   }
   return isDone;
 }
-#endif	//G004
+#endif	/*G004*/
 
 ////////////////////////////////////////////////////////////////
 Handle(Aspect_PixMap) V3d_View::ToPixMap (const Standard_Integer aWidth,
@@ -3273,26 +3278,26 @@
     theBitmap = new Xw_PixMap ( MyWindow, aWidth, aHeight, aCDepth );
 #endif
 
-    //szv: save mapping
+    /*szv: save mapping*/
     Visual3d_ViewMapping prevMapping = MyView->ViewMapping();
 
-    //szv: get mapping frame
+    /*szv: get mapping frame*/
     Standard_Real PUmin, PVmin, PUmax, PVmax;
     prevMapping.WindowLimit(PUmin,PVmin,PUmax,PVmax);
 
-    //szv: calculate expansion
+    /*szv: calculate expansion*/
     Standard_Real Umin = PUmin, Vmin = PVmin, Umax = PUmax, Vmax = PVmax;
     Standard_Real oldWidth = (PUmax - PUmin), oldHeight = (PVmax - PVmin);
     Standard_Real newWidth = (oldHeight * aWidth) / aHeight;
     if (newWidth < oldWidth) {
       Standard_Real newHeight = (oldWidth * aHeight) / aWidth;
-      // Expand height
+      /* Expand height*/
       Standard_Real delta = 0.5 * (newHeight - oldHeight);
       Vmin = PVmin - delta;
       Vmax = PVmax + delta;
     }
     else {
-      // Expand width
+      /* Expand width*/
       Standard_Real delta = 0.5 * (newWidth - oldWidth);
       Umin = PUmin - delta;
       Umax = PUmax + delta;
@@ -3300,7 +3305,7 @@
 
     Graphic3d_CView* cView = (Graphic3d_CView*)MyView->CView();
 
-    // add bitmap ID and size to the MyCView structure ...
+    /* add bitmap ID and size to the MyCView structure ...*/
     Standard_Integer aWi, anHe;
     theBitmap->Size ( aWi, anHe );
     cView->DefBitmap.bitmap = theBitmap->PixmapID();
@@ -3308,17 +3313,17 @@
     cView->DefBitmap.height = anHe;
     cView->DefBitmap.depth = theBitmap->Depth();
 
-    //szv: apply expanded mapping
+    /*szv: apply expanded mapping*/
     MyViewMapping.SetWindowLimit(Umin,Vmin,Umax,Vmax);
     MyView->SetViewMapping(MyViewMapping);
 
     Redraw ( );
 
-    //szv: restore mapping
+    /*szv: restore mapping*/
     MyViewMapping = prevMapping;
     MyView->SetViewMapping(prevMapping);
 
-    // deactivate the bitmap ID in the MyCView structure ...
+    /* deactivate the bitmap ID in the MyCView structure ...*/
     cView->DefBitmap.bitmap  = Aspect_Handle(NULL);
     cView->DefBitmap.width  = 0;
     cView->DefBitmap.height = 0;
diff -Naur OpenCASCADE6.3.0.orig//ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx OpenCASCADE6.3.0/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx
--- OpenCASCADE6.3.0.orig//ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx	2010-07-04 20:15:41.229651213 +0200
+++ OpenCASCADE6.3.0/ros/src/ViewerTest/ViewerTest_ViewerCommands.cxx	2009-01-14 10:24:56.000000000 +0100
@@ -1411,6 +1411,23 @@
   return 0;
 }
 
+//==============================================================================
+//function : VTestZBuffTrihedron
+//purpose  : Displays a V3d_ZBUFFER'ed trihedron at the bottom left corner of the view
+//==============================================================================
+
+static int VTestZBuffTrihedron(Draw_Interpretor& di, Standard_Integer argc, const char** argv)
+{
+  Handle(V3d_View) V3dView = ViewerTest::CurrentView();
+  if ( V3dView.IsNull() ) return 1;
+
+  // Set up default trihedron parameters
+  V3dView->ZBufferTriedronSetup();
+  V3dView->TriedronDisplay( Aspect_TOTP_LEFT_LOWER, Quantity_NOC_WHITE, 0.1, V3d_ZBUFFER );
+  V3dView->ZFitAll();
+  return 0;
+}
+
 //=======================================================================
 //function : ViewerCommands
 //purpose  :
@@ -1453,5 +1470,8 @@
   theCommands.Add("vscale",
 		  "vscale          : vscale X Y Z",
 		  __FILE__,VScale,group);
+  theCommands.Add("vzbufftrihedron",
+		  "vzbufftrihedron : Displays a V3d_ZBUFFER'ed trihedron at the bottom left corner of the view",
+		  __FILE__,VTestZBuffTrihedron,group);
 
 }
diff -Naur OpenCASCADE6.3.0.orig//ros/src/Visual3d/Visual3d_View.cxx OpenCASCADE6.3.0/ros/src/Visual3d/Visual3d_View.cxx
--- OpenCASCADE6.3.0.orig//ros/src/Visual3d/Visual3d_View.cxx	2010-07-04 20:15:42.919646253 +0200
+++ OpenCASCADE6.3.0/ros/src/Visual3d/Visual3d_View.cxx	2008-11-07 14:35:46.000000000 +0100
@@ -59,21 +59,21 @@
 
 ************************************************************************/
 
-#define BUC60572        //GG_03-08-99    Add protection on Zclipping & Zcueing planes
-//              positions.
+#define BUC60572        /*GG_03-08-99    Add protection on Zclipping & Zcueing planes */
+/*              positions.      */
 
-#define BUC60570        //GG 14-09-99 Don't activates lighting
-//                      when the view shading model is NONE.
+#define BUC60570        /*GG 14-09-99 Don't activates lighting
+                      when the view shading model is NONE.   */
 
-#define GER61454        //GG 14-09-99 Activates model clipping planes
+#define GER61454        /*GG 14-09-99 Activates model clipping planes  */
 
-#define IMP140100       //GG14-01-00 Add ViewManager( ) method
+#define IMP140100       /*GG14-01-00 Add ViewManager( ) method  */
 
-#define G003            //EUG 30-09-00 Degeneration management
-//                                     Backfacing management
+#define G003            /*EUG 30-09-00 Degeneration management
+                                     Backfacing management    */
 
-#define RIC120302       //GG Add a NEW SetWindow method which enable
-//                      to connect a graphic widget and context to OGL.
+#define RIC120302       /*GG Add a NEW SetWindow method which enable
+                      to connect a graphic widget and context to OGL.  */
 
 #define  BUC61044    /* 25/10/01 SAV ; added functionality to control gl depth testing
                         from higher API */
@@ -110,7 +110,7 @@
 #include <windows.h>
 #endif
 
-// for the class
+/* for the class  */
 #include <Visual3d_View.ixx>
 #include <Visual3d_View.pxx>
 #include <Visual3d_DepthCueingDefinitionError.hxx>
@@ -153,13 +153,13 @@
 # include <Xw_Window.hxx>
 #else
 # include <WNT_Window.hxx>
-#endif  // WNT
+#endif  /* WNT    */
 
-//-Aliases
+/*-Aliases*/
 
-//-Global data definitions
+/*-Global data definitions  */
 
-//-Constructors
+/*-Constructors */
 
 Visual3d_View::Visual3d_View (const Handle(Visual3d_ViewManager)& AManager):
 MyContext (),
@@ -222,14 +222,14 @@
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix   */
         MyCView.Orientation.IsCustomMatrix = 0;
         memset( (float*)MyCView.Orientation.ModelViewMatrix, 0, 16*sizeof( float ) ); 
         MyCView.Orientation.ModelViewMatrix[0][0] =
         MyCView.Orientation.ModelViewMatrix[1][1] =
         MyCView.Orientation.ModelViewMatrix[2][2] =
         MyCView.Orientation.ModelViewMatrix[3][3] = 1.;
-        //
+                /**/
 
 Standard_Real um, vm, uM, vM;
 
@@ -250,14 +250,14 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix  */
         MyCView.Mapping.IsCustomMatrix = 0;
         memset( (float*)MyCView.Mapping.ProjectionMatrix, 0, 16*sizeof( float ) ); 
         MyCView.Mapping.ProjectionMatrix[0][0] =
         MyCView.Mapping.ProjectionMatrix[1][1] =
         MyCView.Mapping.ProjectionMatrix[2][2] =
         MyCView.Mapping.ProjectionMatrix[3][3] = 1.;
-        //
+        /**/
 
         MyCView.Context.ZBufferActivity = -1;
 
@@ -273,7 +273,7 @@
         MyCView.IsDegeneratesPrev = 0;
         ComputedModeIsActive      = Standard_False;
         MyCView.Backfacing        = 0;
-#endif  // G003
+#endif  /* G003   */
 
         MyCView.DefBitmap.bitmap = 0;
         MyCView.ptrUnderLayer = 0;
@@ -350,8 +350,8 @@
         MyCView.Orientation.ViewScaleX                  = float (Sx);
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
-
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+   
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix    */
         if (MyViewOrientation.IsCustomMatrix()) {
           MyCView.Orientation.IsCustomMatrix = 1;
           for ( i = 0; i < 4; i++)
@@ -366,7 +366,7 @@
           MyCView.Orientation.ModelViewMatrix[2][2] =
           MyCView.Orientation.ModelViewMatrix[3][3] = 1.;
         }
-        //
+        /**/
 
 Standard_Real um, vm, uM, vM;
 
@@ -387,7 +387,7 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        // NKV : 23/07/07 - Define custom MODELVIEW matrix
+        /* NKV : 23/07/07 - Define custom MODELVIEW matrix  */
         if (MyViewMapping.IsCustomMatrix()) {
           MyCView.Mapping.IsCustomMatrix = 1;
           for ( i = 0; i < 4; i++)
@@ -402,8 +402,8 @@
           MyCView.Mapping.ProjectionMatrix[2][2] =
           MyCView.Mapping.ProjectionMatrix[3][3] = 1.;
         }
-        //
-
+        /**/
+   
         MyCView.Context.ZBufferActivity = -1;
 
         MyMatOfMapIsModified    = Standard_True;
@@ -415,7 +415,7 @@
         MyCView.IsDegenerates     = 0;
         MyCView.IsDegeneratesPrev = 0;
         ComputedModeIsActive      = Standard_False;
-#endif  // G003
+#endif  /* G003  */
 
         MyCView.DefBitmap.bitmap = 0;
         MyCView.ptrUnderLayer = 0;
@@ -431,10 +431,10 @@
 
 }
 
-//-Destructors
+/*-Destructors */
 
-//-Methods, in order
-// RIC120302
+/*-Methods, in order*/
+/* RIC120302  */
 void Visual3d_View::SetWindow (const Handle(Aspect_Window)&      AWindow,
                                const Aspect_RenderingContext     AContext,
                                const Aspect_GraphicCallbackProc& ADisplayCB,
@@ -486,8 +486,8 @@
 
 Standard_Integer Width, Height;
         AWindow->Size (Width, Height);
-
-        MyCView.DefWindow.dx    = float( Width );
+	
+        MyCView.DefWindow.dx    = float( Width ); 
         MyCView.DefWindow.dy    = float( Height );
 
 Standard_Real R, G, B;
@@ -628,7 +628,7 @@
         MyViewMapping.WindowLimit(Umin,Vmin,Umax,Vmax) ;
         Xc      = (Umin + Umax)/2. ; Yc = (Vmin + Vmax)/2. ;
         Dxv     = Umax - Umin ; Dyv     = Vmax - Vmin ;
-        if( Dxw > 0 && Dyw > 0 ) Rap = (Standard_Real)Dyw/(Standard_Real)Dxw ;
+	   if( Dxw > 0 && Dyw > 0 ) Rap = (Standard_Real)Dyw/(Standard_Real)Dxw;
         if( Rap > 0.0 ) {
 
             if( Dxv <= Dyv ) 
@@ -665,11 +665,11 @@
 
             // Mise a jour avant le SetViewMapping.
 
-            MyCView.DefWindow.dx        = float( Dxw );
-            MyCView.DefWindow.dy        = float( Dyw );
+            MyCView.DefWindow.dx        = float( Dxw ); 
+            MyCView.DefWindow.dy        = float( Dyw ); 
 
             SetViewMapping (MyViewMapping);
-//          SetViewMappingDefault ();
+            // SetViewMappingDefault ();
             // FMN+ Mise a jout Ratio pour le MyViewMappingReset
             
             MyViewMappingReset.WindowLimit(Umin,Vmin,Umax,Vmax) ;
@@ -1109,7 +1109,7 @@
         MyCView.Orientation.ViewScaleY                  = float (Sy);
         MyCView.Orientation.ViewScaleZ                  = float (Sz);
 
-        CustomIsModified = 
+	  CustomIsModified = 
           MyCView.Orientation.IsCustomMatrix != MyViewOrientation.IsCustomMatrix();
         MyCView.Orientation.IsCustomMatrix = MyViewOrientation.IsCustomMatrix();
         if ( MyViewOrientation.IsCustomMatrix() ) {
@@ -1121,14 +1121,14 @@
               MyCView.Orientation.ModelViewMatrix[i][j] = MyViewOrientation.MyModelViewMatrix->Value(i,j);
             }
         }
-
+              
 #ifdef TRACE_TRSF
 cout << "Visual3d_View::SetViewOrientation\n";
-        if (VUPIsModified || VRPIsModified || VRUIsModified || CustomIsModified)
-                cout <<   "VUPIsModified : " << VUPIsModified
-                     << ", VRPIsModified : " << VRPIsModified
-                     << ", VRUIsModified : " << VRUIsModified 
-                     << ", CustomIsModified : " << CustomIsModified << "\n" << flush;
+         if (VUPIsModified || VRPIsModified || VRUIsModified || CustomIsModified)
+              cout <<   "VUPIsModified : " << VUPIsModified
+                   << ", VRPIsModified : " << VRPIsModified
+                   << ", VRUIsModified : " << VRUIsModified 
+                   << ", CustomIsModified : " << CustomIsModified << "\n" << flush;
         else
                 cout << "no modification\n" << flush;
 #endif
@@ -1297,14 +1297,14 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
+	   MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
         if (MyViewMapping.IsCustomMatrix()) {
           Standard_Integer i, j;
           for (i = 0; i < 4; i++)
             for (j = 0; j < 0; j++)
               MyCView.Mapping.ProjectionMatrix[i][j] = MyViewMapping.MyProjectionMatrix->Value(i,j);
         }
-
+	
         MyMatOfMapIsModified    = Standard_True;
         MyMatOfMapIsEvaluated   = Standard_False;
 
@@ -1365,7 +1365,7 @@
         MyCView.Mapping.WindowLimit.uM  = float (uM);
         MyCView.Mapping.WindowLimit.vM  = float (vM);
 
-        MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
+	  MyCView.Mapping.IsCustomMatrix = MyViewMapping.IsCustomMatrix();
         if (MyViewMapping.IsCustomMatrix()) {
           Standard_Integer i, j;
           for (i = 0; i < 4; i++)
@@ -1605,11 +1605,11 @@
 
 }
 
-void Visual3d_View::DisplayedStructures (Graphic3d_MapOfStructure& SG) const 
+void Visual3d_View::DisplayedStructures (Graphic3d_MapOfStructure& SG) const
 {
 
   if (IsDeleted ()) return;
-
+  
   Graphic3d_MapIteratorOfMapOfStructure Iterator (MyDisplayedStructure);
 
   while (Iterator.More ()) {
@@ -1647,7 +1647,7 @@
                  * la vue directement, si la structure n'est pas deja
                  * affichee et si la vue l'accepte dans son contexte.
                  */
-
+          
 		Visual3d_TypeOfAnswer Answer;
                 Graphic3d_MapOfStructure Map;
                 MyViewManager->DisplayedStructures(Map);
@@ -1718,7 +1718,8 @@
                  * effacee et si la vue l'accepte dans son contexte.
                  */
 
-		Visual3d_TypeOfAnswer Answer;
+           
+          Visual3d_TypeOfAnswer Answer;
                 Graphic3d_MapOfStructure Map;
                 MyViewManager->DisplayedStructures(Map);
                 Graphic3d_MapIteratorOfMapOfStructure it(Map);
@@ -2083,10 +2084,10 @@
                 Index = 0;
         }
 
-	Visual3d_TypeOfAnswer Answer = AcceptDisplay (AStructure);
+      Visual3d_TypeOfAnswer Answer = AcceptDisplay (AStructure);
 
 #ifdef TRACE_DISPLAY
-	Standard_Integer StructId = AStructure->Identification ();
+      	Standard_Integer StructId = AStructure->Identification ();
         cout << "Visual3d_View" << MyCView.ViewId << "::Display ("
              << StructId << ");\n";
         cout << flush;
@@ -2094,8 +2095,8 @@
 
         if (Answer == Visual3d_TOA_NO) {
 #ifdef TRACE_DISPLAY
-                cout << "Answer : Visual3d_TOA_NO\n";
-                cout << flush;
+	          cout << "Answer : Visual3d_TOA_NO\n";
+               cout << flush;
 #endif
                 return;
         }
@@ -2880,24 +2881,25 @@
         	APX     = ( APX + 1 ) * 0.5 * (uM - um) + um;
         	APY     = ( APY + 1 ) * 0.5 * (vM - vm) + vm;
         } else {
-        	Ratio   = (uM - um) / (vM - vm);
-        	if (Ratio >= 1.0)
-        		APY *= Ratio;
-        	else
-        		APX /= Ratio;
-
-        	/*
-        	* Les coordonnees de APX, APY, APZ sont decrites dans
-        	* l'espace [0-1]x[0-1]x[0-1].
-        	* Il faut transformer x et y dans le window space.
-        	* Il faut transformer z dans l'espace du back et front
-        	* plane, en pensant aux plans de clipping.
-        	* Ces plans de z clipping sont definis entre 0 et 1.
-        	*/
-            APX     = APX * (uM - um) + um;
-            APY     = APY * (vM - vm) + vm;
-        }		
-        APZ     = APZ * (fpd - bpd) + bpd;
+        Ratio   = (uM - um) / (vM - vm);
+        if (Ratio >= 1.0)
+            APY *= Ratio;
+        else
+            APX /= Ratio;
+
+        /*
+         * Les coordonnees de APX, APY, APZ sont decrites dans
+         * l'espace [0-1]x[0-1]x[0-1].
+         * Il faut transformer x et y dans le window space.
+         * Il faut transformer z dans l'espace du back et front
+         * plane, en pensant aux plans de clipping.
+         * Ces plans de z clipping sont definis entre 0 et 1.
+        */
+
+        APX     = APX * (uM - um) + um;
+        APY     = APY * (vM - vm) + vm;
+     }
+     APZ     = APZ * (fpd - bpd) + bpd;
 }
  
 Standard_Integer Visual3d_View::Identification () const {
@@ -3094,7 +3096,7 @@
                         MyCOMPUTEDSequence.Value (Index)->Identification ();
 #ifdef TRACE_COMP
 	Standard_Integer StructId = AStructure->Identification ();
-        cout << "La structure " << StructId
+       cout << "La structure " << StructId
              << " calculee, dans la view "
              << Identification () << ", par la structure "
              << OldStructId << " est recalculee.\n";
diff -Naur OpenCASCADE6.3.0.orig//ros/src/WNT/WNT_Window.cdl OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cdl
--- OpenCASCADE6.3.0.orig//ros/src/WNT/WNT_Window.cdl	2010-07-04 20:15:10.640664406 +0200
+++ OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cdl	2008-11-01 13:41:52.000000000 +0100
@@ -16,6 +16,12 @@
 	--  Warning: The position and size for the creation of the window
 	--	    are defined in Device Screen Unit (DSU)
 	--	    floating [0,1] space.
+        --         
+	--          As 3D view window is the main purpose of this class,
+	--          and 3D view does not need its background to be drawn
+	--          by the system, by default the window background is not drawn.
+	--          This can be overridden by calling ClearFlags( WDF_NOERASEBKGRND ).
+	--          See also WNT_WndProc.cxx and InterfaceGraphic_WNT.hxx.
 
  uses
 
@@ -335,11 +341,15 @@
      is static;
      	---Level:   Public
      	---Purpose: Sets user defined flags in the extra window data area.
+	--          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx
+	--          In particular, the window backround can be turned off using this method.
 
     ResetFlags ( me : mutable; aFlags : Integer from Standard )
      is static;
      	---Level:   Public
     	---Purpose: Reset specified flags in the extra window data area.
+	--          Supported flags WDF_* are listed in InterfaceGraphic_WNT.hxx
+	--          In particular, the window backround can be turned on using this method.
 
     
  	----------------------------
diff -Naur OpenCASCADE6.3.0.orig//ros/src/WNT/WNT_Window.cxx OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cxx
--- OpenCASCADE6.3.0.orig//ros/src/WNT/WNT_Window.cxx	2010-07-04 20:15:10.665933819 +0200
+++ OpenCASCADE6.3.0/ros/src/WNT/WNT_Window.cxx	2008-11-07 14:19:38.000000000 +0100
@@ -67,13 +67,13 @@
                const Aspect_Handle                aMenu,
                const Standard_Address             aClientStruct
                   ) : Aspect_Window ( aDevice ), myWClass ( aClass )
-{
+{	
   int   x, y, w, h, px, py, pw, ph;
   DWORD dwStyle = aStyle;
   const Handle( WNT_GraphicDevice )& dev = Handle( WNT_GraphicDevice ) ::
                                            DownCast ( MyGraphicDevice );
 
-  if ( Xc < 0. || Xc > 1. || Yc < 0. || Yc > 1. ||
+   if ( Xc < 0. || Xc > 1. || Yc < 0. || Yc > 1. ||
        aWidth <= 0. || aHeight <= 0. )
 
   Aspect_WindowDefinitionError :: Raise ( "Coordinate(s) out of range" );
@@ -150,8 +150,7 @@
   myHPixmap       = 0;
   myHParentWindow = aParent;
   myWndProc       = myWClass -> WndProc ();
-  myHParentWindow = aParent;
-
+  myHParentWindow = aParent;	
   SetBackground ( aBackColor );
 #ifndef _WIN64
   SetWindowLong (  ( HWND )myHWindow, GWL_WNDPROC,  ( LONG )WNT_WndProc   );
@@ -177,6 +176,11 @@
   myImages = new WNT_ImageManager ( this );
   myFormat = WNT_TOI_XWD;
 
+    /* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+ 
+
+
 }  // end constructor
 //***//
 //************************* Constructor **********************************//
@@ -189,6 +193,9 @@
 
  doCreate ( aDevice, aHandle, aBackColor );
 
+	/* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+
 }  // end constructor
 //***//
 //************************* Constructor **********************************//
@@ -204,6 +211,9 @@
 
  doCreate ( aDevice, aHandle, aBackColor );
 
+ 	/* Bug OCC20596 */
+	SetFlags(WDF_NOERASEBKGRND);
+
 }  // end constructor
 //***//
 //***************************** Destroy **********************************//
