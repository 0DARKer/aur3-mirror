#!/bin/bash

# Some colored makepkg-like functions
msg() {
    printf "${GREEN}==>${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

msg_yellow() {
    printf "${YELLOW}==>${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

msg2() {
    printf "${BLUE}  ->${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

read_msg2() {
    read -p "${BLUE}  ->${ALL_OFF}${BOLD} $1${ALL_OFF}"
}

msg3() {
    printf "${YELLOW}    ->${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

info_yellow() {
    printf "${YELLOW}$1${ALL_OFF}${BOLD} $2${ALL_OFF}\n"
}

warning() {
    printf "${YELLOW}==> WARNING:${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

error() {
    printf "${RED}==> ERROR:${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

# Variables for them
ALL_OFF="$(tput sgr0)"
BOLD="$(tput bold)"
BLUE="${BOLD}$(tput setaf 4)"
GREEN="${BOLD}$(tput setaf 2)"
RED="${BOLD}$(tput setaf 1)"
YELLOW="${BOLD}$(tput setaf 3)"

# Don't continue with an unknown flag
if [[ "$@" ]] && [[ "$@" != '-f' ]]; then
    error "Unknown option: $*"
    info_yellow "Available options:" "-f (force reinstallation even, if modules have already been built)."
    exit 1
fi

# Make sure we are root
if [ $(whoami) != "root" ]; then
    error "This script needs to be run as root."
    exit 1
fi

# Is a VMware product installed?
if [ ! -f /usr/bin/vmware-installer ]; then
    error "No VMware product found. Exiting.."
    exit 1
fi

# Warn about gtkmm 2.24.3-1
if [[ $(pacman -Q gtkmm | cut -d " " -f2) = 2.24.3-1 ]]; then
    warning "Gtkmm 2.24.3-1 found. This will make VMware segfault on startup.
             You are recommended to update to 2.24.4-1."
fi

# Set some variables (|&: hide "No protocol specified" in KDE by redirecting all output to cut/grep)
KERNEL=$(uname -r | cut -d "." -f-2)
VER=$(vmware-installer -l |& egrep "(player|workstation)" | grep -Po "(\d\.){2}\d")
if [ $(vmware-installer -l |& egrep "(player|workstation)" | cut -d " " -f1) = "vmware-workstation" ]; then
    NAME="VMware Workstation"
else
    NAME="VMware Player"
fi

# Make sure vmware.service includes our USB Arbitrator service
if [[ ! $(grep usbarbitrator /usr/lib/systemd/system/vmware.service) ]]; then
    msg "Updating vmware.service.."
    sed '/Description/a Requires=vmware-usbarbitrator.service\nBefore=vmware-usbarbitrator.service' \
         -i /usr/lib/systemd/system/vmware.service
fi

# Make sure there's a version in /etc/arch-release:
# https://wiki.archlinux.org/index.php/Vmware#2.29_The_vmware-usbarbitrator_binary_is_segfaulting
if [ ! $(cat /etc/arch-release) ]; then
    msg "Updating /etc/arch-release.."
    echo 2013.06.01 > /etc/arch-release
fi

# Prepare for /bin, /sbin, /usr/sbin -> /usr/bin move, if necessary (discard symlinks from /sbin): 
# https://mailman.archlinux.org/pipermail/arch-dev-public/2013-May/024908.html
if [[ $(pacman -Q filesystem | cut -d " " -f2 | tr -d .-) -lt 2013051 ]]; then
    msg "Preparing for /bin, /sbin, /usr/sbin -> /usr/bin move"
    perl -p -i -e 's|/sbin/(?!modprobe)|/usr/bin/|g' /etc/init.d/vmware /usr/bin/vm-support /usr/bin/vmplayer
    # If using Workstation, edit these things as well:
    if [ "${NAME}" = "VMware Workstation" ]; then
        perl -p -i -e 's|/sbin/(?!modprobe)|/usr/bin/|g' /usr/bin/vmware /usr/bin/vmware-hostd /usr/bin/vmware-wssc-adminTool
    fi
fi

# Remove leftover header locations
for i in /usr/src/*; do
    if [[ $(ls $i) = 'include' ]]; then
        msg_yellow "Removing leftover header location $i/"
        rm -r $i
    fi
done

# Symlink version.h, if necessary (# 1) We don't have one already (accept files too))
if [ ! -f /usr/src/linux-$(uname -r)/include/linux/version.h ]; then
    # 2) Installed Workstation/Player less than 9.0.2/5.0.2
    if [[ ${VER} != [59].0.[2-6] ]]; then
        # 3) Kernel version 3.5 or above (another way to deal with numbers)
        if [ $(echo ${KERNEL} | tr -d .) -ge 35 ]; then
            msg "Symlinking version.h for $(uname -r)"
            install -d "${pkgdir}"/usr/src/linux-$(uname -r)/include/linux/
            ln -s /usr/src/linux-$(uname -r)/include/generated/uapi/linux/version.h \
                 "${pkgdir}"/usr/src/linux-$(uname -r)/include/linux/
        fi
    fi
fi

# Remove leftover module locations
for i in /usr/lib/modules/*; do
    if [[ $(ls $i) = 'misc' ]]; then
        msg_yellow "Removing leftover module location $i/"
        rm -r $i
    fi
done

# Backup/Convert/Remove old backups, whatever necessary
cd /usr/lib/vmware/modules/
# 1) Use double quotes ("[[") and "ls" instead of the builtin -d/-f for multiple arguments
# 2) 2>&-: supported by "ls", basically same as "2>/dev/null" only shorter (ignore errors (STDERR))
if [[ $(ls -d source?*/ source/*.tar-* 2>&- | grep -vx source-${VER}/) ]]; then
    msg "Cleaning up old backups.."
    # 1) Check the new location first
    # 2) Remove any duplicated/old ones
    # 3) Print full paths
    # 4) Sed: leave out the first result containing ${VER}
    for i in $(readlink -e source?*/ | sed "0,/${VER}/{//d}"); do
        msg2 "Removing ${i}"
        rm -r "${i}"
    done
    # If we already have a backup in the new location, remove any from the old one
    if [ -d source-${VER}*/ ]; then
        for i in $(readlink -e source/*.tar-*); do
            msg2 "Removing ${i}"
            rm -r "${i}"
        done
        # Rename it as we like (or as I do)
        if [ -d source-${VER}?*/ ]; then
            msg3 "Renaming: $(readlink -f source-${VER}*)/ -> $(readlink -f source-${VER})/"
            mv source-${VER}*/ source-${VER}/
        fi
    else
        # Remove any duplicated/old backups
        for i in vmblock vmci vmmon vmnet vsock; do
            for j in $(readlink -e source/${i}.tar-* | sed "0,/${VER}/{//d}"); do
                msg2 "Removing ${j}"
                rm -r "${j}"
            done
        done
        # Convert leftovers
        if [ -f source/vmblock.tar-* ]; then
            # Shorten the msg3 function
            _old=$(readlink -f source/vmblock.tar-* | sed 's/vmblock/*/')
            msg3 "Converting: ${_old} -> $(readlink -f source-${VER})/"
            mkdir source-${VER}/
            for i in vmblock vmci vmmon vmnet vsock; do
                mv source/${i}.tar-* source-${VER}/${i}.tar
            done
        fi
    fi
fi

# Support the '-f' flag
# 1) Have we already built (vsock is built last)?
# 2) Don't check this until we've removed the leftovers
if [ -f /usr/lib/modules/$(uname -r)/misc/vsock.ko ]; then
    # Offer the ability reinstall this thing
    if [[ "$@" = '-f' ]]; then
        msg "Reinstalling modules.."
    elif [[ ! "$@" ]]; then
        error "VMware modules already installed (use -f to override). Exiting.."
        exit 1
    fi
fi

# Patch
# 1) Make sure we can build
# 2) Shorther without double brackets ("[["):
# 3) &>/dev/null: hide all output (STDIN/STDERR)
if ls patches/*${VER}*${KERNEL}*.patch &>/dev/null; then
    # Create a backup/Revert
    if [ ! -d source-${VER} ]; then
        msg "Creating a backup.."
        cp -r source/ source-${VER}/
    else  # Get the original sources from the backup (invalidate the need for 'vmware-unpatch')
        cp source-${VER}/* source/
    fi
    # Loop modules that require patching (vmblock, vmci, vmmon, vmnet and/or vsock)
    msg "Patching ${NAME} v${VER} for kernel $(uname -r).."
    cd source
    for mod in $(ls ../patches/*${VER}*${KERNEL}*.patch | cut -d "/" -f3 | cut -d "-" -f1); do
        # Untar
        tar -xf ${mod}.tar
        # Patch
        msg2 "${mod}"
        # Shorten
        _patch=../patches/${mod}*${VER}*${KERNEL}*.patch
        if ! patch -p0 -s -f -i ${_patch}; then
            error "Failed to apply '$(basename ${_patch})'"
            read_msg2 "Continue? (Y/n) "
            if [[ "$REPLY" != [Yy] ]]; then
                # Revert
                msg "Reverting.."
                cd ..
                rm -r source/
                mv source-${VER}/ source/
                msg "Done."
                exit 1
            fi
        fi
        # Tar patched modules
        tar -cf ${mod}.tar ${mod}-only
        rm -r ${mod}-only
    done
else
    msg "No patching required."
fi

# Install
msg "Installing modules.."
vmware-modconfig --console --install-all &>/dev/null
msg "Done."
