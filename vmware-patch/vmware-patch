#!/bin/bash

# Some colored makepkg-like functions
msg() {
  printf "${GREEN}==>${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

msg_yellow() {
  printf "${YELLOW}==>${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

msg2() {
  printf "${BLUE}  ->${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

read_msg2() {
  read -p "${BLUE}  ->${ALL_OFF}${BOLD} $1${ALL_OFF}"
}

msg3() {
  printf "${YELLOW}    ->${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

info_yellow() {
  printf "${YELLOW}$1${ALL_OFF}${BOLD} $2${ALL_OFF}\n"
}

warning() {
  printf "${YELLOW}==> WARNING:${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

error() {
  printf "${RED}==> ERROR:${ALL_OFF}${BOLD} $1${ALL_OFF}\n"
}

# Variables for them
ALL_OFF="$(tput sgr0)"
BOLD="$(tput bold)"
BLUE="${BOLD}$(tput setaf 4)"
GREEN="${BOLD}$(tput setaf 2)"
RED="${BOLD}$(tput setaf 1)"
YELLOW="${BOLD}$(tput setaf 3)"

# Don't continue with an unknown flag
if [[ "$@" ]] && [[ "$@" != '-f' ]]; then
  error "Unknown option: $*"
  info_yellow "Available options:" "-f (force reinstallation even, if modules have already been built)."
  exit 1
fi

# Make sure we are root
if [ $(whoami) != "root" ]; then
  error "This script needs to be run as root."
  exit 1
fi

# Is a VMware product installed?
if [ ! -f /usr/bin/vmware-installer ]; then
  error "No VMware product found. Exiting.."
  exit 1
fi

# Set some variables (|&: hide "No protocol specified" in KDE by redirecting all output to cut/grep)
kernel=$(uname -r | cut -d "." -f-2)
ver=$(vmware-installer -l |& egrep "(player|workstation)" | grep -Po "(\d+\.){2}\d+")
if [ $(vmware-installer -l |& egrep "(player|workstation)" | cut -d " " -f1) = "vmware-workstation" ]; then
  name="VMware Workstation"
else
  name="VMware Player (Plus)"
fi

# Make sure vmware.service includes our USB Arbitrator service
if [[ ! $(grep usbarbitrator /usr/lib/systemd/system/vmware.service) ]]; then
  msg "Updating vmware.service.."
  sed '/Description/a Requires=vmware-usbarbitrator.service\nBefore=vmware-usbarbitrator.service' \
      -i /usr/lib/systemd/system/vmware.service
fi

# Make sure there's a version in /etc/arch-release for versions prior to Workstation 10 / Player (Plus) 6:
# https://wiki.archlinux.org/index.php?title=VMware&oldid=274532#2.29_The_vmware-usbarbitrator_binary_is_segfaulting
if [[ $ver != 6.0.? ]] && [[ $ver != 10.0.? ]]; then
  if [ ! $(cat /etc/arch-release) ]; then
    msg "Updating /etc/arch-release.."
    curl -s https://www.archlinux.org/releng/releases/ | grep -Pom1 'for \K[^"]*' > /etc/arch-release
  fi
fi

# Fix vmci/vsock failing
if grep -q '$vsock_alias' /etc/init.d/vmware; then
  sed -e 's/mod=$(vmwareRealModName $vmci $vmci_alias)/mod=vmci/' \
      -e 's/mod=$(vmwareRealModName $vsock $vsock_alias)/mod=vsock/' \
      -i /etc/init.d/vmware
fi

# Symlink version.h, if necessary (# 1) We don't have one already (accept files too))
if [ ! -f /usr/src/linux-$(uname -r)/include/linux/version.h ]; then
  # 2) Installed Workstation/Player less than 9.0.2/5.0.2
  if [[ $ver != [59].0.2 ]] && [[ $ver != 6.* ]] && [[ $ver != 10.* ]]; then
    # 3) Kernel version 3.5 or above
    if [ $(echo $kernel | tr -d .) -ge 35 ]; then
      msg "Symlinking version.h for $(uname -r)"
      install -d "$pkgdir"/usr/src/linux-$(uname -r)/include/linux/
      ln -s /usr/src/linux-$(uname -r)/include/generated/uapi/linux/version.h \
            "$pkgdir"/usr/src/linux-$(uname -r)/include/linux/
    fi
  fi
fi

# Remove leftover header locations
if [[ $(find /usr/src/ -mindepth 1 -maxdepth 2 -type d) ]]; then
  for i in /usr/src/*; do
    if [[ $(ls $i) = 'include' ]]; then
      msg_yellow "Removing leftover header location $i/"
      rm -r $i
    fi
  done
fi

# Remove leftover module locations
for i in /usr/lib/modules/*; do
  if [[ $(ls $i) = 'misc' ]]; then
    msg_yellow "Removing leftover module location $i/"
    rm -r $i
  fi
done

# Backup/Convert/Remove old backups, whatever necessary
cd /usr/lib/vmware/modules/
# 1) Use double quotes ("[[") and "ls" instead of the builtin -d/-f for multiple arguments
# 2) 2>&-: supported by "ls", basically same as "2>/dev/null" only shorter (ignore errors (STDERR))
if ls -d source?*/ source/*.tar-* |& grep -qvx source-$ver/; then
  msg "Cleaning up old backups.."
  # 1) Check the new location first
  # 2) Remove any duplicated/old ones
  # 3) Print full paths
  # 4) Sed: leave out the first result containing $ver
  for i in $(readlink -e source?*/ | sed "0,/$ver/{//d}"); do
    msg2 "Removing $i"
    rm -r "$i"
  done
  # If we already have a backup in the new location, remove any from the old one
  if [ -d source-$ver*/ ]; then
    for i in $(readlink -e source/*.tar-*); do
      msg2 "Removing $i"
      rm -r "$i"
    done
    # Rename it as we like (or as I do)
    if [ -d source-$ver?*/ ]; then
      msg3 "Renaming: $(readlink -f source-$ver*)/ -> $(readlink -f source-$ver)/"
      mv source-$ver*/ source-$ver/
    fi
  else
    # Remove any duplicated/old backups
    for i in vmblock vmci vmmon vmnet vsock; do
      for j in $(readlink -e source/$i.tar-* | sed "0,/$ver/{//d}"); do
        msg2 "Removing $j"
        rm -r "$j"
      done
    done
    # Convert leftovers
    if [ -f source/vmblock.tar-* ]; then
      msg3 "Converting: /usr/lib/vmware/modules/source/*.tar -> $(readlink -f source-$ver)/"
      mkdir source-$ver/
      for i in vmblock vmci vmmon vmnet vsock; do
        mv source/$i.tar-* source-$ver/$i.tar
      done
    fi
  fi
fi

# Support the '-f' flag
# 1) Have we already built (vsock is built last)?
# 2) Don't check this until we've removed the leftovers
if [ -f /usr/lib/modules/$(uname -r)/misc/vsock.ko ]; then
  # Offer the ability reinstall this thing
  if [[ "$@" = '-f' ]]; then
    msg "Reinstalling modules.."
  elif [[ ! "$@" ]]; then
    error "VMware modules already installed (use -f to override). Exiting.."
    exit 1
  fi
fi

# Patch
# 1) Make sure we can build
# 2) Shorther without double brackets ("[["):
# 3) &>/dev/null: hide all output (STDIN/STDERR)
if ls patches/*$ver*$kernel*.patch &>/dev/null; then
  # Create a backup/Revert
  if [ ! -d source-$ver ]; then
    msg "Creating a backup.."
    cp -r source/ source-$ver/
  else  # Get the original sources from the backup (invalidate the need for 'vmware-unpatch')
    cp source-$ver/* source/
  fi
  # Loop modules that require patching (vmblock, vmci, vmmon, vmnet and/or vsock)
  msg "Patching $name v$ver for kernel $(uname -r).."
  cd source
  # Prevent duplicate entries with 'sort -u'
  for mod in $(ls ../patches/v*$ver*$kernel*.patch 2>&- | grep -Po "s/\K[^-]*" | sort -u); do
    # Untar
    tar -xf $mod.tar
    # Patch
    msg2 "[$mod]"
    # Loop through all patches
    for i in ../patches/$mod*$ver*$kernel*.patch; do
      if ! patch -p0 -s -f -i $i; then
        error "Failed to apply '$(basename $i)'"
        read_msg2 "Continue? (Y/n) "
        if [[ "$REPLY" != [Yy] ]]; then
          # Revert
          msg "Reverting.."
          cd ..
          rm -r source/
          mv source-$ver/ source/
          msg "Done."
          exit 1
        fi
      fi
    done
    # Tar patched modules
    tar -cf $mod.tar $mod-only
    # Leftovers
    rm -r $mod-only
  done
else
  msg "No patching required."
fi

# Install
msg "Installing modules.."
vmware-modconfig --console --install-all &>/dev/null
msg "Done."
