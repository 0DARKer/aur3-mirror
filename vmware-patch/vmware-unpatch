#!/bin/bash -e

# Some colored makepkg-like functions
msg() {
    printf "${green}==>${all_off}${bold} $1${all_off}\n"
}

msg_yellow() {
    printf "${yellow}==>${all_off}${bold} $1${all_off}\n"
}

msg2() {
    printf "${blue}  ->${all_off}${bold} $1${all_off}\n"
}

msg3() {
    printf "${yellow}    ->${all_off}${bold} $1${all_off}\n"
}

error() {
    printf "${red}==> error:${all_off}${bold} $1${all_off}\n"
}

# Variables for them
all_off="$(tput sgr0)"
bold="$(tput bold)"
blue="${bold}$(tput setaf 4)"
green="${bold}$(tput setaf 2)"
red="${bold}$(tput setaf 1)"
yellow="${bold}$(tput setaf 3)"

# Help message
usage() {
    echo "Usage: $(basename $0) [-v/-V|-h]"
    echo "Revert the VMware modules sources."
    echo
    echo "Available options:"
    echo "  -v, -V, --version   Print version information"
    echo "  -h, --help          Print this help"
}

# Version information
version() {
    echo "$(basename $0) $(pacman -Q vmware-patch | cut -d ' ' -f2)"
    echo "Copyright (c) 2013-2014  Nobody"
    echo
    echo "THIS SCRIPT IS PROVIDED AS-IS FOR ANY PURPOSE WHATSOEVER. YOU ARE FREE TO SHARE IT, MODIFY IT,"
    echo "TAKE CREDIT OF IT, AND SELL IT ON THE STREETS."
    echo
    echo "FIGHT THE POWER."
}

# Flags
while [[ "$1" ]]; do
    # Define actions
    case "$1" in
        -v | -V | --version)   version; exit 0 ;;
        -h | --help)           usage; exit 0 ;;
        -*)                    echo "$(basename $0): error: bad argument: $1"
                               echo
                               usage $1; exit 0 ;;
        *) break ;;
    esac
    shift
done

# Make sure we are root
if (( $EUID != 0 )); then
    error "This script needs to be run as root."
    exit 1
fi

# Is a VMware product installed?
if [[ ! -f /usr/bin/vmware-installer ]]; then
    error "No VMware product found. Exiting.."
    exit 1
fi

# Set some variables (|&: hide errors by redirecting all output)
ver=$(vmware-installer -l |& grep -Po "(player|workstation) *\K(\d+\.){2}\d+")
if vmware-installer -l |& grep -q "workstation"; then
    name="VMware Workstation"
else
    name="VMware Player (Plus)"
fi

# Remove leftover module locations
for i in /usr/lib/modules/*; do
    if [[ $(ls "$i") = 'misc' ]]; then
        misc+=("$i")
    fi
done
if [[ "$misc" ]]; then
    msg_yellow "Removing leftover module location.."
    for i in ${misc[@]}; do
        msg2 "$i/"
        rm -r "$i"
    done
fi

# Remove old backups
cd /usr/lib/vmware/modules/
# Use "ls" instead of the builtin -d for multiple arguments
if ls -d source-*.*/ 2>/dev/null | grep -qv "$ver/"; then
    msg_yellow "Cleaning up old backups.."
    # Print full paths
    for i in $(readlink -f source-*.*/ | grep -v "$ver"); do
        msg2 "$i/"
        rm -r "$i"
    done
fi

# Revert
cd /usr/lib/vmware/modules/
if [[ -d "source-$ver" ]]; then
    msg "Reverting $name v$ver module sources.."
    msg2 "Removing $(readlink -f source)/"
    rm -r source/

    msg2 "Renaming backup: $(readlink -f source-$ver)/ -> $(readlink -f source)/"
    mv "source-$ver/" source/

    msg3 "Done."
else  # Nothing found
    error "No backups found."
    exit
fi
