--- a/Makefile	2011-10-22 18:56:55.000000000 +0200
+++ b/Makefile	2013-02-04 17:31:24.996616972 +0100
@@ -16,7 +16,7 @@
 ifneq ($(KERNELRELEASE),)
 
   LINUXVER_GOODFOR_CFG80211:=$(strip $(shell \
-    if [ "$(VERSION)" -ge "2" -a "$(PATCHLEVEL)" -ge "6" -a "$(SUBLEVEL)" -ge "32" ]; then \
+    if [ "$(VERSION)" -ge "3" -o "$(VERSION)" -ge "2" -a "$(PATCHLEVEL)" -ge "6" -a "$(SUBLEVEL)" -ge "32" ]; then \
       echo TRUE; \
     else \
       echo FALSE; \
@@ -24,7 +24,7 @@
   ))
 
     LINUXVER_WEXT_ONLY:=$(strip $(shell \
-    if [ "$(VERSION)" -ge "2" -a "$(PATCHLEVEL)" -ge "6" -a "$(SUBLEVEL)" -ge "17" ]; then \
+    if [ "$(VERSION)" -ge "3" -o "$(VERSION)" -ge "2" -a "$(PATCHLEVEL)" -ge "6" -a "$(SUBLEVEL)" -ge "17" ]; then \
       echo FALSE; \
     else \
       echo TRUE; \
--- a/src/wl/sys/wl_cfg80211.c	2011-10-22 18:56:55.000000000 +0200
+++ b/src/wl/sys/wl_cfg80211.c	2013-02-04 17:32:39.476617120 +0100
@@ -42,8 +42,12 @@
            enum nl80211_iftype type, u32 *flags, struct vif_params *params);
 static s32 __wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
            struct cfg80211_scan_request *request, struct cfg80211_ssid *this_ssid);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+static s32 wl_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request);
+#else
 static s32 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
            struct cfg80211_scan_request *request);
+#endif
 static s32 wl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
 static s32 wl_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,
            struct cfg80211_ibss_params *params);
@@ -570,10 +574,18 @@
 }
 
 static s32
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+wl_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
+#else
 wl_cfg80211_scan(struct wiphy *wiphy, struct net_device *ndev,
                  struct cfg80211_scan_request *request)
+#endif
 {
 	s32 err = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+    struct wl_priv *wl = wiphy_to_wl(wiphy);
+    struct net_device *ndev = wl_to_ndev(wl);
+#endif
 
 	CHECK_SYS_UP();
 	err = __wl_cfg80211_scan(wiphy, ndev, request, NULL);
@@ -1466,7 +1478,10 @@
 		scb_val.val = 0;
 		err = wl_dev_ioctl(dev, WLC_GET_RSSI, &scb_val, sizeof(scb_val_t));
 		if (err) {
-			WL_ERR(("Could not get rssi (%d)\n", err));
+			if (err != -EINVAL) {
+				// Don't fill syslog with EINVAL error
+				WL_ERR(("Could not get rssi (%d)\n", err));
+			}
 			return err;
 		}
 		rssi = dtoh32(scb_val.val);
@@ -1811,7 +1826,7 @@
 	notif_bss_info->frame_len = offsetof(struct ieee80211_mgmt, u.beacon.variable) +
 	                            wl_get_ielen(wl);
 	freq = ieee80211_channel_to_frequency(notif_bss_info->channel 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 39)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 		,(notif_bss_info->channel <= CH_MAX_2G_CHANNEL) ? IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ
 #endif
 	);
--- a/src/wl/sys/wl_iw.h	2011-10-22 18:56:55.000000000 +0200
+++ b/src/wl/sys/wl_iw.h	2013-02-04 17:30:12.546616826 +0100
@@ -16,6 +16,7 @@
 #define _wl_iw_h_
 
 #include <linux/wireless.h>
+#include <linux/semaphore.h>
 
 #include <typedefs.h>
 #include <proto/ethernet.h>
--- a/src/wl/sys/wl_linux.c	2013-02-04 17:34:11.499950638 +0100
+++ b/src/wl/sys/wl_linux.c	2013-02-04 17:32:39.476617120 +0100
@@ -40,7 +40,9 @@
 #include <linux/pci_ids.h>
 #define WLC_MAXBSSCFG		1	
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 4, 0)
 #include <asm/system.h>
+#endif
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/pgtable.h>
@@ -387,7 +389,11 @@
 #endif
 	.ndo_get_stats = wl_get_stats,
 	.ndo_set_mac_address = wl_set_mac_address,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_rx_mode = wl_set_multicast_list,
+#else
 	.ndo_set_multicast_list = wl_set_multicast_list,
+#endif
 	.ndo_do_ioctl = wl_ioctl
 };
 
@@ -1581,11 +1587,7 @@
 	}
 
 	WL_LOCK(wl);
-	if (!capable(CAP_NET_ADMIN)) {
-		bcmerror = BCME_EPERM;
-	} else {
-		bcmerror = wlc_ioctl(wl->wlc, ioc.cmd, buf, ioc.len, wlif->wlcif);
-	}
+	bcmerror = wlc_ioctl(wl->wlc, ioc.cmd, buf, ioc.len, wlif->wlcif);
 	WL_UNLOCK(wl);
 
 done1:
