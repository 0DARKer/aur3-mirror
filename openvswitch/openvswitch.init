#!/bin/bash

. /etc/rc.conf
. /etc/rc.d/functions

OVS_DB_PID_FILE=/var/run/openvswitch/ovsdb-server.pid
OVS_VS_PID_FILE=/var/run/openvswitch/ovs-vswitchd.pid
OVS_BC_PID_FILE=/var/run/openvswitch/ovs-brcompatd.pid

handle_modules() {
    local i kernversion kver loaded=0 moderr action modules

    # This function checks which openvswitch modules should be used on
    # your system. It is necessary to do this check because openvswitch
    # only became a part of the mainline Linux kernel in kernel version
    # 3.3. Before kernel 3.3 it was required to build modules manually
    # or semi-automatically with dkms. Those modules were then called
    # 'openvswitch_mod' and 'brcompat_mod'.
    #     With kernel 3.3 the name of supplied openvswitch module
    # changed to 'openvswitch'. However, the brcompat module is not
    # included in the mainline kernel nor will it ever be. [1]
    #
    # This means there are a number of options for any system:
    # 1) It runs kernel >= 3.3 and the in-kernel openvswitch module;
    # 2) It runs kernel >= 3.3 and aside from the in-kernel openvswitch module
    #    it also has a separately built openvswitch module, built by dkms or
    #    from git, and henceforth maybe also the brcompat module exists for
    #    this kernel;
    # 3) It runs kernel < 3.3 and already has the openvswitch_mod and
    #     brcompat_mod modules built by the openvswitch(-git) dkms routine;
    # 4) it has kernel < 3.3 but no modules yet;
    # 5) any other option.

    # How to check which is currently the case? First thing is to get the
    # version of the current kernel from /proc/version and, from the second
    # word, only keep the part before the hyphen. This would result in
    # something like "3.3.3", "2.6.12" etc.
    kernversion=($(</proc/version))
    kver=${kernversion[2]%%-*}

    # First check if we already have loaded a module. The fastest way to check
    # probably is by doing some bitmasking:
    # 1 - openvswitch_mod
    # 2 - brcompat_mod
    # 4 - openvswitch
    # 8 - brcompat
    for i in $(awk '{ if ($1 == "openvswitch_mod") print "1"; \
                      if ($1 == "brcompat_mod") print "2"; \
                      if ($1 == "openvswitch") print "4"; \
                      if ($1 == "brcompat") print "8"; }' /proc/modules); do
        (( loaded += i ))
    done; unset i

    # Maybe we can do something with the value in $loaded depending on $1
    # Value  Means
    #   0    Nothing is loaded, try to load both, this is where we use $kver;
    #   1    Only openvswitch_mod is loaded - try to load brcompat_mod or set moderr=2;
    #   2    Only brcompat_mod is loaded - this should never happen - return 254.
    #   3    openvswitch_mod and brcompat_mod are already loaded, return 0;
    #   4    Only openvswitch is loaded - try to load brcompat or set moderr=8;
    #   8    Only brcompat is loaded - this should never happen - return 254.
    #  12    openvswitch and brcompat are both loaded, return 0.
    # other  Something odd is going on, return 255
    case $loaded in
        0)  # we need to both modules if action is load, else leave silently
            [[ $1 == "unload" ]] && return 0

            if [[ ${kver} == 2.4* ]] ; then

                # this is kernel 2.4: fail

                moderr=24

            elif [[ ${kver} == 2.6* ]] || \
              [[ ${kver:0:1} == "3" && ${kver:2:1} -le 2 ]] ; then

                # this is kernel 2.6 or =< 3.2

                if ! modprobe openvswitch_mod &>/dev/null; then
                    # could not load openvswitch_mod; bail
                    moderr=1
                elif ! modprobe brcompat_mod &>/dev/null; then
                    # could not load brcompat_mod; bail
                    moderr=2
                else
                    # if we didn't fail, we're done.
                    return 0
                fi

            elif [[ ${kver:0:1} == "3" && ${kver:2:1} -ge 3 ]]; then

                # This is kernel 3.3 or higher

                if ! modprobe openvswitch &>/dev/null; then
                    # could not load openvswitch; bail
                    moderr=4
                elif ! modprobe brcompat &>/dev/null; then
                    # could not load brcompat; bail
                    moderr=8
                else
                    # if we didn't fail, we're done.
                    return 0
                fi
            else
                moderr=255
            fi

              ;;


        1)    if [[ $1 == "load" ]]; then
                  if modprobe brcompat_mod &>/dev/null; then
                      return 0
                  else
                      moderr=2
                  fi
              elif [[ $1 == "unload" ]] ;then
                  if rmmod openvswitch_mod &>/dev/null; then
                      return 0
                  else
                      moderr=1
                  fi
              fi
              ;;

        4)    if [[ $1 == "load" ]]; then
                  if modprobe brcompat &>/dev/null; then
                      return 0
                  else
                      moderr=8
                  fi
              elif [[ $1 == "unload" ]]; then
                  if rmmod openvswitch &>/dev/null; then
                      return 0
                  else
                      moderr=4
                  fi
              fi
              ;;

        3|12) if [[ $1 == "load" ]]; then
                  return 0
              elif [[ $1 == "unload" && $loaded == 3 ]]; then
                  if ! rmmod brcompat_mod &>/dev/null; then
                      moderr=2
                  elif ! rmmod openvswitch_mod &>/dev/null; then
                      moderr=1
                  else
                      return 0
                  fi
              elif [[ $1 == "unload" && $loaded == 12 ]]; then
                  if ! rmmod brcompat &>/dev/null; then
                      moderr=8
                  elif ! rmmod openvswitch &>/dev/null; then
                      moderr=4
                  else
                      return 0
                  fi
              fi
              ;;

        2|8)  moderr=254 ;;
        *)    moderr=255 ;;
    esac

    # If we're still here something has gone wrong. Let's parse $moderr
    case $moderr in
        1) stat_append " ERROR: could not $1 openvswitch_mod" ;;
        2) stat_append " ERROR: could not $1 brcompat_mod" ;;
        4) stat_append " ERROR: could not $1 openvswitch" ;;
        8) stat_append " ERROR: could not $1 brcompat" ;;
       24) stat_append ' ERROR: kernel 2.4 is not supported' ;;
      254) stat_append ' ERROR: brcompat_mod or brcompat is already loaded but openvswitch is not, this should never happen' ;;
      255) stat_append ' ERROR: loader returned some strange value so something weird is happening' ;;
        *) stat_append ' ERROR: unknown error_fu' ;;
    esac
    stat_append ' - bailing!'
    stat_die
}

case "$1" in
  start)
    stat_busy "Loading openvswitch kernel modules"
    handle_modules load
    stat_done

    [[ ! -d /var/run/openvswitch ]] && mkdir /var/run/openvswitch

    stat_busy "Starting OpenVSwitch DB server"
    /usr/sbin/ovsdb-server /etc/openvswitch/ovs-vswitchd.conf.db \
      --remote=punix:/var/run/openvswitch/db.sock \
      --remote=db:Open_vSwitch,manager_options \
      --private-key=db:SSL,private_key \
      --certificate=db:SSL,certificate \
      --bootstrap-ca-cert=db:SSL,ca_cert \
      --pidfile=${OVS_DB_PID_FILE} \
      --detach
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi

    stat_busy "Starting openvswitch daemon"
    /usr/sbin/ovs-vswitchd unix:/var/run/openvswitch/db.sock \
      --pidfile=${OVS_VS_PID_FILE} \
      --detach \
      --monitor
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi

    stat_busy "Starting openvswitch bridge compatibility"
    ovs-brcompatd --pidfile=${OVS_BC_PID_FILE} --detach
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi

    chgrp ovs /var/run/openvswitch/*
    chmod g+rw /var/run/openvswitch/*

    add_daemon openvswitch
    ;;
  stop)
    stat_busy "Stopping openvswitch bridge compatibility"
    kill $(< ${OVS_BC_PID_FILE}) &> /dev/null
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi
    rm ${OVS_BC_PID_FILE} &> /dev/null

    stat_busy "Stopping openvswitch daemon"
    kill $(< ${OVS_VS_PID_FILE}) &> /dev/null
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi
    rm ${OVS_VS_PID_FILE} &> /dev/null

    stat_busy "Stopping openvswitch DB server"
    kill $(< ${OVS_DB_PID_FILE}) &> /dev/null
    if [ $? -gt 0 ]; then
      stat_fail
    else
      stat_done
    fi
    rm_daemon openvswitch

    stat_busy "Unloading openvswitch kernel modules"
    handle_modules unload
    stat_done
    ;;
  restart)
    $0 stop
    sleep 1
    $0 start
    ;;
    *)
    echo "usage: $0 {start|stop|restart}"
esac
exit 0

