# Group of fixes from upstream that address several issues with the released
# version of mapiproxy, ocsmanager, and rpcproxy
# Fixes included from https://github.com/openchange/openchange/commits/master?
# d51f28d5c3, 78ba0a13b4, aeb78edeea, 9c3c8e6a3c, cf7ebb9999, 88848dee74,
# 3975b0bde4, 236654d7f0, b95e0e5227, 84ea1f4acb, d70878f0f2, ec0cd204bd,
# 1a78475cca, 8c17475e83, a2861b6d4d, 32302ab3e1, 0ff15cf1b1, 177c96ff85,
# 319fe48575, d93bb075cc, 1b7387b375, a9bd1dccbe, f478ed239e, 8449c10639,
# 4429f95091, 727dec7361, 006fb052b1

diff -Naurp openchange-2.0-QUADRANT-orig/libmapi/freebusy.c openchange-2.0-QUADRANT/libmapi/freebusy.c
--- openchange-2.0-QUADRANT-orig/libmapi/freebusy.c	2013-12-10 00:48:11.587398180 -0600
+++ openchange-2.0-QUADRANT/libmapi/freebusy.c	2013-12-10 18:48:27.252928242 -0600
@@ -207,7 +207,7 @@ _PUBLIC_ enum MAPISTATUS GetUserFreeBusy
 	OPENCHANGE_RETVAL_IF(!mid || *mid == MAPI_E_NOT_FOUND, MAPI_E_NOT_FOUND, NULL);
 
 	mapi_object_init(&obj_message);
-	retval = OpenMessage(obj_store, *fid, *mid, &obj_message, 0x0);
+	retval = OpenMessage(&obj_exfreebusy, *fid, *mid, &obj_message, 0x0);
 	OPENCHANGE_RETVAL_IF(retval, retval, NULL);
 
 	/* Step 11. Get FreeBusy properties */
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore.h openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore.h
--- openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore.h	2013-12-10 00:48:11.570731604 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore.h	2013-12-10 18:23:18.941099469 -0600
@@ -194,7 +194,7 @@ struct mapistore_backend {
 		enum mapistore_error	(*get_message_data)(void *, TALLOC_CTX *, struct mapistore_message **);
 		enum mapistore_error	(*modify_recipients)(void *, struct SPropTagArray *, uint16_t, struct mapistore_message_recipient *);
                 enum mapistore_error	(*set_read_flag)(void *, uint8_t);
-		enum mapistore_error	(*save)(void *);
+		enum mapistore_error	(*save)(void *, TALLOC_CTX *);
 		enum mapistore_error	(*submit)(void *, enum SubmitFlags);
                 enum mapistore_error	(*open_attachment)(void *, TALLOC_CTX *, uint32_t, void **);
                 enum mapistore_error	(*create_attachment)(void *, TALLOC_CTX *, void **, uint32_t *);
@@ -328,7 +328,7 @@ enum mapistore_error mapistore_folder_fe
 enum mapistore_error mapistore_message_get_message_data(struct mapistore_context *, uint32_t, void *, TALLOC_CTX *, struct mapistore_message **);
 enum mapistore_error mapistore_message_modify_recipients(struct mapistore_context *, uint32_t, void *, struct SPropTagArray *, uint16_t, struct mapistore_message_recipient *);
 enum mapistore_error mapistore_message_set_read_flag(struct mapistore_context *, uint32_t, void *, uint8_t);
-enum mapistore_error mapistore_message_save(struct mapistore_context *, uint32_t, void *);
+enum mapistore_error mapistore_message_save(struct mapistore_context *, uint32_t, void *, TALLOC_CTX *);
 enum mapistore_error mapistore_message_submit(struct mapistore_context *, uint32_t, void *, enum SubmitFlags);
 enum mapistore_error mapistore_message_open_attachment(struct mapistore_context *, uint32_t, void *, TALLOC_CTX *, uint32_t, void **);
 enum mapistore_error mapistore_message_create_attachment(struct mapistore_context *, uint32_t, void *, TALLOC_CTX *, void **, uint32_t *);
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_backend.c openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_backend.c
--- openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_backend.c	2013-12-10 00:48:11.570731604 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_backend.c	2013-12-10 18:24:23.754081680 -0600
@@ -663,9 +663,9 @@ enum mapistore_error mapistore_backend_m
 	return bctx->backend->message.set_read_flag(message, flag);
 }
 
-enum mapistore_error mapistore_backend_message_save(struct backend_context *bctx, void *message)
+enum mapistore_error mapistore_backend_message_save(struct backend_context *bctx, void *message, TALLOC_CTX *mem_ctx)
 {
-	return bctx->backend->message.save(message);
+	return bctx->backend->message.save(message, mem_ctx);
 }
 
 enum mapistore_error mapistore_backend_message_submit(struct backend_context *bctx, void *message, enum SubmitFlags flags)
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_interface.c openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_interface.c
--- openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_interface.c	2013-12-10 00:48:11.570731604 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_interface.c	2013-12-10 18:25:38.173678515 -0600
@@ -1474,7 +1474,7 @@ _PUBLIC_ enum mapistore_error mapistore_
 
    \return MAPISTORE_SUCCESS on success, otherwise MAPISTORE errors
  */
-_PUBLIC_ enum mapistore_error mapistore_message_save(struct mapistore_context *mstore_ctx, uint32_t context_id, void *message)
+_PUBLIC_ enum mapistore_error mapistore_message_save(struct mapistore_context *mstore_ctx, uint32_t context_id, void *message, TALLOC_CTX *mem_ctx)
 {
 	struct backend_context	*backend_ctx;
 
@@ -1486,7 +1486,7 @@ _PUBLIC_ enum mapistore_error mapistore_
 	MAPISTORE_RETVAL_IF(!backend_ctx, MAPISTORE_ERR_INVALID_PARAMETER, NULL);
 
 	/* Step 2. Call backend savechangesmessage */
-	return mapistore_backend_message_save(backend_ctx, message);
+	return mapistore_backend_message_save(backend_ctx, message, mem_ctx);
 }
 
 
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_private.h openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_private.h
--- openchange-2.0-QUADRANT-orig/mapiproxy/libmapistore/mapistore_private.h	2013-12-10 00:48:11.570731604 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/libmapistore/mapistore_private.h	2013-12-10 18:26:25.050091230 -0600
@@ -180,7 +180,7 @@ enum mapistore_error mapistore_backend_f
 enum mapistore_error mapistore_backend_message_get_message_data(struct backend_context *, void *, TALLOC_CTX *, struct mapistore_message **);
 enum mapistore_error mapistore_backend_message_modify_recipients(struct backend_context *, void *, struct SPropTagArray *, uint16_t, struct mapistore_message_recipient *);
 enum mapistore_error mapistore_backend_message_set_read_flag(struct backend_context *, void *, uint8_t);
-enum mapistore_error mapistore_backend_message_save(struct backend_context *, void *);
+enum mapistore_error mapistore_backend_message_save(struct backend_context *, void *, TALLOC_CTX *);
 enum mapistore_error mapistore_backend_message_submit(struct backend_context *, void *, enum SubmitFlags);
 enum mapistore_error mapistore_backend_message_get_attachment_table(struct backend_context *, void *, TALLOC_CTX *, void **, uint32_t *);
 enum mapistore_error mapistore_backend_message_open_attachment(struct backend_context *, void *, TALLOC_CTX *, uint32_t, void **);
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/emsmdbp_provisioning.c openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/emsmdbp_provisioning.c
--- openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/emsmdbp_provisioning.c	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/emsmdbp_provisioning.c	2013-12-10 18:31:15.941848667 -0600
@@ -635,7 +635,7 @@ FolderId: 0x67ca828f02000001      Displa
 			property_row.lpProps[2].ulPropTag = PidTagNormalizedSubject;
 			property_row.lpProps[2].value.lpszW = "LocalFreebusy";
 			mapistore_properties_set_properties(emsmdbp_ctx->mstore_ctx, context_id, backend_message, &property_row);
-			mapistore_message_save(emsmdbp_ctx->mstore_ctx, context_id, backend_message);
+			mapistore_message_save(emsmdbp_ctx->mstore_ctx, context_id, backend_message, mem_ctx);
 		}
 	
 		mapistore_del_context(emsmdbp_ctx->mstore_ctx, context_id);
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/oxcmsg.c openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/oxcmsg.c
--- openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/oxcmsg.c	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/oxcmsg.c	2013-12-10 18:32:14.798196482 -0600
@@ -605,7 +605,7 @@ _PUBLIC_ enum MAPISTATUS EcDoRpc_RopSave
 	case true:
                 contextID = emsmdbp_get_contextID(object);
 		messageID = object->object.message->messageID;
-		ret = mapistore_message_save(emsmdbp_ctx->mstore_ctx, contextID, object->backend_object);
+		ret = mapistore_message_save(emsmdbp_ctx->mstore_ctx, contextID, object->backend_object, mem_ctx);
 		if (ret == MAPISTORE_ERR_DENIED) {
 			mapi_repl->error_code = MAPI_E_NO_ACCESS;
 			goto end;
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/oxomsg.c openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/oxomsg.c
--- openchange-2.0-QUADRANT-orig/mapiproxy/servers/default/emsmdb/oxomsg.c	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/servers/default/emsmdb/oxomsg.c	2013-12-10 18:35:48.417039209 -0600
@@ -121,7 +121,7 @@ static void oxomsg_mapistore_handle_mess
 		/* FIXME: (from oxomsg 3.2.5.1) PidTagMessageFlags: mfUnsent and mfRead must be cleared */
 		emsmdbp_object_copy_properties(emsmdbp_ctx, old_message_object, message_object, &excluded_tags, true);
 
-		mapistore_message_save(emsmdbp_ctx->mstore_ctx, contextID, message_object->backend_object);
+		mapistore_message_save(emsmdbp_ctx->mstore_ctx, contextID, message_object->backend_object, mem_ctx);
 		mapistore_indexing_record_add_mid(emsmdbp_ctx->mstore_ctx, contextID, owner, messageID);
 	}
 
@@ -494,10 +494,11 @@ _PUBLIC_ enum MAPISTATUS EcDoRpc_RopOpti
 	mapi_repl->handle_idx = mapi_req->handle_idx;
 	mapi_repl->error_code = retval;
 	mapi_repl->u.mapi_OptionsData.Reserved = 0x01; /* always 1, as specified in the doc */
-	mapi_repl->u.mapi_OptionsData.OptionsInfo.cb = 0x0000;
-	mapi_repl->u.mapi_OptionsData.OptionsInfo.lpb = talloc_array(mem_ctx, uint8_t, mapi_repl->u.mapi_OptionsData.OptionsInfo.cb);
+	mapi_repl->u.mapi_OptionsData.OptionsInfo.cb = 0x0121; /* Outlook expects a 300 bytes response, full of 0s */
+	mapi_repl->u.mapi_OptionsData.OptionsInfo.lpb = talloc_zero_array(mem_ctx, uint8_t, mapi_repl->u.mapi_OptionsData.OptionsInfo.cb);
+
 	mapi_repl->u.mapi_OptionsData.HelpFileSize = 0x0000;
-	mapi_repl->u.mapi_OptionsData.HelpFile = talloc_array(mem_ctx, uint8_t, mapi_repl->u.mapi_OptionsData.HelpFileSize);
+	mapi_repl->u.mapi_OptionsData.HelpFile = talloc_zero_array(mem_ctx, uint8_t, mapi_repl->u.mapi_OptionsData.HelpFileSize);
 
 	*size += libmapiserver_RopOptionsData_size(mapi_repl);
 
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/README.txt openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/README.txt
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/README.txt	2013-12-10 00:48:11.580731549 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/README.txt	2013-12-10 18:21:10.678460994 -0600
@@ -1,19 +1,92 @@
-This file is for you to describe the ocsmanager application. Typically
-you would include information such as the information below:
+= Installation and Setup =
 
-Installation and Setup
-======================
-
-Install ``ocsmanager`` using easy_install::
+ 1. Install ``ocsmanager`` using easy_install::
 
     easy_install ocsmanager
 
-Make a config file as follows::
+ 2. Tweak the configuration file (ocsmanager.ini) or use development.ini for testing purposes
 
-    paster make-config ocsmanager config.ini
+ 3. paster server inifile
 
-Tweak the config file as appropriate and then setup the application::
+= Testing with curl =
 
-    paster setup-app config.ini
+To use services available via ocsmanager, the http client must use NTLM auth.
+See http://www.innovation.ch/personal/ronald/ntlm.html
 
-Then you are ready to go.
+As ntlm authenticates 'connections', it is very critical to use either HTTP/1.1
+or HTTP Keep-Alive when using this service.
+Since NTLMAuthHandler uses a cookie to store the client_id of the client,
+the HTTP client used to test the service should be able to handle those.
+
+To test the autodiscovery service with curl, the following command line can be used:
+
+  curl -u 'user:pass' -d @postdata.xml --ntlm -b '' http://127.0.0.1:5000/autodiscover/autodiscover.xml
+
+postdata.xml should contain a XML payload similar to this:
+
+<?xml version="1.0" encoding="utf-8"?>
+<Autodiscover xmlns="http://schemas.microsoft.com/exchange/autodiscover/outlook/requestschema/2006">
+  <Request>
+    <EMailAddress>sogo1@example.com</EMailAddress>
+    <AcceptableResponseSchema>http://schemas.microsoft.com/exchange/autodiscover/outlook/responseschema/2006a</AcceptableResponseSchema>
+  </Request>
+</Autodiscover>
+
+Replace the EMailAddress field with valid data
+
+
+To test the freebusy service:
+  curl -H 'Content-Type: text/xml; charset=utf-8' -u 'sogo1:sogo' -d @fb.xml --ntlm -b '' http://127.0.0.1:5000/ews/as
+
+  fb.xml:
+<?xml version="1.0"?>
+<q:Envelope xmlns:q="http://schemas.xmlsoap.org/soap/envelope/">
+  <q:Header>
+    <wsa:MessageID xmlns:wsa="http://www.w3.org/2005/08/addressing/">urn:uuid:7A3C8FB9-0AFE-4020-A362-172AD7B49B17</wsa:MessageID>
+  </q:Header>
+  <q:Body xmlns:wsa="http://www.w3.org/2005/08/addressing/">
+    <ex12m:GetUserAvailabilityRequest xmlns:ex12m="http://schemas.microsoft.com/exchange/services/2006/messages" xmlns:ex12t="http://schemas.microsoft.com/exchange/services/2006/types">
+      <ex12t:TimeZone>
+        <ex12t:Bias>300</ex12t:Bias>
+        <ex12t:StandardTime>
+          <ex12t:Bias>0</ex12t:Bias>
+          <ex12t:Time>02:00:00</ex12t:Time>
+          <ex12t:DayOrder>1</ex12t:DayOrder>
+          <ex12t:Month>11</ex12t:Month>
+          <ex12t:DayOfWeek>Sunday</ex12t:DayOfWeek>
+        </ex12t:StandardTime>
+        <ex12t:DaylightTime>
+          <ex12t:Bias>-60</ex12t:Bias>
+          <ex12t:Time>02:00:00</ex12t:Time>
+          <ex12t:DayOrder>2</ex12t:DayOrder>
+          <ex12t:Month>3</ex12t:Month>
+          <ex12t:DayOfWeek>Sunday</ex12t:DayOfWeek>
+        </ex12t:DaylightTime>
+      </ex12t:TimeZone>
+      <ex12m:MailboxDataArray>
+        <ex12t:MailboxData>
+          <ex12t:Email>
+            <ex12t:Address>sogo2@example.com</ex12t:Address>
+            <ex12t:RoutingType>SMTP</ex12t:RoutingType>
+          </ex12t:Email>
+          <ex12t:AttendeeType>Required</ex12t:AttendeeType>
+        </ex12t:MailboxData>
+        <ex12t:MailboxData>
+          <ex12t:Email>
+            <ex12t:Address>sogo3@example.com</ex12t:Address>
+            <ex12t:RoutingType>SMTP</ex12t:RoutingType>
+          </ex12t:Email>
+          <ex12t:AttendeeType>Required</ex12t:AttendeeType>
+        </ex12t:MailboxData>
+      </ex12m:MailboxDataArray>
+      <ex12t:FreeBusyViewOptions>
+        <ex12t:TimeWindow>
+          <ex12t:StartTime>2013-02-24T11:00:00</ex12t:StartTime>
+          <ex12t:EndTime>2013-03-26T11:00:00</ex12t:EndTime>
+        </ex12t:TimeWindow>
+        <ex12t:MergedFreeBusyIntervalInMinutes>30</ex12t:MergedFreeBusyIntervalInMinutes>
+        <ex12t:RequestedView>Detailed</ex12t:RequestedView>
+      </ex12t:FreeBusyViewOptions>
+    </ex12m:GetUserAvailabilityRequest>
+  </q:Body>
+</q:Envelope>
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/development.ini openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/development.ini
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/development.ini	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/development.ini	2013-12-10 18:18:34.835971932 -0600
@@ -10,22 +10,56 @@ debug = true
 smtp_server = localhost
 error_email_from = paste@localhost
 
+[main]
+# Possible authentication system
+# auth = file
+#auth = ldap
+auth = single
+debug = yes
+mapistore_root = /usr/local/samba/private
+mapistore_data = /usr/local/samba/private/mapistore
+
+[auth:file]
+#file =
+
+[auth:ldap]
+host = ldap://xxx
+port = 489
+bind_dn =
+bind_pw =
+basedn =
+#filter = (cn=%s)
+#attrs = userPassword, x-isActive
+
+[auth:single]
+username = openchange
+# password is test
+password = {SSHA}I6Hy5Wv0wuxyXvMBFWFQDVVN12_CLaX9
+
 [server:main]
 use = egg:Paste#http
 host = 127.0.0.1
 port = 5000
-
-[perso:test]
-app = clear
+protocol_version = HTTP/1.1
 
 [app:main]
 use = egg:ocsmanager
 full_stack = true
 static_files = true
-
 cache_dir = %(here)s/data
 beaker.session.key = ocsmanager
 beaker.session.secret = somesecret
+app_instance_uuid = {ee533ebc-f266-49d1-ae10-d017ee6aa98c}
+NTLMAUTHHANDLER_WORKDIR = /var/cache/ntlmauthhandler
+
+
+[rpcproxy:ldap]
+host = localhost
+port = 389
+basedn = CN=Users,DC=example,DC=com
+
+[perso:test]
+app = clear
 
 # If you'd like to fine-tune the individual locations of the cache data dirs
 # for the Cache data, or the Session saves, un-comment the desired settings
@@ -36,13 +70,19 @@ beaker.session.secret = somesecret
 # WARNING: *THE LINE BELOW MUST BE UNCOMMENTED ON A PRODUCTION ENVIRONMENT*
 # Debug mode will enable the interactive debugging tool, allowing ANYONE to
 # execute malicious code after an exception is raised.
-#set debug = false
+set debug = true
 
 # override OCSManager authentication scheme. Possible values for auth
 # are:
 #auth = ldap
 auth = config
 
+[auth:single]
+username = openchange
+# password is test
+password = {SSHA}I6Hy5Wv0wuxyXvMBFWFQDVVN12_CLaX9
+
+
 # Logging configuration
 [loggers]
 keys = root, routes, ocsmanager, rpclib
@@ -54,7 +94,7 @@ keys = console
 keys = generic
 
 [logger_root]
-level = INFO
+level = DEBUG
 handlers = console
 
 [logger_routes]
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/config/environment.py openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/config/environment.py
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/config/environment.py	2013-12-10 00:48:11.580731549 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/config/environment.py	2013-12-10 18:14:21.977341785 -0600
@@ -34,18 +34,14 @@ def _load_samba_environment():
     dnsdomain = params.get("realm")
     dnsdomain = dnsdomain.lower()
 
-    serverrole = params.get("server role")
-    if serverrole == "domain controller":
-        domaindn = "DC=" + dnsdomain.replace(".", ",DC=")
-    else:
-        domaindn = "CN=" + netbiosname
+    samdb_ldb = SamDB(url=params.samdb_url(), lp=params)
+    domaindn = samdb_ldb.domain_dn()
 
     rootdn = domaindn
     configdn = "CN=Configuration," + rootdn
     firstorg = FIRST_ORGANIZATION
     firstou = FIRST_ORGANIZATION_UNIT
 
-    samdb_ldb = SamDB(url=params.samdb_url(), lp=params)
     sam_environ = {"samdb_ldb": samdb_ldb,
                    "private_dir": params.get("private dir"),
                    "domaindn": domaindn,
@@ -112,7 +108,7 @@ def load_environment(global_conf, app_co
 
     # CONFIGURATION OPTIONS HERE (note: all config options will override
     # any Pylons config options)
-    ocsconfig = OCSConfig.OCSConfig(os.path.join(config.get('here'), 'ocsmanager.ini'))
+    ocsconfig = OCSConfig.OCSConfig(global_conf['__file__'])
     config['ocsmanager'] = ocsconfig.load()
 
     config['samba'] = _load_samba_environment()
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/config/middleware.py openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/config/middleware.py
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/config/middleware.py	2013-12-10 00:48:11.580731549 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/config/middleware.py	2013-12-10 18:11:40.138218543 -0600
@@ -68,7 +68,12 @@ def make_app(global_conf, full_stack=Tru
     auth_handler = NTLMAuthHandler(app)
 
     def ntlm_env_setter(environ, start_response):
-        environ["NTLMAUTHHANDLER_WORKDIR"] = app_conf["NTLMAUTHHANDLER_WORKDIR"]
+        for var in  ["SAMBA_HOST", "NTLMAUTHHANDLER_WORKDIR"]:
+            try:
+                 environ[var] = app_conf[var]
+            except KeyError:
+              # FIXME: logging?
+              pass
         return auth_handler(environ, start_response)
 
     # Establish the Registry for this application
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/controllers/autodiscover.py openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/controllers/autodiscover.py
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager/controllers/autodiscover.py	2013-12-10 00:48:11.580731549 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager/controllers/autodiscover.py	2013-12-10 18:12:52.191161532 -0600
@@ -5,6 +5,7 @@
 from cStringIO import StringIO
 from time import time, strftime, localtime
 import traceback
+import urllib
 import uuid
 from xml.etree.ElementTree import Element, ElementTree, tostring
 
@@ -53,6 +54,7 @@ class AutodiscoverHandler(object):
 
     def _parse_request(self, body):
         if body is not None and len(body) > 0:
+            body = urllib.unquote_plus(body)
             tree = ElementTree(file=StringIO(body))
             xrq = tree.find("{%s}Request" % REQUEST_XMLNS)
             if xrq is not None:
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager.ini openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager.ini
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/ocsmanager.ini	2013-12-10 00:48:11.580731549 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/ocsmanager.ini	2013-12-10 18:20:07.155471794 -0600
@@ -39,6 +39,7 @@ password = {SSHA}I6Hy5Wv0wuxyXvMBFWFQDVV
 use = egg:Paste#http
 host = 127.0.0.1
 port = 5000
+protocol_version = HTTP/1.1
 
 [app:main]
 use = egg:ocsmanager
@@ -49,6 +50,7 @@ beaker.session.key = ocsmanager
 beaker.session.secret = SDyKK3dKyDgW0mlpqttTMGU1f
 app_instance_uuid = {ee533ebc-f266-49d1-ae10-d017ee6aa98c}
 NTLMAUTHHANDLER_WORKDIR = /var/cache/ntlmauthhandler
+SAMBA_HOST = 127.0.0.1
 
 [rpcproxy:ldap]
 host = localhost
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/setup.cfg openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/setup.cfg
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/ocsmanager/setup.cfg	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/ocsmanager/setup.cfg	2013-12-10 18:15:05.500439333 -0600
@@ -8,7 +8,6 @@ find_links = http://www.pylonshq.com/dow
 [nosetests]
 with-pylons = test.ini
 
-# Babel configuration
 [compile_catalog]
 domain = ocsmanager
 directory = ocsmanager/i18n
@@ -29,3 +28,4 @@ domain = ocsmanager
 input_file = ocsmanager/i18n/ocsmanager.pot
 output_dir = ocsmanager/i18n
 previous = true
+
diff -Naurp openchange-2.0-QUADRANT-orig/mapiproxy/services/web/rpcproxy/rpcproxy.wsgi openchange-2.0-QUADRANT/mapiproxy/services/web/rpcproxy/rpcproxy.wsgi
--- openchange-2.0-QUADRANT-orig/mapiproxy/services/web/rpcproxy/rpcproxy.wsgi	2013-12-10 00:48:11.577398234 -0600
+++ openchange-2.0-QUADRANT/mapiproxy/services/web/rpcproxy/rpcproxy.wsgi	2013-12-10 18:39:43.352433122 -0600
@@ -22,14 +22,31 @@
 # this is the WSGI starting point for rpcproxy
 
 import logging
-import os
+import traceback
 
 from openchange.web.auth.NTLMAuthHandler import *
 from rpcproxy.RPCProxyApplication import *
 
+def application(environ, start_response):
 
-SAMBA_HOST = "127.0.0.1"
-LOG_LEVEL = logging.INFO
+  SAMBA_HOST = environ.get('SAMBA_HOST', "127.0.0.1")
+  RPCPROXY_LOGLEVEL = environ.get('RPCPROXY_LOGLEVEL', logging.INFO)
+  log_level = logging.getLevelName(RPCPROXY_LOGLEVEL)
 
-application = NTLMAuthHandler(RPCProxyApplication(samba_host=SAMBA_HOST,
-                                                  log_level=LOG_LEVEL))
+  # set a basic logger here for NTLMAuthHandler
+  logging.basicConfig(level=log_level)
+  log = logging.getLogger(__name__)
+
+  app = NTLMAuthHandler(RPCProxyApplication(samba_host=SAMBA_HOST,
+                                            log_level=log_level))
+
+  try:
+    return app(environ, start_response)
+  except Exception as e:
+    trace = traceback.format_exc()
+    log.critical("Uncaught exception: %s\n%s", e,trace)
+    status = "500 Internal Error"
+    response_headers = [("content-type", "text/plain"),
+                        ("content-length", str(len(status)))]
+    start_response(status, response_headers)
+    return status
diff -Naurp openchange-2.0-QUADRANT-orig/python/openchange/web/auth/NTLMAuthHandler.py openchange-2.0-QUADRANT/python/openchange/web/auth/NTLMAuthHandler.py
--- openchange-2.0-QUADRANT-orig/python/openchange/web/auth/NTLMAuthHandler.py	2013-12-10 00:48:11.587398180 -0600
+++ openchange-2.0-QUADRANT/python/openchange/web/auth/NTLMAuthHandler.py	2013-12-10 18:44:53.607418993 -0600
@@ -29,7 +29,8 @@ is untested.
 
 from fcntl import flock, LOCK_EX, LOCK_UN
 import httplib
-from os import _exit, getpid, getuid, fork, setsid, stat, umask, unlink, \
+import logging
+from os import _exit, chown, getpid, getuid, fork, setsid, stat, umask, unlink, \
     waitpid, close as close_fd
 from os.path import join, exists
 from select import poll, POLLIN, POLLHUP
@@ -37,6 +38,7 @@ from socket import socket, SHUT_RDWR, AF
     SOCK_STREAM, MSG_WAITALL, error as socket_error
 from struct import pack, unpack, unpack_from, error as struct_error
 import sys
+import traceback
 from time import sleep, time
 from uuid import uuid4
 
@@ -50,6 +52,7 @@ SAMBA_PORT = 1024
 # those are left unconfigurable, at least for now
 CLIENT_TIMEOUT = 60 * 5 # 5 minutes since last use
 ACTIVITY_TIMEOUT = CLIENT_TIMEOUT # 5 minutes since any socket has been used
+SAMBA_CONNECT_MAX_TRIES = 10 # ~10 seconds
 
 
 ## client-daemon protocol:
@@ -77,6 +80,7 @@ class _NTLMDaemon(object):
         self.owner_pair = owner_pair
         self.samba_host = samba_host
         self.client_data = {}
+        self.log = logging.getLogger(__name__)
 
     def run(self):
         if exists(self.socket_filename):
@@ -90,10 +94,12 @@ class _NTLMDaemon(object):
             waitpid(child_pid, 0)
 
             # we are the child
-            # print >> sys.stderr, "waiting for ntlm daemon to create socket (%d)" % getpid()
+            self.log.debug("waiting for ntlm daemon to create socket (%d)",
+                           getpid())
             while not exists(self.socket_filename):
+                sleep(0.5)
                 pass
-            # print >> sys.stderr, "socket of ntlm daemon now exists (%d)" % getpid()
+            self.log.debug("socket of ntlm daemon now exists (%d)", getpid())
         else:
             raise Exception("failure to fork NTLM daemon")
 
@@ -129,22 +135,29 @@ class _NTLMDaemon(object):
         del httplib
         del resource
 
-        # print >> sys.stderr, "cleanup done"
+        self.log.debug("cleanup done")
 
         child_pid = fork()
         if child_pid > 0:
             _exit(0)
 
-        print >> sys.stderr, ("NTLMAuthHandler daemon spawned with pid %d"
-                              % getpid())
-        
+        self.log.info("NTLMAuthHandler daemon spawned with pid %d", getpid())
+
         # forked processes inherits lock created by flock, so we need to
         # unlock the file here
         # flock(lockf.fileno(), LOCK_UN)
         # lockf.close()
 
         # we are the daemon
-        self._run_as_daemon()
+        # Catch all exceptions here and print them to stderr before exiting
+        # to avoid problems when running under paster
+        try:
+          self._run_as_daemon()
+        except Exception as e:
+          trace = traceback.format_exc()
+          self.log.critical("Uncaught exception: %s\n%s", e,trace)
+          self.log.critical("Exiting")
+          _exit(1)
 
     def _run_as_daemon(self):
         client_sockets = {}
@@ -191,8 +204,7 @@ class _NTLMDaemon(object):
                 if last_activity + 30.0 < now:
                     shutdown = True
                 elif last_cleanup + 60.0 < now:
-                    # print >> sys.stderr, ("cleaning up old client ids (%d)"
-                    #                       % getpid())
+                    self.log.debug("cleaning up old client ids (%d)", getpid())
                     self._cleanup_client_data(now - CLIENT_TIMEOUT)
                     last_cleanup = now
             else:
@@ -205,18 +217,17 @@ class _NTLMDaemon(object):
                         new_socket_fd = new_socket.fileno()
                         client_sockets[new_socket_fd] = new_socket
                         fd_pool.register(new_socket_fd, POLLIN)
-                        # print >> sys.stderr, ("registered new client socket"
-                        # " %d (%d)"
-                        # % (new_socket_fd, getpid()))
+                        self.log.debug("registered new client socket %d (%d)",
+                                       new_socket_fd, getpid())
                     elif filedesc in client_sockets:
-                        # print >> sys.stderr, ("handling event %d from client"
-                        # " socket %d" % (event_no, filedesc))
+                        self.log.debug("handling event %d from client socket %d",
+                                       event_no, filedesc)
                         client_socket = client_sockets[filedesc]
                         if (event_no & POLLHUP > 0
                             or not self._process_client_request(client_socket,
                                                                 now)):
-                            # print >> sys.stderr, ("removed client socket from"
-                            # " pool (%d)" % getpid())
+                            self.log.debug("removed client socket from pool (%d)",
+                                           getpid())
                             _safe_close(client_socket)
                             fd_pool.unregister(filedesc)
                             del client_sockets[filedesc]
@@ -231,14 +242,13 @@ class _NTLMDaemon(object):
         [_safe_close(client_socket)
          for client_socket in client_sockets.itervalues()]
         
-        print >> sys.stderr, ("NTLMAuthHandler daemon shutdown (%d)"
-                              % getpid())
+        self.log.info("NTLMAuthHandler daemon shutdown (%d)", getpid())
 
     def _cleanup_client_data(self, time_limit):
         def _cleanup_record(client_id):
             record = self.client_data[client_id]
             if "server" in record:
-                # print >> sys.stderr, "closing server socket"
+                self.log.debug("closing server socket")
                 server = record["server"]
                 _safe_close(server)
             del self.client_data[client_id]
@@ -255,12 +265,13 @@ class _NTLMDaemon(object):
         data = client_socket.recv(5, MSG_WAITALL)
         tag = data[0]
         len_client_id = unpack_from("<l", data, 1)[0]
-        # print >> sys.stderr, "len_client_id: %d" % len_client_id
-        # print >> sys.stderr, "type(len_client_id): %s" % type(len_client_id)
+        self.log.debug("len_client_id: %d", len_client_id)
+        self.log.debug("type(len_client_id): %s", type(len_client_id))
         if len_client_id > 0:
             client_id = client_socket.recv(len_client_id, MSG_WAITALL)
         else:
             client_id = ""
+        self.log.debug("client_id: %s", client_id)
 
         if tag == "k":
             if client_id in self.client_data:
@@ -285,10 +296,11 @@ class _NTLMDaemon(object):
             if response == 0:
                 # directly cleanup the client record, in order to reduce the
                 # amount of sockets in use
-                if "server" in self.client_data[client_id]:
-                    server = self.client_data[client_id]["server"]
-                    _safe_close(server)
-                del self.client_data[client_id]
+                if client_id in self.client_data:
+                  if "server" in self.client_data[client_id]:
+                      server = self.client_data[client_id]["server"]
+                      _safe_close(server)
+                  del self.client_data[client_id]
 
             len_ntlm_payload = len(ntlm_payload)
             client_socket.sendall(pack("<Bl", response, len_ntlm_payload)
@@ -301,12 +313,12 @@ class _NTLMDaemon(object):
         return success
 
     def _handle_auth(self, client_id, ntlm_payload):
-        # print >> sys.stderr, "* client auth stage1"
+        self.log.debug("* client auth stage1")
 
         server = self.client_data[client_id]["server"]
-        # print >> sys.stderr, "host: %s" % str(server.getsockname())
+        self.log.debug("host: %s", str(server.getsockname()))
 
-        # print >> sys.stderr, "building auth_3 and ping packets"
+        self.log.debug("building auth_3 and ping packets")
         packet = RPCAuth3OutPacket()
         packet.ntlm_payload = ntlm_payload
         server.sendall(packet.make())
@@ -324,7 +336,7 @@ class _NTLMDaemon(object):
         packet = RPCPingOutPacket()
         packet.call_id = 2
         server.sendall(packet.make())
-        # print >> sys.stderr, "sent auth3 and ping packets, receiving response"
+        self.log.debug("sent auth3 and ping packets, receiving response")
 
         try:
             packet = RPCPacket.from_file(server)
@@ -344,28 +356,29 @@ class _NTLMDaemon(object):
             response = 1
 
         if response == 1:
-            # authentication completed
             self.client_data[client_id]["status"] = "ok"
             del self.client_data[client_id]["server"]
+            self.log.debug("Authentication completed")
         else:
             # we start over with the whole process
+            self.log.debug("Authentication not completed starting over again")
             del self.client_data[client_id]
 
         _safe_close(server)
 
-        # print >> sys.stderr, "* done with client auth stage1"
+        self.log.debug("* done with client auth stage1")
 
         return response
 
     def _handle_negotiate(self, client_id, ntlm_payload):
-        # print >> sys.stderr, "* client auth stage0"
+        self.log.debug("* client auth stage0")
 
-        # print >> sys.stderr, "connecting to host"
+        self.log.debug("connecting to host")
         server = None
 
         connected = False
         attempt = 0
-        while not connected:
+        while not connected and attempt < SAMBA_CONNECT_MAX_TRIES :
             try:
                 attempt = attempt + 1
                 # TODO: we should query port 135 for the right service
@@ -373,27 +386,31 @@ class _NTLMDaemon(object):
                 server.connect((self.samba_host, SAMBA_PORT))
                 connected = True
             except:
-                print >> sys.stderr, ("NTLMAuthHandler: caught exception when"
-                                      " connecting to samba host: attempt %d"
-                                      % attempt)
+                self.log.error("NTLMAuthHandler: caught exception when"
+                               " connecting to samba host: attempt %d",
+                               attempt)
                 sleep(1)
 
-        # print >> sys.stderr, "host: %s" % str(server.getsockname())
+        if not connected:
+            raise Exception("NTLMAuthHandler: unable to connect to samba host"
+                            " aborting after %d attempts" % attempt)
+
+        self.log.debug("server.sockname: %s", str(server.getsockname()))
 
-        # print >> sys.stderr, "building bind packet"
+        self.log.debug("building bind packet")
         packet = RPCBindOutPacket()
         packet.ntlm_payload = ntlm_payload
         
-        # print >> sys.stderr, "sending bind packet"
+        self.log.debug("sending bind packet")
         server.sendall(packet.make())
 
-        # print >> sys.stderr, "sent bind packet, receiving response"
+        self.log.debug("sent bind packet, receiving response")
 
         packet = RPCPacket.from_file(server)
-        # print >> sys.stderr, "response parsed: %s" % packet.pretty_dump()
+        self.log.debug("response parsed: %s", packet.pretty_dump())
 
         if isinstance(packet, RPCBindACKPacket):
-            # print >> sys.stderr, "ACK received"
+            self.log.debug("ACK received")
             self.client_data[client_id] = {"status": "challenged",
                                            "last_used": time(),
                                            "server": server}
@@ -403,7 +420,7 @@ class _NTLMDaemon(object):
             response = 0
             ntlm_payload = ""
 
-        # print >> sys.stderr, "* done with client auth stage0"
+        self.log.debug("* done with client auth stage0")
 
         return (response, ntlm_payload)
 
@@ -413,24 +430,24 @@ class _NTLMAuthClient(object):
         self.work_dir = work_dir
         self.samba_host = samba_host
         self.connection = None
+        self.log = logging.getLogger(__name__)
 
     def server_knows_client(self, client_id):
-        # print >> sys.stderr, "server knows client? (%d)" % getpid()
+        self.log.debug("server knows client? (%d)", getpid())
         payload = "k%s%s" % (pack("<l", len(client_id)), client_id)
         self._send_to_server(payload)
         payload = self._recv_from_server(1)
         if len(payload) > 0:
             code = unpack_from("<B", payload)[0]
-            # print >> sys.stderr, ("server knows client: %d (%d)"
-            # % (code, getpid()))
+            self.log.debug("server knows client: %d (%d)", code, getpid())
         else:
-            # print >> sys.stderr, ("received empty response (%d)" % getpid())
+            self.log.warning("received empty response (%d)", getpid())
             code = 0
 
         return code != 0
 
     def ntlm_transaction(self, client_id="", ntlm_payload=""):
-        # print >> sys.stderr, "ntlm_transaction (%d)" % getpid()
+        self.log.debug("ntlm_transaction (%d)", getpid())
 
         payload = ("t%s%s%s%s"
                    % (pack("<l", len(client_id)), client_id,
@@ -446,11 +463,11 @@ class _NTLMAuthClient(object):
             else:
                 ntlm_payload = ""
         else:
-            # print >> sys.stderr, ("received empty response (%d)" % getpid())
+            self.log.warning("received empty response (%d)", getpid())
             code = 0
             ntlm_payload = ""
 
-        # print >> sys.stderr, "ntlm_transaction result: %d (%d)" % (code, getpid())
+        self.log.debug("ntlm_transaction result: %d (%d)", code, getpid())
 
         return (code != 0, ntlm_payload)
 
@@ -461,21 +478,20 @@ class _NTLMAuthClient(object):
         # sends a series of bytes to the server and make sure it receives them
         # by restarting it if needed
 
-        # print >>sys.stderr, "sending data (%d)" % getpid()
+        self.log.debug("sending data (%d)", getpid())
         sent = False
         while not sent:
             try:
                 self.connection.sendall(payload)
                 sent = True
             except IOError:
-                # print >> sys.stderr, ("(send) reconnecting to server (%d)..."
-                #                      % getpid())
+                self.log.debug("(send) reconnecting to server (%d)...", getpid())
                 sleep(1)
                 self._make_connection()
-        # print >>sys.stderr, "sent data (%d)" % getpid()
+        self.log.debug("sent data (%d)", getpid())
 
     def _recv_from_server(self, nbr_bytes):
-        # print >>sys.stderr, "receiving data (%d)" % getpid()
+        self.log.debug("receiving data (%d)", getpid())
 
         # receives a payload from the server and returns an empty string if
         # something went wrong, just as if the actual request failed
@@ -487,7 +503,7 @@ class _NTLMAuthClient(object):
             # if the server has died, we must return an error anyway
             payload = ""
 
-        # print >>sys.stderr, "received data (%d)" % getpid()
+        self.log.debug("received data (%d)", getpid())
 
         return payload
 
@@ -500,10 +516,10 @@ class _NTLMAuthClient(object):
             lockf = open(lock_filename, "w+")
             lockf.close()
         lockf = open(lock_filename, "r")
-        # print >> sys.stderr, "acquiring lock (%d)" % getpid()
+        self.log.info("acquiring lock %s (%d)", lock_filename, getpid())
         lock_fd = lockf.fileno()
         flock(lock_fd, LOCK_EX)
-        # print >> sys.stderr, "acquired lock (%d)" % getpid()
+        self.log.debug("acquired lock (%d)", getpid())
         self.connection = self._connect_to_daemon(self.work_dir,
                                                   self.samba_host)
         flock(lock_fd, LOCK_UN)
@@ -542,6 +558,7 @@ class NTLMAuthHandler(object):
 
     def __init__(self, application):
         self.application = application
+        self.log = logging.getLogger(__name__)
 
     def __call__(self, env, start_response):
         (work_dir, samba_host, cookie_name, has_auth) \
@@ -555,12 +572,11 @@ class NTLMAuthHandler(object):
         if cookie_name in cookies:
             client_id = cookies[cookie_name]
             server_knows_client = connection.server_knows_client(client_id)
-            # print >> sys.stderr, \
-                # "server knows client (pid: %d): %s" % (getpid(),
-            # str(server_knows_client))
+            self.log.debug("server knows client (pid: %d): %s", getpid(),
+                           str(server_knows_client))
         else:
             server_knows_client = False
-            # print >> sys.stderr, "client did not pass auth cookie"
+            self.log.info("client did not pass auth cookie")
 
         if has_auth:
             auth = env["HTTP_AUTHORIZATION"]
@@ -606,6 +622,7 @@ class NTLMAuthHandler(object):
 
     @staticmethod
     def _read_environment(env):
+        log = logging.getLogger(__name__)
         if "NTLMAUTHHANDLER_WORKDIR" in env:
             work_dir = env["NTLMAUTHHANDLER_WORKDIR"]
             if not exists(work_dir):
@@ -619,8 +636,8 @@ class NTLMAuthHandler(object):
         if "SAMBA_HOST" in env:
             samba_host = env["SAMBA_HOST"]
         else:
-            print >> sys.stderr, \
-                "'SAMBA_HOST' not configured, 'localhost' will be used"
+            log.warning("'SAMBA_HOST' not configured, "
+                "'localhost' will be used")
             samba_host = "localhost"
 
         if "NTLMAUTHHANDLER_COOKIENAME" in env:
@@ -638,7 +655,7 @@ class NTLMAuthHandler(object):
         if "HTTP_COOKIE" in env:
             cookie_str = env["HTTP_COOKIE"]
             for pair in cookie_str.split(";"):
-                (key, value) = pair.strip().split("=")
+                (key, value) = pair.strip().split("=", 1)
                 cookies[key] = value
 
         return cookies
