X-Git-Url: http://pam-abl.git.sourceforge.net/git/gitweb.cgi?p=pam-abl%2Fpam-abl;a=blobdiff_plain;f=pam_functions.c;h=e49289a856bd05f9b7afad67536d15e282a276f7;hp=7415374b12f74ced3614b3899e6c77875dc0074d;hb=a7f04548a1e9d139e843a15e7c0cda785ffb6f61;hpb=09707e489b086d7e6cebc295f3c099e35bb01f00

diff --git a/pam_functions.c b/pam_functions.c
index 7415374..e49289a 100644
--- a/pam_functions.c
+++ b/pam_functions.c
@@ -36,11 +36,16 @@ typedef struct abl_context {
 
 static void cleanup(pam_handle_t *pamh, void *data, int err) {
     (void)(pamh);
+    //if we are replacing our data pointer, ignore the cleanup.
+    //the function replacing our data should handle the cleanup
+    if (err & PAM_DATA_REPLACE)
+        return;
+
     if (NULL != data) {
         abl_context *context = data;
         log_debug(context->logContext, "In cleanup, err is %08x", err);
 
-        if (err && (err & PAM_DATA_REPLACE) == 0) {
+        if (err) {
             int recordResult = record_attempt(context->dbEnv, context->args, context->attemptInfo, context->logContext);
             log_debug(context->logContext, "record returned %d", recordResult);
         }
@@ -60,80 +65,97 @@ static void cleanup(pam_handle_t *pamh, void *data, int err) {
 PAM_EXTERN int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) {
     (void)(flags);
     int err = PAM_BUF_ERR;
-    PamAblDbEnv *dbEnv = NULL;
-    abl_info *info = malloc(sizeof(abl_info));
-    abl_context *context = malloc(sizeof(abl_context));
-    abl_args *args = config_create();
-    log_context *logContext = createLogContext();
-    if (!info || ! context || !args || !logContext) {
-        err = PAM_BUF_ERR;
-        goto psa_fail;
-    }
-    memset(info, 0, sizeof(abl_info));
-    memset(context, 0, sizeof(abl_context));
+    abl_context *context = NULL;
 
-    err = config_parse_args(argc, argv, args, logContext);
-    if (err == 0) {
-        /* We now keep the database open from the beginning to avoid the cost
-         * of opening them repeatedly. */
-        dbEnv = openPamAblDbEnvironment(args, logContext);
-        if (!dbEnv) {
-            log_error(logContext, "The database environment could not be opened");
+    err = pam_get_data(pamh, MODULE_NAME, (const void **)(&context));
+    if (err != PAM_SUCCESS) {
+        context = NULL;
+	}
+
+    if (!context) {
+        context = malloc(sizeof(abl_context));
+        if (!context) {
+            err = PAM_BUF_ERR;
             goto psa_fail;
         }
-        context->args = args;
-        context->attemptInfo = info;
-        context->logContext = logContext;
-        context->dbEnv = dbEnv;
-
-        err = pam_set_data(pamh, MODULE_NAME, context, cleanup);
-        if (err != PAM_SUCCESS) {
-            log_pam_error(logContext, pamh, err, "setting PAM data");
+        memset(context, 0, sizeof(abl_context));
+        context->attemptInfo = malloc(sizeof(abl_info));
+        context->args = config_create();
+        context->logContext = createLogContext();
+        if (!context->attemptInfo || !context->args || !context->logContext) {
+            err = PAM_BUF_ERR;
             goto psa_fail;
         }
+        memset(context->attemptInfo, 0, sizeof(abl_info));
 
-        err = pam_get_item(pamh, PAM_USER, (const void **) &info->user);
-        if (err != PAM_SUCCESS) {
-            log_pam_error(logContext, pamh, err, "getting PAM_USER");
+        err = config_parse_args(argc, argv, context->args, context->logContext);
+        if (err != 0) {
+            err = PAM_SERVICE_ERR;
+            log_error(context->logContext, "Could not parse the config.");
             goto psa_fail;
         }
-
-        err = pam_get_item(pamh, PAM_SERVICE, (const void **) &info->service);
-        if (err != PAM_SUCCESS) {
-            log_pam_error(logContext, pamh, err, "getting PAM_SERVICE");
+        /* We now keep the database open from the beginning to avoid the cost
+         * of opening them repeatedly. */
+        context->dbEnv = openPamAblDbEnvironment(context->args, context->logContext);
+        if (!context->dbEnv) {
+            log_error(context->logContext, "The database environment could not be opened");
             goto psa_fail;
         }
 
-        err = pam_get_item(pamh, PAM_RHOST, (const void **) &info->host);
+        err = pam_set_data(pamh, MODULE_NAME, context, cleanup);
         if (err != PAM_SUCCESS) {
-            log_pam_error(logContext, pamh, err, "getting PAM_RHOST");
+            log_pam_error(context->logContext, pamh, err, "setting PAM data");
             goto psa_fail;
         }
+    } else {
+        //we have a previous data pointer. We will ASSUME that it was from a previous failed attempt
+        //a good example is sshd, when you try to login, you are given 3 attempts, so this function
+        //can be called up to three times before the cleanup function is called.
+        int recordResult = record_attempt(context->dbEnv, context->args, context->attemptInfo, context->logContext);
+        log_debug(context->logContext, "record from authenticate returned %d", recordResult);
+    }
 
-        //BlockState check_attempt(const PamAblDbEnv *dbEnv, const abl_args *args, abl_info *info, log_context *logContext);
-        BlockState bState = check_attempt(dbEnv, args, info, logContext);
-        if (bState == BLOCKED) {
-            log_info(logContext, "Blocking access from %s to service %s, user %s", info->host, info->service, info->user);
-            return PAM_AUTH_ERR;
-        } else {
-            return PAM_SUCCESS;
-        }
+    //get the user again, it can be that another module has changed the username or something else
+    err = pam_get_item(pamh, PAM_USER, (const void **) &context->attemptInfo->user);
+    if (err != PAM_SUCCESS) {
+        log_pam_error(context->logContext, pamh, err, "getting PAM_USER");
+        goto psa_fail;
+    }
+
+    err = pam_get_item(pamh, PAM_SERVICE, (const void **) &context->attemptInfo->service);
+    if (err != PAM_SUCCESS) {
+        log_pam_error(context->logContext, pamh, err, "getting PAM_SERVICE");
+        goto psa_fail;
+    }
+
+    err = pam_get_item(pamh, PAM_RHOST, (const void **) &context->attemptInfo->host);
+    if (err != PAM_SUCCESS) {
+        log_pam_error(context->logContext, pamh, err, "getting PAM_RHOST");
+        goto psa_fail;
+    }
+
+    BlockState bState = check_attempt(context->dbEnv, context->args, context->attemptInfo, context->logContext);
+    if (bState == BLOCKED) {
+        log_info(context->logContext, "Blocking access from %s to service %s, user %s", context->attemptInfo->host, context->attemptInfo->service, context->attemptInfo->user);
+        return PAM_AUTH_ERR;
     } else {
-        err = PAM_SERVICE_ERR;
-        log_error(logContext, "Could not parse the config.");
+        return PAM_SUCCESS;
     }
 
 psa_fail:
-    if (dbEnv)
-        destroyPamAblDbEnvironment(dbEnv);
-    if (info)
-        free(info);
-    if (context)
+    if (context) {
+        if (context->dbEnv)
+            destroyPamAblDbEnvironment(context->dbEnv);
+        if (context->attemptInfo)
+            free(context->attemptInfo);
+        if (context->args)
+            config_free(context->args);
+        if (context->logContext)
+            destroyLogContext(context->logContext);
         free(context);
-    if (args)
-        config_free(args);
-    if (logContext)
-        destroyLogContext(logContext);
+        //it can be that we already set the data pointer, let's remove it
+        pam_set_data(pamh, MODULE_NAME, NULL, NULL);
+    }
     return err;
 }
 
