diff -Nru -x .git kde-workspace/appmenu/CMakeLists.txt kde-workspace-appmenu/appmenu/CMakeLists.txt
--- kde-workspace/appmenu/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/CMakeLists.txt	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,13 @@
+pkg_check_modules(DBUSMENUQT REQUIRED dbusmenu-qt>=0.6.0)
+
+include_directories(
+    ${KDE4_INCLUDES}
+    ${DBUSMENUQT_INCLUDE_DIRS}
+    )
+
+link_directories(
+    ${DBUSMENUQT_LIBRARY_DIRS}
+    )
+
+add_subdirectory(lib)
+add_subdirectory(module)
diff -Nru -x .git kde-workspace/appmenu/lib/CMakeLists.txt kde-workspace-appmenu/appmenu/lib/CMakeLists.txt
--- kde-workspace/appmenu/lib/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/CMakeLists.txt	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,36 @@
+include_directories(
+    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_BINARY_DIR}
+    )
+
+set(kappmenu_LIB_SRCS
+    kappmenuimporter.cpp
+    importer_interface.cpp
+    )
+
+
+kde4_add_library( kappmenu SHARED ${kappmenu_LIB_SRCS} )
+
+target_link_libraries( kappmenu
+  ${KDE4_KDECORE_LIBS}
+  ${KDE4_KIO_LIBS}
+  ${DBUSMENUQT_LIBRARIES}
+)
+
+set_target_properties( kappmenu
+  PROPERTIES VERSION ${GENERIC_LIB_VERSION} SOVERSION ${GENERIC_LIB_SOVERSION}
+)
+
+install( TARGETS kappmenu  ${INSTALL_TARGETS_DEFAULT_ARGS} )
+
+set( kappmenu_LIB_HDRS
+  kappmenu_export.h
+  kappmenuimporter.h
+  importer_interface.h
+  menuinfo.h
+)
+
+install( FILES ${kappmenu_LIB_HDRS}
+  DESTINATION ${INCLUDE_INSTALL_DIR}/kappmenu
+  COMPONENT Devel
+)
diff -Nru -x .git kde-workspace/appmenu/lib/com.canonical.AppMenu.Registrar.xml kde-workspace-appmenu/appmenu/lib/com.canonical.AppMenu.Registrar.xml
--- kde-workspace/appmenu/lib/com.canonical.AppMenu.Registrar.xml	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/com.canonical.AppMenu.Registrar.xml	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node xmlns:dox="http://www.ayatana.org/dbus/dox.dtd">
+	<dox:d><![CDATA[
+	  @mainpage
+	 
+	  An interface to register menus that are associated with a window in an application.  The
+	  main interface is docuemented here: @ref com::canonical::AppMenu::Registrar.
+	    
+	  The actual menus are transported using the dbusmenu protocol which is available
+	  here: @ref com::canonical::dbusmenu.
+	]]></dox:d>
+	<interface name="com.canonical.AppMenu.Registrar" xmlns:dox="http://www.ayatana.org/dbus/dox.dtd">
+		<dox:d>
+		  An interface to register a menu from an application's window to be displayed in another
+		  window.  This manages that association between XWindow Window IDs and the dbus
+		  address and object that provides the menu using the dbusmenu dbus interface.
+		</dox:d>
+		<method name="RegisterWindow">
+			<dox:d><![CDATA[
+			  Associates a dbusmenu with a window
+	     
+			  /note this method assumes that the connection from the caller is the DBus connection
+			    to use for the object.  Applications that use multiple DBus connections will need to
+			    ensure this method is called with the same connection that implmenets the object.
+			]]></dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="in">
+				<dox:d>The object on the dbus interface implementing the dbusmenu interface</dox:d>
+			</arg>
+		</method>
+		<method name="UnregisterWindow">
+			<dox:d>
+			  A method to allow removing a window from the database.  Windows will also be removed
+			  when the client drops off DBus so this is not required.  It is polite though.  And
+			  important for testing.
+			</dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+		</method>
+		<method name="GetMenuForWindow">
+			<dox:d>Gets the registered menu for a given window ID.</dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window to get</dox:d>
+			</arg>
+			<arg name="service" type="s" direction="out">
+				<dox:d>The address of the connection on DBus (e.g. :1.23 or org.example.service)</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="out">
+				<dox:d>The path to the object which implements the com.canonical.dbusmenu interface.</dox:d>
+			</arg>
+		</method>
+		<method name="GetMenus">
+			<annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="MenuInfoList"/>
+			<dox:d>Gets the information on all menus that the registrar knows about.  This
+			  is useful for debugging or bringing up a new renderer.</dox:d>
+			<arg name="menus" type="a(uso)" direction="out">
+				<dox:d>An array of structures containing the same parameters as @GetMenuForWindow.  Window ID, Service and ObjectPath.</dox:d>
+			</arg>
+		</method>
+		<signal name="WindowRegistered">
+			<dox:d>Signals when the registrar gets a new menu registered</dox:d>
+			<arg name="windowId" type="u" direction="out">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+			<arg name="service" type="s" direction="out">
+				<dox:d>The address of the connection on DBus (e.g. :1.23 or org.example.service)</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="out">
+				<dox:d>The path to the object which implements the com.canonical.dbusmenu interface.</dox:d>
+			</arg>
+		</signal>
+		<signal name="WindowUnregistered">
+			<dox:d>Signals when the registrar removes a menu registration</dox:d>
+			<arg name="windowId" type="u" direction="out">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+		</signal>
+	</interface>
+</node>
diff -Nru -x .git kde-workspace/appmenu/lib/importer_interface.cpp kde-workspace-appmenu/appmenu/lib/importer_interface.cpp
--- kde-workspace/appmenu/lib/importer_interface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/importer_interface.cpp	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,28 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -m -i menuinfo.h -p registrar_interface /usr/share/dbus-1/interfaces/com.canonical.AppMenu.Registrar.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * This file may have been hand-edited. Look for HAND-EDIT comments
+ * before re-generating it.
+ */
+
+#include "importer_interface.h"
+
+/*
+ * Implementation of interface class ComCanonicalAppMenuRegistrarInterface
+ */
+
+ComCanonicalAppMenuRegistrarInterface::ComCanonicalAppMenuRegistrarInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent)
+    : QDBusAbstractInterface(service, path, staticInterfaceName(), connection, parent)
+{
+}
+
+ComCanonicalAppMenuRegistrarInterface::~ComCanonicalAppMenuRegistrarInterface()
+{
+}
+
+
+#include "importer_interface.moc"
diff -Nru -x .git kde-workspace/appmenu/lib/importer_interface.h kde-workspace-appmenu/appmenu/lib/importer_interface.h
--- kde-workspace/appmenu/lib/importer_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/importer_interface.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,89 @@
+/*
+ * This file was generated by qdbusxml2cpp version 0.7
+ * Command line was: qdbusxml2cpp -m -i menuinfo.h -p registrar_interface /usr/share/dbus-1/interfaces/com.canonical.AppMenu.Registrar.xml
+ *
+ * qdbusxml2cpp is Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
+ *
+ * This is an auto-generated file.
+ * Do not edit! All changes made to it will be lost.
+ */
+
+#ifndef REGISTRAR_INTERFACE_H_1325586401
+#define REGISTRAR_INTERFACE_H_1325586401
+
+#include <QtCore/QObject>
+#include <QtCore/QByteArray>
+#include <QtCore/QList>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QStringList>
+#include <QtCore/QVariant>
+#include <QtDBus/QtDBus>
+#include "menuinfo.h"
+
+/*
+ * Proxy class for interface com.canonical.AppMenu.Registrar
+ */
+class ComCanonicalAppMenuRegistrarInterface: public QDBusAbstractInterface
+{
+    Q_OBJECT
+public:
+    static inline const char *staticInterfaceName()
+    { return "com.canonical.AppMenu.Registrar"; }
+
+public:
+    ComCanonicalAppMenuRegistrarInterface(const QString &service, const QString &path, const QDBusConnection &connection, QObject *parent = 0);
+
+    ~ComCanonicalAppMenuRegistrarInterface();
+
+public Q_SLOTS: // METHODS
+    inline QDBusPendingReply<QString, QDBusObjectPath> GetMenuForWindow(uint windowId)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(windowId);
+        return asyncCallWithArgumentList(QLatin1String("GetMenuForWindow"), argumentList);
+    }
+    inline QDBusReply<QString> GetMenuForWindow(uint windowId, QDBusObjectPath &menuObjectPath)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(windowId);
+        QDBusMessage reply = callWithArgumentList(QDBus::Block, QLatin1String("GetMenuForWindow"), argumentList);
+        if (reply.type() == QDBusMessage::ReplyMessage && reply.arguments().count() == 2) {
+            menuObjectPath = qdbus_cast<QDBusObjectPath>(reply.arguments().at(1));
+        }
+        return reply;
+    }
+
+    inline QDBusPendingReply<MenuInfoList> GetMenus()
+    {
+        QList<QVariant> argumentList;
+        return asyncCallWithArgumentList(QLatin1String("GetMenus"), argumentList);
+    }
+
+    inline QDBusPendingReply<> RegisterWindow(uint windowId, const QDBusObjectPath &menuObjectPath)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(windowId) << qVariantFromValue(menuObjectPath);
+        return asyncCallWithArgumentList(QLatin1String("RegisterWindow"), argumentList);
+    }
+
+    inline QDBusPendingReply<> UnregisterWindow(uint windowId)
+    {
+        QList<QVariant> argumentList;
+        argumentList << qVariantFromValue(windowId);
+        return asyncCallWithArgumentList(QLatin1String("UnregisterWindow"), argumentList);
+    }
+
+Q_SIGNALS: // SIGNALS
+    void WindowRegistered(uint windowId, const QString &service, const QDBusObjectPath &menuObjectPath);
+    void WindowUnregistered(uint windowId);
+};
+
+namespace com {
+  namespace canonical {
+    namespace AppMenu {
+      typedef ::ComCanonicalAppMenuRegistrarInterface Registrar;
+    }
+  }
+}
+#endif
diff -Nru -x .git kde-workspace/appmenu/lib/kappmenu_export.h kde-workspace-appmenu/appmenu/lib/kappmenu_export.h
--- kde-workspace/appmenu/lib/kappmenu_export.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/kappmenu_export.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,21 @@
+#ifndef KAPPMENU_EXPORT_H
+#define KAPPMENU_EXPORT_H
+
+// needed for KDE_EXPORT and KDE_IMPORT macros
+#include <kdemacros.h>
+
+#ifndef KAPPMENU_EXPORT
+# if defined(MAKE_KAPPMENU_LIB)
+   // We are building this library
+#  define KAPPMENU_EXPORT KDE_EXPORT
+# else
+   // We are using this library
+#  define KAPPMENU_EXPORT KDE_IMPORT
+# endif
+#endif
+
+# ifndef KAPPMENU_EXPORT_DEPRECATED
+#  define KAPPMENU_EXPORT_DEPRECATED KDE_DEPRECATED KAPPMENU_EXPORT
+# endif
+
+#endif
\ Pas de fin de ligne à la fin du fichier
diff -Nru -x .git kde-workspace/appmenu/lib/kappmenuimporter.cpp kde-workspace-appmenu/appmenu/lib/kappmenuimporter.cpp
--- kde-workspace/appmenu/lib/kappmenuimporter.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/kappmenuimporter.cpp	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,118 @@
+/*
+  This file is part of the KDE project.
+
+  Copyright (c) 2011 Lionel Chauvin <megabigbug@yahoo.fr>
+  Copyright (c) 2011 Cédric Bellegarde <gnumdk@gmail.com>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+  DEALINGS IN THE SOFTWARE.
+*/
+
+#include "kappmenuimporter.h"
+
+#include <QApplication>
+#include <QDBusInterface>
+#include <QDBusReply>
+
+#include <kdebug.h>
+
+#include "kappmenuimporter.moc"
+
+static const char *KDED_INTERFACE = "org.kde.kded";
+static const char *KDED_PATH = "/kded";
+static const char *KDED_APPMENU_PATH = "/modules/appmenu";
+
+KAppMenuImporter::KAppMenuImporter()
+{
+    QDBusInterface kded(KDED_INTERFACE, KDED_PATH, KDED_INTERFACE);
+
+    QDBusReply<bool> reply = kded.call("loadModule", "appmenu");
+
+    if (!reply.isValid()) {
+       kError() << "Error talking to KDED";
+       return;
+    }
+    if (!reply.value()) {
+       kWarning() << "KDED could not load appmenud";
+       return;
+    }
+
+    mRegistrar = new com::canonical::AppMenu::Registrar("com.canonical.AppMenu.Registrar",
+                                                        "/com/canonical/AppMenu/Registrar",
+                                                        QDBusConnection::sessionBus());
+
+    connect(mRegistrar, SIGNAL(WindowRegistered(uint, const QString&, const QDBusObjectPath&)),
+        SLOT(slotWindowRegistered(uint, const QString&, const QDBusObjectPath&)));
+
+    connect(mRegistrar, SIGNAL(WindowUnregistered(uint)),
+        SLOT(slotWindowUnregistered(uint)));
+
+     QDBusMessage msg = QDBusMessage::createSignal(KDED_APPMENU_PATH, KDED_INTERFACE, "clientsUpdate");
+     msg << 1;
+     QDBusConnection::sessionBus().send(msg);
+}
+
+KAppMenuImporter::~KAppMenuImporter()
+{
+     QDBusMessage msg = QDBusMessage::createSignal(KDED_APPMENU_PATH, KDED_INTERFACE, "clientsUpdate");
+     msg << -1;
+     QDBusConnection::sessionBus().send(msg);
+}
+
+QMenu* KAppMenuImporter::menuForWinId(WId wid)
+{
+    MyDBusMenuImporter* importer = importers.value(wid);
+    return importer ? importer->menu() : 0;
+}
+
+bool KAppMenuImporter::available()
+{
+    static const char *APPMENU_INTERFACE = "com.canonical.AppMenu.Registrar";
+    static const char *APPMENU_PATH = "/com/canonical/AppMenu/Registrar";
+    QDBusInterface appmenu(APPMENU_INTERFACE, APPMENU_PATH, APPMENU_INTERFACE);
+    QDBusReply<QDBusArgument> reply = appmenu.call("GetMenus");
+    return reply.isValid();
+}
+
+void KAppMenuImporter::slotWindowRegistered(uint id, const QString& service, const QDBusObjectPath& path)
+{
+    delete importers.take(id);
+    MyDBusMenuImporter* importer = new MyDBusMenuImporter(id, service, &mIcons, path.path(), this);
+    importers.insert(id, importer);
+    connect(importer, SIGNAL(actionActivationRequested(QAction*)),
+            SLOT(slotActionActivationRequested(QAction*)));
+
+    QMetaObject::invokeMethod(importer, "updateMenu", Qt::QueuedConnection);
+    emit windowRegistered(id);
+}
+
+void KAppMenuImporter::slotWindowUnregistered(uint id)
+{
+    MyDBusMenuImporter* importer = importers.take(id);
+    if (importer) {
+        importer->deleteLater();
+    }
+
+    emit windowUnregistered(id);
+}
+
+void KAppMenuImporter::slotActionActivationRequested(QAction* a)
+{
+    MyDBusMenuImporter *importer = static_cast<MyDBusMenuImporter*>(sender());
+    emit actionActivationRequested(importer->wid(), a);
+}
\ Pas de fin de ligne à la fin du fichier
diff -Nru -x .git kde-workspace/appmenu/lib/kappmenuimporter.h kde-workspace-appmenu/appmenu/lib/kappmenuimporter.h
--- kde-workspace/appmenu/lib/kappmenuimporter.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/kappmenuimporter.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,227 @@
+/*
+  This file is part of the KDE project.
+
+  Copyright (c) 2011 Lionel Chauvin <megabigbug@yahoo.fr>
+  Copyright (c) 2011 Cédric Bellegarde <gnumdk@gmail.com>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the "Software"),
+  to deal in the Software without restriction, including without limitation
+  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  and/or sell copies of the Software, and to permit persons to whom the
+  Software is furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+  DEALINGS IN THE SOFTWARE.
+*/
+
+#ifndef APPMENUIMPORTER_H
+#define APPMENUIMPORTER_H
+
+#include <QtCore/QObject>
+#include <QtCore/QHash>
+#include <QtCore/QString>
+#include <QtCore/QMap>
+
+#include <QDBusObjectPath>
+#include <QMenu>
+
+#include <KIcon>
+#include <KIconLoader>
+#include <QDebug>
+#include <dbusmenuimporter.h>
+
+#include "importer_interface.h"
+
+#include "kappmenu_export.h"
+
+class GtkIcons : public QMap<QString, QString>
+{
+    public:
+    GtkIcons( void ) : QMap<QString, QString> ()
+    {
+        insert(QString("gnome-fs-directory"), QString("folder.png"));
+        insert(QString("gnome-fs-regular.png"), QString("application-x-zerosize.png"));
+        insert(QString("gtk-about"), QString("help-about.png"));
+        insert(QString("gtk-add"), QString("list-add.png"));
+        insert(QString("gtk-apply"), QString("dialog-ok-apply.png ok-apply.png apply.png"));
+        insert(QString("gtk-bold"), QString("format-text-bold.png"));
+        insert(QString("gtk-cancel"), QString("dialog-cancel.png cancel.png"));
+        insert(QString("gtk-cdrom"), QString("media-optical.png"));
+        insert(QString("gtk-clear"), QString("edit-clear.png"));
+        insert(QString("gtk-close"), QString("window-close.png"));
+        insert(QString("gtk-color-picker"), QString("color-picker.png"));
+        insert(QString("gtk-connect"), QString("network-connect.png"));
+        insert(QString("gtk-convert"), QString("document-export.png"));
+        insert(QString("gtk-copy"), QString("edit-copy.png"));
+        insert(QString("gtk-cut"), QString("edit-cut.png"));
+        insert(QString("gtk-delete"), QString("edit-delete.png"));
+        insert(QString("gtk-dialog-authentication"), QString("dialog-password.png document-encrypt.png object-locked.png"));
+        insert(QString("gtk-dialog-error"), QString("dialog-error.png"));
+        insert(QString("gtk-dialog-info"), QString("dialog-information.png"));
+        insert(QString("gtk-dialog-question"), QString("dialog-information.png"));
+        insert(QString("gtk-dialog-warning"), QString("dialog-warning.png"));
+        insert(QString("gtk-directory"), QString("folder.png"));
+        insert(QString("gtk-disconnect"), QString("network-disconnect.png"));
+        insert(QString("gtk-dnd"), QString("application-x-zerosize.png"));
+        insert(QString("gtk-dnd-multiple"), QString("document-multiple.png"));
+        insert(QString("gtk-edit"), QString("document-properties.png"));
+        insert(QString("gtk-execute"), QString("fork.png"));
+        insert(QString("gtk-file"), QString("application-x-zerosize.png"));
+        insert(QString("gtk-find"), QString("edit-find.png"));
+        insert(QString("gtk-find-and-replace"), QString("edit-find-replace.png"));
+        insert(QString("gtk-floppy"), QString("media-floppy.png"));
+        insert(QString("gtk-fullscreen"), QString("view-fullscreen.png"));
+        insert(QString("gtk-goto-bottom"), QString("go-bottom.png"));
+        insert(QString("gtk-goto-first"), QString("go-first.png"));
+        insert(QString("gtk-goto-last"), QString("go-last.png"));
+        insert(QString("gtk-goto-top"), QString("go-top.png"));
+        insert(QString("gtk-go-back"), QString("go-previous.png"));
+        insert(QString("gtk-go-back-ltr"), QString("go-previous.png"));
+        insert(QString("gtk-go-back-rtl"), QString("go-next.png"));
+        insert(QString("gtk-go-down"), QString("go-down.png"));
+        insert(QString("gtk-go-forward"), QString("go-next.png"));
+        insert(QString("gtk-go-forward-ltr"), QString("go-next.png"));
+        insert(QString("gtk-go-forward-rtl"), QString("go-previous.png"));
+        insert(QString("gtk-go-up"), QString("go-up.png"));
+        insert(QString("gtk-harddisk"), QString("drive-harddisk.png"));
+        insert(QString("gtk-help"), QString("help-contents.png"));
+        insert(QString("gtk-home"), QString("go-home.png"));
+        insert(QString("gtk-indent"), QString("format-indent-more.png"));
+        insert(QString("gtk-index"), QString("help-contents.png"));
+        insert(QString("gtk-info"), QString("help-about.png"));
+        insert(QString("gtk-italic"), QString("format-text-italic.png"));
+        insert(QString("gtk-jump-to"), QString("go-jump.png"));
+        insert(QString("gtk-justify-center"), QString("format-justify-center.png"));
+        insert(QString("gtk-justify-fill"), QString("format-justify-fill.png"));
+        insert(QString("gtk-justify-left"), QString("format-justify-left.png"));
+        insert(QString("gtk-justify-right"), QString("format-justify-right.png"));
+        insert(QString("gtk-leave-fullscreen"), QString("view-restore.png"));
+        insert(QString("gtk-media-forward"), QString("media-seek-forward.png"));
+        insert(QString("gtk-media-next"), QString("media-skip-forward.png"));
+        insert(QString("gtk-media-pause"), QString("media-playback-pause.png"));
+        insert(QString("gtk-media-play"), QString("media-playback-start.png"));
+        insert(QString("gtk-media-previous"), QString("media-skip-backward.png"));
+        insert(QString("gtk-media-record"), QString("media-record.png"));
+        insert(QString("gtk-media-rewind"), QString("media-seek-backward.png"));
+        insert(QString("gtk-media-stop"), QString("media-playback-stop.png"));
+        insert(QString("gtk-missing-image"), QString("unknown.png"));
+        insert(QString("gtk-network"), QString("network-server.png"));
+        insert(QString("gtk-new"), QString("document-new.png"));
+        insert(QString("gtk-no"), QString("edit-delete.png"));
+        insert(QString("gtk-ok"), QString("dialog-ok.png ok.png"));
+        insert(QString("gtk-open"), QString("document-open.png"));
+        insert(QString("gtk-paste"), QString("edit-paste.png"));
+        insert(QString("gtk-preferences"), QString("configure.png"));
+        insert(QString("gtk-print"), QString("document-print.png"));
+        insert(QString("gtk-print-preview"), QString("document-print-preview.png"));
+        insert(QString("gtk-properties"), QString("document-properties.png"));
+        insert(QString("gtk-quit"), QString("application-exit.png"));
+        insert(QString("gtk-redo"), QString("edit-redo.png"));
+        insert(QString("gtk-refresh"), QString("view-refresh.png"));
+        insert(QString("gtk-remove"), QString("edit-delete.png"));
+        insert(QString("gtk-revert-to-saved"), QString("document-revert.png"));
+        insert(QString("gtk-save"), QString("document-save.png"));
+        insert(QString("gtk-save-as"), QString("document-save-as.png"));
+        insert(QString("gtk-select-all"), QString("edit-select-all.png"));
+        insert(QString("gtk-select-color"), QString("color-picker.png"));
+        insert(QString("gtk-select-font"), QString("preferences-desktop-font.png"));
+        insert(QString("gtk-sort-ascending"), QString("view-sort-ascending.png"));
+        insert(QString("gtk-sort-descending"), QString("view-sort-descending.png"));
+        insert(QString("gtk-spell-check"), QString("tools-check-spelling.png"));
+        insert(QString("gtk-stop"), QString("process-stop.png"));
+        insert(QString("gtk-strikethrough"), QString("format-text-strikethrough.png"));
+        insert(QString("gtk-undelete"), QString("edit-undo.png"));
+        insert(QString("gtk-underline"), QString("format-text-underline.png"));
+        insert(QString("gtk-undo"), QString("edit-undo.png"));
+        insert(QString("gtk-unindent"), QString("format-indent-less.png"));
+        insert(QString("gtk-yes"), QString("dialog-ok.png ok.png"));
+        insert(QString("gtk-zoom-100"), QString("zoom-original.png"));
+        insert(QString("gtk-zoom-fit"), QString("zoom-fit-best.png"));
+        insert(QString("gtk-zoom-in"), QString("zoom-in.png"));
+        insert(QString("gtk-zoom-out"), QString("zoom-out.png"));
+        insert(QString("stock_edit-bookmark"), QString("bookmarks-organize.png"));
+        insert(QString("gimp-edit"), QString("edit.png"));
+        insert(QString("gimp-info"), QString("dialog-information.png"));
+        insert(QString("gimp-reset"), QString("reload.png"));
+        insert(QString("gimp-warning"), QString("dialog-warning.png"));
+        insert(QString("gimp-tool-options"), QString("tool.png"));
+        insert(QString("gimp-images"), QString("image.png"));
+    }
+};
+
+
+class MyDBusMenuImporter : public DBusMenuImporter
+{
+
+public:
+    MyDBusMenuImporter(WId wid, const QString &service, GtkIcons *icons, const QString &path, QObject *parent)
+    : DBusMenuImporter(service, path, parent)
+    , mService(service)
+    , mPath(path)
+    , mWId(wid)
+    {
+        mIcons = icons;
+    }
+
+    QString service() const { return mService; }
+    QString path() const { return mPath; }
+    WId wid() const { return mWId; }
+
+protected:
+    virtual QIcon iconForName(const QString &name)
+    {
+        KIcon icon;
+        if(mIcons->contains(name)){
+            icon =  KIcon(mIcons->value(name));
+        }
+        else if(!KIconLoader::global()->iconPath(name, 1, true ).isNull()){
+            icon = KIcon(name);
+        }
+        return icon;
+    }
+
+private:
+    GtkIcons *mIcons;
+    QString mService;
+    QString mPath;
+    WId mWId;
+};
+
+
+class KAPPMENU_EXPORT KAppMenuImporter : public QObject
+{
+    Q_OBJECT
+
+public:
+    KAppMenuImporter();
+    ~KAppMenuImporter();
+    QMenu* menuForWinId(WId wid);
+    static bool available();
+
+signals:
+    void windowRegistered(WId id);
+    void windowUnregistered(WId id);
+    void actionActivationRequested(WId id, QAction* a);
+
+private Q_SLOTS:
+    void slotWindowRegistered(uint id, const QString& service, const QDBusObjectPath& path);
+    void slotWindowUnregistered(uint id);
+    void slotActionActivationRequested(QAction* a);
+
+private:
+    GtkIcons mIcons;
+    com::canonical::AppMenu::Registrar* mRegistrar;
+    QHash<WId, MyDBusMenuImporter*> importers;
+};
+
+
+#endif // APPMENUIMPORTER_H
diff -Nru -x .git kde-workspace/appmenu/lib/menuinfo.h kde-workspace-appmenu/appmenu/lib/menuinfo.h
--- kde-workspace/appmenu/lib/menuinfo.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/lib/menuinfo.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2010 Canonical Ltd.
+ * Copyright (c) 2010 Aurélien Gâteau <aurelien.gateau@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MENUINFO_H
+#define MENUINFO_H
+
+struct MenuInfo
+{
+    MenuInfo()
+    : winId(0)
+    , path("/")
+    {}
+
+    uint winId;
+    QString service;
+    QDBusObjectPath path;
+};
+Q_DECLARE_METATYPE(MenuInfo)
+
+typedef QList<MenuInfo> MenuInfoList;
+Q_DECLARE_METATYPE(MenuInfoList)
+#endif /* MENUINFO_H */
diff -Nru -x .git kde-workspace/appmenu/module/appmenu.cpp kde-workspace-appmenu/appmenu/module/appmenu.cpp
--- kde-workspace/appmenu/module/appmenu.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/appmenu.cpp	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2010 Canonical Ltd.
+ * Copyright (c) 2010 Aurélien Gâteau <aurelien.gateau@canonical.com>
+ * Copyright (c) 2011  Lionel Chauvin <megabigbug@yahoo.fr>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "appmenu.h"
+#include "registraradaptor.h"
+
+#include <QDBusInterface>
+#include <QDBusReply>
+
+#include <KDebug>
+#include <kpluginfactory.h>
+#include <kpluginloader.h>
+
+K_PLUGIN_FACTORY(AppMenuFactory,
+                 registerPlugin<AppMenuModule>();
+    )
+K_EXPORT_PLUGIN(AppMenuFactory("appmenu"))
+
+static const char *DBUSMENU_INTERFACE = "com.canonical.dbusmenu";
+static const char *KDED_INTERFACE = "org.kde.kded";
+static const char *KDED_PATH = "/kded";
+static const char *KDED_APPMENU_PATH = "/modules/appmenu";
+
+
+//DBusMenuLayoutItem
+QDBusArgument &operator<<(QDBusArgument &argument, const DBusMenuLayoutItem &obj)
+{
+    argument.beginStructure();
+    argument << obj.id << obj.properties;
+    argument.beginArray(qMetaTypeId<QDBusVariant>());
+    Q_FOREACH(const DBusMenuLayoutItem& child, obj.children) {
+        argument << QDBusVariant(QVariant::fromValue<DBusMenuLayoutItem>(child));
+    }
+    argument.endArray();
+    argument.endStructure();
+    return argument;
+}
+//DBusMenuLayoutItem
+const QDBusArgument &operator>>(const QDBusArgument &argument, DBusMenuLayoutItem &obj)
+{
+    argument.beginStructure();
+    argument >> obj.id >> obj.properties;
+    argument.beginArray();
+    while (!argument.atEnd()) {
+        QDBusVariant dbusVariant;
+        argument >> dbusVariant;
+        QDBusArgument childArgument = dbusVariant.variant().value<QDBusArgument>();
+
+        DBusMenuLayoutItem child;
+        childArgument >> child;
+        obj.children.append(child);
+    }
+    argument.endArray();
+    argument.endStructure();
+    return argument;
+}
+
+AppMenuModule::AppMenuModule(QObject* parent, const QList<QVariant>&)
+    : KDEDModule(parent),
+    mRegistrar(new Registrar(parent)),
+    mClients(0)
+{
+    mRegistrar->connectToBus();
+
+    QDBusConnection::sessionBus().connect("", "", DBUSMENU_INTERFACE, "LayoutUpdated",
+                                          this, SLOT(slotLayoutUpdated(uint,int)));
+    QDBusConnection::sessionBus().connect("", KDED_APPMENU_PATH, KDED_INTERFACE, "clientsUpdate",
+                                          this, SLOT(slotClientsUpdated(int)));
+}
+
+AppMenuModule::~AppMenuModule()
+{
+    delete mRegistrar;
+    QDBusConnection::sessionBus().disconnect("", "", DBUSMENU_INTERFACE, "LayoutUpdated",
+                                             this, SLOT(slotLayoutUpdated(uint,int)));
+    QDBusConnection::sessionBus().disconnect("", KDED_APPMENU_PATH, KDED_INTERFACE, "clientsUpdate",
+                                             this, SLOT(slotClientsUpdated(int)));
+}
+
+void AppMenuModule::slotLayoutUpdated(uint revision, int parentId)
+{
+    if (parentId == 0) { //root menu
+        DBusMenuLayoutItem root;
+        QDBusMessage msg = QDBusMessage::createMethodCall(message().service(), message().path(), DBUSMENU_INTERFACE, "GetLayout");
+        msg.setArguments(QList<QVariant>() << 0 << 1 << QStringList());
+        QDBusMessage reply = QDBusConnection::sessionBus().call(msg, QDBus::Block, 3000);
+        if (reply.arguments().size() == 2) {
+            QDBusArgument arg = reply.arguments()[1].value<QDBusArgument>();
+            arg >> root;
+            foreach (const DBusMenuLayoutItem &dbusMenuItem, root.children) {
+                msg = QDBusMessage::createMethodCall(message().service(), message().path(), DBUSMENU_INTERFACE, "AboutToShow");
+                msg.setArguments(QList<QVariant>() << dbusMenuItem.id);
+                QDBusConnection::sessionBus().call(msg, QDBus::NoBlock);
+            }
+        }
+    }
+}
+
+void AppMenuModule::slotClientsUpdated(int i)
+{
+    mClients += i;
+
+    if (!mClients) {
+        QDBusInterface kded(KDED_INTERFACE, KDED_PATH, KDED_INTERFACE);
+
+        QDBusReply<bool> reply = kded.call("unloadModule", "appmenu");
+
+        if (!reply.isValid()) {
+            kError() << "Error talking to KDED";
+            return;
+        }
+        if (!reply.value()) {
+            kWarning() << "KDED could not load appmenud";
+            return;
+        }
+    }
+}
+
+#include "appmenu.moc"
+
diff -Nru -x .git kde-workspace/appmenu/module/appmenu.desktop kde-workspace-appmenu/appmenu/module/appmenu.desktop
--- kde-workspace/appmenu/module/appmenu.desktop	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/appmenu.desktop	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,29 @@
+[Desktop Entry]
+Type=Service
+Name=Application menus daemon
+Name[es]=Demonio de menús de aplicaciones
+Name[et]=Rakenduste menüü deemon
+Name[nl]=Daemon voor menu's van toepassingen
+Name[pl]=Demon menu programów
+Name[pt]=Servidor dos menus da aplicaçãoApplication menus daemon
+Name[pt_BR]=Servidor dos menus do aplicativo
+Name[sv]=Demon för programmenyer
+Name[uk]=Фонова служба меню програм
+Name[x-test]=xxApplication menus daemonxx
+Comment=Transfers application's menu to the desktop
+Comment[de]=Überträgt Anwendungsmenüs auf die Arbeitsfläche
+Comment[es]=Transfiere menús de aplicaciones al escritorio
+Comment[et]=Rakenduste menüü paigutamine töölauale
+Comment[nl]=Verplaatst menu's van toepassingen naar het bureaublad
+Comment[pl]=Przenosi menu aplikacji na pulpit
+Comment[pt]=Transfere o menu da aplicação para o ecrã
+Comment[pt_BR]=Transfere o menu do aplicativo para a área de trabalho
+Comment[sv]=Överför programmets meny till skrivbordet
+Comment[uk]=Передає меню програм на стільницю
+Comment[x-test]=xxTransfers application's menu to the desktopxx
+X-KDE-ServiceTypes=KDEDModule
+X-KDE-Library=appmenu
+X-KDE-DBus-ModuleName=appmenu
+X-KDE-Kded-autoload=false
+X-KDE-Kded-load-on-demand=true
+
diff -Nru -x .git kde-workspace/appmenu/module/appmenu.h kde-workspace-appmenu/appmenu/module/appmenu.h
--- kde-workspace/appmenu/module/appmenu.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/appmenu.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2010 Canonical Ltd.
+ * Copyright (c) 2010 Aurélien Gâteau <aurelien.gateau@canonical.com>
+ * Copyright (c) 2011  Lionel Chauvin <megabigbug@yahoo.fr>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef APPMENUMODULE_H
+#define APPMENUMODULE_H
+
+#include <QDBusServiceWatcher>
+
+#include <kdedmodule.h>
+#include "registrar.h"
+
+/**
+ * Represents an item with its children. GetLayout() returns a
+ * DBusMenuLayoutItemList.
+ */
+struct DBusMenuLayoutItem
+{
+    int id;
+    QVariantMap properties;
+    QList<DBusMenuLayoutItem> children;
+};
+Q_DECLARE_METATYPE(DBusMenuLayoutItem)
+
+class AppMenuModule : public KDEDModule,
+                      protected QDBusContext
+{
+    Q_OBJECT
+public:
+    AppMenuModule(QObject* parent, const QList<QVariant>& list);
+    virtual ~AppMenuModule();
+
+private Q_SLOTS:
+    void slotLayoutUpdated(uint revision, int id);
+    void slotClientsUpdated(int i);
+
+private:
+    Registrar *mRegistrar;
+    unsigned int mClients;
+};
+
+#endif
diff -Nru -x .git kde-workspace/appmenu/module/CMakeLists.txt kde-workspace-appmenu/appmenu/module/CMakeLists.txt
--- kde-workspace/appmenu/module/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/CMakeLists.txt	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,23 @@
+include_directories(
+    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_BINARY_DIR}
+    )
+
+set(kded_appmenu_SRCS
+    appmenu.cpp
+    registrar.cpp
+    )
+
+qt4_add_dbus_adaptor(kded_appmenu_SRCS com.canonical.AppMenu.Registrar.xml
+    registrar.h Registrar registraradaptor RegistrarAdaptor)
+
+kde4_add_plugin(kded_appmenu ${kded_appmenu_SRCS})
+
+target_link_libraries(kded_appmenu  ${KDE4_KIO_LIBS} ${X11_LIBRARIES})
+
+install(TARGETS kded_appmenu  DESTINATION ${PLUGIN_INSTALL_DIR} )
+
+########### install files ###############
+
+install( FILES appmenu.desktop  DESTINATION  ${SERVICES_INSTALL_DIR}/kded )
+install( FILES com.canonical.AppMenu.Registrar.xml DESTINATION ${DBUS_INTERFACES_INSTALL_DIR} )
\ Pas de fin de ligne à la fin du fichier
diff -Nru -x .git kde-workspace/appmenu/module/com.canonical.AppMenu.Registrar.xml kde-workspace-appmenu/appmenu/module/com.canonical.AppMenu.Registrar.xml
--- kde-workspace/appmenu/module/com.canonical.AppMenu.Registrar.xml	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/com.canonical.AppMenu.Registrar.xml	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,82 @@
+<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN" "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
+<node xmlns:dox="http://www.ayatana.org/dbus/dox.dtd">
+	<dox:d><![CDATA[
+	  @mainpage
+	 
+	  An interface to register menus that are associated with a window in an application.  The
+	  main interface is docuemented here: @ref com::canonical::AppMenu::Registrar.
+	    
+	  The actual menus are transported using the dbusmenu protocol which is available
+	  here: @ref com::canonical::dbusmenu.
+	]]></dox:d>
+	<interface name="com.canonical.AppMenu.Registrar" xmlns:dox="http://www.ayatana.org/dbus/dox.dtd">
+		<dox:d>
+		  An interface to register a menu from an application's window to be displayed in another
+		  window.  This manages that association between XWindow Window IDs and the dbus
+		  address and object that provides the menu using the dbusmenu dbus interface.
+		</dox:d>
+		<method name="RegisterWindow">
+			<dox:d><![CDATA[
+			  Associates a dbusmenu with a window
+	     
+			  /note this method assumes that the connection from the caller is the DBus connection
+			    to use for the object.  Applications that use multiple DBus connections will need to
+			    ensure this method is called with the same connection that implmenets the object.
+			]]></dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="in">
+				<dox:d>The object on the dbus interface implementing the dbusmenu interface</dox:d>
+			</arg>
+		</method>
+		<method name="UnregisterWindow">
+			<dox:d>
+			  A method to allow removing a window from the database.  Windows will also be removed
+			  when the client drops off DBus so this is not required.  It is polite though.  And
+			  important for testing.
+			</dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+		</method>
+		<method name="GetMenuForWindow">
+			<dox:d>Gets the registered menu for a given window ID.</dox:d>
+			<arg name="windowId" type="u" direction="in">
+				<dox:d>The XWindow ID of the window to get</dox:d>
+			</arg>
+			<arg name="service" type="s" direction="out">
+				<dox:d>The address of the connection on DBus (e.g. :1.23 or org.example.service)</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="out">
+				<dox:d>The path to the object which implements the com.canonical.dbusmenu interface.</dox:d>
+			</arg>
+		</method>
+		<method name="GetMenus">
+			<annotation name="com.trolltech.QtDBus.QtTypeName.Out0" value="MenuInfoList"/>
+			<dox:d>Gets the information on all menus that the registrar knows about.  This
+			  is useful for debugging or bringing up a new renderer.</dox:d>
+			<arg name="menus" type="a(uso)" direction="out">
+				<dox:d>An array of structures containing the same parameters as @GetMenuForWindow.  Window ID, Service and ObjectPath.</dox:d>
+			</arg>
+		</method>
+		<signal name="WindowRegistered">
+			<dox:d>Signals when the registrar gets a new menu registered</dox:d>
+			<arg name="windowId" type="u" direction="out">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+			<arg name="service" type="s" direction="out">
+				<dox:d>The address of the connection on DBus (e.g. :1.23 or org.example.service)</dox:d>
+			</arg>
+			<arg name="menuObjectPath" type="o" direction="out">
+				<dox:d>The path to the object which implements the com.canonical.dbusmenu interface.</dox:d>
+			</arg>
+		</signal>
+		<signal name="WindowUnregistered">
+			<dox:d>Signals when the registrar removes a menu registration</dox:d>
+			<arg name="windowId" type="u" direction="out">
+				<dox:d>The XWindow ID of the window</dox:d>
+			</arg>
+		</signal>
+	</interface>
+</node>
diff -Nru -x .git kde-workspace/appmenu/module/registrar.cpp kde-workspace-appmenu/appmenu/module/registrar.cpp
--- kde-workspace/appmenu/module/registrar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/registrar.cpp	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2010 Canonical Ltd.
+ * Copyright (c) 2010 Aurélien Gâteau <aurelien.gateau@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+// Self
+#include "registrar.h"
+
+// Qt
+#include <QApplication>
+#include <QDBusMessage>
+#include <QDBusObjectPath>
+#include <QDBusServiceWatcher>
+
+// KDE
+#include <KDebug>
+
+// Local
+#include "registraradaptor.h"
+
+static const char* DBUS_SERVICE = "com.canonical.AppMenu.Registrar";
+static const char* DBUS_OBJECT_PATH = "/com/canonical/AppMenu/Registrar";
+
+// Marshalling code for MenuInfo
+QDBusArgument& operator<<(QDBusArgument& argument, const MenuInfo& info)
+{
+    argument.beginStructure();
+    argument << info.winId << info.service << info.path;
+    argument.endStructure();
+    return argument;
+}
+
+const QDBusArgument& operator>>(const QDBusArgument& argument, MenuInfo& info)
+{
+    argument.beginStructure();
+    argument >> info.winId >> info.service >> info.path;
+    argument.endStructure();
+    return argument;
+}
+
+Registrar::Registrar(QObject* parent)
+: QObject(parent)
+, mServiceWatcher(new QDBusServiceWatcher(this))
+{
+    qDBusRegisterMetaType<MenuInfo>();
+    qDBusRegisterMetaType<MenuInfoList>();
+    mServiceWatcher->setConnection(QDBusConnection::sessionBus());
+    mServiceWatcher->setWatchMode(QDBusServiceWatcher::WatchForUnregistration);
+    connect(mServiceWatcher, SIGNAL(serviceUnregistered(const QString&)), SLOT(slotServiceUnregistered(const QString&)));
+}
+
+Registrar::~Registrar()
+{
+    QDBusConnection::sessionBus().unregisterService(mService);
+}
+
+bool Registrar::connectToBus(const QString& _service, const QString& _path)
+{
+    mService = _service.isEmpty() ? DBUS_SERVICE : _service;
+    QString path = _path.isEmpty() ? DBUS_OBJECT_PATH : _path;
+
+    bool ok = QDBusConnection::sessionBus().registerService(mService);
+    if (!ok) {
+        return false;
+    }
+    new RegistrarAdaptor(this);
+    QDBusConnection::sessionBus().registerObject(path, this);
+
+    return true;
+}
+
+void Registrar::RegisterWindow(uint wid, const QDBusObjectPath& menuObjectPath)
+{
+    MenuInfo info;
+    info.winId = wid;
+    info.service = message().service();
+    info.path = menuObjectPath;
+    mDb.insert(wid, info);
+    mServiceWatcher->addWatchedService(info.service);
+    WindowRegistered(wid, info.service, info.path);
+}
+
+void Registrar::UnregisterWindow(uint wid)
+{
+    mDb.remove(wid);
+    WindowUnregistered(wid);
+}
+
+QString Registrar::GetMenuForWindow(WId winId, QDBusObjectPath& menuObjectPath)
+{
+    MenuInfo info = mDb.value(winId);
+    QString service = info.service;
+    menuObjectPath = info.path;
+    return service;
+}
+
+MenuInfoList Registrar::GetMenus()
+{
+    return mDb.values();
+}
+
+void Registrar::slotServiceUnregistered(const QString& service)
+{
+    MenuInfoDb::Iterator
+        it = mDb.begin(),
+        end = mDb.end();
+    for (;it != end;) {
+        if (it.value().service == service) {
+            WId id = it.key();
+            it = mDb.erase(it);
+            WindowUnregistered(id);
+        } else {
+            ++it;
+        }
+    }
+    mServiceWatcher->removeWatchedService(service);
+}
diff -Nru -x .git kde-workspace/appmenu/module/registrar.h kde-workspace-appmenu/appmenu/module/registrar.h
--- kde-workspace/appmenu/module/registrar.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/appmenu/module/registrar.h	2012-04-26 12:06:44.497997108 +0200
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2010 Canonical Ltd.
+ * Copyright (c) 2010 Aurélien Gâteau <aurelien.gateau@canonical.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef REGISTRAR_H
+#define REGISTRAR_H
+
+// Qt
+#include <QDBusContext>
+#include <QDBusObjectPath>
+#include <QObject>
+#include <QWidget> // For WId
+
+#include "../lib/menuinfo.h"
+
+class QDBusObjectPath;
+class QDBusServiceWatcher;
+class QMenu;
+
+class Registrar : public QObject, protected QDBusContext
+{
+    Q_OBJECT
+
+public:
+    Registrar(QObject*);
+    ~Registrar();
+
+    bool connectToBus(const QString& service = QString(), const QString& objectPath = QString());
+
+Q_SIGNALS:
+    void WindowRegistered(uint wid, const QString& service, const QDBusObjectPath&);
+    void WindowUnregistered(uint wid);
+
+public Q_SLOTS:
+    Q_NOREPLY void RegisterWindow(uint wid, const QDBusObjectPath& menuObjectPath);
+    Q_NOREPLY void UnregisterWindow(uint wid);
+    QString GetMenuForWindow(WId wid, QDBusObjectPath& menuObjectPath);
+    MenuInfoList GetMenus();
+
+private Q_SLOTS:
+    void slotServiceUnregistered(const QString& service);
+
+private:
+    QDBusServiceWatcher* mServiceWatcher;
+    typedef QHash<WId, MenuInfo> MenuInfoDb;
+    MenuInfoDb mDb;
+    QString mService;
+};
+
+#endif /* REGISTRAR_H */
diff -Nru -x .git kde-workspace/CMakeLists.txt kde-workspace-appmenu/CMakeLists.txt
--- kde-workspace/CMakeLists.txt	2012-06-07 09:28:12.770437926 +0200
+++ kde-workspace-appmenu/CMakeLists.txt	2012-06-07 08:56:57.283866468 +0200
@@ -145,6 +145,7 @@
    macro_optional_add_subdirectory(kstartupconfig)
    macro_optional_add_subdirectory(freespacenotifier)
    macro_optional_add_subdirectory(kscreensaver)
+   macro_optional_add_subdirectory(appmenu)
 
    # data
    macro_optional_add_subdirectory(doc)
diff -Nru -x .git kde-workspace/kwin/bridge.cpp kde-workspace-appmenu/kwin/bridge.cpp
--- kde-workspace/kwin/bridge.cpp	2012-06-07 09:28:13.107104576 +0200
+++ kde-workspace-appmenu/kwin/bridge.cpp	2012-06-07 08:56:57.273866469 +0200
@@ -23,6 +23,10 @@
 #include "client.h"
 #include "options.h"
 
+#ifdef KWIN_BUILD_KAPPMENU
+#include "menubar.h"
+#endif
+
 #include <kconfiggroup.h>
 
 namespace KWin
@@ -95,6 +99,27 @@
     return c->shadeMode() != ShadeNone;
 }
 
+bool Bridge::hasApplicationMenu() const
+{
+#ifdef KWIN_BUILD_KAPPMENU
+    return Workspace::self()->hasApplicationMenu(c->window());
+#else
+    return false;
+#endif
+}
+
+void Bridge::showApplicationMenu()
+{
+#ifdef KWIN_BUILD_KAPPMENU
+    //overlay horizontal menubar
+    if (Workspace::self()->applicationMenuType() == KWin::Options::ApplicationMenuBar) {
+        Workspace::self()->showApplicationMenuBar(c->window(), geometry());
+    } else if (Workspace::self()->applicationMenuType() == KWin::Options::ApplicationMenu) {
+        Workspace::self()->showApplicationMenu(c->window());
+    }
+#endif
+}
+
 void Bridge::showWindowMenu(const QPoint &p)
 {
     c->workspace()->showWindowMenu(QRect(p,p), c);
diff -Nru -x .git kde-workspace/kwin/bridge.h kde-workspace-appmenu/kwin/bridge.h
--- kde-workspace/kwin/bridge.h	2012-06-07 09:28:13.107104576 +0200
+++ kde-workspace-appmenu/kwin/bridge.h	2012-04-26 12:06:45.117997077 +0200
@@ -21,6 +21,8 @@
 #ifndef KWIN_BRIDGE_H
 #define KWIN_BRIDGE_H
 
+#include "config-kwin.h"
+
 #include <kdecorationbridge.h>
 
 namespace KWin
@@ -51,6 +53,8 @@
     virtual QIcon icon() const;
     virtual QString caption() const;
     virtual void processMousePressEvent(QMouseEvent*);
+    virtual bool hasApplicationMenu() const;
+    virtual void showApplicationMenu();
     virtual void showWindowMenu(const QPoint &);
     virtual void showWindowMenu(const QRect &);
     virtual void performWindowOperation(WindowOperation);
diff -Nru -x .git kde-workspace/kwin/client.cpp kde-workspace-appmenu/kwin/client.cpp
--- kde-workspace/kwin/client.cpp	2012-06-07 09:28:13.107104576 +0200
+++ kde-workspace-appmenu/kwin/client.cpp	2012-06-07 08:56:57.273866469 +0200
@@ -396,6 +396,12 @@
     if (!noBorder()) {
         setMask(QRegion());  // Reset shape mask
         decoration = workspace()->createDecoration(bridge);
+#ifdef KWIN_BUILD_KAPPMENU
+        connect(this, SIGNAL(appMenuAboutToHide()), decoration, SIGNAL(appMenuAboutToHide()));
+        connect(this, SIGNAL(appMenuAvailable()), decoration, SIGNAL(appMenuAvailable()));
+        connect(this, SIGNAL(appMenuUnavailable()), decoration, SIGNAL(appMenuUnavailable()));
+        connect(this, SIGNAL(moveResizedChanged()), decoration, SIGNAL(clientMoveChanged()));
+#endif
         // TODO: Check decoration's minimum size?
         decoration->init();
         decoration->widget()->installEventFilter(this);
diff -Nru -x .git kde-workspace/kwin/client.h kde-workspace-appmenu/kwin/client.h
--- kde-workspace/kwin/client.h	2012-06-07 09:28:13.107104576 +0200
+++ kde-workspace-appmenu/kwin/client.h	2012-06-07 08:56:57.267199802 +0200
@@ -636,6 +636,18 @@
     void setSessionInteract(bool needed);
     virtual bool isClient() const;
 
+#ifdef KWIN_BUILD_KAPPMENU
+    void emitAppMenuAvailable() {
+        emit appMenuAvailable();
+    }
+    void emitAppMenuUnavailable() {
+        emit appMenuUnavailable();
+    }
+    QRect appMenuButtonPos() {
+        return decoration->property("AppMenuButtonPosition").toRect();
+    }
+#endif
+
 public slots:
     void closeWindow();
 
@@ -725,6 +737,20 @@
      * another group, but not when a Client gets added or removed to the Client's ClientGroup.
      **/
     void tabGroupChanged();
+
+    /**
+     * Emitted whenever the Client's menu is available
+     **/
+    void appMenuAvailable();
+    /**
+     * Emitted whenever the Client's menu is unavailable
+     */
+    void appMenuUnavailable();
+    /**
+     * Emitted whenever the Client's menu is about to close
+     **/
+    void appMenuAboutToHide();
+
     /**
      * Emitted whenever the demands attention state changes.
      **/
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenbutton.cpp kde-workspace-appmenu/kwin/clients/oxygen/oxygenbutton.cpp
--- kde-workspace/kwin/clients/oxygen/oxygenbutton.cpp	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenbutton.cpp	2012-04-26 12:06:45.161330408 +0200
@@ -70,6 +70,10 @@
         _glowAnimation->setPropertyName( "glowIntensity" );
         _glowAnimation->setEasingCurve( QEasingCurve::InOutQuad );
 
+#ifdef KWIN_BUILD_KAPPMENU
+        if ( _type == ButtonApplicationMenu )
+            connect(&_client, SIGNAL(appMenuAboutToHide()), this, SLOT(updateAppMenuButton()));
+#endif
         // setup connections
         reset(0);
 
@@ -338,6 +342,14 @@
             painter->translate(-1.5, -1.5);
             break;
 
+#ifdef KWIN_BUILD_KAPPMENU
+            case ButtonApplicationMenu:
+            painter->drawLine(QPointF(7.5, 7.5), QPointF(13.5, 7.5));
+            painter->drawLine(QPointF(7.5, 10.5), QPointF(13.5, 10.5));
+            painter->drawLine(QPointF(7.5, 13.5), QPointF(13.5, 13.5));
+            break;
+#endif
+
             case ButtonMin:
             painter->drawLine(QPointF( 7.5, 9.5), QPointF(10.5,12.5));
             painter->drawLine(QPointF(10.5,12.5), QPointF(13.5, 9.5));
@@ -410,4 +422,12 @@
         return;
     }
 
+    //___________________________________________________
+    void Button::updateAppMenuButton()
+    {
+#ifdef KWIN_BUILD_KAPPMENU
+        _status &= ~Pressed;
+        update();
+#endif
+    }
 }
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenbutton.h kde-workspace-appmenu/kwin/clients/oxygen/oxygenbutton.h
--- kde-workspace/kwin/clients/oxygen/oxygenbutton.h	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenbutton.h	2012-04-26 12:06:45.161330408 +0200
@@ -28,6 +28,7 @@
 // IN THE SOFTWARE.
 //////////////////////////////////////////////////////////////////////////////
 
+#include <config-kwin.h>
 #include <kcommondecoration.h>
 
 #include "oxygenfactory.h"
@@ -173,6 +174,10 @@
 
         //@}
 
+        private slots:
+        //! restore button state when application menu hidden
+        void updateAppMenuButton();
+
         private:
 
         //! parent client
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenclient.cpp kde-workspace-appmenu/kwin/clients/oxygen/oxygenclient.cpp
--- kde-workspace/kwin/clients/oxygen/oxygenclient.cpp	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenclient.cpp	2012-06-07 08:56:57.267199802 +0200
@@ -210,8 +210,11 @@
         switch (type) {
 
             case MenuButton:
-            return new Button(*this, i18n("Menu"), ButtonMenu);
-
+            return new Button(*this, i18n("Window Menu"), ButtonMenu);
+#ifdef KWIN_BUILD_KAPPMENU
+            case AppMenuButton:
+            return new Button(*this, i18n("Application Menu"), ButtonApplicationMenu);
+#endif
             case HelpButton:
             return new Button(*this, i18n("Help"), ButtonHelp);
 
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenclient.h kde-workspace-appmenu/kwin/clients/oxygen/oxygenclient.h
--- kde-workspace/kwin/clients/oxygen/oxygenclient.h	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenclient.h	2012-06-07 08:56:57.260533136 +0200
@@ -36,6 +36,7 @@
 #include "oxygenshadowcache.h"
 #include "oxygentitleanimationdata.h"
 
+#include <config-kwin.h>
 #include <kcommondecoration.h>
 #include <QtCore/QBasicTimer>
 #include <QtCore/QTextStream>
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenfactory.cpp kde-workspace-appmenu/kwin/clients/oxygen/oxygenfactory.cpp
--- kde-workspace/kwin/clients/oxygen/oxygenfactory.cpp	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenfactory.cpp	2012-06-07 08:56:57.260533136 +0200
@@ -144,6 +144,9 @@
 
             // buttons
             case AbilityButtonMenu:
+#ifdef KWIN_BUILD_KAPPMENU
+            case AbilityButtonApplicationMenu:
+#endif
             case AbilityButtonHelp:
             case AbilityButtonMinimize:
             case AbilityButtonMaximize:
diff -Nru -x .git kde-workspace/kwin/clients/oxygen/oxygenfactory.h kde-workspace-appmenu/kwin/clients/oxygen/oxygenfactory.h
--- kde-workspace/kwin/clients/oxygen/oxygenfactory.h	2012-06-07 09:28:13.113771242 +0200
+++ kde-workspace-appmenu/kwin/clients/oxygen/oxygenfactory.h	2012-04-26 12:06:45.161330408 +0200
@@ -48,6 +48,9 @@
         ButtonMin,
         ButtonClose,
         ButtonMenu,
+#ifdef KWIN_BUILD_KAPPMENU
+        ButtonApplicationMenu,
+#endif
         ButtonSticky,
         ButtonAbove,
         ButtonBelow,
diff -Nru -x .git kde-workspace/kwin/CMakeLists.txt kde-workspace-appmenu/kwin/CMakeLists.txt
--- kde-workspace/kwin/CMakeLists.txt	2012-06-07 09:28:13.107104576 +0200
+++ kde-workspace-appmenu/kwin/CMakeLists.txt	2012-06-07 08:56:57.273866469 +0200
@@ -7,6 +7,7 @@
 OPTION(KWIN_BUILD_TILING "Enable building of KWin Tiling functionality" ON)
 OPTION(KWIN_BUILD_SCREENEDGES "Enable building of KWin with screen edge support" ON)
 OPTION(KWIN_BUILD_SCRIPTING "Enable building of KWin with scripting support" ON)
+OPTION(KWIN_BUILD_KAPPMENU "Enable building of KWin with application menu support" ON)
 OPTION(KWIN_BUILD_XRENDER_COMPOSITING "Enable building of KWin with XRender Compositing support" ON)
 OPTION(KWIN_BUILD_ACTIVITIES "Enable building of KWin with kactivities support" ON)
 if(${KDE_PLATFORM_PROFILE} STREQUAL "Desktop")
@@ -24,6 +25,7 @@
     set(KWIN_BUILD_TILING OFF)
     set(KWIN_BUILD_SCREENEDGES OFF)
     set(KWIN_BUILD_SCRIPTING ON)
+    set(KWIN_BUILD_KAPPMENU OFF)
     set(KWIN_BUILD_XRENDER_COMPOSITING OFF)
     set(KWIN_MOBILE_EFFECTS ON)
     set(KWIN_BUILD_WITH_OPENGLES ON)
@@ -60,6 +62,13 @@
     ${CMAKE_CURRENT_SOURCE_DIR}/tabbox
     )
 
+if(KWIN_BUILD_KAPPMENU)
+    include_directories(${KDEBASE_WORKSPACE_SOURCE_DIR}/appmenu/lib
+                        ${DBUSMENUQT_INCLUDE_DIR}
+    )
+    set(kwin_KDEINIT_SRCS ${kwin_KDEINIT_SRCS} menubar.cpp)
+endif(KWIN_BUILD_KAPPMENU)
+
 add_subdirectory( libkdecorations )
 add_subdirectory( libkwineffects )
 add_subdirectory( killer )
@@ -170,6 +179,14 @@
     )
 endif(KWIN_BUILD_SCREENEDGES)
 
+if(KWIN_BUILD_KAPPMENU)
+    set(
+        kwin_KDEINIT_SRCS ${kwin_KDEINIT_SRCS}
+        menubar.cpp
+    )
+endif(KWIN_BUILD_KAPPMENU)
+
+
 qt4_add_dbus_adaptor( kwin_KDEINIT_SRCS org.kde.KWin.xml workspace.h KWin::Workspace )
 
 qt4_add_dbus_interface( kwin_KDEINIT_SRCS
@@ -190,6 +207,10 @@
     set(kwinLibs ${kwinLibs} ${QT_QTSCRIPT_LIBRARY})
 endif(KWIN_BUILD_SCRIPTING)
 
+if(KWIN_BUILD_KAPPMENU)
+    set(kwinLibs ${kwinLibs} ${DBUSMENUQT_LIBRARIES} kappmenu)
+endif(KWIN_BUILD_KAPPMENU)
+
 if(KWIN_BUILD_ACTIVITIES)
     set(kwinLibs ${kwinLibs} ${KACTIVITIES_LIBRARY})
 endif(KWIN_BUILD_ACTIVITIES)
diff -Nru -x .git kde-workspace/kwin/config-kwin.h.cmake kde-workspace-appmenu/kwin/config-kwin.h.cmake
--- kde-workspace/kwin/config-kwin.h.cmake	2012-06-07 09:28:13.117104575 +0200
+++ kde-workspace-appmenu/kwin/config-kwin.h.cmake	2012-06-07 08:56:57.260533136 +0200
@@ -4,6 +4,7 @@
 #cmakedefine KWIN_BUILD_DESKTOPCHANGEOSD 1
 #cmakedefine KWIN_BUILD_SCREENEDGES 1
 #cmakedefine KWIN_BUILD_SCRIPTING 1
+#cmakedefine KWIN_BUILD_KAPPMENU 1
 #cmakedefine KWIN_BUILD_ACTIVITIES 1
 #define KWIN_NAME "${KWIN_NAME}"
 #define KWIN_CONFIG "${KWIN_NAME}rc"
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwindecoration/buttons.cpp kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/buttons.cpp
--- kde-workspace/kwin/kcmkwin/kwindecoration/buttons.cpp	2012-06-07 09:28:13.150437907 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/buttons.cpp	2012-04-26 12:06:45.197997073 +0200
@@ -31,6 +31,7 @@
 
 #include "buttons.h"
 #include "pixmaps.h"
+#include "config-kwin.h"
 
 #include <QApplication>
 #include <QPainter>
@@ -41,7 +42,9 @@
 
 #include <klocale.h>
 #include <kglobalsettings.h>
-
+#ifdef KWIN_BUILD_KAPPMENU
+#include <kappmenuimporter.h>
+#endif
 #include <kdecorationfactory.h>
 
 
@@ -680,7 +683,18 @@
 
     // insert all possible buttons into the source (backwards to keep the preferred order...)
     bool dummy;
-    m_supportedButtons = "MSHIAX_FBLR"; // support all buttons
+
+#ifdef KWIN_BUILD_KAPPMENU
+    if (KAppMenuImporter::available()) {
+        m_supportedButtons = "MNSHIAX_FBLR"; // support all buttons
+        new ButtonSourceItem(m_buttonSource, getButton('N', dummy));
+    } else {
+#endif
+        m_supportedButtons = "MSHIAX_FBLR";
+#ifdef KWIN_BUILD_KAPPMENU
+    }
+#endif
+
     new ButtonSourceItem(m_buttonSource, getButton('R', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('L', dummy));
     new ButtonSourceItem(m_buttonSource, getButton('B', dummy));
@@ -741,7 +755,13 @@
     } else if (type == 'M') {
         QBitmap bmp = QBitmap::fromData(QSize(menu_width, menu_height), menu_bits);
         bmp.createMaskFromColor(Qt::white);
-        return Button(i18n("Menu"), bmp, 'M', false, m_supportedButtons.contains('M'));
+        return Button(i18nc("Button showing window actions menu", "Window Menu"), bmp, 'M', false, m_supportedButtons.contains('M'));
+#ifdef KWIN_BUILD_KAPPMENU
+    } else if (type == 'N') {
+        QBitmap bmp = QBitmap::fromData(QSize(menu_width, menu_height), menu_bits);
+        bmp.createMaskFromColor(Qt::white);
+        return Button(i18nc("Button showing application menu imported from dbusmenu", "Application Menu"), bmp, 'N', false, m_supportedButtons.contains('N'));
+#endif
     } else if (type == '_') {
         QBitmap bmp = QBitmap::fromData(QSize(spacer_width, spacer_height), spacer_bits);
         bmp.createMaskFromColor(Qt::white);
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwindecoration/CMakeLists.txt kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/CMakeLists.txt
--- kde-workspace/kwin/kcmkwin/kwindecoration/CMakeLists.txt	2012-06-07 09:28:13.150437907 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/CMakeLists.txt	2012-04-26 12:06:45.197997073 +0200
@@ -3,6 +3,10 @@
     ${KDEBASE_WORKSPACE_SOURCE_DIR}/kwin/clients/aurorae/src/lib
 )
 
+if(KWIN_BUILD_KAPPMENU)
+    include_directories(${KDEBASE_WORKSPACE_SOURCE_DIR}/appmenu/lib)
+endif(KWIN_BUILD_KAPPMENU)    
+
 set(AURORAE_SOURCE_DIR ${KDEBASE_WORKSPACE_SOURCE_DIR}/kwin/clients/aurorae/src/lib/)
 
 set(kcm_kwindecoration_PART_SRCS
@@ -24,7 +28,11 @@
 )
 
 kde4_add_plugin(kcm_kwindecoration ${kcm_kwindecoration_PART_SRCS})
-target_link_libraries(kcm_kwindecoration ${KDE4_KNEWSTUFF3_LIBS} kdecorations ${QT_QTDECLARATIVE_LIBRARY} ${X11_LIBRARIES})
+if(KWIN_BUILD_KAPPMENU)
+	target_link_libraries(kcm_kwindecoration ${KDE4_KNEWSTUFF3_LIBS} kdecorations kappmenu ${QT_QTDECLARATIVE_LIBRARY} ${X11_LIBRARIES})
+else(NOT KWIN_BUILD_KAPPMENU)
+	target_link_libraries(kcm_kwindecoration ${KDE4_KNEWSTUFF3_LIBS} kdecorations ${QT_QTDECLARATIVE_LIBRARY} ${X11_LIBRARIES})
+endif(KWIN_BUILD_KAPPMENU)
 install(TARGETS kcm_kwindecoration  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
 ########### install files ###############
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwindecoration/preview.cpp kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/preview.cpp
--- kde-workspace/kwin/kcmkwin/kwindecoration/preview.cpp	2012-06-07 09:28:13.150437907 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/preview.cpp	2012-04-26 12:06:45.197997073 +0200
@@ -372,6 +372,19 @@
 {
 }
 
+bool KDecorationPreviewBridge::hasApplicationMenu() const
+{
+    return false;
+}
+
+void KDecorationPreviewBridge::showApplicationMenu()
+{
+}
+
+void KDecorationPreviewBridge::setApplicationMenuIsLeft(bool)
+{
+}
+
 void KDecorationPreviewBridge::showWindowMenu(const QRect &)
 {
 }
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwindecoration/preview.h kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/preview.h
--- kde-workspace/kwin/kcmkwin/kwindecoration/preview.h	2012-06-07 09:28:13.150437907 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwindecoration/preview.h	2012-04-26 12:06:45.197997073 +0200
@@ -92,6 +92,9 @@
     virtual QIcon icon() const;
     virtual QString caption() const;
     virtual void processMousePressEvent(QMouseEvent*);
+    virtual bool hasApplicationMenu() const;
+    virtual void showApplicationMenu();
+    virtual void setApplicationMenuIsLeft(bool);
     virtual void showWindowMenu(const QRect &);
     virtual void showWindowMenu(const QPoint &);
     virtual void performWindowOperation(WindowOperation);
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwinoptions/windows.cpp kde-workspace-appmenu/kwin/kcmkwin/kwinoptions/windows.cpp
--- kde-workspace/kwin/kcmkwin/kwinoptions/windows.cpp	2012-06-07 09:28:13.153771240 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwinoptions/windows.cpp	2012-06-07 08:58:16.797195767 +0200
@@ -22,6 +22,7 @@
  */
 
 #include <config-workspace.h>
+#include <config-kwin.h>
 
 #include <QApplication>
 #include <QCheckBox>
@@ -34,10 +35,16 @@
 #include <QtDBus/QtDBus>
 
 #include <KButtonGroup>
+#include <kaction.h>
+#include <kactioncollection.h>
 #include <klocale.h>
 #include <knuminput.h>
 #include <kdialog.h>
 
+#ifdef KWIN_BUILD_KAPPMENU
+#include <KKeySequenceWidget>
+#endif
+
 #include <X11/X.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
@@ -47,6 +54,9 @@
 // kwin config keywords
 #define KWIN_FOCUS                 "FocusPolicy"
 #define KWIN_PLACEMENT             "Placement"
+#ifdef KWIN_BUILD_KAPPMENU
+#define KWIN_APPMENU               "ApplicationMenu"
+#endif
 #define KWIN_GEOMETRY              "GeometryTip"
 #define KWIN_AUTORAISE_INTERVAL    "AutoRaiseInterval"
 #define KWIN_AUTORAISE             "AutoRaise"
@@ -632,13 +642,68 @@
 
     connect(placementCombo, SIGNAL(activated(int)), SLOT(changed()));
 
+#ifdef KWIN_BUILD_KAPPMENU
+    m_actionCollection = new KActionCollection(this, KComponentData("kwin"));
+    m_actionCollection->setConfigGroup("Show application menu");
+    m_actionCollection->setConfigGlobal(true);
+
+    KAction *a = static_cast< KAction* >(m_actionCollection->addAction("Show application menu"));
+    a->setGlobalShortcut(KShortcut(Qt::ALT + Qt::Key_M));
+    a->setProperty("isConfigurationAction", true);
+
+    appmenuCombo = new KComboBox(this);
+    appmenuCombo->setEditable(false);
+    appmenuCombo->addItem(i18n("In application menu"), APPLICATION_MENU_NONE);
+    appmenuCombo->addItem(i18n("Overlay menubar"), APPLICATION_MENUBAR);
+    appmenuCombo->addItem(i18n("Menu popup"), APPLICATION_MENU);
+    appmenuCombo->setCurrentIndex(APPLICATION_MENU_NONE);
+
+    // FIXME, when more policies have been added to KWin
+    wtstr = i18n("This option control where the application menu"
+                 " will appear. To show menu, just configure global shortcut or add"
+                 " a menu button to your title bar."
+                 " <ul>"
+                 " <li><em>In application menu</em> Traditional in application menu</li>"
+                 " <li><em>Vertical menu</em> Popup a vertical menu</li>"
+                 " <li><em>Horizontal menu</em> Popup a horizontal menu</li>"
+                 "</ul>") ;
+
+    appmenuCombo->setWhatsThis(wtstr);
+
+    appmenuCombo->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);
+    label = new QLabel(i18n("&Application menu type:"), this);
+    label->setAlignment(Qt::AlignVCenter | Qt::AlignRight);
+    label->setBuddy(appmenuCombo);
+    vLay->addWidget(label, 1, 0);
+    vLay->addWidget(appmenuCombo, 1, 1);
+
+    KKeySequenceWidget *keyWidget = new KKeySequenceWidget(this);
+    if (KAction *a = qobject_cast< KAction* >(m_actionCollection->action("Show application menu")))
+        keyWidget->setKeySequence(a->globalShortcut().primary());
+    keyWidget->setProperty("multiKeyShortcutsAllowed", true);
+    keyWidget->setProperty("checkForConflictsAgainst", QVariant(KKeySequenceWidget::LocalShortcuts
+                                                              | KKeySequenceWidget::StandardShortcuts
+                                                              | KKeySequenceWidget::GlobalShortcuts));
+    label = new QLabel(i18n("Shortcut:"), this);
+    label->setAlignment(Qt::AlignVCenter | Qt::AlignRight);
+    vLay->addWidget(label, 1, 2);
+    vLay->addWidget(keyWidget, 1, 3);
+
+    connect(appmenuCombo, SIGNAL(activated(int)), SLOT(changed()));
+    connect(keyWidget, SIGNAL(keySequenceChanged(QKeySequence)), this, SLOT(appMenuShortcutChanged(QKeySequence)));
+#endif
+
     hideUtilityWindowsForInactive = new QCheckBox(i18n("Hide utility windows for inactive applications"), this);
     hideUtilityWindowsForInactive->setWhatsThis(
         i18n("When turned on, utility windows (tool windows, torn-off menus,...) of inactive applications will be"
              " hidden and will be shown only when the application becomes active. Note that applications"
              " have to mark the windows with the proper window type for this feature to work."));
     connect(hideUtilityWindowsForInactive, SIGNAL(toggled(bool)), SLOT(changed()));
+#ifdef KWIN_BUILD_KAPPMENU
+    vLay->addWidget(hideUtilityWindowsForInactive, 2, 0, 2, 2);
+#else
     vLay->addWidget(hideUtilityWindowsForInactive, 1, 0, 1, 2);
+#endif
 
     tilBox = new KButtonGroup(this);
     tilBox->setTitle(i18n("Tiling"));
@@ -721,6 +786,13 @@
     shadeHover->setEnabled(a);
 }
 
+void KAdvancedConfig::appMenuShortcutChanged(QKeySequence s)
+{
+    if (KAction *a = qobject_cast< KAction* >(m_actionCollection->action("Show application menu")))
+        a->setGlobalShortcut(KShortcut(s), KAction::ActiveShortcut, KAction::NoAutoloading);
+    m_actionCollection->writeSettings();
+}
+
 void KAdvancedConfig::setTilingOn(bool on)
 {
     tilingOn->setChecked(on);
@@ -789,6 +861,9 @@
     placementCombo->setCurrentIndex(idx);
 //  }
 
+#ifdef KWIN_BUILD_KAPPMENU
+    setApplicationMenu(cg.readEntry(KWIN_APPMENU, "none"));
+#endif
     setHideUtilityWindowsForInactive(cg.readEntry(KWIN_HIDE_UTILITY, true));
     setInactiveTabsSkipTaskbar(cg.readEntry(KWIN_INACTIVE_SKIP_TASKBAR, false));
     setAutogroupSimilarWindows(cg.readEntry(KWIN_AUTOGROUP_SIMILAR, false));
@@ -822,6 +897,10 @@
 //       cg.writeEntry(KWIN_PLACEMENT, tmpstr);
 //   }
 
+#ifdef KWIN_BUILD_KAPPMENU
+    cg.writeEntry(KWIN_APPMENU, getApplicationMenu());
+#endif
+
     cg.writeEntry(KWIN_HIDE_UTILITY, hideUtilityWindowsForInactive->isChecked());
     cg.writeEntry(KWIN_INACTIVE_SKIP_TASKBAR, inactiveTabsSkipTaskbar->isChecked());
     cg.writeEntry(KWIN_AUTOGROUP_SIMILAR, autogroupSimilarWindows->isChecked());
@@ -857,6 +936,30 @@
     emit KCModule::changed(true);
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+QString KAdvancedConfig::getApplicationMenu(void)
+{
+    switch (appmenuCombo->currentIndex()) {
+        case APPLICATION_MENU_NONE: return "none";
+        case APPLICATION_MENUBAR: return "menubar";
+        case APPLICATION_MENU: return "menu";
+        default: return "none";
+    }
+}
+
+void KAdvancedConfig::setApplicationMenu(QString s)
+{
+    unsigned int index;
+    if (s == "menubar") {
+        index = APPLICATION_MENUBAR;
+    } else if (s == "menu") {
+        index = APPLICATION_MENU;
+    } else {
+        index = APPLICATION_MENU_NONE;
+    }
+    appmenuCombo->setCurrentIndex(index);
+}
+#endif
 
 void KAdvancedConfig::setHideUtilityWindowsForInactive(bool s)
 {
diff -Nru -x .git kde-workspace/kwin/kcmkwin/kwinoptions/windows.h kde-workspace-appmenu/kwin/kcmkwin/kwinoptions/windows.h
--- kde-workspace/kwin/kcmkwin/kwinoptions/windows.h	2012-06-07 09:28:13.153771240 +0200
+++ kde-workspace-appmenu/kwin/kcmkwin/kwinoptions/windows.h	2012-06-07 08:58:32.253861330 +0200
@@ -25,6 +25,7 @@
 #include <QWidget>
 #include <kcmodule.h>
 #include <config-workspace.h>
+#include <config-kwin.h>
 
 class QRadioButton;
 class QCheckBox;
@@ -34,6 +35,7 @@
 class QLabel;
 class QSlider;
 class KButtonGroup;
+class KActionCollection;
 // class QSpinBox;
 
 class KColorButton;
@@ -45,6 +47,21 @@
 #define TITLEBAR_PLAIN  0
 #define TITLEBAR_SHADED 1
 
+#define SMART_PLACEMENT        0
+#define MAXIMIZING_PLACEMENT   1
+#define CASCADE_PLACEMENT      2
+#define RANDOM_PLACEMENT       3
+#define CENTERED_PLACEMENT     4
+#define ZEROCORNERED_PLACEMENT 5
+#define INTERACTIVE_PLACEMENT  6
+#define MANUAL_PLACEMENT       7
+
+#ifdef KWIN_BUILD_KAPPMENU
+#define APPLICATION_MENU_NONE  0
+#define APPLICATION_MENUBAR    1
+#define APPLICATION_MENU       2
+#endif
+
 #define  CLICK_TO_FOCUS               0
 #define  FOCUS_FOLLOWS_MOUSE          1
 #define  FOCUS_UNDER_MOUSE            2
@@ -176,6 +193,7 @@
 
 private slots:
     void shadeHoverChanged(bool);
+    void appMenuShortcutChanged(QKeySequence);
 
     void changed() {
         emit KCModule::changed(true);
@@ -211,6 +229,13 @@
 
     KComboBox *placementCombo;
 
+#ifdef KWIN_BUILD_KAPPMENU
+    QString getApplicationMenu(void);
+    void setApplicationMenu(QString);
+    KComboBox *appmenuCombo;
+    KActionCollection* m_actionCollection;
+#endif
+
     // ------------------------------
     // Tiling related widgets/methods
     // ------------------------------
diff -Nru -x .git kde-workspace/kwin/kwinbindings.cpp kde-workspace-appmenu/kwin/kwinbindings.cpp
--- kde-workspace/kwin/kwinbindings.cpp	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/kwinbindings.cpp	2012-06-07 08:56:57.257199803 +0200
@@ -131,6 +131,10 @@
     0, slotIncreaseWindowOpacity());
 DEF2("Decrease Opacity", I18N_NOOP("Decrease Opacity of Active Window by 5 %"),
     0, slotLowerWindowOpacity());
+#ifdef KWIN_BUILD_KAPPMENU
+DEF2("Show application menu", I18N_NOOP("Show application menu"),
+    Qt::ALT + Qt::Key_M, slotShowApplicationMenu());
+#endif
 
 a = actionCollection->addAction("Group:Window Desktop");
 a->setText(i18n("Window & Desktop"));
diff -Nru -x .git kde-workspace/kwin/kwin.kcfg kde-workspace-appmenu/kwin/kwin.kcfg
--- kde-workspace/kwin/kwin.kcfg	2012-06-07 09:28:13.160437906 +0200
+++ kde-workspace-appmenu/kwin/kwin.kcfg	2012-04-26 12:06:45.227997072 +0200
@@ -43,6 +43,7 @@
   <entry key="RollOverDesktops" type="Bool" />
   <entry key="FocusStealingPreventionLevel" type="Int" />
   <entry key="Placement" type="String" />
+  <entry key="ApplicationMenu" type="Int" />
   <entry key="AutoRaise" type="Bool" />
   <entry key="AutoRaiseInterval" type="Int" />
   <entry key="DelayFocus" type="Bool" />
diff -Nru -x .git kde-workspace/kwin/libkdecorations/kcommondecoration.cpp kde-workspace-appmenu/kwin/libkdecorations/kcommondecoration.cpp
--- kde-workspace/kwin/libkdecorations/kcommondecoration.cpp	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/libkdecorations/kcommondecoration.cpp	2012-04-26 12:06:45.231330405 +0200
@@ -377,7 +377,7 @@
                 if (!m_button[MenuButton]) {
                     btn = createButton(MenuButton);
                     if (!btn) break;
-                    btn->setTipText(i18n("Menu"));
+                    btn->setTipText(i18nc("Button showing window actions menu", "Window Menu"));
                     btn->setRealizeButtons(Qt::LeftButton | Qt::RightButton);
                     connect(btn, SIGNAL(pressed()), SLOT(menuButtonPressed()));
                     connect(btn, SIGNAL(released()), this, SLOT(menuButtonReleased()));
@@ -388,6 +388,24 @@
                     m_button[MenuButton] = btn;
                 }
                 break;
+#ifdef KWIN_BUILD_KAPPMENU
+             case 'N': // Application Menu button
+                if (!m_button[AppMenuButton]) {
+                    btn = createButton(AppMenuButton);
+                    if (!btn) break;
+                    btn->setTipText(i18nc("Button showing application menu", "Application Menu"));
+                    btn->setRealizeButtons(Qt::LeftButton);
+                    connect(btn, SIGNAL(pressed()), SLOT(appMenuButtonPressed()));
+                    connect(decoration(), SIGNAL(appMenuAvailable()), this, SLOT(appMenuAvailable()));
+                    connect(decoration(), SIGNAL(appMenuUnavailable()), this, SLOT(appMenuUnavailable()));
+                    connect(decoration(), SIGNAL(clientMoveChanged()), this, SLOT(updateAppMenuButtonPosition()));
+
+                    // fix double deletion, see objDestroyed()
+                    connect(btn, SIGNAL(destroyed(QObject*)), this, SLOT(objDestroyed(QObject*)));
+                    m_button[AppMenuButton] = btn;
+                }
+                break;
+#endif
             case 'S': // OnAllDesktops button
                 if (!m_button[OnAllDesktopsButton]) {
                     btn = createButton(OnAllDesktopsButton);
@@ -516,7 +534,19 @@
             if (btn) {
                 btn->setLeft(isLeft);
                 btn->setSize(QSize(layoutMetric(LM_ButtonWidth, true, btn), layoutMetric(LM_ButtonHeight, true, btn)));
-                btn->show();
+#ifdef KWIN_BUILD_KAPPMENU
+                // Only show button if menu available, will be shown later on window registration
+                if (btn->type() == AppMenuButton) {
+                    if (wrapper->hasApplicationMenu()) {
+                        btn->show();
+                    }
+                }
+                else
+#endif
+                {
+                    btn->show();
+                }
+
                 btnContainer.append(btn);
             }
 
@@ -556,8 +586,16 @@
 
             if (! btnArray[i]->isHidden())
                 break; // all buttons shown...
-
-            btnArray[i]->show();
+#ifdef KWIN_BUILD_KAPPMENU
+            if (btnArray[i]->type() == AppMenuButton) {
+                if (wrapper->hasApplicationMenu()) {
+                    btnArray[i]->show();
+                }
+            } else
+#endif
+            {
+                btnArray[i]->show();
+            }
         }
     }
 }
@@ -755,6 +793,44 @@
     showWindowMenu(QRect(menutop, menubottom));
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+void KCommonDecoration::appMenuButtonPressed()
+{
+    wrapper->showApplicationMenu();
+
+    KDecorationFactory* f = factory();
+    if (!f->exists(decoration()))   // 'this' was deleted
+        return;
+    m_button[AppMenuButton]->setDown(false);
+}
+
+void KCommonDecoration::appMenuAvailable()
+{
+    if (m_button[AppMenuButton]) {
+        m_button[AppMenuButton]->show();
+        updateLayout();
+    }
+}
+
+void KCommonDecoration::appMenuUnavailable()
+{
+    if (m_button[AppMenuButton]) {
+        m_button[AppMenuButton]->hide();
+        updateLayout();
+    }
+}
+
+void KCommonDecoration::updateAppMenuButtonPosition()
+{
+    if (m_button[AppMenuButton]) {
+        QRect menuRect = m_button[AppMenuButton]->rect();
+        QPoint globalTopLeft = m_button[AppMenuButton]->mapToGlobal(menuRect.topLeft());
+        QRect globalMenuRect = QRect(globalTopLeft, menuRect.size());
+        decoration()->setProperty("AppMenuButtonPosition", globalMenuRect);
+    }
+}
+#endif
+
 void KCommonDecoration::resizeEvent(QResizeEvent */*e*/)
 {
     if (decorationBehaviour(DB_ButtonHide))
@@ -1054,7 +1130,15 @@
     QAbstractButton::mouseReleaseEvent(&me);
 }
 
-
+bool KCommonDecorationButton::event(QEvent *e)
+{
+    // update position on paint eventFilter
+    // should be better with QEvent::PolishRequest but it fails with some apps: Kopete for exemple...
+    if (e->type() == QEvent::Paint && m_type == AppMenuButton) {
+        decoration()->updateAppMenuButtonPosition();
+    }
+    return QAbstractButton::event(e);
+}
 
 // *** wrap everything from KDecoration *** //
 bool KCommonDecoration::drawbound(const QRect&, bool)
@@ -1297,6 +1381,9 @@
     : KCommonDecoration(bridge, factory)
 {
     Q_ASSERT(dynamic_cast<const KDecorationUnstable*>(decoration()));
+#ifdef KWIN_BUILD_KAPPMENU
+    connect(decoration(), SIGNAL(appMenuAboutToHide()), this, SIGNAL(appMenuAboutToHide()));
+#endif
 }
 
 KCommonDecorationUnstable::~KCommonDecorationUnstable()
diff -Nru -x .git kde-workspace/kwin/libkdecorations/kcommondecoration.h kde-workspace-appmenu/kwin/libkdecorations/kcommondecoration.h
--- kde-workspace/kwin/libkdecorations/kcommondecoration.h	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/libkdecorations/kcommondecoration.h	2012-04-26 12:06:45.231330405 +0200
@@ -25,6 +25,7 @@
 #ifndef KCOMMONDECORATION_H
 #define KCOMMONDECORATION_H
 
+#include <config-kwin.h>
 #include <QtGui/QAbstractButton>
 #include "kdecoration.h"
 
@@ -40,6 +41,7 @@
     MinButton,
     CloseButton,
     MenuButton,
+    AppMenuButton,
     OnAllDesktopsButton,
     AboveButton,
     BelowButton,
@@ -274,6 +276,12 @@
     void slotKeepBelow();
     void menuButtonPressed();
     void menuButtonReleased();
+#ifdef KWIN_BUILD_KAPPMENU
+    void appMenuButtonPressed();
+    void appMenuAvailable();
+    void appMenuUnavailable();
+    void updateAppMenuButtonPosition();
+#endif
 public:
     virtual Position mousePosition(const QPoint &point) const;
 
@@ -412,9 +420,10 @@
     int tabCount() const;
     long tabId(int idx) const;
     void untab(long id, const QRect& newGeom);
-
     WindowOperation buttonToWindowOperation(Qt::MouseButtons button);
     virtual bool eventFilter(QObject* o, QEvent* e);
+Q_SIGNALS:
+    void appMenuAboutToHide();
 };
 
 /**
@@ -487,6 +496,7 @@
     void setLeft(bool left);
     void mousePressEvent(QMouseEvent *e);
     void mouseReleaseEvent(QMouseEvent *e);
+    bool event(QEvent *e);
 
 private:
     KCommonDecoration *m_decoration;
diff -Nru -x .git kde-workspace/kwin/libkdecorations/kdecorationbridge.h kde-workspace-appmenu/kwin/libkdecorations/kdecorationbridge.h
--- kde-workspace/kwin/libkdecorations/kdecorationbridge.h	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/libkdecorations/kdecorationbridge.h	2012-04-26 12:06:45.234663738 +0200
@@ -26,6 +26,7 @@
 #define KDECORATIONBRIDGE_H
 
 #include "kdecoration.h"
+#include <config-kwin.h>
 #include <QtGui/QWidget>
 
 /** @addtogroup kdecoration */
@@ -113,6 +114,10 @@
     virtual long tabId(int idx) const = 0;
     virtual void untab(long id, const QRect& newGeom) = 0;
     virtual WindowOperation buttonToWindowOperation(Qt::MouseButtons button) = 0;
+#ifdef KWIN_BUILD_KAPPMENU
+    virtual bool hasApplicationMenu() const = 0;
+    virtual void showApplicationMenu() = 0;
+#endif
 };
 
 /** @} */
diff -Nru -x .git kde-workspace/kwin/libkdecorations/kdecoration.cpp kde-workspace-appmenu/kwin/libkdecorations/kdecoration.cpp
--- kde-workspace/kwin/libkdecorations/kdecoration.cpp	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/libkdecorations/kdecoration.cpp	2012-04-26 12:06:45.231330405 +0200
@@ -68,6 +68,7 @@
 KDecoration::~KDecoration()
 {
     factory()->removeDecoration(this);
+
     delete w_;
 }
 
@@ -476,6 +477,18 @@
 
 //END tabbing
 
+#ifdef KWIN_BUILD_KAPPMENU
+bool KDecorationUnstable::hasApplicationMenu() const
+{
+    return static_cast< KDecorationBridgeUnstable* >(bridge_)->hasApplicationMenu();
+}
+
+void KDecorationUnstable::showApplicationMenu()
+{
+    static_cast< KDecorationBridgeUnstable* >(bridge_)->showApplicationMenu();
+}
+#endif
+
 KDecoration::WindowOperation KDecorationUnstable::buttonToWindowOperation(Qt::MouseButtons button)
 {
     return static_cast< KDecorationBridgeUnstable* >(bridge_)->buttonToWindowOperation(button);
diff -Nru -x .git kde-workspace/kwin/libkdecorations/kdecoration.h kde-workspace-appmenu/kwin/libkdecorations/kdecoration.h
--- kde-workspace/kwin/libkdecorations/kdecoration.h	2012-06-07 09:28:13.163771239 +0200
+++ kde-workspace-appmenu/kwin/libkdecorations/kdecoration.h	2012-06-07 08:56:57.257199803 +0200
@@ -25,6 +25,7 @@
 #ifndef KDECORATION_H
 #define KDECORATION_H
 
+#include <config-kwin.h>
 #include <QtGui/QColor>
 #include <QtGui/QFont>
 #include <QtCore/QObject>
@@ -177,7 +178,7 @@
         AbilityAnnounceButtons = 0, ///< decoration supports AbilityButton* values (always use)
         AbilityAnnounceColors = 1, ///< decoration supports AbilityColor* values (always use)
         // buttons
-        AbilityButtonMenu = 1000,   ///< decoration supports the menu button
+        AbilityButtonMenu = 1000,   ///< decoration supports the window menu button
         AbilityButtonOnAllDesktops = 1001, ///< decoration supports the on all desktops button
         AbilityButtonSpacer = 1002, ///< decoration supports inserting spacers between buttons
         AbilityButtonHelp = 1003,   ///< decoration supports what's this help button
@@ -188,6 +189,9 @@
         AbilityButtonBelowOthers = 1008, ///< decoration supports a below button
         AbilityButtonShade = 1009, ///< decoration supports a shade button
         AbilityButtonResize = 1010, ///< decoration supports a resize button
+#ifdef KWIN_BUILD_KAPPMENU
+        AbilityButtonApplicationMenu = 1011,   ///< decoration supports the application menu button
+#endif
         // colors
         AbilityColorTitleBack = 2000, ///< decoration supports titlebar background color
         ABILITYCOLOR_FIRST = AbilityColorTitleBack, ///< @internal
@@ -305,7 +309,8 @@
      * If customButtonPositions() returns true, titleButtonsLeft
      * returns which buttons should be on the left side of the titlebar from left
      * to right. Characters in the returned string have this meaning :
-     * @li 'M' menu button
+     * @li 'N' application menu button
+     * @li 'M' window menu button
      * @li 'S' on_all_desktops button
      * @li 'H' quickhelp button
      * @li 'I' minimize ( iconify ) button
@@ -992,6 +997,16 @@
      * global coordinates specified by \p pos.
      */
     void showWindowMenu(const QPoint& pos, long id);
+#ifdef KWIN_BUILD_KAPPMENU
+    /**
+     * show application menu
+     */
+    void showApplicationMenu();
+    /**
+     * true if an application menu is available
+     */
+    bool hasApplicationMenu() const;
+#endif
     /**
      * unshadow virtuals
      */
@@ -1014,6 +1029,23 @@
      * @since 4.8
      */
     QRegion region(KDecorationDefines::Region r);
+Q_SIGNALS:
+    /**
+     * This signal is emitted whenever application menu becomes available
+     */
+    void appMenuAvailable();
+    /**
+     * This signal is emitted whenever application menu becomes unavailable
+     */
+    void appMenuUnavailable();
+    /**
+     * This signal is emitted whenever an application menu is closed
+     */
+    void appMenuAboutToHide();
+    /**
+     * This signal is emitted whenever client is moved
+     */
+    void clientMoveChanged();
 };
 
 inline
diff -Nru -x .git kde-workspace/kwin/menubar.cpp kde-workspace-appmenu/kwin/menubar.cpp
--- kde-workspace/kwin/menubar.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/kwin/menubar.cpp	2012-04-26 12:06:45.237997071 +0200
@@ -0,0 +1,371 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright  2012    Cédric Bellegarde <gnumdk@gmail.com>
+Copyright  2009    Aurélien Gâteau <agateau@kde.org>
+Inspirated by plasma-widget-menubar
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+
+#include "menubar.h"
+
+// Qt
+#include <QGraphicsLinearLayout>
+#include <QPainter>
+#include <QMenu>
+#include <QToolButton>
+#include <QDesktopWidget>
+
+// KDE
+#include <KWindowSystem>
+#include <Plasma/FrameSvg>
+#include <Plasma/Label>
+#include <Plasma/Meter>
+#include <Plasma/Theme>
+#include <Plasma/WindowEffects>
+#include <KApplication>
+
+MenuBarWidget::MenuBarWidget(MenuBar *parent, QMenu *menu) :
+    QGraphicsWidget(),
+    m_mouseTimer(new QTimer(this)),
+    m_layout(new QGraphicsLinearLayout(this)),
+    m_parent(parent),
+    m_currentButton(0),
+    m_menu(menu)
+{
+    m_mouseTimer->setInterval(50);
+    connect(m_mouseTimer, SIGNAL(timeout()), SLOT(slotCheckActiveItem()));
+    m_layout->setContentsMargins(0, 0, 0, 0);
+}
+
+MenuBarWidget::~MenuBarWidget()
+{
+    delete m_mouseTimer;
+    while (!m_buttons.isEmpty()) {
+        delete m_buttons.front();
+        m_buttons.pop_front();
+    }
+}
+
+void MenuBarWidget::updateLayout()
+{
+    if (!m_menu) return;
+
+    foreach( QAction* action, m_menu->actions() )
+    {
+        QMenu *menu = action->menu();
+        action->setShortcut(QKeySequence());
+        MenuButton* button;
+        if( action->isSeparator() || !menu )
+            continue;
+
+        //Create a new button, we do not set menu here as it may have changed on showMenu()
+        button = new MenuButton(this);
+        button->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Minimum);
+        button->setText(action->text());
+        button->setMenu(action->menu());
+        connect(button, SIGNAL(clicked()), SLOT(slotButtonClicked()));
+        m_layout->addItem(button);
+        m_buttons << button;
+    }
+}
+
+bool MenuBarWidget::eventFilter(QObject* object, QEvent* event)
+{
+    QMenu *menu = static_cast<QMenu*>(object);
+
+    if (event->type() == QEvent::KeyPress) {
+        menu->removeEventFilter(this);
+        QApplication::sendEvent(menu, event);
+        menu->installEventFilter(this);
+        if (!event->isAccepted()) {
+            QKeyEvent* keyEvent = static_cast<QKeyEvent*>(event);
+            switch (keyEvent->key()) {
+            case Qt::Key_Left:
+                showLeftRightMenu(false);
+                break;
+            case Qt::Key_Right:
+                showLeftRightMenu(true);
+                break;
+            case Qt::Key_Escape:
+                menu->hide();
+                break;
+            default:
+                break;
+            }
+        }
+        return true;
+    }
+    return false;
+}
+
+void MenuBarWidget::slotCheckActiveItem()
+{
+    MenuButton* buttonBelow = 0;
+    QPoint pos =  m_parent->mapFromGlobal(QCursor::pos());
+    QGraphicsItem* item = m_parent->itemAt(pos);
+
+    if (item)
+        buttonBelow = qobject_cast<MenuButton*>(item->toGraphicsObject());
+
+    if (!buttonBelow)
+        return;
+
+    if (buttonBelow != m_currentButton) {
+        if (m_currentButton) {
+            m_currentButton->nativeWidget()->setDown(false);
+            QMenu *menu = m_currentButton->menu();
+            if (menu) {
+                disconnect(menu, SIGNAL(aboutToHide()), this, SLOT(slotMenuAboutToHide()));
+                menu->hide();
+            }
+        }
+        m_currentButton = buttonBelow;
+        m_currentButton->nativeWidget()->setDown(true);
+        showMenu();
+    }
+}
+
+void MenuBarWidget::slotMenuAboutToHide()
+{
+    m_currentButton->setDown( false );
+    m_parent->hide();
+}
+
+void MenuBarWidget::slotButtonClicked()
+{
+    m_currentButton = qobject_cast<MenuButton*>(sender());
+
+    m_currentButton->nativeWidget()->setDown(true);
+    showMenu();
+}
+
+bool MenuBarWidget::menuVisible()
+{
+    QMenu *menu = 0;
+    foreach(MenuButton *button, m_buttons) {
+        if (button) {
+            menu = button->menu();
+        }
+        if (menu && menu->isVisible())
+            return true;
+    }
+    return false;
+}
+
+void MenuBarWidget::activateAction(QAction *action)
+{
+    m_currentButton = m_buttons.first();
+
+    if (action) {
+        QMenu *menu;
+        foreach (MenuButton *button, m_buttons) {
+            menu = button->menu();
+            if (menu && menu == action->menu()) {
+                m_currentButton = button;
+                break;
+            }
+        }
+    }
+    m_currentButton->nativeWidget()->animateClick();
+    m_parent->hideTimerStop();
+}
+
+void MenuBarWidget::showMenu()
+{
+    QMenu *menu = 0;
+    //Look for submenu, we do not use m_currentButton->menu() as menu may have changed.
+    foreach (QAction *action, m_menu->actions()) {
+        if (m_currentButton->text() == action->text()) {
+            menu = action->menu();
+            break;
+        }
+    }
+
+    if (menu) {
+        QPoint globalPos = m_parent->mapToGlobal(QPoint(0,0));
+        QPointF parentPos =  m_currentButton->mapFromParent(QPoint(0,0));
+        QRect screen = KApplication::desktop()->screenGeometry();
+        int x = globalPos.x() - parentPos.x();
+        int y = globalPos.y() + m_currentButton->size().height() - parentPos.y();
+
+        m_currentButton->setMenu(menu);
+        menu->popup(QPoint(x, y));
+
+        // Fix offscreen menu
+        if (menu->size().height() + y > screen.height() + screen.y()) {
+            y = globalPos.y() - parentPos.y() - menu->size().height();
+            if (menu->size().width() + x > screen.width() + screen.x())
+                x = screen.width() + screen.x() - menu->size().width();
+            else if (menu->size().width() + x < screen.x())
+                x = screen.x();
+            menu->move(x, y);
+        }
+
+        connect(menu, SIGNAL(aboutToHide()), this, SLOT(slotMenuAboutToHide()));
+
+        installEventFilterForAll(menu, this);
+        m_parent->hideTimerStop();
+    }
+}
+
+void MenuBarWidget::showLeftRightMenu(bool next)
+{
+    int index = m_buttons.indexOf(m_currentButton);
+    if (index == -1) {
+        kWarning() << "Couldn't find button!";
+        return;
+    }
+    if (next) {
+        index = (index + 1) % m_buttons.count();
+    } else {
+        index = (index == 0 ? m_buttons.count() : index) - 1;
+    }
+
+    QMenu *menu = m_currentButton->menu();
+
+    if (menu) {
+        disconnect(menu, SIGNAL(aboutToHide()), this, SLOT(slotMenuAboutToHide()));
+        menu->hide();
+    }
+
+    m_currentButton->setDown(false);
+    m_currentButton = m_buttons.at(index);
+    m_currentButton->nativeWidget()->setDown(true);
+    showMenu();
+}
+
+void MenuBarWidget::installEventFilterForAll(QMenu *menu, QObject *object)
+{
+    menu->installEventFilter(this);
+
+    foreach (QAction *action, menu->actions()) {
+        if (action->menu())
+            installEventFilterForAll(action->menu(), object);
+    }
+}
+
+//____________________________________________________________________________________
+
+MenuBar::MenuBar(QMenu *menu, unsigned int wid)
+    : QGraphicsView(),
+    m_hideTimer(new QTimer(this)),
+    m_background(new Plasma::FrameSvg(this)),
+    m_scene(new QGraphicsScene(this)),
+    m_container(new MenuBarWidget(this, menu)),
+    m_wid(wid)
+{
+    m_hideTimer->setInterval(3000);
+    m_hideTimer->setSingleShot(true);
+    connect(m_hideTimer, SIGNAL(timeout()), this, SLOT(slotHide()));
+
+    //Setup the window properties
+    setWindowFlags(Qt::X11BypassWindowManagerHint);
+    setFrameStyle(QFrame::NoFrame);
+    viewport()->setAutoFillBackground(false);
+    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    setAttribute(Qt::WA_TranslucentBackground);
+
+    //Setup the widgets
+    m_background->setImagePath("widgets/tooltip");
+
+    m_container->updateLayout();
+
+    m_scene->addItem(m_container);
+
+    setScene(m_scene);
+}
+
+MenuBar::~MenuBar()
+{
+    delete m_container;
+}
+
+//FIXME: What is offset = 8 when compositingActive()?
+void MenuBar::setPosition(QPoint pos, bool buttonLeft, int screenWidth)
+{
+    QSizeF sh = sizeHint();
+    int offset = KWindowSystem::compositingActive() ? 8 : 0;
+    int x = buttonLeft ? pos.x() - offset : pos.x() - sh.width() + offset + 1;
+    int y = pos.y() - offset;
+
+    // Don't want menubar to be offscreen
+    if (buttonLeft) {
+        if (x + sh.width() > screenWidth)
+            x = screenWidth - sh.width() + offset;
+    } else {
+        if (x - offset < 0)
+            x = - offset;
+    }
+
+    setGeometry(x, y , sh.width(), sh.height());
+}
+
+QSize MenuBar::sizeHint() const
+{
+    qreal left, top, right, bottom;
+    QSizeF size = m_container->preferredSize();
+    m_background->getMargins(left, top, right, bottom);
+    return QSize(size.width() + left + right, size.height() + top + bottom);
+}
+
+void MenuBar::show()
+{
+    QGraphicsView::show();
+    m_container->startMouseTimer();
+    m_hideTimer->start();
+}
+
+void MenuBar::hide()
+{
+    aboutToHide();
+    m_container->stopMouseTimer();
+    QGraphicsView::hide();
+}
+
+void MenuBar::slotHide()
+{
+    if (!m_container->menuVisible())
+        hide();
+}
+void MenuBar::drawBackground(QPainter *painter, const QRectF &/*rectF*/)
+{
+    painter->save();
+    painter->setCompositionMode(QPainter::CompositionMode_Source);
+    m_background->paintFrame(painter);
+    painter->restore();
+}
+
+void MenuBar::resizeEvent(QResizeEvent*)
+{
+    m_background->resizeFrame(size());
+    m_container->setGeometry(0, 0, width(), height());
+    qreal left, top, right, bottom;
+    m_background->getMargins(left, top, right, bottom);
+    m_container->layout()->setContentsMargins(left, top, right, bottom);
+
+    m_scene->setSceneRect(0, 0, width(), height());
+    if (!KWindowSystem::compositingActive()) {
+        setMask(m_background->mask());
+    }
+}
+
+void MenuBar::showEvent(QShowEvent *)
+{
+    Plasma::WindowEffects::overrideShadow(winId(), true);
+    Plasma::WindowEffects::enableBlurBehind(winId(), true, m_background->mask());
+}
diff -Nru -x .git kde-workspace/kwin/menubar.h kde-workspace-appmenu/kwin/menubar.h
--- kde-workspace/kwin/menubar.h	1970-01-01 01:00:00.000000000 +0100
+++ kde-workspace-appmenu/kwin/menubar.h	2012-04-26 12:06:45.237997071 +0200
@@ -0,0 +1,140 @@
+/********************************************************************
+ KWin - the KDE window manager
+ This file is part of the KDE project.
+
+Copyright  2012    Cédric Bellegarde <gnumdk@gmail.com>
+Copyright  2009    Aurélien Gâteau <agateau@kde.org>
+Inspirated by plasma-widget-menubar
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*********************************************************************/
+#ifndef MENUBAR__H
+#define MENUBAR__H
+
+#include <QGraphicsView>
+#include <QTimer>
+#include <QGraphicsWidget>
+#include <Plasma/ToolButton>
+
+class QGraphicsLinearLayout;
+class MenuBar;
+
+namespace Plasma
+{
+class FrameSvg;
+class Label;
+class Meter;
+}
+
+class MenuButton : public Plasma::ToolButton
+{
+Q_OBJECT
+public:
+    MenuButton(QGraphicsWidget *parent):
+    Plasma::ToolButton(parent),
+    m_menu(0)
+    {}
+
+    void setMenu(QMenu *menu) { m_menu = menu; }
+    QMenu *menu() { return m_menu; }
+protected:
+    //! disable plasma animations
+    void hoverEnterEvent(QGraphicsSceneHoverEvent *){}
+    void hoverLeaveEvent(QGraphicsSceneHoverEvent *){}
+private:
+    QMenu *m_menu;
+};
+
+class MenuBarWidget : public QGraphicsWidget
+{
+Q_OBJECT
+public:
+    MenuBarWidget(MenuBar *parent = 0, QMenu *menu = 0);
+    ~MenuBarWidget();
+
+    //! Update layout with root menu_
+    void updateLayout();
+    //! True if a menu is visible in menubar
+    bool menuVisible();
+
+    void startMouseTimer() { m_mouseTimer->start(); }
+    void stopMouseTimer() { if (m_mouseTimer->isActive()) m_mouseTimer->stop(); }
+
+    //! Activate action, or first action if null
+    void activateAction(QAction *action);
+
+protected:
+    //! Use to get keyboard events
+    virtual bool eventFilter(QObject*, QEvent*);
+private Q_SLOTS:
+    //! Check active item and active it
+    void slotCheckActiveItem();
+    //! a menu is hidding
+    void slotMenuAboutToHide();
+    //! menubar button clicked
+    void slotButtonClicked();
+
+private:
+    //! Show current button menu
+    void showMenu();
+    //! Show next menu if next, otherwise previous
+    void showLeftRightMenu(bool next);
+    //! Install event filter for menu and it submenus
+    void installEventFilterForAll(QMenu *menu, QObject *object);
+
+    //! Follow mouse position
+    QTimer *m_mouseTimer;
+    QGraphicsLinearLayout *m_layout;
+    QList<MenuButton*> m_buttons;
+    MenuBar *m_parent;
+    MenuButton *m_currentButton;
+    QMenu *m_menu;
+};
+
+class MenuBar : public QGraphicsView
+{
+Q_OBJECT
+public:
+    MenuBar(QMenu *menu = 0, unsigned int wid = 0);
+    ~MenuBar();
+
+    //! Set position at pos
+    void setPosition(QPoint pos, bool buttonLeft, int screenWidth);
+    //! Activate action, first item if null
+    void activateAction(QAction *action) { m_container->activateAction(action); }
+    //! Stop hide timer
+    void hideTimerStop() { if (m_hideTimer->isActive()) m_hideTimer->stop(); }
+    unsigned int getWid() { return m_wid; }
+    QSize sizeHint() const;
+
+    void show();
+    void hide();
+
+private Q_SLOTS:
+    void slotHide();
+Q_SIGNALS:
+    void aboutToHide();
+protected:
+    void drawBackground(QPainter *painter, const QRectF &rectF);
+    void resizeEvent(QResizeEvent *);
+    void showEvent(QShowEvent *event);
+private:
+    QTimer *m_hideTimer;
+    Plasma::FrameSvg *m_background;
+    QGraphicsScene *m_scene;
+    MenuBarWidget *m_container;
+    unsigned int m_wid;
+};
+
+#endif
diff -Nru -x .git kde-workspace/kwin/options.cpp kde-workspace-appmenu/kwin/options.cpp
--- kde-workspace/kwin/options.cpp	2012-06-07 09:28:13.170437906 +0200
+++ kde-workspace-appmenu/kwin/options.cpp	2012-06-07 08:59:50.310524352 +0200
@@ -864,6 +864,12 @@
     setPlacement(Placement::Maximizing);
 #endif
 
+#ifdef KWIN_BUILD_KAPPMENU
+    m_applicationMenuType = applicationMenu(config.readEntry("ApplicationMenu", "ApplicationMenuNone"));
+#else
+    m_applicationMenuType = ApplicationMenuNone;
+#endif
+
     setAutoRaise(config.readEntry("AutoRaise", Options::defaultAutoRaise()));
     setAutoRaiseInterval(config.readEntry("AutoRaiseInterval", Options::defaultAutoRaiseInterval()));
     setDelayFocusInterval(config.readEntry("DelayFocusInterval", Options::defaultDelayFocusInterval()));
@@ -1122,6 +1128,17 @@
     return MouseWheelChangeCurrentTab;
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+Options::ApplicationMenuTypes Options::applicationMenu(const QString &name)
+{
+    QString lowerName = name.toLower();
+    if (lowerName == "none") return ApplicationMenuNone;
+    if (lowerName == "menubar") return ApplicationMenuBar;
+    if (lowerName == "menu") return ApplicationMenu;
+    return ApplicationMenuNone;
+}
+#endif
+
 bool Options::showGeometryTip() const
 {
     return show_geometry_tip;
diff -Nru -x .git kde-workspace/kwin/options.h kde-workspace-appmenu/kwin/options.h
--- kde-workspace/kwin/options.h	2012-06-07 09:28:13.170437906 +0200
+++ kde-workspace-appmenu/kwin/options.h	2012-06-07 09:00:05.997190224 +0200
@@ -44,6 +44,9 @@
     Q_ENUMS(FocusPolicy)
     Q_ENUMS(MouseCommand)
     Q_ENUMS(MouseWheelCommand)
+#ifdef KWIN_BUILD_KAPPMENU
+    Q_ENUMS(ApplicationMenuTypes)
+#endif
 
     Q_PROPERTY(FocusPolicy focusPolicy READ focusPolicy WRITE setFocusPolicy NOTIFY focusPolicyChanged)
     Q_PROPERTY(bool nextFocusPrefersMouse READ isNextFocusPrefersMouse WRITE setNextFocusPrefersMouse NOTIFY nextFocusPrefersMouseChanged)
@@ -173,6 +176,18 @@
     /**
      * Whether to hide utility windows for inactive applications.
      **/
+    Q_PROPERTY(bool hideUtilityWindowsForInactive READ isHideUtilityWindowsForInactive NOTIFY configChanged)
+    Q_PROPERTY(bool inactiveTabsSkipTaskbar READ isInactiveTabsSkipTaskbar NOTIFY configChanged)
+    Q_PROPERTY(bool autogroupSimilarWindows READ isAutogroupSimilarWindows NOTIFY configChanged)
+    Q_PROPERTY(bool autogroupInForeground READ isAutogroupInForeground NOTIFY configChanged)
+#ifdef KWIN_BUILD_KAPPMENU
+    Q_PROPERTY(ApplicationMenuTypes applicationMenuType READ applicationMenuType NOTIFY configChanged)
+#endif
+    Q_PROPERTY(int compositingMode READ compositingMode NOTIFY configChanged)
+    Q_PROPERTY(bool useCompositing READ isUseCompositing NOTIFY configChanged)
+    Q_PROPERTY(bool compositingInitialized READ isCompositingInitialized WRITE setCompositingInitialized NOTIFY configChanged)
+    Q_PROPERTY(int hiddenPreviews READ hiddenPreviews NOTIFY configChanged)
+    Q_PROPERTY(bool unredirectFullscreen READ isUnredirectFullscreen NOTIFY configChanged)
     Q_PROPERTY(bool hideUtilityWindowsForInactive READ isHideUtilityWindowsForInactive WRITE setHideUtilityWindowsForInactive NOTIFY hideUtilityWindowsForInactiveChanged)
     Q_PROPERTY(bool inactiveTabsSkipTaskbar READ isInactiveTabsSkipTaskbar WRITE setInactiveTabsSkipTaskbar NOTIFY inactiveTabsSkipTaskbarChanged)
     Q_PROPERTY(bool autogroupSimilarWindows READ isAutogroupSimilarWindows WRITE setAutogroupSimilarWindows NOTIFY autogroupSimilarWindowsChanged)
@@ -535,6 +551,18 @@
         return m_autogroupInForeground;
     }
 
+    enum ApplicationMenuTypes {
+        ApplicationMenuNone,
+        ApplicationMenuBar,
+        ApplicationMenu
+    };
+#ifdef KWIN_BUILD_KAPPMENU
+    ApplicationMenuTypes applicationMenuType() const {
+        return m_applicationMenuType;
+    }
+
+    static ApplicationMenuTypes applicationMenu(const QString &name);
+#endif
     // Desktop effects
     double animationTimeFactor() const;
 
@@ -1002,7 +1030,9 @@
     bool m_inactiveTabsSkipTaskbar;
     bool m_autogroupSimilarWindows;
     bool m_autogroupInForeground;
-
+#ifdef KWIN_BUILD_KAPPMENU
+    ApplicationMenuTypes m_applicationMenuType;
+#endif
     CompositingType m_compositingMode;
     bool m_useCompositing;
     bool m_compositingInitialized;
diff -Nru -x .git kde-workspace/kwin/scripting/workspace_wrapper.cpp kde-workspace-appmenu/kwin/scripting/workspace_wrapper.cpp
--- kde-workspace/kwin/scripting/workspace_wrapper.cpp	2012-06-07 09:28:13.173771239 +0200
+++ kde-workspace-appmenu/kwin/scripting/workspace_wrapper.cpp	2012-06-07 08:56:57.217199805 +0200
@@ -122,6 +122,8 @@
 SLOTWRAPPER(slotIncreaseWindowOpacity)
 SLOTWRAPPER(slotLowerWindowOpacity)
 
+SLOTWRAPPER(slotShowApplicationMenu)
+
 SLOTWRAPPER(slotWindowOperations)
 SLOTWRAPPER(slotWindowClose)
 SLOTWRAPPER(slotWindowMove)
diff -Nru -x .git kde-workspace/kwin/scripting/workspace_wrapper.h kde-workspace-appmenu/kwin/scripting/workspace_wrapper.h
--- kde-workspace/kwin/scripting/workspace_wrapper.h	2012-06-07 09:28:13.173771239 +0200
+++ kde-workspace-appmenu/kwin/scripting/workspace_wrapper.h	2012-06-07 08:56:57.190533140 +0200
@@ -22,6 +22,8 @@
 #ifndef KWIN_SCRIPTING_WORKSPACE_WRAPPER_H
 #define KWIN_SCRIPTING_WORKSPACE_WRAPPER_H
 
+#include <config-kwin.h>
+
 #include <QtCore/QObject>
 #include <QtCore/QSize>
 #include <kwinglobals.h>
@@ -242,6 +244,8 @@
     void slotIncreaseWindowOpacity();
     void slotLowerWindowOpacity();
 
+    void slotShowApplicationMenu();
+
     void slotWindowOperations();
     void slotWindowClose();
     void slotWindowMove();
diff -Nru -x .git kde-workspace/kwin/useractions.cpp kde-workspace-appmenu/kwin/useractions.cpp
--- kde-workspace/kwin/useractions.cpp	2012-06-07 09:28:13.183771238 +0200
+++ kde-workspace-appmenu/kwin/useractions.cpp	2012-06-07 08:56:57.170533142 +0200
@@ -34,6 +34,9 @@
 #include "client.h"
 #include "workspace.h"
 #include "effects.h"
+#ifdef KWIN_BUILD_KAPPMENU
+#include "menubar.h"
+#endif
 #ifdef KWIN_BUILD_TILING
 #include "tiling/tile.h"
 #include "tiling/tilinglayout.h"
@@ -64,6 +67,9 @@
 #include <kauthorized.h>
 #include <kactioncollection.h>
 #include <kaction.h>
+#ifdef KWIN_BUILD_KAPPMENU
+#include <kappmenuimporter.h>
+#endif
 
 #include "killwindow.h"
 #ifdef KWIN_BUILD_TABBOX
@@ -255,6 +261,13 @@
     active_client->setOpacity(qMax(active_client->opacity() - 0.05, 0.05));
 }
 
+void Workspace::slotShowApplicationMenu()
+{
+#ifdef KWIN_BUILD_KAPPMENU
+    actionActivationRequested(0);
+#endif
+}
+
 /*!
   The client popup menu will become visible soon.
 
@@ -1614,6 +1627,71 @@
         closeActivePopup();
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+/**
+  Shows application menu for wid contraint by rect left/right aligned
+*/
+void Workspace::showApplicationMenuBar(unsigned int wid, const QRect &rect)
+{
+    if (m_applicationMenuImporter == 0) return;
+
+    QMenu *menu = m_applicationMenuImporter->menuForWinId(wid);
+
+    if (menu != 0) {
+        Client *c = 0;
+        foreach (c, clients) {
+            if (c->window() == wid)
+                break;
+        }
+        if (!c) return;
+
+        if (m_menubar != 0) {
+            m_menubar->hide();
+            delete m_menubar;
+            m_menubar = 0;
+        }
+
+        QRect menuButtonRect = c->appMenuButtonPos();
+        bool buttonLeft = menuButtonRect.topRight().x() - menuButtonRect.size().width()/2 < rect.topRight().x() - rect.size().width()/2;
+        int buttonX = buttonLeft ? menuButtonRect.topLeft().x() : menuButtonRect.topRight().x();
+        m_menubar = new MenuBar(menu, wid);
+        m_menubar->setPosition(QPoint(buttonX, rect.topLeft().y()), buttonLeft, workspaceWidth());
+        connect(m_menubar, SIGNAL(aboutToHide()), c, SIGNAL(appMenuAboutToHide()));
+        raiseClient(c);
+        m_menubar->show();
+    }
+}
+
+/**
+  Shows application menu for wid at p
+*/
+void Workspace::showApplicationMenu(unsigned int wid, QAction *action)
+{
+    static QMenu *previousMenu = 0;
+
+    if (m_applicationMenuImporter == 0) return;
+
+    QMenu *menu = m_applicationMenuImporter->menuForWinId(wid);
+    if (menu != 0) {
+        Client *c = 0;
+        foreach (c, clients) {
+            if (c->window() == wid)
+                break;
+        }
+        if (!c) return;
+
+        if (previousMenu != menu) {
+            connect(menu, SIGNAL(aboutToHide()), c, SIGNAL(appMenuAboutToHide()));
+            previousMenu = menu;
+        }
+
+        raiseClient(c);
+        menu->setActiveAction(action);
+        menu->popup(c->appMenuButtonPos().bottomLeft() - QPoint(0, 2));
+    }
+}
+#endif
+
 /*!
   Closes the popup client
  */
diff -Nru -x .git kde-workspace/kwin/workspace.cpp kde-workspace-appmenu/kwin/workspace.cpp
--- kde-workspace/kwin/workspace.cpp	2012-06-07 09:28:13.183771238 +0200
+++ kde-workspace-appmenu/kwin/workspace.cpp	2012-06-07 09:00:19.383856234 +0200
@@ -45,6 +45,9 @@
 #include <QtDBus/QtDBus>
 
 #include "client.h"
+#ifdef KWIN_BUILD_KAPPMENU
+#include "menubar.h"
+#endif
 #ifdef KWIN_BUILD_TABBOX
 #include "tabbox.h"
 #endif
@@ -81,6 +84,9 @@
 #include <kglobalsettings.h>
 #include <kwindowsystem.h>
 #include <kwindowinfo.h>
+#ifdef KWIN_BUILD_KAPPMENU
+#include <kappmenuimporter.h>
+#endif
 
 namespace KWin
 {
@@ -159,6 +165,10 @@
     , transButton(NULL)
     , forceUnredirectCheck(true)
     , m_finishingCompositing(false)
+#ifdef KWIN_BUILD_KAPPMENU
+    , m_applicationMenuImporter(NULL)
+    , m_menubar(NULL)
+#endif
     , m_scripting(NULL)
 {
     // If KWin was already running it saved its configuration after loosing the selection -> Reread
@@ -251,6 +261,19 @@
 
     client_keys = new KActionCollection(this);
 
+#ifdef KWIN_BUILD_KAPPMENU
+    if (options->applicationMenuType() != KWin::Options::ApplicationMenuNone) {
+        m_applicationMenuImporter = new KAppMenuImporter();
+        connect(m_applicationMenuImporter, SIGNAL(windowRegistered(WId)),
+                SLOT(windowMenuRegistered(WId)));
+        connect(m_applicationMenuImporter, SIGNAL(windowUnregistered(WId)),
+                SLOT(windowMenuUnregistered(WId)));
+        connect(m_applicationMenuImporter, SIGNAL(actionActivationRequested(WId, QAction*)),
+                SLOT(actionActivationRequested(WId, QAction*)));
+        connect(options, SIGNAL(configChanged()), SLOT(appMenuConfigChanged()));
+    }
+#endif
+
     m_outline = new Outline();
 
     initShortcuts();
@@ -545,6 +568,12 @@
     delete startup;
     delete initPositioning;
     delete client_keys_dialog;
+#ifdef KWIN_BUILD_KAPPMENU
+    if (m_applicationMenuImporter != NULL)
+        delete m_applicationMenuImporter;
+    if (m_menubar != NULL)
+        delete m_menubar;
+#endif
     while (!rules.isEmpty()) {
         delete rules.front();
         rules.pop_front();
@@ -975,7 +1004,22 @@
     emit configChanged();
     discardPopup();
     updateToolWindows(true);
-
+#ifdef KWIN_BUILD_KAPPMENU
+    if (!m_applicationMenuImporter && options->applicationMenuType() != KWin::Options::ApplicationMenuNone) {
+        m_applicationMenuImporter = new KAppMenuImporter();
+        connect(m_applicationMenuImporter, SIGNAL(windowRegistered(WId)),
+                SLOT(windowMenuRegistered(WId)));
+        connect(m_applicationMenuImporter, SIGNAL(windowUnregistered(WId)),
+                SLOT(windowMenuUnregistered(WId)));
+        connect(m_applicationMenuImporter, SIGNAL(actionActivationRequested(WId, QAction*)),
+                SLOT(actionActivationRequested(WId, QAction*)));
+        connect(options, SIGNAL(configChanged()), SLOT(appMenuConfigChanged()));
+
+    } else if (options->applicationMenuType() == KWin::Options::ApplicationMenuNone) {
+        delete m_applicationMenuImporter;
+        m_applicationMenuImporter = NULL;
+    }
+#endif
     if (hasDecorationPlugin() && mgr->reset(changed)) {
         // Decorations need to be recreated
 
@@ -1828,6 +1872,18 @@
     updateClientArea();
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+bool Workspace::hasApplicationMenu(unsigned int wid) const
+{
+    return m_applicationMenuImporter != NULL && m_applicationMenuImporter->menuForWinId(wid);
+}
+
+int Workspace::applicationMenuType() const
+{
+    return options->applicationMenuType();
+}
+#endif
+
 int Workspace::numScreens() const
 {
     return QApplication::desktop()->screenCount();
@@ -2218,6 +2274,57 @@
     last_cursor_timestamp = CurrentTime;
 }
 
+#ifdef KWIN_BUILD_KAPPMENU
+void Workspace::windowMenuRegistered(WId id)
+{
+    foreach (Client *c, clients) {
+        if (c->window() == id)
+            emit c->emitAppMenuAvailable();
+    }
+}
+
+void Workspace::windowMenuUnregistered(WId id)
+{
+    if (m_menubar != NULL && id == m_menubar->getWid())
+        m_menubar->hide();
+
+}
+
+void Workspace::appMenuConfigChanged()
+{
+    switch (options->applicationMenuType()) {
+    case KWin::Options::ApplicationMenuBar:
+    case KWin::Options::ApplicationMenu:
+        foreach (Client *c, clients) {
+            if (hasApplicationMenu(c->window())) {
+                emit c->emitAppMenuAvailable();
+            }
+        }
+        break;
+    case KWin::Options::ApplicationMenuNone:
+    default:
+        foreach (Client *c, clients) {
+            emit c->emitAppMenuUnavailable();
+        }
+        break;
+    }
+}
+
+void Workspace::actionActivationRequested(WId, QAction *action)
+{
+    if (!active_client||!hasApplicationMenu(active_client->window())) {
+        return;
+    }
+
+    if (options->applicationMenuType() == KWin::Options::ApplicationMenuBar) {
+        showApplicationMenuBar(active_client->window(), active_client->geometry());
+        m_menubar->activateAction(action);
+    } else if (options->applicationMenuType() == KWin::Options::ApplicationMenu) {
+        showApplicationMenu(active_client->window(), action);
+    }
+}
+#endif
+
 void Workspace::checkCursorPos()
 {
     QPoint last = last_cursor_pos;
diff -Nru -x .git kde-workspace/kwin/workspace.h kde-workspace-appmenu/kwin/workspace.h
--- kde-workspace/kwin/workspace.h	2012-06-07 09:28:13.183771238 +0200
+++ kde-workspace-appmenu/kwin/workspace.h	2012-06-07 09:30:47.510428750 +0200
@@ -50,6 +50,10 @@
 
 // TODO: Cleanup the order of things in this .h file
 
+#ifdef KWIN_BUILD_KAPPMENU
+class KAppMenuImporter;
+class MenuBar;
+#endif
 class QMenu;
 class QActionGroup;
 class QStringList;
@@ -397,6 +401,10 @@
     QStringList loadedEffects() const;
     QStringList listOfEffects() const;
 
+#ifdef KWIN_BUILD_KAPPMENU
+    bool hasApplicationMenu(unsigned int wid) const;
+    int applicationMenuType() const;
+#endif
 
     /**
      * Shows the menu operations menu for the client and makes it active if
@@ -410,6 +418,17 @@
     void showWindowMenu(QPoint pos, Client* cl);
     bool windowMenuShown();
 
+#ifdef KWIN_BUILD_KAPPMENU
+    /**
+     * Shows application menubar for wid contraint by rect top
+     */
+    void showApplicationMenuBar(unsigned int wid, const QRect &rect);
+    /**
+     * Shows application menu for wid and activate action
+     */
+    void showApplicationMenu(unsigned int wid, QAction *action = 0);
+#endif
+
     void updateMinimizedOfTransients(Client*);
     void updateOnAllDesktopsOfTransients(Client*);
     void updateOnAllActivitiesOfTransients(Client*);
@@ -600,6 +619,8 @@
     void slotIncreaseWindowOpacity();
     void slotLowerWindowOpacity();
 
+    void slotShowApplicationMenu();
+
     void slotWindowOperations();
     void slotWindowClose();
     void slotWindowMove();
@@ -677,6 +698,28 @@
     void lostCMSelection();
     void resetCursorPosTime();
     void delayedCheckUnredirect();
+
+#ifdef KWIN_BUILD_KAPPMENU
+    /**
+     * When a window is registered over dbus, update decoration
+     * Some application do not have menu when window is mapped
+     */
+    void windowMenuRegistered(WId id);
+    /**
+     * When a window is unregistered over dbus, remove any menu to prevent
+     * access to null menu
+     */
+    void windowMenuUnregistered(WId id);
+    /**
+     * When application menu type changed, add or remove application menu button
+     */
+    void appMenuConfigChanged();
+    /**
+     * When an action is requested by keyboard
+     */
+    void actionActivationRequested(WId, QAction* action = 0);
+#endif
+
     void updateCurrentActivity(const QString &new_activity);
     void activityRemoved(const QString &activity);
     void activityAdded(const QString &activity);
@@ -925,6 +968,11 @@
     QTimer compositeResetTimer; // for compressing composite resets
     bool m_finishingCompositing; // finishCompositing() sets this variable while shutting down
 
+#ifdef KWIN_BUILD_KAPPMENU
+    KAppMenuImporter* m_applicationMenuImporter; //libdbusmenu client
+    MenuBar* m_menubar; //overlay menubar
+#endif
+
     Scripting *m_scripting;
 
 private:
