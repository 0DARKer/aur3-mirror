diff --git a/src/wl/sys/wl_cfg80211.c b/src/wl/sys/wl_cfg80211.c
index c54ae87..f5e3ce4 100644
--- a/src/wl/sys/wl_cfg80211.c
+++ b/src/wl/sys/wl_cfg80211.c
@@ -37,11 +37,47 @@
 #include <bcmendian.h>
 #include <wlioctl.h>
 #include <wl_cfg80211.h>
+#include <linux/rcupdate.h>
 
 #define EVENT_TYPE(e) dtoh32((e)->event_type)
 #define EVENT_FLAGS(e) dtoh16((e)->flags)
 #define EVENT_STATUS(e) dtoh32((e)->status)
 
+#ifdef CONFIG_PREEMPT_RCU
+static void bdcm_rcu_read_lock(void)
+{
+	current->rcu_read_lock_nesting++;
+	barrier();  /* critical section after entry code. */
+}
+
+static void bdcm_rcu_read_unlock(void)
+{
+	struct task_struct *t = current;
+
+	if (t->rcu_read_lock_nesting != 1) {
+		--t->rcu_read_lock_nesting;
+	} else {
+		barrier();  /* critical section before exit code. */
+		t->rcu_read_lock_nesting = INT_MIN;
+#ifdef CONFIG_PROVE_RCU_DELAY
+		udelay(10); /* Make preemption more probable. */
+#endif /* #ifdef CONFIG_PROVE_RCU_DELAY */
+		barrier();  /* assign before ->rcu_read_unlock_special load */
+		if (unlikely(ACCESS_ONCE(t->rcu_read_unlock_special)))
+			rcu_read_unlock_special(t);
+		barrier();  /* ->rcu_read_unlock_special load before assign */
+		t->rcu_read_lock_nesting = 0;
+	}
+#ifdef CONFIG_PROVE_LOCKING
+	{
+		int rrln = ACCESS_ONCE(t->rcu_read_lock_nesting);
+
+		WARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);
+	}
+#endif /* #ifdef CONFIG_PROVE_LOCKING */
+}
+#endif
+
 u32 wl_dbg_level = WL_DBG_ERR | WL_DBG_INFO;
 
 static s32 wl_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,
@@ -2001,18 +2037,31 @@ static s32 wl_update_bss_info(struct wl_cfg80211_priv *wl)
 		ie = bss->information_elements;
 		ie_len = bss->len_information_elements;
 #else
+#ifdef CONFIG_PREEMPT_RCU
+		bdcm_rcu_read_lock();
+#else
 		rcu_read_lock();
+#endif
 		ies = (const struct cfg80211_bss_ies*)rcu_dereference(bss->ies);
 		if (!ies) {
 			/* This should never happen */
+#ifdef CONFIG_PREEMPT_RCU
+			bdcm_rcu_read_unlock();
+#else
 			rcu_read_unlock();
+#endif
 			err = -EIO;
 			goto update_bss_info_out;
 		}
 		ie = ies->data;
 		ie_len = (size_t)(ies->len);
+#ifdef CONFIG_PREEMPT_RCU
+		bdcm_rcu_read_unlock();
+#else
 		rcu_read_unlock();
 #endif
+
+#endif
 		cfg80211_put_bss(bss);
 	}
 
