diff -Naur xf86-input-synaptics-1.5.0/include/synaptics.h xf86-input-synaptics-1.5.0-old/include/synaptics.h
--- xf86-input-synaptics-1.5.0/include/synaptics.h	2011-10-14 01:34:08.608958796 +0200
+++ xf86-input-synaptics-1.5.0-old/include/synaptics.h	2011-10-14 01:33:00.379408971 +0200
@@ -54,7 +54,6 @@
     int version;			    /* Driver version */
 
     /* Current device state */
-    int orientation;
     int x, y;				    /* actual x, y coordinates */
     int z;				    /* pressure value */
     int numFingers;			    /* number of fingers */
diff -Naur xf86-input-synaptics-1.5.0/include/synaptics-properties.h xf86-input-synaptics-1.5.0-old/include/synaptics-properties.h
--- xf86-input-synaptics-1.5.0/include/synaptics-properties.h	2011-10-14 01:34:08.612292090 +0200
+++ xf86-input-synaptics-1.5.0-old/include/synaptics-properties.h	2011-10-14 01:33:00.379408971 +0200
@@ -142,9 +142,6 @@
 /* 8 bit (BOOL) */
 #define SYNAPTICS_PROP_GRAB "Synaptics Grab Event Device"
 
-/* 32 bit */
-#define SYNAPTICS_ORIENTATION "Synaptics Orientation"
-
 /* 8 bit (BOOL), 1 value, tap-and-drag */
 #define SYNAPTICS_PROP_GESTURES "Synaptics Gestures"
 
diff -Naur xf86-input-synaptics-1.5.0/src/eventcomm.c xf86-input-synaptics-1.5.0-old/src/eventcomm.c
--- xf86-input-synaptics-1.5.0/src/eventcomm.c	2011-10-14 01:34:08.612292090 +0200
+++ xf86-input-synaptics-1.5.0-old/src/eventcomm.c	2011-10-14 01:33:00.386074730 +0200
@@ -468,28 +468,10 @@
 	case EV_ABS:
 	    switch (ev.code) {
 	    case ABS_X:
-		if (para->orientation==0)
-			hw->x = ev.value;
-		else if (para->orientation==2)
-			hw->x = priv->maxx + priv->minx - ev.value;
-		else if (para->orientation==3)
-			hw->y = (priv->maxx - ev.value) * (priv->maxy - priv->miny) / (priv->maxx - priv->minx) + priv->miny;
-		else if (para->orientation==1)
-			hw->y = (ev.value - priv->minx) * (priv->maxy - priv->miny) / (priv->maxx - priv->minx) + priv->miny;
-		else
-			hw->x = ev.value;
+		hw->x = ev.value;
 		break;
 	    case ABS_Y:
-		if (para->orientation==0)
-			hw->y = ev.value;
-		else if (para->orientation==2)
-			hw->y = priv->maxy + priv->miny - ev.value;
-		else if (para->orientation==3)
-			hw->x = (ev.value - priv->miny) * (priv->maxx - priv->minx) / (priv->maxy - priv->miny) + priv->minx;
-		else if (para->orientation==1)
-			hw->x = (priv->maxy - ev.value) * (priv->maxx - priv->minx) / (priv->maxy - priv->miny) + priv->minx;
-		else
-			hw->y = ev.value;
+		hw->y = ev.value;
 		break;
 	    case ABS_PRESSURE:
 		hw->z = ev.value;
diff -Naur xf86-input-synaptics-1.5.0/src/eventcomm.c.orig xf86-input-synaptics-1.5.0-old/src/eventcomm.c.orig
--- xf86-input-synaptics-1.5.0/src/eventcomm.c.orig	2011-09-02 08:02:56.000000000 +0200
+++ xf86-input-synaptics-1.5.0-old/src/eventcomm.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,586 +0,0 @@
-/*
- * Copyright Â© 2004-2007 Peter Osterlund
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Red Hat
- * not be used in advertising or publicity pertaining to distribution
- * of the software without specific, written prior permission.  Red
- * Hat makes no representations about the suitability of this software
- * for any purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
- * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Authors:
- *      Peter Osterlund (petero2@telia.com)
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <xorg-server.h>
-#include "eventcomm.h"
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <dirent.h>
-#include <string.h>
-#include <stdio.h>
-#include "synproto.h"
-#include "synaptics.h"
-#include "synapticsstr.h"
-#include <xf86.h>
-
-
-#define SYSCALL(call) while (((call) == -1) && (errno == EINTR))
-
-#define LONG_BITS (sizeof(long) * 8)
-#define NBITS(x) (((x) + LONG_BITS - 1) / LONG_BITS)
-
-/**
- * Protocol-specific data.
- */
-struct eventcomm_proto_data
-{
-    /**
-     * Do we need to grab the event device?
-     * Note that in the current flow, this variable is always false and
-     * exists for readability of the code.
-     */
-    BOOL need_grab;
-};
-
-static void
-EventDeviceOnHook(InputInfoPtr pInfo, SynapticsParameters *para)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-    struct eventcomm_proto_data *proto_data = (struct eventcomm_proto_data*)priv->proto_data;
-
-    if (!proto_data) {
-	proto_data = calloc(1, sizeof(struct eventcomm_proto_data));
-	priv->proto_data = proto_data;
-    }
-
-    if (para->grab_event_device) {
-	/* Try to grab the event device so that data don't leak to /dev/input/mice */
-	int ret;
-	SYSCALL(ret = ioctl(pInfo->fd, EVIOCGRAB, (pointer)1));
-	if (ret < 0) {
-	    xf86IDrvMsg(pInfo, X_WARNING, "can't grab event device, errno=%d\n",
-			errno);
-	}
-    }
-
-    proto_data->need_grab = FALSE;
-}
-
-/**
- * Test if the device on the file descriptior is recognized as touchpad
- * device. Required bits for touchpad recognition are:
- * - ABS_X + ABS_Y for absolute axes
- * - ABS_PRESSURE or BTN_TOUCH
- * - BTN_TOOL_FINGER
- * - BTN_TOOL_PEN is _not_ set
- *
- * @param fd The file descriptor to an event device.
- * @param test_grab If true, test whether an EVIOCGRAB is possible on the
- * device. A failure to grab the event device returns in a failure.
- *
- * @return TRUE if the device is a touchpad or FALSE otherwise.
- */
-static Bool
-event_query_is_touchpad(int fd, BOOL test_grab)
-{
-    int ret = FALSE, rc;
-    unsigned long evbits[NBITS(EV_MAX)] = {0};
-    unsigned long absbits[NBITS(ABS_MAX)] = {0};
-    unsigned long keybits[NBITS(KEY_MAX)] = {0};
-
-    if (test_grab)
-    {
-        SYSCALL(rc = ioctl(fd, EVIOCGRAB, (pointer)1));
-        if (rc < 0)
-            return FALSE;
-    }
-
-    /* Check for ABS_X, ABS_Y, ABS_PRESSURE and BTN_TOOL_FINGER */
-
-    SYSCALL(rc = ioctl(fd, EVIOCGBIT(0, sizeof(evbits)), evbits));
-    if (rc < 0)
-	goto unwind;
-    if (!BitIsOn(evbits, EV_SYN) ||
-	!BitIsOn(evbits, EV_ABS) ||
-	!BitIsOn(evbits, EV_KEY))
-	goto unwind;
-
-    SYSCALL(rc = ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits));
-    if (rc < 0)
-	goto unwind;
-    if (!BitIsOn(absbits, ABS_X) ||
-	!BitIsOn(absbits, ABS_Y))
-	goto unwind;
-
-    SYSCALL(rc = ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits));
-    if (rc < 0)
-	goto unwind;
-
-    /* we expect touchpad either report raw pressure or touches */
-    if (!BitIsOn(absbits, ABS_PRESSURE) && !BitIsOn(keybits, BTN_TOUCH))
-	goto unwind;
-    /* all Synaptics-like touchpad report BTN_TOOL_FINGER */
-    if (!BitIsOn(keybits, BTN_TOOL_FINGER))
-	goto unwind;
-    if (BitIsOn(keybits, BTN_TOOL_PEN))
-	goto unwind;			    /* Don't match wacom tablets */
-
-    ret = TRUE;
-
-unwind:
-    if (test_grab)
-        SYSCALL(ioctl(fd, EVIOCGRAB, (pointer)0));
-
-    return (ret == TRUE);
-}
-
-typedef struct {
-	short vendor;
-	short product;
-	enum TouchpadModel model;
-} model_lookup_t;
-#define PRODUCT_ANY 0x0000
-
-static model_lookup_t model_lookup_table[] = {
-	{0x0002, 0x0007, MODEL_SYNAPTICS},
-	{0x0002, 0x0008, MODEL_ALPS},
-	{0x05ac, PRODUCT_ANY, MODEL_APPLETOUCH},
-	{0x0, 0x0, 0x0}
-};
-
-/**
- * Check for the vendor/product id on the file descriptor and compare
- * with the built-in model LUT. This information is used in synaptics.c to
- * initialize model-specific dimensions.
- *
- * @param fd The file descriptor to a event device.
- * @param[out] model_out The type of touchpad model detected.
- *
- * @return TRUE on success or FALSE otherwise.
- */
-static Bool
-event_query_model(int fd, enum TouchpadModel *model_out, unsigned short *vendor_id, unsigned short *product_id)
-{
-    struct input_id id;
-    int rc;
-    model_lookup_t *model_lookup;
-
-    SYSCALL(rc = ioctl(fd, EVIOCGID, &id));
-    if (rc < 0)
-        return FALSE;
-
-    for(model_lookup = model_lookup_table; model_lookup->vendor; model_lookup++) {
-        if(model_lookup->vendor == id.vendor &&
-           (model_lookup->product == id.product|| model_lookup->product == PRODUCT_ANY))
-            *model_out = model_lookup->model;
-    }
-
-    *vendor_id = id.vendor;
-    *product_id = id.product;
-
-    return TRUE;
-}
-
-/**
- * Get absinfo information from the given file descriptor for the given
- * ABS_FOO code and store the information in min, max, fuzz and res.
- *
- * @param fd File descriptor to an event device
- * @param code Event code (e.g. ABS_X)
- * @param[out] min Minimum axis range
- * @param[out] max Maximum axis range
- * @param[out] fuzz Fuzz of this axis. If NULL, fuzz is ignored.
- * @param[out] res Axis resolution. If NULL or the current kernel does not
- * support the resolution field, res is ignored
- *
- * @return Zero on success, or errno otherwise.
- */
-static int
-event_get_abs(InputInfoPtr pInfo, int fd, int code,
-              int *min, int *max, int *fuzz, int *res)
-{
-    int rc;
-    struct input_absinfo abs =  {0};
-
-    SYSCALL(rc = ioctl(fd, EVIOCGABS(code), &abs));
-    if (rc < 0) {
-	xf86IDrvMsg(pInfo, X_ERROR, "%s EVIOCGABS error on %d (%s)\n",
-		    __func__, code, strerror(rc));
-	return errno;
-    }
-
-    *min = abs.minimum;
-    *max = abs.maximum;
-    /* We dont trust a zero fuzz as it probably is just a lazy value */
-    if (fuzz && abs.fuzz > 0)
-	*fuzz = abs.fuzz;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
-    if (res)
-	*res = abs.resolution;
-#endif
-
-    return 0;
-}
-
-
-/* Query device for axis ranges */
-static void
-event_query_axis_ranges(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-    struct input_absinfo abs = {0};
-    unsigned long absbits[NBITS(ABS_MAX)] = {0};
-    unsigned long keybits[NBITS(KEY_MAX)] = {0};
-    char buf[256] = {0};
-    int rc;
-
-    /* The kernel's fuzziness concept seems a bit weird, but it can more or
-     * less be applied as hysteresis directly, i.e. no factor here. */
-    event_get_abs(pInfo, pInfo->fd, ABS_X, &priv->minx, &priv->maxx,
-		  &priv->synpara.hyst_x, &priv->resx);
-
-    event_get_abs(pInfo, pInfo->fd, ABS_Y, &priv->miny, &priv->maxy,
-		  &priv->synpara.hyst_y, &priv->resy);
-
-    priv->has_pressure = FALSE;
-    priv->has_width = FALSE;
-    SYSCALL(rc = ioctl(pInfo->fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits));
-    if (rc >= 0)
-    {
-	priv->has_pressure = (BitIsOn(absbits, ABS_PRESSURE) != 0);
-	priv->has_width = (BitIsOn(absbits, ABS_TOOL_WIDTH) != 0);
-    }
-    else
-	xf86IDrvMsg(pInfo, X_ERROR, "failed to query ABS bits (%s)\n", strerror(errno));
-
-    if (priv->has_pressure)
-	event_get_abs(pInfo, pInfo->fd, ABS_PRESSURE, &priv->minp, &priv->maxp,
-		      NULL, NULL);
-
-    if (priv->has_width)
-	event_get_abs(pInfo, pInfo->fd, ABS_TOOL_WIDTH,
-		      &priv->minw, &priv->maxw,
-		      NULL, NULL);
-
-    SYSCALL(rc = ioctl(pInfo->fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits));
-    if (rc >= 0)
-    {
-	priv->has_left = (BitIsOn(keybits, BTN_LEFT) != 0);
-	priv->has_right = (BitIsOn(keybits, BTN_RIGHT) != 0);
-	priv->has_middle = (BitIsOn(keybits, BTN_MIDDLE) != 0);
-	priv->has_double = (BitIsOn(keybits, BTN_TOOL_DOUBLETAP) != 0);
-	priv->has_triple = (BitIsOn(keybits, BTN_TOOL_TRIPLETAP) != 0);
-
-	if ((BitIsOn(keybits, BTN_0) != 0) ||
-	    (BitIsOn(keybits, BTN_1) != 0) ||
-	    (BitIsOn(keybits, BTN_2) != 0) ||
-	    (BitIsOn(keybits, BTN_3) != 0))
-	    priv->has_scrollbuttons = 1;
-    }
-
-    /* Now print the device information */
-    xf86IDrvMsg(pInfo, X_PROBED, "x-axis range %d - %d\n",
-		priv->minx, priv->maxx);
-    xf86IDrvMsg(pInfo, X_PROBED, "y-axis range %d - %d\n",
-		priv->miny, priv->maxy);
-    if (priv->has_pressure)
-	xf86IDrvMsg(pInfo, X_PROBED, "pressure range %d - %d\n",
-		    priv->minp, priv->maxp);
-    else
-	xf86IDrvMsg(pInfo, X_INFO,
-		    "device does not report pressure, will use touch data.\n");
-    if (priv->has_width)
-	xf86IDrvMsg(pInfo, X_PROBED, "finger width range %d - %d\n",
-		    abs.minimum, abs.maximum);
-    else
-	xf86IDrvMsg(pInfo, X_INFO,
-		    "device does not report finger width.\n");
-
-    if (priv->has_left)
-	strcat(buf, " left");
-    if (priv->has_right)
-	strcat(buf, " right");
-    if (priv->has_middle)
-	strcat(buf, " middle");
-    if (priv->has_double)
-	strcat(buf, " double");
-    if (priv->has_triple)
-	strcat(buf, " triple");
-    if (priv->has_scrollbuttons)
-	strcat(buf, " scroll-buttons");
-
-    xf86IDrvMsg(pInfo, X_PROBED, "buttons:%s\n", buf);
-}
-
-static Bool
-EventQueryHardware(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-    struct eventcomm_proto_data *proto_data = priv->proto_data;
-
-    if (!event_query_is_touchpad(pInfo->fd, (proto_data) ? proto_data->need_grab : TRUE))
-	return FALSE;
-
-    xf86IDrvMsg(pInfo, X_PROBED, "touchpad found\n");
-
-    return TRUE;
-}
-
-static Bool
-SynapticsReadEvent(InputInfoPtr pInfo, struct input_event *ev)
-{
-    int rc = TRUE;
-    ssize_t len;
-
-    len = read(pInfo->fd, ev, sizeof(*ev));
-    if (len <= 0)
-    {
-        /* We use X_NONE here because it doesn't alloc */
-        if (errno != EAGAIN)
-            xf86MsgVerb(X_NONE, 0, "%s: Read error %s\n", pInfo->name, strerror(errno));
-        rc = FALSE;
-    } else if (len % sizeof(*ev)) {
-        xf86MsgVerb(X_NONE, 0, "%s: Read error, invalid number of bytes.", pInfo->name);
-        rc = FALSE;
-    }
-    return rc;
-}
-
-/**
- * Count the number of fingers based on the CommData information.
- * The CommData struct contains the event information based on previous
- * struct input_events, now we're just counting based on that.
- *
- * @param comm Assembled information from previous events.
- * @return The number of fingers currently set.
- */
-static int count_fingers(const struct CommData *comm)
-{
-    int fingers = 0;
-
-    if (comm->oneFinger)
-	fingers = 1;
-    else if (comm->twoFingers)
-	fingers = 2;
-    else if (comm->threeFingers)
-	fingers = 3;
-
-    return fingers;
-}
-
-
-Bool
-EventReadHwState(InputInfoPtr pInfo,
-		 struct CommData *comm, struct SynapticsHwState *hwRet)
-{
-    struct input_event ev;
-    Bool v;
-    struct SynapticsHwState *hw = &(comm->hwState);
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-    SynapticsParameters *para = &priv->synpara;
-
-    while (SynapticsReadEvent(pInfo, &ev)) {
-	switch (ev.type) {
-	case EV_SYN:
-	    switch (ev.code) {
-	    case SYN_REPORT:
-		hw->numFingers = count_fingers(comm);
-		*hwRet = *hw;
-		return TRUE;
-	    }
-	    break;
-	case EV_KEY:
-	    v = (ev.value ? TRUE : FALSE);
-	    switch (ev.code) {
-	    case BTN_LEFT:
-		hw->left = v;
-		break;
-	    case BTN_RIGHT:
-		hw->right = v;
-		break;
-	    case BTN_MIDDLE:
-		hw->middle = v;
-		break;
-	    case BTN_FORWARD:
-		hw->up = v;
-		break;
-	    case BTN_BACK:
-		hw->down = v;
-		break;
-	    case BTN_0:
-		hw->multi[0] = v;
-		break;
-	    case BTN_1:
-		hw->multi[1] = v;
-		break;
-	    case BTN_2:
-		hw->multi[2] = v;
-		break;
-	    case BTN_3:
-		hw->multi[3] = v;
-		break;
-	    case BTN_4:
-		hw->multi[4] = v;
-		break;
-	    case BTN_5:
-		hw->multi[5] = v;
-		break;
-	    case BTN_6:
-		hw->multi[6] = v;
-		break;
-	    case BTN_7:
-		hw->multi[7] = v;
-		break;
-	    case BTN_TOOL_FINGER:
-		comm->oneFinger = v;
-		break;
-	    case BTN_TOOL_DOUBLETAP:
-		comm->twoFingers = v;
-		break;
-	    case BTN_TOOL_TRIPLETAP:
-		comm->threeFingers = v;
-		break;
-	    case BTN_TOUCH:
-		if (!priv->has_pressure)
-			hw->z = v ? para->finger_high + 1 : 0;
-		break;
-	    }
-	    break;
-	case EV_ABS:
-	    switch (ev.code) {
-	    case ABS_X:
-		hw->x = ev.value;
-		break;
-	    case ABS_Y:
-		hw->y = ev.value;
-		break;
-	    case ABS_PRESSURE:
-		hw->z = ev.value;
-		break;
-	    case ABS_TOOL_WIDTH:
-		hw->fingerWidth = ev.value;
-		break;
-	    }
-	    break;
-	}
-    }
-    return FALSE;
-}
-
-/* filter for the AutoDevProbe scandir on /dev/input */
-static int EventDevOnly(const struct dirent *dir) {
-	return strncmp(EVENT_DEV_NAME, dir->d_name, 5) == 0;
-}
-
-/**
- * Probe the open device for dimensions.
- */
-static void
-EventReadDevDimensions(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-    struct eventcomm_proto_data *proto_data = priv->proto_data;
-
-    if (event_query_is_touchpad(pInfo->fd, (proto_data) ? proto_data->need_grab : TRUE))
-	event_query_axis_ranges(pInfo);
-    event_query_model(pInfo->fd, &priv->model, &priv->id_vendor, &priv->id_product);
-
-    xf86IDrvMsg(pInfo, X_PROBED, "Vendor %#hx Product %#hx\n",
-                priv->id_vendor, priv->id_product);
-}
-
-static Bool
-EventAutoDevProbe(InputInfoPtr pInfo, const char *device)
-{
-    /* We are trying to find the right eventX device or fall back to
-       the psaux protocol and the given device from XF86Config */
-    int i;
-    Bool touchpad_found = FALSE;
-    struct dirent **namelist;
-
-    if (device) {
-	int fd = -1;
-	SYSCALL(fd = open(device, O_RDONLY));
-	if (fd >= 0)
-	{
-	    touchpad_found = event_query_is_touchpad(fd, TRUE);
-
-	    SYSCALL(close(fd));
-            /* if a device is set and not a touchpad (or already grabbed),
-             * we must return FALSE.  Otherwise, we'll add a device that
-             * wasn't requested for and repeat
-             * f5687a6741a19ef3081e7fd83ac55f6df8bcd5c2. */
-	    return touchpad_found;
-	}
-    }
-
-    i = scandir(DEV_INPUT_EVENT, &namelist, EventDevOnly, alphasort);
-    if (i < 0) {
-		xf86IDrvMsg(pInfo, X_ERROR, "Couldn't open %s\n", DEV_INPUT_EVENT);
-		return FALSE;
-    }
-    else if (i == 0) {
-		xf86IDrvMsg(pInfo, X_ERROR, "The /dev/input/event* device nodes seem to be missing\n");
-		free(namelist);
-		return FALSE;
-    }
-
-    while (i--) {
-		char fname[64];
-		int fd = -1;
-
-		if (!touchpad_found) {
-			sprintf(fname, "%s/%s", DEV_INPUT_EVENT, namelist[i]->d_name);
-			SYSCALL(fd = open(fname, O_RDONLY));
-			if (fd < 0)
-				continue;
-
-			if (event_query_is_touchpad(fd, TRUE)) {
-				touchpad_found = TRUE;
-			    xf86IDrvMsg(pInfo, X_PROBED, "auto-dev sets device to %s\n",
-					fname);
-			    pInfo->options =
-			    	xf86ReplaceStrOption(pInfo->options, "Device", fname);
-			}
-			SYSCALL(close(fd));
-		}
-		free(namelist[i]);
-    }
-
-    free(namelist);
-
-    if (!touchpad_found) {
-	xf86IDrvMsg(pInfo, X_ERROR, "no synaptics event device found\n");
-	return FALSE;
-    }
-
-    return TRUE;
-}
-
-struct SynapticsProtocolOperations event_proto_operations = {
-    EventDeviceOnHook,
-    NULL,
-    EventQueryHardware,
-    EventReadHwState,
-    EventAutoDevProbe,
-    EventReadDevDimensions
-};
diff -Naur xf86-input-synaptics-1.5.0/src/properties.c xf86-input-synaptics-1.5.0-old/src/properties.c
--- xf86-input-synaptics-1.5.0/src/properties.c	2011-10-14 01:34:08.618958581 +0200
+++ xf86-input-synaptics-1.5.0-old/src/properties.c	2011-10-14 01:33:00.382741827 +0200
@@ -54,7 +54,6 @@
 static Atom float_type;
 
 Atom prop_edges                 = 0;
-Atom prop_orientation           = 0;
 Atom prop_finger                = 0;
 Atom prop_tap_time              = 0;
 Atom prop_tap_move              = 0;
@@ -266,8 +265,6 @@
     fvalues[0] = para->press_motion_min_factor;
     fvalues[1] = para->press_motion_max_factor;
 
-    prop_orientation = InitAtom(pInfo->dev, SYNAPTICS_ORIENTATION, 32, 1, &para->orientation);
-
     prop_pressuremotion_factor = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR, 2, fvalues);
 
     prop_grab = InitAtom(pInfo->dev, SYNAPTICS_PROP_GRAB, 8, 1, &para->grab_event_device);
@@ -335,13 +332,7 @@
         para = &tmp;
     }
 
-    if (property == prop_orientation)
-	{
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-		para->orientation = *(INT32*)prop->data;
-	}
-    else if (property == prop_edges)
+    if (property == prop_edges)
     {
         INT32 *edges;
         if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
diff -Naur xf86-input-synaptics-1.5.0/src/properties.c.orig xf86-input-synaptics-1.5.0-old/src/properties.c.orig
--- xf86-input-synaptics-1.5.0/src/properties.c.orig	2011-09-02 08:02:56.000000000 +0200
+++ xf86-input-synaptics-1.5.0-old/src/properties.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,702 +0,0 @@
-/*
- * Copyright Â© 2008 Red Hat, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Red Hat
- * not be used in advertising or publicity pertaining to distribution
- * of the software without specific, written prior permission.  Red
- * Hat makes no representations about the suitability of this software
- * for any purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
- * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Authors: Peter Hutterer
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <xorg-server.h>
-#include "xf86Module.h"
-
-#include <X11/Xatom.h>
-#include <xf86.h>
-#include <xf86Xinput.h>
-#include <exevents.h>
-
-#include "synaptics.h"
-#include "synapticsstr.h"
-#include "synaptics-properties.h"
-
-#ifndef XATOM_FLOAT
-#define XATOM_FLOAT "FLOAT"
-#endif
-
-#ifndef XI_PROP_PRODUCT_ID
-#define XI_PROP_PRODUCT_ID "Device Product ID"
-#endif
-
-#ifndef XI_PROP_DEVICE_NODE
-#define XI_PROP_DEVICE_NODE "Device Node"
-#endif
-
-static Atom float_type;
-
-Atom prop_edges                 = 0;
-Atom prop_finger                = 0;
-Atom prop_tap_time              = 0;
-Atom prop_tap_move              = 0;
-Atom prop_tap_durations         = 0;
-Atom prop_tap_fast              = 0;
-Atom prop_middle_timeout        = 0;
-Atom prop_twofinger_pressure    = 0;
-Atom prop_twofinger_width       = 0;
-Atom prop_scrolldist            = 0;
-Atom prop_scrolledge            = 0;
-Atom prop_scrolltwofinger       = 0;
-Atom prop_speed                 = 0;
-Atom prop_edgemotion_pressure   = 0;
-Atom prop_edgemotion_speed      = 0;
-Atom prop_edgemotion_always     = 0;
-Atom prop_buttonscroll          = 0;
-Atom prop_buttonscroll_repeat   = 0;
-Atom prop_buttonscroll_time     = 0;
-Atom prop_off                   = 0;
-Atom prop_lockdrags             = 0;
-Atom prop_lockdrags_time        = 0;
-Atom prop_tapaction             = 0;
-Atom prop_clickaction           = 0;
-Atom prop_circscroll            = 0;
-Atom prop_circscroll_dist       = 0;
-Atom prop_circscroll_trigger    = 0;
-Atom prop_circpad               = 0;
-Atom prop_palm                  = 0;
-Atom prop_palm_dim              = 0;
-Atom prop_coastspeed            = 0;
-Atom prop_pressuremotion        = 0;
-Atom prop_pressuremotion_factor = 0;
-Atom prop_grab                  = 0;
-Atom prop_gestures              = 0;
-Atom prop_capabilities          = 0;
-Atom prop_resolution            = 0;
-Atom prop_area                  = 0;
-Atom prop_noise_cancellation    = 0;
-Atom prop_product_id            = 0;
-Atom prop_device_node           = 0;
-
-static Atom
-InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
-{
-    int i;
-    Atom atom;
-    uint8_t val_8[9]; /* we never have more than 9 values in an atom */
-    uint16_t val_16[9];
-    uint32_t val_32[9];
-    pointer converted;
-
-
-    for (i = 0; i < nvalues; i++)
-    {
-        switch(format)
-        {
-            case 8:  val_8[i]  = values[i]; break;
-            case 16: val_16[i] = values[i]; break;
-            case 32: val_32[i] = values[i]; break;
-        }
-    }
-
-    switch(format)
-    {
-        case 8: converted = val_8; break;
-        case 16: converted = val_16; break;
-        case 32: converted = val_32; break;
-    }
-
-    atom = MakeAtom(name, strlen(name), TRUE);
-    XIChangeDeviceProperty(dev, atom, XA_INTEGER, format,
-                           PropModeReplace, nvalues,
-                           converted, FALSE);
-    XISetDevicePropertyDeletable(dev, atom, FALSE);
-    return atom;
-}
-
-static Atom
-InitFloatAtom(DeviceIntPtr dev, char *name, int nvalues, float *values)
-{
-    Atom atom;
-
-    atom = MakeAtom(name, strlen(name), TRUE);
-    XIChangeDeviceProperty(dev, atom, float_type, 32, PropModeReplace,
-                           nvalues, values, FALSE);
-    XISetDevicePropertyDeletable(dev, atom, FALSE);
-    return atom;
-}
-
-void
-InitDeviceProperties(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
-    SynapticsParameters *para = &priv->synpara;
-    int values[9]; /* we never have more than 9 values in an atom */
-    float fvalues[4]; /* never have more than 4 float values */
-
-    float_type = XIGetKnownProperty(XATOM_FLOAT);
-    if (!float_type)
-    {
-        float_type = MakeAtom(XATOM_FLOAT, strlen(XATOM_FLOAT), TRUE);
-        if (!float_type)
-        {
-            xf86IDrvMsg(pInfo, X_ERROR, "Failed to init float atom. "
-                        "Disabling property support.\n");
-            return;
-        }
-    }
-
-    values[0] = para->left_edge;
-    values[1] = para->right_edge;
-    values[2] = para->top_edge;
-    values[3] = para->bottom_edge;
-
-    prop_edges = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGES, 32, 4, values);
-
-    values[0] = para->finger_low;
-    values[1] = para->finger_high;
-    values[2] = para->finger_press;
-
-    prop_finger = InitAtom(pInfo->dev, SYNAPTICS_PROP_FINGER, 32, 3, values);
-    prop_tap_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_TIME, 32, 1, &para->tap_time);
-    prop_tap_move = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_MOVE, 32, 1, &para->tap_move);
-
-    values[0] = para->single_tap_timeout;
-    values[1] = para->tap_time_2;
-    values[2] = para->click_time;
-
-    prop_tap_durations = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_DURATIONS, 32, 3, values);
-    prop_tap_fast = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_FAST, 8, 1, &para->fast_taps);
-    prop_middle_timeout = InitAtom(pInfo->dev, SYNAPTICS_PROP_MIDDLE_TIMEOUT,
-                                   32, 1, &para->emulate_mid_button_time);
-    prop_twofinger_pressure = InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_PRESSURE,
-                                       32, 1, &para->emulate_twofinger_z);
-    prop_twofinger_width = InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_WIDTH,
-                                       32, 1, &para->emulate_twofinger_w);
-
-    values[0] = para->scroll_dist_vert;
-    values[1] = para->scroll_dist_horiz;
-    prop_scrolldist = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_DISTANCE, 32, 2, values);
-
-    values[0] = para->scroll_edge_vert;
-    values[1] = para->scroll_edge_horiz;
-    values[2] = para->scroll_edge_corner;
-    prop_scrolledge = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_EDGE,8, 3, values);
-    values[0] = para->scroll_twofinger_vert;
-    values[1] = para->scroll_twofinger_horiz;
-    prop_scrolltwofinger = InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_TWOFINGER,8, 2, values);
-
-    fvalues[0] = para->min_speed;
-    fvalues[1] = para->max_speed;
-    fvalues[2] = para->accl;
-    fvalues[3] = para->trackstick_speed;
-    prop_speed = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_SPEED, 4, fvalues);
-
-    values[0] = para->edge_motion_min_z;
-    values[1] = para->edge_motion_max_z;
-    prop_edgemotion_pressure = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_PRESSURE, 32, 2, values);
-
-    values[0] = para->edge_motion_min_speed;
-    values[1] = para->edge_motion_max_speed;
-    prop_edgemotion_speed = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION_SPEED, 32, 2, values);
-    prop_edgemotion_always = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGEMOTION, 8, 1, &para->edge_motion_use_always);
-
-    if (priv->has_scrollbuttons)
-    {
-        values[0] = para->updown_button_scrolling;
-        values[1] = para->leftright_button_scrolling;
-        prop_buttonscroll = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING, 8, 2, values);
-
-        values[0] = para->updown_button_repeat;
-        values[1] = para->leftright_button_repeat;
-        prop_buttonscroll_repeat = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT, 8, 2, values);
-        prop_buttonscroll_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_BUTTONSCROLLING_TIME, 32, 1, &para->scroll_button_repeat);
-    }
-
-    prop_off = InitAtom(pInfo->dev, SYNAPTICS_PROP_OFF, 8, 1, &para->touchpad_off);
-    prop_lockdrags = InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS, 8, 1, &para->locked_drags);
-    prop_lockdrags_time = InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT, 32, 1, &para->locked_drag_time);
-
-    memcpy(values, para->tap_action, MAX_TAP * sizeof(int));
-    prop_tapaction = InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_ACTION, 8, MAX_TAP, values);
-
-    memcpy(values, para->click_action, MAX_CLICK * sizeof(int));
-    prop_clickaction = InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICK_ACTION, 8, MAX_CLICK, values);
-
-    prop_circscroll = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING, 8, 1, &para->circular_scrolling);
-
-    fvalues[0] = para->scroll_dist_circ;
-    prop_circscroll_dist = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST, 1, fvalues);
-
-    prop_circscroll_trigger = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER, 8, 1, &para->circular_trigger);
-    prop_circpad = InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_PAD, 8, 1, &para->circular_pad);
-    prop_palm = InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DETECT, 8, 1, &para->palm_detect);
-
-    values[0] = para->palm_min_width;
-    values[1] = para->palm_min_z;
-
-    prop_palm_dim = InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DIMENSIONS, 32, 2, values);
-
-    fvalues[0] = para->coasting_speed;
-    fvalues[1] = para->coasting_friction;
-    prop_coastspeed = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_COASTING_SPEED, 2, fvalues);
-
-    values[0] = para->press_motion_min_z;
-    values[1] = para->press_motion_max_z;
-    prop_pressuremotion = InitAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION, 32, 2, values);
-
-    fvalues[0] = para->press_motion_min_factor;
-    fvalues[1] = para->press_motion_max_factor;
-
-    prop_pressuremotion_factor = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR, 2, fvalues);
-
-    prop_grab = InitAtom(pInfo->dev, SYNAPTICS_PROP_GRAB, 8, 1, &para->grab_event_device);
-
-    values[0] = para->tap_and_drag_gesture;
-    prop_gestures = InitAtom(pInfo->dev, SYNAPTICS_PROP_GESTURES, 8, 1, values);
-
-    values[0] = priv->has_left;
-    values[1] = priv->has_middle;
-    values[2] = priv->has_right;
-    values[3] = priv->has_double;
-    values[4] = priv->has_triple;
-    values[5] = priv->has_pressure;
-    values[6] = priv->has_width;
-    prop_capabilities = InitAtom(pInfo->dev, SYNAPTICS_PROP_CAPABILITIES, 8, 7, values);
-
-    values[0] = para->resolution_vert;
-    values[1] = para->resolution_horiz;
-    prop_resolution = InitAtom(pInfo->dev, SYNAPTICS_PROP_RESOLUTION, 32, 2, values);
-
-    values[0] = para->area_left_edge;
-    values[1] = para->area_right_edge;
-    values[2] = para->area_top_edge;
-    values[3] = para->area_bottom_edge;
-    prop_area = InitAtom(pInfo->dev, SYNAPTICS_PROP_AREA, 32, 4, values);
-
-    values[0] = para->hyst_x;
-    values[1] = para->hyst_y;
-    prop_noise_cancellation = InitAtom(pInfo->dev,
-            SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2, values);
-
-    /* only init product_id property if we actually know them */
-    if (priv->id_vendor || priv->id_product)
-    {
-        values[0] = priv->id_vendor;
-        values[1] = priv->id_product;
-        prop_product_id = InitAtom(pInfo->dev, XI_PROP_PRODUCT_ID, 32, 2, values);
-    }
-
-    if (priv->device)
-    {
-        prop_device_node = MakeAtom(XI_PROP_DEVICE_NODE, strlen(XI_PROP_DEVICE_NODE), TRUE);
-        XIChangeDeviceProperty(pInfo->dev, prop_device_node, XA_STRING, 8,
-                               PropModeReplace, strlen(priv->device),
-                               priv->device, FALSE);
-        XISetDevicePropertyDeletable(pInfo->dev, prop_device_node, FALSE);
-    }
-
-}
-
-int
-SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
-            BOOL checkonly)
-{
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
-    SynapticsParameters *para = &priv->synpara;
-    SynapticsParameters tmp;
-
-    /* If checkonly is set, no parameters may be changed. So just let the code
-     * change temporary variables and forget about it. */
-    if (checkonly)
-    {
-        tmp = *para;
-        para = &tmp;
-    }
-
-    if (property == prop_edges)
-    {
-        INT32 *edges;
-        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        edges = (INT32*)prop->data;
-        if (edges[0] > edges[1] || edges[2] > edges[3])
-            return BadValue;
-
-        para->left_edge   = edges[0];
-        para->right_edge  = edges[1];
-        para->top_edge    = edges[2];
-        para->bottom_edge = edges[3];
-
-    } else if (property == prop_finger)
-    {
-        INT32 *finger;
-        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        finger = (INT32*)prop->data;
-        if (finger[0] > finger[1])
-            return BadValue;
-
-        para->finger_low   = finger[0];
-        para->finger_high  = finger[1];
-        para->finger_press = finger[2];
-
-    } else if (property == prop_tap_time)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->tap_time = *(INT32*)prop->data;
-
-    } else if (property == prop_tap_move)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->tap_move = *(INT32*)prop->data;
-    } else if (property == prop_tap_durations)
-    {
-        INT32 *timeouts;
-
-        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        timeouts = (INT32*)prop->data;
-
-        para->single_tap_timeout = timeouts[0];
-        para->tap_time_2         = timeouts[1];
-        para->click_time         = timeouts[2];
-
-    } else if (property == prop_tap_fast)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->fast_taps = *(BOOL*)prop->data;
-
-    } else if (property == prop_middle_timeout)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->emulate_mid_button_time = *(INT32*)prop->data;
-    } else if (property == prop_twofinger_pressure)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->emulate_twofinger_z = *(INT32*)prop->data;
-    } else if (property == prop_twofinger_width)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->emulate_twofinger_w = *(INT32*)prop->data;
-    } else if (property == prop_scrolldist)
-    {
-        INT32 *dist;
-        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        dist = (INT32*)prop->data;
-        para->scroll_dist_vert = dist[0];
-        para->scroll_dist_horiz = dist[1];
-    } else if (property == prop_scrolledge)
-    {
-        CARD8 *edge;
-        if (prop->size != 3 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        edge = (BOOL*)prop->data;
-        para->scroll_edge_vert   = edge[0];
-        para->scroll_edge_horiz  = edge[1];
-        para->scroll_edge_corner = edge[2];
-    } else if (property == prop_scrolltwofinger)
-    {
-        CARD8 *twofinger;
-
-        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        twofinger = (BOOL*)prop->data;
-        para->scroll_twofinger_vert  = twofinger[0];
-        para->scroll_twofinger_horiz = twofinger[1];
-    } else if (property == prop_speed)
-    {
-        float *speed;
-
-        if (prop->size != 4 || prop->format != 32 || prop->type != float_type)
-            return BadMatch;
-
-        speed = (float*)prop->data;
-        para->min_speed = speed[0];
-        para->max_speed = speed[1];
-        para->accl = speed[2];
-        para->trackstick_speed = speed[3];
-
-    } else if (property == prop_edgemotion_pressure)
-    {
-        CARD32 *pressure;
-
-        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        pressure = (CARD32*)prop->data;
-        if (pressure[0] > pressure[1])
-            return BadValue;
-
-        para->edge_motion_min_z = pressure[0];
-        para->edge_motion_max_z = pressure[1];
-
-    } else if (property == prop_edgemotion_speed)
-    {
-        CARD32 *speed;
-
-        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        speed = (CARD32*)prop->data;
-        if (speed[0] > speed[1])
-            return BadValue;
-
-        para->edge_motion_min_speed = speed[0];
-        para->edge_motion_max_speed = speed[1];
-
-    } else if (property == prop_edgemotion_always)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->edge_motion_use_always = *(BOOL*)prop->data;
-
-    } else if (property == prop_buttonscroll)
-    {
-        BOOL *scroll;
-
-        if (!priv->has_scrollbuttons)
-            return BadMatch;
-
-        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        scroll = (BOOL*)prop->data;
-        para->updown_button_scrolling    = scroll[0];
-        para->leftright_button_scrolling = scroll[1];
-
-    } else if (property == prop_buttonscroll_repeat)
-    {
-        BOOL *repeat;
-
-        if (!priv->has_scrollbuttons)
-            return BadMatch;
-
-        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        repeat = (BOOL*)prop->data;
-        para->updown_button_repeat    = repeat[0];
-        para->leftright_button_repeat = repeat[1];
-    } else if (property == prop_buttonscroll_time)
-    {
-        if (!priv->has_scrollbuttons)
-            return BadMatch;
-
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->scroll_button_repeat = *(INT32*)prop->data;
-
-    } else if (property == prop_off)
-    {
-        CARD8 off;
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        off = *(CARD8*)prop->data;
-
-        if (off > 2)
-            return BadValue;
-
-        para->touchpad_off = off;
-    } else if (property == prop_gestures)
-    {
-        BOOL *gestures;
-
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        gestures = (BOOL*)prop->data;
-        para->tap_and_drag_gesture = gestures[0];
-    } else if (property == prop_lockdrags)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->locked_drags = *(BOOL*)prop->data;
-    } else if (property == prop_lockdrags_time)
-    {
-        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->locked_drag_time = *(INT32*)prop->data;
-    } else if (property == prop_tapaction)
-    {
-        int i;
-        CARD8 *action;
-
-        if (prop->size > MAX_TAP || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        action = (CARD8*)prop->data;
-
-        for (i = 0; i < MAX_TAP; i++)
-            para->tap_action[i] = action[i];
-    } else if (property == prop_clickaction)
-    {
-        int i;
-        CARD8 *action;
-
-        if (prop->size > MAX_CLICK || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        action = (CARD8*)prop->data;
-
-        for (i = 0; i < MAX_CLICK; i++)
-            para->click_action[i] = action[i];
-    } else if (property == prop_circscroll)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->circular_scrolling = *(BOOL*)prop->data;
-
-    } else if (property == prop_circscroll_dist)
-    {
-        float circdist;
-
-        if (prop->size != 1 || prop->format != 32 || prop->type != float_type)
-            return BadMatch;
-
-        circdist = *(float*)prop->data;
-        para->scroll_dist_circ = circdist;
-    } else if (property == prop_circscroll_trigger)
-    {
-        int trigger;
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        trigger = *(CARD8*)prop->data;
-        if (trigger > 8)
-            return BadValue;
-
-        para->circular_trigger = trigger;
-
-    } else if (property == prop_circpad)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->circular_pad = *(BOOL*)prop->data;
-    } else if (property == prop_palm)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->palm_detect = *(BOOL*)prop->data;
-    } else if (property == prop_palm_dim)
-    {
-        INT32 *dim;
-
-        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        dim = (INT32*)prop->data;
-
-        para->palm_min_width = dim[0];
-        para->palm_min_z     = dim[1];
-    } else if (property == prop_coastspeed)
-    {
-        float *coast_speeds;
-
-        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
-            return BadMatch;
-
-        coast_speeds = (float*)prop->data;
-        para->coasting_speed = coast_speeds[0];
-        para->coasting_friction = coast_speeds[1];
-    } else if (property == prop_pressuremotion)
-    {
-        float *press;
-        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
-            return BadMatch;
-
-        press = (float*)prop->data;
-        if (press[0] > press[1])
-            return BadValue;
-
-        para->press_motion_min_z = press[0];
-        para->press_motion_max_z = press[1];
-    } else if (property == prop_grab)
-    {
-        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        para->grab_event_device = *(BOOL*)prop->data;
-    } else if (property == prop_capabilities)
-    {
-        /* read-only */
-        return BadValue;
-    } else if (property == prop_resolution)
-    {
-        /* read-only */
-        return BadValue;
-    } else if (property == prop_area)
-    {
-        INT32 *area;
-        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        area = (INT32*)prop->data;
-        if ((((area[0] != 0) && (area[1] != 0)) && (area[0] > area[1]) ) || (((area[2] != 0) && (area[3] != 0)) && (area[2] > area[3])))
-            return BadValue;
-
-        para->area_left_edge   = area[0];
-        para->area_right_edge  = area[1];
-        para->area_top_edge    = area[2];
-        para->area_bottom_edge = area[3];
-    } else if (property == prop_noise_cancellation) {
-        INT32 *hyst;
-        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
-            return BadMatch;
-
-        hyst = (INT32*)prop->data;
-        if (hyst[0] < 0 || hyst[1] < 0)
-            return BadValue;
-        para->hyst_x = hyst[0];
-        para->hyst_y = hyst[1];
-    } else if (property == prop_product_id || property == prop_device_node)
-        return BadValue; /* read-only */
-
-    return Success;
-}
-
diff -Naur xf86-input-synaptics-1.5.0/src/synaptics.c xf86-input-synaptics-1.5.0-old/src/synaptics.c
--- xf86-input-synaptics-1.5.0/src/synaptics.c	2011-10-14 01:34:08.622291857 +0200
+++ xf86-input-synaptics-1.5.0-old/src/synaptics.c	2011-10-14 01:33:00.386074730 +0200
@@ -410,7 +410,6 @@
     int vertResolution = 1;
     int width, height, diag, range;
     int horizHyst, vertHyst;
-    int orientation;
 
     /* read the parameters */
     if (priv->synshm)
@@ -490,7 +489,6 @@
     }
 
     /* set the parameters */
-    pars->orientation = xf86SetIntOption(opts, "Orientation", 0);
     pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
     pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
     pars->top_edge = xf86SetIntOption(opts, "TopEdge", t);
diff -Naur xf86-input-synaptics-1.5.0/src/synaptics.c.orig xf86-input-synaptics-1.5.0-old/src/synaptics.c.orig
--- xf86-input-synaptics-1.5.0/src/synaptics.c.orig	2011-09-02 08:03:42.000000000 +0200
+++ xf86-input-synaptics-1.5.0-old/src/synaptics.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,2683 +0,0 @@
-/*
- * Copyright © 1999 Henry Davies
- * Copyright © 2001 Stefan Gmeiner
- * Copyright © 2002 S. Lehner
- * Copyright © 2002 Peter Osterlund
- * Copyright © 2002 Linuxcare Inc. David Kennedy
- * Copyright © 2003 Hartwig Felger
- * Copyright © 2003 Jörg Bösner
- * Copyright © 2003 Fred Hucht
- * Copyright © 2004 Alexei Gilchrist
- * Copyright © 2004 Matthias Ihmig
- * Copyright © 2006 Stefan Bethge
- * Copyright © 2006 Christian Thaeter
- * Copyright © 2007 Joseph P. Skudlarek
- * Copyright © 2008 Fedor P. Goncharov
- * Copyright © 2008-2009 Red Hat, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Red Hat
- * not be used in advertising or publicity pertaining to distribution
- * of the software without specific, written prior permission.  Red
- * Hat makes no representations about the suitability of this software
- * for any purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
- * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Authors:
- *      Joseph P. Skudlarek <Jskud@Jskud.com>
- *      Christian Thaeter <chth@gmx.net>
- *      Stefan Bethge <stefan.bethge@web.de>
- *      Matthias Ihmig <m.ihmig@gmx.net>
- *      Alexei Gilchrist <alexei@physics.uq.edu.au>
- *      Jörg Bösner <ich@joerg-boesner.de>
- *      Hartwig Felger <hgfelger@hgfelger.de>
- *      Peter Osterlund <petero2@telia.com>
- *      S. Lehner <sam_x@bluemail.ch>
- *      Stefan Gmeiner <riddlebox@freesurf.ch>
- *      Henry Davies <hdavies@ameritech.net> for the
- *      Linuxcare Inc. David Kennedy <dkennedy@linuxcare.com>
- *      Fred Hucht <fred@thp.Uni-Duisburg.de>
- *      Fedor P. Goncharov <fedgo@gorodok.net>
- *      Simon Thum <simon.thum@gmx.de>
- *
- * Trademarks are the property of their respective owners.
- */
-
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <xorg-server.h>
-#include <unistd.h>
-#include <misc.h>
-#include <xf86.h>
-#include <sys/shm.h>
-#include <math.h>
-#include <stdio.h>
-#include <xf86_OSproc.h>
-#include <xf86Xinput.h>
-#include <exevents.h>
-
-#include "synaptics.h"
-#include "synapticsstr.h"
-#include "synaptics-properties.h"
-
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-#include <X11/Xatom.h>
-#include <xserver-properties.h>
-#include <ptrveloc.h>
-#endif
-
-typedef enum {
-    NO_EDGE = 0,
-    BOTTOM_EDGE = 1,
-    TOP_EDGE = 2,
-    LEFT_EDGE = 4,
-    RIGHT_EDGE = 8,
-    LEFT_BOTTOM_EDGE = BOTTOM_EDGE | LEFT_EDGE,
-    RIGHT_BOTTOM_EDGE = BOTTOM_EDGE | RIGHT_EDGE,
-    RIGHT_TOP_EDGE = TOP_EDGE | RIGHT_EDGE,
-    LEFT_TOP_EDGE = TOP_EDGE | LEFT_EDGE
-} edge_type;
-
-#define MAX(a, b) (((a)>(b))?(a):(b))
-#define MIN(a, b) (((a)<(b))?(a):(b))
-#define TIME_DIFF(a, b) ((int)((a)-(b)))
-
-#define SQR(x) ((x) * (x))
-
-#ifndef M_PI
-#define M_PI 3.14159265358979323846
-#endif
-
-#ifndef M_SQRT1_2
-#define M_SQRT1_2  0.70710678118654752440  /* 1/sqrt(2) */
-#endif
-
-#define INPUT_BUFFER_SIZE 200
-
-/*****************************************************************************
- * Forward declaration
- ****************************************************************************/
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
-static int SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
-#else
-static InputInfoPtr SynapticsPreInit(InputDriverPtr drv, IDevPtr dev, int flags);
-#endif
-static void SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
-static Bool DeviceControl(DeviceIntPtr, int);
-static void ReadInput(InputInfoPtr);
-static int HandleState(InputInfoPtr, struct SynapticsHwState*);
-static int ControlProc(InputInfoPtr, xDeviceCtl*);
-static int SwitchMode(ClientPtr, DeviceIntPtr, int);
-static Bool DeviceInit(DeviceIntPtr);
-static Bool DeviceOn(DeviceIntPtr);
-static Bool DeviceOff(DeviceIntPtr);
-static Bool DeviceClose(DeviceIntPtr);
-static Bool QueryHardware(InputInfoPtr);
-static void ReadDevDimensions(InputInfoPtr);
-static void ScaleCoordinates(SynapticsPrivate *priv, struct SynapticsHwState *hw);
-static void CalculateScalingCoeffs(SynapticsPrivate *priv);
-static void SanitizeDimensions(InputInfoPtr pInfo);
-
-void InitDeviceProperties(InputInfoPtr pInfo);
-int SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
-                BOOL checkonly);
-
-const static struct {
-    const char *name;
-    struct SynapticsProtocolOperations *proto_ops;
-} protocols[] = {
-#ifdef BUILD_EVENTCOMM
-    {"event", &event_proto_operations},
-#endif
-#ifdef BUILD_PSMCOMM
-    {"psm", &psm_proto_operations},
-#endif
-#ifdef BUILD_PS2COMM
-    {"psaux", &psaux_proto_operations},
-    {"alps", &alps_proto_operations},
-#endif
-    {NULL, NULL}
-};
-
-InputDriverRec SYNAPTICS = {
-    1,
-    "synaptics",
-    NULL,
-    SynapticsPreInit,
-    SynapticsUnInit,
-    NULL,
-};
-
-static XF86ModuleVersionInfo VersionRec = {
-    "synaptics",
-    MODULEVENDORSTRING,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XORG_VERSION_CURRENT,
-    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
-    ABI_CLASS_XINPUT,
-    ABI_XINPUT_VERSION,
-    MOD_CLASS_XINPUT,
-    {0, 0, 0, 0}
-};
-
-static pointer
-SetupProc(pointer module, pointer options, int *errmaj, int *errmin)
-{
-    xf86AddInputDriver(&SYNAPTICS, module, 0);
-    return module;
-}
-
-_X_EXPORT XF86ModuleData synapticsModuleData = {
-    &VersionRec,
-    &SetupProc,
-    NULL
-};
-
-
-/*****************************************************************************
- *	Function Definitions
- ****************************************************************************/
-/**
- * Fill in default dimensions for backends that cannot query the hardware.
- * Eventually, we want the edges to be 1900/5400 for x, 1900/4000 for y.
- * These values are based so that calculate_edge_widths() will give us the
- * right values.
- *
- * The default values 1900, etc. come from the dawn of time, when men where
- * men, or possibly apes.
- */
-static void
-SanitizeDimensions(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *)pInfo->private;
-
-    if (priv->minx >= priv->maxx)
-    {
-	priv->minx = 1615;
-	priv->maxx = 5685;
-	priv->resx = 0;
-
-	xf86IDrvMsg(pInfo, X_PROBED,
-		    "invalid x-axis range.  defaulting to %d - %d\n",
-		    priv->minx, priv->maxx);
-    }
-
-    if (priv->miny >= priv->maxy)
-    {
-	priv->miny = 1729;
-	priv->maxy = 4171;
-	priv->resy = 0;
-
-	xf86IDrvMsg(pInfo, X_PROBED,
-		    "invalid y-axis range.  defaulting to %d - %d\n",
-		    priv->miny, priv->maxy);
-    }
-
-    if (priv->minp >= priv->maxp)
-    {
-	priv->minp = 0;
-	priv->maxp = 255;
-
-	xf86IDrvMsg(pInfo, X_PROBED,
-		    "invalid pressure range.  defaulting to %d - %d\n",
-		    priv->minp, priv->maxp);
-    }
-
-    if (priv->minw >= priv->maxw)
-    {
-	priv->minw = 0;
-	priv->maxw = 15;
-
-	xf86IDrvMsg(pInfo, X_PROBED,
-		    "invalid finger width range.  defaulting to %d - %d\n",
-		    priv->minw, priv->maxw);
-    }
-}
-
-static void
-SetDeviceAndProtocol(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = pInfo->private;
-    char *proto, *device;
-    int i;
-
-    proto = xf86SetStrOption(pInfo->options, "Protocol", NULL);
-    device = xf86SetStrOption(pInfo->options, "Device", NULL);
-    for (i = 0; protocols[i].name; i++) {
-        if ((!device || !proto) &&
-            protocols[i].proto_ops->AutoDevProbe &&
-            protocols[i].proto_ops->AutoDevProbe(pInfo, device))
-            break;
-        else if (proto && !strcmp(proto, protocols[i].name))
-            break;
-    }
-    free(proto);
-    free(device);
-
-    priv->proto_ops = protocols[i].proto_ops;
-}
-
-/*
- * Allocate and initialize read-only memory for the SynapticsParameters data to hold
- * driver settings.
- * The function will allocate shared memory if priv->shm_config is TRUE.
- */
-static Bool
-alloc_shm_data(InputInfoPtr pInfo)
-{
-    int shmid;
-    SynapticsPrivate *priv = pInfo->private;
-
-    if (priv->synshm)
-	return TRUE;			    /* Already allocated */
-
-    if (priv->shm_config) {
-	if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
-	    shmctl(shmid, IPC_RMID, NULL);
-	if ((shmid = shmget(SHM_SYNAPTICS, sizeof(SynapticsSHM),
-				0774 | IPC_CREAT)) == -1) {
-	    xf86IDrvMsg(pInfo, X_ERROR, "error shmget\n");
-	    return FALSE;
-	}
-	if ((priv->synshm = (SynapticsSHM*)shmat(shmid, NULL, 0)) == NULL) {
-	    xf86IDrvMsg(pInfo, X_ERROR, "error shmat\n");
-	    return FALSE;
-	}
-    } else {
-	priv->synshm = calloc(1, sizeof(SynapticsSHM));
-	if (!priv->synshm)
-	    return FALSE;
-    }
-
-    return TRUE;
-}
-
-/*
- * Free SynapticsParameters data previously allocated by alloc_shm_data().
- */
-static void
-free_shm_data(SynapticsPrivate *priv)
-{
-    int shmid;
-
-    if (!priv->synshm)
-	return;
-
-    if (priv->shm_config) {
-	if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) != -1)
-	    shmctl(shmid, IPC_RMID, NULL);
-    } else {
-	free(priv->synshm);
-    }
-
-    priv->synshm = NULL;
-}
-
-static void
-calculate_edge_widths(SynapticsPrivate *priv, int *l, int *r, int *t, int *b)
-{
-    int width, height;
-    int ewidth, eheight; /* edge width/height */
-
-    width = abs(priv->maxx - priv->minx);
-    height = abs(priv->maxy - priv->miny);
-
-    if (priv->model == MODEL_SYNAPTICS)
-    {
-        ewidth = width * .07;
-        eheight = height * .07;
-    } else if (priv->model == MODEL_ALPS)
-    {
-        ewidth = width * .15;
-        eheight = height * .15;
-    } else if (priv->model == MODEL_APPLETOUCH)
-    {
-        ewidth = width * .085;
-        eheight = height * .085;
-    } else
-    {
-        ewidth = width * .04;
-        eheight = height * .054;
-    }
-
-    *l = priv->minx + ewidth;
-    *r = priv->maxx - ewidth;
-    *t = priv->miny + eheight;
-    *b = priv->maxy - eheight;
-}
-
-/* Area options support both percent values and absolute values. This is
- * awkward. The xf86Set* calls will print to the log, but they'll
- * also print an error if we request a percent value but only have an
- * int. So - check first for percent, then call xf86Set* again to get
- * the log message.
- */
-static int set_percent_option(pointer options, const char* optname,
-                              const int range, const int offset,
-                              const int default_value)
-{
-    int result;
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 11
-    double percent = xf86CheckPercentOption(options, optname, -1);
-
-    if (percent >= 0.0) {
-        percent = xf86SetPercentOption(options, optname, -1);
-        result = percent/100.0 * range + offset;
-    } else
-#endif
-        result = xf86SetIntOption(options, optname, default_value);
-
-    return result;
-}
-
-static void set_default_parameters(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = pInfo->private; /* read-only */
-    pointer opts = pInfo->options; /* read-only */
-    SynapticsParameters *pars = &priv->synpara; /* modified */
-
-    int horizScrollDelta, vertScrollDelta;		/* pixels */
-    int tapMove;					/* pixels */
-    int l, r, t, b; /* left, right, top, bottom */
-    int edgeMotionMinSpeed, edgeMotionMaxSpeed;		/* pixels/second */
-    double accelFactor;					/* 1/pixels */
-    int fingerLow, fingerHigh, fingerPress;		/* pressure */
-    int emulateTwoFingerMinZ;				/* pressure */
-    int emulateTwoFingerMinW;				/* width */
-    int edgeMotionMinZ, edgeMotionMaxZ;			/* pressure */
-    int pressureMotionMinZ, pressureMotionMaxZ;		/* pressure */
-    int palmMinWidth, palmMinZ;				/* pressure */
-    int tapButton1, tapButton2, tapButton3;
-    int clickFinger1, clickFinger2, clickFinger3;
-    Bool vertEdgeScroll, horizEdgeScroll;
-    Bool vertTwoFingerScroll, horizTwoFingerScroll;
-    int horizResolution = 1;
-    int vertResolution = 1;
-    int width, height, diag, range;
-    int horizHyst, vertHyst;
-
-    /* read the parameters */
-    if (priv->synshm)
-        priv->synshm->version = (PACKAGE_VERSION_MAJOR*10000+PACKAGE_VERSION_MINOR*100+PACKAGE_VERSION_PATCHLEVEL);
-
-    /* The synaptics specs specify typical edge widths of 4% on x, and 5.4% on
-     * y (page 7) [Synaptics TouchPad Interfacing Guide, 510-000080 - A
-     * Second Edition, http://www.synaptics.com/support/dev_support.cfm, 8 Sep
-     * 2008]. We use 7% for both instead for synaptics devices, and 15% for
-     * ALPS models.
-     * http://bugs.freedesktop.org/show_bug.cgi?id=21214
-     *
-     * If the range was autodetected, apply these edge widths to all four
-     * sides.
-     */
-
-    width = abs(priv->maxx - priv->minx);
-    height = abs(priv->maxy - priv->miny);
-    diag = sqrt(width * width + height * height);
-
-    calculate_edge_widths(priv, &l, &r, &t, &b);
-
-    /* Again, based on typical x/y range and defaults */
-    horizScrollDelta = diag * .020;
-    vertScrollDelta = diag * .020;
-    tapMove = diag * .044;
-    edgeMotionMinSpeed = 1;
-    edgeMotionMaxSpeed = diag * .080;
-    accelFactor = 200.0 / diag; /* trial-and-error */
-
-    /* hysteresis, assume >= 0 is a detected value (e.g. evdev fuzz) */
-    horizHyst = pars->hyst_x >= 0 ? pars->hyst_x : diag * 0.005;
-    vertHyst = pars->hyst_y >= 0 ? pars->hyst_y : diag * 0.005;
-
-    range = priv->maxp - priv->minp + 1;
-
-    /* scaling based on defaults and a pressure of 256 */
-    fingerLow = priv->minp + range * (25.0/256);
-    fingerHigh = priv->minp + range * (30.0/256);
-    fingerPress = priv->minp + range * 1.000;
-    emulateTwoFingerMinZ = priv->minp + range * (282.0/256);
-    edgeMotionMinZ = priv->minp + range * (30.0/256);
-    edgeMotionMaxZ = priv->minp + range * (160.0/256);
-    pressureMotionMinZ = priv->minp + range * (30.0/256);
-    pressureMotionMaxZ = priv->minp + range * (160.0/256);
-    palmMinZ = priv->minp + range * (200.0/256);
-
-    range = priv->maxw - priv->minw + 1;
-
-    /* scaling based on defaults below and a tool width of 16 */
-    palmMinWidth = priv->minw + range * (10.0/16);
-    emulateTwoFingerMinW = priv->minw + range * (7.0/16);
-
-    /* Enable tap if we don't have a phys left button */
-    tapButton1 = priv->has_left ? 0 : 1;
-    tapButton2 = priv->has_left ? 0 : 3;
-    tapButton3 = priv->has_left ? 0 : 2;
-
-    /* Enable multifinger-click if only have one physical button,
-       otherwise clickFinger is always button 1. */
-    clickFinger1 = 1;
-    clickFinger2 = (priv->has_right || priv->has_middle) ? 1 : 3;
-    clickFinger3 = (priv->has_right || priv->has_middle) ? 1 : 2;
-
-    /* Enable vert edge scroll if we can't detect doubletap */
-    vertEdgeScroll = priv->has_double ? FALSE : TRUE;
-    horizEdgeScroll = FALSE;
-
-    /* Enable twofinger scroll if we can detect doubletap */
-    vertTwoFingerScroll = priv->has_double ? TRUE : FALSE;
-    horizTwoFingerScroll = FALSE;
-
-    /* Use resolution reported by hardware if available */
-    if ((priv->resx > 0) && (priv->resy > 0)) {
-        horizResolution = priv->resx;
-        vertResolution = priv->resy;
-    }
-
-    /* set the parameters */
-    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
-    pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
-    pars->top_edge = xf86SetIntOption(opts, "TopEdge", t);
-    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge", b);
-
-    pars->area_top_edge = set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
-    pars->area_bottom_edge = set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
-    pars->area_left_edge = set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
-    pars->area_right_edge = set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);
-
-    pars->hyst_x = set_percent_option(opts, "HorizHysteresis", width, 0, horizHyst);
-    pars->hyst_y = set_percent_option(opts, "VertHysteresis", height, 0, vertHyst);
-
-    pars->finger_low = xf86SetIntOption(opts, "FingerLow", fingerLow);
-    pars->finger_high = xf86SetIntOption(opts, "FingerHigh", fingerHigh);
-    pars->finger_press = xf86SetIntOption(opts, "FingerPress", fingerPress);
-    pars->tap_time = xf86SetIntOption(opts, "MaxTapTime", 180);
-    pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", tapMove);
-    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
-    pars->click_time = xf86SetIntOption(opts, "ClickTime", 100);
-    pars->fast_taps = xf86SetBoolOption(opts, "FastTaps", FALSE);
-    pars->emulate_mid_button_time = xf86SetIntOption(opts, "EmulateMidButtonTime", 75);
-    pars->emulate_twofinger_z = xf86SetIntOption(opts, "EmulateTwoFingerMinZ", emulateTwoFingerMinZ);
-    pars->emulate_twofinger_w = xf86SetIntOption(opts, "EmulateTwoFingerMinW", emulateTwoFingerMinW);
-    pars->scroll_dist_vert = xf86SetIntOption(opts, "VertScrollDelta", horizScrollDelta);
-    pars->scroll_dist_horiz = xf86SetIntOption(opts, "HorizScrollDelta", vertScrollDelta);
-    pars->scroll_edge_vert = xf86SetBoolOption(opts, "VertEdgeScroll", vertEdgeScroll);
-    pars->scroll_edge_horiz = xf86SetBoolOption(opts, "HorizEdgeScroll", horizEdgeScroll);
-    pars->scroll_edge_corner = xf86SetBoolOption(opts, "CornerCoasting", FALSE);
-    pars->scroll_twofinger_vert = xf86SetBoolOption(opts, "VertTwoFingerScroll", vertTwoFingerScroll);
-    pars->scroll_twofinger_horiz = xf86SetBoolOption(opts, "HorizTwoFingerScroll", horizTwoFingerScroll);
-    pars->edge_motion_min_z = xf86SetIntOption(opts, "EdgeMotionMinZ", edgeMotionMinZ);
-    pars->edge_motion_max_z = xf86SetIntOption(opts, "EdgeMotionMaxZ", edgeMotionMaxZ);
-    pars->edge_motion_min_speed = xf86SetIntOption(opts, "EdgeMotionMinSpeed", edgeMotionMinSpeed);
-    pars->edge_motion_max_speed = xf86SetIntOption(opts, "EdgeMotionMaxSpeed", edgeMotionMaxSpeed);
-    pars->edge_motion_use_always = xf86SetBoolOption(opts, "EdgeMotionUseAlways", FALSE);
-    if (priv->has_scrollbuttons) {
-	pars->updown_button_scrolling = xf86SetBoolOption(opts, "UpDownScrolling", TRUE);
-	pars->leftright_button_scrolling = xf86SetBoolOption(opts, "LeftRightScrolling", TRUE);
-	pars->updown_button_repeat = xf86SetBoolOption(opts, "UpDownScrollRepeat", TRUE);
-	pars->leftright_button_repeat = xf86SetBoolOption(opts, "LeftRightScrollRepeat", TRUE);
-    }
-    pars->scroll_button_repeat = xf86SetIntOption(opts,"ScrollButtonRepeat", 100);
-    pars->touchpad_off = xf86SetIntOption(opts, "TouchpadOff", 0);
-    pars->locked_drags = xf86SetBoolOption(opts, "LockedDrags", FALSE);
-    pars->locked_drag_time = xf86SetIntOption(opts, "LockedDragTimeout", 5000);
-    pars->tap_action[RT_TAP] = xf86SetIntOption(opts, "RTCornerButton", 0);
-    pars->tap_action[RB_TAP] = xf86SetIntOption(opts, "RBCornerButton", 0);
-    pars->tap_action[LT_TAP] = xf86SetIntOption(opts, "LTCornerButton", 0);
-    pars->tap_action[LB_TAP] = xf86SetIntOption(opts, "LBCornerButton", 0);
-    pars->tap_action[F1_TAP] = xf86SetIntOption(opts, "TapButton1",     tapButton1);
-    pars->tap_action[F2_TAP] = xf86SetIntOption(opts, "TapButton2",     tapButton2);
-    pars->tap_action[F3_TAP] = xf86SetIntOption(opts, "TapButton3",     tapButton3);
-    pars->click_action[F1_CLICK1] = xf86SetIntOption(opts, "ClickFinger1", clickFinger1);
-    pars->click_action[F2_CLICK1] = xf86SetIntOption(opts, "ClickFinger2", clickFinger2);
-    pars->click_action[F3_CLICK1] = xf86SetIntOption(opts, "ClickFinger3", clickFinger3);
-    pars->circular_scrolling = xf86SetBoolOption(opts, "CircularScrolling", FALSE);
-    pars->circular_trigger   = xf86SetIntOption(opts, "CircScrollTrigger", 0);
-    pars->circular_pad       = xf86SetBoolOption(opts, "CircularPad", FALSE);
-    pars->palm_detect        = xf86SetBoolOption(opts, "PalmDetect", FALSE);
-    pars->palm_min_width     = xf86SetIntOption(opts, "PalmMinWidth", palmMinWidth);
-    pars->palm_min_z         = xf86SetIntOption(opts, "PalmMinZ", palmMinZ);
-    pars->single_tap_timeout = xf86SetIntOption(opts, "SingleTapTimeout", 180);
-    pars->press_motion_min_z = xf86SetIntOption(opts, "PressureMotionMinZ", pressureMotionMinZ);
-    pars->press_motion_max_z = xf86SetIntOption(opts, "PressureMotionMaxZ", pressureMotionMaxZ);
-
-    pars->min_speed = xf86SetRealOption(opts, "MinSpeed", 0.4);
-    pars->max_speed = xf86SetRealOption(opts, "MaxSpeed", 0.7);
-    pars->accl = xf86SetRealOption(opts, "AccelFactor", accelFactor);
-    pars->trackstick_speed = xf86SetRealOption(opts, "TrackstickSpeed", 40);
-    pars->scroll_dist_circ = xf86SetRealOption(opts, "CircScrollDelta", 0.1);
-    pars->coasting_speed = xf86SetRealOption(opts, "CoastingSpeed", 20.0);
-    pars->coasting_friction = xf86SetRealOption(opts, "CoastingFriction", 50);
-    pars->press_motion_min_factor = xf86SetRealOption(opts, "PressureMotionMinFactor", 1.0);
-    pars->press_motion_max_factor = xf86SetRealOption(opts, "PressureMotionMaxFactor", 1.0);
-    pars->grab_event_device = xf86SetBoolOption(opts, "GrabEventDevice", TRUE);
-    pars->tap_and_drag_gesture = xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
-    pars->resolution_horiz = xf86SetIntOption(opts, "HorizResolution", horizResolution);
-    pars->resolution_vert = xf86SetIntOption(opts, "VertResolution", vertResolution);
-
-    /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
-    if (pars->top_edge > pars->bottom_edge) {
-	int tmp = pars->top_edge;
-	pars->top_edge = pars->bottom_edge;
-	pars->bottom_edge = tmp;
-	xf86IDrvMsg(pInfo, X_WARNING, "TopEdge is bigger than BottomEdge. Fixing.\n");
-    }
-}
-
-static float SynapticsAccelerationProfile(DeviceIntPtr dev,
-                                          DeviceVelocityPtr vel,
-                                          float velocity,
-                                          float thr,
-                                          float acc) {
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsParameters* para = &priv->synpara;
-
-    double accelfct;
-
-    /*
-     * synaptics accel was originally base on device coordinate based
-     * velocity, which we recover this way so para->accl retains its scale.
-     */
-    velocity /= vel->const_acceleration;
-
-    /* speed up linear with finger velocity */
-    accelfct = velocity * para->accl;
-
-    /* clip acceleration factor */
-    if (accelfct > para->max_speed * acc)
-	accelfct = para->max_speed * acc;
-    else if (accelfct < para->min_speed)
-	accelfct = para->min_speed;
-
-    /* modify speed according to pressure */
-    if (priv->moving_state == MS_TOUCHPAD_RELATIVE) {
-	int minZ = para->press_motion_min_z;
-	int maxZ = para->press_motion_max_z;
-	double minFctr = para->press_motion_min_factor;
-	double maxFctr = para->press_motion_max_factor;
-	if (priv->hwState.z <= minZ) {
-	    accelfct *= minFctr;
-	} else if (priv->hwState.z >= maxZ) {
-	    accelfct *= maxFctr;
-	} else {
-	    accelfct *= minFctr + (priv->hwState.z - minZ) * (maxFctr - minFctr) / (maxZ - minZ);
-	}
-    }
-
-    return accelfct;
-}
-
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
-static int
-NewSynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
-/*
- *  called by the module loader for initialization
- */
-static InputInfoPtr
-SynapticsPreInit(InputDriverPtr drv, IDevPtr dev, int flags)
-{
-    InputInfoPtr pInfo;
-
-    /* Allocate a new InputInfoRec and add it to the head xf86InputDevs. */
-    pInfo = xf86AllocateInput(drv, 0);
-    if (!pInfo) {
-	return NULL;
-    }
-
-    /* initialize the InputInfoRec */
-    pInfo->name                    = dev->identifier;
-    pInfo->reverse_conversion_proc = NULL;
-    pInfo->dev                     = NULL;
-    pInfo->private_flags           = 0;
-    pInfo->flags                   = XI86_SEND_DRAG_EVENTS;
-    pInfo->conf_idev               = dev;
-    pInfo->always_core_feedback    = 0;
-
-    xf86CollectInputOptions(pInfo, NULL, NULL);
-
-    if (NewSynapticsPreInit(drv, pInfo, flags) != Success)
-        return NULL;
-
-    pInfo->flags |= XI86_CONFIGURED;
-
-    return pInfo;
-}
-
-static int
-NewSynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
-#else
-static int
-SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
-#endif
-{
-    SynapticsPrivate *priv;
-
-    /* allocate memory for SynapticsPrivateRec */
-    priv = calloc(1, sizeof(SynapticsPrivate));
-    if (!priv)
-	return BadAlloc;
-
-    pInfo->type_name               = XI_TOUCHPAD;
-    pInfo->device_control          = DeviceControl;
-    pInfo->read_input              = ReadInput;
-    pInfo->control_proc            = ControlProc;
-    pInfo->switch_mode             = SwitchMode;
-    pInfo->private                 = priv;
-
-    /* allocate now so we don't allocate in the signal handler */
-    priv->timer = TimerSet(NULL, 0, 0, NULL, NULL);
-    if (!priv->timer) {
-	free(priv);
-	return BadAlloc;
-    }
-
-    /* may change pInfo->options */
-    SetDeviceAndProtocol(pInfo);
-    if (priv->proto_ops == NULL) {
-        xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to detect protocol\n");
-        goto SetupProc_fail;
-    }
-
-    priv->device = xf86FindOptionValue(pInfo->options, "Device");
-
-    /* open the touchpad device */
-    pInfo->fd = xf86OpenSerial(pInfo->options);
-    if (pInfo->fd == -1) {
-	xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to open device\n");
-	goto SetupProc_fail;
-    }
-    xf86ErrorFVerb(6, "port opened successfully\n");
-
-    /* initialize variables */
-    priv->repeatButtons = 0;
-    priv->nextRepeat = 0;
-    priv->count_packet_finger = 0;
-    priv->tap_state = TS_START;
-    priv->tap_button = 0;
-    priv->tap_button_state = TBS_BUTTON_UP;
-    priv->touch_on.millis = 0;
-    priv->synpara.hyst_x = -1;
-    priv->synpara.hyst_y = -1;
-
-    /* read hardware dimensions */
-    ReadDevDimensions(pInfo);
-
-    /* install shared memory or normal memory for parameters */
-    priv->shm_config = xf86SetBoolOption(pInfo->options, "SHMConfig", FALSE);
-
-    set_default_parameters(pInfo);
-
-    CalculateScalingCoeffs(priv);
-
-    if (!alloc_shm_data(pInfo))
-	goto SetupProc_fail;
-
-    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);
-
-    if (!QueryHardware(pInfo)) {
-	xf86IDrvMsg(pInfo, X_ERROR, "Unable to query/initialize Synaptics hardware.\n");
-	goto SetupProc_fail;
-    }
-
-    xf86ProcessCommonOptions(pInfo, pInfo->options);
-
-    if (pInfo->fd != -1) {
-	if (priv->comm.buffer) {
-	    XisbFree(priv->comm.buffer);
-	    priv->comm.buffer = NULL;
-	}
-	xf86CloseSerial(pInfo->fd);
-    }
-    pInfo->fd = -1;
-
-    return Success;
-
- SetupProc_fail:
-    if (pInfo->fd >= 0) {
-	xf86CloseSerial(pInfo->fd);
-	pInfo->fd = -1;
-    }
-
-    if (priv->comm.buffer)
-	XisbFree(priv->comm.buffer);
-    free_shm_data(priv);
-    free(priv->proto_data);
-    free(priv->timer);
-    free(priv);
-    pInfo->private = NULL;
-    return BadAlloc;
-}
-
-
-/*
- *  Uninitialize the device.
- */
-static void SynapticsUnInit(InputDriverPtr drv,
-                            InputInfoPtr   pInfo,
-                            int            flags)
-{
-    SynapticsPrivate *priv = ((SynapticsPrivate *)pInfo->private);
-    if (priv && priv->timer)
-        free(priv->timer);
-    if (priv && priv->proto_data)
-        free(priv->proto_data);
-    free(pInfo->private);
-    pInfo->private = NULL;
-    xf86DeleteInput(pInfo, 0);
-}
-
-
-/*
- *  Alter the control parameters for the mouse. Note that all special
- *  protocol values are handled by dix.
- */
-static void
-SynapticsCtrl(DeviceIntPtr device, PtrCtrl *ctrl)
-{
-}
-
-static Bool
-DeviceControl(DeviceIntPtr dev, int mode)
-{
-    Bool RetValue;
-
-    switch (mode) {
-    case DEVICE_INIT:
-	RetValue = DeviceInit(dev);
-	break;
-    case DEVICE_ON:
-	RetValue = DeviceOn(dev);
-	break;
-    case DEVICE_OFF:
-	RetValue = DeviceOff(dev);
-	break;
-    case DEVICE_CLOSE:
-	RetValue = DeviceClose(dev);
-	break;
-    default:
-	RetValue = BadValue;
-    }
-
-    return RetValue;
-}
-
-static Bool
-DeviceOn(DeviceIntPtr dev)
-{
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-
-    DBG(3, "Synaptics DeviceOn called\n");
-
-    pInfo->fd = xf86OpenSerial(pInfo->options);
-    if (pInfo->fd == -1) {
-	xf86IDrvMsg(pInfo, X_WARNING, "cannot open input device\n");
-	return !Success;
-    }
-
-    if (priv->proto_ops->DeviceOnHook)
-        priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara);
-
-    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);
-    if (!priv->comm.buffer) {
-	xf86CloseSerial(pInfo->fd);
-	pInfo->fd = -1;
-	return !Success;
-    }
-
-    xf86FlushInput(pInfo->fd);
-
-    /* reinit the pad */
-    if (!QueryHardware(pInfo))
-    {
-        XisbFree(priv->comm.buffer);
-        priv->comm.buffer = NULL;
-        xf86CloseSerial(pInfo->fd);
-        pInfo->fd = -1;
-        return !Success;
-    }
-
-    xf86AddEnabledDevice(pInfo);
-    dev->public.on = TRUE;
-
-    return Success;
-}
-
-static Bool
-DeviceOff(DeviceIntPtr dev)
-{
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-
-    DBG(3, "Synaptics DeviceOff called\n");
-
-    if (pInfo->fd != -1) {
-	TimerCancel(priv->timer);
-	xf86RemoveEnabledDevice(pInfo);
-        if (priv->proto_ops->DeviceOffHook)
-            priv->proto_ops->DeviceOffHook(pInfo);
-	if (priv->comm.buffer) {
-	    XisbFree(priv->comm.buffer);
-	    priv->comm.buffer = NULL;
-	}
-	xf86CloseSerial(pInfo->fd);
-	pInfo->fd = -1;
-    }
-    dev->public.on = FALSE;
-    return Success;
-}
-
-static Bool
-DeviceClose(DeviceIntPtr dev)
-{
-    Bool RetValue;
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
-
-    RetValue = DeviceOff(dev);
-    TimerFree(priv->timer);
-    priv->timer = NULL;
-    free_shm_data(priv);
-    return RetValue;
-}
-
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-static void InitAxesLabels(Atom *labels, int nlabels)
-{
-    memset(labels, 0, nlabels * sizeof(Atom));
-    switch(nlabels)
-    {
-        default:
-        case 2:
-            labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
-        case 1:
-            labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
-            break;
-    }
-}
-
-static void InitButtonLabels(Atom *labels, int nlabels)
-{
-    memset(labels, 0, nlabels * sizeof(Atom));
-    switch(nlabels)
-    {
-        default:
-        case 7:
-            labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
-        case 6:
-            labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
-        case 5:
-            labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
-        case 4:
-            labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
-        case 3:
-            labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
-        case 2:
-            labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
-        case 1:
-            labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
-            break;
-    }
-}
-#endif
-
-static Bool
-DeviceInit(DeviceIntPtr dev)
-{
-    InputInfoPtr pInfo = dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    Atom float_type, prop;
-    float tmpf;
-    unsigned char map[SYN_MAX_BUTTONS + 1];
-    int i;
-    int min, max;
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-    Atom btn_labels[SYN_MAX_BUTTONS] = { 0 };
-    Atom axes_labels[2] = { 0 };
-    DeviceVelocityPtr pVel;
-
-    InitAxesLabels(axes_labels, 2);
-    InitButtonLabels(btn_labels, SYN_MAX_BUTTONS);
-#endif
-
-    DBG(3, "Synaptics DeviceInit called\n");
-
-    for (i = 0; i <= SYN_MAX_BUTTONS; i++)
-	map[i] = i;
-
-    dev->public.on = FALSE;
-
-    InitPointerDeviceStruct((DevicePtr)dev, map,
-			    SYN_MAX_BUTTONS,
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-                            btn_labels,
-#endif
-			    SynapticsCtrl,
-			    GetMotionHistorySize(), 2
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-                            , axes_labels
-#endif
-			    );
-
-    /*
-     * setup dix acceleration to match legacy synaptics settings, and
-     * etablish a device-specific profile to do stuff like pressure-related
-     * acceleration.
-     */
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-    if (NULL != (pVel = GetDevicePredictableAccelData(dev))) {
-	SetDeviceSpecificAccelerationProfile(pVel,
-	                                     SynapticsAccelerationProfile);
-
-	/* float property type */
-	float_type = XIGetKnownProperty(XATOM_FLOAT);
-
-	/* translate MinAcc to constant deceleration.
-	 * May be overridden in xf86InitValuatorDefaults */
-	tmpf = 1.0 / priv->synpara.min_speed;
-
-	xf86IDrvMsg(pInfo, X_CONFIG, "(accel) MinSpeed is now constant deceleration "
-		    "%.1f\n", tmpf);
-	prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
-	XIChangeDeviceProperty(dev, prop, float_type, 32,
-	                       PropModeReplace, 1, &tmpf, FALSE);
-
-	/* adjust accordingly */
-	priv->synpara.max_speed /= priv->synpara.min_speed;
-	priv->synpara.min_speed = 1.0;
-
-	/* synaptics seems to report 80 packet/s, but dix scales for
-	 * 100 packet/s by default. */
-	pVel->corr_mul = 12.5f; /*1000[ms]/80[/s] = 12.5 */
-
-	xf86IDrvMsg(pInfo, X_CONFIG, "MaxSpeed is now %.2f\n",
-		    priv->synpara.max_speed);
-	xf86IDrvMsg(pInfo, X_CONFIG, "AccelFactor is now %.3f\n",
-		    priv->synpara.accl);
-
-	prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
-	i = AccelProfileDeviceSpecific;
-	XIChangeDeviceProperty(dev, prop, XA_INTEGER, 32,
-	                       PropModeReplace, 1, &i, FALSE);
-    }
-#endif
-
-    /* X valuator */
-    if (priv->minx < priv->maxx)
-    {
-        min = priv->minx;
-        max = priv->maxx;
-    } else
-    {
-        min = 0;
-        max = -1;
-    }
-
-    xf86InitValuatorAxisStruct(dev, 0,
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-            axes_labels[0],
-#endif
-            min, max, priv->resx * 1000, 0, priv->resx * 1000
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
-            , Relative
-#endif
-            );
-    xf86InitValuatorDefaults(dev, 0);
-
-    /* Y valuator */
-    if (priv->miny < priv->maxy)
-    {
-        min = priv->miny;
-        max = priv->maxy;
-    } else
-    {
-        min = 0;
-        max = -1;
-    }
-
-    xf86InitValuatorAxisStruct(dev, 1,
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 7
-            axes_labels[1],
-#endif
-            min, max, priv->resy * 1000, 0, priv->resy * 1000
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) >= 12
-            , Relative
-#endif
-            );
-    xf86InitValuatorDefaults(dev, 1);
-
-    if (!alloc_shm_data(pInfo))
-	return !Success;
-
-    InitDeviceProperties(pInfo);
-    XIRegisterPropertyHandler(pInfo->dev, SetProperty, NULL, NULL);
-
-    return Success;
-}
-
-
-/*
- * Convert from absolute X/Y coordinates to a coordinate system where
- * -1 corresponds to the left/upper edge and +1 corresponds to the
- * right/lower edge.
- */
-static void
-relative_coords(SynapticsPrivate *priv, int x, int y,
-		double *relX, double *relY)
-{
-    int minX = priv->synpara.left_edge;
-    int maxX = priv->synpara.right_edge;
-    int minY = priv->synpara.top_edge;
-    int maxY = priv->synpara.bottom_edge;
-    double xCenter = (minX + maxX) / 2.0;
-    double yCenter = (minY + maxY) / 2.0;
-
-    if ((maxX - xCenter > 0) && (maxY - yCenter > 0)) {
-	*relX = (x - xCenter) / (maxX - xCenter);
-	*relY = (y - yCenter) / (maxY - yCenter);
-    } else {
-	*relX = 0;
-	*relY = 0;
-    }
-}
-
-/* return angle of point relative to center */
-static double
-angle(SynapticsPrivate *priv, int x, int y)
-{
-    double xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2.0;
-    double yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2.0;
-
-    return atan2(-(y - yCenter), x - xCenter);
-}
-
-/* return angle difference */
-static double
-diffa(double a1, double a2)
-{
-    double da = fmod(a2 - a1, 2 * M_PI);
-    if (da < 0)
-	da += 2 * M_PI;
-    if (da > M_PI)
-	da -= 2 * M_PI;
-    return da;
-}
-
-static edge_type
-circular_edge_detection(SynapticsPrivate *priv, int x, int y)
-{
-    edge_type edge = 0;
-    double relX, relY, relR;
-
-    relative_coords(priv, x, y, &relX, &relY);
-    relR = SQR(relX) + SQR(relY);
-
-    if (relR > 1) {
-	/* we are outside the ellipse enclosed by the edge parameters */
-	if (relX > M_SQRT1_2)
-	    edge |= RIGHT_EDGE;
-	else if (relX < -M_SQRT1_2)
-	    edge |= LEFT_EDGE;
-
-	if (relY < -M_SQRT1_2)
-	    edge |= TOP_EDGE;
-	else if (relY > M_SQRT1_2)
-	    edge |= BOTTOM_EDGE;
-    }
-
-    return edge;
-}
-
-static edge_type
-edge_detection(SynapticsPrivate *priv, int x, int y)
-{
-    edge_type edge = NO_EDGE;
-
-    if (priv->synpara.circular_pad)
-	return circular_edge_detection(priv, x, y);
-
-    if (x > priv->synpara.right_edge)
-	edge |= RIGHT_EDGE;
-    else if (x < priv->synpara.left_edge)
-	edge |= LEFT_EDGE;
-
-    if (y < priv->synpara.top_edge)
-	edge |= TOP_EDGE;
-    else if (y > priv->synpara.bottom_edge)
-	edge |= BOTTOM_EDGE;
-
-    return edge;
-}
-
-/* Checks whether coordinates are in the Synaptics Area
- * or not. If no Synaptics Area is defined (i.e. if
- * priv->synpara.area_{left|right|top|bottom}_edge are
- * all set to zero), the function returns TRUE.
- */
-static Bool
-is_inside_active_area(SynapticsPrivate *priv, int x, int y)
-{
-    Bool inside_area = TRUE;
-
-    if ((priv->synpara.area_left_edge != 0) && (x < priv->synpara.area_left_edge))
-	inside_area = FALSE;
-    else if ((priv->synpara.area_right_edge != 0) && (x > priv->synpara.area_right_edge))
-	inside_area = FALSE;
-
-    if ((priv->synpara.area_top_edge != 0) && (y < priv->synpara.area_top_edge))
-	inside_area = FALSE;
-    else if ((priv->synpara.area_bottom_edge != 0) && (y > priv->synpara.area_bottom_edge))
-	inside_area = FALSE;
-
-    return inside_area;
-}
-
-static CARD32
-timerFunc(OsTimerPtr timer, CARD32 now, pointer arg)
-{
-    InputInfoPtr pInfo = arg;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    struct SynapticsHwState hw;
-    int delay;
-    int sigstate;
-    CARD32 wakeUpTime;
-
-    sigstate = xf86BlockSIGIO();
-
-    hw = priv->hwState;
-    hw.millis = now;
-    delay = HandleState(pInfo, &hw);
-
-    /*
-     * Workaround for wraparound bug in the TimerSet function. This bug is already
-     * fixed in CVS, but this driver needs to work with XFree86 versions 4.2.x and
-     * 4.3.x too.
-     */
-    wakeUpTime = now + delay;
-    if (wakeUpTime <= now)
-	wakeUpTime = 0xffffffffL;
-
-    priv->timer = TimerSet(priv->timer, TimerAbsolute, wakeUpTime, timerFunc, pInfo);
-
-    xf86UnblockSIGIO(sigstate);
-
-    return 0;
-}
-
-static int
-clamp(int val, int min, int max)
-{
-    if (val < min)
-	return min;
-    else if (val < max)
-	return val;
-    else
-	return max;
-}
-
-static Bool
-SynapticsGetHwState(InputInfoPtr pInfo, SynapticsPrivate *priv,
-		    struct SynapticsHwState *hw)
-{
-    return priv->proto_ops->ReadHwState(pInfo, &priv->comm, hw);
-}
-
-/*
- *  called for each full received packet from the touchpad
- */
-static void
-ReadInput(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    struct SynapticsHwState hw;
-    int delay = 0;
-    Bool newDelay = FALSE;
-
-    while (SynapticsGetHwState(pInfo, priv, &hw)) {
-	hw.millis = GetTimeInMillis();
-	priv->hwState = hw;
-	delay = HandleState(pInfo, &hw);
-	newDelay = TRUE;
-    }
-
-    if (newDelay)
-	priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
-}
-
-static int
-HandleMidButtonEmulation(SynapticsPrivate *priv, struct SynapticsHwState *hw, int *delay)
-{
-    SynapticsParameters *para = &priv->synpara;
-    Bool done = FALSE;
-    int timeleft;
-    int mid = 0;
-
-    while (!done) {
-	switch (priv->mid_emu_state) {
-	case MBE_LEFT_CLICK:
-	case MBE_RIGHT_CLICK:
-	case MBE_OFF:
-	    priv->button_delay_millis = hw->millis;
-	    if (hw->left) {
-		priv->mid_emu_state = MBE_LEFT;
-	    } else if (hw->right) {
-		priv->mid_emu_state = MBE_RIGHT;
-	    } else {
-		done = TRUE;
-	    }
-	    break;
-	case MBE_LEFT:
-	    timeleft = TIME_DIFF(priv->button_delay_millis + para->emulate_mid_button_time,
-				 hw->millis);
-	    if (timeleft > 0)
-		*delay = MIN(*delay, timeleft);
-
-            /* timeout, but within the same ReadInput cycle! */
-            if ((timeleft <= 0) && !hw->left) {
-		priv->mid_emu_state = MBE_LEFT_CLICK;
-		done = TRUE;
-            } else if ((!hw->left) || (timeleft <= 0)) {
-		hw->left = TRUE;
-		priv->mid_emu_state = MBE_TIMEOUT;
-		done = TRUE;
-	    } else if (hw->right) {
-		priv->mid_emu_state = MBE_MID;
-	    } else {
-		hw->left = FALSE;
-		done = TRUE;
-	    }
-	    break;
-	case MBE_RIGHT:
-	    timeleft = TIME_DIFF(priv->button_delay_millis + para->emulate_mid_button_time,
-				 hw->millis);
-	    if (timeleft > 0)
-		*delay = MIN(*delay, timeleft);
-
-	     /* timeout, but within the same ReadInput cycle! */
-            if ((timeleft <= 0) && !hw->right) {
-		priv->mid_emu_state = MBE_RIGHT_CLICK;
-		done = TRUE;
-            } else if (!hw->right || (timeleft <= 0)) {
-		hw->right = TRUE;
-		priv->mid_emu_state = MBE_TIMEOUT;
-		done = TRUE;
-	    } else if (hw->left) {
-		priv->mid_emu_state = MBE_MID;
-	    } else {
-		hw->right = FALSE;
-		done = TRUE;
-	    }
-	    break;
-	case MBE_MID:
-	    if (!hw->left && !hw->right) {
-		priv->mid_emu_state = MBE_OFF;
-	    } else {
-		mid = TRUE;
-		hw->left = hw->right = FALSE;
-		done = TRUE;
-	    }
-	    break;
-	case MBE_TIMEOUT:
-	    if (!hw->left && !hw->right) {
-		priv->mid_emu_state = MBE_OFF;
-	    } else {
-		done = TRUE;
-	    }
-	}
-    }
-    return mid;
-}
-
-static enum FingerState
-SynapticsDetectFinger(SynapticsPrivate *priv, struct SynapticsHwState *hw)
-{
-    SynapticsParameters *para = &priv->synpara;
-    enum FingerState finger;
-
-    /* finger detection thru pressure and threshold */
-    if (hw->z > para->finger_press && priv->finger_state < FS_PRESSED)
-        finger = FS_PRESSED;
-    else if (hw->z > para->finger_high && priv->finger_state < FS_TOUCHED)
-        finger = FS_TOUCHED;
-    else if (hw->z < para->finger_low &&  priv->finger_state > FS_UNTOUCHED)
-        finger = FS_UNTOUCHED;
-    else
-	finger = priv->finger_state;
-
-    if (!para->palm_detect)
-	return finger;
-
-    /* palm detection */
-    if (finger) {
-	if ((hw->z > para->palm_min_z) && (hw->fingerWidth > para->palm_min_width))
-	    priv->palm = TRUE;
-    } else {
-	priv->palm = FALSE;
-    }
-    if (hw->x == 0)
-	priv->avg_width = 0;
-    else
-	priv->avg_width += (hw->fingerWidth - priv->avg_width + 1) / 2;
-    if (finger && !priv->finger_state) {
-	int safe_width = MAX(hw->fingerWidth, priv->avg_width);
-
-	if (hw->numFingers > 1 ||	/* more than one finger -> not a palm */
-	    ((safe_width < 6) && (priv->prev_z < para->finger_high)) ||  /* thin finger, distinct touch -> not a palm */
-	    ((safe_width < 7) && (priv->prev_z < para->finger_high / 2)))/* thin finger, distinct touch -> not a palm */
-	{
-	    /* leave finger value as is */
-	} else if (hw->z > priv->prev_z + 1)	/* z not stable, may be a palm */
-	    finger = FS_UNTOUCHED;
-	else if (hw->z < priv->prev_z - 5)	/* z not stable, may be a palm */
-	    finger = FS_UNTOUCHED;
-	else if (hw->fingerWidth > para->palm_min_width) /* finger width too large -> probably palm */
-	    finger = FS_UNTOUCHED;
-    }
-    priv->prev_z = hw->z;
-
-    if (priv->palm)
-	finger = FS_UNTOUCHED;
-
-    return finger;
-}
-
-static void
-SelectTapButton(SynapticsPrivate *priv, edge_type edge)
-{
-    TapEvent tap;
-
-    if (priv->synpara.touchpad_off == 2) {
-	priv->tap_button = 0;
-	return;
-    }
-
-    switch (priv->tap_max_fingers) {
-    case 1:
-    default:
-	switch (edge) {
-	case RIGHT_TOP_EDGE:
-	    DBG(7, "right top edge\n");
-	    tap = RT_TAP;
-	    break;
-	case RIGHT_BOTTOM_EDGE:
-	    DBG(7, "right bottom edge\n");
-	    tap = RB_TAP;
-	    break;
-	case LEFT_TOP_EDGE:
-	    DBG(7, "left top edge\n");
-	    tap = LT_TAP;
-	    break;
-	case LEFT_BOTTOM_EDGE:
-	    DBG(7, "left bottom edge\n");
-	    tap = LB_TAP;
-	    break;
-	default:
-	    DBG(7, "no edge\n");
-	    tap = F1_TAP;
-	    break;
-	}
-	break;
-    case 2:
-	DBG(7, "two finger tap\n");
-	tap = F2_TAP;
-	break;
-    case 3:
-	DBG(7, "three finger tap\n");
-	tap = F3_TAP;
-	break;
-    }
-
-    priv->tap_button = priv->synpara.tap_action[tap];
-    priv->tap_button = clamp(priv->tap_button, 0, SYN_MAX_BUTTONS);
-}
-
-static void
-SetTapState(SynapticsPrivate *priv, enum TapState tap_state, int millis)
-{
-    SynapticsParameters *para = &priv->synpara;
-    DBG(7, "SetTapState - %d -> %d (millis:%d)\n", priv->tap_state, tap_state, millis);
-    switch (tap_state) {
-    case TS_START:
-	priv->tap_button_state = TBS_BUTTON_UP;
-	priv->tap_max_fingers = 0;
-	break;
-    case TS_1:
-	priv->tap_button_state = TBS_BUTTON_UP;
-	break;
-    case TS_2A:
-	if (para->fast_taps)
-	    priv->tap_button_state = TBS_BUTTON_DOWN;
-	else
-	    priv->tap_button_state = TBS_BUTTON_UP;
-	break;
-    case TS_2B:
-	priv->tap_button_state = TBS_BUTTON_UP;
-	break;
-    case TS_3:
-	if (para->tap_and_drag_gesture)
-	    priv->tap_button_state = TBS_BUTTON_DOWN;
-	else
-	    priv->tap_button_state = TBS_BUTTON_UP;
-	break;
-    case TS_SINGLETAP:
-	if (para->fast_taps)
-	    priv->tap_button_state = TBS_BUTTON_UP;
-	else
-	    priv->tap_button_state = TBS_BUTTON_DOWN;
-	priv->touch_on.millis = millis;
-	break;
-    default:
-	break;
-    }
-    priv->tap_state = tap_state;
-}
-
-static void
-SetMovingState(SynapticsPrivate *priv, enum MovingState moving_state, int millis)
-{
-    DBG(7, "SetMovingState - %d -> %d center at %d/%d (millis:%d)\n", priv->moving_state,
-		  moving_state,priv->hwState.x, priv->hwState.y, millis);
-
-    if (moving_state == MS_TRACKSTICK) {
-	priv->trackstick_neutral_x = priv->hwState.x;
-	priv->trackstick_neutral_y = priv->hwState.y;
-    }
-    priv->moving_state = moving_state;
-}
-
-static int
-GetTimeOut(SynapticsPrivate *priv)
-{
-    SynapticsParameters *para = &priv->synpara;
-
-    switch (priv->tap_state) {
-    case TS_1:
-    case TS_3:
-    case TS_5:
-	return para->tap_time;
-    case TS_SINGLETAP:
-	return para->click_time;
-    case TS_2A:
-	return para->single_tap_timeout;
-    case TS_2B:
-	return para->tap_time_2;
-    case TS_4:
-	return para->locked_drag_time;
-    default:
-	return -1;			    /* No timeout */
-    }
-}
-
-static int
-HandleTapProcessing(SynapticsPrivate *priv, struct SynapticsHwState *hw,
-		    enum FingerState finger, Bool inside_active_area)
-{
-    SynapticsParameters *para = &priv->synpara;
-    Bool touch, release, is_timeout, move;
-    int timeleft, timeout;
-    edge_type edge;
-    int delay = 1000000000;
-
-    if (priv->palm)
-	return delay;
-
-    touch = finger && !priv->finger_state;
-    release = !finger && priv->finger_state;
-    move = (finger &&
-	     (priv->tap_max_fingers <= ((priv->horiz_scroll_twofinger_on || priv->vert_scroll_twofinger_on)? 2 : 1)) &&
-	     ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
-	     (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
-
-    if (touch) {
-	priv->touch_on.x = hw->x;
-	priv->touch_on.y = hw->y;
-	priv->touch_on.millis = hw->millis;
-    } else if (release) {
-	priv->touch_on.millis = hw->millis;
-    }
-    if (hw->z > para->finger_high)
-	if (priv->tap_max_fingers < hw->numFingers)
-	    priv->tap_max_fingers = hw->numFingers;
-    timeout = GetTimeOut(priv);
-    timeleft = TIME_DIFF(priv->touch_on.millis + timeout, hw->millis);
-    is_timeout = timeleft <= 0;
-
- restart:
-    switch (priv->tap_state) {
-    case TS_START:
-	if (touch)
-	    SetTapState(priv, TS_1, hw->millis);
-	break;
-    case TS_1:
-	if (move) {
-	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-	    SetTapState(priv, TS_MOVE, hw->millis);
-	    goto restart;
-	} else if (is_timeout) {
-	    if (finger == FS_TOUCHED) {
-		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-	    } else if (finger == FS_PRESSED) {
-		SetMovingState(priv, MS_TRACKSTICK, hw->millis);
-	    }
-	    SetTapState(priv, TS_MOVE, hw->millis);
-	    goto restart;
-	} else if (release) {
-	    edge = edge_detection(priv, priv->touch_on.x, priv->touch_on.y);
-	    SelectTapButton(priv, edge);
-	    /* Disable taps outside of the active area */
-	    if (!inside_active_area) {
-		priv->tap_button = 0;
-	    }
-	    SetTapState(priv, TS_2A, hw->millis);
-	}
-	break;
-    case TS_MOVE:
-	if (move && priv->moving_state == MS_TRACKSTICK) {
-	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-	}
-	if (release) {
-	    SetMovingState(priv, MS_FALSE, hw->millis);
-	    SetTapState(priv, TS_START, hw->millis);
-	}
-	break;
-    case TS_2A:
-	if (touch)
-	    SetTapState(priv, TS_3, hw->millis);
-	else if (is_timeout)
-	    SetTapState(priv, TS_SINGLETAP, hw->millis);
-	break;
-    case TS_2B:
-	if (touch) {
-	    SetTapState(priv, TS_3, hw->millis);
-	} else if (is_timeout) {
-	    SetTapState(priv, TS_START, hw->millis);
-	    priv->tap_button_state = TBS_BUTTON_DOWN_UP;
-	}
-	break;
-    case TS_SINGLETAP:
-	if (touch)
-	    SetTapState(priv, TS_1, hw->millis);
-	else if (is_timeout)
-	    SetTapState(priv, TS_START, hw->millis);
-	break;
-    case TS_3:
-	if (move) {
-	    if (para->tap_and_drag_gesture) {
-		SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-		SetTapState(priv, TS_DRAG, hw->millis);
-	    } else {
-		SetTapState(priv, TS_1, hw->millis);
-	    }
-	    goto restart;
-	} else if (is_timeout) {
-	    if (para->tap_and_drag_gesture) {
-		if (finger == FS_TOUCHED) {
-		    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-		} else if (finger == FS_PRESSED) {
-		    SetMovingState(priv, MS_TRACKSTICK, hw->millis);
-		}
-		SetTapState(priv, TS_DRAG, hw->millis);
-	    } else {
-		SetTapState(priv, TS_1, hw->millis);
-	    }
-	    goto restart;
-	} else if (release) {
-	    SetTapState(priv, TS_2B, hw->millis);
-	}
-	break;
-    case TS_DRAG:
-	if (move)
-	    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, hw->millis);
-	if (release) {
-	    SetMovingState(priv, MS_FALSE, hw->millis);
-	    if (para->locked_drags) {
-		SetTapState(priv, TS_4, hw->millis);
-	    } else {
-		SetTapState(priv, TS_START, hw->millis);
-	    }
-	}
-	break;
-    case TS_4:
-	if (is_timeout) {
-	    SetTapState(priv, TS_START, hw->millis);
-	    goto restart;
-	}
-	if (touch)
-	    SetTapState(priv, TS_5, hw->millis);
-	break;
-    case TS_5:
-	if (is_timeout || move) {
-	    SetTapState(priv, TS_DRAG, hw->millis);
-	    goto restart;
-	} else if (release) {
-	    SetMovingState(priv, MS_FALSE, hw->millis);
-	    SetTapState(priv, TS_START, hw->millis);
-	}
-	break;
-    }
-
-    timeout = GetTimeOut(priv);
-    if (timeout >= 0) {
-	timeleft = TIME_DIFF(priv->touch_on.millis + timeout, hw->millis);
-	delay = clamp(timeleft, 1, delay);
-    }
-    return delay;
-}
-
-#define HIST(a) (priv->move_hist[((priv->hist_index - (a) + SYNAPTICS_MOVE_HISTORY) % SYNAPTICS_MOVE_HISTORY)])
-
-static void
-store_history(SynapticsPrivate *priv, int x, int y, unsigned int millis)
-{
-    int idx = (priv->hist_index + 1) % SYNAPTICS_MOVE_HISTORY;
-    priv->move_hist[idx].x = x;
-    priv->move_hist[idx].y = y;
-    priv->move_hist[idx].millis = millis;
-    priv->hist_index = idx;
-}
-
-/*
- * Estimate the slope for the data sequence [x3, x2, x1, x0] by using
- * linear regression to fit a line to the data and use the slope of the
- * line.
- */
-static double
-estimate_delta(double x0, double x1, double x2, double x3)
-{
-    return x0 * 0.3 + x1 * 0.1 - x2 * 0.1 - x3 * 0.3;
-}
-
-/**
- * Applies hysteresis. center is shifted such that it is in range with
- * in by the margin again. The new center is returned.
- * @param in the current value
- * @param center the current center
- * @param margin the margin to center in which no change is applied
- * @return the new center (which might coincide with the previous)
- */
-static int hysteresis(int in, int center, int margin) {
-    int diff = in - center;
-    if (abs(diff) <= margin) {
-	diff = 0;
-    } else if (diff > margin) {
-	diff -= margin;
-    } else if (diff < -margin) {
-	diff += margin;
-    }
-    return center + diff;
-}
-
-static void
-get_delta_for_trackstick(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
-                         double *dx, double *dy)
-{
-    SynapticsParameters *para = &priv->synpara;
-    double dtime = (hw->millis - HIST(0).millis) / 1000.0;
-
-    *dx = (hw->x - priv->trackstick_neutral_x);
-    *dy = (hw->y - priv->trackstick_neutral_y);
-
-    *dx = *dx * dtime * para->trackstick_speed;
-    *dy = *dy * dtime * para->trackstick_speed;
-}
-
-static void
-get_edge_speed(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
-               edge_type edge, int *x_edge_speed, int *y_edge_speed)
-{
-    SynapticsParameters *para = &priv->synpara;
-
-    int minZ = para->edge_motion_min_z;
-    int maxZ = para->edge_motion_max_z;
-    int minSpd = para->edge_motion_min_speed;
-    int maxSpd = para->edge_motion_max_speed;
-    int edge_speed;
-
-    if (hw->z <= minZ) {
-        edge_speed = minSpd;
-    } else if (hw->z >= maxZ) {
-        edge_speed = maxSpd;
-    } else {
-        edge_speed = minSpd + (hw->z - minZ) * (maxSpd - minSpd) / (maxZ - minZ);
-    }
-    if (!priv->synpara.circular_pad) {
-        /* on rectangular pad */
-        if (edge & RIGHT_EDGE) {
-            *x_edge_speed = edge_speed;
-        } else if (edge & LEFT_EDGE) {
-            *x_edge_speed = -edge_speed;
-        }
-        if (edge & TOP_EDGE) {
-            *y_edge_speed = -edge_speed;
-        } else if (edge & BOTTOM_EDGE) {
-            *y_edge_speed = edge_speed;
-        }
-    } else if (edge) {
-        /* at edge of circular pad */
-        double relX, relY;
-
-        relative_coords(priv, hw->x, hw->y, &relX, &relY);
-        *x_edge_speed = (int)(edge_speed * relX);
-        *y_edge_speed = (int)(edge_speed * relY);
-    }
-}
-
-static void
-get_delta(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
-          edge_type edge, double *dx, double *dy)
-{
-    SynapticsParameters *para = &priv->synpara;
-    double dtime = (hw->millis - HIST(0).millis) / 1000.0;
-    double integral;
-    double tmpf;
-    int x_edge_speed = 0;
-    int y_edge_speed = 0;
-
-    /* HIST is full enough: priv->count_packet_finger > 3 */
-    *dx = estimate_delta(hw->x, HIST(0).x, HIST(1).x, HIST(2).x);
-    *dy = estimate_delta(hw->y, HIST(0).y, HIST(1).y, HIST(2).y);
-
-    if ((priv->tap_state == TS_DRAG) || para->edge_motion_use_always)
-        get_edge_speed(priv, hw, edge, &x_edge_speed, &y_edge_speed);
-
-    /* report edge speed as synthetic motion. Of course, it would be
-     * cooler to report floats than to buffer, but anyway. */
-    tmpf = *dx + x_edge_speed * dtime + priv->frac_x;
-    priv->frac_x = modf(tmpf, &integral);
-    *dx = integral;
-    tmpf = *dy + y_edge_speed * dtime + priv->frac_y;
-    priv->frac_y = modf(tmpf, &integral);
-    *dy = integral;
-}
-
-/**
- * Compute relative motion ('deltas') including edge motion xor trackstick.
- */
-static int
-ComputeDeltas(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
-	      edge_type edge, int *dxP, int *dyP, Bool inside_area)
-{
-    enum MovingState moving_state;
-    double dx, dy;
-    int delay = 1000000000;
-
-    dx = dy = 0;
-
-    moving_state = priv->moving_state;
-    if (moving_state == MS_FALSE) {
-	switch (priv->tap_state) {
-	case TS_MOVE:
-	case TS_DRAG:
-	    moving_state = MS_TOUCHPAD_RELATIVE;
-	    break;
-	case TS_1:
-	case TS_3:
-	case TS_5:
-	    if (hw->numFingers == 1)
-		moving_state = MS_TOUCHPAD_RELATIVE;
-	    break;
-	default:
-	    break;
-	}
-    }
-
-    if (!inside_area || !moving_state || priv->palm ||
-	priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
-	priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
-	priv->circ_scroll_on || priv->prevFingers != hw->numFingers)
-    {
-        /* reset packet counter. */
-        priv->count_packet_finger = 0;
-        goto out;
-    }
-
-    /* to create fluid edge motion, call back 'soon'
-     * even in the absence of new hardware events */
-    delay = MIN(delay, 13);
-
-    if (priv->count_packet_finger <= 3) /* min. 3 packets, see get_delta() */
-        goto skip; /* skip the lot */
-
-    if (priv->moving_state == MS_TRACKSTICK)
-        get_delta_for_trackstick(priv, hw, &dx, &dy);
-    else if (moving_state == MS_TOUCHPAD_RELATIVE)
-        get_delta(priv, hw, edge, &dx, &dy);
-
-skip:
-    priv->count_packet_finger++;
-out:
-    priv->prevFingers = hw->numFingers;
-
-    *dxP = dx;
-    *dyP = dy;
-
-    return delay;
-}
-
-struct ScrollData {
-    int left, right, up, down;
-};
-
-static double
-estimate_delta_circ(SynapticsPrivate *priv)
-{
-	double a1 = angle(priv, HIST(3).x, HIST(3).y);
-	double a2 = angle(priv, HIST(2).x, HIST(2).y);
-	double a3 = angle(priv, HIST(1).x, HIST(1).y);
-	double a4 = angle(priv, HIST(0).x, HIST(0).y);
-	double d1 = diffa(a2, a1);
-	double d2 = d1 + diffa(a3, a2);
-	double d3 = d2 + diffa(a4, a3);
-	return estimate_delta(d3, d2, d1, 0);
-}
-
-/* vert and horiz are to know which direction to start coasting
- * circ is true if the user had been circular scrolling.
- */
-static void
-start_coasting(SynapticsPrivate *priv, struct SynapticsHwState *hw,
-	       Bool vert, Bool horiz, Bool circ)
-{
-    SynapticsParameters *para = &priv->synpara;
-
-    priv->autoscroll_y = 0.0;
-    priv->autoscroll_x = 0.0;
-
-    if ((priv->scroll_packet_count > 3) && (para->coasting_speed > 0.0)) {
-	double pkt_time = (HIST(0).millis - HIST(3).millis) / 1000.0;
-	if (vert && !circ) {
-	    double dy = estimate_delta(HIST(0).y, HIST(1).y, HIST(2).y, HIST(3).y);
-	    int sdelta = para->scroll_dist_vert;
-	    if (pkt_time > 0 && sdelta > 0) {
-		double scrolls_per_sec = dy / pkt_time / sdelta;
-		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
-		    priv->autoscroll_yspd = scrolls_per_sec;
-		    priv->autoscroll_y = (hw->y - priv->scroll_y) / (double)sdelta;
-		}
-	    }
-	}
-	if (horiz && !circ){
-	    double dx = estimate_delta(HIST(0).x, HIST(1).x, HIST(2).x, HIST(3).x);
-	    int sdelta = para->scroll_dist_horiz;
-	    if (pkt_time > 0 && sdelta > 0) {
-		double scrolls_per_sec = dx / pkt_time / sdelta;
-		if (fabs(scrolls_per_sec) >= para->coasting_speed) {
-		    priv->autoscroll_xspd = scrolls_per_sec;
-		    priv->autoscroll_x = (hw->x - priv->scroll_x) / (double)sdelta;
-		}
-	    }
-	}
-	if (circ) {
-	    double da = estimate_delta_circ(priv);
-	    double sdelta = para->scroll_dist_circ;
-	    if (pkt_time > 0 && sdelta > 0) {
-	        double scrolls_per_sec = da / pkt_time / sdelta;
-	        if (fabs(scrolls_per_sec) >= para->coasting_speed) {
-	            if (vert) {
-	                priv->autoscroll_yspd = scrolls_per_sec;
-	                priv->autoscroll_y = diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) / sdelta;
-	            }
-	            else if (horiz) {
-	                priv->autoscroll_xspd = scrolls_per_sec;
-	                priv->autoscroll_x = diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) / sdelta;
-	            }
-	        }
-	    }
-	}
-    }
-    priv->scroll_packet_count = 0;
-}
-
-static void
-stop_coasting(SynapticsPrivate *priv)
-{
-    priv->autoscroll_xspd = 0;
-    priv->autoscroll_yspd = 0;
-    priv->scroll_packet_count = 0;
-}
-
-static int
-HandleScrolling(SynapticsPrivate *priv, struct SynapticsHwState *hw,
-		edge_type edge, Bool finger, struct ScrollData *sd)
-{
-    SynapticsParameters *para = &priv->synpara;
-    int delay = 1000000000;
-
-    sd->left = sd->right = sd->up = sd->down = 0;
-
-    if (priv->synpara.touchpad_off == 2) {
-	stop_coasting(priv);
-	priv->circ_scroll_on = FALSE;
-	priv->vert_scroll_edge_on = FALSE;
-	priv->horiz_scroll_edge_on = FALSE;
-	priv->vert_scroll_twofinger_on = FALSE;
-	priv->horiz_scroll_twofinger_on = FALSE;
-	return delay;
-    }
-
-    /* scroll detection */
-    if (finger && !priv->finger_state) {
-	stop_coasting(priv);
-	if (para->circular_scrolling) {
-	    if ((para->circular_trigger == 0 && edge) ||
-		(para->circular_trigger == 1 && edge & TOP_EDGE) ||
-		(para->circular_trigger == 2 && edge & TOP_EDGE && edge & RIGHT_EDGE) ||
-		(para->circular_trigger == 3 && edge & RIGHT_EDGE) ||
-		(para->circular_trigger == 4 && edge & RIGHT_EDGE && edge & BOTTOM_EDGE) ||
-		(para->circular_trigger == 5 && edge & BOTTOM_EDGE) ||
-		(para->circular_trigger == 6 && edge & BOTTOM_EDGE && edge & LEFT_EDGE) ||
-		(para->circular_trigger == 7 && edge & LEFT_EDGE) ||
-		(para->circular_trigger == 8 && edge & LEFT_EDGE && edge & TOP_EDGE)) {
-		priv->circ_scroll_on = TRUE;
-		priv->circ_scroll_vert = TRUE;
-		priv->scroll_a = angle(priv, hw->x, hw->y);
-		DBG(7, "circular scroll detected on edge\n");
-	    }
-	}
-    }
-    if (!priv->circ_scroll_on) {
-	if (finger) {
-	    if (hw->numFingers == 2) {
-		if (!priv->vert_scroll_twofinger_on &&
-		    (para->scroll_twofinger_vert) && (para->scroll_dist_vert != 0)) {
-		    priv->vert_scroll_twofinger_on = TRUE;
-		    priv->vert_scroll_edge_on = FALSE;
-		    priv->scroll_y = hw->y;
-		    DBG(7, "vert two-finger scroll detected\n");
-		}
-		if (!priv->horiz_scroll_twofinger_on &&
-		    (para->scroll_twofinger_horiz) && (para->scroll_dist_horiz != 0)) {
-		    priv->horiz_scroll_twofinger_on = TRUE;
-		    priv->horiz_scroll_edge_on = FALSE;
-		    priv->scroll_x = hw->x;
-		    DBG(7, "horiz two-finger scroll detected\n");
-		}
-	    }
-	}
-	if (finger && !priv->finger_state) {
-	    if (!priv->vert_scroll_twofinger_on && !priv->horiz_scroll_twofinger_on) {
-		if ((para->scroll_edge_vert) && (para->scroll_dist_vert != 0) &&
-		    (edge & RIGHT_EDGE)) {
-		    priv->vert_scroll_edge_on = TRUE;
-		    priv->scroll_y = hw->y;
-		    DBG(7, "vert edge scroll detected on right edge\n");
-		}
-		if ((para->scroll_edge_horiz) && (para->scroll_dist_horiz != 0) &&
-		    (edge & BOTTOM_EDGE)) {
-		    priv->horiz_scroll_edge_on = TRUE;
-		    priv->scroll_x = hw->x;
-		    DBG(7, "horiz edge scroll detected on bottom edge\n");
-		}
-	    }
-	}
-    }
-    {
-	Bool oldv = priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on ||
-	              (priv->circ_scroll_on && priv->circ_scroll_vert);
-
-	Bool oldh = priv->horiz_scroll_twofinger_on || priv->horiz_scroll_edge_on ||
-	              (priv->circ_scroll_on && !priv->circ_scroll_vert);
-
-	Bool oldc = priv->circ_scroll_on;
-
-	if (priv->circ_scroll_on && !finger) {
-	    /* circular scroll locks in until finger is raised */
-	    DBG(7, "cicular scroll off\n");
-	    priv->circ_scroll_on = FALSE;
-	}
-
-	if (!finger || hw->numFingers != 2) {
-	    if (priv->vert_scroll_twofinger_on) {
-		DBG(7, "vert two-finger scroll off\n");
-		priv->vert_scroll_twofinger_on = FALSE;
-	    }
-	    if (priv->horiz_scroll_twofinger_on) {
-		DBG(7, "horiz two-finger scroll off\n");
-		priv->horiz_scroll_twofinger_on = FALSE;
-	    }
-	}
-
-	if (priv->vert_scroll_edge_on && (!(edge & RIGHT_EDGE) || !finger)) {
-	    DBG(7, "vert edge scroll off\n");
-	    priv->vert_scroll_edge_on = FALSE;
-	}
-	if (priv->horiz_scroll_edge_on && (!(edge & BOTTOM_EDGE) || !finger)) {
-	    DBG(7, "horiz edge scroll off\n");
-	    priv->horiz_scroll_edge_on = FALSE;
-	}
-	/* If we were corner edge scrolling (coasting),
-	 * but no longer in corner or raised a finger, then stop coasting. */
-	if (para->scroll_edge_corner && (priv->autoscroll_xspd || priv->autoscroll_yspd)) {
-	    Bool is_in_corner =
-		((edge & RIGHT_EDGE)  && (edge & (TOP_EDGE | BOTTOM_EDGE))) ||
-		((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) ;
-	    if (!is_in_corner || !finger) {
-		DBG(7, "corner edge scroll off\n");
-		stop_coasting(priv);
-	    }
-	}
-	/* if we were scrolling, but couldn't corner edge scroll,
-	 * and are no longer scrolling, then start coasting */
-	oldv = oldv && !(priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on ||
-	              (priv->circ_scroll_on && priv->circ_scroll_vert));
-
-	oldh = oldh && !(priv->horiz_scroll_twofinger_on || priv->horiz_scroll_edge_on ||
-	              (priv->circ_scroll_on && !priv->circ_scroll_vert));
-
-	oldc = oldc && !priv->circ_scroll_on;
-
-	if ((oldv || oldh) && !para->scroll_edge_corner) {
-	    start_coasting(priv, hw, oldv, oldh, oldc);
-	}
-    }
-
-    /* if hitting a corner (top right or bottom right) while vertical
-     * scrolling is active, consider starting corner edge scrolling or
-     * switching over to circular scrolling smoothly */
-    if (priv->vert_scroll_edge_on && !priv->horiz_scroll_edge_on &&
-	(edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
-	if (para->scroll_edge_corner) {
-	    if (priv->autoscroll_yspd == 0) {
-		/* FYI: We can generate multiple start_coasting requests if
-		 * we're in the corner, but we were moving so slowly when we
-		 * got here that we didn't actually start coasting. */
-		DBG(7, "corner edge scroll on\n");
-		start_coasting(priv, hw, TRUE, FALSE, FALSE);
-	    }
-	} else if (para->circular_scrolling) {
-	    priv->vert_scroll_edge_on = FALSE;
-	    priv->circ_scroll_on = TRUE;
-	    priv->circ_scroll_vert = TRUE;
-	    priv->scroll_a = angle(priv, hw->x, hw->y);
-	    DBG(7, "switching to circular scrolling\n");
-	}
-    }
-    /* Same treatment for horizontal scrolling */
-    if (priv->horiz_scroll_edge_on && !priv->vert_scroll_edge_on &&
-	(edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
-	if (para->scroll_edge_corner) {
-	    if (priv->autoscroll_xspd == 0) {
-		/* FYI: We can generate multiple start_coasting requests if
-		 * we're in the corner, but we were moving so slowly when we
-		 * got here that we didn't actually start coasting. */
-		DBG(7, "corner edge scroll on\n");
-		start_coasting(priv, hw, FALSE, TRUE, FALSE);
-	    }
-	} else if (para->circular_scrolling) {
-	    priv->horiz_scroll_edge_on = FALSE;
-	    priv->circ_scroll_on = TRUE;
-	    priv->circ_scroll_vert = FALSE;
-	    priv->scroll_a = angle(priv, hw->x, hw->y);
-	    DBG(7, "switching to circular scrolling\n");
-	}
-    }
-
-    if (priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
-	priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
-	priv->circ_scroll_on) {
-	priv->scroll_packet_count++;
-    }
-
-    if (priv->vert_scroll_edge_on || priv->vert_scroll_twofinger_on) {
-	/* + = down, - = up */
-	int delta = para->scroll_dist_vert;
-	if (delta > 0) {
-	    while (hw->y - priv->scroll_y > delta) {
-		sd->down++;
-		priv->scroll_y += delta;
-	    }
-	    while (hw->y - priv->scroll_y < -delta) {
-		sd->up++;
-		priv->scroll_y -= delta;
-	    }
-	}
-    }
-    if (priv->horiz_scroll_edge_on || priv->horiz_scroll_twofinger_on) {
-	/* + = right, - = left */
-	int delta = para->scroll_dist_horiz;
-	if (delta > 0) {
-	    while (hw->x - priv->scroll_x > delta) {
-		sd->right++;
-		priv->scroll_x += delta;
-	    }
-	    while (hw->x - priv->scroll_x < -delta) {
-		sd->left++;
-		priv->scroll_x -= delta;
-	    }
-	}
-    }
-    if (priv->circ_scroll_on) {
-	/* + = counter clockwise, - = clockwise */
-	double delta = para->scroll_dist_circ;
-	if (delta >= 0.005) {
-	    while (diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) > delta) {
-		if (priv->circ_scroll_vert)
-		    sd->up++;
-		else
-		    sd->right++;
-		priv->scroll_a += delta;
-		if (priv->scroll_a > M_PI)
-		    priv->scroll_a -= 2 * M_PI;
-	    }
-	    while (diffa(priv->scroll_a, angle(priv, hw->x, hw->y)) < -delta) {
-		if (priv->circ_scroll_vert)
-		    sd->down++;
-		else
-		    sd->left++;
-		priv->scroll_a -= delta;
-		if (priv->scroll_a < -M_PI)
-		    priv->scroll_a += 2 * M_PI;
-	    }
-	}
-    }
-
-    if (priv->autoscroll_yspd) {
-	double dtime = (hw->millis - HIST(0).millis) / 1000.0;
-	double ddy = para->coasting_friction * dtime;
-	priv->autoscroll_y += priv->autoscroll_yspd * dtime;
-	delay = MIN(delay, 20);
-	while (priv->autoscroll_y > 1.0) {
-	    sd->down++;
-	    priv->autoscroll_y -= 1.0;
-	}
-	while (priv->autoscroll_y < -1.0) {
-	    sd->up++;
-	    priv->autoscroll_y += 1.0;
-	}
-	if (abs(priv->autoscroll_yspd) < ddy) {
-	    priv->autoscroll_yspd = 0;
-	    priv->scroll_packet_count = 0;
-	} else {
-	    priv->autoscroll_yspd += (priv->autoscroll_yspd < 0 ? ddy : -1*ddy);
-	}
-    }
-
-    if (priv->autoscroll_xspd) {
-	double dtime = (hw->millis - HIST(0).millis) / 1000.0;
-	double ddx = para->coasting_friction * dtime;
-	priv->autoscroll_x += priv->autoscroll_xspd * dtime;
-	delay = MIN(delay, 20);
-	while (priv->autoscroll_x > 1.0) {
-	    sd->right++;
-	    priv->autoscroll_x -= 1.0;
-	}
-	while (priv->autoscroll_x < -1.0) {
-	    sd->left++;
-	    priv->autoscroll_x += 1.0;
-	}
-	if (abs(priv->autoscroll_xspd) < ddx) {
-	    priv->autoscroll_xspd = 0;
-	    priv->scroll_packet_count = 0;
-	} else {
-	    priv->autoscroll_xspd += (priv->autoscroll_xspd < 0 ? ddx : -1*ddx);
-	}
-    }
-
-    return delay;
-}
-
-static void
-handle_clickfinger(SynapticsParameters *para, struct SynapticsHwState *hw)
-{
-    int action = 0;
-    switch(hw->numFingers){
-        case 1:
-            action = para->click_action[F1_CLICK1];
-            break;
-        case 2:
-            action = para->click_action[F2_CLICK1];
-            break;
-        case 3:
-            action = para->click_action[F3_CLICK1];
-            break;
-    }
-    switch(action){
-        case 1:
-            hw->left = 1;
-            break;
-        case 2:
-            hw->left = 0;
-            hw->middle = 1;
-            break;
-        case 3:
-            hw->left = 0;
-            hw->right = 1;
-            break;
-    }
-}
-
-
-/* Update the hardware state in shared memory. This is read-only these days,
- * nothing in the driver reads back from SHM. SHM configuration is a thing of the past.
- */
-static void
-update_shm(const InputInfoPtr pInfo, const struct SynapticsHwState *hw)
-{
-    int i;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsSHM *shm = priv->synshm;
-
-    if (!shm)
-	    return;
-
-    shm->x = hw->x;
-    shm->y = hw->y;
-    shm->z = hw->z;
-    shm->numFingers = hw->numFingers;
-    shm->fingerWidth = hw->fingerWidth;
-    shm->left = hw->left;
-    shm->right = hw->right;
-    shm->up = hw->up;
-    shm->down = hw->down;
-    for (i = 0; i < 8; i++)
-	    shm->multi[i] = hw->multi[i];
-    shm->middle = hw->middle;
-}
-
-/* Adjust the hardware state according to the extra buttons (if the touchpad
- * has any and not many touchpads do these days). These buttons are up/down
- * tilt buttons and/or left/right buttons that then map into a specific
- * function (or scrolling into).
- */
-static Bool
-adjust_state_from_scrollbuttons(const InputInfoPtr pInfo, struct SynapticsHwState *hw)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsParameters *para = &priv->synpara;
-    Bool double_click = FALSE;
-
-    if (!para->updown_button_scrolling) {
-	if (hw->down) {		/* map down button to middle button */
-	    hw->middle = TRUE;
-	}
-
-	if (hw->up) {		/* up button generates double click */
-	    if (!priv->prev_up)
-		double_click = TRUE;
-	}
-	priv->prev_up = hw->up;
-
-	/* reset up/down button events */
-	hw->up = hw->down = FALSE;
-    }
-
-    /* Left/right button scrolling, or middle clicks */
-    if (!para->leftright_button_scrolling) {
-	if (hw->multi[2] || hw->multi[3])
-	    hw->middle = TRUE;
-
-	/* reset left/right button events */
-	hw->multi[2] = hw->multi[3] = FALSE;
-    }
-
-    return double_click;
-}
-
-static void
-update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw, int *delay)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsParameters *para = &priv->synpara;
-
-    /* Treat the first two multi buttons as up/down for now. */
-    hw->up |= hw->multi[0];
-    hw->down |= hw->multi[1];
-
-    /* 3rd button emulation */
-    hw->middle |= HandleMidButtonEmulation(priv, hw, delay);
-
-    /* Fingers emulate other buttons */
-    if(hw->left && hw->numFingers >= 1){
-        handle_clickfinger(para, hw);
-    }
-
-    /* Two finger emulation */
-    if (hw->numFingers == 1 && hw->z >= para->emulate_twofinger_z &&
-        hw->fingerWidth >= para->emulate_twofinger_w) {
-	hw->numFingers = 2;
-    }
-}
-
-static void
-post_button_click(const InputInfoPtr pInfo, const int button)
-{
-    xf86PostButtonEvent(pInfo->dev, FALSE, button, TRUE, 0, 0);
-    xf86PostButtonEvent(pInfo->dev, FALSE, button, FALSE, 0, 0);
-}
-
-
-static void
-post_scroll_events(const InputInfoPtr pInfo, struct ScrollData scroll)
-{
-    while (scroll.up-- > 0)
-        post_button_click(pInfo, 4);
-
-    while (scroll.down-- > 0)
-        post_button_click(pInfo, 5);
-
-    while (scroll.left-- > 0)
-        post_button_click(pInfo, 6);
-
-    while (scroll.right-- > 0)
-        post_button_click(pInfo, 7);
-}
-
-static inline int
-repeat_scrollbuttons(const InputInfoPtr pInfo,
-                     const struct SynapticsHwState *hw,
-		     int buttons, int delay)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsParameters *para = &priv->synpara;
-    int repeat_delay, timeleft;
-    int rep_buttons = ((para->updown_button_repeat ? 0x18 : 0) |
-			(para->leftright_button_repeat ? 0x60 : 0));
-
-    /* Handle auto repeat buttons */
-    repeat_delay = clamp(para->scroll_button_repeat, SBR_MIN, SBR_MAX);
-    if (((hw->up || hw->down) && para->updown_button_repeat &&
-	 para->updown_button_scrolling) ||
-	((hw->multi[2] || hw->multi[3]) && para->leftright_button_repeat &&
-	 para->leftright_button_scrolling)) {
-	priv->repeatButtons = buttons & rep_buttons;
-	if (!priv->nextRepeat) {
-	    priv->nextRepeat = hw->millis + repeat_delay * 2;
-	}
-    } else {
-	priv->repeatButtons = 0;
-	priv->nextRepeat = 0;
-    }
-
-    if (priv->repeatButtons) {
-	timeleft = TIME_DIFF(priv->nextRepeat, hw->millis);
-	if (timeleft > 0)
-	    delay = MIN(delay, timeleft);
-	if (timeleft <= 0) {
-	    int change, id;
-	    change = priv->repeatButtons;
-	    while (change) {
-		id = ffs(change);
-		change &= ~(1 << (id - 1));
-		xf86PostButtonEvent(pInfo->dev, FALSE, id, FALSE, 0, 0);
-		xf86PostButtonEvent(pInfo->dev, FALSE, id, TRUE, 0, 0);
-	    }
-
-	    priv->nextRepeat = hw->millis + repeat_delay;
-	    delay = MIN(delay, repeat_delay);
-	}
-    }
-
-    return delay;
-}
-
-/*
- * React on changes in the hardware state. This function is called every time
- * the hardware state changes. The return value is used to specify how many
- * milliseconds to wait before calling the function again if no state change
- * occurs.
- */
-static int
-HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-    SynapticsParameters *para = &priv->synpara;
-    int finger;
-    int dx, dy, buttons, id;
-    edge_type edge = NO_EDGE;
-    int change;
-    struct ScrollData scroll;
-    int double_click = FALSE;
-    int delay = 1000000000;
-    int timeleft;
-    Bool inside_active_area;
-
-    update_shm(pInfo, hw);
-
-    /* If touchpad is switched off, we skip the whole thing and return delay */
-    if (para->touchpad_off == 1)
-	return delay;
-
-    /* apply hysteresis before doing anything serious. This cancels
-     * out a lot of noise which might surface in strange phenomena
-     * like flicker in scrolling or noise motion. */
-    priv->hyst_center_x = hysteresis(hw->x, priv->hyst_center_x, para->hyst_x);
-    priv->hyst_center_y = hysteresis(hw->y, priv->hyst_center_y, para->hyst_y);
-    hw->x = priv->hyst_center_x;
-    hw->y = priv->hyst_center_y;
-
-    inside_active_area = is_inside_active_area(priv, hw->x, hw->y);
-
-    /* now we know that these _coordinates_ aren't in the area.
-       invalid are: x, y, z, numFingers, fingerWidth
-       valid are: millis, left/right/middle/up/down/etc.
-    */
-    if (!inside_active_area)
-    {
-	hw->x = 0;
-	hw->y = 0;
-	hw->z = 0;
-	hw->numFingers = 0;
-	hw->fingerWidth = 0;
-
-	/* FIXME: if finger accidentally moves into the area and doesn't
-	 * really release, the finger should remain down. */
-	finger = FS_UNTOUCHED;
-	edge = NO_EDGE;
-
-	dx = dy = 0;
-    }
-
-    /* these two just update hw->left, right, etc. */
-    update_hw_button_state(pInfo, hw, &delay);
-    if (priv->has_scrollbuttons)
-	double_click = adjust_state_from_scrollbuttons(pInfo, hw);
-
-    /* no edge or finger detection outside of area */
-    if (inside_active_area) {
-	edge = edge_detection(priv, hw->x, hw->y);
-	finger = SynapticsDetectFinger(priv, hw);
-    }
-
-    /* tap and drag detection. Needs to be performed even if the finger is in
-     * the dead area to reset the state. */
-    timeleft = HandleTapProcessing(priv, hw, finger, inside_active_area);
-    if (timeleft > 0)
-	delay = MIN(delay, timeleft);
-
-    if (inside_active_area)
-    {
-	/* Don't bother about scrolling in the dead area of the touchpad. */
-	timeleft = HandleScrolling(priv, hw, edge, finger, &scroll);
-	if (timeleft > 0)
-	    delay = MIN(delay, timeleft);
-
-	/*
-	 * Compensate for unequal x/y resolution. This needs to be done after
-	 * calculations that require unadjusted coordinates, for example edge
-	 * detection.
-	 */
-	ScaleCoordinates(priv, hw);
-    }
-
-    dx = dy = 0;
-
-    if (!priv->absolute_events) {
-      timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
-      delay = MIN(delay, timeleft);
-    }
-
-
-    buttons = ((hw->left     ? 0x01 : 0) |
-	       (hw->middle   ? 0x02 : 0) |
-	       (hw->right    ? 0x04 : 0) |
-	       (hw->up       ? 0x08 : 0) |
-	       (hw->down     ? 0x10 : 0) |
-	       (hw->multi[2] ? 0x20 : 0) |
-	       (hw->multi[3] ? 0x40 : 0));
-
-    if (priv->tap_button > 0) {
-	int tap_mask = 1 << (priv->tap_button - 1);
-	if (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {
-	    if (tap_mask != (priv->lastButtons & tap_mask)) {
-		xf86PostButtonEvent(pInfo->dev, FALSE, priv->tap_button, TRUE, 0, 0);
-		priv->lastButtons |= tap_mask;
-	    }
-	    priv->tap_button_state = TBS_BUTTON_UP;
-	}
-	if (priv->tap_button_state == TBS_BUTTON_DOWN)
-	    buttons |= tap_mask;
-    }
-
-    /* Post events */
-    if (finger > FS_UNTOUCHED) {
-        if (priv->absolute_events && inside_active_area) {
-            xf86PostMotionEvent(pInfo->dev, 1, 0, 2, hw->x, hw->y);
-        } else if (dx || dy) {
-            xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);
-        }
-    }
-
-    if (priv->mid_emu_state == MBE_LEFT_CLICK)
-    {
-	post_button_click(pInfo, 1);
-	priv->mid_emu_state = MBE_OFF;
-    } else if (priv->mid_emu_state == MBE_RIGHT_CLICK)
-    {
-	post_button_click(pInfo, 3);
-	priv->mid_emu_state = MBE_OFF;
-    }
-
-    change = buttons ^ priv->lastButtons;
-    while (change) {
-	id = ffs(change); /* number of first set bit 1..32 is returned */
-	change &= ~(1 << (id - 1));
-	xf86PostButtonEvent(pInfo->dev, FALSE, id, (buttons & (1 << (id - 1))), 0, 0);
-    }
-
-    /* Process scroll events only if coordinates are
-     * in the Synaptics Area
-     */
-    if (inside_active_area)
-	post_scroll_events(pInfo, scroll);
-
-    if (double_click) {
-	post_button_click(pInfo, 1);
-	post_button_click(pInfo, 1);
-    }
-
-    if (priv->has_scrollbuttons)
-	delay = repeat_scrollbuttons(pInfo, hw, buttons, delay);
-
-    /* Save old values of some state variables */
-    priv->finger_state = finger;
-    priv->lastButtons = buttons;
-
-    /* generate a history of the absolute positions */
-    if (inside_active_area)
-	store_history(priv, hw->x, hw->y, hw->millis);
-
-    return delay;
-}
-
-static int
-ControlProc(InputInfoPtr pInfo, xDeviceCtl * control)
-{
-    DBG(3, "Control Proc called\n");
-    return Success;
-}
-
-
-static int
-SwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
-{
-    InputInfoPtr pInfo = (InputInfoPtr) dev->public.devicePrivate;
-    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
-
-    DBG(3, "SwitchMode called\n");
-
-    switch (mode) {
-    case Absolute:
-        priv->absolute_events = TRUE;
-        break;
-
-    case Relative:
-        priv->absolute_events = FALSE;
-        break;
-
-    default:
-        return XI_BadMode;
-    }
-
-    return Success;
-}
-
-static void
-ReadDevDimensions(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
-
-    if (priv->proto_ops->ReadDevDimensions)
-	priv->proto_ops->ReadDevDimensions(pInfo);
-
-    SanitizeDimensions(pInfo);
-}
-
-static Bool
-QueryHardware(InputInfoPtr pInfo)
-{
-    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
-
-    priv->comm.protoBufTail = 0;
-
-    if (!priv->proto_ops->QueryHardware(pInfo)) {
-	xf86IDrvMsg(pInfo, X_PROBED, "no supported touchpad found\n");
-	if (priv->proto_ops->DeviceOffHook)
-            priv->proto_ops->DeviceOffHook(pInfo);
-        return FALSE;
-    }
-
-    return TRUE;
-}
-
-static void
-ScaleCoordinates(SynapticsPrivate *priv, struct SynapticsHwState *hw)
-{
-    int xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2;
-    int yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2;
-
-    hw->x = (hw->x - xCenter) * priv->horiz_coeff + xCenter;
-    hw->y = (hw->y - yCenter) * priv->vert_coeff + yCenter;
-}
-
-void
-CalculateScalingCoeffs(SynapticsPrivate *priv)
-{
-    int vertRes = priv->synpara.resolution_vert;
-    int horizRes = priv->synpara.resolution_horiz;
-
-    if ((horizRes > vertRes) && (horizRes > 0)) {
-        priv->horiz_coeff = vertRes / (double)horizRes;
-        priv->vert_coeff = 1;
-    } else if ((horizRes < vertRes) && (vertRes > 0)) {
-        priv->horiz_coeff = 1;
-        priv->vert_coeff = horizRes / (double)vertRes;
-    } else {
-        priv->horiz_coeff = 1;
-        priv->vert_coeff = 1;
-    }
-}
diff -Naur xf86-input-synaptics-1.5.0/src/synapticsstr.h xf86-input-synaptics-1.5.0-old/src/synapticsstr.h
--- xf86-input-synaptics-1.5.0/src/synapticsstr.h	2011-10-14 01:34:08.625625080 +0200
+++ xf86-input-synaptics-1.5.0-old/src/synapticsstr.h	2011-10-14 01:33:00.386074730 +0200
@@ -165,7 +165,6 @@
     unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
     int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
     int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
-    int orientation;
 } SynapticsParameters;
 
 
diff -Naur xf86-input-synaptics-1.5.0/src/synapticsstr.h.orig xf86-input-synaptics-1.5.0-old/src/synapticsstr.h.orig
--- xf86-input-synaptics-1.5.0/src/synapticsstr.h.orig	2011-09-02 08:02:56.000000000 +0200
+++ xf86-input-synaptics-1.5.0-old/src/synapticsstr.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,253 +0,0 @@
-/*
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Red Hat
- * not be used in advertising or publicity pertaining to distribution
- * of the software without specific, written prior permission.  Red
- * Hat makes no representations about the suitability of this software
- * for any purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
- * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef	_SYNAPTICSSTR_H_
-#define _SYNAPTICSSTR_H_
-
-#include "synproto.h"
-
-#ifdef DBG
-#  undef DBG
-#endif
-
-#ifdef DEBUG
-#define DBG(verb, ...) \
-    xf86MsgVerb(X_INFO, verb, __VA_ARGS__)
-#else
-#define DBG(verb, msg, ...) /* */
-#endif
-
-#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 12
-#define xf86IDrvMsg(pInfo, type, ...) xf86Msg(type, __VA_ARGS__)
-#endif
-
-/******************************************************************************
- *		Definitions
- *					structs, typedefs, #defines, enums
- *****************************************************************************/
-#define SYNAPTICS_MOVE_HISTORY	5
-
-typedef struct _SynapticsMoveHist
-{
-    int x, y;
-    int millis;
-} SynapticsMoveHistRec;
-
-enum FingerState {		/* Note! The order matters. Compared with < operator. */
-    FS_UNTOUCHED,
-    FS_TOUCHED,
-    FS_PRESSED
-};
-
-enum MovingState {
-    MS_FALSE,
-    MS_TOUCHPAD_RELATIVE,
-    MS_TRACKSTICK		/* trackstick is always relative */
-};
-
-enum MidButtonEmulation {
-    MBE_OFF,			/* No button pressed */
-    MBE_LEFT,			/* Left button pressed, waiting for right button or timeout */
-    MBE_RIGHT,			/* Right button pressed, waiting for left button or timeout */
-    MBE_MID,			/* Left and right buttons pressed, waiting for both buttons
-				   to be released */
-    MBE_TIMEOUT,		/* Waiting for both buttons to be released. */
-    MBE_LEFT_CLICK,		/* Emulate left button click. */
-    MBE_RIGHT_CLICK,		/* Emulate right button click. */
-};
-
-/* See docs/tapndrag.dia for a state machine diagram */
-enum TapState {
-    TS_START,			/* No tap/drag in progress */
-    TS_1,			/* After first touch */
-    TS_MOVE,			/* Pointer movement enabled */
-    TS_2A,			/* After first release */
-    TS_2B,			/* After second/third/... release */
-    TS_SINGLETAP,		/* After timeout after first release */
-    TS_3,			/* After second touch */
-    TS_DRAG,			/* Pointer drag enabled */
-    TS_4,			/* After release when "locked drags" enabled */
-    TS_5			/* After touch when "locked drags" enabled */
-};
-
-enum TapButtonState {
-    TBS_BUTTON_UP,		/* "Virtual tap button" is up */
-    TBS_BUTTON_DOWN,		/* "Virtual tap button" is down */
-    TBS_BUTTON_DOWN_UP		/* Send button down event + set up state */
-};
-
-enum TouchpadModel {
-    MODEL_UNKNOWN = 0,
-    MODEL_SYNAPTICS,
-    MODEL_ALPS,
-    MODEL_APPLETOUCH
-};
-
-typedef struct _SynapticsParameters
-{
-    /* Parameter data */
-    int left_edge, right_edge, top_edge, bottom_edge; /* edge coordinates absolute */
-    int finger_low, finger_high, finger_press;	      /* finger detection values in Z-values */
-    int tap_time;
-    int tap_move;			    /* max. tapping time and movement in packets and coord. */
-    int single_tap_timeout;		    /* timeout to recognize a single tap */
-    int tap_time_2;			    /* max. tapping time for double taps */
-    int click_time;			    /* The duration of a single click */
-    Bool fast_taps;			    /* Faster reaction to single taps */
-    int emulate_mid_button_time;	    /* Max time between left and right button presses to
-					       emulate a middle button press. */
-    int emulate_twofinger_z;		    /* pressure threshold to emulate two finger touch (for Alps) */
-    int emulate_twofinger_w;		    /* Finger width threshold to emulate two finger touch */
-    int scroll_dist_vert;		    /* Scrolling distance in absolute coordinates */
-    int scroll_dist_horiz;		    /* Scrolling distance in absolute coordinates */
-    Bool scroll_edge_vert;		    /* Enable/disable vertical scrolling on right edge */
-    Bool scroll_edge_horiz;		    /* Enable/disable horizontal scrolling on left edge */
-    Bool scroll_edge_corner;		    /* Enable/disable continuous edge scrolling when in the corner */
-    Bool scroll_twofinger_vert;		    /* Enable/disable vertical two-finger scrolling */
-    Bool scroll_twofinger_horiz;	    /* Enable/disable horizontal two-finger scrolling */
-    double min_speed, max_speed, accl;	    /* movement parameters */
-    double trackstick_speed;		    /* trackstick mode speed */
-    int edge_motion_min_z;		    /* finger pressure at which minimum edge motion speed is set */
-    int edge_motion_max_z;		    /* finger pressure at which maximum edge motion speed is set */
-    int edge_motion_min_speed;		    /* slowest setting for edge motion speed */
-    int edge_motion_max_speed;		    /* fastest setting for edge motion speed */
-    Bool edge_motion_use_always;	    /* If false, edge motion is used only when dragging */
-
-    Bool updown_button_scrolling;	    /* Up/Down-Button scrolling or middle/double-click */
-    Bool leftright_button_scrolling;	    /* Left/right-button scrolling, or two lots of middle button */
-    Bool updown_button_repeat;		    /* If up/down button being used to scroll, auto-repeat?*/
-    Bool leftright_button_repeat;	    /* If left/right button being used to scroll, auto-repeat? */
-    int scroll_button_repeat;		    /* time, in milliseconds, between scroll events being
-					     * sent when holding down scroll buttons */
-    int touchpad_off;			    /* Switches the touchpad off
-					     * 0 : Not off
-					     * 1 : Off
-					     * 2 : Only tapping and scrolling off
-					     */
-    Bool locked_drags;			    /* Enable locked drags */
-    int locked_drag_time;		    /* timeout for locked drags */
-    int tap_action[MAX_TAP];		    /* Button to report on tap events */
-    int click_action[MAX_CLICK];	    /* Button to report on click with fingers */
-    Bool circular_scrolling;		    /* Enable circular scrolling */
-    double scroll_dist_circ;		    /* Scrolling angle radians */
-    int circular_trigger;		    /* Trigger area for circular scrolling */
-    Bool circular_pad;			    /* Edge has an oval or circular shape */
-    Bool palm_detect;			    /* Enable Palm Detection */
-    int palm_min_width;			    /* Palm detection width */
-    int palm_min_z;			    /* Palm detection depth */
-    double coasting_speed;		    /* Coasting threshold scrolling speed */
-    double coasting_friction;		    /* Number of scrolls per second per second to change coasting speed */
-    int press_motion_min_z;		    /* finger pressure at which minimum pressure motion factor is applied */
-    int press_motion_max_z;		    /* finger pressure at which maximum pressure motion factor is applied */
-    double press_motion_min_factor;	    /* factor applied on speed when finger pressure is at minimum */
-    double press_motion_max_factor; 	    /* factor applied on speed when finger pressure is at minimum */
-    Bool grab_event_device;		    /* grab event device for exclusive use? */
-    Bool tap_and_drag_gesture;		    /* Switches the tap-and-drag gesture on/off */
-    unsigned int resolution_horiz;          /* horizontal resolution of touchpad in units/mm */
-    unsigned int resolution_vert;           /* vertical resolution of touchpad in units/mm */
-    int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge; /* area coordinates absolute */
-    int hyst_x, hyst_y;                     /* x and y width of hysteresis box */
-} SynapticsParameters;
-
-
-typedef struct _SynapticsPrivateRec
-{
-    SynapticsParameters synpara;            /* Default parameter settings, read from
-					       the X config file */
-    SynapticsSHM *synshm;		     /* Current parameter settings. Will point to
-					        shared memory if shm_config is true */
-    struct SynapticsProtocolOperations* proto_ops;
-    void *proto_data;			/* protocol-specific data */
-
-    struct SynapticsHwState hwState;
-
-    char *device;			/* device node */
-    Bool shm_config;			/* True when shared memory area allocated */
-
-    OsTimerPtr timer;			/* for up/down-button repeat, tap processing, etc */
-
-    struct CommData comm;
-
-    Bool absolute_events;               /* post absolute motion events instead of relative */
-    SynapticsMoveHistRec move_hist[SYNAPTICS_MOVE_HISTORY]; /* movement history */
-    int hist_index;			/* Last added entry in move_hist[] */
-    int hyst_center_x;			/* center x of hysteresis*/
-    int hyst_center_y;			/* center y of hysteresis*/
-    int scroll_y;			/* last y-scroll position */
-    int scroll_x;			/* last x-scroll position */
-    double scroll_a;			/* last angle-scroll position */
-    int count_packet_finger;		/* packet counter with finger on the touchpad */
-    int button_delay_millis;		/* button delay for 3rd button emulation */
-    Bool prev_up;			/* Previous up button value, for double click emulation */
-    enum FingerState finger_state;	/* previous finger state */
-
-    enum TapState tap_state;		/* State of tap processing */
-    int tap_max_fingers;		/* Max number of fingers seen since entering start state */
-    int tap_button;			/* Which button started the tap processing */
-    enum TapButtonState tap_button_state; /* Current tap action */
-    SynapticsMoveHistRec touch_on;	/* data when the touchpad is touched/released */
-
-    enum MovingState moving_state;	/* previous moving state */
-    Bool vert_scroll_edge_on;		/* Keeps track of currently active scroll modes */
-    Bool horiz_scroll_edge_on;		/* Keeps track of currently active scroll modes */
-    Bool vert_scroll_twofinger_on;	/* Keeps track of currently active scroll modes */
-    Bool horiz_scroll_twofinger_on;	/* Keeps track of currently active scroll modes */
-    Bool circ_scroll_on;		/* Keeps track of currently active scroll modes */
-    Bool circ_scroll_vert;		/* True: Generate vertical scroll events
-					   False: Generate horizontal events */
-    int trackstick_neutral_x;		/* neutral x position for trackstick mode */
-    int trackstick_neutral_y;		/* neutral y position for trackstick mode */
-    double autoscroll_xspd;		/* Horizontal coasting speed */
-    double autoscroll_yspd;		/* Vertical coasting speed */
-    double autoscroll_x;		/* Accumulated horizontal coasting scroll */
-    double autoscroll_y;		/* Accumulated vertical coasting scroll */
-    int scroll_packet_count;		/* Scroll duration */
-    double frac_x, frac_y;		/* absolute -> relative fraction */
-    enum MidButtonEmulation mid_emu_state;	/* emulated 3rd button */
-    int repeatButtons;			/* buttons for repeat */
-    int nextRepeat;			/* Time when to trigger next auto repeat event */
-    int lastButtons;			/* last state of the buttons */
-    int palm;				/* Set to true when palm detected, reset to false when
-					   palm/finger contact disappears */
-    int prev_z;				/* previous z value, for palm detection */
-    int prevFingers;			/* previous numFingers, for transition detection */
-    int avg_width;			/* weighted average of previous fingerWidth values */
-    double horiz_coeff;                 /* normalization factor for x coordintes */
-    double vert_coeff;                  /* normalization factor for y coordintes */
-
-    int minx, maxx, miny, maxy;         /* min/max dimensions as detected */
-    int minp, maxp, minw, maxw;		/* min/max pressure and finger width as detected */
-    int resx, resy;                     /* resolution of coordinates as detected in units/mm */
-    Bool has_left;			/* left button detected for this device */
-    Bool has_right;			/* right button detected for this device */
-    Bool has_middle;			/* middle button detected for this device */
-    Bool has_double;			/* double click detected for this device */
-    Bool has_triple;			/* triple click detected for this device */
-    Bool has_pressure;			/* device reports pressure */
-    Bool has_width;			/* device reports finger width */
-    Bool has_scrollbuttons;		/* device has physical scrollbuttons */
-
-    enum TouchpadModel model;		/* The detected model */
-    unsigned short id_vendor;		/* vendor id */
-    unsigned short id_product;		/* product id */
-} SynapticsPrivate;
-
-#endif /* _SYNAPTICSSTR_H_ */
diff -Naur xf86-input-synaptics-1.5.0/tools/synclient.c xf86-input-synaptics-1.5.0-old/tools/synclient.c
--- xf86-input-synaptics-1.5.0/tools/synclient.c	2011-10-14 01:34:08.625625080 +0200
+++ xf86-input-synaptics-1.5.0-old/tools/synclient.c	2011-10-14 01:33:00.382741827 +0200
@@ -74,7 +74,6 @@
 
 static struct Parameter params[] = {
     {"LeftEdge",              PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	0},
-    {"Orientation",           PT_INT,    0, 3,     SYNAPTICS_ORIENTATION,       32,     0},
     {"RightEdge",             PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	1},
     {"TopEdge",               PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	2},
     {"BottomEdge",            PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	3},
diff -Naur xf86-input-synaptics-1.5.0/tools/synclient.c.orig xf86-input-synaptics-1.5.0-old/tools/synclient.c.orig
--- xf86-input-synaptics-1.5.0/tools/synclient.c.orig	2011-07-11 23:28:37.000000000 +0200
+++ xf86-input-synaptics-1.5.0-old/tools/synclient.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,614 +0,0 @@
-/*
- * Copyright Â© 2002-2005,2007 Peter Osterlund
- *
- * Permission to use, copy, modify, distribute, and sell this software
- * and its documentation for any purpose is hereby granted without
- * fee, provided that the above copyright notice appear in all copies
- * and that both that copyright notice and this permission notice
- * appear in supporting documentation, and that the name of Red Hat
- * not be used in advertising or publicity pertaining to distribution
- * of the software without specific, written prior permission.  Red
- * Hat makes no representations about the suitability of this software
- * for any purpose.  It is provided "as is" without express or implied
- * warranty.
- *
- * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
- * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
- * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
- * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *
- * Authors:
- *      Peter Osterlund (petero2@telia.com)
- */
-
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/ipc.h>
-#include <sys/shm.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include <string.h>
-#include <stddef.h>
-#include <math.h>
-
-#include <X11/Xdefs.h>
-#include <X11/Xatom.h>
-#include <X11/extensions/XI.h>
-#include <X11/extensions/XInput.h>
-#include "synaptics.h"
-#include "synaptics-properties.h"
-
-#ifndef XATOM_FLOAT
-#define XATOM_FLOAT "FLOAT"
-#endif
-
-union flong { /* Xlibs 64-bit property handling madness */
-    long l;
-    float f;
-};
-
-
-enum ParaType {
-    PT_INT,
-    PT_BOOL,
-    PT_DOUBLE
-};
-
-struct Parameter {
-    char *name;				    /* Name of parameter */
-    enum ParaType type;			    /* Type of parameter */
-    double min_val;			    /* Minimum allowed value */
-    double max_val;			    /* Maximum allowed value */
-    char *prop_name;			    /* Property name */
-    int prop_format;			    /* Property format (0 for floats) */
-    int prop_offset;			    /* Offset inside property */
-};
-
-static struct Parameter params[] = {
-    {"LeftEdge",              PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	0},
-    {"RightEdge",             PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	1},
-    {"TopEdge",               PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	2},
-    {"BottomEdge",            PT_INT,    0, 10000, SYNAPTICS_PROP_EDGES,	32,	3},
-    {"FingerLow",             PT_INT,    0, 255,   SYNAPTICS_PROP_FINGER,	32,	0},
-    {"FingerHigh",            PT_INT,    0, 255,   SYNAPTICS_PROP_FINGER,	32,	1},
-    {"FingerPress",           PT_INT,    0, 256,   SYNAPTICS_PROP_FINGER,	32,	2},
-    {"MaxTapTime",            PT_INT,    0, 1000,  SYNAPTICS_PROP_TAP_TIME,	32,	0},
-    {"MaxTapMove",            PT_INT,    0, 2000,  SYNAPTICS_PROP_TAP_MOVE,	32,	0},
-    {"MaxDoubleTapTime",      PT_INT,    0, 1000,  SYNAPTICS_PROP_TAP_DURATIONS,32,	1},
-    {"SingleTapTimeout",      PT_INT,    0, 1000,  SYNAPTICS_PROP_TAP_DURATIONS,32,	0},
-    {"ClickTime",             PT_INT,    0, 1000,  SYNAPTICS_PROP_TAP_DURATIONS,32,	2},
-    {"FastTaps",              PT_BOOL,   0, 1,     SYNAPTICS_PROP_TAP_FAST,	8,	0},
-    {"EmulateMidButtonTime",  PT_INT,    0, 1000,  SYNAPTICS_PROP_MIDDLE_TIMEOUT,32,	0},
-    {"EmulateTwoFingerMinZ",  PT_INT,    0, 1000,  SYNAPTICS_PROP_TWOFINGER_PRESSURE,	32,	0},
-    {"EmulateTwoFingerMinW",  PT_INT,    0, 15,    SYNAPTICS_PROP_TWOFINGER_WIDTH,	32,	0},
-    {"VertScrollDelta",       PT_INT,    0, 1000,  SYNAPTICS_PROP_SCROLL_DISTANCE,	32,	0},
-    {"HorizScrollDelta",      PT_INT,    0, 1000,  SYNAPTICS_PROP_SCROLL_DISTANCE,	32,	1},
-    {"VertEdgeScroll",        PT_BOOL,   0, 1,     SYNAPTICS_PROP_SCROLL_EDGE,	8,	0},
-    {"HorizEdgeScroll",       PT_BOOL,   0, 1,     SYNAPTICS_PROP_SCROLL_EDGE,	8,	1},
-    {"CornerCoasting",        PT_BOOL,   0, 1,     SYNAPTICS_PROP_SCROLL_EDGE,	8,	2},
-    {"VertTwoFingerScroll",   PT_BOOL,   0, 1,     SYNAPTICS_PROP_SCROLL_TWOFINGER,	8,	0},
-    {"HorizTwoFingerScroll",  PT_BOOL,   0, 1,     SYNAPTICS_PROP_SCROLL_TWOFINGER,	8,	1},
-    {"MinSpeed",              PT_DOUBLE, 0, 255.0,   SYNAPTICS_PROP_SPEED,	0, /*float */	0},
-    {"MaxSpeed",              PT_DOUBLE, 0, 255.0,   SYNAPTICS_PROP_SPEED,	0, /*float */	1},
-    {"AccelFactor",           PT_DOUBLE, 0, 1.0,   SYNAPTICS_PROP_SPEED,	0, /*float */	2},
-    {"TrackstickSpeed",       PT_DOUBLE, 0, 200.0, SYNAPTICS_PROP_SPEED,	0, /*float */ 3},
-    {"EdgeMotionMinZ",        PT_INT,    1, 255,   SYNAPTICS_PROP_EDGEMOTION_PRESSURE,  32,	0},
-    {"EdgeMotionMaxZ",        PT_INT,    1, 255,   SYNAPTICS_PROP_EDGEMOTION_PRESSURE,  32,	1},
-    {"EdgeMotionMinSpeed",    PT_INT,    0, 1000,  SYNAPTICS_PROP_EDGEMOTION_SPEED,     32,	0},
-    {"EdgeMotionMaxSpeed",    PT_INT,    0, 1000,  SYNAPTICS_PROP_EDGEMOTION_SPEED,     32,	1},
-    {"EdgeMotionUseAlways",   PT_BOOL,   0, 1,     SYNAPTICS_PROP_EDGEMOTION,   8,	0},
-    {"UpDownScrolling",       PT_BOOL,   0, 1,     SYNAPTICS_PROP_BUTTONSCROLLING,  8,	0},
-    {"LeftRightScrolling",    PT_BOOL,   0, 1,     SYNAPTICS_PROP_BUTTONSCROLLING,  8,	1},
-    {"UpDownScrollRepeat",    PT_BOOL,   0, 1,     SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT,   8,	0},
-    {"LeftRightScrollRepeat", PT_BOOL,   0, 1,     SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT,   8,	1},
-    {"ScrollButtonRepeat",    PT_INT,    SBR_MIN , SBR_MAX, SYNAPTICS_PROP_BUTTONSCROLLING_TIME, 32,	0},
-    {"TouchpadOff",           PT_INT,    0, 2,     SYNAPTICS_PROP_OFF,		8,	0},
-    {"LockedDrags",           PT_BOOL,   0, 1,     SYNAPTICS_PROP_LOCKED_DRAGS,	8,	0},
-    {"LockedDragTimeout",     PT_INT,    0, 30000, SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT,	32,	0},
-    {"RTCornerButton",        PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	0},
-    {"RBCornerButton",        PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	1},
-    {"LTCornerButton",        PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	2},
-    {"LBCornerButton",        PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	3},
-    {"TapButton1",            PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	4},
-    {"TapButton2",            PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	5},
-    {"TapButton3",            PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_TAP_ACTION,	8,	6},
-    {"ClickFinger1",          PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_CLICK_ACTION,	8,	0},
-    {"ClickFinger2",          PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_CLICK_ACTION,	8,	1},
-    {"ClickFinger3",          PT_INT,    0, SYN_MAX_BUTTONS, SYNAPTICS_PROP_CLICK_ACTION,	8,	2},
-    {"CircularScrolling",     PT_BOOL,   0, 1,     SYNAPTICS_PROP_CIRCULAR_SCROLLING,	8,	0},
-    {"CircScrollDelta",       PT_DOUBLE, .01, 3,   SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST,	0 /* float */,	0},
-    {"CircScrollTrigger",     PT_INT,    0, 8,     SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER,	8,	0},
-    {"CircularPad",           PT_BOOL,   0, 1,     SYNAPTICS_PROP_CIRCULAR_PAD,	8,	0},
-    {"PalmDetect",            PT_BOOL,   0, 1,     SYNAPTICS_PROP_PALM_DETECT,	8,	0},
-    {"PalmMinWidth",          PT_INT,    0, 15,    SYNAPTICS_PROP_PALM_DIMENSIONS,	32,	0},
-    {"PalmMinZ",              PT_INT,    0, 255,   SYNAPTICS_PROP_PALM_DIMENSIONS,	32,	1},
-    {"CoastingSpeed",         PT_DOUBLE, 0, 20,    SYNAPTICS_PROP_COASTING_SPEED,	0 /* float*/,	0},
-    {"CoastingFriction",      PT_DOUBLE, 0, 255,   SYNAPTICS_PROP_COASTING_SPEED,	0 /* float*/,	1},
-    {"PressureMotionMinZ",    PT_INT,    1, 255,   SYNAPTICS_PROP_PRESSURE_MOTION,	32,	0},
-    {"PressureMotionMaxZ",    PT_INT,    1, 255,   SYNAPTICS_PROP_PRESSURE_MOTION,	32,	1},
-    {"PressureMotionMinFactor", PT_DOUBLE, 0, 10.0,SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR,	0 /*float*/,	0},
-    {"PressureMotionMaxFactor", PT_DOUBLE, 0, 10.0,SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR,	0 /*float*/,	1},
-    {"GrabEventDevice",       PT_BOOL,   0, 1,     SYNAPTICS_PROP_GRAB,	8,	0},
-    {"TapAndDragGesture",     PT_BOOL,   0, 1,     SYNAPTICS_PROP_GESTURES,	8,	0},
-    {"AreaLeftEdge",          PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	0},
-    {"AreaRightEdge",         PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	1},
-    {"AreaTopEdge",           PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	2},
-    {"AreaBottomEdge",        PT_INT,    0, 10000, SYNAPTICS_PROP_AREA,	32,	3},
-    { NULL, 0, 0, 0, 0 }
-};
-
-static double
-parse_cmd(char* cmd, struct Parameter** par)
-{
-    char *eqp = strchr(cmd, '=');
-    *par = NULL;
-
-    if (eqp) {
-	int j;
-	int found = 0;
-	*eqp = 0;
-	for (j = 0; params[j].name; j++) {
-	    if (strcasecmp(cmd, params[j].name) == 0) {
-		found = 1;
-		break;
-	    }
-	}
-	if (found) {
-	    double val = atof(&eqp[1]);
-	    *par = &params[j];
-
-	    if (val < (*par)->min_val)
-		val = (*par)->min_val;
-	    if (val > (*par)->max_val)
-		val = (*par)->max_val;
-
-	    return val;
-	} else {
-	    printf("Unknown parameter %s\n", cmd);
-	}
-    } else {
-	printf("Invalid command: %s\n", cmd);
-    }
-
-    return 0;
-}
-
-static int
-is_equal(SynapticsSHM *s1, SynapticsSHM *s2)
-{
-    int i;
-
-    if ((s1->x           != s2->x) ||
-	(s1->y           != s2->y) ||
-	(s1->z           != s2->z) ||
-	(s1->numFingers  != s2->numFingers) ||
-	(s1->fingerWidth != s2->fingerWidth) ||
-	(s1->left        != s2->left) ||
-	(s1->right       != s2->right) ||
-	(s1->up          != s2->up) ||
-	(s1->down        != s2->down) ||
-	(s1->middle      != s2->middle))
-	return 0;
-
-    for (i = 0; i < 8; i++)
-	if (s1->multi[i] != s2->multi[i])
-	    return 0;
-
-    return 1;
-}
-
-static double
-get_time(void)
-{
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return tv.tv_sec + tv.tv_usec / 1000000.0;
-}
-
-static void
-shm_monitor(SynapticsSHM *synshm, int delay)
-{
-    int header = 0;
-    SynapticsSHM old;
-    double t0 = get_time();
-
-    memset(&old, 0, sizeof(SynapticsSHM));
-    old.x = -1;				    /* Force first equality test to fail */
-
-    while (1) {
-	SynapticsSHM cur = *synshm;
-	if (!is_equal(&old, &cur)) {
-	    if (!header) {
-		printf("%8s  %4s %4s %3s %s %2s %2s %s %s %s %s  %8s  "
-		       "%2s %2s %2s %3s %3s\n",
-		       "time", "x", "y", "z", "f", "w", "l", "r", "u", "d", "m",
-		       "multi", "gl", "gm", "gr", "gdx", "gdy");
-		header = 20;
-	    }
-	    header--;
-	    printf("%8.3f  %4d %4d %3d %d %2d %2d %d %d %d %d  %d%d%d%d%d%d%d%d\n",
-		   get_time() - t0,
-		   cur.x, cur.y, cur.z, cur.numFingers, cur.fingerWidth,
-		   cur.left, cur.right, cur.up, cur.down, cur.middle,
-		   cur.multi[0], cur.multi[1], cur.multi[2], cur.multi[3],
-		   cur.multi[4], cur.multi[5], cur.multi[6], cur.multi[7]);
-	    fflush(stdout);
-	    old = cur;
-	}
-	usleep(delay * 1000);
-    }
-}
-
-/** Init and return SHM area or NULL on error */
-static  SynapticsSHM*
-shm_init()
-{
-    SynapticsSHM *synshm = NULL;
-    int shmid = 0;
-
-    if ((shmid = shmget(SHM_SYNAPTICS, sizeof(SynapticsSHM), 0)) == -1) {
-	if ((shmid = shmget(SHM_SYNAPTICS, 0, 0)) == -1)
-	    fprintf(stderr, "Can't access shared memory area. SHMConfig disabled?\n");
-	else
-	    fprintf(stderr, "Incorrect size of shared memory area. Incompatible driver version?\n");
-    } else if ((synshm = (SynapticsSHM*) shmat(shmid, NULL, SHM_RDONLY)) == NULL)
-	perror("shmat");
-
-    return synshm;
-}
-
-static void
-shm_process_commands(int do_monitor, int delay)
-{
-    SynapticsSHM *synshm = NULL;
-
-    synshm = shm_init();
-    if (!synshm)
-        return;
-
-    if (do_monitor)
-        shm_monitor(synshm, delay);
-}
-
-/** Init display connection or NULL on error */
-static Display*
-dp_init()
-{
-    Display *dpy		= NULL;
-    XExtensionVersion *v	= NULL;
-    Atom touchpad_type		= 0;
-    Atom synaptics_property	= 0;
-    int error			= 0;
-
-    dpy = XOpenDisplay(NULL);
-    if (!dpy) {
-	fprintf(stderr, "Failed to connect to X Server.\n");
-	error = 1;
-	goto unwind;
-    }
-
-    v = XGetExtensionVersion(dpy, INAME);
-    if (!v->present ||
-	(v->major_version * 1000 + v->minor_version) < (XI_Add_DeviceProperties_Major * 1000
-	    + XI_Add_DeviceProperties_Minor)) {
-	fprintf(stderr, "X server supports X Input %d.%d. I need %d.%d.\n",
-		v->major_version, v->minor_version,
-		XI_Add_DeviceProperties_Major,
-		XI_Add_DeviceProperties_Minor);
-	error = 1;
-	goto unwind;
-    }
-
-    /* We know synaptics sets XI_TOUCHPAD for all the devices. */
-    touchpad_type = XInternAtom(dpy, XI_TOUCHPAD, True);
-    if (!touchpad_type) {
-	fprintf(stderr, "XI_TOUCHPAD not initialised.\n");
-	error = 1;
-	goto unwind;
-    }
-
-    synaptics_property = XInternAtom(dpy, SYNAPTICS_PROP_EDGES, True);
-    if (!synaptics_property) {
-	fprintf(stderr, "Couldn't find synaptics properties. No synaptics "
-		"driver loaded?\n");
-	error = 1;
-	goto unwind;
-    }
-
-unwind:
-    XFree(v);
-    if (error && dpy)
-    {
-	XCloseDisplay(dpy);
-	dpy = NULL;
-    }
-    return dpy;
-}
-
-static XDevice *
-dp_get_device(Display *dpy)
-{
-    XDevice* dev		= NULL;
-    XDeviceInfo *info		= NULL;
-    int ndevices		= 0;
-    Atom touchpad_type		= 0;
-    Atom synaptics_property	= 0;
-    Atom *properties		= NULL;
-    int nprops			= 0;
-    int error			= 0;
-
-    touchpad_type = XInternAtom(dpy, XI_TOUCHPAD, True);
-    synaptics_property = XInternAtom(dpy, SYNAPTICS_PROP_EDGES, True);
-    info = XListInputDevices(dpy, &ndevices);
-
-    while(ndevices--) {
-	if (info[ndevices].type == touchpad_type) {
-	    dev = XOpenDevice(dpy, info[ndevices].id);
-	    if (!dev) {
-		fprintf(stderr, "Failed to open device '%s'.\n",
-			info[ndevices].name);
-		error = 1;
-		goto unwind;
-	    }
-
-	    properties = XListDeviceProperties(dpy, dev, &nprops);
-	    if (!properties || !nprops)
-	    {
-		fprintf(stderr, "No properties on device '%s'.\n",
-			info[ndevices].name);
-		error = 1;
-		goto unwind;
-	    }
-
-	    while(nprops--)
-	    {
-		if (properties[nprops] == synaptics_property)
-		    break;
-	    }
-	    if (!nprops)
-	    {
-		fprintf(stderr, "No synaptics properties on device '%s'.\n",
-			info[ndevices].name);
-		error = 1;
-		goto unwind;
-	    }
-
-	    break; /* Yay, device is suitable */
-	}
-    }
-
-unwind:
-    XFree(properties);
-    XFreeDeviceList(info);
-    if (!dev)
-        fprintf(stderr, "Unable to find a synaptics device.\n");
-    else if (error && dev)
-    {
-	XCloseDevice(dpy, dev);
-	dev = NULL;
-    }
-    return dev;
-}
-
-static void
-dp_set_variables(Display *dpy, XDevice* dev, int argc, char *argv[], int first_cmd)
-{
-    int i;
-    double val;
-    struct Parameter *par;
-    Atom prop, type, float_type;
-    int format;
-    unsigned char* data;
-    unsigned long nitems, bytes_after;
-
-    union flong *f;
-    long *n;
-    char *b;
-
-    float_type = XInternAtom(dpy, XATOM_FLOAT, True);
-    if (!float_type)
-	fprintf(stderr, "Float properties not available.\n");
-
-    for (i = first_cmd; i < argc; i++) {
-	val = parse_cmd(argv[i], &par);
-	if (!par)
-	    continue;
-
-	prop = XInternAtom(dpy, par->prop_name, True);
-	if (!prop)
-	{
-	    fprintf(stderr, "Property for '%s' not available. Skipping.\n",
-		    par->name);
-	    continue;
-
-	}
-
-	XGetDeviceProperty(dpy, dev, prop, 0, 1000, False, AnyPropertyType,
-				&type, &format, &nitems, &bytes_after, &data);
-
-	switch(par->prop_format)
-	{
-	    case 8:
-		if (format != par->prop_format || type != XA_INTEGER) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-		b = (char*)data;
-		b[par->prop_offset] = rint(val);
-		break;
-	    case 32:
-		if (format != par->prop_format || type != XA_INTEGER) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-		n = (long*)data;
-		n[par->prop_offset] = rint(val);
-		break;
-	    case 0: /* float */
-		if (!float_type)
-		    continue;
-		if (format != 32 || type != float_type) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-		f = (union flong*)data;
-		f[par->prop_offset].f = val;
-		break;
-	}
-
-	XChangeDeviceProperty(dpy, dev, prop, type, format,
-				PropModeReplace, data, nitems);
-	XFlush(dpy);
-    }
-}
-
-/* FIXME: horribly inefficient. */
-static void
-dp_show_settings(Display *dpy, XDevice *dev)
-{
-    int j;
-    Atom a, type, float_type;
-    int format;
-    unsigned long nitems, bytes_after;
-    unsigned char* data;
-    int len;
-
-    union flong *f;
-    long *i;
-    char *b;
-
-    float_type = XInternAtom(dpy, XATOM_FLOAT, True);
-    if (!float_type)
-	fprintf(stderr, "Float properties not available.\n");
-
-    printf("Parameter settings:\n");
-    for (j = 0; params[j].name; j++) {
-	struct Parameter *par = &params[j];
-	a = XInternAtom(dpy, par->prop_name, True);
-	if (!a)
-	    continue;
-
-	len = 1 + ((par->prop_offset * (par->prop_format ? par->prop_format : 32)/8))/4;
-
-	XGetDeviceProperty(dpy, dev, a, 0, len, False,
-				AnyPropertyType, &type, &format,
-				&nitems, &bytes_after, &data);
-
-	switch(par->prop_format) {
-	    case 8:
-		if (format != par->prop_format || type != XA_INTEGER) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-
-		b = (char*)data;
-		printf("    %-23s = %d\n", par->name, b[par->prop_offset]);
-		break;
-	    case 32:
-		if (format != par->prop_format || type != XA_INTEGER) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-
-		i = (long*)data;
-		printf("    %-23s = %ld\n", par->name, i[par->prop_offset]);
-		break;
-	    case 0: /* Float */
-		if (!float_type)
-		    continue;
-		if (format != 32 || type != float_type) {
-		    fprintf(stderr, "   %-23s = format mismatch (%d)\n",
-			    par->name, format);
-		    break;
-		}
-
-		f = (union flong*)data;
-		printf("    %-23s = %g\n", par->name, f[par->prop_offset].f);
-		break;
-	}
-
-	XFree(data);
-    }
-}
-
-static void
-usage(void)
-{
-    fprintf(stderr, "Usage: synclient [-s] [-m interval] [-h] [-l] [-V] [-?] [var1=value1 [var2=value2] ...]\n");
-    fprintf(stderr, "  -m monitor changes to the touchpad state (implies -s)\n"
-	    "     interval specifies how often (in ms) to poll the touchpad state\n");
-    fprintf(stderr, "  -l List current user settings\n");
-    fprintf(stderr, "  -V Print synclient version string and exit\n");
-    fprintf(stderr, "  -? Show this help message\n");
-    fprintf(stderr, "  var=value  Set user parameter 'var' to 'value'.\n");
-    exit(1);
-}
-
-int
-main(int argc, char *argv[])
-{
-    int c;
-    int delay = -1;
-    int do_monitor = 0;
-    int dump_settings = 0;
-    int first_cmd;
-
-    Display *dpy;
-    XDevice *dev;
-
-    if (argc == 1)
-        dump_settings = 1;
-
-    /* Parse command line parameters */
-    while ((c = getopt(argc, argv, "sm:hlV")) != -1) {
-	switch (c) {
-	case 'm':
-	    do_monitor = 1;
-	    if ((delay = atoi(optarg)) < 0)
-		usage();
-	    break;
-	case 'l':
-	    dump_settings = 1;
-	    break;
-	case 'V':
-	    printf("%s\n", VERSION);
-	    exit(0);
-	default:
-	    usage();
-	}
-    }
-
-    first_cmd = optind;
-    if (!do_monitor && !dump_settings && first_cmd == argc)
-	usage();
-
-    /* Connect to the shared memory area */
-    if (do_monitor)
-        shm_process_commands(do_monitor, delay);
-
-    dpy = dp_init();
-    if (!dpy || !(dev = dp_get_device(dpy)))
-        return 1;
-
-    dp_set_variables(dpy, dev, argc, argv, first_cmd);
-    if (dump_settings)
-        dp_show_settings(dpy, dev);
-
-    XCloseDevice(dpy, dev);
-    XCloseDisplay(dpy);
-
-    return 0;
-}
