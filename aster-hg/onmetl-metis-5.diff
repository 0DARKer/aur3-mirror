diff -Naur aster.orig/bibc/renum/onmetl.c aster/bibc/renum/onmetl.c
--- aster.orig/bibc/renum/onmetl.c	2014-01-06 23:28:12.601916921 +0100
+++ aster/bibc/renum/onmetl.c	2014-01-21 13:59:15.724619630 +0100
@@ -20,137 +20,188 @@
 
 #ifdef _HAVE_METIS
 #include "metis.h"
-#endif
-
-
-void DEFPPPPPPPPPPPPP(ONMETL,onmetl, nbnd,nadj,
-                        xadjd, adjncy,
-                       invpnd,permnd,supnd, parent,
-          nbsn,nbops,fctnzs, lgind, 
-          niv)
-     INTEGER4 *nbnd,*nadj,  *xadjd, *adjncy;
-     INTEGER4 *invpnd, *permnd,*supnd, *parent,*nbsn;
-     DOUBLE *nbops;
-     INTEGER4 *fctnzs, *lgind;
-     INTEGER *niv;
-{
-#ifdef _HAVE_METIS
-  /*
-Donnees:
---------
-nbnd : Nombre de noeuds
-nadj : Nombre d aretes du graphe de connexion
-xadj[1:nbnd+1]: pointeur de adjncy
-adjncy[1:nadj] : connexion du graphe, voisins de chaque noeud
-
-niv : niveau des impressions 0, 1, 2 
-
-Resultats:
----------
-invpnd[1:nbnd] : Renumerotation des noeuds (nouveau numero)
-permnd[1:nbnd] : inverse du precedent (ancien numero)
-nbsn : Nombre de super noeuds
-parent[1:nbsn] : arborescence des super noeuds
-supnd[1:nbnd+1] : definition des supernoeuds
-
-nbops : Nombre d operation flottantes pour la factorisation a effectuer
-fctnzs : Nombre de termes non nuls dans la matrice factorisee
-lgind  : longueur de tableaux de pointeurs
-   */
-  int n,m,i;
-  n=*nbnd;
-  m=*nadj;
-
-  int  options[10],ret;
-   idxtype *perm, *iperm; 
-   GraphType graph; 
-   char filename[256]; 
-   int numflag = 0, wgtflag; 
-   timer TOTALTmr, METISTmr, IOTmr, SMBTmr; 
-   strcpy(filename, "fort.81"); 
-   
-   cleartimer(TOTALTmr); 
-   cleartimer(METISTmr); 
-   cleartimer(IOTmr); 
-   cleartimer(SMBTmr); 
+#include "time.h"
 
-   starttimer(TOTALTmr); 
-   starttimer(IOTmr);
-   ret = ReadGraphL(&graph,nbnd,nadj,xadjd,adjncy , &wgtflag);
-   if (graph.nvtxs <= 0) { 
-     printf("Empty graph. Nothing to do.\n"); 
-     exit(4); 
-   } 
-   if (graph.ncon != 1) { 
-     printf("Ordering can only be applied to graphs with one constraint.\n"); 
-     exit(4); 
-   } 
-   stoptimer(IOTmr); 
-
-   /* Ordering does not use weights! */ 
-   GKfree(&graph.vwgt, &graph.adjwgt, LTERM); 
-
-   if (*niv > 1 ) {
-     printf("**********************************************************************\n"); 
-     printf("%s", METISTITLE); 
-     printf("Graph Information ---------------------------------------------------\n"); 
-     printf("  Name: %s, #Vertices: %d, #Edges: %d\n\n", filename, graph.nvtxs, graph.nedges/2); 
-     printf("Node-Based Ordering... ----------------------------------------------\n"); 
-   }
-   perm = idxmalloc(graph.nvtxs, "main: perm"); 
-   iperm = idxmalloc(graph.nvtxs, "main: iperm"); 
-   options[0] = 0; 
- 
-   starttimer(METISTmr); 
-   METIS_NodeND(&graph.nvtxs, graph.xadj, graph.adjncy, &numflag, options, perm, iperm); 
-   stoptimer(METISTmr); 
+/*************************************************************************
+ * This function returns program time in seconds
+ **************************************************************************/
+double seconds(void){
+  return((double) clock()/CLOCKS_PER_SEC);
+}
 
-   starttimer(IOTmr); 
-   WritePermutation(filename, iperm, graph.nvtxs);
+/*************************************************************************
+ * The following function is wrapper for METIS_Free() that accepts multiple 
+ * arguments.
+ **************************************************************************/
+void idxfree( idx_t * firstVar, ... ){
+  va_list vars;
+  va_start (vars, firstVar);
+
+  idx_t * var = firstVar;
+  while( var != NULL ){
+    METIS_Free( var );
+    var = va_arg(vars, idx_t *);
+  }
+  va_end(vars);
+}
 
-   stoptimer(IOTmr); 
-   starttimer(SMBTmr); 
-   ret = ComputeFillInL(&graph, iperm,parent,
-          supnd,&graph.nvtxs,nbsn,nbops,lgind,fctnzs);
-   stoptimer(SMBTmr); 
+/*************************************************************************
+ * The following function allocates an array of type idx_t
+ **************************************************************************/
+idx_t *idxmalloc(int n, char *msg) {
+  if (n == 0)
+    return NULL;
+
+  idx_t * x = (idx_t *)malloc(sizeof(idx_t)*n);
+  if (x == NULL) 
+    errexit("Memory allocation failed for %s. Requested size: %d bytes", msg, (sizeof(idx_t)*n));
 
-   stoptimer(TOTALTmr); 
-   
-   if (*niv > 1 ) {
-     printf("\nTiming Information --------------------------------------------------\n"); 
-     printf("  I/O:                     \t %7.3f\n", gettimer(IOTmr)); 
-     printf("  Ordering:                \t %7.3f   (ONMETIS time)\n", gettimer(METISTmr)); 
-     printf("  Symbolic Factorization:  \t %7.3f\n", gettimer(SMBTmr)); 
-     printf("  Total:                   \t %7.3f\n", gettimer(TOTALTmr)); 
-     printf("**********************************************************************\n"); 
-   }
+  return x;
+}
 
+/*************************************************************************
+ * The following function allocates an array of type idx_t and sets initial
+ * values to ival
+ **************************************************************************/
+idx_t *idxsmalloc(int n, idx_t ival, char *msg) {
+  if (n == 0)
+    return NULL;
+
+  idx_t * x = (idx_t *)malloc(sizeof(idx_t)*n);
+  if (x == NULL) 
+    errexit("Memory allocation failed for %s. Requested size: %d bytes", msg, (sizeof(idx_t)*n));
+
+  int i;
+  for (i=0; i<n; i++)
+    x[i] = ival;
 
-   
-   {int kkk;
- 
-   for(kkk=0;kkk<graph.nvtxs;kkk++)
-     {invpnd[kkk]= iperm[kkk]; 
-       permnd[ invpnd[kkk] ]= kkk;
- 
-     } 
-    for(kkk=0;kkk<graph.nvtxs;kkk++)
-      { invpnd[kkk]+=1;
-    permnd[kkk]+=1;
-      }
-   }
-    GKfree(&graph.xadj, &graph.adjncy, &perm, &iperm, LTERM); 
-     
-#else    
-  
-    CALL_UTMESS("F", "FERMETUR_15");
-  
-           
-#endif
+  return x;
 }
 
+/************************************************************************
+ *  The following data structure stores holds information on degrees for k-way
+ *  partition
+ *************************************************************************/
+typedef struct ckrinfo_t {
+  idx_t id;           /*!< The internal degree of a vertex (sum of weights) */
+  idx_t ed;           /*!< The total external degree of a vertex */
+  idx_t nnbrs;        /*!< The number of neighboring subdomains */
+  idx_t inbr;         /*!< The index in the cnbr_t array where the nnbrs list 
+                             of neighbors is stored */
+} ckrinfo_t;
+
+/*************************************************************************/
+/*! The following data structure holds information on degrees for k-way
+  vol-based partition */
+/*************************************************************************/
+typedef struct vkrinfo_t {
+  idx_t nid;          /*!< The internal degree of a vertex (count of edges) */
+  idx_t ned;          /*!< The total external degree of a vertex (count of edges) */
+  idx_t gv;           /*!< The volume gain of moving that vertex */
+  idx_t nnbrs;        /*!< The number of neighboring subdomains */
+  idx_t inbr;         /*!< The index in the vnbr_t array where the nnbrs list 
+                           of neighbors is stored */
+} vkrinfo_t;
+
+/************************************************************************
+ * The following data structure holds information on degrees for k-way
+ * partition
+ *************************************************************************/
+typedef struct nrinfo_t {
+  idx_t edegrees[2];  
+} nrinfo_t;
+
+/************************************************************************
+ * This data structure holds a graph
+ *************************************************************************/
+typedef struct GraphType {
+  idx_t nvtxs, nedges; /* The # of vertices and edges in the graph */
+  idx_t ncon;          /* The # of constrains */ 
+  idx_t *xadj;         /* Pointers to the locally stored vertices */
+  idx_t *vwgt;         /* Vertex weights */
+  idx_t *vsize;        /* Vertex sizes for min-volume formulation */
+  idx_t *adjncy;       /* Array that stores the adjacency lists of nvtxs */
+  idx_t *adjwgt;       /* Array that stores the weights of the adjacency lists */
+
+  idx_t *tvwgt;        /* The sum of the vertex weights in the graph */
+  real_t *invtvwgt;    /* The inverse of the sum of the vertex weights in the graph */
+
+
+  /* These are to keep track control if the corresponding fields correspond to
+     application or library memory */
+  int free_xadj, free_vwgt, free_vsize, free_adjncy, free_adjwgt;
+
+  idx_t *label;
+
+  idx_t *cmap;
+
+  /* Partition parameters */
+  idx_t mincut, minvol;
+  idx_t *where, *pwgts;
+  idx_t nbnd;
+  idx_t *bndptr, *bndind;
+
+  /* Bisection refinement parameters */
+  idx_t *id, *ed;
+
+  /* K-way refinement parameters */
+  ckrinfo_t *ckrinfo;   /*!< The per-vertex cut-based refinement info */
+  vkrinfo_t *vkrinfo;   /*!< The per-vertex volume-based refinement info */
+
+  /* Node refinement information */
+  nrinfo_t *nrinfo;
+
+  struct GraphType *coarser, *finer;
+} GraphType;
+
+/************************************************************************
+ *! This function initializes a GraphType data structure 
+ ************************************************************************/
+void InitGraphType(GraphType *graph) {
+  memset((void *)graph, 0, sizeof(GraphType));
+
+  /* graph size constants */
+  graph->nvtxs     = -1;
+  graph->nedges    = -1;
+  graph->ncon      = -1;
+  graph->mincut    = -1;
+  graph->minvol    = -1;
+  graph->nbnd      = -1;
+
+  /* memory for the graph structure */
+  graph->xadj      = NULL;
+  graph->vwgt      = NULL;
+  graph->vsize     = NULL;
+  graph->adjncy    = NULL;
+  graph->adjwgt    = NULL;
+  graph->label     = NULL;
+  graph->cmap      = NULL;
+  graph->tvwgt     = NULL;
+  graph->invtvwgt  = NULL;
+
+  /* by default these are set to true, but the can be explicitly changed afterwards */
+  graph->free_xadj   = 1;
+  graph->free_vwgt   = 1;
+  graph->free_vsize  = 1;
+  graph->free_adjncy = 1;
+  graph->free_adjwgt = 1;
+
+  /* memory for the partition/refinement structure */
+  graph->where     = NULL;
+  graph->pwgts     = NULL;
+  graph->id        = NULL;
+  graph->ed        = NULL;
+  graph->bndptr    = NULL;
+  graph->bndind    = NULL;
+  graph->nrinfo    = NULL;
+  graph->ckrinfo   = NULL;
+  graph->vkrinfo   = NULL;
+
+  /* linked-list structure */
+  graph->coarser   = NULL;
+  graph->finer     = NULL;
+}
 
-#ifdef _HAVE_METIS
  /************************************************************************* 
  * This function reads the spd matrix 
  **************************************************************************/ 
@@ -158,14 +209,15 @@
 int ReadGraphL(GraphType *graph, int *nbnd,int *nadj,int *xadjd,int *adjnci, int *wgtflag)
 {
   int i, j, k, l, fmt, readew, readvw, ncon, edge, ewgt;
-  idxtype *xadj, *adjncy, *vwgt, *adjwgt;
-  char *line, *oldstr, *newstr;
+  idx_t *xadj, *adjncy, *vwgt, *adjwgt;
+  /* char * line */
+  char *oldstr, *newstr;
   FILE *fpin;
 
-  InitGraph(graph);
+  InitGraphType(graph);
 
-  line = (char *)malloc(sizeof(char)*(MAXLINE+1));
   /*
+  line = (char *)malloc(sizeof(char)*(MAXLINE+1));
   if ((fpin = fopen(filename, "r")) == NULL) {
     printf("Failed to open file %s\n", filename);
     exit(0);
@@ -212,8 +264,8 @@
   /*  graph->nedges *=2;mis directement a nadj */
   ncon = graph->ncon = (ncon == 0 ? 1 : ncon);
 
-  if (graph->nvtxs > MAXIDX) 
-    errexit("\nThe matrix is too big: %d [%d %d]\n", graph->nvtxs, MAXIDX, sizeof(idxtype));
+  if (graph->nvtxs > IDX_MAX) 
+    errexit("\nThe matrix is too big: %d [%d %d]\n", graph->nvtxs, IDX_MAX, sizeof(idx_t));
 
   xadj = graph->xadj = idxsmalloc(graph->nvtxs+1, 0, "ReadGraph: xadj");
   adjncy = graph->adjncy = idxmalloc(graph->nedges, "ReadGraph: adjncy");
@@ -232,7 +284,7 @@
          adjncy[k]=adjnci[k]-1; /*  on est en C */
     }
  
-  free(line);
+  /* free(line); */
   return 0;
 }
 
@@ -240,7 +292,7 @@
  /************************************************************************* 
  * This function writes out the partition vector 
  **************************************************************************/ 
- void WritePermutation(char *fname, idxtype *iperm, int n) 
+ void WritePermutation(char *fname, idx_t *iperm, int n) 
  { 
    FILE *fpout; 
    int i; 
@@ -267,12 +319,12 @@
 /************************************************************************* 
  * This function sets up data structures for fill-in computations 
  **************************************************************************/ 
-int ComputeFillInL(GraphType *graph, idxtype *iperm,idxtype *parent,
-            idxtype *supnd,int *neq,int *nbsn,double *opc,int *lgindd,int *maxlnz)
+int ComputeFillInL(GraphType *graph, idx_t *iperm,idx_t *parent,
+            idx_t *supnd,int *neq,int *nbsn,double *opc,int *lgindd,int *maxlnz)
  { 
    int i, j, k, nvtxs, maxsub,lgind;
-   idxtype *xadj, *adjncy; 
-   idxtype *perm, *xlnz, *xnzsub, *nzsub; 
+   idx_t *xadj, *adjncy; 
+   idx_t *perm, *xlnz, *xnzsub, *nzsub; 
 
 
  
@@ -334,7 +386,7 @@
    
    
   
-   GKfree(&perm, &xlnz, &xnzsub, &nzsub, LTERM); 
+   idxfree(perm, xlnz, xnzsub, nzsub); 
 
 
    /* Relabel the vertices so that it starts from 0 */ 
@@ -376,21 +428,21 @@
  *      MAXLNZ - THE NUMBER OF NONZEROS FOUND.              
  * 
  *******************************************************************/ 
- int smbfctl(int neqns, idxtype *xadj, idxtype *adjncy, idxtype *perm, idxtype *invp,
-             idxtype *xlnz, int *maxlnz, idxtype *xnzsub, idxtype *nzsub, int *maxsub,
-             idxtype *supnd, idxtype *parsnode, int *nbsn, int *lgin, double *opc)
+ int smbfctl(int neqns, idx_t *xadj, idx_t *adjncy, idx_t *perm, idx_t *invp,
+             idx_t *xlnz, int *maxlnz, idx_t *xnzsub, idx_t *nzsub, int *maxsub,
+             idx_t *supnd, idx_t *parsnode, int *nbsn, int *lgin, double *opc)
  { 
    /* Local variables */ 
    int snode,node, rchm, mrgk, lmax, i, j, k, m, nabor, nzbeg, nzend;
    int kxsub, jstop, jstrt, mrkflg, inz, knz, flag,lgind; 
-   idxtype *mrglnk, *marker, *rchlnk; 
+   idx_t *mrglnk, *marker, *rchlnk; 
  /* jyb */ 
    int  lnode, xnzi, xnzip1,nbi, nbip1; 
    int aux, minsn, maxsn; 
 
    int taille1, k1, taille2, k2, taille3, k3,nd; 
-   /* idxtype *parent, *nliens, *supnd, *tbnode, *parsnode;*/
-   idxtype *parent, *nliens, *tbnode; 
+   /* idx_t *parent, *nliens, *supnd, *tbnode, *parsnode;*/
+   idx_t *parent, *nliens, *tbnode; 
    FILE *fpout; 
    /*  extern void ecri11_; */ 
  /* jyb fin */ 
@@ -715,7 +767,7 @@
    perm++; 
    adjncy++; 
    xadj++; 
-   GKfree(&rchlnk, &mrglnk, &marker, LTERM);
+   idxfree(rchlnk, mrglnk, marker);
    parsnode++;
    supnd++;
    
@@ -727,3 +779,132 @@
  }  
 
 #endif
+
+void DEFPPPPPPPPPPPPP(ONMETL,onmetl, nbnd,nadj,
+                        xadjd, adjncy,
+                       invpnd,permnd,supnd, parent,
+          nbsn,nbops,fctnzs, lgind, 
+          niv)
+     INTEGER4 *nbnd,*nadj,  *xadjd, *adjncy;
+     INTEGER4 *invpnd, *permnd,*supnd, *parent,*nbsn;
+     DOUBLE *nbops;
+     INTEGER4 *fctnzs, *lgind;
+     INTEGER *niv;
+{
+#ifdef _HAVE_METIS
+  /*
+Donnees:
+--------
+nbnd : Nombre de noeuds
+nadj : Nombre d aretes du graphe de connexion
+xadj[1:nbnd+1]: pointeur de adjncy
+adjncy[1:nadj] : connexion du graphe, voisins de chaque noeud
+
+niv : niveau des impressions 0, 1, 2 
+
+Resultats:
+---------
+invpnd[1:nbnd] : Renumerotation des noeuds (nouveau numero)
+permnd[1:nbnd] : inverse du precedent (ancien numero)
+nbsn : Nombre de super noeuds
+parent[1:nbsn] : arborescence des super noeuds
+supnd[1:nbnd+1] : definition des supernoeuds
+
+nbops : Nombre d operation flottantes pour la factorisation a effectuer
+fctnzs : Nombre de termes non nuls dans la matrice factorisee
+lgind  : longueur de tableaux de pointeurs
+   */
+  int n,m,i;
+  n=*nbnd;
+  m=*nadj;
+
+   idx_t options[METIS_NOPTIONS];
+   int  ret;
+   idx_t *perm, *iperm; 
+   GraphType graph; 
+   char filename[256]; 
+   int numflag = 0, wgtflag; 
+   double TOTALTmr, METISTmr, IOTmr, SMBTmr; 
+   strcpy(filename, "fort.81"); 
+   
+   /* Clear timers */
+   TOTALTmr = 0.0; 
+   METISTmr = 0.0; 
+   IOTmr = 0.0; 
+   SMBTmr = 0.0; 
+
+   TOTALTmr -= seconds(); 
+   IOTmr -= seconds();
+   ret = ReadGraphL(&graph,nbnd,nadj,xadjd,adjncy , &wgtflag);
+   if (graph.nvtxs <= 0) { 
+     printf("Empty graph. Nothing to do.\n"); 
+     exit(4); 
+   } 
+   if (graph.ncon != 1) { 
+     printf("Ordering can only be applied to graphs with one constraint.\n"); 
+     exit(4); 
+   } 
+   IOTmr += seconds(); 
+
+   /* Ordering does not use weights! */ 
+   idxfree(graph.vwgt, graph.adjwgt); 
+
+   if (*niv > 1 ) {
+     printf("**********************************************************************\n"); 
+     printf("METIS VERSION %d.%d.%d", METIS_VER_MAJOR, METIS_VER_MINOR, METIS_VER_SUBMINOR);
+     printf("Graph Information ---------------------------------------------------\n"); 
+     printf("  Name: %s, #Vertices: %d, #Edges: %d\n\n", filename, graph.nvtxs, graph.nedges/2); 
+     printf("Node-Based Ordering... ----------------------------------------------\n"); 
+   }
+   perm = idxmalloc(graph.nvtxs, "main: perm"); 
+   iperm = idxmalloc(graph.nvtxs, "main: iperm"); 
+   METIS_SetDefaultOptions(options);
+   /*options[0] = 0; */
+ 
+   METISTmr -= seconds(); 
+   METIS_NodeND(&graph.nvtxs, graph.xadj, graph.adjncy, &numflag, options, perm, iperm); 
+   METISTmr += seconds(); 
+
+   IOTmr -= seconds(); 
+   WritePermutation(filename, iperm, graph.nvtxs);
+   IOTmr += seconds(); 
+
+   SMBTmr -= seconds(); 
+   ret = ComputeFillInL(&graph, iperm,parent,
+          supnd,&graph.nvtxs,nbsn,nbops,lgind,fctnzs);
+   SMBTmr += seconds(); 
+
+   TOTALTmr += seconds(); 
+   
+   if (*niv > 1 ) {
+     printf("\nTiming Information --------------------------------------------------\n"); 
+     printf("  I/O:                     \t %7.3f\n", IOTmr); 
+     printf("  Ordering:                \t %7.3f   (ONMETIS time)\n", METISTmr); 
+     printf("  Symbolic Factorization:  \t %7.3f\n", SMBTmr); 
+     printf("  Total:                   \t %7.3f\n", TOTALTmr); 
+     printf("**********************************************************************\n"); 
+   }
+
+
+   
+   {int kkk;
+ 
+   for(kkk=0;kkk<graph.nvtxs;kkk++)
+     {invpnd[kkk]= iperm[kkk]; 
+       permnd[ invpnd[kkk] ]= kkk;
+ 
+     } 
+    for(kkk=0;kkk<graph.nvtxs;kkk++)
+      { invpnd[kkk]+=1;
+    permnd[kkk]+=1;
+      }
+   }
+    idxfree(graph.xadj, graph.adjncy, perm, iperm); 
+     
+#else    
+  
+    CALL_UTMESS("F", "FERMETUR_15");
+  
+           
+#endif
+}
