diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/branch/branch.conf 2.x/.bzr/branch/branch.conf
*** galera-23.2.2-src/.bzr/branch/branch.conf	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/branch/branch.conf	2013-03-08 19:49:02.058502045 +0800
***************
*** 0 ****
--- 1 ----
+ parent_location = http://bazaar.launchpad.net/~codership/galera/2.x/
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/branch/format 2.x/.bzr/branch/format
*** galera-23.2.2-src/.bzr/branch/format	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/branch/format	2013-03-08 19:49:01.015164215 +0800
***************
*** 0 ****
--- 1 ----
+ Bazaar Branch Format 7 (needs bzr 1.6)
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/branch/last-revision 2.x/.bzr/branch/last-revision
*** galera-23.2.2-src/.bzr/branch/last-revision	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/branch/last-revision	2013-03-08 19:49:01.018497562 +0800
***************
*** 0 ****
--- 1 ----
+ 143 alexey.yurchenko@codership.com-20130121172355-dcvbiabufnm8e7hw
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/branch/tags 2.x/.bzr/branch/tags
*** galera-23.2.2-src/.bzr/branch/tags	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/branch/tags	2013-03-08 19:49:01.691833798 +0800
***************
*** 0 ****
--- 1 ----
+ d13:release_0.8.059:teemu.ollakka@codership.com-20110612174405-4qfyoif10w6v7fr413:release_0.8.145:ayurchen@void-20110725095805-emqvtv7kio06urqf13:release_0.8.245:ayurchen@void-20110826082404-2di133euvgovrigo14:release_21.1.045:ayurchen@void-20111019141034-jz56awk8mxlk327z14:release_23.2.045:ayurchen@void-20120217151912-1cqdbp3raiu2z75z14:release_23.2.145:ayurchen@void-20120515235026-glzd7f4t9gk9rfph14:release_23.2.262:alexey.yurchenko@codership.com-20121025181707-3g7kgf11ac1xuvlv17:release_23.2.2rc162:alexey.yurchenko@codership.com-20120929070540-hyxbke9gk8nti1mr17:release_23.2.2rc262:alexey.yurchenko@codership.com-20121012180141-hd6jm2o364024xnp14:release_23.2.362:alexey.yurchenko@codership.com-20130121172355-dcvbiabufnm8e7hwe
\ No newline at end of file
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/branch-format 2.x/.bzr/branch-format
*** galera-23.2.2-src/.bzr/branch-format	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/branch-format	2013-03-08 19:46:51.381272138 +0800
***************
*** 0 ****
--- 1 ----
+ Bazaar-NG meta directory, format 1
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/checkout/conflicts 2.x/.bzr/checkout/conflicts
*** galera-23.2.2-src/.bzr/checkout/conflicts	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/checkout/conflicts	2013-03-08 19:49:02.491837246 +0800
***************
*** 0 ****
--- 1 ----
+ BZR conflict list format 1
Binary files galera-23.2.2-src/.bzr/checkout/dirstate and 2.x/.bzr/checkout/dirstate differ
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/checkout/format 2.x/.bzr/checkout/format
*** galera-23.2.2-src/.bzr/checkout/format	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/checkout/format	2013-03-08 19:49:02.058502045 +0800
***************
*** 0 ****
--- 1 ----
+ Bazaar Working Tree Format 6 (bzr 1.14)
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/README 2.x/.bzr/README
*** galera-23.2.2-src/.bzr/README	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/README	2013-03-08 19:46:51.381272138 +0800
***************
*** 0 ****
--- 1,3 ----
+ This is a Bazaar control directory.
+ Do not change any files in this directory.
+ See http://bazaar.canonical.com/ for more information about Bazaar.
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/repository/format 2.x/.bzr/repository/format
*** galera-23.2.2-src/.bzr/repository/format	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/repository/format	2013-03-08 19:46:51.384605486 +0800
***************
*** 0 ****
--- 1 ----
+ Bazaar repository format 2a (needs bzr 1.16 or later)
Binary files galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.cix and 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.cix differ
Binary files galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.iix and 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.iix differ
Binary files galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.rix and 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.rix differ
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.six 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.six
*** galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.six	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.six	2013-03-08 19:49:00.861830221 +0800
***************
*** 0 ****
--- 1,5 ----
+ B+Tree Graph Index 2
+ node_ref_lists=0
+ key_elements=1
+ len=0
+ row_lengths=
Binary files galera-23.2.2-src/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.tix and 2.x/.bzr/repository/indices/61317f6b4d3b3e6f09532e78f2f2ea73.tix differ
Binary files galera-23.2.2-src/.bzr/repository/pack-names and 2.x/.bzr/repository/pack-names differ
Binary files galera-23.2.2-src/.bzr/repository/packs/61317f6b4d3b3e6f09532e78f2f2ea73.pack and 2.x/.bzr/repository/packs/61317f6b4d3b3e6f09532e78f2f2ea73.pack differ
diff -crB --unidirectional-new-file galera-23.2.2-src/.bzrignore 2.x/.bzrignore
*** galera-23.2.2-src/.bzrignore	1970-01-01 08:00:00.000000000 +0800
--- 2.x/.bzrignore	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,78 ----
+ #*#
+ *$
+ *,v
+ *.BAK
+ *.a
+ *.bak
+ *.elc
+ *.exe
+ *.la
+ *.lo
+ *.o
+ *.obj
+ *.orig
+ *.py[oc]
+ *.so
+ *.os
+ *.tmp
+ *.log
+ *.passed
+ *~
+ .#*
+ .*.sw[nop]
+ .*.tmp
+ ./.python-eggs
+ .DS_Store
+ .arch-ids
+ .arch-inventory
+ .bzr.log
+ .del-*
+ .git
+ .hg
+ .jamdeps.libs
+ .make.state
+ .sconsign*
+ .svn
+ .sw[nop]
+ .tmp*
+ BitKeeper
+ CVS
+ CVS.adm
+ RCS
+ SCCS
+ TAGS
+ _darcs
+ aclocal.m4
+ autom4te*
+ config.h
+ config.h.in
+ config.log
+ config.status
+ config.sub
+ stamp-h
+ stamp-h.in
+ stamp-h1
+ scons*
+ .sconf*
+ {arch}
+ galera_check
+ gu_tests
+ gu_tests++
+ check_gcomm
+ gcs_test
+ gcs_tests
+ cluster.conf
+ nodes.conf
+ tests/conf/*.cnf
+ tests/run
+ tests/out
+ tests/bin/*
+ gcache/src/test
+ gcache/tests/gcache_tests
+ Makefile
+ Makefile.in
+ .deps
+ .libs
+ garb/garbd
+ gcs/src/.garb
+ 
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/certification.cpp 2.x/galera/src/certification.cpp
*** galera-23.2.2-src/galera/src/certification.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/certification.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 248,254 ****
              trx_map_.begin()->second->global_seqno() - 1);
      }
  
!     // Scan over write sets
      while (offset < wscoll.size())
      {
          WriteSet ws(trx->version());
--- 248,259 ----
              trx_map_.begin()->second->global_seqno() - 1);
      }
  
! #ifndef NDEBUG
!     // to check that cleanup after cert failure returns cert_index_
!     // to original size
!     size_t prev_cert_index_size(cert_index_.size());
! #endif // NDEBUG
!     /* Scan over write sets */
      while (offset < wscoll.size())
      {
          WriteSet ws(trx->version());
***************
*** 354,359 ****
--- 359,371 ----
                  {
                      // kel was added to cert_index_ by this trx -
                      // remove from cert_index_ and fall through to delete
+                     if (ke->get_key().flags() != kel->get_key().flags())
+                     {
+                         // two copies of keys in key list, shared and exclusive,
+                         // skip the one which was not used to create key entry
+                         assert(key_list.find(ke) != key_list.end());
+                         continue;
+                     }
                      assert(ke->ref_full_trx() == 0);
                      assert(ke->ref_full_shared_trx() == 0);
                      assert(kel == ke);
***************
*** 381,386 ****
--- 393,399 ----
              assert(kel->ref_full_shared_trx() == 0);
              delete kel;
          }
+         assert(cert_index_.size() == prev_cert_index_size);
      }
  
      return TEST_FAILED;
***************
*** 398,409 ****
          return TEST_FAILED;
      }
  
!     if (trx->last_seen_seqno() < initial_position_ ||
!         trx->global_seqno() - trx->last_seen_seqno() > max_length_)
      {
          if (trx->last_seen_seqno() < initial_position_)
          {
!             log_debug << "last seen seqno below limit for trx " << *trx;
          }
  
          if (trx->global_seqno() - trx->last_seen_seqno() > max_length_)
--- 411,422 ----
          return TEST_FAILED;
      }
  
!     if (gu_unlikely(trx->last_seen_seqno() < initial_position_ ||
!                     trx->global_seqno() - trx->last_seen_seqno() > max_length_))
      {
          if (trx->last_seen_seqno() < initial_position_)
          {
!             log_warn << "last seen seqno below limit for trx " << *trx;
          }
  
          if (trx->global_seqno() - trx->last_seen_seqno() > max_length_)
***************
*** 551,556 ****
--- 564,576 ----
                        << " trx seqno " << trx->global_seqno();
          }
  
+         if (gu_unlikely((trx->last_seen_seqno() + 1) < trx_map_.begin()->first))
+         {
+             /* See #733 - for now it is false positive */
+             cert_debug << "WARNING: last_seen_seqno is below certification index: "
+             << trx_map_.begin()->first << " > " << trx->last_seen_seqno();
+         }
+ 
          position_ = trx->global_seqno();
  
          if (gu_unlikely(!(position_ & max_length_check_) &&
***************
*** 570,575 ****
--- 590,596 ----
              }
              else
              {
+                 cert_debug << "purging index up to " << trim_seqno;
                  purge_trxs_upto_(trim_seqno);
              }
          }
***************
*** 627,632 ****
--- 648,654 ----
  void galera::Certification::purge_trxs_upto_(wsrep_seqno_t seqno)
  {
      TrxMap::iterator lower_bound(trx_map_.lower_bound(seqno));
+     cert_debug << "purging index up to " << lower_bound->first;
      for_each(trx_map_.begin(), lower_bound, PurgeAndDiscard(*this));
      trx_map_.erase(trx_map_.begin(), lower_bound);
      if (0 == ((trx_map_.size() + 1) % 10000))
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/galera_service_thd.cpp 2.x/galera/src/galera_service_thd.cpp
*** galera-23.2.2-src/galera/src/galera_service_thd.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/galera_service_thd.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 34,48 ****
          {
              if (data.act_ & A_LAST_COMMITTED)
              {
!                 ssize_t ret;
  
!                 if ((ret = st->gcs_.set_last_applied(data.last_committed_)))
                  {
                      log_warn << "Failed to report last committed "
                               << data.last_committed_ << ", " << ret
                               << " (" << strerror (-ret) << ')';
                      // @todo: figure out what to do in this case
                  }
              }
          }
      }
--- 34,53 ----
          {
              if (data.act_ & A_LAST_COMMITTED)
              {
!                 ssize_t const ret(st->gcs_.set_last_applied(data.last_committed_));
  
!                 if (gu_unlikely(ret < 0))
                  {
                      log_warn << "Failed to report last committed "
                               << data.last_committed_ << ", " << ret
                               << " (" << strerror (-ret) << ')';
                      // @todo: figure out what to do in this case
                  }
+                 else
+                 {
+                     log_debug << "Reported last committed: "
+                               << data.last_committed_;
+                 }
              }
          }
      }
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/gcs.hpp 2.x/galera/src/gcs.hpp
*** galera-23.2.2-src/galera/src/gcs.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/gcs.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 76,82 ****
          ssize_t connect(const std::string& cluster_name,
                          const std::string& cluster_url)
          {
!             return gcs_open(conn_, cluster_name.c_str(), cluster_url.c_str());
          }
  
          ssize_t set_initial_position(const wsrep_uuid_t& uuid,
--- 76,85 ----
          ssize_t connect(const std::string& cluster_name,
                          const std::string& cluster_url)
          {
!             if (cluster_url != "bootstrap")
!                 return gcs_open(conn_,cluster_name.c_str(),cluster_url.c_str());
!             else
!                 return gcs_open(conn_,cluster_name.c_str(),"gcomm://");
          }
  
          ssize_t set_initial_position(const wsrep_uuid_t& uuid,
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/replicator_smm.cpp 2.x/galera/src/replicator_smm.cpp
*** galera-23.2.2-src/galera/src/replicator_smm.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/replicator_smm.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 72,91 ****
      {
          try
          {
- #if 0
              if (trx.is_toi())
              {
!                 log_info << "Executing TO isolated action: " << trx;
              }
- #endif
              gu_trace(apply_wscoll(recv_ctx, apply_cb, trx));
- #if 0
              if (trx.is_toi())
              {
!                 log_info << "Done executing TO isolated action: "
                           << trx.global_seqno();
              }
- #endif
              break;
          }
          catch (galera::ApplyException& e)
--- 72,87 ----
      {
          try
          {
              if (trx.is_toi())
              {
!                 log_debug << "Executing TO isolated action: " << trx;
              }
              gu_trace(apply_wscoll(recv_ctx, apply_cb, trx));
              if (trx.is_toi())
              {
!                 log_debug << "Done executing TO isolated action: "
                           << trx.global_seqno();
              }
              break;
          }
          catch (galera::ApplyException& e)
***************
*** 517,523 ****
          return retval;
      }
  
!     trx->set_last_seen_seqno(co_mode_ != CommitOrder::BYPASS ? commit_monitor_.last_left() : apply_monitor_.last_left());
      trx->flush(0);
      trx->set_state(TrxHandle::S_REPLICATING);
  
--- 513,519 ----
          return retval;
      }
  
!     trx->set_last_seen_seqno(last_committed());
      trx->flush(0);
      trx->set_state(TrxHandle::S_REPLICATING);
  
***************
*** 992,997 ****
--- 988,995 ----
  {
      assert(trx->state() == TrxHandle::S_APPLYING);
  
+     log_debug << "Done executing TO isolated action: " << *trx;
+ 
      CommitOrder co(*trx, co_mode_);
      if (co_mode_ != CommitOrder::BYPASS) commit_monitor_.leave(co);
      ApplyOrder ao(*trx);
***************
*** 1090,1095 ****
--- 1088,1094 ----
      gu_trace(local_monitor_.enter(lo));
      cert_.purge_trxs_upto(seq);
      local_monitor_.leave(lo);
+     log_debug << "Got commit cut from GCS: " << seq;
  }
  
  void galera::ReplicatorSMM::establish_protocol_versions (int proto_ver)
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/replicator_smm.hpp 2.x/galera/src/replicator_smm.hpp
*** galera-23.2.2-src/galera/src/replicator_smm.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/replicator_smm.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 151,160 ****
          static const Defaults defaults;
          // both a list of parameters and a list of default values
  
!         inline void report_last_committed()
          {
              if (gu_unlikely(cert_.index_purge_required()))
!                 service_thd_.report_last_committed(apply_monitor_.last_left());
          }
  
          wsrep_status_t cert(TrxHandle* trx);
--- 151,169 ----
          static const Defaults defaults;
          // both a list of parameters and a list of default values
  
!         wsrep_seqno_t last_committed()
!         {
!             return co_mode_ != CommitOrder::BYPASS ?
!                    commit_monitor_.last_left() : apply_monitor_.last_left();
!         }
! 
!         void report_last_committed()
          {
              if (gu_unlikely(cert_.index_purge_required()))
!             {
!                 wsrep_seqno_t const purge_seqno(cert_.get_safe_to_discard_seqno());
!                 service_thd_.report_last_committed(purge_seqno);
!             }
          }
  
          wsrep_status_t cert(TrxHandle* trx);
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/src/replicator_str.cpp 2.x/galera/src/replicator_str.cpp
*** galera-23.2.2-src/galera/src/replicator_str.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/src/replicator_str.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 289,296 ****
  static bool
  sst_is_trivial (const void* const req, size_t const len)
  {
!     return (len == (strlen(ReplicatorSMM::TRIVIAL_SST) + 1) &&
!             !memcmp (req, ReplicatorSMM::TRIVIAL_SST, len));
  }
  
  void ReplicatorSMM::process_state_req(void*       recv_ctx,
--- 289,298 ----
  static bool
  sst_is_trivial (const void* const req, size_t const len)
  {
!     /* Check that the first string in request == ReplicatorSMM::TRIVIAL_SST */
!     size_t const trivial_len = strlen(ReplicatorSMM::TRIVIAL_SST) + 1;
!     return (len >= trivial_len &&
!             !memcmp (req, ReplicatorSMM::TRIVIAL_SST, trivial_len));
  }
  
  void ReplicatorSMM::process_state_req(void*       recv_ctx,
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/tests/saved_state_check.cpp 2.x/galera/tests/saved_state_check.cpp
*** galera-23.2.2-src/galera/tests/saved_state_check.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/tests/saved_state_check.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 213,219 ****
      tcase_add_test  (tc, test_basic);
      tcase_add_test  (tc, test_unsafe);
      tcase_add_test  (tc, test_corrupt);
!     tcase_set_timeout(tc, 60);
      suite_add_tcase (s, tc);
  
      return s;
--- 213,219 ----
      tcase_add_test  (tc, test_basic);
      tcase_add_test  (tc, test_unsafe);
      tcase_add_test  (tc, test_corrupt);
!     tcase_set_timeout(tc, 120);
      suite_add_tcase (s, tc);
  
      return s;
diff -crB --unidirectional-new-file galera-23.2.2-src/galera/tests/write_set_check.cpp 2.x/galera/tests/write_set_check.cpp
*** galera-23.2.2-src/galera/tests/write_set_check.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galera/tests/write_set_check.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 512,517 ****
--- 512,583 ----
  END_TEST
  
  
+ START_TEST(test_trac_726)
+ {
+     log_info << "test_trac_726";
+     const int version(2);
+     gu::Config conf;
+     galera::Certification cert(conf);
+     wsrep_uuid_t uuid1 = {{1, }};
+     wsrep_uuid_t uuid2 = {{2, }};
+     cert.assign_initial_position(0, version);
+ 
+     mark_point();
+ 
+     wsrep_key_part_t key1 = {void_cast("1"), 1};
+     wsrep_key_part_t key2 = {void_cast("2"), 1};
+ 
+     {
+         TrxHandle* trx(new TrxHandle(version, uuid1, 0, 0, false));
+ 
+         trx->append_key(Key(version, &key1, 1, 0));
+         trx->set_last_seen_seqno(0);
+         trx->flush(0);
+ 
+         // serialize/unserialize to verify that ver1 trx is serializable
+         const galera::MappedBuffer& wc(trx->write_set_collection());
+         gu::Buffer buf(wc.size());
+         std::copy(&wc[0], &wc[0] + wc.size(), &buf[0]);
+         trx->unref();
+         trx = new TrxHandle();
+         size_t offset(unserialize(&buf[0], buf.size(), 0, *trx));
+         trx->append_write_set(&buf[0] + offset, buf.size() - offset);
+ 
+         trx->set_received(0, 1, 1);
+         Certification::TestResult result(cert.append_trx(trx));
+         fail_unless(result == Certification::TEST_OK);
+         cert.set_trx_committed(trx);
+         trx->unref();
+     }
+ 
+     {
+         TrxHandle* trx(new TrxHandle(version, uuid2, 0, 0, false));
+ 
+         trx->append_key(Key(version, &key2, 1, 0));
+         trx->append_key(Key(version, &key2, 1, Key::F_SHARED));
+         trx->append_key(Key(version, &key1, 1, 0));
+ 
+         trx->set_last_seen_seqno(0);
+         trx->flush(0);
+ 
+         // serialize/unserialize to verify that ver1 trx is serializable
+         const galera::MappedBuffer& wc(trx->write_set_collection());
+         gu::Buffer buf(wc.size());
+         std::copy(&wc[0], &wc[0] + wc.size(), &buf[0]);
+         trx->unref();
+         trx = new TrxHandle();
+         size_t offset(unserialize(&buf[0], buf.size(), 0, *trx));
+         trx->append_write_set(&buf[0] + offset, buf.size() - offset);
+ 
+         trx->set_received(0, 2, 2);
+         Certification::TestResult result(cert.append_trx(trx));
+         fail_unless(result == Certification::TEST_FAILED);
+         cert.set_trx_committed(trx);
+         trx->unref();
+     }
+ }
+ END_TEST
+ 
  Suite* write_set_suite()
  {
      Suite* s = suite_create("write_set");
***************
*** 545,550 ****
--- 611,619 ----
      tcase_add_test(tc, test_cert_hierarchical_v2);
      suite_add_tcase(s, tc);
  
+     tc = tcase_create("test_trac_726");
+     tcase_add_test(tc, test_trac_726);
+     suite_add_tcase(s, tc);
  
      return s;
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/src/gu_backtrace.c 2.x/galerautils/src/gu_backtrace.c
*** galera-23.2.2-src/galerautils/src/gu_backtrace.c	1970-01-01 08:00:00.000000000 +0800
--- 2.x/galerautils/src/gu_backtrace.c	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,31 ----
+ // Copyright (C) 2012 Codership Oy <info@codership.com>
+ 
+ #include "gu_backtrace.h"
+ #include "gu_log.h"
+ 
+ #ifdef __GNUC__
+ #include <execinfo.h>
+ #include <stdlib.h>
+ 
+ char** gu_backtrace(int* size)
+ {
+     char** strings;
+     void** array = malloc(*size * sizeof(void*));
+     if (!array)
+     {
+         gu_error("could not allocate memory for %d pointers\n", *size);
+         return NULL;
+     }
+     *size = backtrace(array, *size);
+     strings = backtrace_symbols(array, *size);
+ 
+     free(array);
+     return strings;
+ }
+ #else
+ char **gu_backtrace(int* size)
+ {
+     return NULL;
+ }
+ #endif /* */
+ 
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/src/gu_backtrace.h 2.x/galerautils/src/gu_backtrace.h
*** galera-23.2.2-src/galerautils/src/gu_backtrace.h	1970-01-01 08:00:00.000000000 +0800
--- 2.x/galerautils/src/gu_backtrace.h	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,28 ----
+ // Copyright (C) 2012 Codership Oy <info@codership.com>
+ 
+ #ifndef GU_BACKTRACE_H
+ #define GU_BACKTRACE_H
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif /* __cplusplus */
+ 
+ /*!
+  * Get current backtrace. Return buffer will contain backtrace symbols if
+  * available. NULL pointer is returned if getting backtrace is not supported
+  * on current platform. Maximum number of frames in backtrace is passed
+  * in size parameter, number of frames in returned backtrace is assigned
+  * in size parameter on return.
+  *
+  * @param size Pointer to integer containing maximum number of frames
+  *             in backtrace
+  *
+  * @return Allocated array of strings containing backtrace symbols
+  */
+ char** gu_backtrace(int* size);
+ 
+ #ifdef __cplusplus
+ }
+ #endif /* __cplusplus */
+ 
+ #endif /* GU_BACKTRACE_H */
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/src/gu_backtrace.hpp 2.x/galerautils/src/gu_backtrace.hpp
*** galera-23.2.2-src/galerautils/src/gu_backtrace.hpp	1970-01-01 08:00:00.000000000 +0800
--- 2.x/galerautils/src/gu_backtrace.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,65 ----
+ // Copyright (C) 2012 Codership Oy <info@codership.com>
+ 
+ #ifndef GU_BACKTRACE_HPP
+ #define GU_BACKTRACE_HPP
+ 
+ #include "gu_backtrace.h"
+ 
+ #include <cstdlib>
+ #include <ostream>
+ 
+ namespace gu
+ {
+     /*!
+      * Utility class to print backtraces.
+      */
+     class Backtrace
+     {
+     public:
+         /*!
+          * Construct backtrace object.
+          *
+          * @param Maximum number of backtrace symbols resolved (default 50).
+          */
+         Backtrace(int size = 50)
+             :
+             symbols_size_(size),
+             symbols_(gu_backtrace(&symbols_size_))
+         { }
+ 
+         ~Backtrace()
+         {
+             free(symbols_);
+         }
+ 
+         /*!
+          * Print backtrace into ostream.
+          *
+          * @param os    Ostream to print backtrace into.
+          * @param delim Delimiter separating backtrace symbols.
+          */
+         void print(std::ostream& os, char delim = '\n')
+         {
+             if (symbols_ != 0)
+             {
+                 for (int i(0); i < symbols_size_; ++i)
+                 {
+                     os << symbols_[i] << delim;
+                 }
+             }
+             else
+             {
+                 os << "no backtrace available";
+             }
+         }
+ 
+     private:
+         Backtrace(const Backtrace&);
+         void operator=(const Backtrace&);
+         int symbols_size_;
+         char** symbols_;
+     };
+ }
+ 
+ 
+ #endif // GU_BACKTRACE_HPP
Only in galera-23.2.2-src/galerautils/src: gu_datagram.hpp
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/src/SConscript 2.x/galerautils/src/SConscript
*** galera-23.2.2-src/galerautils/src/SConscript	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galerautils/src/SConscript	2013-03-08 19:49:02.370351000 +0800
***************
*** 16,22 ****
      'gu_print_buf.c',
      'gu_to.c',
      'gu_utils.c',
!     'gu_uuid.c'
  ]
  
  libgalerautils_env.StaticLibrary('galerautils', libgalerautils_sources)
--- 16,23 ----
      'gu_print_buf.c',
      'gu_to.c',
      'gu_utils.c',
!     'gu_uuid.c',
!     'gu_backtrace.c'
  ]
  
  libgalerautils_env.StaticLibrary('galerautils', libgalerautils_sources)
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/tests/gu_dbug_test.c 2.x/galerautils/tests/gu_dbug_test.c
*** galera-23.2.2-src/galerautils/tests/gu_dbug_test.c	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galerautils/tests/gu_dbug_test.c	2013-03-08 19:49:02.370351000 +0800
***************
*** 1,6 ****
  // Copyright (C) 2008 Codership Oy <info@codership.com>
  
! // $Id: gu_dbug_test.c 2745 2012-03-17 00:00:23Z alex $
  
  /* Pthread yield */
  #define _GNU_SOURCE 1
--- 1,6 ----
  // Copyright (C) 2008 Codership Oy <info@codership.com>
  
! // $Id: gu_dbug_test.c 2919 2012-12-26 23:20:00Z alex $
  
  /* Pthread yield */
  #define _GNU_SOURCE 1
***************
*** 41,49 ****
  
  static void *dbg_thr(void *arg)
  {
!     while (time(NULL) < stop) {
! 	af();
!     }
      pthread_exit(NULL);
  }
  
--- 41,47 ----
  
  static void *dbg_thr(void *arg)
  {
!     while (time(NULL) < stop) { af(); }
      pthread_exit(NULL);
  }
  
***************
*** 55,61 ****
  
      /* Log > /dev/null */
      GU_DBUG_FILE = fopen("/dev/null", "a+");
!     
      /* These should not produce output yet */
      af();
      af();
--- 53,59 ----
  
      /* Log > /dev/null */
      GU_DBUG_FILE = fopen("/dev/null", "a+");
! 
      /* These should not produce output yet */
      af();
      af();
***************
*** 73,82 ****
      /* Run few threads concurrently */
      stop = time(NULL) + 2;
      for (i = 0; i < N_THREADS; i++)
! 	pthread_create(&th[i], NULL, &dbg_thr, NULL);
      for (i = 0; i < N_THREADS; i++)
! 	pthread_join(th[i], NULL);
!     
  }
  END_TEST
  
--- 69,77 ----
      /* Run few threads concurrently */
      stop = time(NULL) + 2;
      for (i = 0; i < N_THREADS; i++)
!         pthread_create(&th[i], NULL, &dbg_thr, NULL);
      for (i = 0; i < N_THREADS; i++)
!         pthread_join(th[i], NULL);
  }
  END_TEST
  
***************
*** 87,91 ****
--- 82,87 ----
  
    suite_add_tcase (s, tc);
    tcase_add_test  (tc, gu_dbug_test);
+   tcase_set_timeout(tc, 60);
    return s;
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/galerautils/tests/gu_net_test.cpp 2.x/galerautils/tests/gu_net_test.cpp
*** galera-23.2.2-src/galerautils/tests/gu_net_test.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/galerautils/tests/gu_net_test.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 12,18 ****
  
  #include "gu_logger.hpp"
  #include "gu_uri.hpp"
- #include "gu_datagram.hpp"
  #include "gu_resolver.hpp"
  #include "gu_lock.hpp"
  #include "gu_prodcons.hpp"
--- 12,17 ----
***************
*** 28,131 ****
  using namespace gu::net;
  using namespace gu::prodcons;
  
- 
- START_TEST(test_datagram)
- {
- 
-     // Header check
-     NetHeader hdr(42, 0);
-     fail_unless(hdr.len() == 42);
-     fail_unless(hdr.has_crc32() == false);
-     fail_unless(hdr.version() == 0);
- 
-     hdr.set_crc32(1234);
-     fail_unless(hdr.has_crc32() == true);
-     fail_unless(hdr.len() == 42);
- 
-     NetHeader hdr1(42, 1);
-     fail_unless(hdr1.len() == 42);
-     fail_unless(hdr1.has_crc32() == false);
-     fail_unless(hdr1.version() == 1);
- 
-     byte_t hdrbuf[NetHeader::serial_size_];
-     fail_unless(serialize(hdr1, hdrbuf, sizeof(hdrbuf), 0) ==
-                 NetHeader::serial_size_);
-     try
-     {
-         unserialize(hdrbuf, sizeof(hdrbuf), 0, hdr);
-         fail("");
-     }
-     catch (Exception& e)
-     {
-         // ok
-     }
- 
- 
-     byte_t b[128];
-     for (byte_t i = 0; i < sizeof(b); ++i)
-     {
-         b[i] = i;
-     }
-     Buffer buf(b, b + sizeof(b));
- 
-     Datagram dg(buf);
-     fail_unless(dg.get_len() == sizeof(b));
- 
-     // Normal copy construction
-     Datagram dgcopy(buf);
-     fail_unless(dgcopy.get_len() == sizeof(b));
-     fail_unless(memcmp(dgcopy.get_header() + dgcopy.get_header_offset(),
-                        dg.get_header() + dg.get_header_offset(),
-                        dg.get_header_len()) == 0);
-     fail_unless(dgcopy.get_payload() == dg.get_payload());
- 
-     // Copy construction from offset of 16
-     Datagram dg16(dg, 16);
-     log_info << dg16.get_len();
-     fail_unless(dg16.get_len() - dg16.get_offset() == sizeof(b) - 16);
-     for (byte_t i = 0; i < sizeof(b) - 16; ++i)
-     {
-         fail_unless(dg16.get_payload()[i + dg16.get_offset()] == i + 16);
-     }
- 
- #if 0
-     // Normalize datagram, all data is moved into payload, data from
-     // beginning to offset is discarded. Normalization must not change
-     // dg
-     dg16.normalize();
- 
-     fail_unless(dg16.get_len() == sizeof(b) - 16);
-     for (byte_t i = 0; i < sizeof(b) - 16; ++i)
-     {
-         fail_unless(dg16.get_payload()[i] == i + 16);
-     }
- 
-     fail_unless(dg.get_len() == sizeof(b));
-     for (byte_t i = 0; i < sizeof(b); ++i)
-     {
-         fail_unless(dg.get_payload()[i] == i);
-     }
- 
-     Datagram dgoff(buf, 16);
-     dgoff.get_header().resize(8);
-     dgoff.set_header_offset(4);
-     fail_unless(dgoff.get_len() == buf.size() + 4);
-     fail_unless(dgoff.get_header_offset() == 4);
-     fail_unless(dgoff.get_header().size() == 8);
-     for (byte_t i = 0; i < 4; ++i)
-     {
-         *(&dgoff.get_header()[0] + i) = i;
-     }
- 
-     dgoff.normalize();
- 
-     fail_unless(dgoff.get_len() == sizeof(b) - 16 + 4);
-     fail_unless(dgoff.get_header_offset() == 0);
-     fail_unless(dgoff.get_header().size() == 0);
- #endif // 0
- }
- END_TEST
- 
  START_TEST(test_resolver)
  {
      std::string tcp_lh4("tcp://127.0.0.1:2002");
--- 27,32 ----
***************
*** 176,185 ****
      Suite* s = suite_create("galerautils++ Networking");
      TCase* tc;
  
-     tc = tcase_create("test_datagram");
-     tcase_add_test(tc, test_datagram);
-     suite_add_tcase(s, tc);
- 
      tc = tcase_create("test_resolver");
      tcase_add_test(tc, test_resolver);
      suite_add_tcase(s, tc);
--- 77,82 ----
diff -crB --unidirectional-new-file galera-23.2.2-src/garb/garb_gcs.cpp 2.x/garb/garb_gcs.cpp
*** galera-23.2.2-src/garb/garb_gcs.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/garb/garb_gcs.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 75,82 ****
      /* Need to substitute the first ':' for \0 */
  
      ssize_t req_len = request.length() + 1 /* \0 */;
!     char* const req_str(
! 	reinterpret_cast<char*>(::malloc(req_len + 1 /* potentially need one more \0 */)));
  
      if (!req_str)
      {
--- 75,82 ----
      /* Need to substitute the first ':' for \0 */
  
      ssize_t req_len = request.length() + 1 /* \0 */;
!     char* const req_str(reinterpret_cast<char*>(::malloc(
!                         req_len + 1 /* potentially need one more \0 */)));
  
      if (!req_str)
      {
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_addr.hpp 2.x/gcomm/src/asio_addr.hpp
*** galera-23.2.2-src/gcomm/src/asio_addr.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_addr.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 12,55 ****
  #include <string>
  #include <algorithm>
  
! static inline std::string escape_addr(const asio::ip::address& addr)
  {
!     if (addr.is_v4())
      {
!         return addr.to_v4().to_string();
      }
!     else
      {
!         return "[" + addr.to_v6().to_string() + "]";
      }
- }
- 
- static inline std::string unescape_addr(const std::string& addr)
- {
-     std::string ret(addr);
-     size_t pos(ret.find('['));
-     if (pos != std::string::npos) ret.erase(pos, 1);
-     pos = ret.find(']');
-     if (pos != std::string::npos) ret.erase(pos, 1);
-     return ret;
- }
  
  
! static inline std::string anyaddr(const asio::ip::address& addr)
! {
!     if (addr.is_v4() == true)
!     {
!         return addr.to_v4().any().to_string();
!     }
!     else
      {
!         return addr.to_v6().any().to_string();
      }
-     gu_throw_fatal;
-     throw;
  }
  
- 
  template <class S>
  void set_fd_options(S& socket)
  {
--- 12,57 ----
  #include <string>
  #include <algorithm>
  
! namespace gcomm
  {
!     static inline std::string escape_addr(const asio::ip::address& addr)
      {
!         if (addr.is_v4())
!         {
!             return addr.to_v4().to_string();
!         }
!         else
!         {
!             return "[" + addr.to_v6().to_string() + "]";
!         }
      }
! 
!     static inline std::string unescape_addr(const std::string& addr)
      {
!         std::string ret(addr);
!         size_t pos(ret.find('['));
!         if (pos != std::string::npos) ret.erase(pos, 1);
!         pos = ret.find(']');
!         if (pos != std::string::npos) ret.erase(pos, 1);
!         return ret;
      }
  
  
!     static inline std::string anyaddr(const asio::ip::address& addr)
      {
!         if (addr.is_v4() == true)
!         {
!             return addr.to_v4().any().to_string();
!         }
!         else
!         {
!             return addr.to_v6().any().to_string();
!         }
!         gu_throw_fatal;
!         throw;
      }
  }
  
  template <class S>
  void set_fd_options(S& socket)
  {
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_protonet.cpp 2.x/gcomm/src/asio_protonet.cpp
*** galera-23.2.2-src/gcomm/src/asio_protonet.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_protonet.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 21,32 ****
  
  #include <fstream>
  
- using namespace std;
- using namespace std::rel_ops;
- using namespace gu;
- using namespace gu::datetime;
- 
- 
  #ifdef HAVE_ASIO_SSL_HPP
  
  namespace
--- 21,26 ----
***************
*** 75,81 ****
  std::string gcomm::AsioProtonet::get_ssl_password() const
  {
      std::string   file(get_file(conf_, Conf::SocketSslPasswordFile));
!     std::ifstream ifs(file.c_str(), ios_base::in);
      if (ifs.good() == false)
      {
          gu_throw_error(errno) << "could not open password file '" << file
--- 69,75 ----
  std::string gcomm::AsioProtonet::get_ssl_password() const
  {
      std::string   file(get_file(conf_, Conf::SocketSslPasswordFile));
!     std::ifstream ifs(file.c_str(), std::ios_base::in);
      if (ifs.good() == false)
      {
          gu_throw_error(errno) << "could not open password file '" << file
***************
*** 94,100 ****
      :
      gcomm::Protonet(conf, "asio", version),
      mutex_(),
!     poll_until_(Date::max()),
      io_service_(),
      timer_(io_service_),
  #ifdef HAVE_ASIO_SSL_HPP
--- 88,94 ----
      :
      gcomm::Protonet(conf, "asio", version),
      mutex_(),
!     poll_until_(gu::datetime::Date::max()),
      io_service_(),
      timer_(io_service_),
  #ifdef HAVE_ASIO_SSL_HPP
***************
*** 198,204 ****
      mutex_.unlock();
  }
  
! gcomm::SocketPtr gcomm::AsioProtonet::socket(const URI& uri)
  {
      if (uri.get_scheme() == "tcp" || uri.get_scheme() == "ssl")
      {
--- 192,198 ----
      mutex_.unlock();
  }
  
! gcomm::SocketPtr gcomm::AsioProtonet::socket(const gu::URI& uri)
  {
      if (uri.get_scheme() == "tcp" || uri.get_scheme() == "ssl")
      {
***************
*** 215,244 ****
      }
  }
  
! gcomm::Acceptor* gcomm::AsioProtonet::acceptor(const URI& uri)
  {
      return new AsioTcpAcceptor(*this, uri);
  }
  
  
  
! Period handle_timers_helper(gcomm::Protonet& pnet, const Period& period)
  {
!     const Date now(Date::now());
!     const Date stop(now + period);
  
!     const Date next_time(pnet.handle_timers());
!     const Period sleep_p(min(stop - now, next_time - now));
      return (sleep_p < 0 ? 0 : sleep_p);
  }
  
  
! void gcomm::AsioProtonet::event_loop(const Period& period)
  {
      io_service_.reset();
!     poll_until_ = Date::now() + period;
  
!     const Period p(handle_timers_helper(*this, period));
      timer_.expires_from_now(boost::posix_time::nanosec(p.get_nsecs()));
      timer_.async_wait(boost::bind(&AsioProtonet::handle_wait, this,
                                    asio::placeholders::error));
--- 209,239 ----
      }
  }
  
! gcomm::Acceptor* gcomm::AsioProtonet::acceptor(const gu::URI& uri)
  {
      return new AsioTcpAcceptor(*this, uri);
  }
  
  
  
! gu::datetime::Period handle_timers_helper(gcomm::Protonet&            pnet,
!                                           const gu::datetime::Period& period)
  {
!     const gu::datetime::Date now(gu::datetime::Date::now());
!     const gu::datetime::Date stop(now + period);
  
!     const gu::datetime::Date next_time(pnet.handle_timers());
!     const gu::datetime::Period sleep_p(std::min(stop - now, next_time - now));
      return (sleep_p < 0 ? 0 : sleep_p);
  }
  
  
! void gcomm::AsioProtonet::event_loop(const gu::datetime::Period& period)
  {
      io_service_.reset();
!     poll_until_ = gu::datetime::Date::now() + period;
  
!     const gu::datetime::Period p(handle_timers_helper(*this, period));
      timer_.expires_from_now(boost::posix_time::nanosec(p.get_nsecs()));
      timer_.async_wait(boost::bind(&AsioProtonet::handle_wait, this,
                                    asio::placeholders::error));
***************
*** 250,256 ****
                                     const Datagram& dg,
                                     const ProtoUpMeta& um)
  {
!     for (deque<Protostack*>::iterator i = protos_.begin();
           i != protos_.end(); ++i)
      {
          (*i)->dispatch(id, dg, um);
--- 245,251 ----
                                     const Datagram& dg,
                                     const ProtoUpMeta& um)
  {
!     for (std::deque<Protostack*>::iterator i = protos_.begin();
           i != protos_.end(); ++i)
      {
          (*i)->dispatch(id, dg, um);
***************
*** 266,273 ****
  
  void gcomm::AsioProtonet::handle_wait(const asio::error_code& ec)
  {
!     Date now(Date::now());
!     const Period p(handle_timers_helper(*this, poll_until_ - now));
      if (ec == asio::error_code() && poll_until_ >= now)
      {
          timer_.expires_from_now(boost::posix_time::nanosec(p.get_nsecs()));
--- 261,269 ----
  
  void gcomm::AsioProtonet::handle_wait(const asio::error_code& ec)
  {
!     gu::datetime::Date now(gu::datetime::Date::now());
!     const gu::datetime::Period p(handle_timers_helper(*this, poll_until_ - now));
!     using std::rel_ops::operator>=;
      if (ec == asio::error_code() && poll_until_ >= now)
      {
          timer_.expires_from_now(boost::posix_time::nanosec(p.get_nsecs()));
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_protonet.hpp 2.x/gcomm/src/asio_protonet.hpp
*** galera-23.2.2-src/gcomm/src/asio_protonet.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_protonet.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 35,48 ****
      ~AsioProtonet();
      void event_loop(const gu::datetime::Period& p);
      void dispatch(const SocketId&,
!                   const gu::Datagram&,
                    const ProtoUpMeta&);
      void interrupt();
      SocketPtr socket(const gu::URI&);
      gcomm::Acceptor* acceptor(const gu::URI&);
      void enter();
      void leave();
!     size_t get_mtu() const { return mtu_; }
  
  #ifdef HAVE_ASIO_SSL_HPP
      std::string get_ssl_password() const;
--- 35,48 ----
      ~AsioProtonet();
      void event_loop(const gu::datetime::Period& p);
      void dispatch(const SocketId&,
!                   const Datagram&,
                    const ProtoUpMeta&);
      void interrupt();
      SocketPtr socket(const gu::URI&);
      gcomm::Acceptor* acceptor(const gu::URI&);
      void enter();
      void leave();
!     size_t mtu() const { return mtu_; }
  
  #ifdef HAVE_ASIO_SSL_HPP
      std::string get_ssl_password() const;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_tcp.cpp 2.x/gcomm/src/asio_tcp.cpp
*** galera-23.2.2-src/gcomm/src/asio_tcp.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_tcp.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 7,18 ****
  #include "gcomm/util.hpp"
  #include "gcomm/common.hpp"
  
- using namespace std;
- using namespace gu;
  
  #define FAILED_HANDLER(_e) failed_handler(_e, __FUNCTION__, __LINE__)
  
! gcomm::AsioTcpSocket::AsioTcpSocket(AsioProtonet& net, const URI& uri)
      :
      Socket       (uri),
      net_         (net),
--- 7,16 ----
  #include "gcomm/util.hpp"
  #include "gcomm/common.hpp"
  
  
  #define FAILED_HANDLER(_e) failed_handler(_e, __FUNCTION__, __LINE__)
  
! gcomm::AsioTcpSocket::AsioTcpSocket(AsioProtonet& net, const gu::URI& uri)
      :
      Socket       (uri),
      net_         (net),
***************
*** 21,36 ****
      ssl_socket_  (0),
  #endif /* HAVE_ASIO_SSL_HPP */
      send_q_      (),
!     recv_buf_    (net_.get_mtu() + NetHeader::serial_size_),
      recv_offset_ (0),
!     state_       (S_CLOSED)
  {
!     log_debug << "ctor for " << get_id();
  }
  
  gcomm::AsioTcpSocket::~AsioTcpSocket()
  {
!     log_debug << "dtor for " << get_id();
      close_socket();
  #ifdef HAVE_ASIO_SSL_HPP
      delete ssl_socket_;
--- 19,36 ----
      ssl_socket_  (0),
  #endif /* HAVE_ASIO_SSL_HPP */
      send_q_      (),
!     recv_buf_    (net_.mtu() + NetHeader::serial_size_),
      recv_offset_ (0),
!     state_       (S_CLOSED),
!     local_addr_  (),
!     remote_addr_ ()
  {
!     log_debug << "ctor for " << id();
  }
  
  gcomm::AsioTcpSocket::~AsioTcpSocket()
  {
!     log_debug << "dtor for " << id();
      close_socket();
  #ifdef HAVE_ASIO_SSL_HPP
      delete ssl_socket_;
***************
*** 43,68 ****
                                            int line)
  {
      log_debug << "failed handler from " << func << ":" << line
!               << " socket " << get_id() << " " << socket_.native()
                << " error " << ec
!               << " " << socket_.is_open() << " state " << get_state();
  
      try
      {
!         log_debug << "local endpoint " << get_local_addr()
!                   << " remote endpoint " << get_remote_addr();
      } catch (...) { }
  
!     const State prev_state(get_state());
  
!     if (get_state() != S_CLOSED)
      {
          state_ = S_FAILED;
      }
  
      if (prev_state != S_FAILED && prev_state != S_CLOSED)
      {
!         net_.dispatch(get_id(), Datagram(), ProtoUpMeta(ec.value()));
      }
  }
  
--- 43,68 ----
                                            int line)
  {
      log_debug << "failed handler from " << func << ":" << line
!               << " socket " << id() << " " << socket_.native()
                << " error " << ec
!               << " " << socket_.is_open() << " state " << state();
  
      try
      {
!         log_debug << "local endpoint " << local_addr()
!                   << " remote endpoint " << remote_addr();
      } catch (...) { }
  
!     const State prev_state(state());
  
!     if (state() != S_CLOSED)
      {
          state_ = S_FAILED;
      }
  
      if (prev_state != S_FAILED && prev_state != S_CLOSED)
      {
!         net_.dispatch(id(), Datagram(), ProtoUpMeta(ec.value()));
      }
  }
  
***************
*** 79,86 ****
--- 79,102 ----
      {
          return SSL_COMP_get_name(SSL_get_current_compression(ssl));
      }
+ 
+ 
+     static std::string extra_error_info(const asio::error_code& ec)
+     {
+         std::ostringstream os;
+         if (ec.category() == asio::error::get_ssl_category())
+         {
+             char errstr[120] = {0, };
+             ERR_error_string_n(ec.value(), errstr, sizeof(errstr));
+             os << ec.value() << ": '" << errstr << "'";
+         }
+         return os.str();
+     }
+ 
  }
  
+ 
+ 
  void gcomm::AsioTcpSocket::handshake_handler(const asio::error_code& ec)
  {
      if (ec)
***************
*** 86,93 ****
      if (ec)
      {
          log_error << "handshake with remote endpoint "
!                   << get_remote_addr() << " failed: " << ec.message()
!                   << " (" << ec << ")"; ;
          FAILED_HANDLER(ec);
          return;
      }
--- 102,109 ----
      if (ec)
      {
          log_error << "handshake with remote endpoint "
!                   << remote_addr() << " failed: " << ec << ": '" << ec.message()
!                   << "' ( " << extra_error_info(ec) << ")";
          FAILED_HANDLER(ec);
          return;
      }
***************
*** 95,114 ****
      if (ssl_socket_ == 0)
      {
          log_error << "handshake handler called for non-SSL socket "
!                   << get_id() << " "
!                   << get_remote_addr() << " <-> "
!                   << get_local_addr();
          FAILED_HANDLER(asio::error_code(EPROTO, asio::error::system_category));
          return;
      }
  
      log_info << "SSL handshake successful, "
!              << "remote endpoint " << get_remote_addr()
!              << " local endpoint " << get_local_addr()
               << " cipher: " << get_cipher(ssl_socket_->impl()->ssl)
               << " compression: " << get_compression(ssl_socket_->impl()->ssl);
      state_ = S_CONNECTED;
!     net_.dispatch(get_id(), Datagram(), ProtoUpMeta(ec.value()));
      async_receive();
  }
  #endif /* HAVE_ASIO_SSL_HPP */
--- 111,130 ----
      if (ssl_socket_ == 0)
      {
          log_error << "handshake handler called for non-SSL socket "
!                   << id() << " "
!                   << remote_addr() << " <-> "
!                   << local_addr();
          FAILED_HANDLER(asio::error_code(EPROTO, asio::error::system_category));
          return;
      }
  
      log_info << "SSL handshake successful, "
!              << "remote endpoint " << remote_addr()
!              << " local endpoint " << local_addr()
               << " cipher: " << get_cipher(ssl_socket_->impl()->ssl)
               << " compression: " << get_compression(ssl_socket_->impl()->ssl);
      state_ = S_CONNECTED;
!     net_.dispatch(id(), Datagram(), ProtoUpMeta(ec.value()));
      async_receive();
  }
  #endif /* HAVE_ASIO_SSL_HPP */
***************
*** 117,123 ****
  {
      Critical<AsioProtonet> crit(net_);
  
!     log_debug << "connect handler " << get_id() << " " << ec;
  
      if (ec)
      {
--- 133,139 ----
  {
      Critical<AsioProtonet> crit(net_);
  
!     log_debug << "connect handler " << id() << " " << ec;
  
      if (ec)
      {
***************
*** 126,140 ****
      }
      else
      {
  #ifdef HAVE_ASIO_SSL_HPP
          if (ssl_socket_ != 0)
          {
              ssl_socket_->lowest_layer().set_option(
                  asio::ip::tcp::no_delay(true));
              set_fd_options(ssl_socket_->lowest_layer());
!             log_debug << "socket " << get_id() << " connected, remote endpoint "
!                       << get_remote_addr() << " local endpoint "
!                       << get_local_addr();
              try
              {
                  ssl_socket_->async_handshake(
--- 142,158 ----
      }
      else
      {
+         assign_local_addr();
+         assign_remote_addr();
  #ifdef HAVE_ASIO_SSL_HPP
          if (ssl_socket_ != 0)
          {
              ssl_socket_->lowest_layer().set_option(
                  asio::ip::tcp::no_delay(true));
              set_fd_options(ssl_socket_->lowest_layer());
!             log_debug << "socket " << id() << " connected, remote endpoint "
!                       << remote_addr() << " local endpoint "
!                       << local_addr();
              try
              {
                  ssl_socket_->async_handshake(
***************
*** 155,165 ****
  #endif /* HAVE_ASIO_SSL_HPP */
              socket_.set_option(asio::ip::tcp::no_delay(true));
              set_fd_options(socket_);
!             log_debug << "socket " << get_id() << " connected, remote endpoint "
!                       << get_remote_addr() << " local endpoint "
!                       << get_local_addr();
              state_ = S_CONNECTED;
!             net_.dispatch(get_id(), Datagram(), ProtoUpMeta(ec.value()));
              async_receive();
  
  #ifdef HAVE_ASIO_SSL_HPP
--- 173,183 ----
  #endif /* HAVE_ASIO_SSL_HPP */
              socket_.set_option(asio::ip::tcp::no_delay(true));
              set_fd_options(socket_);
!             log_debug << "socket " << id() << " connected, remote endpoint "
!                       << remote_addr() << " local endpoint "
!                       << local_addr();
              state_ = S_CONNECTED;
!             net_.dispatch(id(), Datagram(), ProtoUpMeta(ec.value()));
              async_receive();
  
  #ifdef HAVE_ASIO_SSL_HPP
***************
*** 168,174 ****
      }
  }
  
! void gcomm::AsioTcpSocket::connect(const URI& uri)
  {
      try
      {
--- 186,192 ----
      }
  }
  
! void gcomm::AsioTcpSocket::connect(const gu::URI& uri)
  {
      try
      {
***************
*** 220,231 ****
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (get_state() == S_CLOSED || get_state() == S_CLOSING) return;
  
!     log_debug << "closing " << get_id() << " state " << get_state()
                << " send_q size " << send_q_.size();
  
!     if (send_q_.empty() == true || get_state() != S_CONNECTED)
      {
          close_socket();
          state_ = S_CLOSED;
--- 239,250 ----
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (state() == S_CLOSED || state() == S_CLOSING) return;
  
!     log_debug << "closing " << id() << " state " << state()
                << " send_q size " << send_q_.size();
  
!     if (send_q_.empty() == true || state() != S_CONNECTED)
      {
          close_socket();
          state_ = S_CLOSED;
***************
*** 242,264 ****
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (get_state() != S_CONNECTED && get_state() != S_CLOSING)
      {
!         log_debug << "write handler for " << get_id()
!                   << " state " << get_state();
          return;
      }
  
      if (!ec)
      {
          gcomm_assert(send_q_.empty() == false);
!         gcomm_assert(send_q_.front().get_len() >= bytes_transferred);
  
          while (send_q_.empty() == false &&
!                bytes_transferred >= send_q_.front().get_len())
          {
              const Datagram& dg(send_q_.front());
!             bytes_transferred -= dg.get_len();
              send_q_.pop_front();
          }
          gcomm_assert(bytes_transferred == 0);
--- 261,288 ----
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (state() != S_CONNECTED && state() != S_CLOSING)
      {
!         log_debug << "write handler for " << id()
!                   << " state " << state();
!         if (ec.category() == asio::error::get_ssl_category())
!         {
!             log_warn << "write_handler(): " << ec.message()
!                      << " (" << extra_error_info(ec) << ")";
!         }
          return;
      }
  
      if (!ec)
      {
          gcomm_assert(send_q_.empty() == false);
!         gcomm_assert(send_q_.front().len() >= bytes_transferred);
  
          while (send_q_.empty() == false &&
!                bytes_transferred >= send_q_.front().len())
          {
              const Datagram& dg(send_q_.front());
!             bytes_transferred -= dg.len();
              send_q_.pop_front();
          }
          gcomm_assert(bytes_transferred == 0);
***************
*** 267,289 ****
          {
              const Datagram& dg(send_q_.front());
              boost::array<asio::const_buffer, 2> cbs;
!             cbs[0] = asio::const_buffer(dg.get_header()
!                                         + dg.get_header_offset(),
!                                         dg.get_header_len());
!             cbs[1] = asio::const_buffer(&dg.get_payload()[0],
!                                         dg.get_payload().size());
              write_one(cbs);
          }
          else if (state_ == S_CLOSING)
          {
!             log_debug << "deferred close of " << get_id();
              close_socket();
              state_ = S_CLOSED;
          }
      }
      else if (state_ == S_CLOSING)
      {
!         log_debug << "deferred close of " << get_id() << " error " << ec;
          close_socket();
          state_ = S_CLOSED;
      }
--- 291,313 ----
          {
              const Datagram& dg(send_q_.front());
              boost::array<asio::const_buffer, 2> cbs;
!             cbs[0] = asio::const_buffer(dg.header()
!                                         + dg.header_offset(),
!                                         dg.header_len());
!             cbs[1] = asio::const_buffer(&dg.payload()[0],
!                                         dg.payload().size());
              write_one(cbs);
          }
          else if (state_ == S_CLOSING)
          {
!             log_debug << "deferred close of " << id();
              close_socket();
              state_ = S_CLOSED;
          }
      }
      else if (state_ == S_CLOSING)
      {
!         log_debug << "deferred close of " << id() << " error " << ec;
          close_socket();
          state_ = S_CLOSED;
      }
***************
*** 298,311 ****
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (get_state() != S_CONNECTED)
      {
          return ENOTCONN;
      }
  
  
  
!     NetHeader hdr(static_cast<uint32_t>(dg.get_len()), net_.version_);
      if (net_.checksum_ == true)
      {
          hdr.set_crc32(crc32(dg));
--- 322,335 ----
  {
      Critical<AsioProtonet> crit(net_);
  
!     if (state() != S_CONNECTED)
      {
          return ENOTCONN;
      }
  
  
  
!     NetHeader hdr(static_cast<uint32_t>(dg.len()), net_.version_);
      if (net_.checksum_ == true)
      {
          hdr.set_crc32(crc32(dg));
***************
*** 314,334 ****
      send_q_.push_back(dg); // makes copy of dg
      Datagram& priv_dg(send_q_.back());
  
!     priv_dg.set_header_offset(priv_dg.get_header_offset() -
                                NetHeader::serial_size_);
      serialize(hdr,
!               priv_dg.get_header(),
!               priv_dg.get_header_size(),
!               priv_dg.get_header_offset());
  
      if (send_q_.size() == 1)
      {
          boost::array<asio::const_buffer, 2> cbs;
!         cbs[0] = asio::const_buffer(priv_dg.get_header()
!                                     + priv_dg.get_header_offset(),
!                                     priv_dg.get_header_len());
!         cbs[1] = asio::const_buffer(&priv_dg.get_payload()[0],
!                                     priv_dg.get_payload().size());
          write_one(cbs);
      }
      return 0;
--- 338,358 ----
      send_q_.push_back(dg); // makes copy of dg
      Datagram& priv_dg(send_q_.back());
  
!     priv_dg.set_header_offset(priv_dg.header_offset() -
                                NetHeader::serial_size_);
      serialize(hdr,
!               priv_dg.header(),
!               priv_dg.header_size(),
!               priv_dg.header_offset());
  
      if (send_q_.size() == 1)
      {
          boost::array<asio::const_buffer, 2> cbs;
!         cbs[0] = asio::const_buffer(priv_dg.header()
!                                     + priv_dg.header_offset(),
!                                     priv_dg.header_len());
!         cbs[1] = asio::const_buffer(&priv_dg.payload()[0],
!                                     priv_dg.payload().size());
          write_one(cbs);
      }
      return 0;
***************
*** 342,352 ****
  
      if (ec)
      {
          FAILED_HANDLER(ec);
          return;
      }
  
!     if (get_state() == S_CLOSING)
      {
          // keep on reading data in case of deferred shutdown too
          boost::array<asio::mutable_buffer, 1> mbs;
--- 366,381 ----
  
      if (ec)
      {
+         if (ec.category() == asio::error::get_ssl_category())
+         {
+             log_warn << "read_handler(): " << ec.message() << " ("
+                      << extra_error_info(ec) << ")";
+         }
          FAILED_HANDLER(ec);
          return;
      }
  
!     if (state() == S_CLOSING)
      {
          // keep on reading data in case of deferred shutdown too
          boost::array<asio::mutable_buffer, 1> mbs;
***************
*** 355,364 ****
          read_one(mbs);
          return;
      }
!     else if (get_state() != S_CONNECTED)
      {
!         log_debug << "read handler for " << get_id()
!                   << " state " << get_state();
          return;
      }
  
--- 384,393 ----
          read_one(mbs);
          return;
      }
!     else if (state() != S_CONNECTED)
      {
!         log_debug << "read handler for " << id()
!                   << " state " << state();
          return;
      }
  
***************
*** 371,377 ****
          {
              unserialize(&recv_buf_[0], recv_buf_.size(), 0, hdr);
          }
!         catch (Exception& e)
          {
              FAILED_HANDLER(asio::error_code(e.get_errno(),
                                              asio::error::system_category));
--- 400,406 ----
          {
              unserialize(&recv_buf_[0], recv_buf_.size(), 0, hdr);
          }
!         catch (gu::Exception& e)
          {
              FAILED_HANDLER(asio::error_code(e.get_errno(),
                                              asio::error::system_category));
***************
*** 379,388 ****
          }
          if (recv_offset_ >= hdr.len() + NetHeader::serial_size_)
          {
!             Datagram dg(SharedBuffer(
!                             new Buffer(&recv_buf_[0] + NetHeader::serial_size_,
!                                        &recv_buf_[0] + NetHeader::serial_size_
!                                        + hdr.len())));
              if (net_.checksum_ == true)
              {
  #ifdef TEST_NET_CHECKSUM_ERROR
--- 408,418 ----
          }
          if (recv_offset_ >= hdr.len() + NetHeader::serial_size_)
          {
!             Datagram dg(
!                 gu::SharedBuffer(
!                     new gu::Buffer(&recv_buf_[0] + NetHeader::serial_size_,
!                                    &recv_buf_[0] + NetHeader::serial_size_
!                                    + hdr.len())));
              if (net_.checksum_ == true)
              {
  #ifdef TEST_NET_CHECKSUM_ERROR
***************
*** 404,410 ****
                  }
              }
              ProtoUpMeta um;
!             net_.dispatch(get_id(), dg, um);
              recv_offset_ -= NetHeader::serial_size_ + hdr.len();
  
              if (recv_offset_ > 0)
--- 434,440 ----
                  }
              }
              ProtoUpMeta um;
!             net_.dispatch(id(), dg, um);
              recv_offset_ -= NetHeader::serial_size_ + hdr.len();
  
              if (recv_offset_ > 0)
***************
*** 433,452 ****
      Critical<AsioProtonet> crit(net_);
      if (ec)
      {
          FAILED_HANDLER(ec);
          return 0;
      }
  
!     if (get_state() == S_CLOSING)
      {
!         log_debug << "read completion condition for " << get_id()
!                   << " state " << get_state();
          return 0;
      }
      else if (state_ != S_CONNECTED)
      {
!         log_debug << "read completion condition for " << get_id()
!                   << " state " << get_state();
          return 0;
      }
  
--- 463,487 ----
      Critical<AsioProtonet> crit(net_);
      if (ec)
      {
+         if (ec.category() == asio::error::get_ssl_category())
+         {
+             log_warn << "read_completion_condition(): " << ec.message() << " ("
+                      << extra_error_info(ec) << ")";
+         }
          FAILED_HANDLER(ec);
          return 0;
      }
  
!     if (state() == S_CLOSING)
      {
!         log_debug << "read completion condition for " << id()
!                   << " state " << state();
          return 0;
      }
      else if (state_ != S_CONNECTED)
      {
!         log_debug << "read completion condition for " << id()
!                   << " state " << state();
          return 0;
      }
  
***************
*** 457,463 ****
          {
              unserialize(&recv_buf_[0], NetHeader::serial_size_, 0, hdr);
          }
!         catch (Exception& e)
          {
              log_warn << "unserialize error " << e.what();
              FAILED_HANDLER(asio::error_code(e.get_errno(),
--- 492,498 ----
          {
              unserialize(&recv_buf_[0], NetHeader::serial_size_, 0, hdr);
          }
!         catch (gu::Exception& e)
          {
              log_warn << "unserialize error " << e.what();
              FAILED_HANDLER(asio::error_code(e.get_errno(),
***************
*** 478,484 ****
  {
      Critical<AsioProtonet> crit(net_);
  
!     gcomm_assert(get_state() == S_CONNECTED);
  
      boost::array<asio::mutable_buffer, 1> mbs;
  
--- 513,519 ----
  {
      Critical<AsioProtonet> crit(net_);
  
!     gcomm_assert(state() == S_CONNECTED);
  
      boost::array<asio::mutable_buffer, 1> mbs;
  
***************
*** 486,545 ****
      read_one(mbs);
  }
  
! size_t gcomm::AsioTcpSocket::get_mtu() const
  {
!     return net_.get_mtu();
  }
  
  
  
! std::string gcomm::AsioTcpSocket::get_local_addr() const
  {
! #ifdef HAVE_ASIO_SSL_HPP
!     if (ssl_socket_ != 0)
!     {
!         return uri_string(
!             SSL_SCHEME,
!             escape_addr(ssl_socket_->lowest_layer().local_endpoint().address()),
!             to_string(ssl_socket_->lowest_layer().local_endpoint().port())
!             );
!     }
!     else
!     {
! #endif /* HAVE_ASIO_SSL_HPP */
!         return uri_string(
!             TCP_SCHEME,
!             escape_addr(socket_.local_endpoint().address()),
!             to_string(socket_.local_endpoint().port())
!             );
! #ifdef HAVE_ASIO_SSL_HPP
!     }
! #endif /* HAVE_ASIO_SSL_HPP */
! 
  }
  
! std::string gcomm::AsioTcpSocket::get_remote_addr() const
  {
! #ifdef HAVE_ASIO_SSL_HPP
!     if (ssl_socket_ != 0)
!     {
!         return uri_string(
!             SSL_SCHEME,
!             escape_addr(ssl_socket_->lowest_layer().remote_endpoint().address()),
!             to_string(ssl_socket_->lowest_layer().remote_endpoint().port())
!             );
!     }
!     else
!     {
! #endif /* HAVE_ASIO_SSL_HPP */
!         return uri_string(
!             TCP_SCHEME,
!             escape_addr(socket_.remote_endpoint().address()),
!             to_string(socket_.remote_endpoint().port())
!             );
! #ifdef HAVE_ASIO_SSL_HPP
!     }
! #endif /* HAVE_ASIO_SSL_HPP */
  }
  
  
--- 521,541 ----
      read_one(mbs);
  }
  
! size_t gcomm::AsioTcpSocket::mtu() const
  {
!     return net_.mtu();
  }
  
  
  
! std::string gcomm::AsioTcpSocket::local_addr() const
  {
!     return local_addr_;
  }
  
! std::string gcomm::AsioTcpSocket::remote_addr() const
  {
!     return remote_addr_;
  }
  
  
***************
*** 625,632 ****
      catch (...) { }
  }
  
  
! gcomm::AsioTcpAcceptor::AsioTcpAcceptor(AsioProtonet& net, const URI& uri)
      :
      Acceptor        (uri),
      net_            (net),
--- 621,681 ----
      catch (...) { }
  }
  
+ void gcomm::AsioTcpSocket::assign_local_addr()
+ {
+ #ifdef HAVE_ASIO_SSL_HPP
+     if (ssl_socket_ != 0)
+     {
+         local_addr_ = gcomm::uri_string(
+             gcomm::SSL_SCHEME,
+             gcomm::escape_addr(
+                 ssl_socket_->lowest_layer().local_endpoint().address()),
+             gu::to_string(
+                 ssl_socket_->lowest_layer().local_endpoint().port())
+             );
+     }
+     else
+     {
+ #endif /* HAVE_ASIO_SSL_HPP */
+         local_addr_ = gcomm::uri_string(
+             gcomm::TCP_SCHEME,
+             gcomm::escape_addr(socket_.local_endpoint().address()),
+             gu::to_string(socket_.local_endpoint().port())
+             );
+ #ifdef HAVE_ASIO_SSL_HPP
+     }
+ #endif /* HAVE_ASIO_SSL_HPP */
+ }
+ 
+ void gcomm::AsioTcpSocket::assign_remote_addr()
+ {
+ #ifdef HAVE_ASIO_SSL_HPP
+     if (ssl_socket_ != 0)
+     {
+         remote_addr_ = gcomm::uri_string(
+             gcomm::SSL_SCHEME,
+             gcomm::escape_addr(
+                 ssl_socket_->lowest_layer().remote_endpoint().address()),
+             gu::to_string(
+                 ssl_socket_->lowest_layer().remote_endpoint().port())
+             );
+     }
+     else
+     {
+ #endif /* HAVE_ASIO_SSL_HPP */
+         remote_addr_ = uri_string(
+             gcomm::TCP_SCHEME,
+             gcomm::escape_addr(socket_.remote_endpoint().address()),
+             gu::to_string(socket_.remote_endpoint().port())
+             );
+ #ifdef HAVE_ASIO_SSL_HPP
+     }
+ #endif /* HAVE_ASIO_SSL_HPP */
+ }
+ 
+ 
  
! gcomm::AsioTcpAcceptor::AsioTcpAcceptor(AsioProtonet& net, const gu::URI& uri)
      :
      Acceptor        (uri),
      net_            (net),
***************
*** 649,654 ****
--- 698,705 ----
      if (!error)
      {
          AsioTcpSocket* s(static_cast<AsioTcpSocket*>(socket.get()));
+         s->assign_local_addr();
+         s->assign_remote_addr();
  #ifdef HAVE_ASIO_SSL_HPP
          if (s->ssl_socket_ != 0)
          {
***************
*** 656,664 ****
                  asio::ip::tcp::no_delay(true));
              set_fd_options(s->ssl_socket_->lowest_layer());
              log_debug << "socket "
!                       << s->get_id() << " connected, remote endpoint "
!                       << s->get_remote_addr() << " local endpoint "
!                       << s->get_local_addr();
              s->ssl_socket_->async_handshake(
                  asio::ssl::stream<asio::ip::tcp::socket>::server,
                  boost::bind(&AsioTcpSocket::handshake_handler,
--- 707,715 ----
                  asio::ip::tcp::no_delay(true));
              set_fd_options(s->ssl_socket_->lowest_layer());
              log_debug << "socket "
!                       << s->id() << " connected, remote endpoint "
!                       << s->remote_addr() << " local endpoint "
!                       << s->local_addr();
              s->ssl_socket_->async_handshake(
                  asio::ssl::stream<asio::ip::tcp::socket>::server,
                  boost::bind(&AsioTcpSocket::handshake_handler,
***************
*** 676,683 ****
          }
  #endif /* HAVE_ASIO_SSL_HPP */
          accepted_socket_ = socket;
!         log_debug << "accepted socket " << socket->get_id();
!         net_.dispatch(get_id(), Datagram(), ProtoUpMeta(error.value()));
          AsioTcpSocket* new_socket(new AsioTcpSocket(net_, uri_));
  #ifdef HAVE_ASIO_SSL_HPP
          if (uri_.get_scheme() == SSL_SCHEME)
--- 727,734 ----
          }
  #endif /* HAVE_ASIO_SSL_HPP */
          accepted_socket_ = socket;
!         log_debug << "accepted socket " << socket->id();
!         net_.dispatch(id(), Datagram(), ProtoUpMeta(error.value()));
          AsioTcpSocket* new_socket(new AsioTcpSocket(net_, uri_));
  #ifdef HAVE_ASIO_SSL_HPP
          if (uri_.get_scheme() == SSL_SCHEME)
***************
*** 710,716 ****
  }
  
  
! void gcomm::AsioTcpAcceptor::listen(const URI& uri)
  {
      try
      {
--- 761,767 ----
  }
  
  
! void gcomm::AsioTcpAcceptor::listen(const gu::URI& uri)
  {
      try
      {
***************
*** 792,798 ****
  
  gcomm::SocketPtr gcomm::AsioTcpAcceptor::accept()
  {
!     if (accepted_socket_->get_state() == Socket::S_CONNECTED)
      {
          accepted_socket_->async_receive();
      }
--- 843,849 ----
  
  gcomm::SocketPtr gcomm::AsioTcpAcceptor::accept()
  {
!     if (accepted_socket_->state() == Socket::S_CONNECTED)
      {
          accepted_socket_->async_receive();
      }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_tcp.hpp 2.x/gcomm/src/asio_tcp.hpp
*** galera-23.2.2-src/gcomm/src/asio_tcp.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_tcp.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 38,55 ****
      void close();
      void write_handler(const asio::error_code& ec,
                         size_t bytes_transferred);
!     int send(const gu::Datagram& dg);
      size_t read_completion_condition(
          const asio::error_code& ec,
          const size_t bytes_transferred);
      void read_handler(const asio::error_code& ec,
                        const size_t bytes_transferred);
      void async_receive();
!     size_t get_mtu() const;
!     std::string get_local_addr() const;
!     std::string get_remote_addr() const;
!     State get_state() const { return state_; }
!     SocketId get_id() const { return &socket_; }
  private:
      friend class gcomm::AsioTcpAcceptor;
  
--- 38,55 ----
      void close();
      void write_handler(const asio::error_code& ec,
                         size_t bytes_transferred);
!     int send(const Datagram& dg);
      size_t read_completion_condition(
          const asio::error_code& ec,
          const size_t bytes_transferred);
      void read_handler(const asio::error_code& ec,
                        const size_t bytes_transferred);
      void async_receive();
!     size_t mtu() const;
!     std::string local_addr() const;
!     std::string remote_addr() const;
!     State state() const { return state_; }
!     SocketId id() const { return &socket_; }
  private:
      friend class gcomm::AsioTcpAcceptor;
  
***************
*** 60,74 ****
      void write_one(const boost::array<asio::const_buffer, 2>& cbs);
      void close_socket();
  
      AsioProtonet&                             net_;
      asio::ip::tcp::socket                     socket_;
  #ifdef HAVE_ASIO_SSL_HPP
      asio::ssl::stream<asio::ip::tcp::socket>* ssl_socket_;
  #endif // HAVE_ASIO_SSL_HPP
!     std::deque<gu::Datagram>                  send_q_;
      std::vector<gu::byte_t>                   recv_buf_;
      size_t                                    recv_offset_;
      State                                     state_;
  };
  
  
--- 60,83 ----
      void write_one(const boost::array<asio::const_buffer, 2>& cbs);
      void close_socket();
  
+     // call to assign local/remote addresses at the point where it
+     // is known that underlying socket is live
+     void assign_local_addr();
+     void assign_remote_addr();
+ 
      AsioProtonet&                             net_;
      asio::ip::tcp::socket                     socket_;
  #ifdef HAVE_ASIO_SSL_HPP
      asio::ssl::stream<asio::ip::tcp::socket>* ssl_socket_;
  #endif // HAVE_ASIO_SSL_HPP
!     std::deque<Datagram>                      send_q_;
      std::vector<gu::byte_t>                   recv_buf_;
      size_t                                    recv_offset_;
      State                                     state_;
+     // Querying addresses from failed socket does not work,
+     // so need to maintain copy for diagnostics logging
+     std::string                               local_addr_;
+     std::string                               remote_addr_;
  };
  
  
***************
*** 86,98 ****
      void close();
      SocketPtr accept();
  
!     State get_state() const
      {
          gu_throw_fatal << "TODO:";
          throw;
      }
  
!     SocketId get_id() const { return &acceptor_; }
  
  private:
      AsioProtonet& net_;
--- 95,107 ----
      void close();
      SocketPtr accept();
  
!     State state() const
      {
          gu_throw_fatal << "TODO:";
          throw;
      }
  
!     SocketId id() const { return &acceptor_; }
  
  private:
      AsioProtonet& net_;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_udp.cpp 2.x/gcomm/src/asio_udp.cpp
*** galera-23.2.2-src/gcomm/src/asio_udp.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_udp.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 11,19 ****
  #include <boost/bind.hpp>
  #include <boost/array.hpp>
  
- using namespace std;
- using namespace gu;
- 
  
  static bool is_multicast(const asio::ip::udp::endpoint& ep)
  {
--- 11,16 ----
***************
*** 56,62 ****
  
  
  
! gcomm::AsioUdpSocket::AsioUdpSocket(AsioProtonet& net, const URI& uri)
      :
      Socket(uri),
      net_(net),
--- 53,59 ----
  
  
  
! gcomm::AsioUdpSocket::AsioUdpSocket(AsioProtonet& net, const gu::URI& uri)
      :
      Socket(uri),
      net_(net),
***************
*** 74,82 ****
  }
  
  
! void gcomm::AsioUdpSocket::connect(const URI& uri)
  {
!     gcomm_assert(get_state() == S_CLOSED);
      Critical<AsioProtonet> crit(net_);
      asio::ip::udp::resolver resolver(net_.io_service_);
  
--- 71,79 ----
  }
  
  
! void gcomm::AsioUdpSocket::connect(const gu::URI& uri)
  {
!     gcomm_assert(state() == S_CLOSED);
      Critical<AsioProtonet> crit(net_);
      asio::ip::udp::resolver resolver(net_.io_service_);
  
***************
*** 93,99 ****
      asio::ip::udp::socket::non_blocking_io cmd(true);
      socket_.io_control(cmd);
  
!     const string if_addr(
          unescape_addr(
              uri.get_option("socket.if_addr",
                             anyaddr(conn_i->endpoint().address()))));
--- 90,96 ----
      asio::ip::udp::socket::non_blocking_io cmd(true);
      socket_.io_control(cmd);
  
!     const std::string if_addr(
          unescape_addr(
              uri.get_option("socket.if_addr",
                             anyaddr(conn_i->endpoint().address()))));
***************
*** 104,120 ****
          join_group(socket_, conn_i->endpoint(), local_if);
          socket_.set_option(
              asio::ip::multicast::enable_loopback(
!                 from_string<bool>(uri.get_option("socket.if_loop", "false"))));
          socket_.set_option(
              asio::ip::multicast::hops(
!                 from_string<int>(uri.get_option("socket.mcast_ttl", "1"))));
          socket_.bind(*conn_i);
      }
      else
      {
          socket_.bind(
!             asio::ip::udp::endpoint(local_if,
!                               from_string<unsigned short>(uri.get_port())));
      }
  
      async_receive();
--- 101,118 ----
          join_group(socket_, conn_i->endpoint(), local_if);
          socket_.set_option(
              asio::ip::multicast::enable_loopback(
!                 gu::from_string<bool>(uri.get_option("socket.if_loop", "false"))));
          socket_.set_option(
              asio::ip::multicast::hops(
!                 gu::from_string<int>(uri.get_option("socket.mcast_ttl", "1"))));
          socket_.bind(*conn_i);
      }
      else
      {
          socket_.bind(
!             asio::ip::udp::endpoint(
!                 local_if,
!                 gu::from_string<unsigned short>(uri.get_port())));
      }
  
      async_receive();
***************
*** 124,130 ****
  void gcomm::AsioUdpSocket::close()
  {
      Critical<AsioProtonet> crit(net_);
!     if (get_state() != S_CLOSED)
      {
          if (is_multicast(target_ep_) == true)
          {
--- 122,128 ----
  void gcomm::AsioUdpSocket::close()
  {
      Critical<AsioProtonet> crit(net_);
!     if (state() != S_CLOSED)
      {
          if (is_multicast(target_ep_) == true)
          {
***************
*** 139,155 ****
  {
      Critical<AsioProtonet> crit(net_);
      boost::array<asio::const_buffer, 3> cbs;
!     NetHeader hdr(dg.get_len(), net_.version_);
      if (net_.checksum_ == true)
      {
          hdr.set_crc32(crc32(dg));
      }
!     byte_t buf[NetHeader::serial_size_];
!     gu::serialize(hdr, buf, sizeof(buf), 0);
      cbs[0] = asio::const_buffer(buf, sizeof(buf));
!     cbs[1] = asio::const_buffer(dg.get_header() + dg.get_header_offset(),
!                           dg.get_header_len());
!     cbs[2] = asio::const_buffer(&dg.get_payload()[0], dg.get_payload().size());
      try
      {
          socket_.send_to(cbs, target_ep_);
--- 137,153 ----
  {
      Critical<AsioProtonet> crit(net_);
      boost::array<asio::const_buffer, 3> cbs;
!     NetHeader hdr(dg.len(), net_.version_);
      if (net_.checksum_ == true)
      {
          hdr.set_crc32(crc32(dg));
      }
!     gu::byte_t buf[NetHeader::serial_size_];
!     serialize(hdr, buf, sizeof(buf), 0);
      cbs[0] = asio::const_buffer(buf, sizeof(buf));
!     cbs[1] = asio::const_buffer(dg.header() + dg.header_offset(),
!                           dg.header_len());
!     cbs[2] = asio::const_buffer(&dg.payload()[0], dg.payload().size());
      try
      {
          socket_.send_to(cbs, target_ep_);
***************
*** 178,186 ****
          NetHeader hdr;
          try
          {
!             gu::unserialize(&recv_buf_[0], NetHeader::serial_size_, 0, hdr);
          }
!         catch (Exception& e)
          {
              log_warn << "hdr unserialize failed: " << e.get_errno();
              return;
--- 176,184 ----
          NetHeader hdr;
          try
          {
!             unserialize(&recv_buf_[0], NetHeader::serial_size_, 0, hdr);
          }
!         catch (gu::Exception& e)
          {
              log_warn << "hdr unserialize failed: " << e.get_errno();
              return;
***************
*** 193,202 ****
          }
          else
          {
!             Datagram dg(SharedBuffer(
!                             new Buffer(&recv_buf_[0] + NetHeader::serial_size_,
!                                        &recv_buf_[0] + NetHeader::serial_size_
!                                        + hdr.len())));
              if (net_.checksum_ == true &&
                  ((hdr.has_crc32() == true && crc32(dg) != hdr.crc32()) ||
                   (hdr.has_crc32() == false && hdr.crc32() != 0)))
--- 191,201 ----
          }
          else
          {
!             Datagram dg(
!                 gu::SharedBuffer(
!                     new gu::Buffer(&recv_buf_[0] + NetHeader::serial_size_,
!                                    &recv_buf_[0] + NetHeader::serial_size_
!                                    + hdr.len())));
              if (net_.checksum_ == true &&
                  ((hdr.has_crc32() == true && crc32(dg) != hdr.crc32()) ||
                   (hdr.has_crc32() == false && hdr.crc32() != 0)))
***************
*** 207,213 ****
              }
              else
              {
!                 net_.dispatch(get_id(), dg, ProtoUpMeta());
              }
          }
      }
--- 206,212 ----
              }
              else
              {
!                 net_.dispatch(id(), dg, ProtoUpMeta());
              }
          }
      }
***************
*** 231,251 ****
  }
  
  
! size_t gcomm::AsioUdpSocket::get_mtu() const
  {
      return (1 << 15);
  }
  
! string gcomm::AsioUdpSocket::get_local_addr() const
  {
      return uri_string(UDP_SCHEME,
                        escape_addr(socket_.local_endpoint().address()),
!                       to_string(socket_.local_endpoint().port()));
  }
  
! string gcomm::AsioUdpSocket::get_remote_addr() const
  {
      return uri_string(UDP_SCHEME,
                        escape_addr(socket_.remote_endpoint().address()),
!                       to_string(socket_.remote_endpoint().port()));
  }
--- 230,250 ----
  }
  
  
! size_t gcomm::AsioUdpSocket::mtu() const
  {
      return (1 << 15);
  }
  
! std::string gcomm::AsioUdpSocket::local_addr() const
  {
      return uri_string(UDP_SCHEME,
                        escape_addr(socket_.local_endpoint().address()),
!                       gu::to_string(socket_.local_endpoint().port()));
  }
  
! std::string gcomm::AsioUdpSocket::remote_addr() const
  {
      return uri_string(UDP_SCHEME,
                        escape_addr(socket_.remote_endpoint().address()),
!                       gu::to_string(socket_.remote_endpoint().port()));
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/asio_udp.hpp 2.x/gcomm/src/asio_udp.hpp
*** galera-23.2.2-src/gcomm/src/asio_udp.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/asio_udp.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 25,38 ****
      ~AsioUdpSocket();
      void connect(const gu::URI& uri);
      void close();
!     int send(const gu::Datagram& dg);
      void read_handler(const asio::error_code&, size_t);
      void async_receive();
!     size_t get_mtu() const;
!     std::string get_local_addr() const;
!     std::string get_remote_addr() const;
!     State get_state() const { return state_; }
!     SocketId get_id() const { return &socket_; }
  
  private:
      AsioProtonet&            net_;
--- 25,38 ----
      ~AsioUdpSocket();
      void connect(const gu::URI& uri);
      void close();
!     int send(const Datagram& dg);
      void read_handler(const asio::error_code&, size_t);
      void async_receive();
!     size_t mtu() const;
!     std::string local_addr() const;
!     std::string remote_addr() const;
!     State state() const { return state_; }
!     SocketId id() const { return &socket_; }
  
  private:
      AsioProtonet&            net_;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/conf.cpp 2.x/gcomm/src/conf.cpp
*** galera-23.2.2-src/gcomm/src/conf.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/conf.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 101,103 ****
--- 101,104 ----
  std::string const gcomm::Conf::PcWaitPrim = PcScheme + Delim + "wait_prim";
  std::string const gcomm::Conf::PcWaitPrimTimeout =
      PcScheme + Delim + "wait_prim_timeout";
+ std::string const gcomm::Conf::PcWeight = PcScheme + Delim + "weight";
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_consensus.cpp 2.x/gcomm/src/evs_consensus.cpp
*** galera-23.2.2-src/gcomm/src/evs_consensus.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_consensus.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 12,24 ****
  
  #include <list>
  
- using namespace std;
- using namespace gcomm;
- using namespace gcomm::evs;
- 
  // Disable debug logging until debug mask is available here
! #define evs_log_debug(i) if (true) {} else log_debug << get_uuid() << " "
! 
  
  //
  // Helpers
--- 12,19 ----
  
  #include <list>
  
  // Disable debug logging until debug mask is available here
! #define evs_log_debug(i) if (true) {} else log_debug << uuid() << " "
  
  //
  // Helpers
***************
*** 27,41 ****
  class LeaveSeqCmpOp
  {
  public:
!     bool operator()(const MessageNodeList::value_type& a,
!                     const MessageNodeList::value_type& b) const
      {
!         const MessageNode& aval(MessageNodeList::get_value(a));
!         const MessageNode& bval(MessageNodeList::get_value(b));
!         gcomm_assert(aval.get_leaving() != false &&
!                      bval.get_leaving() != false);
!         const seqno_t asec(aval.get_leave_seq());
!         const seqno_t bsec(bval.get_leave_seq());
          gcomm_assert(asec != -1 && bsec != -1);
          return (asec < bsec);
      }
--- 22,39 ----
  class LeaveSeqCmpOp
  {
  public:
! 
!     bool operator()(const gcomm::evs::MessageNodeList::value_type& a,
!                     const gcomm::evs::MessageNodeList::value_type& b) const
      {
!         using gcomm::evs::MessageNode;
!         using gcomm::evs::MessageNodeList;
!         const MessageNode& aval(MessageNodeList::value(a));
!         const MessageNode& bval(MessageNodeList::value(b));
!         gcomm_assert(aval.leaving() != false &&
!                      bval.leaving() != false);
!         const gcomm::evs::seqno_t asec(aval.leave_seq());
!         const gcomm::evs::seqno_t bsec(bval.leave_seq());
          gcomm_assert(asec != -1 && bsec != -1);
          return (asec < bsec);
      }
***************
*** 45,55 ****
  class RangeLuCmp
  {
  public:
!     bool operator()(const MessageNodeList::value_type& a,
!                     const MessageNodeList::value_type& b) const
      {
!         return MessageNodeList::get_value(a).get_im_range().get_lu() <
!             MessageNodeList::get_value(b).get_im_range().get_lu();
      }
  };
  
--- 43,53 ----
  class RangeLuCmp
  {
  public:
!     bool operator()(const gcomm::evs::MessageNodeList::value_type& a,
!                     const gcomm::evs::MessageNodeList::value_type& b) const
      {
!         return (gcomm::evs::MessageNodeList::value(a).im_range().lu() <
!                 gcomm::evs::MessageNodeList::value(b).im_range().lu());
      }
  };
  
***************
*** 57,67 ****
  class SafeSeqCmp
  {
  public:
!     bool operator()(const MessageNodeList::value_type& a,
!                     const MessageNodeList::value_type& b) const
      {
!         return MessageNodeList::get_value(a).get_safe_seq() <
!             MessageNodeList::get_value(b).get_safe_seq();
      }
  };
  
--- 55,65 ----
  class SafeSeqCmp
  {
  public:
!     bool operator()(const gcomm::evs::MessageNodeList::value_type& a,
!                     const gcomm::evs::MessageNodeList::value_type& b) const
      {
!         return (gcomm::evs::MessageNodeList::value(a).safe_seq() <
!                 gcomm::evs::MessageNodeList::value(b).safe_seq());
      }
  };
  
***************
*** 73,96 ****
  
  bool gcomm::evs::Consensus::equal(const Message& m1, const Message& m2) const
  {
!     gcomm_assert(m1.get_type() == Message::T_JOIN ||
!                  m1.get_type() == Message::T_INSTALL);
!     gcomm_assert(m2.get_type() == Message::T_JOIN ||
!                  m2.get_type() == Message::T_INSTALL);
  
      // Seq and aru seq are comparable only if coming from same view
!     if (m1.get_source_view_id() == m2.get_source_view_id())
      {
!         if (m1.get_seq() != m2.get_seq())
          {
              evs_log_debug(D_CONSENSUS) << "seq not equal " <<
!                 m1.get_seq() << " " << m2.get_seq();
              return false;
          }
!         if (m1.get_aru_seq() != m2.get_aru_seq())
          {
              evs_log_debug(D_CONSENSUS) << "aruseq not equal " <<
!                 m1.get_aru_seq() << " " << m2.get_aru_seq();
              return false;
          }
      }
--- 71,94 ----
  
  bool gcomm::evs::Consensus::equal(const Message& m1, const Message& m2) const
  {
!     gcomm_assert(m1.type() == Message::T_JOIN ||
!                  m1.type() == Message::T_INSTALL);
!     gcomm_assert(m2.type() == Message::T_JOIN ||
!                  m2.type() == Message::T_INSTALL);
  
      // Seq and aru seq are comparable only if coming from same view
!     if (m1.source_view_id() == m2.source_view_id())
      {
!         if (m1.seq() != m2.seq())
          {
              evs_log_debug(D_CONSENSUS) << "seq not equal " <<
!                 m1.seq() << " " << m2.seq();
              return false;
          }
!         if (m1.aru_seq() != m2.aru_seq())
          {
              evs_log_debug(D_CONSENSUS) << "aruseq not equal " <<
!                 m1.aru_seq() << " " << m2.aru_seq();
              return false;
          }
      }
***************
*** 99,116 ****
  
      // When comparing messages from same source whole node list is comparable,
      // otherwise only operational part of it.
!     if (m1.get_source() == m2.get_source())
      {
!         for_each(m1.get_node_list().begin(), m1.get_node_list().end(),
!                  SelectNodesOp(nl1, m1.get_source_view_id(), true, true));
!         for_each(m2.get_node_list().begin(), m2.get_node_list().end(),
!                  SelectNodesOp(nl2, m2.get_source_view_id(), true, true));
      }
      else
      {
!         for_each(m1.get_node_list().begin(), m1.get_node_list().end(),
                   SelectNodesOp(nl1, ViewId(), true, false));
!         for_each(m2.get_node_list().begin(), m2.get_node_list().end(),
                   SelectNodesOp(nl2, ViewId(), true, false));
      }
  
--- 97,114 ----
  
      // When comparing messages from same source whole node list is comparable,
      // otherwise only operational part of it.
!     if (m1.source() == m2.source())
      {
!         for_each(m1.node_list().begin(), m1.node_list().end(),
!                  SelectNodesOp(nl1, m1.source_view_id(), true, true));
!         for_each(m2.node_list().begin(), m2.node_list().end(),
!                  SelectNodesOp(nl2, m2.source_view_id(), true, true));
      }
      else
      {
!         for_each(m1.node_list().begin(), m1.node_list().end(),
                   SelectNodesOp(nl1, ViewId(), true, false));
!         for_each(m2.node_list().begin(), m2.node_list().end(),
                   SelectNodesOp(nl2, ViewId(), true, false));
      }
  
***************
*** 122,177 ****
  
  gcomm::evs::seqno_t gcomm::evs::Consensus::highest_reachable_safe_seq() const
  {
!     list<seqno_t> seq_list;
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end();
           ++i)
      {
!         const Node& node(NodeMap::get_value(i));
!         const JoinMessage* jm(node.get_join_message());
!         const LeaveMessage* lm(node.get_leave_message());
! 
!         if ((jm == 0 && current_view_.is_member(NodeMap::get_key(i)) == true) ||
!             (jm != 0 && jm->get_source_view_id() == current_view_.get_id()) ||
!             (lm != 0 && lm->get_source_view_id() == current_view_.get_id()))
          {
              if (lm != 0)
              {
                  if (node.is_suspected() == false)
                  {
!                     seq_list.push_back(lm->get_seq());
                  }
              }
!             else if (node.get_operational() == false)
              {
                  seq_list.push_back(
!                     min(
!                         input_map_.get_safe_seq(node.get_index()),
!                         input_map_.get_range(node.get_index()).get_lu() - 1));
              }
              else
              {
!                 seq_list.push_back(input_map_.get_range(node.get_index()).get_hs());
              }
          }
      }
  
!     return *min_element(seq_list.begin(), seq_list.end());
  }
  
  
  bool gcomm::evs::Consensus::is_consistent_highest_reachable_safe_seq(
      const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(msg.get_source_view_id() == current_view_.get_id());
  
!     const MessageNodeList& node_list(msg.get_node_list());
  
      // Same view
      MessageNodeList same_view;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(same_view, current_view_.get_id(), true, false));
      MessageNodeList::const_iterator max_hs_i(max_element(same_view.begin(),
                                                           same_view.end(),
                                                           RangeHsCmp()));
--- 120,175 ----
  
  gcomm::evs::seqno_t gcomm::evs::Consensus::highest_reachable_safe_seq() const
  {
!     std::list<seqno_t> seq_list;
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end();
           ++i)
      {
!         const Node& node(NodeMap::value(i));
!         const JoinMessage* jm(node.join_message());
!         const LeaveMessage* lm(node.leave_message());
! 
!         if ((jm == 0 && current_view_.is_member(NodeMap::key(i)) == true) ||
!             (jm != 0 && jm->source_view_id() == current_view_.id()) ||
!             (lm != 0 && lm->source_view_id() == current_view_.id()))
          {
              if (lm != 0)
              {
                  if (node.is_suspected() == false)
                  {
!                     seq_list.push_back(lm->seq());
                  }
              }
!             else if (node.operational() == false)
              {
                  seq_list.push_back(
!                     std::min(
!                         input_map_.safe_seq(node.index()),
!                         input_map_.range(node.index()).lu() - 1));
              }
              else
              {
!                 seq_list.push_back(input_map_.range(node.index()).hs());
              }
          }
      }
  
!     return *std::min_element(seq_list.begin(), seq_list.end());
  }
  
  
  bool gcomm::evs::Consensus::is_consistent_highest_reachable_safe_seq(
      const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
!     const MessageNodeList& node_list(msg.node_list());
  
      // Same view
      MessageNodeList same_view;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(same_view, current_view_.id(), true, false));
      MessageNodeList::const_iterator max_hs_i(max_element(same_view.begin(),
                                                           same_view.end(),
                                                           RangeHsCmp()));
***************
*** 179,264 ****
  
      // Max highest seen
      const seqno_t max_hs(
!         MessageNodeList::get_value(max_hs_i).get_im_range().get_hs());
  
      seqno_t max_reachable_safe_seq(max_hs);
  
      // Leaving nodes
      MessageNodeList leaving;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(leaving, current_view_.get_id(), false, true));
  
      if (leaving.empty() == false)
      {
          const MessageNodeList::const_iterator min_leave_seq_i(
!             min_element(leaving.begin(), leaving.end(),
                          LeaveSeqCmpOp()));
          gcomm_assert(min_leave_seq_i != leaving.end());
          const seqno_t min_leave_seq(
!             MessageNodeList::get_value(min_leave_seq_i).get_leave_seq());
!         max_reachable_safe_seq = min(max_reachable_safe_seq, min_leave_seq);
      }
  
      // Partitioning nodes
      MessageNodeList partitioning;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(partitioning, current_view_.get_id(), false, false));
  
      if (partitioning.empty() == false)
      {
          MessageNodeList::const_iterator min_part_safe_seq_i(
!             min_element(partitioning.begin(), partitioning.end(),
                          SafeSeqCmp()));
          gcomm_assert(min_part_safe_seq_i != partitioning.end());
          const seqno_t min_part_safe_seq(
!             MessageNodeList::get_value(min_part_safe_seq_i).get_safe_seq());
!         max_reachable_safe_seq = min(max_reachable_safe_seq,
!                                      min_part_safe_seq);
  
          MessageNodeList::const_iterator min_part_lu_i(
!             min_element(partitioning.begin(), partitioning.end(),
!                         RangeLuCmp()));
          gcomm_assert(min_part_lu_i != partitioning.end());
!         const seqno_t min_part_lu(MessageNodeList::get_value(min_part_lu_i).get_im_range().get_lu() - 1);
!         max_reachable_safe_seq = min(max_reachable_safe_seq,
!                                      min_part_lu);
      }
  
      evs_log_debug(D_CONSENSUS)
          << " max reachable safe seq " << max_reachable_safe_seq
          << " highest reachable safe seq " << highest_reachable_safe_seq()
          << " max_hs " << max_hs
!         << " input map max hs " << input_map_.get_max_hs()
!         << " input map safe_seq " << input_map_.get_safe_seq();
  
!     return (input_map_.get_max_hs()       == max_hs                 &&
              highest_reachable_safe_seq() == max_reachable_safe_seq &&
!             input_map_.get_safe_seq()     == max_reachable_safe_seq);
  }
  
  
  bool gcomm::evs::Consensus::is_consistent_input_map(const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(msg.get_source_view_id() == current_view_.get_id());
  
  
!     if (msg.get_aru_seq() != input_map_.get_aru_seq())
      {
          evs_log_debug(D_CONSENSUS) << "message aru seq "
!                                    << msg.get_aru_seq()
                                     << " not consistent with input map aru seq "
!                                    << input_map_.get_aru_seq();
          return false;
      }
  
!     if (msg.get_seq() != input_map_.get_safe_seq())
      {
          evs_log_debug(D_CONSENSUS) << "message safe seq "
!                                    << msg.get_seq()
                                     << " not consistent with input map safe seq "
!                                    << input_map_.get_safe_seq();
          return false;
      }
  
--- 177,262 ----
  
      // Max highest seen
      const seqno_t max_hs(
!         MessageNodeList::value(max_hs_i).im_range().hs());
  
      seqno_t max_reachable_safe_seq(max_hs);
  
      // Leaving nodes
      MessageNodeList leaving;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(leaving, current_view_.id(), false, true));
  
      if (leaving.empty() == false)
      {
          const MessageNodeList::const_iterator min_leave_seq_i(
!             std::min_element(leaving.begin(), leaving.end(),
                          LeaveSeqCmpOp()));
          gcomm_assert(min_leave_seq_i != leaving.end());
          const seqno_t min_leave_seq(
!             MessageNodeList::value(min_leave_seq_i).leave_seq());
!         max_reachable_safe_seq = std::min(max_reachable_safe_seq, min_leave_seq);
      }
  
      // Partitioning nodes
      MessageNodeList partitioning;
      for_each(node_list.begin(), node_list.end(),
!              SelectNodesOp(partitioning, current_view_.id(), false, false));
  
      if (partitioning.empty() == false)
      {
          MessageNodeList::const_iterator min_part_safe_seq_i(
!             std::min_element(partitioning.begin(), partitioning.end(),
                          SafeSeqCmp()));
          gcomm_assert(min_part_safe_seq_i != partitioning.end());
          const seqno_t min_part_safe_seq(
!             MessageNodeList::value(min_part_safe_seq_i).safe_seq());
!         max_reachable_safe_seq = std::min(max_reachable_safe_seq,
!                                           min_part_safe_seq);
  
          MessageNodeList::const_iterator min_part_lu_i(
!             std::min_element(partitioning.begin(), partitioning.end(),
!                              RangeLuCmp()));
          gcomm_assert(min_part_lu_i != partitioning.end());
!         const seqno_t min_part_lu(MessageNodeList::value(min_part_lu_i).im_range().lu() - 1);
!         max_reachable_safe_seq = std::min(max_reachable_safe_seq,
!                                           min_part_lu);
      }
  
      evs_log_debug(D_CONSENSUS)
          << " max reachable safe seq " << max_reachable_safe_seq
          << " highest reachable safe seq " << highest_reachable_safe_seq()
          << " max_hs " << max_hs
!         << " input map max hs " << input_map_.max_hs()
!         << " input map safe_seq " << input_map_.safe_seq();
  
!     return (input_map_.max_hs()       == max_hs                 &&
              highest_reachable_safe_seq() == max_reachable_safe_seq &&
!             input_map_.safe_seq()     == max_reachable_safe_seq);
  }
  
  
  bool gcomm::evs::Consensus::is_consistent_input_map(const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
  
!     if (msg.aru_seq() != input_map_.aru_seq())
      {
          evs_log_debug(D_CONSENSUS) << "message aru seq "
!                                    << msg.aru_seq()
                                     << " not consistent with input map aru seq "
!                                    << input_map_.aru_seq();
          return false;
      }
  
!     if (msg.seq() != input_map_.safe_seq())
      {
          evs_log_debug(D_CONSENSUS) << "message safe seq "
!                                    << msg.seq()
                                     << " not consistent with input map safe seq "
!                                    << input_map_.safe_seq();
          return false;
      }
  
***************
*** 266,291 ****
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         const Node& node(NodeMap::get_value(i));
          if (current_view_.is_member(uuid) == true)
          {
              gu_trace((void)local_insts.insert_unique(
!                          make_pair(uuid, input_map_.get_range(node.get_index()))));
          }
      }
  
!     const MessageNodeList& m_insts(msg.get_node_list());
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& msg_uuid(MessageNodeList::get_key(i));
!         const MessageNode& msg_inst(MessageNodeList::get_value(i));
!         if (msg_inst.get_view_id() == current_view_.get_id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          make_pair(msg_uuid, msg_inst.get_im_range())));
          }
      }
  
--- 264,289 ----
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::key(i));
!         const Node& node(NodeMap::value(i));
          if (current_view_.is_member(uuid) == true)
          {
              gu_trace((void)local_insts.insert_unique(
!                          std::make_pair(uuid, input_map_.range(node.index()))));
          }
      }
  
!     const MessageNodeList& m_insts(msg.node_list());
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& msg_uuid(MessageNodeList::key(i));
!         const MessageNode& msg_inst(MessageNodeList::value(i));
!         if (msg_inst.view_id() == current_view_.id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          std::make_pair(msg_uuid, msg_inst.im_range())));
          }
      }
  
***************
*** 298,306 ****
  
  bool gcomm::evs::Consensus::is_consistent_partitioning(const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(msg.get_source_view_id() == current_view_.get_id());
  
  
      // Compare instances that were present in the current view but are
--- 296,304 ----
  
  bool gcomm::evs::Consensus::is_consistent_partitioning(const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
  
      // Compare instances that were present in the current view but are
***************
*** 310,340 ****
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         const Node& node(NodeMap::get_value(i));
!         if (node.get_operational()       == false &&
!             node.get_leave_message()     == 0     &&
              current_view_.is_member(uuid) == true)
          {
              gu_trace((void)local_insts.insert_unique(
!                          make_pair(uuid,
!                                    input_map_.get_range(node.get_index()))));
          }
      }
  
!     const MessageNodeList& m_insts = msg.get_node_list();
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& m_uuid(MessageNodeList::get_key(i));
!         const MessageNode& m_inst(MessageNodeList::get_value(i));
!         if (m_inst.get_operational() == false &&
!             m_inst.get_leaving()     == false &&
!             m_inst.get_view_id()     == current_view_.get_id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          make_pair(m_uuid, m_inst.get_im_range())));
          }
      }
  
--- 308,338 ----
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::key(i));
!         const Node& node(NodeMap::value(i));
!         if (node.operational()       == false &&
!             node.leave_message()     == 0     &&
              current_view_.is_member(uuid) == true)
          {
              gu_trace((void)local_insts.insert_unique(
!                          std::make_pair(uuid,
!                                         input_map_.range(node.index()))));
          }
      }
  
!     const MessageNodeList& m_insts = msg.node_list();
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& m_uuid(MessageNodeList::key(i));
!         const MessageNode& m_inst(MessageNodeList::value(i));
!         if (m_inst.operational() == false &&
!             m_inst.leaving()     == false &&
!             m_inst.view_id()     == current_view_.id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          std::make_pair(m_uuid, m_inst.im_range())));
          }
      }
  
***************
*** 347,355 ****
  
  bool gcomm::evs::Consensus::is_consistent_leaving(const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(msg.get_source_view_id() == current_view_.get_id());
  
      // Compare instances that were present in the current view but are
      // not proceeding in the next view.
--- 345,353 ----
  
  bool gcomm::evs::Consensus::is_consistent_leaving(const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
      // Compare instances that were present in the current view but are
      // not proceeding in the next view.
***************
*** 358,389 ****
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         const Node& inst(NodeMap::get_value(i));
!         const LeaveMessage* lm(inst.get_leave_message());
  
!         if (inst.get_operational()   == false &&
              lm                       != 0  &&
!             lm->get_source_view_id() == current_view_.get_id())
          {
              gu_trace((void)local_insts.insert_unique(
!                          make_pair(uuid, input_map_.get_range(inst.get_index()))));
          }
      }
  
!     const MessageNodeList& m_insts = msg.get_node_list();
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& m_uuid(MessageNodeList::get_key(i));
!         const MessageNode& m_inst(MessageNodeList::get_value(i));
!         if (m_inst.get_operational() == false &&
!             m_inst.get_leaving()     == true &&
!             m_inst.get_view_id()     == current_view_.get_id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          make_pair(m_uuid, m_inst.get_im_range())));
          }
      }
  
--- 356,387 ----
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::key(i));
!         const Node& inst(NodeMap::value(i));
!         const LeaveMessage* lm(inst.leave_message());
  
!         if (inst.operational()   == false &&
              lm                       != 0  &&
!             lm->source_view_id() == current_view_.id())
          {
              gu_trace((void)local_insts.insert_unique(
!                          std::make_pair(uuid, input_map_.range(inst.index()))));
          }
      }
  
!     const MessageNodeList& m_insts = msg.node_list();
  
      for (MessageNodeList::const_iterator i = m_insts.begin();
           i != m_insts.end(); ++i)
      {
!         const UUID& m_uuid(MessageNodeList::key(i));
!         const MessageNode& m_inst(MessageNodeList::value(i));
!         if (m_inst.operational() == false &&
!             m_inst.leaving()     == true &&
!             m_inst.view_id()     == current_view_.id())
          {
              gu_trace((void)msg_insts.insert_unique(
!                          std::make_pair(m_uuid, m_inst.im_range())));
          }
      }
  
***************
*** 395,403 ****
  
  bool gcomm::evs::Consensus::is_consistent_same_view(const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(msg.get_source_view_id() == current_view_.get_id());
  
      if (is_consistent_highest_reachable_safe_seq(msg) == false)
      {
--- 393,401 ----
  
  bool gcomm::evs::Consensus::is_consistent_same_view(const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
      if (is_consistent_highest_reachable_safe_seq(msg) == false)
      {
***************
*** 430,445 ****
  
  bool gcomm::evs::Consensus::is_consistent(const Message& msg) const
  {
!     gcomm_assert(msg.get_type() == Message::T_JOIN ||
!                  msg.get_type() == Message::T_INSTALL);
  
      const JoinMessage* my_jm =
!         NodeMap::get_value(known_.find_checked(get_uuid())).get_join_message();
      if (my_jm == 0)
      {
          return false;
      }
!     if (msg.get_source_view_id() == current_view_.get_id())
      {
          return (is_consistent_same_view(msg) == true &&
                  equal(msg, *my_jm) == true);
--- 428,443 ----
  
  bool gcomm::evs::Consensus::is_consistent(const Message& msg) const
  {
!     gcomm_assert(msg.type() == Message::T_JOIN ||
!                  msg.type() == Message::T_INSTALL);
  
      const JoinMessage* my_jm =
!         NodeMap::value(known_.find_checked(uuid())).join_message();
      if (my_jm == 0)
      {
          return false;
      }
!     if (msg.source_view_id() == current_view_.id())
      {
          return (is_consistent_same_view(msg) == true &&
                  equal(msg, *my_jm) == true);
***************
*** 453,459 ****
  bool gcomm::evs::Consensus::is_consensus() const
  {
      const JoinMessage* my_jm =
!         NodeMap::get_value(known_.find_checked(get_uuid())).get_join_message();
  
      if (my_jm == 0)
      {
--- 451,457 ----
  bool gcomm::evs::Consensus::is_consensus() const
  {
      const JoinMessage* my_jm =
!         NodeMap::value(known_.find_checked(uuid())).join_message();
  
      if (my_jm == 0)
      {
***************
*** 469,482 ****
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const Node& inst(NodeMap::get_value(i));
!         if (inst.get_operational() == true)
          {
!             const JoinMessage* jm = inst.get_join_message();
              if (jm == 0)
              {
                  evs_log_debug(D_CONSENSUS)
!                     << "no join message for " << NodeMap::get_key(i);
                  return false;
              }
              // call is_consistent() instead of equal() to enforce strict
--- 467,480 ----
  
      for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const Node& inst(NodeMap::value(i));
!         if (inst.operational() == true)
          {
!             const JoinMessage* jm = inst.join_message();
              if (jm == 0)
              {
                  evs_log_debug(D_CONSENSUS)
!                     << "no join message for " << NodeMap::key(i);
                  return false;
              }
              // call is_consistent() instead of equal() to enforce strict
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_consensus.hpp 2.x/gcomm/src/evs_consensus.hpp
*** galera-23.2.2-src/gcomm/src/evs_consensus.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_consensus.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 25,33 ****
                const NodeMap&  known,
                const InputMap& input_map,
                const View&     current_view) :
!         uuid_(uuid),
!         known_(known),
!         input_map_(input_map),
          current_view_(current_view)
      { }
  
--- 25,33 ----
                const NodeMap&  known,
                const InputMap& input_map,
                const View&     current_view) :
!         uuid_        (uuid),
!         known_       (known),
!         input_map_   (input_map),
          current_view_(current_view)
      { }
  
***************
*** 61,70 ****
      bool is_consensus() const;
  private:
  
!     const UUID& get_uuid() const { return uuid_; }
  
!     const UUID& uuid_;
!     const NodeMap& known_;
      const InputMap& input_map_;
!     const View& current_view_;
  };
--- 61,70 ----
      bool is_consensus() const;
  private:
  
!     const UUID& uuid() const { return uuid_; }
  
!     const UUID&     uuid_;
!     const NodeMap&  known_;
      const InputMap& input_map_;
!     const View&     current_view_;
  };
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_input_map2.cpp 2.x/gcomm/src/evs_input_map2.cpp
*** galera-23.2.2-src/gcomm/src/evs_input_map2.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_input_map2.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 11,20 ****
  #include <stdexcept>
  #include <numeric>
  
- using namespace gu;
- using namespace std;
- using namespace std::rel_ops;
- 
  
  //////////////////////////////////////////////////////////////////////////
  //
--- 11,16 ----
***************
*** 31,37 ****
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
  
!         return (a.get_range().get_lu() < b.get_range().get_lu());
      }
  };
  
--- 27,33 ----
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
  
!         return (a.range().lu() < b.range().lu());
      }
  };
  
***************
*** 41,47 ****
      bool operator()(const gcomm::evs::InputMapNodeIndex::value_type& a,
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
!         return (a.get_range().get_hs() < b.get_range().get_hs());
      }
  };
  
--- 37,43 ----
      bool operator()(const gcomm::evs::InputMapNodeIndex::value_type& a,
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
!         return (a.range().hs() < b.range().hs());
      }
  };
  
***************
*** 53,59 ****
      bool operator()(const gcomm::evs::InputMapNodeIndex::value_type& a,
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
!         return a.get_safe_seq() < b.get_safe_seq();
      }
  };
  
--- 49,55 ----
      bool operator()(const gcomm::evs::InputMapNodeIndex::value_type& a,
                      const gcomm::evs::InputMapNodeIndex::value_type& b) const
      {
!         return a.safe_seq() < b.safe_seq();
      }
  };
  
***************
*** 68,104 ****
  //////////////////////////////////////////////////////////////////////////
  
  
! ostream& gcomm::evs::operator<<(ostream& os, const InputMapNode& in)
  {
      return (os << "node: {"
!             << "idx="      << in.get_index()    << ","
!             << "range="    << in.get_range()    << ","
!             << "safe_seq=" << in.get_safe_seq() << "}");
  }
  
! ostream& gcomm::evs::operator<<(ostream& os, const InputMapNodeIndex& ni)
  {
!     copy(ni.begin(), ni.end(), ostream_iterator<const InputMapNode>(os, " "));
      return os;
  }
  
! ostream& gcomm::operator<<(ostream& os, const InputMapMsgKey& mk)
  {
!     return (os << "(" << mk.get_index() << "," << mk.get_seq() << ")");
  }
  
  
! ostream& gcomm::evs::operator<<(ostream& os, const InputMapMsg& m)
  {
!     return (os << m.get_msg());
  }
  
  
! ostream& gcomm::evs::operator<<(ostream& os, const InputMap& im)
  {
      return (os << "evs::input_map: {"
!             << "aru_seq="        << im.get_aru_seq()   << ","
!             << "safe_seq="       << im.get_safe_seq()  << ","
              << "node_index="     << *im.node_index_     << ","
              << "msg_index="      << *im.msg_index_      << ","
              << "recovery_index=" << *im.recovery_index_ << "}");
--- 64,100 ----
  //////////////////////////////////////////////////////////////////////////
  
  
! std::ostream& gcomm::evs::operator<<(std::ostream& os, const InputMapNode& in)
  {
      return (os << "node: {"
!             << "idx="      << in.index()    << ","
!             << "range="    << in.range()    << ","
!             << "safe_seq=" << in.safe_seq() << "}");
  }
  
! std::ostream& gcomm::evs::operator<<(std::ostream& os, const InputMapNodeIndex& ni)
  {
!     copy(ni.begin(), ni.end(), std::ostream_iterator<const InputMapNode>(os, " "));
      return os;
  }
  
! std::ostream& gcomm::operator<<(std::ostream& os, const InputMapMsgKey& mk)
  {
!     return (os << "(" << mk.index() << "," << mk.seq() << ")");
  }
  
  
! std::ostream& gcomm::evs::operator<<(std::ostream& os, const InputMapMsg& m)
  {
!     return (os << m.msg());
  }
  
  
! std::ostream& gcomm::evs::operator<<(std::ostream& os, const InputMap& im)
  {
      return (os << "evs::input_map: {"
!             << "aru_seq="        << im.aru_seq()   << ","
!             << "safe_seq="       << im.safe_seq()  << ","
              << "node_index="     << *im.node_index_     << ","
              << "msg_index="      << *im.msg_index_      << ","
              << "recovery_index=" << *im.recovery_index_ << "}");
***************
*** 164,189 ****
  
  
  
! gcomm::evs::seqno_t gcomm::evs::InputMap::get_min_hs() const
      throw (gu::Exception)
  {
      seqno_t ret;
      gcomm_assert(node_index_->empty() == false);
      ret = min_element(node_index_->begin(),
                        node_index_->end(),
!                       NodeIndexHSCmpOp())->get_range().get_hs();
      return ret;
  }
  
  
! gcomm::evs::seqno_t gcomm::evs::InputMap::get_max_hs() const
      throw (gu::Exception)
  {
      seqno_t ret;
      gcomm_assert(node_index_->empty() == false);
      ret = max_element(node_index_->begin(),
                        node_index_->end(),
!                       NodeIndexHSCmpOp())->get_range().get_hs();
      return ret;
  }
  
--- 160,185 ----
  
  
  
! gcomm::evs::seqno_t gcomm::evs::InputMap::min_hs() const
      throw (gu::Exception)
  {
      seqno_t ret;
      gcomm_assert(node_index_->empty() == false);
      ret = min_element(node_index_->begin(),
                        node_index_->end(),
!                       NodeIndexHSCmpOp())->range().hs();
      return ret;
  }
  
  
! gcomm::evs::seqno_t gcomm::evs::InputMap::max_hs() const
      throw (gu::Exception)
  {
      seqno_t ret;
      gcomm_assert(node_index_->empty() == false);
      ret = max_element(node_index_->begin(),
                        node_index_->end(),
!                       NodeIndexHSCmpOp())->range().hs();
      return ret;
  }
  
***************
*** 201,208 ****
      // Update node safe seq. Must (at least should) be updated
      // in monotonically increasing order if node works ok.
      InputMapNode& node(node_index_->at(uuid));
!     gcomm_assert(seq >= node.get_safe_seq())
!         << "node.safe_seq=" << node.get_safe_seq()
          << " seq=" << seq;
      node.set_safe_seq(seq);
  
--- 197,204 ----
      // Update node safe seq. Must (at least should) be updated
      // in monotonically increasing order if node works ok.
      InputMapNode& node(node_index_->at(uuid));
!     gcomm_assert(seq >= node.safe_seq())
!         << "node.safe_seq=" << node.safe_seq()
          << " seq=" << seq;
      node.set_safe_seq(seq);
  
***************
*** 210,216 ****
      InputMapNodeIndex::const_iterator min =
          min_element(node_index_->begin(), node_index_->end(),
                      NodeIndexSafeSeqCmpOp());
!     const seqno_t minval = min->get_safe_seq();
      gcomm_assert(minval >= safe_seq_);
      safe_seq_ = minval;
  
--- 206,212 ----
      InputMapNodeIndex::const_iterator min =
          min_element(node_index_->begin(), node_index_->end(),
                      NodeIndexSafeSeqCmpOp());
!     const seqno_t minval = min->safe_seq();
      gcomm_assert(minval >= safe_seq_);
      safe_seq_ = minval;
  
***************
*** 251,328 ****
      Range range;
  
      // Only insert messages with meaningful seqno
!     gcomm_assert(msg.get_seq() > -1);
  
      // User should check aru_seq before inserting. This check is left
      // also in optimized builds since violating it may cause duplicate
      // messages.
!     gcomm_assert(aru_seq_ < msg.get_seq())
!         << "aru seq " << aru_seq_ << " msg seq " << msg.get_seq()
          << " index size " << msg_index_->size();
  
      gcomm_assert(uuid < node_index_->size());
      InputMapNode& node((*node_index_)[uuid]);
!     range = node.get_range();
  
      // User should check LU before inserting. This check is left
      // also in optimized builds since violating it may cause duplicate
      // messages
!     gcomm_assert(range.get_lu() <= msg.get_seq())
!         << "lu " << range.get_lu() << " > "
!         << msg.get_seq();
  
      // Check whether this message has already been seen
!     if (msg.get_seq() < node.get_range().get_lu() ||
!         (msg.get_seq() <= node.get_range().get_hs() &&
!          recovery_index_->find(InputMapMsgKey(node.get_index(), msg.get_seq())) !=
           recovery_index_->end()))
      {
!         return node.get_range();
      }
  
      // Loop over message seqno range and insert messages when not
      // already found
!     for (seqno_t s = msg.get_seq(); s <= msg.get_seq() + msg.get_seq_range(); ++s)
      {
          InputMapMsgIndex::iterator msg_i;
  
!         if (range.get_hs() < s)
          {
              msg_i = msg_index_->end();
          }
          else
          {
!             msg_i = msg_index_->find(InputMapMsgKey(node.get_index(), s));
          }
  
          if (msg_i == msg_index_->end())
          {
!             Datagram ins_dg(s == msg.get_seq() ?
!                             Datagram(rb)       :
!                             Datagram());
              gu_trace((void)msg_index_->insert_unique(
!                          make_pair(InputMapMsgKey(node.get_index(), s),
!                                    InputMapMsg(
!                                        (s == msg.get_seq() ?
!                                         msg :
!                                         UserMessage(msg.get_version(),
!                                                     msg.get_source(),
!                                                     msg.get_source_view_id(),
!                                                     s,
!                                                     msg.get_aru_seq(),
!                                                     0,
!                                                     O_DROP)), ins_dg))));
!             ++n_msgs_[msg.get_order()];
          }
  
          // Update highest seen
!         if (range.get_hs() < s)
          {
              range.set_hs(s);
          }
  
          // Update lowest unseen
!         if (range.get_lu() == s)
          {
              seqno_t i(s);
              do
--- 247,325 ----
      Range range;
  
      // Only insert messages with meaningful seqno
!     gcomm_assert(msg.seq() > -1);
  
      // User should check aru_seq before inserting. This check is left
      // also in optimized builds since violating it may cause duplicate
      // messages.
!     gcomm_assert(aru_seq_ < msg.seq())
!         << "aru seq " << aru_seq_ << " msg seq " << msg.seq()
          << " index size " << msg_index_->size();
  
      gcomm_assert(uuid < node_index_->size());
      InputMapNode& node((*node_index_)[uuid]);
!     range = node.range();
  
      // User should check LU before inserting. This check is left
      // also in optimized builds since violating it may cause duplicate
      // messages
!     gcomm_assert(range.lu() <= msg.seq())
!         << "lu " << range.lu() << " > "
!         << msg.seq();
  
      // Check whether this message has already been seen
!     if (msg.seq() < node.range().lu() ||
!         (msg.seq() <= node.range().hs() &&
!          recovery_index_->find(InputMapMsgKey(node.index(), msg.seq())) !=
           recovery_index_->end()))
      {
!         return node.range();
      }
  
      // Loop over message seqno range and insert messages when not
      // already found
!     for (seqno_t s = msg.seq(); s <= msg.seq() + msg.seq_range(); ++s)
      {
          InputMapMsgIndex::iterator msg_i;
  
!         if (range.hs() < s)
          {
              msg_i = msg_index_->end();
          }
          else
          {
!             msg_i = msg_index_->find(InputMapMsgKey(node.index(), s));
          }
  
          if (msg_i == msg_index_->end())
          {
!             Datagram ins_dg(s == msg.seq() ?
!                                 Datagram(rb)   :
!                                 Datagram());
              gu_trace((void)msg_index_->insert_unique(
!                          std::make_pair(
!                              InputMapMsgKey(node.index(), s),
!                              InputMapMsg(
!                                  (s == msg.seq() ?
!                                   msg :
!                                   UserMessage(msg.version(),
!                                               msg.source(),
!                                               msg.source_view_id(),
!                                               s,
!                                               msg.aru_seq(),
!                                               0,
!                                               O_DROP)), ins_dg))));
!             ++n_msgs_[msg.order()];
          }
  
          // Update highest seen
!         if (range.hs() < s)
          {
              range.set_hs(s);
          }
  
          // Update lowest unseen
!         if (range.lu() == s)
          {
              seqno_t i(s);
              do
***************
*** 330,339 ****
                  ++i;
              }
              while (
!                 i <= range.get_hs() &&
!                 (msg_index_->find(InputMapMsgKey(node.get_index(), i))
                   != msg_index_->end() ||
!                  recovery_index_->find(InputMapMsgKey(node.get_index(), i))
                   != recovery_index_->end()));
              range.set_lu(i);
          }
--- 327,336 ----
                  ++i;
              }
              while (
!                 i <= range.hs() &&
!                 (msg_index_->find(InputMapMsgKey(node.index(), i))
                   != msg_index_->end() ||
!                  recovery_index_->find(InputMapMsgKey(node.index(), i))
                   != recovery_index_->end()));
              range.set_lu(i);
          }
***************
*** 348,355 ****
  void gcomm::evs::InputMap::erase(iterator i)
      throw (gu::Exception)
  {
!     const UserMessage& msg(InputMapMsgIndex::get_value(i).get_msg());
!     --n_msgs_[msg.get_order()];
      gu_trace(recovery_index_->insert_unique(*i));
      gu_trace(msg_index_->erase(i));
  }
--- 345,352 ----
  void gcomm::evs::InputMap::erase(iterator i)
      throw (gu::Exception)
  {
!     const UserMessage& msg(InputMapMsgIndex::value(i).msg());
!     --n_msgs_[msg.order()];
      gu_trace(recovery_index_->insert_unique(*i));
      gu_trace(msg_index_->erase(i));
  }
***************
*** 361,367 ****
  {
      iterator ret;
      const InputMapNode& node(node_index_->at(uuid));
!     const InputMapMsgKey key(node.get_index(), seq);
      gu_trace(ret = msg_index_->find(key));
      return ret;
  }
--- 358,364 ----
  {
      iterator ret;
      const InputMapNode& node(node_index_->at(uuid));
!     const InputMapMsgKey key(node.index(), seq);
      gu_trace(ret = msg_index_->find(key));
      return ret;
  }
***************
*** 373,379 ****
  {
      iterator ret;
      const InputMapNode& node(node_index_->at(uuid));
!     const InputMapMsgKey key(node.get_index(), seq);
      gu_trace(ret = recovery_index_->find_checked(key));
      return ret;
  }
--- 370,376 ----
  {
      iterator ret;
      const InputMapNode& node(node_index_->at(uuid));
!     const InputMapMsgKey key(node.index(), seq);
      gu_trace(ret = recovery_index_->find_checked(key));
      return ret;
  }
***************
*** 393,399 ****
      InputMapNodeIndex::const_iterator min =
          min_element(node_index_->begin(), node_index_->end(), NodeIndexLUCmpOp());
  
!     const seqno_t minval = min->get_range().get_lu();
      /* aru_seq must not decrease */
      gcomm_assert(minval - 1 >= aru_seq_);
      aru_seq_ = minval - 1;
--- 390,396 ----
      InputMapNodeIndex::const_iterator min =
          min_element(node_index_->begin(), node_index_->end(), NodeIndexLUCmpOp());
  
!     const seqno_t minval = min->range().lu();
      /* aru_seq must not decrease */
      gcomm_assert(minval - 1 >= aru_seq_);
      aru_seq_ = minval - 1;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_input_map2.hpp 2.x/gcomm/src/evs_input_map2.hpp
*** galera-23.2.2-src/gcomm/src/evs_input_map2.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_input_map2.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 19,30 ****
  #ifndef EVS_INPUT_MAP2_HPP
  #define EVS_INPUT_MAP2_HPP
  
- #include "gu_datagram.hpp"
- 
  #include "evs_message2.hpp"
  #include "gcomm/map.hpp"
  
  #include <boost/pool/pool_alloc.hpp>
  
  #include <vector>
  
--- 19,31 ----
  #ifndef EVS_INPUT_MAP2_HPP
  #define EVS_INPUT_MAP2_HPP
  
  #include "evs_message2.hpp"
  #include "gcomm/map.hpp"
+ #include "gcomm/datagram.hpp"
  
+ #if defined(GALERA_USE_BOOST_POOL_ALLOC)
  #include <boost/pool/pool_alloc.hpp>
+ #endif
  
  #include <vector>
  
***************
*** 57,64 ****
          seq_   (seq)
      { }
  
!     size_t       get_index() const { return index_; }
!     evs::seqno_t get_seq  () const { return seq_;   }
  
      bool operator<(const InputMapMsgKey& cmp) const
      {
--- 58,65 ----
          seq_   (seq)
      { }
  
!     size_t       index() const { return index_; }
!     evs::seqno_t seq  () const { return seq_;   }
  
      bool operator<(const InputMapMsgKey& cmp) const
      {
***************
*** 76,105 ****
  class gcomm::evs::InputMapMsg
  {
  public:
!     InputMapMsg(const UserMessage&       msg_,
!                 const gu::Datagram& rb_   ) :
!         msg  (msg_ ),
!         rb   (rb_  )
!     { }
! 
!     InputMapMsg(const InputMapMsg& m) :
!         msg  (m.msg ),
!         rb   (m.rb  )
      { }
! 
      ~InputMapMsg() { }
  
!     const UserMessage& get_msg () const { return msg;  }
!     const gu::Datagram&    get_rb  () const { return rb;   }
  private:
      void operator=(const InputMapMsg&);
  
!     UserMessage const msg;
!     gu::Datagram rb;
  };
  
  
! #if 1
  
  class DummyMutex
  {
--- 77,102 ----
  class gcomm::evs::InputMapMsg
  {
  public:
!     InputMapMsg(const UserMessage&  msg,
!                 const Datagram&     rb)
!         :
!         msg_(msg),
!         rb_ (rb)
      { }
!     InputMapMsg(const InputMapMsg& m) : msg_(m.msg_), rb_ (m.rb_) { }
      ~InputMapMsg() { }
  
!     const UserMessage&  msg () const { return msg_;  }
!     const Datagram& rb  () const { return rb_;   }
  private:
      void operator=(const InputMapMsg&);
  
!     UserMessage const msg_;
!     Datagram          rb_;
  };
  
  
! #if defined(GALERA_USE_BOOST_POOL_ALLOC)
  
  class DummyMutex
  {
***************
*** 118,124 ****
                              boost::default_user_allocator_new_delete,
                              DummyMutex> > >
  { };
! #else
  
  class gcomm::evs::InputMapMsgIndex :
      public Map<InputMapMsgKey, InputMapMsg> { };
--- 115,122 ----
                              boost::default_user_allocator_new_delete,
                              DummyMutex> > >
  { };
! 
! #else /* GALERA_USE_BOOST_POOL_ALLOC */
  
  class gcomm::evs::InputMapMsgIndex :
      public Map<InputMapMsgKey, InputMapMsg> { };
***************
*** 127,133 ****
  //                        std::less<InputMapMsgKey>,
  //                        boost::fast_pool_allocator<
  //                            std::pair<const InputMapMsgKey, InputMapMsg> > > >
! #endif // 0
  
  /* Internal node representation */
  class gcomm::evs::InputMapNode
--- 125,131 ----
  //                        std::less<InputMapMsgKey>,
  //                        boost::fast_pool_allocator<
  //                            std::pair<const InputMapMsgKey, InputMapMsg> > > >
! #endif /* GALERA_USE_BOOST_POOL_ALLOC */
  
  /* Internal node representation */
  class gcomm::evs::InputMapNode
***************
*** 139,147 ****
      void   set_safe_seq  (const seqno_t s)       { safe_seq_  = s; }
      void   set_index     (const size_t  i)       { idx_       = i; }
  
!     Range   get_range     ()               const { return range_;     }
!     seqno_t get_safe_seq  ()               const { return safe_seq_;  }
!     size_t  get_index     ()               const { return idx_;       }
  
  private:
      size_t  idx_;
--- 137,145 ----
      void   set_safe_seq  (const seqno_t s)       { safe_seq_  = s; }
      void   set_index     (const size_t  i)       { idx_       = i; }
  
!     Range   range     ()               const { return range_;     }
!     seqno_t safe_seq  ()               const { return safe_seq_;  }
!     size_t  index     ()               const { return idx_;       }
  
  private:
      size_t  idx_;
***************
*** 180,193 ****
       *
       * @return Current value of aru_seq
       */
!     seqno_t get_aru_seq () const { return aru_seq_;  }
  
      /*!
       * Get current value of safe_seq.
       *
       * @return Current value of safe_seq
       */
!     seqno_t get_safe_seq() const { return safe_seq_; }
  
      /*!
       * Set sequence number safe for node.
--- 178,191 ----
       *
       * @return Current value of aru_seq
       */
!     seqno_t aru_seq () const { return aru_seq_;  }
  
      /*!
       * Get current value of safe_seq.
       *
       * @return Current value of safe_seq
       */
!     seqno_t safe_seq() const { return safe_seq_; }
  
      /*!
       * Set sequence number safe for node.
***************
*** 210,219 ****
       *
       * @throws FatalException if node was not found
       */
!     seqno_t get_safe_seq(const size_t uuid) const
          throw (gu::Exception)
      {
!         return node_index_->at(uuid).get_safe_seq();
      }
  
      /*!
--- 208,217 ----
       *
       * @throws FatalException if node was not found
       */
!     seqno_t safe_seq(const size_t uuid) const
          throw (gu::Exception)
      {
!         return node_index_->at(uuid).safe_seq();
      }
  
      /*!
***************
*** 225,240 ****
       *
       * @throws FatalException if node was not found
       */
!     Range get_range   (const size_t uuid) const
          throw (gu::Exception)
      {
!         return node_index_->at(uuid).get_range();
      }
  
!     seqno_t get_min_hs() const
          throw (gu::Exception);
  
!     seqno_t get_max_hs() const
          throw (gu::Exception);
  
      /*!
--- 223,238 ----
       *
       * @throws FatalException if node was not found
       */
!     Range range   (const size_t uuid) const
          throw (gu::Exception)
      {
!         return node_index_->at(uuid).range();
      }
  
!     seqno_t min_hs() const
          throw (gu::Exception);
  
!     seqno_t max_hs() const
          throw (gu::Exception);
  
      /*!
***************
*** 259,265 ****
      bool is_safe  (iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::get_key(i).get_seq());
          return (seq <= safe_seq_);
      }
  
--- 257,263 ----
      bool is_safe  (iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::key(i).seq());
          return (seq <= safe_seq_);
      }
  
***************
*** 271,277 ****
      bool is_agreed(iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::get_key(i).get_seq());
          return (seq <= aru_seq_);
      }
  
--- 269,275 ----
      bool is_agreed(iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::key(i).seq());
          return (seq <= aru_seq_);
      }
  
***************
*** 283,292 ****
      bool is_fifo  (iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::get_key(i).get_seq());
          const InputMapNode& node((*node_index_)[
!                                      InputMapMsgIndex::get_key(i).get_index()]);
!         return (node.get_range().get_lu() > seq);
      }
  
      bool has_deliverables() const
--- 281,290 ----
      bool is_fifo  (iterator i) const
          throw (gu::Exception)
      {
!         const seqno_t seq(InputMapMsgIndex::key(i).seq());
          const InputMapNode& node((*node_index_)[
!                                      InputMapMsgIndex::key(i).index()]);
!         return (node.range().lu() > seq);
      }
  
      bool has_deliverables() const
***************
*** 323,329 ****
       *         number is out of allowed range
       */
      Range insert(const size_t uuid, const UserMessage& msg,
!                  const gu::Datagram& dg = gu::Datagram())
          throw (gu::Exception);
  
      /*!
--- 321,327 ----
       *         number is out of allowed range
       */
      Range insert(const size_t uuid, const UserMessage& msg,
!                  const Datagram& dg = Datagram())
          throw (gu::Exception);
  
      /*!
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_message2.cpp 2.x/gcomm/src/evs_message2.cpp
*** galera-23.2.2-src/gcomm/src/evs_message2.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_message2.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 9,60 ****
  #include "gu_exception.hpp"
  #include "gu_logger.hpp"
  
- using namespace std;
- using namespace std::rel_ops;
  
! using namespace gu;
! 
! ostream& gcomm::evs::operator<<(ostream& os, const gcomm::evs::MessageNode& node)
  {
      os << "node: {";
!     os << "operational=" << node.get_operational() << ",";
!     os << "suspected=" << node.get_suspected() << ",";
!     os << "leave_seq=" << node.get_leave_seq() << ",";
!     os << "view_id=" << node.get_view_id() << ",";
!     os << "safe_seq=" << node.get_safe_seq() << ",";
!     os << "im_range=" << node.get_im_range() << ",";
      os << "}";
      return os;
  }
  
! ostream& gcomm::evs::operator<<(ostream& os, const gcomm::evs::Message& msg)
  {
      os << "evs::msg{";
!     os << "version=" << static_cast<int>(msg.get_version()) << ",";
!     os << "type=" << msg.get_type() << ",";
!     os << "user_type=" << static_cast<int>(msg.get_user_type()) << ",";
!     os << "order=" << msg.get_order() << ",";
!     os << "seq=" << msg.get_seq() << ",";
!     os << "seq_range=" << msg.get_seq_range() << ",";
!     os << "aru_seq=" << msg.get_aru_seq() << ",";
!     os << "flags=" << static_cast<int>(msg.get_flags()) << ",";
!     os << "source=" << msg.get_source() << ",";
!     os << "source_view_id=" << msg.get_source_view_id() << ",";
!     os << "range_uuid=" << msg.get_range_uuid() << ",";
!     os << "range=" << msg.get_range() << ",";
!     os << "fifo_seq=" << msg.get_fifo_seq() << ",";
!     os << "node_list=(" << msg.get_node_list() << ")\n";
      os << "}";
      return os;
  }
  
! size_t gcomm::evs::MessageNode::serialize(byte_t* const buf,
!                                           size_t  const buflen,
!                                           size_t        offset) const
      throw(gu::Exception)
  {
!     uint8_t b = 
!         static_cast<uint8_t>((operational_ == true ? F_OPERATIONAL : 0) | 
                               (suspected_   == true ? F_SUSPECTED   : 0));
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
      uint8_t pad(0);
--- 9,58 ----
  #include "gu_exception.hpp"
  #include "gu_logger.hpp"
  
  
! std::ostream&
! gcomm::evs::operator<<(std::ostream& os, const gcomm::evs::MessageNode& node)
  {
      os << "node: {";
!     os << "operational=" << node.operational() << ",";
!     os << "suspected=" << node.suspected() << ",";
!     os << "leave_seq=" << node.leave_seq() << ",";
!     os << "view_id=" << node.view_id() << ",";
!     os << "safe_seq=" << node.safe_seq() << ",";
!     os << "im_range=" << node.im_range() << ",";
      os << "}";
      return os;
  }
  
! std::ostream&
! gcomm::evs::operator<<(std::ostream& os, const gcomm::evs::Message& msg)
  {
      os << "evs::msg{";
!     os << "version=" << static_cast<int>(msg.version()) << ",";
!     os << "type=" << msg.type() << ",";
!     os << "user_type=" << static_cast<int>(msg.user_type()) << ",";
!     os << "order=" << msg.order() << ",";
!     os << "seq=" << msg.seq() << ",";
!     os << "seq_range=" << msg.seq_range() << ",";
!     os << "aru_seq=" << msg.aru_seq() << ",";
!     os << "flags=" << static_cast<int>(msg.flags()) << ",";
!     os << "source=" << msg.source() << ",";
!     os << "source_view_id=" << msg.source_view_id() << ",";
!     os << "range_uuid=" << msg.range_uuid() << ",";
!     os << "range=" << msg.range() << ",";
!     os << "fifo_seq=" << msg.fifo_seq() << ",";
!     os << "node_list=(" << msg.node_list() << ")\n";
      os << "}";
      return os;
  }
  
! size_t gcomm::evs::MessageNode::serialize(gu::byte_t* const buf,
!                                           size_t      const buflen,
!                                           size_t            offset) const
      throw(gu::Exception)
  {
!     uint8_t b =
!         static_cast<uint8_t>((operational_ == true ? F_OPERATIONAL : 0) |
                               (suspected_   == true ? F_SUSPECTED   : 0));
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
      uint8_t pad(0);
***************
*** 62,75 ****
      gu_trace(offset = gu::serialize8(leave_seq_, buf, buflen, offset));
      gu_trace(offset = view_id_.serialize(buf, buflen, offset));
      gu_trace(offset = gu::serialize8(safe_seq_, buf, buflen, offset));
!     gu_trace(offset = im_range_.serialize(buf, buflen, offset));    
      return offset;
  }
  
  
! size_t gcomm::evs::MessageNode::unserialize(const byte_t* const buf,
!                                             size_t        const buflen,
!                                             size_t              offset)
      throw(gu::Exception)
  {
      uint8_t b;
--- 60,73 ----
      gu_trace(offset = gu::serialize8(leave_seq_, buf, buflen, offset));
      gu_trace(offset = view_id_.serialize(buf, buflen, offset));
      gu_trace(offset = gu::serialize8(safe_seq_, buf, buflen, offset));
!     gu_trace(offset = im_range_.serialize(buf, buflen, offset));
      return offset;
  }
  
  
! size_t gcomm::evs::MessageNode::unserialize(const gu::byte_t* const buf,
!                                             size_t            const buflen,
!                                             size_t                  offset)
      throw(gu::Exception)
  {
      uint8_t b;
***************
*** 80,86 ****
      }
      operational_ = b & F_OPERATIONAL;
      suspected_   = b & F_SUSPECTED;
!     
      uint8_t pad(0);
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, pad));
      if (pad != 0)
--- 78,84 ----
      }
      operational_ = b & F_OPERATIONAL;
      suspected_   = b & F_SUSPECTED;
! 
      uint8_t pad(0);
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, pad));
      if (pad != 0)
***************
*** 90,96 ****
      gu_trace(offset = gu::unserialize8(buf, buflen, offset, leave_seq_));
      gu_trace(offset = view_id_.unserialize(buf, buflen, offset));
      gu_trace(offset = gu::unserialize8(buf, buflen, offset, safe_seq_));
!     gu_trace(offset = im_range_.unserialize(buf, buflen, offset));    
      return offset;
  }
  
--- 88,94 ----
      gu_trace(offset = gu::unserialize8(buf, buflen, offset, leave_seq_));
      gu_trace(offset = view_id_.unserialize(buf, buflen, offset));
      gu_trace(offset = gu::unserialize8(buf, buflen, offset, safe_seq_));
!     gu_trace(offset = im_range_.unserialize(buf, buflen, offset));
      return offset;
  }
  
***************
*** 98,178 ****
  {
      return 2 +                  // 4 bytes reserved for flags
          sizeof(seqno_t) +
!         ViewId::serial_size() + 
!         sizeof(seqno_t) + 
          Range::serial_size();
  }
  
  
  bool gcomm::evs::Message::operator==(const Message& cmp) const
  {
!     return (version         == cmp.version         &&
!             type            == cmp.type            &&
!             user_type       == cmp.user_type       &&
!             order           == cmp.order           &&
!             seq             == cmp.seq             &&
!             seq_range       == cmp.seq_range       &&
!             aru_seq         == cmp.aru_seq         &&
!             fifo_seq        == cmp.fifo_seq        &&
!             flags           == cmp.flags           &&
!             source          == cmp.source          &&
!             source_view_id  == cmp.source_view_id  &&
!             install_view_id == cmp.install_view_id &&
!             range_uuid      == cmp.range_uuid      &&
!             range           == cmp.range           &&
!             node_list       == cmp.node_list);
  }
  
  
! size_t gcomm::evs::Message::serialize(byte_t* const buf, 
!                                       size_t  const buflen,
!                                       size_t        offset) const 
      throw(gu::Exception)
  {
!     
!     uint8_t b = static_cast<uint8_t>(version | (type << 2) | (order << 5));
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
!     gu_trace(offset = gu::serialize1(flags, buf, buflen, offset));
      uint16_t pad(0);
      gu_trace(offset = gu::serialize2(pad, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(fifo_seq, buf, buflen, offset));
!     if (flags & F_SOURCE)
      {
!         gu_trace(offset = source.serialize(buf, buflen, offset));
      }
!     gu_trace(offset = source_view_id.serialize(buf, buflen, offset));
      return offset;
  }
  
  
! size_t gcomm::evs::Message::unserialize(const byte_t* const buf, 
!                                         size_t        const buflen,
!                                         size_t              offset)
      throw(gu::Exception)
  {
      uint8_t b;
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, b));
!     
!     version = static_cast<uint8_t>(b & 0x3);
!     if (version != 0)
      {
!         gu_throw_error(EPROTONOSUPPORT) << "protocol version not supported: " << version;
      }
!     
!     type    = static_cast<Type>((b >> 2) & 0x7);
!     if (type <= T_NONE || type > T_LEAVE)
      {
!         gu_throw_error(EINVAL) << "invalid type " << type;
      }
!     
!     order = static_cast<Order>((b >> 5) & 0x7);
!     if (order < O_DROP || order > O_SAFE)
      {
!         gu_throw_error(EINVAL) << "invalid safety prefix " 
!                                     << order;
      }
  
!     gu_trace(offset = gu::unserialize1(buf, buflen, offset, flags));
  
      uint16_t pad;
      gu_trace(offset = gu::unserialize2(buf, buflen, offset, pad));
--- 96,177 ----
  {
      return 2 +                  // 4 bytes reserved for flags
          sizeof(seqno_t) +
!         ViewId::serial_size() +
!         sizeof(seqno_t) +
          Range::serial_size();
  }
  
  
  bool gcomm::evs::Message::operator==(const Message& cmp) const
  {
!     return (version_         == cmp.version_         &&
!             type_            == cmp.type_            &&
!             user_type_       == cmp.user_type_       &&
!             order_           == cmp.order_           &&
!             seq_             == cmp.seq_             &&
!             seq_range_       == cmp.seq_range_       &&
!             aru_seq_         == cmp.aru_seq_         &&
!             fifo_seq_        == cmp.fifo_seq_        &&
!             flags_           == cmp.flags_           &&
!             source_          == cmp.source_          &&
!             source_view_id_  == cmp.source_view_id_  &&
!             install_view_id_ == cmp.install_view_id_ &&
!             range_uuid_      == cmp.range_uuid_      &&
!             range_           == cmp.range_           &&
!             node_list_       == cmp.node_list_);
  }
  
  
! size_t gcomm::evs::Message::serialize(gu::byte_t* const buf,
!                                       size_t      const buflen,
!                                       size_t            offset) const
      throw(gu::Exception)
  {
! 
!     uint8_t b = static_cast<uint8_t>(version_ | (type_ << 2) | (order_ << 5));
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
!     gu_trace(offset = gu::serialize1(flags_, buf, buflen, offset));
      uint16_t pad(0);
      gu_trace(offset = gu::serialize2(pad, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(fifo_seq_, buf, buflen, offset));
!     if (flags_ & F_SOURCE)
      {
!         gu_trace(offset = source_.serialize(buf, buflen, offset));
      }
!     gu_trace(offset = source_view_id_.serialize(buf, buflen, offset));
      return offset;
  }
  
  
! size_t gcomm::evs::Message::unserialize(const gu::byte_t* const buf,
!                                         size_t            const buflen,
!                                         size_t                  offset)
      throw(gu::Exception)
  {
      uint8_t b;
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, b));
! 
!     version_ = static_cast<uint8_t>(b & 0x3);
!     if (version_ != 0)
      {
!         gu_throw_error(EPROTONOSUPPORT) << "protocol version not supported: "
!                                         << version_;
      }
! 
!     type_    = static_cast<Type>((b >> 2) & 0x7);
!     if (type_ <= T_NONE || type_ > T_LEAVE)
      {
!         gu_throw_error(EINVAL) << "invalid type " << type_;
      }
! 
!     order_ = static_cast<Order>((b >> 5) & 0x7);
!     if (order_ < O_DROP || order_ > O_SAFE)
      {
!         gu_throw_error(EINVAL) << "invalid safety prefix "
!                                     << order_;
      }
  
!     gu_trace(offset = gu::unserialize1(buf, buflen, offset, flags_));
  
      uint16_t pad;
      gu_trace(offset = gu::unserialize2(buf, buflen, offset, pad));
***************
*** 182,195 ****
          gu_throw_error(EINVAL) << "invalid pad" << pad;
      }
  
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, fifo_seq));
  
!     if (flags & F_SOURCE)
      {
!         gu_trace(offset = source.unserialize(buf, buflen, offset));
      }
!     
!     gu_trace(offset = source_view_id.unserialize(buf, buflen, offset));
  
      return offset;
  }
--- 181,194 ----
          gu_throw_error(EINVAL) << "invalid pad" << pad;
      }
  
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, fifo_seq_));
  
!     if (flags_ & F_SOURCE)
      {
!         gu_trace(offset = source_.unserialize(buf, buflen, offset));
      }
! 
!     gu_trace(offset = source_view_id_.unserialize(buf, buflen, offset));
  
      return offset;
  }
***************
*** 199,251 ****
      return (1 +                 // version | type | order
              1 +                 // flags
              2 +                 // pad
!             sizeof(fifo_seq) +  // fifo_seq
!             ((flags & F_SOURCE) ? UUID::serial_size() : 0) +
              ViewId::serial_size()); // source_view_id
  }
  
  
! size_t gcomm::evs::UserMessage::serialize(byte_t* const buf,
!                                           size_t  const buflen,
!                                           size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize1(user_type, buf, buflen, offset));
!     
!     gcomm_assert(seq_range <= seqno_t(0xff));
!     uint8_t b = static_cast<uint8_t>(seq_range);
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
      gu_trace(offset = gu::serialize2(uint16_t(0), buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq, buf, buflen, offset));
!     
      return offset;
  }
  
! size_t gcomm::evs::UserMessage::unserialize(const byte_t* const buf,
!                                             size_t        const buflen,
!                                             size_t              offset,
!                                             bool                skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize1(buf, buflen, offset, user_type));
      uint8_t b;
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, b));
!     seq_range = b;
      uint16_t pad;
      gu_trace(offset = gu::unserialize2(buf, buflen, offset, pad));
      if (pad != 0)
      {
          log_warn << "invalid pad: " << pad;
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq));
!     
      return offset;
  }
  
--- 198,250 ----
      return (1 +                 // version | type | order
              1 +                 // flags
              2 +                 // pad
!             sizeof(fifo_seq_) +  // fifo_seq
!             ((flags_ & F_SOURCE) ? UUID::serial_size() : 0) +
              ViewId::serial_size()); // source_view_id
  }
  
  
! size_t gcomm::evs::UserMessage::serialize(gu::byte_t* const buf,
!                                           size_t      const buflen,
!                                           size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize1(user_type_, buf, buflen, offset));
! 
!     gcomm_assert(seq_range_ <= seqno_t(0xff));
!     uint8_t b = static_cast<uint8_t>(seq_range_);
      gu_trace(offset = gu::serialize1(b, buf, buflen, offset));
      gu_trace(offset = gu::serialize2(uint16_t(0), buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq_, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq_, buf, buflen, offset));
! 
      return offset;
  }
  
! size_t gcomm::evs::UserMessage::unserialize(const gu::byte_t* const buf,
!                                             size_t            const buflen,
!                                             size_t                  offset,
!                                             bool                    skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize1(buf, buflen, offset, user_type_));
      uint8_t b;
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, b));
!     seq_range_ = b;
      uint16_t pad;
      gu_trace(offset = gu::unserialize2(buf, buflen, offset, pad));
      if (pad != 0)
      {
          log_warn << "invalid pad: " << pad;
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq_));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq_));
! 
      return offset;
  }
  
***************
*** 257,269 ****
          2 +                         // Pad/reserved
          sizeof(seqno_t) +           // Seq
          sizeof(seqno_t);            // Aru seq
!         
  }
  
  
! size_t gcomm::evs::AggregateMessage::serialize(byte_t* const buf,
!                                                size_t  const buflen,
!                                                size_t        offset) const
      throw (gu::Exception)
  {
      gu_trace(offset = gu::serialize1(flags_, buf, buflen, offset));
--- 256,268 ----
          2 +                         // Pad/reserved
          sizeof(seqno_t) +           // Seq
          sizeof(seqno_t);            // Aru seq
! 
  }
  
  
! size_t gcomm::evs::AggregateMessage::serialize(gu::byte_t* const buf,
!                                                size_t      const buflen,
!                                                size_t            offset) const
      throw (gu::Exception)
  {
      gu_trace(offset = gu::serialize1(flags_, buf, buflen, offset));
***************
*** 273,281 ****
  }
  
  
! size_t gcomm::evs::AggregateMessage::unserialize(const byte_t* const buf,
!                                                  size_t const buflen,
!                                                  size_t       offset)
      throw (gu::Exception)
  {
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, flags_));
--- 272,280 ----
  }
  
  
! size_t gcomm::evs::AggregateMessage::unserialize(const gu::byte_t* const buf,
!                                                  size_t            const buflen,
!                                                  size_t                  offset)
      throw (gu::Exception)
  {
      gu_trace(offset = gu::unserialize1(buf, buflen, offset, flags_));
***************
*** 286,309 ****
  
  size_t gcomm::evs::AggregateMessage::serial_size() const
  {
!     return sizeof(flags_) 
!          + sizeof(len_) 
           + sizeof(user_type_);
  }
  
! size_t gcomm::evs::DelegateMessage::serialize(byte_t* const buf,
!                                               size_t  const buflen,
!                                               size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::DelegateMessage::unserialize(const byte_t* const buf,
!                                                 size_t        const buflen,
!                                                 size_t              offset,
!                                                 bool                skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
--- 285,308 ----
  
  size_t gcomm::evs::AggregateMessage::serial_size() const
  {
!     return sizeof(flags_)
!          + sizeof(len_)
           + sizeof(user_type_);
  }
  
! size_t gcomm::evs::DelegateMessage::serialize(gu::byte_t* const buf,
!                                               size_t      const buflen,
!                                               size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::DelegateMessage::unserialize(const gu::byte_t* const buf,
!                                                 size_t            const buflen,
!                                                 size_t                  offset,
!                                                 bool                    skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
***************
*** 320,352 ****
  
  
  
! size_t gcomm::evs::GapMessage::serialize(byte_t* const buf,
!                                          size_t  const buflen,
!                                          size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq, buf, buflen, offset));
!     gu_trace(offset = range_uuid.serialize(buf, buflen, offset));
!     gu_trace(offset = range.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::GapMessage::unserialize(const byte_t* const buf,
!                                            size_t        const buflen,
!                                            size_t              offset,
!                                            bool                skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq));
!     gu_trace(offset = range_uuid.unserialize(buf, buflen, offset));
!     gu_trace(offset = range.unserialize(buf, buflen, offset));
      return offset;
  }
  
--- 319,351 ----
  
  
  
! size_t gcomm::evs::GapMessage::serialize(gu::byte_t* const buf,
!                                          size_t      const buflen,
!                                          size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq_, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq_, buf, buflen, offset));
!     gu_trace(offset = range_uuid_.serialize(buf, buflen, offset));
!     gu_trace(offset = range_.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::GapMessage::unserialize(const gu::byte_t* const buf,
!                                            size_t            const buflen,
!                                            size_t                  offset,
!                                            bool                    skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq_));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq_));
!     gu_trace(offset = range_uuid_.unserialize(buf, buflen, offset));
!     gu_trace(offset = range_.unserialize(buf, buflen, offset));
      return offset;
  }
  
***************
*** 354,389 ****
  {
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
!             + UUID::serial_size() 
              + Range::serial_size());
  }
  
! size_t gcomm::evs::JoinMessage::serialize(byte_t* const buf,
!                                           size_t  const buflen,
!                                           size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq, buf, buflen, offset));
!     gu_trace(offset = node_list.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::JoinMessage::unserialize(const byte_t* const buf,
!                                             size_t        const buflen,
!                                             size_t              offset,
!                                             bool                skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq));
!     node_list.clear();
!     gu_trace(offset = node_list.unserialize(buf, buflen, offset));
      return offset;
  }
  
--- 353,388 ----
  {
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
!             + UUID::serial_size()
              + Range::serial_size());
  }
  
! size_t gcomm::evs::JoinMessage::serialize(gu::byte_t* const buf,
!                                           size_t      const buflen,
!                                           size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq_, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq_, buf, buflen, offset));
!     gu_trace(offset = node_list_.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::JoinMessage::unserialize(const gu::byte_t* const buf,
!                                             size_t            const buflen,
!                                             size_t                  offset,
!                                             bool                    skip_header)
      throw(gu::Exception)
  {
      if (skip_header == false)
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq_));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq_));
!     node_list_.clear();
!     gu_trace(offset = node_list_.unserialize(buf, buflen, offset));
      return offset;
  }
  
***************
*** 391,415 ****
  {
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
!             + node_list.serial_size());
  }
  
! size_t gcomm::evs::InstallMessage::serialize(byte_t* const buf,
!                                              size_t  const buflen,
!                                              size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq, buf, buflen, offset));
!     gu_trace(offset = install_view_id.serialize(buf, buflen, offset));
!     gu_trace(offset = node_list.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::InstallMessage::unserialize(const byte_t* const buf,
!                                            size_t        const buflen,
!                                                size_t              offset,
                                                 bool skip_header)
      throw(gu::Exception)
  {
--- 390,414 ----
  {
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
!             + node_list_.serial_size());
  }
  
! size_t gcomm::evs::InstallMessage::serialize(gu::byte_t* const buf,
!                                              size_t      const buflen,
!                                              size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq_, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq_, buf, buflen, offset));
!     gu_trace(offset = install_view_id_.serialize(buf, buflen, offset));
!     gu_trace(offset = node_list_.serialize(buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::InstallMessage::unserialize(const gu::byte_t* const buf,
!                                                size_t            const buflen,
!                                                size_t                  offset,
                                                 bool skip_header)
      throw(gu::Exception)
  {
***************
*** 417,427 ****
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq));
!     gu_trace(offset = install_view_id.unserialize(buf, buflen, offset));
!     node_list.clear();
!     gu_trace(offset = node_list.unserialize(buf, buflen, offset));
      return offset;
  }
  
--- 416,426 ----
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq_));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq_));
!     gu_trace(offset = install_view_id_.unserialize(buf, buflen, offset));
!     node_list_.clear();
!     gu_trace(offset = node_list_.unserialize(buf, buflen, offset));
      return offset;
  }
  
***************
*** 430,453 ****
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
              + ViewId::serial_size()
!             + node_list.serial_size());
  }
  
  
! size_t gcomm::evs::LeaveMessage::serialize(byte_t* const buf,
!                                            size_t  const buflen,
!                                            size_t        offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq, buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::LeaveMessage::unserialize(const byte_t* const buf,
!                                              size_t        const buflen,
!                                              size_t              offset,
                                               bool skip_header)
      throw(gu::Exception)
  {
--- 429,452 ----
      return (Message::serial_size()
              + 2 * sizeof(seqno_t)
              + ViewId::serial_size()
!             + node_list_.serial_size());
  }
  
  
! size_t gcomm::evs::LeaveMessage::serialize(gu::byte_t* const buf,
!                                            size_t      const buflen,
!                                            size_t            offset) const
      throw(gu::Exception)
  {
      gu_trace(offset = Message::serialize(buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(seq_, buf, buflen, offset));
!     gu_trace(offset = gu::serialize8(aru_seq_, buf, buflen, offset));
      return offset;
  }
  
! size_t gcomm::evs::LeaveMessage::unserialize(const gu::byte_t* const buf,
!                                              size_t            const buflen,
!                                              size_t                  offset,
                                               bool skip_header)
      throw(gu::Exception)
  {
***************
*** 455,462 ****
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq));
      return offset;
  }
  
--- 454,461 ----
      {
          gu_trace(offset = Message::unserialize(buf, buflen, offset));
      }
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, seq_));
!     gu_trace(offset = gu::unserialize8(buf, buflen, offset, aru_seq_));
      return offset;
  }
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_message2.hpp 2.x/gcomm/src/evs_message2.hpp
*** galera-23.2.2-src/gcomm/src/evs_message2.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_message2.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 70,82 ****
          im_range_    (mn.im_range_   )
      { }
  
!     bool          get_operational() const { return operational_       ; }
!     bool          get_suspected()   const { return suspected_         ; }
!     bool          get_leaving()     const { return (leave_seq_ != -1) ; }
!     seqno_t       get_leave_seq()   const { return leave_seq_         ; }
!     const ViewId& get_view_id()     const { return view_id_           ; }
!     seqno_t       get_safe_seq()    const { return safe_seq_          ; }
!     Range         get_im_range()    const { return im_range_          ; }
  
      bool operator==(const MessageNode& cmp) const
      {
--- 70,82 ----
          im_range_    (mn.im_range_   )
      { }
  
!     bool          operational() const { return operational_       ; }
!     bool          suspected()   const { return suspected_         ; }
!     bool          leaving()     const { return (leave_seq_ != -1) ; }
!     seqno_t       leave_seq()   const { return leave_seq_         ; }
!     const ViewId& view_id()     const { return view_id_           ; }
!     seqno_t       safe_seq()    const { return safe_seq_          ; }
!     Range         im_range()    const { return im_range_          ; }
  
      bool operator==(const MessageNode& cmp) const
      {
***************
*** 146,159 ****
       *
       * @return Version number
       */
!     uint8_t get_version() const { return version; }
  
      /*!
       * Get type of the message
       *
       * @return Message type
       */
!     Type get_type() const { return type; }
  
      /*!
       * Check wheter message is of membership type
--- 146,159 ----
       *
       * @return Version number
       */
!     uint8_t version() const { return version_; }
  
      /*!
       * Get type of the message
       *
       * @return Message type
       */
!     Type type() const { return type_; }
  
      /*!
       * Check wheter message is of membership type
***************
*** 162,168 ****
       */
      bool is_membership() const
      {
!         return type == T_JOIN || type == T_INSTALL || type == T_LEAVE;
      }
  
      /*!
--- 162,168 ----
       */
      bool is_membership() const
      {
!         return (type_ == T_JOIN || type_ == T_INSTALL || type_ == T_LEAVE);
      }
  
      /*!
***************
*** 171,212 ****
       *
       * @return User type of the message.
       */
!     uint8_t get_user_type() const { return user_type; }
  
      /*!
       * Get message order type.
       *
       * @return Order type of the message.
       */
!     Order get_order() const { return order; }
  
      /*!
       * Get sequence number associated to the message.
       *
       * @return Const reference to sequence number associated to the message.
       */
!     seqno_t get_seq() const { return seq; }
  
      /*!
       * Get sequence numer range associated to the message.
       *
       * @return Sequence number range associated to the message.
       */
!     seqno_t get_seq_range() const { return seq_range; }
  
      /*!
       * Get all-received-upto sequence number associated the the message.
       *
       * @return All-received-upto sequence number associated to the message.
       */
!     seqno_t get_aru_seq() const { return aru_seq; }
  
      /*!
       * Get message flags.
       *
       * @return Message flags.
       */
!     uint8_t get_flags() const { return flags; }
  
      /*!
       * Set message source
--- 171,212 ----
       *
       * @return User type of the message.
       */
!     uint8_t user_type() const { return user_type_; }
  
      /*!
       * Get message order type.
       *
       * @return Order type of the message.
       */
!     Order order() const { return order_; }
  
      /*!
       * Get sequence number associated to the message.
       *
       * @return Const reference to sequence number associated to the message.
       */
!     seqno_t seq() const { return seq_; }
  
      /*!
       * Get sequence numer range associated to the message.
       *
       * @return Sequence number range associated to the message.
       */
!     seqno_t seq_range() const { return seq_range_; }
  
      /*!
       * Get all-received-upto sequence number associated the the message.
       *
       * @return All-received-upto sequence number associated to the message.
       */
!     seqno_t aru_seq() const { return aru_seq_; }
  
      /*!
       * Get message flags.
       *
       * @return Message flags.
       */
!     uint8_t flags() const { return flags_; }
  
      /*!
       * Set message source
***************
*** 215,222 ****
       */
      void set_source(const UUID& uuid)
      {
!         source = uuid;
!         flags |= F_SOURCE;
      }
  
      /*!
--- 215,222 ----
       */
      void set_source(const UUID& uuid)
      {
!         source_ = uuid;
!         flags_ |= F_SOURCE;
      }
  
      /*!
***************
*** 224,230 ****
       *
       * @return Message source UUID.
       */
!     const UUID& get_source() const { return source; }
  
      /*!
       * Get message source view id, view where the message was originated
--- 224,230 ----
       *
       * @return Message source UUID.
       */
!     const UUID& source() const { return source_; }
  
      /*!
       * Get message source view id, view where the message was originated
***************
*** 232,254 ****
       *
       * @return Message source view id.
       */
!     const gcomm::ViewId& get_source_view_id() const { return source_view_id; }
  
!     const gcomm::ViewId& get_install_view_id() const { return install_view_id; }
  
      /*!
       * Get range UUID associated to the message.
       *
       * @return Range UUID associated to the message.
       */
!     const UUID& get_range_uuid() const { return range_uuid; }
  
      /*!
       * Get range associated to the message.
       *
       * @return Range associated to the message.
       */
!     Range get_range() const { return range; }
  
      /*!
       * Get fifo sequence number associated to the message. This is
--- 232,254 ----
       *
       * @return Message source view id.
       */
!     const gcomm::ViewId& source_view_id() const { return source_view_id_; }
  
!     const gcomm::ViewId& install_view_id() const { return install_view_id_; }
  
      /*!
       * Get range UUID associated to the message.
       *
       * @return Range UUID associated to the message.
       */
!     const UUID& range_uuid() const { return range_uuid_; }
  
      /*!
       * Get range associated to the message.
       *
       * @return Range associated to the message.
       */
!     Range range() const { return range_; }
  
      /*!
       * Get fifo sequence number associated to the message. This is
***************
*** 256,274 ****
       *
       * @return Fifo sequence number associated to the message.
       */
!     int64_t get_fifo_seq() const { return fifo_seq; }
  
      /*!
       * Get message node list.
       *
       * @return Const reference to message node list.
       */
!     const MessageNodeList& get_node_list() const { return node_list; }
  
      /*!
       * Get timestamp associated to the message.
       */
!     gu::datetime::Date get_tstamp() const { return tstamp; }
  
      size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
          throw(gu::Exception);
--- 256,274 ----
       *
       * @return Fifo sequence number associated to the message.
       */
!     int64_t fifo_seq() const { return fifo_seq_; }
  
      /*!
       * Get message node list.
       *
       * @return Const reference to message node list.
       */
!     const MessageNodeList& node_list() const { return node_list_; }
  
      /*!
       * Get timestamp associated to the message.
       */
!     gu::datetime::Date tstamp() const { return tstamp_; }
  
      size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
          throw(gu::Exception);
***************
*** 280,321 ****
       */
  
      Message(const Message& msg) :
!         version         (msg.version),
!         type            (msg.type),
!         user_type       (msg.user_type),
!         order           (msg.order),
!         seq             (msg.seq),
!         seq_range       (msg.seq_range),
!         aru_seq         (msg.aru_seq),
!         fifo_seq        (msg.fifo_seq),
!         flags           (msg.flags),
!         source          (msg.source),
!         source_view_id  (msg.source_view_id),
!         install_view_id (msg.install_view_id),
!         range_uuid      (msg.range_uuid),
!         range           (msg.range),
!         tstamp          (msg.tstamp),
!         node_list       (msg.node_list)
      { }
  
      Message& operator=(const Message& msg)
      {
!         version         = msg.version;
!         type            = msg.type;
!         user_type       = msg.user_type;
!         order           = msg.order;
!         seq             = msg.seq;
!         seq_range       = msg.seq_range;
!         aru_seq         = msg.aru_seq;
!         fifo_seq        = msg.fifo_seq;
!         flags           = msg.flags;
!         source          = msg.source;
!         source_view_id  = msg.source_view_id;
!         install_view_id = msg.install_view_id;
!         range_uuid      = msg.range_uuid;
!         range           = msg.range;
!         tstamp          = msg.tstamp;
!         node_list       = msg.node_list;
          return *this;
      }
  
--- 280,321 ----
       */
  
      Message(const Message& msg) :
!         version_         (msg.version_),
!         type_            (msg.type_),
!         user_type_       (msg.user_type_),
!         order_           (msg.order_),
!         seq_             (msg.seq_),
!         seq_range_       (msg.seq_range_),
!         aru_seq_         (msg.aru_seq_),
!         fifo_seq_        (msg.fifo_seq_),
!         flags_           (msg.flags_),
!         source_          (msg.source_),
!         source_view_id_  (msg.source_view_id_),
!         install_view_id_ (msg.install_view_id_),
!         range_uuid_      (msg.range_uuid_),
!         range_           (msg.range_),
!         tstamp_          (msg.tstamp_),
!         node_list_       (msg.node_list_)
      { }
  
      Message& operator=(const Message& msg)
      {
!         version_         = msg.version_;
!         type_            = msg.type_;
!         user_type_       = msg.user_type_;
!         order_           = msg.order_;
!         seq_             = msg.seq_;
!         seq_range_       = msg.seq_range_;
!         aru_seq_         = msg.aru_seq_;
!         fifo_seq_        = msg.fifo_seq_;
!         flags_           = msg.flags_;
!         source_          = msg.source_;
!         source_view_id_  = msg.source_view_id_;
!         install_view_id_ = msg.install_view_id_;
!         range_uuid_      = msg.range_uuid_;
!         range_           = msg.range_;
!         tstamp_          = msg.tstamp_;
!         node_list_       = msg.node_list_;
          return *this;
      }
  
***************
*** 323,359 ****
  
  
      /*! Default constructor */
!     Message(const uint8_t          version_         = 0,
!             const Type             type_            = T_NONE,
!             const UUID&            source_          = UUID::nil(),
!             const ViewId&          source_view_id_  = ViewId(),
!             const ViewId&          install_view_id_ = ViewId(),
!             const uint8_t          user_type_       = 0xff,
!             const Order            order_           = O_DROP,
!             const int64_t          fifo_seq_        = -1,
!             const seqno_t            seq_             = -1,
!             const seqno_t            seq_range_       = -1,
!             const seqno_t            aru_seq_         = -1,
!             const uint8_t          flags_           = 0,
!             const UUID&            range_uuid_      = UUID(),
!             const Range            range_           = Range(),
!             const MessageNodeList& node_list_       = MessageNodeList()) :
!         version         (version_),
!         type            (type_),
!         user_type       (user_type_),
!         order           (order_),
!         seq             (seq_),
!         seq_range       (seq_range_),
!         aru_seq         (aru_seq_),
!         fifo_seq        (fifo_seq_),
!         flags           (flags_),
!         source          (source_),
!         source_view_id  (source_view_id_),
!         install_view_id (install_view_id_),
!         range_uuid      (range_uuid_),
!         range           (range_),
!         tstamp          (gu::datetime::Date::now()),
!         node_list       (node_list_)
      { }
  
  protected:
--- 323,359 ----
  
  
      /*! Default constructor */
!     Message(const uint8_t          version         = 0,
!             const Type             type            = T_NONE,
!             const UUID&            source          = UUID::nil(),
!             const ViewId&          source_view_id  = ViewId(),
!             const ViewId&          install_view_id = ViewId(),
!             const uint8_t          user_type       = 0xff,
!             const Order            order           = O_DROP,
!             const int64_t          fifo_seq        = -1,
!             const seqno_t          seq             = -1,
!             const seqno_t          seq_range       = -1,
!             const seqno_t          aru_seq         = -1,
!             const uint8_t          flags           = 0,
!             const UUID&            range_uuid      = UUID(),
!             const Range            range           = Range(),
!             const MessageNodeList& node_list       = MessageNodeList()) :
!         version_         (version),
!         type_            (type),
!         user_type_       (user_type),
!         order_           (order),
!         seq_             (seq),
!         seq_range_       (seq_range),
!         aru_seq_         (aru_seq),
!         fifo_seq_        (fifo_seq),
!         flags_           (flags),
!         source_          (source),
!         source_view_id_  (source_view_id),
!         install_view_id_ (install_view_id),
!         range_uuid_      (range_uuid),
!         range_           (range),
!         tstamp_          (gu::datetime::Date::now()),
!         node_list_       (node_list)
      { }
  
  protected:
***************
*** 363,384 ****
  
      size_t serial_size() const;
  
!     uint8_t            version;
!     Type               type;
!     uint8_t            user_type;
!     Order              order;
!     seqno_t              seq;
!     seqno_t              seq_range;
!     seqno_t              aru_seq;
!     int64_t            fifo_seq;
!     uint8_t            flags;
!     UUID               source;
!     ViewId             source_view_id;
!     ViewId             install_view_id;
!     UUID               range_uuid;
!     Range              range;
!     gu::datetime::Date tstamp;
!     MessageNodeList    node_list;
  
  
  };
--- 363,384 ----
  
      size_t serial_size() const;
  
!     uint8_t            version_;
!     Type               type_;
!     uint8_t            user_type_;
!     Order              order_;
!     seqno_t            seq_;
!     seqno_t            seq_range_;
!     seqno_t            aru_seq_;
!     int64_t            fifo_seq_;
!     uint8_t            flags_;
!     UUID               source_;
!     ViewId             source_view_id_;
!     ViewId             install_view_id_;
!     UUID               range_uuid_;
!     Range              range_;
!     gu::datetime::Date tstamp_;
!     MessageNodeList    node_list_;
  
  
  };
***************
*** 389,400 ****
  class gcomm::evs::UserMessage : public Message
  {
  public:
!     UserMessage(const int          version = -1,
                  const UUID&        source         = UUID::nil(),
                  const ViewId&      source_view_id = ViewId(),
!                 const seqno_t        seq            = -1,
!                 const seqno_t        aru_seq        = -1,
!                 const seqno_t        seq_range      = 0,
                  const Order        order          = O_SAFE,
                  const int64_t      fifo_seq       = -1,
                  const uint8_t      user_type      = 0xff,
--- 389,400 ----
  class gcomm::evs::UserMessage : public Message
  {
  public:
!     UserMessage(const int          version        = -1,
                  const UUID&        source         = UUID::nil(),
                  const ViewId&      source_view_id = ViewId(),
!                 const seqno_t      seq            = -1,
!                 const seqno_t      aru_seq        = -1,
!                 const seqno_t      seq_range      = 0,
                  const Order        order          = O_SAFE,
                  const int64_t      fifo_seq       = -1,
                  const uint8_t      user_type      = 0xff,
***************
*** 415,421 ****
                  Range())
      { }
  
!     void set_aru_seq(const seqno_t as) { aru_seq = as; }
  
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
          throw(gu::Exception);
--- 415,421 ----
                  Range())
      { }
  
!     void set_aru_seq(const seqno_t as) { aru_seq_ = as; }
  
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
          throw(gu::Exception);
***************
*** 439,447 ****
          len_      (gu::convert(len, uint16_t(0)))
      { }
  
!     int    get_flags() const { return flags_; }
!     size_t get_len()   const { return len_;   }
!     uint8_t get_user_type() const { return user_type_; }
  
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
          throw(gu::Exception);
--- 439,447 ----
          len_      (gu::convert(len, uint16_t(0)))
      { }
  
!     int    flags() const { return flags_; }
!     size_t len()   const { return len_;   }
!     uint8_t user_type() const { return user_type_; }
  
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
          throw(gu::Exception);
***************
*** 461,467 ****
  
  inline std::ostream& gcomm::evs::operator<<(std::ostream& os, const AggregateMessage& am)
  {
!     return (os << "{flags=" << am.get_flags() << ",len=" << am.get_len() << "}");
  }
  
  
--- 461,467 ----
  
  inline std::ostream& gcomm::evs::operator<<(std::ostream& os, const AggregateMessage& am)
  {
!     return (os << "{flags=" << am.flags() << ",len=" << am.len() << "}");
  }
  
  
***************
*** 641,653 ****
  
      void operator()(const MessageNodeList::value_type& vt) const
      {
!         const MessageNode& node(MessageNodeList::get_value(vt));
          if ((view_id_                  == ViewId() ||
!              node.get_view_id()        == view_id_    ) &&
              ((operational_             == true          &&
                leaving_                 == true   ) ||
!              (node.get_operational() == operational_ &&
!               node.get_leaving()     == leaving_ ) ) )
  
          {
              nl_.insert_unique(vt);
--- 641,653 ----
  
      void operator()(const MessageNodeList::value_type& vt) const
      {
!         const MessageNode& node(MessageNodeList::value(vt));
          if ((view_id_                  == ViewId() ||
!              node.view_id()        == view_id_    ) &&
              ((operational_             == true          &&
                leaving_                 == true   ) ||
!              (node.operational() == operational_ &&
!               node.leaving()     == leaving_ ) ) )
  
          {
              nl_.insert_unique(vt);
***************
*** 667,676 ****
      bool operator()(const MessageNodeList::value_type& a,
                      const MessageNodeList::value_type& b) const
      {
!         gcomm_assert(MessageNodeList::get_value(a).get_view_id() ==
!                      MessageNodeList::get_value(b).get_view_id());
!         return (MessageNodeList::get_value(a).get_im_range().get_lu() <
!                 MessageNodeList::get_value(b).get_im_range().get_lu());
      }
  };
  
--- 667,676 ----
      bool operator()(const MessageNodeList::value_type& a,
                      const MessageNodeList::value_type& b) const
      {
!         gcomm_assert(MessageNodeList::value(a).view_id() ==
!                      MessageNodeList::value(b).view_id());
!         return (MessageNodeList::value(a).im_range().lu() <
!                 MessageNodeList::value(b).im_range().lu());
      }
  };
  
***************
*** 680,689 ****
      bool operator()(const MessageNodeList::value_type& a,
                      const MessageNodeList::value_type& b) const
      {
!         gcomm_assert(MessageNodeList::get_value(a).get_view_id() ==
!                      MessageNodeList::get_value(b).get_view_id());
!         return (MessageNodeList::get_value(a).get_im_range().get_hs() <
!                 MessageNodeList::get_value(b).get_im_range().get_hs());
      }
  };
  
--- 680,689 ----
      bool operator()(const MessageNodeList::value_type& a,
                      const MessageNodeList::value_type& b) const
      {
!         gcomm_assert(MessageNodeList::value(a).view_id() ==
!                      MessageNodeList::value(b).view_id());
!         return (MessageNodeList::value(a).im_range().hs() <
!                 MessageNodeList::value(b).im_range().hs());
      }
  };
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_node.cpp 2.x/gcomm/src/evs_node.cpp
*** galera-23.2.2-src/gcomm/src/evs_node.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_node.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 7,37 ****
  
  #include <ostream>
  
- using namespace std;
- using namespace gu::datetime;
- using namespace gcomm::evs;
  
! ostream& gcomm::evs::operator<<(ostream& os, const Node& n)
  {
      os << "evs::node{";
!     os << "operational=" << n.get_operational() << ",";
!     os << "suspected=" << n.get_suspected() << ",";
!     os << "installed=" << n.get_installed() << ",";
!     os << "fifo_seq=" << n.get_fifo_seq() << ",";
!     if (n.get_join_message() != 0)
      {
!         os << "join_message=\n" << *n.get_join_message() << ",\n";
      }
!     if (n.get_leave_message() != 0)
      {
!         os << "leave_message=\n" << *n.get_leave_message() << ",\n";
      }
      os << "}";
      return os;
  }
  
  
! gcomm::evs::Node::Node(const Node& n) 
      :
      index_           (n.index_),
      operational_     (n.operational_),
--- 7,35 ----
  
  #include <ostream>
  
  
! std::ostream&
! gcomm::evs::operator<<(std::ostream& os, const gcomm::evs::Node& n)
  {
      os << "evs::node{";
!     os << "operational=" << n.operational() << ",";
!     os << "suspected=" << n.suspected() << ",";
!     os << "installed=" << n.installed() << ",";
!     os << "fifo_seq=" << n.fifo_seq() << ",";
!     if (n.join_message() != 0)
      {
!         os << "join_message=\n" << *n.join_message() << ",\n";
      }
!     if (n.leave_message() != 0)
      {
!         os << "leave_message=\n" << *n.leave_message() << ",\n";
      }
      os << "}";
      return os;
  }
  
  
! gcomm::evs::Node::Node(const Node& n)
      :
      index_           (n.index_),
      operational_     (n.operational_),
***************
*** 39,47 ****
      inactive_        (n.inactive_),
      committed_       (n.committed_),
      installed_       (n.installed_),
!     join_message_    (n.join_message_ != 0 ? 
                        new JoinMessage(*n.join_message_) : 0),
!     leave_message_   (n.leave_message_ != 0 ? 
                        new LeaveMessage(*n.leave_message_) : 0),
      suspect_timeout_ (n.suspect_timeout_),
      inactive_timeout_(n.inactive_timeout_),
--- 37,45 ----
      inactive_        (n.inactive_),
      committed_       (n.committed_),
      installed_       (n.installed_),
!     join_message_    (n.join_message_ != 0 ?
                        new JoinMessage(*n.join_message_) : 0),
!     leave_message_   (n.leave_message_ != 0 ?
                        new LeaveMessage(*n.leave_message_) : 0),
      suspect_timeout_ (n.suspect_timeout_),
      inactive_timeout_(n.inactive_timeout_),
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_node.hpp 2.x/gcomm/src/evs_node.hpp
*** galera-23.2.2-src/gcomm/src/evs_node.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_node.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 56,94 ****
      ~Node();
  
      void set_index(const size_t idx) { index_ = idx; }
!     size_t get_index() const { return index_; }
  
      void set_operational(const bool op)
      {
          gcomm_assert(op == false);
          operational_ = op;
      }
!     bool get_operational() const { return operational_; }
  
      void set_suspected(const bool s)
      {
          suspected_ = s;
      }
!     bool get_suspected() const { return suspected_; }
  
      void set_committed(const bool comm) { committed_ = comm; }
!     bool get_committed() const { return committed_; }
      void set_installed(const bool inst) { installed_ = inst; }
!     bool get_installed() const { return installed_; }
  
      void set_join_message(const JoinMessage* msg);
  
!     const JoinMessage* get_join_message() const { return join_message_; }
  
      void set_leave_message(const LeaveMessage* msg);
  
!     const LeaveMessage* get_leave_message() const { return leave_message_; }
  
      void set_tstamp(const gu::datetime::Date& t) { tstamp_ = t; }
!     const gu::datetime::Date& get_tstamp() const { return tstamp_; }
  
      void set_fifo_seq(const int64_t seq) { fifo_seq_ = seq; }
!     int64_t get_fifo_seq() const { return fifo_seq_; }
  
      bool is_inactive() const;
      bool is_suspected() const;
--- 56,94 ----
      ~Node();
  
      void set_index(const size_t idx) { index_ = idx; }
!     size_t index() const { return index_; }
  
      void set_operational(const bool op)
      {
          gcomm_assert(op == false);
          operational_ = op;
      }
!     bool operational() const { return operational_; }
  
      void set_suspected(const bool s)
      {
          suspected_ = s;
      }
!     bool suspected() const { return suspected_; }
  
      void set_committed(const bool comm) { committed_ = comm; }
!     bool committed() const { return committed_; }
      void set_installed(const bool inst) { installed_ = inst; }
!     bool installed() const { return installed_; }
  
      void set_join_message(const JoinMessage* msg);
  
!     const JoinMessage* join_message() const { return join_message_; }
  
      void set_leave_message(const LeaveMessage* msg);
  
!     const LeaveMessage* leave_message() const { return leave_message_; }
  
      void set_tstamp(const gu::datetime::Date& t) { tstamp_ = t; }
!     const gu::datetime::Date& tstamp() const { return tstamp_; }
  
      void set_fifo_seq(const int64_t seq) { fifo_seq_ = seq; }
!     int64_t fifo_seq() const { return fifo_seq_; }
  
      bool is_inactive() const;
      bool is_suspected() const;
***************
*** 141,147 ****
  
      void operator()(const NodeMap::value_type& vt) const
      {
!         if (NodeMap::get_value(vt).get_operational() == true)
          {
              nm.insert_unique(vt);
          }
--- 141,147 ----
  
      void operator()(const NodeMap::value_type& vt) const
      {
!         if (NodeMap::value(vt).operational() == true)
          {
              nm.insert_unique(vt);
          }
***************
*** 158,164 ****
      {
          Node& node(p.second);
          gu::datetime::Date now(gu::datetime::Date::now());
!         if (node.get_tstamp() + node.suspect_timeout_ < now)
          {
              if (node.suspected_ == false)
              {
--- 158,164 ----
      {
          Node& node(p.second);
          gu::datetime::Date now(gu::datetime::Date::now());
!         if (node.tstamp() + node.suspect_timeout_ < now)
          {
              if (node.suspected_ == false)
              {
***************
*** 172,178 ****
          {
              node.suspected_ = false;
          }
!         if (node.get_tstamp() + node.inactive_timeout_ < now)
          {
              if (node.inactive_ == false)
              {
--- 172,178 ----
          {
              node.suspected_ = false;
          }
!         if (node.tstamp() + node.inactive_timeout_ < now)
          {
              if (node.inactive_ == false)
              {
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_proto.cpp 2.x/gcomm/src/evs_proto.cpp
*** galera-23.2.2-src/gcomm/src/evs_proto.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_proto.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 22,202 ****
  #include <algorithm>
  #include <numeric>
  
- using namespace std;
  using namespace std::rel_ops;
- using namespace gu;
- using namespace gu::datetime;
- using namespace gcomm;
- using namespace gcomm::evs;
  
  // Convenience macros for debug and info logging
  #define evs_log_debug(__mask__)             \
!     if ((debug_mask & (__mask__)) == 0) { } \
      else log_debug << self_string() << ": "
  
  #define evs_log_info(__mask__)              \
!     if ((info_mask & (__mask__)) == 0) { }  \
      else log_info << self_string() << ": "
  
  
  // const int gcomm::evs::Proto::max_version_(GCOMM_EVS_MAX_VERSION);
  
! gcomm::evs::Proto::Proto(gu::Config& conf,
!                          const UUID& my_uuid_,
                           const gu::URI& uri,
!                          const size_t mtu_)
      :
      Protolay(conf),
!     timers(),
!     version(check_range(Conf::EvsVersion,
!                         param<int>(conf, uri, Conf::EvsVersion, "0"),
!                         0, max_version_ + 1)),
!     debug_mask(param<int>(conf, uri, Conf::EvsDebugLogMask, "0x1", std::hex)),
!     info_mask(param<int>(conf, uri, Conf::EvsInfoLogMask, "0x0", std::hex)),
!     last_stats_report(Date::now()),
!     collect_stats(true),
!     hs_agreed("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     hs_safe("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     hs_local_causal("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     send_queue_s(0),
!     n_send_queue_s(0),
!     sent_msgs(7, 0),
!     retrans_msgs(0),
!     recovered_msgs(0),
!     recvd_msgs(7, 0),
!     delivered_msgs(O_LOCAL_CAUSAL + 1),
!     send_user_prof    ("send_user"),
!     send_gap_prof     ("send_gap"),
!     send_join_prof    ("send_join"),
!     send_install_prof ("send_install"),
!     send_leave_prof   ("send_leave"),
!     consistent_prof   ("consistent"),
!     consensus_prof    ("consensus"),
!     shift_to_prof     ("shift_to"),
!     input_map_prof    ("input_map"),
!     delivery_prof     ("delivery"),
!     delivering(false),
!     my_uuid(my_uuid_),
!     known(),
!     self_i(),
!     view_forget_timeout(
          check_range(Conf::EvsViewForgetTimeout,
!                     param<Period>(conf, uri, Conf::EvsViewForgetTimeout,
!                                   Defaults::EvsViewForgetTimeout),
!                     gu::from_string<Period>(Defaults::EvsViewForgetTimeoutMin),
!                     Period::max())),
!     inactive_timeout(
          check_range(Conf::EvsInactiveTimeout,
!                     param<Period>(conf, uri, Conf::EvsInactiveTimeout,
!                                   Defaults::EvsInactiveTimeout),
!                     gu::from_string<Period>(Defaults::EvsInactiveTimeoutMin),
!                     Period::max())),
!     suspect_timeout(
          check_range(Conf::EvsSuspectTimeout,
!                     param<Period>(conf, uri, Conf::EvsSuspectTimeout,
!                                   Defaults::EvsSuspectTimeout),
!                     gu::from_string<Period>(Defaults::EvsSuspectTimeoutMin),
!                     Period::max())),
!     inactive_check_period(
          check_range(Conf::EvsInactiveCheckPeriod,
!                     param<Period>(conf, uri, Conf::EvsInactiveCheckPeriod,
!                                   Defaults::EvsInactiveCheckPeriod),
!                     Period::min(),
!                     suspect_timeout/2 + 1)),
!     retrans_period(
          check_range(Conf::EvsKeepalivePeriod,
!                     param<Period>(conf, uri, Conf::EvsKeepalivePeriod,
!                                   Defaults::EvsRetransPeriod),
!                     gu::from_string<Period>(Defaults::EvsRetransPeriodMin),
!                     suspect_timeout/3 + 1)),
!     install_timeout(
          check_range(Conf::EvsInstallTimeout,
!                     param<Period>(conf, uri, Conf::EvsInstallTimeout,
!                                   gu::to_string(inactive_timeout)),
!                     retrans_period*2, inactive_timeout + 1)),
!     join_retrans_period(
          check_range(Conf::EvsJoinRetransPeriod,
!                     param<Period>(conf, uri, Conf::EvsJoinRetransPeriod,
!                                   Defaults::EvsJoinRetransPeriod),
!                     gu::from_string<Period>(Defaults::EvsRetransPeriodMin),
!                     Period::max())),
!     stats_report_period(
          check_range(Conf::EvsStatsReportPeriod,
!                     param<Period>(conf, uri, Conf::EvsStatsReportPeriod,
!                                   Defaults::EvsStatsReportPeriod),
!                     gu::from_string<Period>(Defaults::EvsStatsReportPeriodMin),
!                     Period::max())),
!     causal_keepalive_period(retrans_period),
!     last_inactive_check   (gu::datetime::Date::now()),
!     last_causal_keepalive (gu::datetime::Date::now()),
!     current_view(ViewId(V_TRANS, my_uuid, 0)),
!     previous_view(),
!     previous_views(),
!     input_map(new InputMap()),
      causal_queue_(),
!     consensus(my_uuid, known, *input_map, current_view),
!     install_message(0),
!     attempt_seq(1),
!     max_install_timeouts(
          check_range(Conf::EvsMaxInstallTimeouts,
                      param<int>(conf, uri, Conf::EvsMaxInstallTimeouts,
                                 Defaults::EvsMaxInstallTimeouts),
                      0, std::numeric_limits<int>::max())),
!     install_timeout_count(0),
!     fifo_seq(-1),
!     last_sent(-1),
!     send_window(
          check_range(Conf::EvsSendWindow,
                      param<seqno_t>(conf, uri, Conf::EvsSendWindow,
                                     Defaults::EvsSendWindow),
                      gu::from_string<seqno_t>(Defaults::EvsSendWindowMin),
                      std::numeric_limits<seqno_t>::max())),
!     user_send_window(
          check_range(Conf::EvsUserSendWindow,
                      param<seqno_t>(conf, uri, Conf::EvsUserSendWindow,
                                     Defaults::EvsUserSendWindow),
                      gu::from_string<seqno_t>(Defaults::EvsUserSendWindowMin),
!                     send_window + 1)),
!     output(),
      send_buf_(),
!     max_output_size(128),
!     mtu(mtu_),
!     use_aggregate(param<bool>(conf, uri, Conf::EvsUseAggregate, "true")),
!     self_loopback(false),
!     state(S_CLOSED),
!     shift_to_rfcnt(0)
! {
!     log_info << "EVS version " << version;
! 
!     conf.set(Conf::EvsVersion, gu::to_string(version));
!     conf.set(Conf::EvsViewForgetTimeout, gu::to_string(view_forget_timeout));
!     conf.set(Conf::EvsSuspectTimeout, gu::to_string(suspect_timeout));
!     conf.set(Conf::EvsInactiveTimeout, gu::to_string(inactive_timeout));
!     conf.set(Conf::EvsKeepalivePeriod, gu::to_string(retrans_period));
      conf.set(Conf::EvsInactiveCheckPeriod,
!              gu::to_string(inactive_check_period));
!     conf.set(Conf::EvsJoinRetransPeriod, gu::to_string(join_retrans_period));
!     conf.set(Conf::EvsInstallTimeout, gu::to_string(install_timeout));
!     conf.set(Conf::EvsStatsReportPeriod, gu::to_string(stats_report_period));
      conf.set(Conf::EvsCausalKeepalivePeriod,
!              gu::to_string(causal_keepalive_period));
!     conf.set(Conf::EvsSendWindow, gu::to_string(send_window));
!     conf.set(Conf::EvsUserSendWindow, gu::to_string(user_send_window));
!     conf.set(Conf::EvsUseAggregate, gu::to_string(use_aggregate));
!     conf.set(Conf::EvsDebugLogMask, gu::to_string(debug_mask, std::hex));
!     conf.set(Conf::EvsInfoLogMask, gu::to_string(info_mask, std::hex));
!     conf.set(Conf::EvsMaxInstallTimeouts, gu::to_string(max_install_timeouts));
  
      //
  
!     known.insert_unique(make_pair(my_uuid, Node(inactive_timeout, suspect_timeout)));
!     self_i = known.begin();
!     assert(NodeMap::get_value(self_i).get_operational() == true);
! 
!     NodeMap::get_value(self_i).set_index(0);
!     input_map->reset(1);
!     current_view.add_member(my_uuid, "");
!     if (mtu_ != numeric_limits<size_t>::max())
      {
          send_buf_.reserve(mtu_);
      }
--- 22,213 ----
  #include <algorithm>
  #include <numeric>
  
  using namespace std::rel_ops;
  
  // Convenience macros for debug and info logging
  #define evs_log_debug(__mask__)             \
!     if ((debug_mask_ & (__mask__)) == 0) { } \
      else log_debug << self_string() << ": "
  
  #define evs_log_info(__mask__)              \
!     if ((info_mask_ & (__mask__)) == 0) { }  \
      else log_info << self_string() << ": "
  
  
  // const int gcomm::evs::Proto::max_version_(GCOMM_EVS_MAX_VERSION);
  
! gcomm::evs::Proto::Proto(gu::Config&    conf,
!                          const UUID&    my_uuid,
                           const gu::URI& uri,
!                          const size_t   mtu)
      :
      Protolay(conf),
!     timers_(),
!     version_(check_range(Conf::EvsVersion,
!                          param<int>(conf, uri, Conf::EvsVersion, "0"),
!                          0, max_version_ + 1)),
!     debug_mask_(param<int>(conf, uri, Conf::EvsDebugLogMask, "0x1", std::hex)),
!     info_mask_(param<int>(conf, uri, Conf::EvsInfoLogMask, "0x0", std::hex)),
!     last_stats_report_(gu::datetime::Date::now()),
!     collect_stats_(true),
!     hs_agreed_("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     hs_safe_("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     hs_local_causal_("0.0,0.0005,0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.5,1.,5.,10.,30."),
!     send_queue_s_(0),
!     n_send_queue_s_(0),
!     sent_msgs_(7, 0),
!     retrans_msgs_(0),
!     recovered_msgs_(0),
!     recvd_msgs_(7, 0),
!     delivered_msgs_(O_LOCAL_CAUSAL + 1),
!     send_user_prof_    ("send_user"),
!     send_gap_prof_     ("send_gap"),
!     send_join_prof_    ("send_join"),
!     send_install_prof_ ("send_install"),
!     send_leave_prof_   ("send_leave"),
!     consistent_prof_   ("consistent"),
!     consensus_prof_    ("consensus"),
!     shift_to_prof_     ("shift_to"),
!     input_map_prof_    ("input_map"),
!     delivery_prof_     ("delivery"),
!     delivering_(false),
!     my_uuid_(my_uuid),
!     known_(),
!     self_i_(),
!     view_forget_timeout_(
          check_range(Conf::EvsViewForgetTimeout,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsViewForgetTimeout,
!                         Defaults::EvsViewForgetTimeout),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsViewForgetTimeoutMin),
!                     gu::datetime::Period::max())),
!     inactive_timeout_(
          check_range(Conf::EvsInactiveTimeout,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsInactiveTimeout,
!                         Defaults::EvsInactiveTimeout),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsInactiveTimeoutMin),
!                     gu::datetime::Period::max())),
!     suspect_timeout_(
          check_range(Conf::EvsSuspectTimeout,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsSuspectTimeout,
!                         Defaults::EvsSuspectTimeout),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsSuspectTimeoutMin),
!                     gu::datetime::Period::max())),
!     inactive_check_period_(
          check_range(Conf::EvsInactiveCheckPeriod,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsInactiveCheckPeriod,
!                         Defaults::EvsInactiveCheckPeriod),
!                     gu::datetime::Period::min(),
!                     suspect_timeout_/2 + 1)),
!     retrans_period_(
          check_range(Conf::EvsKeepalivePeriod,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsKeepalivePeriod,
!                         Defaults::EvsRetransPeriod),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsRetransPeriodMin),
!                     suspect_timeout_/3 + 1)),
!     install_timeout_(
          check_range(Conf::EvsInstallTimeout,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsInstallTimeout,
!                         gu::to_string(inactive_timeout_)),
!                     retrans_period_*2, inactive_timeout_ + 1)),
!     join_retrans_period_(
          check_range(Conf::EvsJoinRetransPeriod,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsJoinRetransPeriod,
!                         Defaults::EvsJoinRetransPeriod),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsRetransPeriodMin),
!                     gu::datetime::Period::max())),
!     stats_report_period_(
          check_range(Conf::EvsStatsReportPeriod,
!                     param<gu::datetime::Period>(
!                         conf, uri, Conf::EvsStatsReportPeriod,
!                         Defaults::EvsStatsReportPeriod),
!                     gu::from_string<gu::datetime::Period>(
!                         Defaults::EvsStatsReportPeriodMin),
!                     gu::datetime::Period::max())),
!     causal_keepalive_period_(retrans_period_),
!     last_inactive_check_   (gu::datetime::Date::now()),
!     last_causal_keepalive_ (gu::datetime::Date::now()),
!     current_view_(ViewId(V_TRANS, my_uuid, 0)),
!     previous_view_(),
!     previous_views_(),
!     input_map_(new InputMap()),
      causal_queue_(),
!     consensus_(my_uuid_, known_, *input_map_, current_view_),
!     install_message_(0),
!     attempt_seq_(1),
!     max_install_timeouts_(
          check_range(Conf::EvsMaxInstallTimeouts,
                      param<int>(conf, uri, Conf::EvsMaxInstallTimeouts,
                                 Defaults::EvsMaxInstallTimeouts),
                      0, std::numeric_limits<int>::max())),
!     install_timeout_count_(0),
!     fifo_seq_(-1),
!     last_sent_(-1),
!     send_window_(
          check_range(Conf::EvsSendWindow,
                      param<seqno_t>(conf, uri, Conf::EvsSendWindow,
                                     Defaults::EvsSendWindow),
                      gu::from_string<seqno_t>(Defaults::EvsSendWindowMin),
                      std::numeric_limits<seqno_t>::max())),
!     user_send_window_(
          check_range(Conf::EvsUserSendWindow,
                      param<seqno_t>(conf, uri, Conf::EvsUserSendWindow,
                                     Defaults::EvsUserSendWindow),
                      gu::from_string<seqno_t>(Defaults::EvsUserSendWindowMin),
!                     send_window_ + 1)),
!     output_(),
      send_buf_(),
!     max_output_size_(128),
!     mtu_(mtu),
!     use_aggregate_(param<bool>(conf, uri, Conf::EvsUseAggregate, "true")),
!     self_loopback_(false),
!     state_(S_CLOSED),
!     shift_to_rfcnt_(0)
! {
!     log_info << "EVS version " << version_;
! 
!     conf.set(Conf::EvsVersion, gu::to_string(version_));
!     conf.set(Conf::EvsViewForgetTimeout, gu::to_string(view_forget_timeout_));
!     conf.set(Conf::EvsSuspectTimeout, gu::to_string(suspect_timeout_));
!     conf.set(Conf::EvsInactiveTimeout, gu::to_string(inactive_timeout_));
!     conf.set(Conf::EvsKeepalivePeriod, gu::to_string(retrans_period_));
      conf.set(Conf::EvsInactiveCheckPeriod,
!              gu::to_string(inactive_check_period_));
!     conf.set(Conf::EvsJoinRetransPeriod, gu::to_string(join_retrans_period_));
!     conf.set(Conf::EvsInstallTimeout, gu::to_string(install_timeout_));
!     conf.set(Conf::EvsStatsReportPeriod, gu::to_string(stats_report_period_));
      conf.set(Conf::EvsCausalKeepalivePeriod,
!              gu::to_string(causal_keepalive_period_));
!     conf.set(Conf::EvsSendWindow, gu::to_string(send_window_));
!     conf.set(Conf::EvsUserSendWindow, gu::to_string(user_send_window_));
!     conf.set(Conf::EvsUseAggregate, gu::to_string(use_aggregate_));
!     conf.set(Conf::EvsDebugLogMask, gu::to_string(debug_mask_, std::hex));
!     conf.set(Conf::EvsInfoLogMask, gu::to_string(info_mask_, std::hex));
!     conf.set(Conf::EvsMaxInstallTimeouts, gu::to_string(max_install_timeouts_));
  
      //
  
!     known_.insert_unique(
!         std::make_pair(my_uuid_,
!                        Node(inactive_timeout_, suspect_timeout_)));
!     self_i_ = known_.begin();
!     assert(NodeMap::value(self_i_).operational() == true);
! 
!     NodeMap::value(self_i_).set_index(0);
!     input_map_->reset(1);
!     current_view_.add_member(my_uuid_, "");
!     if (mtu_ != std::numeric_limits<size_t>::max())
      {
          send_buf_.reserve(mtu_);
      }
***************
*** 205,213 ****
  
  gcomm::evs::Proto::~Proto()
  {
!     output.clear();
!     delete install_message;
!     delete input_map;
  }
  
  
--- 216,224 ----
  
  gcomm::evs::Proto::~Proto()
  {
!     output_.clear();
!     delete install_message_;
!     delete input_map_;
  }
  
  
***************
*** 216,341 ****
  {
      if (key == gcomm::Conf::EvsSendWindow)
      {
!         send_window = check_range(Conf::EvsSendWindow,
!                                   gu::from_string<seqno_t>(val),
!                                   user_send_window,
!                                   std::numeric_limits<seqno_t>::max());
!         conf_.set(Conf::EvsSendWindow, gu::to_string(send_window));
          return true;
      }
      else if (key == gcomm::Conf::EvsUserSendWindow)
      {
!         user_send_window = check_range(
              Conf::EvsUserSendWindow,
              gu::from_string<seqno_t>(val),
              gu::from_string<seqno_t>(Defaults::EvsUserSendWindowMin),
!             send_window + 1);
!         conf_.set(Conf::EvsUserSendWindow, gu::to_string(user_send_window));
          return true;
      }
      else if (key == gcomm::Conf::EvsMaxInstallTimeouts)
      {
!         max_install_timeouts = check_range(
              Conf::EvsMaxInstallTimeouts,
              gu::from_string<int>(val),
              0, std::numeric_limits<int>::max());
!         conf_.set(Conf::EvsMaxInstallTimeouts, gu::to_string(max_install_timeouts));
          return true;
      }
      else if (key == Conf::EvsStatsReportPeriod)
      {
!         stats_report_period = check_range(
              Conf::EvsStatsReportPeriod,
!             gu::from_string<Period>(val),
!             gu::from_string<Period>(Defaults::EvsStatsReportPeriodMin),
!             Period::max());
!         conf_.set(Conf::EvsStatsReportPeriod, gu::to_string(stats_report_period));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInfoLogMask)
      {
!         info_mask = gu::from_string<int>(val, std::hex);
!         conf_.set(Conf::EvsInfoLogMask, gu::to_string<int>(info_mask, std::hex));
          return true;
      }
      else if (key == Conf::EvsDebugLogMask)
      {
!         debug_mask = gu::from_string<int>(val, std::hex);
!         conf_.set(Conf::EvsDebugLogMask, gu::to_string<int>(debug_mask, std::hex));
          return true;
      }
      else if (key == Conf::EvsSuspectTimeout)
      {
!         suspect_timeout = check_range(
              Conf::EvsSuspectTimeout,
!             gu::from_string<Period>(val),
!             gu::from_string<Period>(Defaults::EvsSuspectTimeoutMin),
!             Period::max());
!         conf_.set(Conf::EvsSuspectTimeout, gu::to_string(suspect_timeout));
!         for (NodeMap::iterator i(known.begin()); i != known.end(); ++i)
          {
!             NodeMap::get_value(i).set_suspect_timeout(suspect_timeout);
          }
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInactiveTimeout)
      {
!         inactive_timeout = check_range(
              Conf::EvsInactiveTimeout,
!             gu::from_string<Period>(val),
!             gu::from_string<Period>(Defaults::EvsInactiveTimeoutMin),
!             Period::max());
!         conf_.set(Conf::EvsInactiveTimeout, gu::to_string(inactive_timeout));
!         for (NodeMap::iterator i(known.begin()); i != known.end(); ++i)
          {
!             NodeMap::get_value(i).set_inactive_timeout(inactive_timeout);
          }
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsKeepalivePeriod)
      {
!         retrans_period = check_range(
              Conf::EvsKeepalivePeriod,
!             gu::from_string<Period>(val),
!             gu::from_string<Period>(Defaults::EvsRetransPeriodMin),
!             Period::max());
!         conf_.set(Conf::EvsKeepalivePeriod, gu::to_string(retrans_period));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsCausalKeepalivePeriod)
      {
!         causal_keepalive_period = check_range(
              Conf::EvsCausalKeepalivePeriod,
!             gu::from_string<Period>(val),
!             Period(0),
!             Period::max());
          conf_.set(Conf::EvsCausalKeepalivePeriod,
!                   gu::to_string(causal_keepalive_period));
          // no timer reset here, causal keepalives don't rely on timer
          return true;
      }
      else if (key == Conf::EvsJoinRetransPeriod)
      {
!         join_retrans_period = check_range(
              Conf::EvsJoinRetransPeriod,
!             gu::from_string<Period>(val),
!             gu::from_string<Period>(Defaults::EvsRetransPeriodMin),
!             Period::max());
!         conf_.set(Conf::EvsJoinRetransPeriod, gu::to_string(join_retrans_period));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInstallTimeout)
      {
!         install_timeout = check_range(
              Conf::EvsInstallTimeout,
!             gu::from_string<Period>(val),
!             retrans_period*2, inactive_timeout + 1);
!         conf_.set(Conf::EvsInstallTimeout, gu::to_string(install_timeout));
          reset_timers();
          return true;
      }
--- 227,352 ----
  {
      if (key == gcomm::Conf::EvsSendWindow)
      {
!         send_window_ = check_range(Conf::EvsSendWindow,
!                                    gu::from_string<seqno_t>(val),
!                                    user_send_window_,
!                                    std::numeric_limits<seqno_t>::max());
!         conf_.set(Conf::EvsSendWindow, gu::to_string(send_window_));
          return true;
      }
      else if (key == gcomm::Conf::EvsUserSendWindow)
      {
!         user_send_window_ = check_range(
              Conf::EvsUserSendWindow,
              gu::from_string<seqno_t>(val),
              gu::from_string<seqno_t>(Defaults::EvsUserSendWindowMin),
!             send_window_ + 1);
!         conf_.set(Conf::EvsUserSendWindow, gu::to_string(user_send_window_));
          return true;
      }
      else if (key == gcomm::Conf::EvsMaxInstallTimeouts)
      {
!         max_install_timeouts_ = check_range(
              Conf::EvsMaxInstallTimeouts,
              gu::from_string<int>(val),
              0, std::numeric_limits<int>::max());
!         conf_.set(Conf::EvsMaxInstallTimeouts, gu::to_string(max_install_timeouts_));
          return true;
      }
      else if (key == Conf::EvsStatsReportPeriod)
      {
!         stats_report_period_ = check_range(
              Conf::EvsStatsReportPeriod,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::from_string<gu::datetime::Period>(Defaults::EvsStatsReportPeriodMin),
!             gu::datetime::Period::max());
!         conf_.set(Conf::EvsStatsReportPeriod, gu::to_string(stats_report_period_));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInfoLogMask)
      {
!         info_mask_ = gu::from_string<int>(val, std::hex);
!         conf_.set(Conf::EvsInfoLogMask, gu::to_string<int>(info_mask_, std::hex));
          return true;
      }
      else if (key == Conf::EvsDebugLogMask)
      {
!         debug_mask_ = gu::from_string<int>(val, std::hex);
!         conf_.set(Conf::EvsDebugLogMask, gu::to_string<int>(debug_mask_, std::hex));
          return true;
      }
      else if (key == Conf::EvsSuspectTimeout)
      {
!         suspect_timeout_ = check_range(
              Conf::EvsSuspectTimeout,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::from_string<gu::datetime::Period>(Defaults::EvsSuspectTimeoutMin),
!             gu::datetime::Period::max());
!         conf_.set(Conf::EvsSuspectTimeout, gu::to_string(suspect_timeout_));
!         for (NodeMap::iterator i(known_.begin()); i != known_.end(); ++i)
          {
!             NodeMap::value(i).set_suspect_timeout(suspect_timeout_);
          }
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInactiveTimeout)
      {
!         inactive_timeout_ = check_range(
              Conf::EvsInactiveTimeout,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::from_string<gu::datetime::Period>(Defaults::EvsInactiveTimeoutMin),
!             gu::datetime::Period::max());
!         conf_.set(Conf::EvsInactiveTimeout, gu::to_string(inactive_timeout_));
!         for (NodeMap::iterator i(known_.begin()); i != known_.end(); ++i)
          {
!             NodeMap::value(i).set_inactive_timeout(inactive_timeout_);
          }
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsKeepalivePeriod)
      {
!         retrans_period_ = check_range(
              Conf::EvsKeepalivePeriod,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::from_string<gu::datetime::Period>(Defaults::EvsRetransPeriodMin),
!             gu::datetime::Period::max());
!         conf_.set(Conf::EvsKeepalivePeriod, gu::to_string(retrans_period_));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsCausalKeepalivePeriod)
      {
!         causal_keepalive_period_ = check_range(
              Conf::EvsCausalKeepalivePeriod,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::datetime::Period(0),
!             gu::datetime::Period::max());
          conf_.set(Conf::EvsCausalKeepalivePeriod,
!                   gu::to_string(causal_keepalive_period_));
          // no timer reset here, causal keepalives don't rely on timer
          return true;
      }
      else if (key == Conf::EvsJoinRetransPeriod)
      {
!         join_retrans_period_ = check_range(
              Conf::EvsJoinRetransPeriod,
!             gu::from_string<gu::datetime::Period>(val),
!             gu::from_string<gu::datetime::Period>(Defaults::EvsRetransPeriodMin),
!             gu::datetime::Period::max());
!         conf_.set(Conf::EvsJoinRetransPeriod, gu::to_string(join_retrans_period_));
          reset_timers();
          return true;
      }
      else if (key == Conf::EvsInstallTimeout)
      {
!         install_timeout_ = check_range(
              Conf::EvsInstallTimeout,
!             gu::from_string<gu::datetime::Period>(val),
!             retrans_period_*2, inactive_timeout_ + 1);
!         conf_.set(Conf::EvsInstallTimeout, gu::to_string(install_timeout_));
          reset_timers();
          return true;
      }
***************
*** 350,430 ****
  }
  
  
! ostream& gcomm::evs::operator<<(ostream& os, const Proto& p)
  {
      os << "evs::proto("
         << p.self_string() << ", "
!        << p.to_string(p.get_state()) << ") {\n";
!     os << "current_view=" << p.current_view << ",\n";
!     os << "input_map=" << *p.input_map << ",\n";
!     os << "fifo_seq=" << p.fifo_seq << ",\n";
!     os << "last_sent=" << p.last_sent << ",\n";
!     os << "known={\n" << p.known << " } \n";
!     if (p.install_message != 0)
!         os << "install msg=" << *p.install_message << "\n";
      os << " }";
      return os;
  }
  
! string gcomm::evs::Proto::get_stats() const
  {
!     ostringstream os;
!     os << "\n\tnodes " << current_view.get_members().size();
!     os << "\n\tagreed deliv hist {" << hs_agreed << "} ";
!     os << "\n\tsafe deliv hist {" << hs_safe << "} ";
!     os << "\n\tcaus deliv hist {" << hs_local_causal << "} ";
!     os << "\n\toutq avg " << double(send_queue_s)/double(n_send_queue_s);
      os << "\n\tsent {";
!     copy(sent_msgs.begin(), sent_msgs.end(),
!          ostream_iterator<long long int>(os, ","));
      os << "}\n\tsent per sec {";
!     const double norm(double(Date::now().get_utc()
!                              - last_stats_report.get_utc())/gu::datetime::Sec);
!     vector<double> result(7, norm);
!     transform(sent_msgs.begin(), sent_msgs.end(),
!               result.begin(), result.begin(), divides<double>());
!     copy(result.begin(), result.end(), ostream_iterator<double>(os, ","));
      os << "}\n\trecvd { ";
!     copy(recvd_msgs.begin(), recvd_msgs.end(), ostream_iterator<long long int>(os, ","));
      os << "}\n\trecvd per sec {";
!     fill(result.begin(), result.end(), norm);
!     transform(recvd_msgs.begin(), recvd_msgs.end(),
!               result.begin(), result.begin(), divides<double>());
!     copy(result.begin(), result.end(), ostream_iterator<double>(os, ","));
!     os << "}\n\tretransmitted " << retrans_msgs << " ";
!     os << "\n\trecovered " << recovered_msgs;
      os << "\n\tdelivered {";
!     copy(delivered_msgs.begin(), delivered_msgs.end(),
!          ostream_iterator<long long int>(os, ", "));
      os << "}\n\teff(delivered/sent) " <<
!         double(accumulate(delivered_msgs.begin() + 1,
!                           delivered_msgs.begin() + O_SAFE + 1, 0))
!         /double(accumulate(sent_msgs.begin(), sent_msgs.end(), 0));
      return os.str();
  }
  
  void gcomm::evs::Proto::reset_stats()
  {
!     hs_agreed.clear();
!     hs_safe.clear();
!     hs_local_causal.clear();
!     send_queue_s = 0;
!     n_send_queue_s = 0;
!     fill(sent_msgs.begin(), sent_msgs.end(), 0LL);
!     fill(recvd_msgs.begin(), recvd_msgs.end(), 0LL);
!     retrans_msgs = 0LL;
!     recovered_msgs = 0LL;
!     fill(delivered_msgs.begin(), delivered_msgs.end(), 0LL);
!     last_stats_report = Date::now();
  }
  
  
  bool gcomm::evs::Proto::is_msg_from_previous_view(const Message& msg)
  {
!     for (list<pair<ViewId, Date> >::const_iterator i = previous_views.begin();
!          i != previous_views.end(); ++i)
      {
!         if (msg.get_source_view_id() == i->first)
          {
              evs_log_debug(D_FOREIGN_MSGS) << " message " << msg
                                            << " from previous view " << i->first;
--- 361,445 ----
  }
  
  
! std::ostream& gcomm::evs::operator<<(std::ostream& os, const Proto& p)
  {
      os << "evs::proto("
         << p.self_string() << ", "
!        << p.to_string(p.state()) << ") {\n";
!     os << "current_view=" << p.current_view_ << ",\n";
!     os << "input_map=" << *p.input_map_ << ",\n";
!     os << "fifo_seq=" << p.fifo_seq_ << ",\n";
!     os << "last_sent=" << p.last_sent_ << ",\n";
!     os << "known={\n" << p.known_ << " } \n";
!     if (p.install_message_ != 0)
!         os << "install msg=" << *p.install_message_ << "\n";
      os << " }";
      return os;
  }
  
! std::string gcomm::evs::Proto::stats() const
  {
!     std::ostringstream os;
!     os << "\n\tnodes " << current_view_.members().size();
!     os << "\n\tagreed deliv hist {" << hs_agreed_ << "} ";
!     os << "\n\tsafe deliv hist {" << hs_safe_ << "} ";
!     os << "\n\tcaus deliv hist {" << hs_local_causal_ << "} ";
!     os << "\n\toutq avg " << double(send_queue_s_)/double(n_send_queue_s_);
      os << "\n\tsent {";
!     std::copy(sent_msgs_.begin(), sent_msgs_.end(),
!          std::ostream_iterator<long long int>(os, ","));
      os << "}\n\tsent per sec {";
!     const double norm(double(gu::datetime::Date::now().get_utc()
!                              - last_stats_report_.get_utc())/gu::datetime::Sec);
!     std::vector<double> result(7, norm);
!     std::transform(sent_msgs_.begin(), sent_msgs_.end(),
!                    result.begin(), result.begin(), std::divides<double>());
!     std::copy(result.begin(), result.end(),
!               std::ostream_iterator<double>(os, ","));
      os << "}\n\trecvd { ";
!     std::copy(recvd_msgs_.begin(), recvd_msgs_.end(),
!               std::ostream_iterator<long long int>(os, ","));
      os << "}\n\trecvd per sec {";
!     std::fill(result.begin(), result.end(), norm);
!     std::transform(recvd_msgs_.begin(), recvd_msgs_.end(),
!                    result.begin(), result.begin(), std::divides<double>());
!     std::copy(result.begin(), result.end(),
!               std::ostream_iterator<double>(os, ","));
!     os << "}\n\tretransmitted " << retrans_msgs_ << " ";
!     os << "\n\trecovered " << recovered_msgs_;
      os << "\n\tdelivered {";
!     std::copy(delivered_msgs_.begin(), delivered_msgs_.end(),
!               std::ostream_iterator<long long int>(os, ", "));
      os << "}\n\teff(delivered/sent) " <<
!         double(accumulate(delivered_msgs_.begin() + 1,
!                           delivered_msgs_.begin() + O_SAFE + 1, 0))
!         /double(accumulate(sent_msgs_.begin(), sent_msgs_.end(), 0));
      return os.str();
  }
  
  void gcomm::evs::Proto::reset_stats()
  {
!     hs_agreed_.clear();
!     hs_safe_.clear();
!     hs_local_causal_.clear();
!     send_queue_s_ = 0;
!     n_send_queue_s_ = 0;
!     fill(sent_msgs_.begin(), sent_msgs_.end(), 0LL);
!     fill(recvd_msgs_.begin(), recvd_msgs_.end(), 0LL);
!     retrans_msgs_ = 0LL;
!     recovered_msgs_ = 0LL;
!     fill(delivered_msgs_.begin(), delivered_msgs_.end(), 0LL);
!     last_stats_report_ = gu::datetime::Date::now();
  }
  
  
  bool gcomm::evs::Proto::is_msg_from_previous_view(const Message& msg)
  {
!     for (std::list<std::pair<ViewId, gu::datetime::Date> >::const_iterator
!              i = previous_views_.begin();
!          i != previous_views_.end(); ++i)
      {
!         if (msg.source_view_id() == i->first)
          {
              evs_log_debug(D_FOREIGN_MSGS) << " message " << msg
                                            << " from previous view " << i->first;
***************
*** 435,445 ****
      // If node is in current view, check message source view seq, if it is
      // smaller than current view seq then the message is also from some
      // previous (but unknown to us) view
!     NodeList::const_iterator ni(current_view.get_members().find(msg.get_source()));
!     if (ni != current_view.get_members().end())
      {
!         if (msg.get_source_view_id().get_seq() <
!             current_view.get_id().get_seq())
          {
              log_warn << "stale message from unknown origin " << msg;
              return true;
--- 450,460 ----
      // If node is in current view, check message source view seq, if it is
      // smaller than current view seq then the message is also from some
      // previous (but unknown to us) view
!     NodeList::const_iterator ni(current_view_.members().find(msg.source()));
!     if (ni != current_view_.members().end())
      {
!         if (msg.source_view_id().seq() <
!             current_view_.id().seq())
          {
              log_warn << "stale message from unknown origin " << msg;
              return true;
***************
*** 460,575 ****
  void gcomm::evs::Proto::handle_retrans_timer()
  {
      evs_log_debug(D_TIMERS) << "retrans timer";
!     if (get_state() == S_GATHER)
      {
          gu_trace(send_join(true));
!         if (install_message != 0)
          {
              gu_trace(send_gap(UUID::nil(),
!                               install_message->get_install_view_id(),
                                Range(), true));
          }
      }
!     else if (get_state() == S_INSTALL)
      {
!         gcomm_assert(install_message != 0);
          gu_trace(send_gap(UUID::nil(),
!                           install_message->get_install_view_id(),
                            Range(), true));
          gu_trace(send_gap(UUID::nil(),
!                           install_message->get_install_view_id(),
                            Range()));
      }
!     else if (get_state() == S_OPERATIONAL)
      {
!         const seqno_t prev_last_sent(last_sent);
!         evs_log_debug(D_TIMERS) << "send user timer, last_sent=" << last_sent;
          Datagram dg;
          gu_trace((void)send_user(dg, 0xff, O_DROP, -1, -1));
!         if (prev_last_sent == last_sent)
          {
              log_warn << "could not send keepalive";
          }
      }
!     else if (get_state() == S_LEAVING)
      {
          evs_log_debug(D_TIMERS) << "send leave timer";
!         profile_enter(send_leave_prof);
          send_leave(false);
!         profile_leave(send_leave_prof);
      }
  }
  
  
  void gcomm::evs::Proto::handle_install_timer()
  {
!     gcomm_assert(get_state() == S_GATHER || get_state() == S_INSTALL);
      log_warn << self_string() << " install timer expired";
  
!     bool is_cons(consensus.is_consensus());
!     bool is_repr(is_representative(get_uuid()));
      evs_log_info(I_STATE) << "before inspection:";
      evs_log_info(I_STATE) << "consensus: " << is_cons;
      evs_log_info(I_STATE) << "repr     : " << is_repr;
      evs_log_info(I_STATE) << "state dump for diagnosis:";
      std::cerr << *this << std::endl;
  
!     if (install_timeout_count == max_install_timeouts - 1)
      {
          // before reaching max_install_timeouts, declare only inconsistent
          // nodes as inactive
!         for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
          {
!             const Node& node(NodeMap::get_value(i));
!             if (NodeMap::get_key(i) != get_uuid() &&
!                 (node.get_join_message() == 0 ||
!                  consensus.is_consistent(*node.get_join_message()) == false))
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::get_key(i)
                      << " as inactive due to expired install timer";
!                 set_inactive(NodeMap::get_key(i));
              }
          }
      }
!     else if (install_timeout_count == max_install_timeouts)
      {
          // max install timeouts reached, declare all other nodes
          // as inactive
!         for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
          {
!             if (NodeMap::get_key(i) != get_uuid())
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::get_key(i)
                      << " as inactive due to expired install timer";
!                 set_inactive(NodeMap::get_key(i));
              }
          }
      }
!     else if (install_timeout_count > max_install_timeouts)
      {
          log_info << "going to give up, state dump for diagnosis:";
          std::cerr << *this << std::endl;
          gu_throw_fatal << self_string()
                         << " failed to form singleton view after exceeding "
!                        << "max_install_timeouts " << max_install_timeouts
                         << ", giving up";
      }
  
  
!     if (install_message != 0)
      {
!         for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
          {
!             if (NodeMap::get_value(i).get_committed() == false)
              {
!                 log_info << self_string() << " node " << NodeMap::get_key(i)
                           << " failed to commit for install message, "
                           << "declaring inactive";
!                 if (NodeMap::get_key(i) != get_uuid())
                  {
!                     set_inactive(NodeMap::get_key(i));
                  }
              }
          }
--- 475,590 ----
  void gcomm::evs::Proto::handle_retrans_timer()
  {
      evs_log_debug(D_TIMERS) << "retrans timer";
!     if (state() == S_GATHER)
      {
          gu_trace(send_join(true));
!         if (install_message_ != 0)
          {
              gu_trace(send_gap(UUID::nil(),
!                               install_message_->install_view_id(),
                                Range(), true));
          }
      }
!     else if (state() == S_INSTALL)
      {
!         gcomm_assert(install_message_ != 0);
          gu_trace(send_gap(UUID::nil(),
!                           install_message_->install_view_id(),
                            Range(), true));
          gu_trace(send_gap(UUID::nil(),
!                           install_message_->install_view_id(),
                            Range()));
      }
!     else if (state() == S_OPERATIONAL)
      {
!         const seqno_t prev_last_sent(last_sent_);
!         evs_log_debug(D_TIMERS) << "send user timer, last_sent=" << last_sent_;
          Datagram dg;
          gu_trace((void)send_user(dg, 0xff, O_DROP, -1, -1));
!         if (prev_last_sent == last_sent_)
          {
              log_warn << "could not send keepalive";
          }
      }
!     else if (state() == S_LEAVING)
      {
          evs_log_debug(D_TIMERS) << "send leave timer";
!         profile_enter(send_leave_prof_);
          send_leave(false);
!         profile_leave(send_leave_prof_);
      }
  }
  
  
  void gcomm::evs::Proto::handle_install_timer()
  {
!     gcomm_assert(state() == S_GATHER || state() == S_INSTALL);
      log_warn << self_string() << " install timer expired";
  
!     bool is_cons(consensus_.is_consensus());
!     bool is_repr(is_representative(uuid()));
      evs_log_info(I_STATE) << "before inspection:";
      evs_log_info(I_STATE) << "consensus: " << is_cons;
      evs_log_info(I_STATE) << "repr     : " << is_repr;
      evs_log_info(I_STATE) << "state dump for diagnosis:";
      std::cerr << *this << std::endl;
  
!     if (install_timeout_count_ == max_install_timeouts_ - 1)
      {
          // before reaching max_install_timeouts, declare only inconsistent
          // nodes as inactive
!         for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
          {
!             const Node& node(NodeMap::value(i));
!             if (NodeMap::key(i) != uuid() &&
!                 (node.join_message() == 0 ||
!                  consensus_.is_consistent(*node.join_message()) == false))
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::key(i)
                      << " as inactive due to expired install timer";
!                 set_inactive(NodeMap::key(i));
              }
          }
      }
!     else if (install_timeout_count_ == max_install_timeouts_)
      {
          // max install timeouts reached, declare all other nodes
          // as inactive
!         for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
          {
!             if (NodeMap::key(i) != uuid())
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::key(i)
                      << " as inactive due to expired install timer";
!                 set_inactive(NodeMap::key(i));
              }
          }
      }
!     else if (install_timeout_count_ > max_install_timeouts_)
      {
          log_info << "going to give up, state dump for diagnosis:";
          std::cerr << *this << std::endl;
          gu_throw_fatal << self_string()
                         << " failed to form singleton view after exceeding "
!                        << "max_install_timeouts " << max_install_timeouts_
                         << ", giving up";
      }
  
  
!     if (install_message_ != 0)
      {
!         for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
          {
!             if (NodeMap::value(i).committed() == false)
              {
!                 log_info << self_string() << " node " << NodeMap::key(i)
                           << " failed to commit for install message, "
                           << "declaring inactive";
!                 if (NodeMap::key(i) != uuid())
                  {
!                     set_inactive(NodeMap::key(i));
                  }
              }
          }
***************
*** 580,587 ****
      }
  
      shift_to(S_GATHER, true);
!     is_cons = consensus.is_consensus();
!     is_repr = is_representative(get_uuid());
      evs_log_info(I_STATE) << "after inspection:";
      evs_log_info(I_STATE) << "consensus: " << is_cons;
      evs_log_info(I_STATE) << "repr     : " << is_repr;
--- 595,602 ----
      }
  
      shift_to(S_GATHER, true);
!     is_cons = consensus_.is_consensus();
!     is_repr = is_representative(uuid());
      evs_log_info(I_STATE) << "after inspection:";
      evs_log_info(I_STATE) << "consensus: " << is_cons;
      evs_log_info(I_STATE) << "repr     : " << is_repr;
***************
*** 589,617 ****
      {
          send_install();
      }
!     install_timeout_count++;
  }
  
  void gcomm::evs::Proto::handle_stats_timer()
  {
!     if (info_mask & I_STATISTICS)
      {
          evs_log_info(I_STATISTICS) << "statistics (stderr):";
!         std::cerr << get_stats() << std::endl;
      }
      reset_stats();
  #ifdef GCOMM_PROFILE
      evs_log_info(I_PROFILING) << "\nprofiles:\n";
!     evs_log_info(I_PROFILING) << send_user_prof    << "\n";
!     evs_log_info(I_PROFILING) << send_gap_prof     << "\n";
!     evs_log_info(I_PROFILING) << send_join_prof    << "\n";
!     evs_log_info(I_PROFILING) << send_install_prof << "\n";
!     evs_log_info(I_PROFILING) << send_leave_prof   << "\n";
!     evs_log_info(I_PROFILING) << consistent_prof   << "\n";
!     evs_log_info(I_PROFILING) << consensus_prof    << "\n";
!     evs_log_info(I_PROFILING) << shift_to_prof     << "\n";
!     evs_log_info(I_PROFILING) << input_map_prof    << "\n";
!     evs_log_info(I_PROFILING) << delivery_prof     << "\n";
  #endif // GCOMM_PROFILE
  }
  
--- 604,632 ----
      {
          send_install();
      }
!     install_timeout_count_++;
  }
  
  void gcomm::evs::Proto::handle_stats_timer()
  {
!     if (info_mask_ & I_STATISTICS)
      {
          evs_log_info(I_STATISTICS) << "statistics (stderr):";
!         std::cerr << stats() << std::endl;
      }
      reset_stats();
  #ifdef GCOMM_PROFILE
      evs_log_info(I_PROFILING) << "\nprofiles:\n";
!     evs_log_info(I_PROFILING) << send_user_prof_    << "\n";
!     evs_log_info(I_PROFILING) << send_gap_prof_     << "\n";
!     evs_log_info(I_PROFILING) << send_join_prof_    << "\n";
!     evs_log_info(I_PROFILING) << send_install_prof_ << "\n";
!     evs_log_info(I_PROFILING) << send_leave_prof_   << "\n";
!     evs_log_info(I_PROFILING) << consistent_prof_   << "\n";
!     evs_log_info(I_PROFILING) << consensus_prof_    << "\n";
!     evs_log_info(I_PROFILING) << shift_to_prof_     << "\n";
!     evs_log_info(I_PROFILING) << input_map_prof_    << "\n";
!     evs_log_info(I_PROFILING) << delivery_prof_     << "\n";
  #endif // GCOMM_PROFILE
  }
  
***************
*** 620,666 ****
  class TimerSelectOp
  {
  public:
!     TimerSelectOp(const Proto::Timer t_) : t(t_) { }
!     bool operator()(const Proto::TimerList::value_type& vt) const
      {
!         return (Proto::TimerList::get_value(vt) == t);
      }
  private:
!     Proto::Timer const t;
  };
  
  
! Date gcomm::evs::Proto::get_next_expiration(const Timer t) const
  {
!     gcomm_assert(get_state() != S_CLOSED);
!     Date now(Date::now());
      switch (t)
      {
      case T_INACTIVITY:
!         return (now + inactive_check_period);
      case T_RETRANS:
!         switch (get_state())
          {
          case S_OPERATIONAL:
          case S_LEAVING:
!             return (now + retrans_period);
          case S_GATHER:
          case S_INSTALL:
!             return (now + join_retrans_period);
          default:
              gu_throw_fatal;
          }
      case T_INSTALL:
!         switch (get_state())
          {
          case S_GATHER:
          case S_INSTALL:
!             return (now + install_timeout);
          default:
!             return Date::max();
          }
      case T_STATS:
!         return (now + stats_report_period);
      }
      gu_throw_fatal;
      throw;
--- 635,681 ----
  class TimerSelectOp
  {
  public:
!     TimerSelectOp(const gcomm::evs::Proto::Timer t_) : t(t_) { }
!     bool operator()(const gcomm::evs::Proto::TimerList::value_type& vt) const
      {
!         return (gcomm::evs::Proto::TimerList::value(vt) == t);
      }
  private:
!     gcomm::evs::Proto::Timer const t;
  };
  
  
! gu::datetime::Date gcomm::evs::Proto::next_expiration(const Timer t) const
  {
!     gcomm_assert(state() != S_CLOSED);
!     gu::datetime::Date now(gu::datetime::Date::now());
      switch (t)
      {
      case T_INACTIVITY:
!         return (now + inactive_check_period_);
      case T_RETRANS:
!         switch (state())
          {
          case S_OPERATIONAL:
          case S_LEAVING:
!             return (now + retrans_period_);
          case S_GATHER:
          case S_INSTALL:
!             return (now + join_retrans_period_);
          default:
              gu_throw_fatal;
          }
      case T_INSTALL:
!         switch (state())
          {
          case S_GATHER:
          case S_INSTALL:
!             return (now + install_timeout_);
          default:
!             return gu::datetime::Date::max();
          }
      case T_STATS:
!         return (now + stats_report_period_);
      }
      gu_throw_fatal;
      throw;
***************
*** 669,695 ****
  
  void gcomm::evs::Proto::reset_timers()
  {
!     timers.clear();
!     gu_trace((void)timers.insert(
!                  make_pair(get_next_expiration(T_INACTIVITY), T_INACTIVITY)));
!     gu_trace((void)timers.insert(
!                  make_pair(get_next_expiration(T_RETRANS), T_RETRANS)));
!     gu_trace((void)timers.insert(
!                  make_pair(get_next_expiration(T_INSTALL), T_INSTALL)));
!     gu_trace((void)timers.insert(
!                  make_pair(get_next_expiration(T_STATS), T_STATS)));
  }
  
  
! Date gcomm::evs::Proto::handle_timers()
  {
!     Date now(Date::now());
  
!     while (timers.empty() == false &&
!            TimerList::get_key(timers.begin()) <= now)
      {
!         Timer t(TimerList::get_value(timers.begin()));
!         timers.erase(timers.begin());
          switch (t)
          {
          case T_INACTIVITY:
--- 684,713 ----
  
  void gcomm::evs::Proto::reset_timers()
  {
!     timers_.clear();
!     gu_trace((void)timers_.insert(
!                  std::make_pair(
!                      next_expiration(T_INACTIVITY), T_INACTIVITY)));
!     gu_trace((void)timers_.insert(
!                  std::make_pair(
!                      next_expiration(T_RETRANS), T_RETRANS)));
!     gu_trace((void)timers_.insert(
!                  std::make_pair(
!                      next_expiration(T_INSTALL), T_INSTALL)));
!     gu_trace((void)timers_.insert(
!                  std::make_pair(next_expiration(T_STATS), T_STATS)));
  }
  
  
! gu::datetime::Date gcomm::evs::Proto::handle_timers()
  {
!     gu::datetime::Date now(gu::datetime::Date::now());
  
!     while (timers_.empty() == false &&
!            TimerList::key(timers_.begin()) <= now)
      {
!         Timer t(TimerList::value(timers_.begin()));
!         timers_.erase(timers_.begin());
          switch (t)
          {
          case T_INACTIVITY:
***************
*** 705,769 ****
              handle_stats_timer();
              break;
          }
!         if (get_state() == S_CLOSED)
          {
!             return Date::max();
          }
          // Make sure that timer was not inserted twice
!         TimerList::iterator ii(find_if(timers.begin(), timers.end(),
                                         TimerSelectOp(t)));
!         if (ii != timers.end())
          {
!             timers.erase(ii);
          }
!         gu_trace((void)timers.insert(make_pair(get_next_expiration(t), t)));
      }
  
!     if (timers.empty() == true)
      {
          evs_log_debug(D_TIMERS) << "no timers set";
!         return Date::max();
      }
!     return TimerList::get_key(timers.begin());
  }
  
  
  
  void gcomm::evs::Proto::check_inactive()
  {
!     const Date now(Date::now());
!     if (last_inactive_check + inactive_check_period*3 < now)
      {
!         log_warn << "last inactive check more than " << inactive_check_period*3
                   << " ago, skipping check";
!         last_inactive_check = now;
          return;
      }
  
!     NodeMap::get_value(self_i).set_tstamp(gu::datetime::Date::now());
!     std::for_each(known.begin(), known.end(), InspectNode());
  
      bool has_inactive(false);
      size_t n_suspected(0);
!     for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         Node& node(NodeMap::get_value(i));
!         if (uuid                   != get_uuid()    &&
              (node.is_inactive()     == true      ||
               node.is_suspected()    == true           ))
          {
!             if (node.get_operational() == true && node.is_inactive() == true)
              {
!                 log_info << self_string() << " detected inactive node: " << uuid;
              }
              else if (node.is_suspected() == true && node.is_inactive() == false)
              {
!                 log_info << self_string() << " suspecting node: " << uuid;
              }
              if (node.is_inactive() == true)
              {
!                 set_inactive(uuid);
              }
              if (node.is_suspected() == true)
              {
--- 723,788 ----
              handle_stats_timer();
              break;
          }
!         if (state() == S_CLOSED)
          {
!             return gu::datetime::Date::max();
          }
          // Make sure that timer was not inserted twice
!         TimerList::iterator ii(find_if(timers_.begin(), timers_.end(),
                                         TimerSelectOp(t)));
!         if (ii != timers_.end())
          {
!             timers_.erase(ii);
          }
!         gu_trace((void)timers_.insert(
!                      std::make_pair(next_expiration(t), t)));
      }
  
!     if (timers_.empty() == true)
      {
          evs_log_debug(D_TIMERS) << "no timers set";
!         return gu::datetime::Date::max();
      }
!     return TimerList::key(timers_.begin());
  }
  
  
  
  void gcomm::evs::Proto::check_inactive()
  {
!     const gu::datetime::Date now(gu::datetime::Date::now());
!     if (last_inactive_check_ + inactive_check_period_*3 < now)
      {
!         log_warn << "last inactive check more than " << inactive_check_period_*3
                   << " ago, skipping check";
!         last_inactive_check_ = now;
          return;
      }
  
!     NodeMap::value(self_i_).set_tstamp(gu::datetime::Date::now());
!     std::for_each(known_.begin(), known_.end(), InspectNode());
  
      bool has_inactive(false);
      size_t n_suspected(0);
!     for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& node_uuid(NodeMap::key(i));
!         Node& node(NodeMap::value(i));
!         if (node_uuid                  != uuid()    &&
              (node.is_inactive()     == true      ||
               node.is_suspected()    == true           ))
          {
!             if (node.operational() == true && node.is_inactive() == true)
              {
!                 log_info << self_string() << " detected inactive node: " << node_uuid;
              }
              else if (node.is_suspected() == true && node.is_inactive() == false)
              {
!                 log_info << self_string() << " suspecting node: " << node_uuid;
              }
              if (node.is_inactive() == true)
              {
!                 set_inactive(node_uuid);
              }
              if (node.is_suspected() == true)
              {
***************
*** 777,823 ****
      // This will speed up recovery when this node has been isolated from
      // other group. Note that this should be done only if known size is
      // greater than 2 in order to avoid immediate split brain.
!     if (known.size() > 2 && n_suspected + 1 == known.size())
      {
!         for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
          {
!             if (NodeMap::get_key(i) != get_uuid())
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::get_key(i)
                      << " inactive (other nodes under suspicion)";
!                 set_inactive(NodeMap::get_key(i));
              }
          }
      }
  
!     if (has_inactive == true && get_state() == S_OPERATIONAL)
      {
!         profile_enter(shift_to_prof);
          gu_trace(shift_to(S_GATHER, true));
!         profile_leave(shift_to_prof);
      }
      else if (has_inactive    == true &&
!              get_state()     == S_LEAVING &&
               n_operational() == 1)
      {
!         profile_enter(shift_to_prof);
          gu_trace(shift_to(S_CLOSED));
!         profile_leave(shift_to_prof);
      }
  
!     last_inactive_check = now;
  }
  
  
! void gcomm::evs::Proto::set_inactive(const UUID& uuid)
  {
      NodeMap::iterator i;
!     gcomm_assert(uuid != get_uuid());
!     gu_trace(i = known.find_checked(uuid));
!     evs_log_debug(D_STATE) << "setting " << uuid << " inactive";
!     Node& node(NodeMap::get_value(i));
!     node.set_tstamp(Date::zero());
      node.set_join_message(0);
      // node.set_leave_message(0);
      node.set_operational(false);
--- 796,842 ----
      // This will speed up recovery when this node has been isolated from
      // other group. Note that this should be done only if known size is
      // greater than 2 in order to avoid immediate split brain.
!     if (known_.size() > 2 && n_suspected + 1 == known_.size())
      {
!         for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
          {
!             if (NodeMap::key(i) != uuid())
              {
                  evs_log_info(I_STATE)
!                     << " setting source " << NodeMap::key(i)
                      << " inactive (other nodes under suspicion)";
!                 set_inactive(NodeMap::key(i));
              }
          }
      }
  
!     if (has_inactive == true && state() == S_OPERATIONAL)
      {
!         profile_enter(shift_to_prof_);
          gu_trace(shift_to(S_GATHER, true));
!         profile_leave(shift_to_prof_);
      }
      else if (has_inactive    == true &&
!              state()     == S_LEAVING &&
               n_operational() == 1)
      {
!         profile_enter(shift_to_prof_);
          gu_trace(shift_to(S_CLOSED));
!         profile_leave(shift_to_prof_);
      }
  
!     last_inactive_check_ = now;
  }
  
  
! void gcomm::evs::Proto::set_inactive(const UUID& node_uuid)
  {
      NodeMap::iterator i;
!     gcomm_assert(node_uuid != uuid());
!     gu_trace(i = known_.find_checked(node_uuid));
!     evs_log_debug(D_STATE) << "setting " << node_uuid << " inactive";
!     Node& node(NodeMap::value(i));
!     node.set_tstamp(gu::datetime::Date::zero());
      node.set_join_message(0);
      // node.set_leave_message(0);
      node.set_operational(false);
***************
*** 827,839 ****
  void gcomm::evs::Proto::cleanup_unoperational()
  {
      NodeMap::iterator i, i_next;
!     for (i = known.begin(); i != known.end(); i = i_next)
      {
          i_next = i, ++i_next;
!         if (NodeMap::get_value(i).get_installed() == false)
          {
!             evs_log_debug(D_STATE) << "erasing " << NodeMap::get_key(i);
!             known.erase(i);
          }
      }
  }
--- 846,858 ----
  void gcomm::evs::Proto::cleanup_unoperational()
  {
      NodeMap::iterator i, i_next;
!     for (i = known_.begin(); i != known_.end(); i = i_next)
      {
          i_next = i, ++i_next;
!         if (NodeMap::value(i).installed() == false)
          {
!             evs_log_debug(D_STATE) << "erasing " << NodeMap::key(i);
!             known_.erase(i);
          }
      }
  }
***************
*** 841,860 ****
  
  void gcomm::evs::Proto::cleanup_views()
  {
!     Date now(Date::now());
!     list<pair<ViewId, Date> >::iterator i = previous_views.begin();
!     while (i != previous_views.end())
      {
!         if (i->second + view_forget_timeout <= now)
          {
              evs_log_debug(D_STATE) << " erasing view: " << i->first;
!             previous_views.erase(i);
          }
          else
          {
              break;
          }
!         i = previous_views.begin();
      }
  }
  
--- 860,880 ----
  
  void gcomm::evs::Proto::cleanup_views()
  {
!     gu::datetime::Date now(gu::datetime::Date::now());
!     std::list<std::pair<ViewId, gu::datetime::Date> >::iterator
!         i(previous_views_.begin());
!     while (i != previous_views_.end())
      {
!         if (i->second + view_forget_timeout_ <= now)
          {
              evs_log_debug(D_STATE) << " erasing view: " << i->first;
!             previous_views_.erase(i);
          }
          else
          {
              break;
          }
!         i = previous_views_.begin();
      }
  }
  
***************
*** 862,869 ****
  {
      NodeMap::const_iterator i;
      size_t ret = 0;
!     for (i = known.begin(); i != known.end(); ++i) {
!         if (i->second.get_operational() == true)
              ret++;
      }
      return ret;
--- 882,889 ----
  {
      NodeMap::const_iterator i;
      size_t ret = 0;
!     for (i = known_.begin(); i != known_.end(); ++i) {
!         if (i->second.operational() == true)
              ret++;
      }
      return ret;
***************
*** 871,915 ****
  
  void gcomm::evs::Proto::deliver_reg_view()
  {
!     if (install_message == 0)
      {
          gu_throw_fatal
              << "Protocol error: no install message in deliver reg view";
      }
  
!     if (previous_views.size() == 0) gu_throw_fatal << "Zero-size view";
  
!     const View& prev_view (previous_view);
!     View view (install_message->get_install_view_id());
  
!     for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
      {
!         if (NodeMap::get_value(i).get_installed() == true)
          {
!             view.add_member(NodeMap::get_key(i), "");
!             if (prev_view.get_members().find(NodeMap::get_key(i)) ==
!                 prev_view.get_members().end())
              {
!                 view.add_joined(NodeMap::get_key(i), "");
              }
          }
!         else if (NodeMap::get_value(i).get_installed() == false)
          {
!             const MessageNodeList& instances = install_message->get_node_list();
              MessageNodeList::const_iterator inst_i;
!             if ((inst_i = instances.find(NodeMap::get_key(i))) != instances.end())
              {
!                 if (MessageNodeList::get_value(inst_i).get_leaving() == true)
                  {
!                     view.add_left(NodeMap::get_key(i), "");
                  }
                  else
                  {
!                     view.add_partitioned(NodeMap::get_key(i), "");
                  }
              }
!             gcomm_assert(NodeMap::get_key(i) != get_uuid());
!             gcomm_assert(NodeMap::get_value(i).get_operational() == false);
          }
      }
  
--- 891,935 ----
  
  void gcomm::evs::Proto::deliver_reg_view()
  {
!     if (install_message_ == 0)
      {
          gu_throw_fatal
              << "Protocol error: no install message in deliver reg view";
      }
  
!     if (previous_views_.size() == 0) gu_throw_fatal << "Zero-size view";
  
!     const View& prev_view (previous_view_);
!     View view (install_message_->install_view_id());
  
!     for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         if (NodeMap::value(i).installed() == true)
          {
!             view.add_member(NodeMap::key(i), "");
!             if (prev_view.members().find(NodeMap::key(i)) ==
!                 prev_view.members().end())
              {
!                 view.add_joined(NodeMap::key(i), "");
              }
          }
!         else if (NodeMap::value(i).installed() == false)
          {
!             const MessageNodeList& instances = install_message_->node_list();
              MessageNodeList::const_iterator inst_i;
!             if ((inst_i = instances.find(NodeMap::key(i))) != instances.end())
              {
!                 if (MessageNodeList::value(inst_i).leaving() == true)
                  {
!                     view.add_left(NodeMap::key(i), "");
                  }
                  else
                  {
!                     view.add_partitioned(NodeMap::key(i), "");
                  }
              }
!             gcomm_assert(NodeMap::key(i) != uuid());
!             gcomm_assert(NodeMap::value(i).operational() == false);
          }
      }
  
***************
*** 922,970 ****
  
  void gcomm::evs::Proto::deliver_trans_view(bool local)
  {
!     if (local == false && install_message == 0)
      {
          gu_throw_fatal
              << "Protocol error: no install message in deliver trans view";
      }
  
      View view(ViewId(V_TRANS,
!                      current_view.get_id().get_uuid(),
!                      current_view.get_id().get_seq()));
  
!     for (NodeMap::const_iterator i = known.begin(); i != known.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         const Node& inst(NodeMap::get_value(i));
  
!         if (inst.get_installed() == true &&
!             current_view.get_members().find(uuid) !=
!             current_view.get_members().end() &&
              (local == true ||
!              MessageNodeList::get_value(install_message->get_node_list().find_checked(uuid)).get_view_id() == current_view.get_id()))
          {
!             view.add_member(NodeMap::get_key(i), "");
          }
!         else if (inst.get_installed() == false)
          {
              if (local == false)
              {
!                 const MessageNodeList& instances(install_message->get_node_list());
                  MessageNodeList::const_iterator inst_i;
!                 if ((inst_i = instances.find(NodeMap::get_key(i))) != instances.end())
                  {
!                     if (MessageNodeList::get_value(inst_i).get_leaving())
                      {
!                         view.add_left(NodeMap::get_key(i), "");
                      }
                      else
                      {
!                         view.add_partitioned(NodeMap::get_key(i), "");
                      }
                  }
!                 else if (current_view.is_member(NodeMap::get_key(i)) == true)
                  {
!                     view.add_partitioned(NodeMap::get_key(i), "");
                  }
              }
              else
--- 942,990 ----
  
  void gcomm::evs::Proto::deliver_trans_view(bool local)
  {
!     if (local == false && install_message_ == 0)
      {
          gu_throw_fatal
              << "Protocol error: no install message in deliver trans view";
      }
  
      View view(ViewId(V_TRANS,
!                      current_view_.id().uuid(),
!                      current_view_.id().seq()));
  
!     for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& uuid(NodeMap::key(i));
!         const Node& inst(NodeMap::value(i));
  
!         if (inst.installed() == true &&
!             current_view_.members().find(uuid) !=
!             current_view_.members().end() &&
              (local == true ||
!              MessageNodeList::value(install_message_->node_list().find_checked(uuid)).view_id() == current_view_.id()))
          {
!             view.add_member(NodeMap::key(i), "");
          }
!         else if (inst.installed() == false)
          {
              if (local == false)
              {
!                 const MessageNodeList& instances(install_message_->node_list());
                  MessageNodeList::const_iterator inst_i;
!                 if ((inst_i = instances.find(NodeMap::key(i))) != instances.end())
                  {
!                     if (MessageNodeList::value(inst_i).leaving())
                      {
!                         view.add_left(NodeMap::key(i), "");
                      }
                      else
                      {
!                         view.add_partitioned(NodeMap::key(i), "");
                      }
                  }
!                 else if (current_view_.is_member(NodeMap::key(i)) == true)
                  {
!                     view.add_partitioned(NodeMap::key(i), "");
                  }
              }
              else
***************
*** 973,979 ****
                  // for leaving node anyway and it is not guaranteed if
                  // the others get the leave message, so it is not safe
                  // to assume then as left.
!                 view.add_partitioned(NodeMap::get_key(i), "");
              }
          }
          else
--- 993,999 ----
                  // for leaving node anyway and it is not guaranteed if
                  // the others get the leave message, so it is not safe
                  // to assume then as left.
!                 view.add_partitioned(NodeMap::key(i), "");
              }
          }
          else
***************
*** 982,988 ****
          }
      }
  
!     gcomm_assert(view.is_member(get_uuid()) == true);
  
      evs_log_info(I_VIEWS) << " delivering view " << view;
  
--- 1002,1008 ----
          }
      }
  
!     gcomm_assert(view.is_member(uuid()) == true);
  
      evs_log_info(I_VIEWS) << " delivering view " << view;
  
***************
*** 1004,1021 ****
  
  void gcomm::evs::Proto::setall_committed(bool val)
  {
!     for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
      {
!         NodeMap::get_value(i).set_committed(val);
      }
  }
  
  bool gcomm::evs::Proto::is_all_committed() const
  {
!     for (NodeMap::const_iterator i = known.begin(); i != known.end(); ++i)
      {
!         const Node& inst(NodeMap::get_value(i));
!         if (inst.get_operational() == true && inst.get_committed() == false)
          {
              return false;
          }
--- 1024,1041 ----
  
  void gcomm::evs::Proto::setall_committed(bool val)
  {
!     for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         NodeMap::value(i).set_committed(val);
      }
  }
  
  bool gcomm::evs::Proto::is_all_committed() const
  {
!     for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const Node& inst(NodeMap::value(i));
!         if (inst.operational() == true && inst.committed() == false)
          {
              return false;
          }
***************
*** 1025,1052 ****
  
  void gcomm::evs::Proto::setall_installed(bool val)
  {
!     for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
      {
!         NodeMap::get_value(i).set_installed(val);
      }
  }
  
  
  void gcomm::evs::Proto::cleanup_joins()
  {
!     for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
      {
!         NodeMap::get_value(i).set_join_message(0);
      }
  }
  
  
  bool gcomm::evs::Proto::is_all_installed() const
  {
!     for (NodeMap::const_iterator i = known.begin(); i != known.end(); ++i)
      {
!         const Node& inst(NodeMap::get_value(i));
!         if (inst.get_operational() == true && inst.get_installed() == false)
          {
              return false;
          }
--- 1045,1072 ----
  
  void gcomm::evs::Proto::setall_installed(bool val)
  {
!     for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         NodeMap::value(i).set_installed(val);
      }
  }
  
  
  void gcomm::evs::Proto::cleanup_joins()
  {
!     for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         NodeMap::value(i).set_join_message(0);
      }
  }
  
  
  bool gcomm::evs::Proto::is_all_installed() const
  {
!     for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const Node& inst(NodeMap::value(i));
!         if (inst.operational() == true && inst.installed() == false)
          {
              return false;
          }
***************
*** 1059,1071 ****
  
  bool gcomm::evs::Proto::is_representative(const UUID& uuid) const
  {
!     for (NodeMap::const_iterator i = known.begin(); i != known.end(); ++i)
      {
!         if (NodeMap::get_value(i).get_operational() == true &&
!             NodeMap::get_value(i).is_inactive()     == false)
          {
!             gcomm_assert(NodeMap::get_value(i).get_leave_message() == 0);
!             return (uuid == NodeMap::get_key(i));
          }
      }
  
--- 1079,1091 ----
  
  bool gcomm::evs::Proto::is_representative(const UUID& uuid) const
  {
!     for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         if (NodeMap::value(i).operational() == true &&
!             NodeMap::value(i).is_inactive()     == false)
          {
!             gcomm_assert(NodeMap::value(i).leave_message() == 0);
!             return (uuid == NodeMap::key(i));
          }
      }
  
***************
*** 1085,1091 ****
  {
      gcomm_assert(seq != -1 && win != -1);
  
!     const seqno_t base(input_map->get_aru_seq());
      if (seq > base + win)
      {
          return true;
--- 1105,1111 ----
  {
      gcomm_assert(seq != -1 && win != -1);
  
!     const seqno_t base(input_map_->aru_seq());
      if (seq > base + win)
      {
          return true;
***************
*** 1100,1116 ****
                                   seqno_t const up_to_seqno,
                                   size_t const n_aggregated)
  {
!     assert(get_state() == S_LEAVING ||
!            get_state() == S_GATHER ||
!            get_state() == S_OPERATIONAL);
!     assert(dg.get_offset() == 0);
!     assert(n_aggregated == 1 || output.size() >= n_aggregated);
  
!     gcomm_assert(up_to_seqno == -1 || up_to_seqno >= last_sent);
      gcomm_assert(up_to_seqno == -1 || win == -1);
  
      int ret;
!     const seqno_t seq(last_sent + 1);
  
      if (win                       != -1   &&
          is_flow_control(seq, win) == true)
--- 1120,1136 ----
                                   seqno_t const up_to_seqno,
                                   size_t const n_aggregated)
  {
!     assert(state() == S_LEAVING ||
!            state() == S_GATHER ||
!            state() == S_OPERATIONAL);
!     assert(dg.offset() == 0);
!     assert(n_aggregated == 1 || output_.size() >= n_aggregated);
  
!     gcomm_assert(up_to_seqno == -1 || up_to_seqno >= last_sent_);
      gcomm_assert(up_to_seqno == -1 || win == -1);
  
      int ret;
!     const seqno_t seq(last_sent_ + 1);
  
      if (win                       != -1   &&
          is_flow_control(seq, win) == true)
***************
*** 1122,1128 ****
      seqno_t last_msg_seq(seq + seq_range);
      uint8_t flags;
  
!     if (output.size() <= n_aggregated ||
          up_to_seqno != -1 ||
          (win != -1 && is_flow_control(last_msg_seq + 1, win) == true))
      {
--- 1142,1148 ----
      seqno_t last_msg_seq(seq + seq_range);
      uint8_t flags;
  
!     if (output_.size() <= n_aggregated ||
          up_to_seqno != -1 ||
          (win != -1 && is_flow_control(last_msg_seq + 1, win) == true))
      {
***************
*** 1139,1147 ****
  
      if ((flags & Message::F_MSG_MORE) == 0 && up_to_seqno == -1)
      {
!         seq_range = input_map->get_max_hs() - seq;
!         seq_range = max(static_cast<seqno_t>(0), seq_range);
!         seq_range = min(static_cast<seqno_t>(0xff), seq_range);
          if (seq_range != 0)
          {
              log_debug << "adjusted seq range to: " << seq_range;
--- 1159,1167 ----
  
      if ((flags & Message::F_MSG_MORE) == 0 && up_to_seqno == -1)
      {
!         seq_range = input_map_->max_hs() - seq;
!         seq_range = std::max(static_cast<seqno_t>(0), seq_range);
!         seq_range = std::min(static_cast<seqno_t>(0xff), seq_range);
          if (seq_range != 0)
          {
              log_debug << "adjusted seq range to: " << seq_range;
***************
*** 1156,1187 ****
      }
      gcomm_assert(seq_range >= 0 && seq_range <= 0xff);
  
!     UserMessage msg(version,
!                     get_uuid(),
!                     current_view.get_id(),
                      seq,
!                     input_map->get_aru_seq(),
                      seq_range,
                      order,
!                     ++fifo_seq,
                      user_type,
                      flags);
  
      // Insert first to input map to determine correct aru seq
      Range range;
!     gu_trace(range = input_map->insert(NodeMap::get_value(self_i).get_index(),
                                         msg, dg));
  
!     gcomm_assert(range.get_hs() == last_msg_seq)
!         << msg << " " << *input_map << " " << *this;
  
!     last_sent = last_msg_seq;
!     assert(range.get_hs() == last_sent);
  
!     update_im_safe_seq(NodeMap::get_value(self_i).get_index(),
!                        input_map->get_aru_seq());
  
!     msg.set_aru_seq(input_map->get_aru_seq());
      evs_log_debug(D_USER_MSGS) << " sending " << msg;
      gu_trace(push_header(msg, dg));
      if ((ret = send_down(dg, ProtoDownMeta())) != 0)
--- 1176,1207 ----
      }
      gcomm_assert(seq_range >= 0 && seq_range <= 0xff);
  
!     UserMessage msg(version_,
!                     uuid(),
!                     current_view_.id(),
                      seq,
!                     input_map_->aru_seq(),
                      seq_range,
                      order,
!                     ++fifo_seq_,
                      user_type,
                      flags);
  
      // Insert first to input map to determine correct aru seq
      Range range;
!     gu_trace(range = input_map_->insert(NodeMap::value(self_i_).index(),
                                         msg, dg));
  
!     gcomm_assert(range.hs() == last_msg_seq)
!         << msg << " " << *input_map_ << " " << *this;
  
!     last_sent_ = last_msg_seq;
!     assert(range.hs() == last_sent_);
  
!     update_im_safe_seq(NodeMap::value(self_i_).index(),
!                        input_map_->aru_seq());
  
!     msg.set_aru_seq(input_map_->aru_seq());
      evs_log_debug(D_USER_MSGS) << " sending " << msg;
      gu_trace(push_header(msg, dg));
      if ((ret = send_down(dg, ProtoDownMeta())) != 0)
***************
*** 1189,1197 ****
          log_debug << "send failed: "  << strerror(ret);
      }
      gu_trace(pop_header(msg, dg));
!     sent_msgs[Message::T_USER]++;
  
!     if (delivering == false && input_map->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
--- 1209,1217 ----
          log_debug << "send failed: "  << strerror(ret);
      }
      gu_trace(pop_header(msg, dg));
!     sent_msgs_[Message::T_USER]++;
  
!     if (delivering_ == false && input_map_->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
***************
*** 1204,1217 ****
      bool is_aggregate(false);
      size_t ret(0);
      AggregateMessage am;
!     deque<pair<Datagram, ProtoDownMeta> >::const_iterator i(output.begin());
!     const Order ord(i->second.get_order());
!     ret += i->first.get_len() + am.serial_size();
!     for (++i; i != output.end() && i->second.get_order() == ord; ++i)
      {
!         if (ret + i->first.get_len() + am.serial_size() <= get_mtu())
          {
!             ret += i->first.get_len() + am.serial_size();
              is_aggregate = true;
          }
          else
--- 1224,1238 ----
      bool is_aggregate(false);
      size_t ret(0);
      AggregateMessage am;
!     std::deque<std::pair<Datagram, ProtoDownMeta> >::const_iterator
!         i(output_.begin());
!     const Order ord(i->second.order());
!     ret += i->first.len() + am.serial_size();
!     for (++i; i != output_.end() && i->second.order() == ord; ++i)
      {
!         if (ret + i->first.len() + am.serial_size() <= mtu())
          {
!             ret += i->first.len() + am.serial_size();
              is_aggregate = true;
          }
          else
***************
*** 1225,1284 ****
  
  int gcomm::evs::Proto::send_user(const seqno_t win)
  {
!     gcomm_assert(output.empty() == false);
!     gcomm_assert(get_state() == S_OPERATIONAL);
!     gcomm_assert(win <= send_window);
      int ret;
      size_t alen;
!     if (use_aggregate == true && (alen = aggregate_len()) > 0)
      {
          // Messages can be aggregated into single message
          send_buf_.resize(alen);
          size_t offset(0);
          size_t n(0);
  
!         deque<pair<Datagram, ProtoDownMeta> >::iterator i(output.begin());
!         Order ord(i->second.get_order());
!         while ((alen > 0 && i != output.end()))
          {
              const Datagram& dg(i->first);
              const ProtoDownMeta dm(i->second);
!             AggregateMessage am(0, dg.get_len(), dm.get_user_type());
!             gcomm_assert(alen >= dg.get_len() + am.serial_size());
  
              gu_trace(offset = am.serialize(&send_buf_[0],
                                             send_buf_.size(), offset));
!             copy(dg.get_header() + dg.get_header_offset(),
!                  dg.get_header() + dg.get_header_size(),
!                  &send_buf_[0] + offset);
!             offset += (dg.get_header_len());
!             copy(dg.get_payload().begin(), dg.get_payload().end(),
!                  &send_buf_[0] + offset);
!             offset += dg.get_payload().size();
!             alen -= dg.get_len() + am.serial_size();
              ++n;
              ++i;
          }
!         Datagram dg(SharedBuffer(new Buffer(send_buf_.begin(),
!                                             send_buf_.end())));
          if ((ret = send_user(dg, 0xff, ord, win, -1, n)) == 0)
          {
              while (n-- > 0)
              {
!                 output.pop_front();
              }
          }
      }
      else
      {
!         pair<Datagram, ProtoDownMeta> wb(output.front());
          if ((ret = send_user(wb.first,
!                              wb.second.get_user_type(),
!                              wb.second.get_order(),
                               win,
                               -1)) == 0)
          {
!             output.pop_front();
          }
      }
      return ret;
--- 1246,1306 ----
  
  int gcomm::evs::Proto::send_user(const seqno_t win)
  {
!     gcomm_assert(output_.empty() == false);
!     gcomm_assert(state() == S_OPERATIONAL);
!     gcomm_assert(win <= send_window_);
      int ret;
      size_t alen;
!     if (use_aggregate_ == true && (alen = aggregate_len()) > 0)
      {
          // Messages can be aggregated into single message
          send_buf_.resize(alen);
          size_t offset(0);
          size_t n(0);
  
!         std::deque<std::pair<Datagram, ProtoDownMeta> >::iterator
!             i(output_.begin());
!         Order ord(i->second.order());
!         while ((alen > 0 && i != output_.end()))
          {
              const Datagram& dg(i->first);
              const ProtoDownMeta dm(i->second);
!             AggregateMessage am(0, dg.len(), dm.user_type());
!             gcomm_assert(alen >= dg.len() + am.serial_size());
  
              gu_trace(offset = am.serialize(&send_buf_[0],
                                             send_buf_.size(), offset));
!             std::copy(dg.header() + dg.header_offset(),
!                       dg.header() + dg.header_size(),
!                       &send_buf_[0] + offset);
!             offset += (dg.header_len());
!             std::copy(dg.payload().begin(), dg.payload().end(),
!                       &send_buf_[0] + offset);
!             offset += dg.payload().size();
!             alen -= dg.len() + am.serial_size();
              ++n;
              ++i;
          }
!         Datagram dg(gu::SharedBuffer(new gu::Buffer(send_buf_.begin(),
!                                                         send_buf_.end())));
          if ((ret = send_user(dg, 0xff, ord, win, -1, n)) == 0)
          {
              while (n-- > 0)
              {
!                 output_.pop_front();
              }
          }
      }
      else
      {
!         std::pair<Datagram, ProtoDownMeta> wb(output_.front());
          if ((ret = send_user(wb.first,
!                              wb.second.user_type(),
!                              wb.second.order(),
                               win,
                               -1)) == 0)
          {
!             output_.pop_front();
          }
      }
      return ret;
***************
*** 1287,1306 ****
  
  void gcomm::evs::Proto::complete_user(const seqno_t high_seq)
  {
!     gcomm_assert(get_state() == S_OPERATIONAL || get_state() == S_GATHER);
  
      evs_log_debug(D_USER_MSGS) << "completing seqno to " << high_seq;;
  
      Datagram wb;
      int err;
!     profile_enter(send_user_prof);
      err = send_user(wb, 0xff, O_DROP, -1, high_seq);
!     profile_leave(send_user_prof);
      if (err != 0)
      {
          log_debug << "failed to send completing msg " << strerror(err)
!                   << " seq=" << high_seq << " send_window=" << send_window
!                   << " last_sent=" << last_sent;
      }
  
  }
--- 1309,1328 ----
  
  void gcomm::evs::Proto::complete_user(const seqno_t high_seq)
  {
!     gcomm_assert(state() == S_OPERATIONAL || state() == S_GATHER);
  
      evs_log_debug(D_USER_MSGS) << "completing seqno to " << high_seq;;
  
      Datagram wb;
      int err;
!     profile_enter(send_user_prof_);
      err = send_user(wb, 0xff, O_DROP, -1, high_seq);
!     profile_leave(send_user_prof_);
      if (err != 0)
      {
          log_debug << "failed to send completing msg " << strerror(err)
!                   << " seq=" << high_seq << " send_window=" << send_window_
!                   << " last_sent=" << last_sent_;
      }
  
  }
***************
*** 1308,1318 ****
  
  int gcomm::evs::Proto::send_delegate(Datagram& wb)
  {
!     DelegateMessage dm(version, get_uuid(), current_view.get_id(), ++fifo_seq);
      push_header(dm, wb);
      int ret = send_down(wb, ProtoDownMeta());
      pop_header(dm, wb);
!     sent_msgs[Message::T_DELEGATE]++;
      return ret;
  }
  
--- 1330,1341 ----
  
  int gcomm::evs::Proto::send_delegate(Datagram& wb)
  {
!     DelegateMessage dm(version_, uuid(), current_view_.id(),
!                        ++fifo_seq_);
      push_header(dm, wb);
      int ret = send_down(wb, ProtoDownMeta());
      pop_header(dm, wb);
!     sent_msgs_[Message::T_DELEGATE]++;
      return ret;
  }
  
***************
*** 1325,1350 ****
      evs_log_debug(D_GAP_MSGS) << "sending gap  to "
                                << range_uuid
                                << " requesting range " << range;
!     gcomm_assert((commit == false && source_view_id == current_view.get_id())
!                  || install_message != 0);
      // TODO: Investigate if gap sending can be somehow limited,
      // message loss happen most probably during congestion and
      // flooding network with gap messages won't probably make
      // conditions better
  
!     GapMessage gm(version,
!                   get_uuid(),
                    source_view_id,
!                   (source_view_id == current_view.get_id() ? last_sent :
!                    (commit == true ? install_message->get_fifo_seq() : -1)),
!                   (source_view_id == current_view.get_id() ?
!                    input_map->get_aru_seq() : -1),
!                   ++fifo_seq,
                    range_uuid,
                    range,
                    (commit == true ? Message::F_COMMIT : static_cast<uint8_t>(0)));
  
!     Buffer buf;
      serialize(gm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
--- 1348,1373 ----
      evs_log_debug(D_GAP_MSGS) << "sending gap  to "
                                << range_uuid
                                << " requesting range " << range;
!     gcomm_assert((commit == false && source_view_id == current_view_.id())
!                  || install_message_ != 0);
      // TODO: Investigate if gap sending can be somehow limited,
      // message loss happen most probably during congestion and
      // flooding network with gap messages won't probably make
      // conditions better
  
!     GapMessage gm(version_,
!                   uuid(),
                    source_view_id,
!                   (source_view_id == current_view_.id() ? last_sent_ :
!                    (commit == true ? install_message_->fifo_seq() : -1)),
!                   (source_view_id == current_view_.id() ?
!                    input_map_->aru_seq() : -1),
!                   ++fifo_seq_,
                    range_uuid,
                    range,
                    (commit == true ? Message::F_COMMIT : static_cast<uint8_t>(0)));
  
!     gu::Buffer buf;
      serialize(gm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
***************
*** 1352,1412 ****
      {
          log_debug << "send failed: " << strerror(err);
      }
!     sent_msgs[Message::T_GAP]++;
!     gu_trace(handle_gap(gm, self_i));
  }
  
  
  void gcomm::evs::Proto::populate_node_list(MessageNodeList* node_list) const
  {
!     for (NodeMap::const_iterator i = known.begin(); i != known.end(); ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         const Node& node(NodeMap::get_value(i));
!         MessageNode mnode(node.get_operational(), node.get_suspected());
!         if (uuid != get_uuid())
          {
!             const JoinMessage* jm(node.get_join_message());
!             const LeaveMessage* lm(node.get_leave_message());
  
              //
              if (jm != 0)
              {
!                 const ViewId& nsv(jm->get_source_view_id());
!                 const MessageNode& mn(MessageNodeList::get_value(jm->get_node_list().find_checked(uuid)));
!                 mnode = MessageNode(node.get_operational(),
                                      node.is_suspected(),
                                      -1,
!                                     jm->get_source_view_id(),
!                                     (nsv == current_view.get_id() ?
!                                      input_map->get_safe_seq(node.get_index()) :
!                                      mn.get_safe_seq()),
!                                     (nsv == current_view.get_id() ?
!                                      input_map->get_range(node.get_index()) :
!                                      mn.get_im_range()));
              }
              else if (lm != 0)
              {
!                 const ViewId& nsv(lm->get_source_view_id());
!                 mnode = MessageNode(node.get_operational(),
                                      node.is_suspected(),
!                                     lm->get_seq(),
                                      nsv,
!                                     (nsv == current_view.get_id() ?
!                                      input_map->get_safe_seq(node.get_index()) :
                                       -1),
!                                     (nsv == current_view.get_id() ?
!                                      input_map->get_range(node.get_index()) :
                                       Range()));
              }
!             else if (current_view.is_member(uuid) == true)
              {
!                 mnode = MessageNode(node.get_operational(),
                                      node.is_suspected(),
                                      -1,
!                                     current_view.get_id(),
!                                     input_map->get_safe_seq(node.get_index()),
!                                     input_map->get_range(node.get_index()));
              }
          }
          else
--- 1375,1435 ----
      {
          log_debug << "send failed: " << strerror(err);
      }
!     sent_msgs_[Message::T_GAP]++;
!     gu_trace(handle_gap(gm, self_i_));
  }
  
  
  void gcomm::evs::Proto::populate_node_list(MessageNodeList* node_list) const
  {
!     for (NodeMap::const_iterator i = known_.begin(); i != known_.end(); ++i)
      {
!         const UUID& node_uuid(NodeMap::key(i));
!         const Node& node(NodeMap::value(i));
!         MessageNode mnode(node.operational(), node.suspected());
!         if (node_uuid != uuid())
          {
!             const JoinMessage* jm(node.join_message());
!             const LeaveMessage* lm(node.leave_message());
  
              //
              if (jm != 0)
              {
!                 const ViewId& nsv(jm->source_view_id());
!                 const MessageNode& mn(MessageNodeList::value(jm->node_list().find_checked(node_uuid)));
!                 mnode = MessageNode(node.operational(),
                                      node.is_suspected(),
                                      -1,
!                                     jm->source_view_id(),
!                                     (nsv == current_view_.id() ?
!                                      input_map_->safe_seq(node.index()) :
!                                      mn.safe_seq()),
!                                     (nsv == current_view_.id() ?
!                                      input_map_->range(node.index()) :
!                                      mn.im_range()));
              }
              else if (lm != 0)
              {
!                 const ViewId& nsv(lm->source_view_id());
!                 mnode = MessageNode(node.operational(),
                                      node.is_suspected(),
!                                     lm->seq(),
                                      nsv,
!                                     (nsv == current_view_.id() ?
!                                      input_map_->safe_seq(node.index()) :
                                       -1),
!                                     (nsv == current_view_.id() ?
!                                      input_map_->range(node.index()) :
                                       Range()));
              }
!             else if (current_view_.is_member(node_uuid) == true)
              {
!                 mnode = MessageNode(node.operational(),
                                      node.is_suspected(),
                                      -1,
!                                     current_view_.id(),
!                                     input_map_->safe_seq(node.index()),
!                                     input_map_->range(node.index()));
              }
          }
          else
***************
*** 1414,1474 ****
              mnode = MessageNode(true,
                                  false,
                                  -1,
!                                 current_view.get_id(),
!                                 input_map->get_safe_seq(node.get_index()),
!                                 input_map->get_range(node.get_index()));
          }
!         gu_trace((void)node_list->insert_unique(make_pair(uuid, mnode)));
      }
  
      evs_log_debug(D_CONSENSUS) << "populate node list:\n" << *node_list;
  }
  
! const JoinMessage& gcomm::evs::Proto::create_join()
  {
  
      MessageNodeList node_list;
  
      gu_trace(populate_node_list(&node_list));
!     JoinMessage jm(version,
!                    get_uuid(),
!                    current_view.get_id(),
!                    input_map->get_safe_seq(),
!                    input_map->get_aru_seq(),
!                    ++fifo_seq,
                     node_list);
!     NodeMap::get_value(self_i).set_join_message(&jm);
  
      evs_log_debug(D_JOIN_MSGS) << " created join message " << jm;
  
      // Note: This assertion does not hold anymore, join message is
      //       not necessarily equal to local state.
!     // gcomm_assert(consensus.is_consistent_same_view(jm) == true)
      //    << "created inconsistent JOIN message " << jm
      //    << " local state " << *this;
  
!     return *NodeMap::get_value(self_i).get_join_message();
  }
  
  
  void gcomm::evs::Proto::set_join(const JoinMessage& jm, const UUID& source)
  {
      NodeMap::iterator i;
!     gu_trace(i = known.find_checked(source));
!     NodeMap::get_value(i).set_join_message(&jm);;
  }
  
  
  void gcomm::evs::Proto::set_leave(const LeaveMessage& lm, const UUID& source)
  {
      NodeMap::iterator i;
!     gu_trace(i = known.find_checked(source));
!     Node& inst(NodeMap::get_value(i));
  
!     if (inst.get_leave_message())
      {
          evs_log_debug(D_LEAVE_MSGS) << "Duplicate leave:\told: "
!                                     << *inst.get_leave_message()
                                      << "\tnew: " << lm;
      }
      else
--- 1437,1497 ----
              mnode = MessageNode(true,
                                  false,
                                  -1,
!                                 current_view_.id(),
!                                 input_map_->safe_seq(node.index()),
!                                 input_map_->range(node.index()));
          }
!         gu_trace((void)node_list->insert_unique(std::make_pair(node_uuid, mnode)));
      }
  
      evs_log_debug(D_CONSENSUS) << "populate node list:\n" << *node_list;
  }
  
! const gcomm::evs::JoinMessage& gcomm::evs::Proto::create_join()
  {
  
      MessageNodeList node_list;
  
      gu_trace(populate_node_list(&node_list));
!     JoinMessage jm(version_,
!                    uuid(),
!                    current_view_.id(),
!                    input_map_->safe_seq(),
!                    input_map_->aru_seq(),
!                    ++fifo_seq_,
                     node_list);
!     NodeMap::value(self_i_).set_join_message(&jm);
  
      evs_log_debug(D_JOIN_MSGS) << " created join message " << jm;
  
      // Note: This assertion does not hold anymore, join message is
      //       not necessarily equal to local state.
!     // gcomm_assert(consensus_.is_consistent_same_view(jm) == true)
      //    << "created inconsistent JOIN message " << jm
      //    << " local state " << *this;
  
!     return *NodeMap::value(self_i_).join_message();
  }
  
  
  void gcomm::evs::Proto::set_join(const JoinMessage& jm, const UUID& source)
  {
      NodeMap::iterator i;
!     gu_trace(i = known_.find_checked(source));
!     NodeMap::value(i).set_join_message(&jm);;
  }
  
  
  void gcomm::evs::Proto::set_leave(const LeaveMessage& lm, const UUID& source)
  {
      NodeMap::iterator i;
!     gu_trace(i = known_.find_checked(source));
!     Node& inst(NodeMap::value(i));
  
!     if (inst.leave_message())
      {
          evs_log_debug(D_LEAVE_MSGS) << "Duplicate leave:\told: "
!                                     << *inst.leave_message()
                                      << "\tnew: " << lm;
      }
      else
***************
*** 1480,1490 ****
  
  void gcomm::evs::Proto::send_join(bool handle)
  {
!     assert(output.empty() == true);
  
      JoinMessage jm(create_join());
  
!     Buffer buf;
      serialize(jm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
--- 1503,1513 ----
  
  void gcomm::evs::Proto::send_join(bool handle)
  {
!     assert(output_.empty() == true);
  
      JoinMessage jm(create_join());
  
!     gu::Buffer buf;
      serialize(jm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
***************
*** 1493,1543 ****
      {
          log_debug << "send failed: " << strerror(err);
      }
!     sent_msgs[Message::T_JOIN]++;
      if (handle == true)
      {
!         handle_join(jm, self_i);
      }
  }
  
  
  void gcomm::evs::Proto::send_leave(bool handle)
  {
!     gcomm_assert(get_state() == S_LEAVING);
  
      // If no messages have been sent, generate one dummy to
      // trigger message acknowledgement mechanism
!     if (last_sent == -1 && output.empty() == true)
      {
          Datagram wb;
          gu_trace(send_user(wb, 0xff, O_DROP, -1, -1));
      }
  
      /* Move all pending messages from output to input map */
!     while (output.empty() == false)
      {
!         pair<Datagram, ProtoDownMeta> wb = output.front();
          if (send_user(wb.first,
!                       wb.second.get_user_type(),
!                       wb.second.get_order(),
                        -1, -1) != 0)
          {
              gu_throw_fatal << "send_user() failed";
          }
!         output.pop_front();
      }
  
  
!     LeaveMessage lm(version,
!                     get_uuid(),
!                     current_view.get_id(),
!                     last_sent,
!                     input_map->get_aru_seq(),
!                     ++fifo_seq);
  
      evs_log_debug(D_LEAVE_MSGS) << "sending leave msg " << lm;
  
!     Buffer buf;
      serialize(lm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
--- 1516,1566 ----
      {
          log_debug << "send failed: " << strerror(err);
      }
!     sent_msgs_[Message::T_JOIN]++;
      if (handle == true)
      {
!         handle_join(jm, self_i_);
      }
  }
  
  
  void gcomm::evs::Proto::send_leave(bool handle)
  {
!     gcomm_assert(state() == S_LEAVING);
  
      // If no messages have been sent, generate one dummy to
      // trigger message acknowledgement mechanism
!     if (last_sent_ == -1 && output_.empty() == true)
      {
          Datagram wb;
          gu_trace(send_user(wb, 0xff, O_DROP, -1, -1));
      }
  
      /* Move all pending messages from output to input map */
!     while (output_.empty() == false)
      {
!         std::pair<Datagram, ProtoDownMeta> wb = output_.front();
          if (send_user(wb.first,
!                       wb.second.user_type(),
!                       wb.second.order(),
                        -1, -1) != 0)
          {
              gu_throw_fatal << "send_user() failed";
          }
!         output_.pop_front();
      }
  
  
!     LeaveMessage lm(version_,
!                     uuid(),
!                     current_view_.id(),
!                     last_sent_,
!                     input_map_->aru_seq(),
!                     ++fifo_seq_);
  
      evs_log_debug(D_LEAVE_MSGS) << "sending leave msg " << lm;
  
!     gu::Buffer buf;
      serialize(lm, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
***************
*** 1546,1569 ****
          log_debug << "send failed " << strerror(err);
      }
  
!     sent_msgs[Message::T_LEAVE]++;
  
      if (handle == true)
      {
!         handle_leave(lm, self_i);
      }
  }
  
  
  struct ViewIdCmp
  {
!     bool operator()(const NodeMap::value_type& a,
!                     const NodeMap::value_type& b) const
      {
!         gcomm_assert(NodeMap::get_value(a).get_join_message() != 0 &&
!                      NodeMap::get_value(b).get_join_message() != 0);
!         return (NodeMap::get_value(a).get_join_message()->get_source_view_id().get_seq() <
!                 NodeMap::get_value(b).get_join_message()->get_source_view_id().get_seq());
  
      }
  };
--- 1569,1593 ----
          log_debug << "send failed " << strerror(err);
      }
  
!     sent_msgs_[Message::T_LEAVE]++;
  
      if (handle == true)
      {
!         handle_leave(lm, self_i_);
      }
  }
  
  
  struct ViewIdCmp
  {
!     bool operator()(const gcomm::evs::NodeMap::value_type& a,
!                     const gcomm::evs::NodeMap::value_type& b) const
      {
!         using gcomm::evs::NodeMap;
!         gcomm_assert(NodeMap::value(a).join_message() != 0 &&
!                      NodeMap::value(b).join_message() != 0);
!         return (NodeMap::value(a).join_message()->source_view_id().seq() <
!                 NodeMap::value(b).join_message()->source_view_id().seq());
  
      }
  };
***************
*** 1571,1603 ****
  
  void gcomm::evs::Proto::send_install()
  {
!     gcomm_assert(consensus.is_consensus() == true &&
!                  is_representative(get_uuid()) == true) << *this;
  
      NodeMap oper_list;
!     for_each(known.begin(), known.end(), OperationalSelect(oper_list));
      NodeMap::const_iterator max_node =
          max_element(oper_list.begin(), oper_list.end(), ViewIdCmp());
  
      const uint32_t max_view_id_seq =
!         NodeMap::get_value(max_node).get_join_message()->get_source_view_id().get_seq();
  
      MessageNodeList node_list;
      populate_node_list(&node_list);
  
!     InstallMessage imsg(version,
!                         get_uuid(),
!                         current_view.get_id(),
!                         ViewId(V_REG, get_uuid(), max_view_id_seq + attempt_seq),
!                         input_map->get_safe_seq(),
!                         input_map->get_aru_seq(),
!                         ++fifo_seq,
                          node_list);
!     ++attempt_seq;
      evs_log_debug(D_INSTALL_MSGS) << "sending install " << imsg;
!     gcomm_assert(consensus.is_consistent(imsg));
  
!     Buffer buf;
      serialize(imsg, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
--- 1595,1627 ----
  
  void gcomm::evs::Proto::send_install()
  {
!     gcomm_assert(consensus_.is_consensus() == true &&
!                  is_representative(uuid()) == true) << *this;
  
      NodeMap oper_list;
!     for_each(known_.begin(), known_.end(), OperationalSelect(oper_list));
      NodeMap::const_iterator max_node =
          max_element(oper_list.begin(), oper_list.end(), ViewIdCmp());
  
      const uint32_t max_view_id_seq =
!         NodeMap::value(max_node).join_message()->source_view_id().seq();
  
      MessageNodeList node_list;
      populate_node_list(&node_list);
  
!     InstallMessage imsg(version_,
!                         uuid(),
!                         current_view_.id(),
!                         ViewId(V_REG, uuid(), max_view_id_seq + attempt_seq_),
!                         input_map_->safe_seq(),
!                         input_map_->aru_seq(),
!                         ++fifo_seq_,
                          node_list);
!     ++attempt_seq_;
      evs_log_debug(D_INSTALL_MSGS) << "sending install " << imsg;
!     gcomm_assert(consensus_.is_consistent(imsg));
  
!     gu::Buffer buf;
      serialize(imsg, buf);
      Datagram dg(buf);
      int err = send_down(dg, ProtoDownMeta());
***************
*** 1606,1626 ****
          log_debug << "send failed: " << strerror(err);
      }
  
!     sent_msgs[Message::T_INSTALL]++;
!     handle_install(imsg, self_i);
  }
  
  
  void gcomm::evs::Proto::resend(const UUID& gap_source, const Range range)
  {
!     gcomm_assert(gap_source != get_uuid());
!     gcomm_assert(range.get_lu() <= range.get_hs()) <<
!         "lu (" << range.get_lu() << ") > hs(" << range.get_hs() << ")";
  
!     if (range.get_lu() <= input_map->get_safe_seq())
      {
!         log_warn << self_string() << "lu (" << range.get_lu() <<
!             ") <= safe_seq(" << input_map->get_safe_seq()
                   << "), can't recover message";
          return;
      }
--- 1630,1650 ----
          log_debug << "send failed: " << strerror(err);
      }
  
!     sent_msgs_[Message::T_INSTALL]++;
!     handle_install(imsg, self_i_);
  }
  
  
  void gcomm::evs::Proto::resend(const UUID& gap_source, const Range range)
  {
!     gcomm_assert(gap_source != uuid());
!     gcomm_assert(range.lu() <= range.hs()) <<
!         "lu (" << range.lu() << ") > hs(" << range.hs() << ")";
  
!     if (range.lu() <= input_map_->safe_seq())
      {
!         log_warn << self_string() << "lu (" << range.lu() <<
!             ") <= safe_seq(" << input_map_->safe_seq()
                   << "), can't recover message";
          return;
      }
***************
*** 1628,1662 ****
      evs_log_debug(D_RETRANS) << " retrans requested by "
                               << gap_source
                               << " "
!                              << range.get_lu() << " -> "
!                              << range.get_hs();
  
!     seqno_t seq(range.get_lu());
!     while (seq <= range.get_hs())
      {
!         InputMap::iterator msg_i = input_map->find(NodeMap::get_value(self_i).get_index(), seq);
!         if (msg_i == input_map->end())
          {
!             gu_trace(msg_i = input_map->recover(NodeMap::get_value(self_i).get_index(), seq));
!         }
! 
!         const UserMessage& msg(InputMapMsgIndex::get_value(msg_i).get_msg());
!         gcomm_assert(msg.get_source() == get_uuid());
!         Datagram rb(InputMapMsgIndex::get_value(msg_i).get_rb());
!         assert(rb.get_offset() == 0);
! 
!         UserMessage um(msg.get_version(),
!                        msg.get_source(),
!                        msg.get_source_view_id(),
!                        msg.get_seq(),
!                        input_map->get_aru_seq(),
!                        msg.get_seq_range(),
!                        msg.get_order(),
!                        msg.get_fifo_seq(),
!                        msg.get_user_type(),
                         static_cast<uint8_t>(
                             Message::F_RETRANS |
!                            (msg.get_flags() & Message::F_AGGREGATE)));
  
          push_header(um, rb);
  
--- 1652,1686 ----
      evs_log_debug(D_RETRANS) << " retrans requested by "
                               << gap_source
                               << " "
!                              << range.lu() << " -> "
!                              << range.hs();
  
!     seqno_t seq(range.lu());
!     while (seq <= range.hs())
      {
!         InputMap::iterator msg_i = input_map_->find(NodeMap::value(self_i_).index(), seq);
!         if (msg_i == input_map_->end())
          {
!             gu_trace(msg_i = input_map_->recover(NodeMap::value(self_i_).index(), seq));
!         }
! 
!         const UserMessage& msg(InputMapMsgIndex::value(msg_i).msg());
!         gcomm_assert(msg.source() == uuid());
!         Datagram rb(InputMapMsgIndex::value(msg_i).rb());
!         assert(rb.offset() == 0);
! 
!         UserMessage um(msg.version(),
!                        msg.source(),
!                        msg.source_view_id(),
!                        msg.seq(),
!                        input_map_->aru_seq(),
!                        msg.seq_range(),
!                        msg.order(),
!                        msg.fifo_seq(),
!                        msg.user_type(),
                         static_cast<uint8_t>(
                             Message::F_RETRANS |
!                            (msg.flags() & Message::F_AGGREGATE)));
  
          push_header(um, rb);
  
***************
*** 1670,1677 ****
          {
              evs_log_debug(D_RETRANS) << "retransmitted " << um;
          }
!         seq = seq + msg.get_seq_range() + 1;
!         retrans_msgs++;
      }
  }
  
--- 1694,1701 ----
          {
              evs_log_debug(D_RETRANS) << "retransmitted " << um;
          }
!         seq = seq + msg.seq_range() + 1;
!         retrans_msgs_++;
      }
  }
  
***************
*** 1680,1701 ****
                                  const UUID& range_uuid,
                                  const Range range)
  {
!     gcomm_assert(gap_source != get_uuid())
!         << "gap_source (" << gap_source << ") == get_uuid() (" << get_uuid()
          << " state " << *this;
!     gcomm_assert(range.get_lu() <= range.get_hs())
!         << "lu (" << range.get_lu() << ") > hs (" << range.get_hs() << ")";
  
!     if (range.get_lu() <= input_map->get_safe_seq())
      {
!         log_warn << self_string() << "lu (" << range.get_lu() <<
!             ") <= safe_seq(" << input_map->get_safe_seq()
                   << "), can't recover message";
          return;
      }
  
!     const Node& range_node(NodeMap::get_value(known.find_checked(range_uuid)));
!     const Range im_range(input_map->get_range(range_node.get_index()));
  
      evs_log_debug(D_RETRANS) << " recovering message from "
                               << range_uuid
--- 1704,1725 ----
                                  const UUID& range_uuid,
                                  const Range range)
  {
!     gcomm_assert(gap_source != uuid())
!         << "gap_source (" << gap_source << ") == uuid() (" << uuid()
          << " state " << *this;
!     gcomm_assert(range.lu() <= range.hs())
!         << "lu (" << range.lu() << ") > hs (" << range.hs() << ")";
  
!     if (range.lu() <= input_map_->safe_seq())
      {
!         log_warn << self_string() << "lu (" << range.lu() <<
!             ") <= safe_seq(" << input_map_->safe_seq()
                   << "), can't recover message";
          return;
      }
  
!     const Node& range_node(NodeMap::value(known_.find_checked(range_uuid)));
!     const Range im_range(input_map_->range(range_node.index()));
  
      evs_log_debug(D_RETRANS) << " recovering message from "
                               << range_uuid
***************
*** 1705,1719 ****
                               << " available " << im_range;
  
  
!     seqno_t seq(range.get_lu());
!     while (seq <= range.get_hs() && seq <= im_range.get_hs())
      {
!         InputMap::iterator msg_i = input_map->find(range_node.get_index(), seq);
!         if (msg_i == input_map->end())
          {
              try
              {
!                 gu_trace(msg_i = input_map->recover(range_node.get_index(), seq));
              }
              catch (...)
              {
--- 1729,1743 ----
                               << " available " << im_range;
  
  
!     seqno_t seq(range.lu());
!     while (seq <= range.hs() && seq <= im_range.hs())
      {
!         InputMap::iterator msg_i = input_map_->find(range_node.index(), seq);
!         if (msg_i == input_map_->end())
          {
              try
              {
!                 gu_trace(msg_i = input_map_->recover(range_node.index(), seq));
              }
              catch (...)
              {
***************
*** 1722,1745 ****
              }
          }
  
!         const UserMessage& msg(InputMapMsgIndex::get_value(msg_i).get_msg());
!         assert(msg.get_source() == range_uuid);
  
!         Datagram rb(InputMapMsgIndex::get_value(msg_i).get_rb());
!         assert(rb.get_offset() == 0);
!         UserMessage um(msg.get_version(),
!                        msg.get_source(),
!                        msg.get_source_view_id(),
!                        msg.get_seq(),
!                        msg.get_aru_seq(),
!                        msg.get_seq_range(),
!                        msg.get_order(),
!                        msg.get_fifo_seq(),
!                        msg.get_user_type(),
                         static_cast<uint8_t>(
                             Message::F_SOURCE |
                             Message::F_RETRANS |
!                            (msg.get_flags() & Message::F_AGGREGATE)));
  
          push_header(um, rb);
  
--- 1746,1769 ----
              }
          }
  
!         const UserMessage& msg(InputMapMsgIndex::value(msg_i).msg());
!         assert(msg.source() == range_uuid);
  
!         Datagram rb(InputMapMsgIndex::value(msg_i).rb());
!         assert(rb.offset() == 0);
!         UserMessage um(msg.version(),
!                        msg.source(),
!                        msg.source_view_id(),
!                        msg.seq(),
!                        msg.aru_seq(),
!                        msg.seq_range(),
!                        msg.order(),
!                        msg.fifo_seq(),
!                        msg.user_type(),
                         static_cast<uint8_t>(
                             Message::F_SOURCE |
                             Message::F_RETRANS |
!                            (msg.flags() & Message::F_AGGREGATE)));
  
          push_header(um, rb);
  
***************
*** 1753,1760 ****
          {
              evs_log_debug(D_RETRANS) << "recover " << um;
          }
!         seq = seq + msg.get_seq_range() + 1;
!         recovered_msgs++;
      }
  }
  
--- 1777,1784 ----
          {
              evs_log_debug(D_RETRANS) << "recover " << um;
          }
!         seq = seq + msg.seq_range() + 1;
!         recovered_msgs_++;
      }
  }
  
***************
*** 1762,1779 ****
  void gcomm::evs::Proto::handle_foreign(const Message& msg)
  {
      // no need to handle foreign LEAVE message
!     if (msg.get_type() == Message::T_LEAVE)
      {
          return;
      }
  
      // don't handle foreing messages in install phase
!     if (get_state()              == S_INSTALL)
      {
          //evs_log_debug(D_FOREIGN_MSGS)
          log_warn << self_string()
                   << " dropping foreign message from "
!                  << msg.get_source() << " in install state";
          return;
      }
  
--- 1786,1803 ----
  void gcomm::evs::Proto::handle_foreign(const Message& msg)
  {
      // no need to handle foreign LEAVE message
!     if (msg.type() == Message::T_LEAVE)
      {
          return;
      }
  
      // don't handle foreing messages in install phase
!     if (state()              == S_INSTALL)
      {
          //evs_log_debug(D_FOREIGN_MSGS)
          log_warn << self_string()
                   << " dropping foreign message from "
!                  << msg.source() << " in install state";
          return;
      }
  
***************
*** 1782,1810 ****
          return;
      }
  
!     const UUID& source = msg.get_source();
  
      evs_log_debug(D_FOREIGN_MSGS) << " detected new message source "
                                    << source;
  
      NodeMap::iterator i;
!     gu_trace(i = known.insert_unique(make_pair(source, Node(inactive_timeout, suspect_timeout))));
!     assert(NodeMap::get_value(i).get_operational() == true);
  
!     if (get_state() == S_JOINING || get_state() == S_GATHER ||
!         get_state() == S_OPERATIONAL)
      {
          evs_log_info(I_STATE)
              << " shift to GATHER due to foreign message from "
!             << msg.get_source();
          gu_trace(shift_to(S_GATHER, false));
      }
  
      // Set join message after shift to recovery, shift may clean up
      // join messages
!     if (msg.get_type() == Message::T_JOIN)
      {
!         set_join(static_cast<const JoinMessage&>(msg), msg.get_source());
      }
      send_join(true);
  }
--- 1806,1836 ----
          return;
      }
  
!     const UUID& source = msg.source();
  
      evs_log_debug(D_FOREIGN_MSGS) << " detected new message source "
                                    << source;
  
      NodeMap::iterator i;
!     gu_trace(i = known_.insert_unique(
!                  std::make_pair(
!                      source, Node(inactive_timeout_, suspect_timeout_))));
!     assert(NodeMap::value(i).operational() == true);
  
!     if (state() == S_JOINING || state() == S_GATHER ||
!         state() == S_OPERATIONAL)
      {
          evs_log_info(I_STATE)
              << " shift to GATHER due to foreign message from "
!             << msg.source();
          gu_trace(shift_to(S_GATHER, false));
      }
  
      // Set join message after shift to recovery, shift may clean up
      // join messages
!     if (msg.type() == Message::T_JOIN)
      {
!         set_join(static_cast<const JoinMessage&>(msg), msg.source());
      }
      send_join(true);
  }
***************
*** 1812,1853 ****
  void gcomm::evs::Proto::handle_msg(const Message& msg,
                                     const Datagram& rb)
  {
!     assert(msg.get_type() <= Message::T_LEAVE);
!     if (get_state() == S_CLOSED)
      {
          return;
      }
  
!     if (msg.get_source() == get_uuid())
      {
          return;
      }
  
!     if (msg.get_version() != version)
      {
!         log_info << "incompatible protocol version " << msg.get_version();
          return;
      }
  
  
  
!     gcomm_assert(msg.get_source() != UUID::nil());
  
  
      // Figure out if the message is from known source
!     NodeMap::iterator ii = known.find(msg.get_source());
  
!     if (ii == known.end())
      {
          gu_trace(handle_foreign(msg));
          return;
      }
  
!     Node& node(NodeMap::get_value(ii));
  
!     if (node.get_operational()                 == false &&
!         node.get_leave_message()               == 0     &&
!         (msg.get_flags() & Message::F_RETRANS) == 0)
      {
          // We have set this node unoperational and there was
          // probably good reason to do so. Don't accept messages
--- 1838,1879 ----
  void gcomm::evs::Proto::handle_msg(const Message& msg,
                                     const Datagram& rb)
  {
!     assert(msg.type() <= Message::T_LEAVE);
!     if (state() == S_CLOSED)
      {
          return;
      }
  
!     if (msg.source() == uuid())
      {
          return;
      }
  
!     if (msg.version() != version_)
      {
!         log_info << "incompatible protocol version " << msg.version();
          return;
      }
  
  
  
!     gcomm_assert(msg.source() != UUID::nil());
  
  
      // Figure out if the message is from known source
!     NodeMap::iterator ii = known_.find(msg.source());
  
!     if (ii == known_.end())
      {
          gu_trace(handle_foreign(msg));
          return;
      }
  
!     Node& node(NodeMap::value(ii));
  
!     if (node.operational()                 == false &&
!         node.leave_message()               == 0     &&
!         (msg.flags() & Message::F_RETRANS) == 0)
      {
          // We have set this node unoperational and there was
          // probably good reason to do so. Don't accept messages
***************
*** 1859,1913 ****
      }
  
      // Filter out non-fifo messages
!     if (msg.get_fifo_seq() != -1 && (msg.get_flags() & Message::F_RETRANS) == 0)
      {
  
!         if (node.get_fifo_seq() >= msg.get_fifo_seq())
          {
              evs_log_debug(D_FOREIGN_MSGS)
                  << "droppoing non-fifo message " << msg
!                 << " fifo seq " << node.get_fifo_seq();
              return;
          }
          else
          {
!             node.set_fifo_seq(msg.get_fifo_seq());
          }
      }
  
      // Accept non-membership messages only from current view
      // or from view to be installed
      if (msg.is_membership()                     == false                    &&
!         msg.get_source_view_id()                != current_view.get_id()    &&
!         (install_message                        == 0                     ||
!          install_message->get_install_view_id() != msg.get_source_view_id()))
      {
          // If source node seems to be operational but it has proceeded
          // into new view, mark it as unoperational in order to create
          // intermediate views before re-merge.
!         if (node.get_installed()           == true      &&
!             node.get_operational()         == true      &&
              is_msg_from_previous_view(msg) == false     &&
!             get_state()                    != S_LEAVING)
          {
              evs_log_info(I_STATE)
                  << " detected new view from operational source "
!                 << msg.get_source() << ": "
!                 << msg.get_source_view_id();
              // Note: Commented out, this causes problems with
              // attempt_seq. Newly (remotely?) generated install message
              // followed by commit gap may cause undesired
              // node inactivation and shift to gather.
              //
!             // set_inactive(msg.get_source());
              // gu_trace(shift_to(S_GATHER, true));
          }
          return;
      }
  
!     recvd_msgs[msg.get_type()]++;
  
!     switch (msg.get_type())
      {
      case Message::T_USER:
          gu_trace(handle_user(static_cast<const UserMessage&>(msg), ii, rb));
--- 1885,1939 ----
      }
  
      // Filter out non-fifo messages
!     if (msg.fifo_seq() != -1 && (msg.flags() & Message::F_RETRANS) == 0)
      {
  
!         if (node.fifo_seq() >= msg.fifo_seq())
          {
              evs_log_debug(D_FOREIGN_MSGS)
                  << "droppoing non-fifo message " << msg
!                 << " fifo seq " << node.fifo_seq();
              return;
          }
          else
          {
!             node.set_fifo_seq(msg.fifo_seq());
          }
      }
  
      // Accept non-membership messages only from current view
      // or from view to be installed
      if (msg.is_membership()                     == false                    &&
!         msg.source_view_id()                != current_view_.id()    &&
!         (install_message_                        == 0                     ||
!          install_message_->install_view_id() != msg.source_view_id()))
      {
          // If source node seems to be operational but it has proceeded
          // into new view, mark it as unoperational in order to create
          // intermediate views before re-merge.
!         if (node.installed()           == true      &&
!             node.operational()         == true      &&
              is_msg_from_previous_view(msg) == false     &&
!             state()                    != S_LEAVING)
          {
              evs_log_info(I_STATE)
                  << " detected new view from operational source "
!                 << msg.source() << ": "
!                 << msg.source_view_id();
              // Note: Commented out, this causes problems with
              // attempt_seq. Newly (remotely?) generated install message
              // followed by commit gap may cause undesired
              // node inactivation and shift to gather.
              //
!             // set_inactive(msg.source());
              // gu_trace(shift_to(S_GATHER, true));
          }
          return;
      }
  
!     recvd_msgs_[msg.type()]++;
  
!     switch (msg.type())
      {
      case Message::T_USER:
          gu_trace(handle_user(static_cast<const UserMessage&>(msg), ii, rb));
***************
*** 1928,1934 ****
          gu_trace(handle_install(static_cast<const InstallMessage&>(msg), ii));
          break;
      default:
!         log_warn << "invalid message type " << msg.get_type();
      }
  }
  
--- 1954,1960 ----
          gu_trace(handle_install(static_cast<const InstallMessage&>(msg), ii));
          break;
      default:
!         log_warn << "invalid message type " << msg.type();
      }
  }
  
***************
*** 1941,1958 ****
                                                Message* msg)
  {
      size_t offset;
!     const byte_t* begin(get_begin(rb));
!     const size_t available(get_available(rb));
      gu_trace(offset = msg->unserialize(begin,
                                         available,
                                         0));
!     if ((msg->get_flags() & Message::F_SOURCE) == 0)
      {
          gcomm_assert(source != UUID::nil());
          msg->set_source(source);
      }
  
!     switch (msg->get_type())
      {
      case Message::T_NONE:
          gu_throw_fatal;
--- 1967,1984 ----
                                                Message* msg)
  {
      size_t offset;
!     const gu::byte_t* begin(gcomm::begin(rb));
!     const size_t available(gcomm::available(rb));
      gu_trace(offset = msg->unserialize(begin,
                                         available,
                                         0));
!     if ((msg->flags() & Message::F_SOURCE) == 0)
      {
          gcomm_assert(source != UUID::nil());
          msg->set_source(source);
      }
  
!     switch (msg->type())
      {
      case Message::T_NONE:
          gu_throw_fatal;
***************
*** 1982,1988 ****
                       begin, available, offset, true));
          break;
      }
!     return (offset + rb.get_offset());
  }
  
  void gcomm::evs::Proto::handle_up(const void* cid,
--- 2008,2014 ----
                       begin, available, offset, true));
          break;
      }
!     return (offset + rb.offset());
  }
  
  void gcomm::evs::Proto::handle_up(const void* cid,
***************
*** 1992,2012 ****
  
      Message msg;
  
!     if (get_state() == S_CLOSED || um.get_source() == get_uuid())
      {
          // Silent drop
          return;
      }
  
!     gcomm_assert(um.get_source() != UUID::nil());
  
      try
      {
          size_t offset;
!         gu_trace(offset = unserialize_message(um.get_source(), rb, &msg));
          handle_msg(msg, Datagram(rb, offset));
      }
!     catch (Exception& e)
      {
          switch (e.get_errno())
          {
--- 2018,2038 ----
  
      Message msg;
  
!     if (state() == S_CLOSED || um.source() == uuid())
      {
          // Silent drop
          return;
      }
  
!     gcomm_assert(um.source() != UUID::nil());
  
      try
      {
          size_t offset;
!         gu_trace(offset = unserialize_message(um.source(), rb, &msg));
          handle_msg(msg, Datagram(rb, offset));
      }
!     catch (gu::Exception& e)
      {
          switch (e.get_errno())
          {
***************
*** 2029,2061 ****
  
  int gcomm::evs::Proto::handle_down(Datagram& wb, const ProtoDownMeta& dm)
  {
!     if (get_state() == S_GATHER || get_state() == S_INSTALL)
      {
          return EAGAIN;
      }
  
!     else if (get_state() != S_OPERATIONAL)
      {
!         log_warn << "user message in state " << to_string(get_state());
          return ENOTCONN;
      }
  
!     if (dm.get_order() == O_LOCAL_CAUSAL)
      {
          gu::datetime::Date now(gu::datetime::Date::now());
          if (causal_queue_.empty() == true &&
!             last_sent == input_map->get_safe_seq() &&
!             causal_keepalive_period > Period(0) &&
!             last_causal_keepalive + causal_keepalive_period > now)
          {
!             hs_local_causal.insert(0.0);
!             deliver_causal(dm.get_user_type(), last_sent, wb);
          }
          else
          {
!             seqno_t causal_seqno(input_map->get_aru_seq());
!             if (causal_keepalive_period == Period(0) ||
!                 last_causal_keepalive + causal_keepalive_period <= now)
              {
                  // generate traffic to make sure that group is live
                  Datagram dg;
--- 2055,2087 ----
  
  int gcomm::evs::Proto::handle_down(Datagram& wb, const ProtoDownMeta& dm)
  {
!     if (state() == S_GATHER || state() == S_INSTALL)
      {
          return EAGAIN;
      }
  
!     else if (state() != S_OPERATIONAL)
      {
!         log_warn << "user message in state " << to_string(state());
          return ENOTCONN;
      }
  
!     if (dm.order() == O_LOCAL_CAUSAL)
      {
          gu::datetime::Date now(gu::datetime::Date::now());
          if (causal_queue_.empty() == true &&
!             last_sent_ == input_map_->safe_seq() &&
!             causal_keepalive_period_ > gu::datetime::Period(0) &&
!             last_causal_keepalive_ + causal_keepalive_period_ > now)
          {
!             hs_local_causal_.insert(0.0);
!             deliver_causal(dm.user_type(), last_sent_, wb);
          }
          else
          {
!             seqno_t causal_seqno(input_map_->aru_seq());
!             if (causal_keepalive_period_ == gu::datetime::Period(0) ||
!                 last_causal_keepalive_ + causal_keepalive_period_ <= now)
              {
                  // generate traffic to make sure that group is live
                  Datagram dg;
***************
*** 2068,2102 ****
                  // in order to make sure that the group is live,
                  // safe seqno must be advanced and in this case
                  // safe seqno equals to aru seqno.
!                 causal_seqno = last_sent;
!                 last_causal_keepalive = now;
              }
!             causal_queue_.push_back(CausalMessage(dm.get_user_type(),
                                                    causal_seqno, wb));
          }
          return 0;
      }
  
  
!     send_queue_s += output.size();
!     ++n_send_queue_s;
  
      int ret = 0;
  
!     if (output.empty() == true)
      {
          int err;
          err = send_user(wb,
!                         dm.get_user_type(),
!                         dm.get_order(),
!                         user_send_window,
                          -1);
  
          switch (err)
          {
          case EAGAIN:
          {
!             output.push_back(make_pair(wb, dm));
              // Fall through
          }
          case 0:
--- 2094,2128 ----
                  // in order to make sure that the group is live,
                  // safe seqno must be advanced and in this case
                  // safe seqno equals to aru seqno.
!                 causal_seqno = last_sent_;
!                 last_causal_keepalive_ = now;
              }
!             causal_queue_.push_back(CausalMessage(dm.user_type(),
                                                    causal_seqno, wb));
          }
          return 0;
      }
  
  
!     send_queue_s_ += output_.size();
!     ++n_send_queue_s_;
  
      int ret = 0;
  
!     if (output_.empty() == true)
      {
          int err;
          err = send_user(wb,
!                         dm.user_type(),
!                         dm.order(),
!                         user_send_window_,
                          -1);
  
          switch (err)
          {
          case EAGAIN:
          {
!             output_.push_back(std::make_pair(wb, dm));
              // Fall through
          }
          case 0:
***************
*** 2107,2115 ****
              ret = err;
          }
      }
!     else if (output.size() < max_output_size)
      {
!         output.push_back(make_pair(wb, dm));
      }
      else
      {
--- 2133,2141 ----
              ret = err;
          }
      }
!     else if (output_.size() < max_output_size_)
      {
!         output_.push_back(std::make_pair(wb, dm));
      }
      else
      {
***************
*** 2124,2132 ****
  
  void gcomm::evs::Proto::shift_to(const State s, const bool send_j)
  {
!     if (shift_to_rfcnt > 0) gu_throw_fatal << *this;
  
!     shift_to_rfcnt++;
  
      static const bool allowed[S_MAX][S_MAX] = {
          // CLOSED JOINING LEAVING GATHER INSTALL OPERAT
--- 2150,2158 ----
  
  void gcomm::evs::Proto::shift_to(const State s, const bool send_j)
  {
!     if (shift_to_rfcnt_ > 0) gu_throw_fatal << *this;
  
!     shift_to_rfcnt_++;
  
      static const bool allowed[S_MAX][S_MAX] = {
          // CLOSED JOINING LEAVING GATHER INSTALL OPERAT
***************
*** 2145,2199 ****
  
      assert(s < S_MAX);
  
!     if (allowed[state][s] == false) {
          gu_throw_fatal << "Forbidden state transition: "
!                           << to_string(state) << " -> " << to_string(s);
      }
  
!     if (get_state() != s)
      {
          evs_log_info(I_STATE) << " state change: "
!                               << to_string(state) << " -> " << to_string(s);
      }
      switch (s) {
      case S_CLOSED:
!         gcomm_assert(get_state() == S_LEAVING);
          gu_trace(deliver());
          gu_trace(deliver_local());
          setall_installed(false);
!         NodeMap::get_value(self_i).set_installed(true);
          gu_trace(deliver_trans_view(true));
          gu_trace(deliver_trans());
          gu_trace(deliver_local(true));
          gcomm_assert(causal_queue_.empty() == true);
!         if (collect_stats == true)
          {
              handle_stats_timer();
          }
          gu_trace(deliver_empty_view());
          cleanup_unoperational();
          cleanup_views();
!         timers.clear();
!         state = S_CLOSED;
          break;
      case S_JOINING:
!         state = S_JOINING;
          break;
      case S_LEAVING:
!         state = S_LEAVING;
          reset_timers();
          break;
      case S_GATHER:
      {
          setall_committed(false);
          setall_installed(false);
!         delete install_message;
!         install_message = 0;
  
!         if (get_state() == S_OPERATIONAL)
          {
!             profile_enter(send_user_prof);
!             while (output.empty() == false)
              {
                  int err;
                  gu_trace(err = send_user(-1));
--- 2171,2225 ----
  
      assert(s < S_MAX);
  
!     if (allowed[state_][s] == false) {
          gu_throw_fatal << "Forbidden state transition: "
!                        << to_string(state_) << " -> " << to_string(s);
      }
  
!     if (state() != s)
      {
          evs_log_info(I_STATE) << " state change: "
!                               << to_string(state_) << " -> " << to_string(s);
      }
      switch (s) {
      case S_CLOSED:
!         gcomm_assert(state() == S_LEAVING);
          gu_trace(deliver());
          gu_trace(deliver_local());
          setall_installed(false);
!         NodeMap::value(self_i_).set_installed(true);
          gu_trace(deliver_trans_view(true));
          gu_trace(deliver_trans());
          gu_trace(deliver_local(true));
          gcomm_assert(causal_queue_.empty() == true);
!         if (collect_stats_ == true)
          {
              handle_stats_timer();
          }
          gu_trace(deliver_empty_view());
          cleanup_unoperational();
          cleanup_views();
!         timers_.clear();
!         state_ = S_CLOSED;
          break;
      case S_JOINING:
!         state_ = S_JOINING;
          break;
      case S_LEAVING:
!         state_ = S_LEAVING;
          reset_timers();
          break;
      case S_GATHER:
      {
          setall_committed(false);
          setall_installed(false);
!         delete install_message_;
!         install_message_ = 0;
  
!         if (state() == S_OPERATIONAL)
          {
!             profile_enter(send_user_prof_);
!             while (output_.empty() == false)
              {
                  int err;
                  gu_trace(err = send_user(-1));
***************
*** 2205,2244 ****
                                     << strerror(err);
                  }
              }
!             profile_leave(send_user_prof);
          }
          else
          {
!             gcomm_assert(output.empty() == true);
          }
  
!         state = S_GATHER;
          if (send_j == true)
          {
!             profile_enter(send_join_prof);
              gu_trace(send_join(false));
!             profile_leave(send_join_prof);
          }
!         gcomm_assert(get_state() == S_GATHER);
          reset_timers();
          break;
      }
      case S_INSTALL:
      {
!         gcomm_assert(install_message != 0);
          gcomm_assert(is_all_committed() == true);
!         state = S_INSTALL;
          reset_timers();
          break;
      }
      case S_OPERATIONAL:
      {
!         gcomm_assert(output.empty() == true);
!         gcomm_assert(install_message != 0);
!         gcomm_assert(NodeMap::get_value(self_i).get_join_message() != 0 &&
!                      consensus.equal(
!                          *NodeMap::get_value(self_i).get_join_message(),
!                          *install_message))
              << "install message not consistent with own join, state: " << *this;
          gcomm_assert(is_all_installed() == true);
          gu_trace(deliver());
--- 2231,2270 ----
                                     << strerror(err);
                  }
              }
!             profile_leave(send_user_prof_);
          }
          else
          {
!             gcomm_assert(output_.empty() == true);
          }
  
!         state_ = S_GATHER;
          if (send_j == true)
          {
!             profile_enter(send_join_prof_);
              gu_trace(send_join(false));
!             profile_leave(send_join_prof_);
          }
!         gcomm_assert(state() == S_GATHER);
          reset_timers();
          break;
      }
      case S_INSTALL:
      {
!         gcomm_assert(install_message_ != 0);
          gcomm_assert(is_all_committed() == true);
!         state_ = S_INSTALL;
          reset_timers();
          break;
      }
      case S_OPERATIONAL:
      {
!         gcomm_assert(output_.empty() == true);
!         gcomm_assert(install_message_ != 0);
!         gcomm_assert(NodeMap::value(self_i_).join_message() != 0 &&
!                      consensus_.equal(
!                          *NodeMap::value(self_i_).join_message(),
!                          *install_message_))
              << "install message not consistent with own join, state: " << *this;
          gcomm_assert(is_all_installed() == true);
          gu_trace(deliver());
***************
*** 2247,2315 ****
          gu_trace(deliver_trans());
          gu_trace(deliver_local(true));
          gcomm_assert(causal_queue_.empty() == true);
!         input_map->clear();
!         if (collect_stats == true)
          {
              handle_stats_timer();
          }
  
!         previous_view = current_view;
!         previous_views.push_back(make_pair(current_view.get_id(), Date::now()));
  
!         const MessageNodeList& imap(install_message->get_node_list());
  
          for (MessageNodeList::const_iterator i = imap.begin();
               i != imap.end(); ++i)
          {
!             previous_views.push_back(make_pair(MessageNodeList::get_value(i).get_view_id(),
!                                                Date::now()));
          }
!         current_view = View(install_message->get_install_view_id());
          size_t idx = 0;
!         for (NodeMap::iterator i = known.begin(); i != known.end(); ++i)
          {
!             if (NodeMap::get_value(i).get_installed() == true)
              {
!                 gu_trace(current_view.add_member(NodeMap::get_key(i), ""));
!                 NodeMap::get_value(i).set_index(idx++);
              }
              else
              {
!                 NodeMap::get_value(i).set_index(numeric_limits<size_t>::max());
              }
          }
  
!         if (previous_view.get_id().get_type() == V_REG &&
!             previous_view.get_members() == current_view.get_members())
          {
              log_warn << "subsequent views have same members, prev view "
!                      << previous_view << " current view " << current_view;
          }
  
!         input_map->reset(current_view.get_members().size());
!         last_sent = -1;
!         state = S_OPERATIONAL;
          deliver_reg_view();
  
          cleanup_unoperational();
          cleanup_views();
          cleanup_joins();
  
!         delete install_message;
!         install_message = 0;
!         attempt_seq = 1;
!         install_timeout_count = 0;
!         profile_enter(send_gap_prof);
!         gu_trace(send_gap(UUID::nil(), current_view.get_id(), Range()));;
!         profile_leave(send_gap_prof);
!         gcomm_assert(get_state() == S_OPERATIONAL);
          reset_timers();
          break;
      }
      default:
          gu_throw_fatal << "invalid state";
      }
!     shift_to_rfcnt--;
  }
  
  ////////////////////////////////////////////////////////////////////////////
--- 2273,2344 ----
          gu_trace(deliver_trans());
          gu_trace(deliver_local(true));
          gcomm_assert(causal_queue_.empty() == true);
!         input_map_->clear();
!         if (collect_stats_ == true)
          {
              handle_stats_timer();
          }
  
!         previous_view_ = current_view_;
!         previous_views_.push_back(
!             std::make_pair(current_view_.id(), gu::datetime::Date::now()));
  
!         const MessageNodeList& imap(install_message_->node_list());
  
          for (MessageNodeList::const_iterator i = imap.begin();
               i != imap.end(); ++i)
          {
!             previous_views_.push_back(
!                 std::make_pair(MessageNodeList::value(i).view_id(),
!                                gu::datetime::Date::now()));
          }
!         current_view_ = View(install_message_->install_view_id());
          size_t idx = 0;
!         for (NodeMap::iterator i = known_.begin(); i != known_.end(); ++i)
          {
!             if (NodeMap::value(i).installed() == true)
              {
!                 gu_trace(current_view_.add_member(NodeMap::key(i), ""));
!                 NodeMap::value(i).set_index(idx++);
              }
              else
              {
!                 NodeMap::value(i).set_index(
!                     std::numeric_limits<size_t>::max());
              }
          }
  
!         if (previous_view_.id().type() == V_REG &&
!             previous_view_.members() == current_view_.members())
          {
              log_warn << "subsequent views have same members, prev view "
!                      << previous_view_ << " current view " << current_view_;
          }
  
!         input_map_->reset(current_view_.members().size());
!         last_sent_ = -1;
!         state_ = S_OPERATIONAL;
          deliver_reg_view();
  
          cleanup_unoperational();
          cleanup_views();
          cleanup_joins();
  
!         delete install_message_;
!         install_message_ = 0;
!         attempt_seq_ = 1;
!         install_timeout_count_ = 0;
!         profile_enter(send_gap_prof_);
!         gu_trace(send_gap(UUID::nil(), current_view_.id(), Range()));;
!         profile_leave(send_gap_prof_);
!         gcomm_assert(state() == S_OPERATIONAL);
          reset_timers();
          break;
      }
      default:
          gu_throw_fatal << "invalid state";
      }
!     shift_to_rfcnt_--;
  }
  
  ////////////////////////////////////////////////////////////////////////////
***************
*** 2318,2345 ****
  
  void gcomm::evs::Proto::deliver_causal(uint8_t user_type,
                                         seqno_t seqno,
!                                        const gu::Datagram& datagram)
  {
!     send_up(datagram, ProtoUpMeta(get_uuid(),
!                                   current_view.get_id(),
                                    0,
                                    user_type,
                                    O_LOCAL_CAUSAL,
                                    seqno));
!     ++delivered_msgs[O_LOCAL_CAUSAL];
  }
  
  
  void gcomm::evs::Proto::deliver_local(bool trans)
  {
      // local causal
!     const seqno_t causal_seq(trans == false ? input_map->get_safe_seq() : last_sent);
      gu::datetime::Date now(gu::datetime::Date::now());
      while (causal_queue_.empty() == false &&
             causal_queue_.front().seqno() <= causal_seq)
      {
          const CausalMessage& cm(causal_queue_.front());
!         hs_local_causal.insert(double(now.get_utc() - cm.tstamp().get_utc())/gu::datetime::Sec);
          deliver_causal(cm.user_type(), cm.seqno(), cm.datagram());
          causal_queue_.pop_front();
      }
--- 2347,2374 ----
  
  void gcomm::evs::Proto::deliver_causal(uint8_t user_type,
                                         seqno_t seqno,
!                                        const Datagram& datagram)
  {
!     send_up(datagram, ProtoUpMeta(uuid(),
!                                   current_view_.id(),
                                    0,
                                    user_type,
                                    O_LOCAL_CAUSAL,
                                    seqno));
!     ++delivered_msgs_[O_LOCAL_CAUSAL];
  }
  
  
  void gcomm::evs::Proto::deliver_local(bool trans)
  {
      // local causal
!     const seqno_t causal_seq(trans == false ? input_map_->safe_seq() : last_sent_);
      gu::datetime::Date now(gu::datetime::Date::now());
      while (causal_queue_.empty() == false &&
             causal_queue_.front().seqno() <= causal_seq)
      {
          const CausalMessage& cm(causal_queue_.front());
!         hs_local_causal_.insert(double(now.get_utc() - cm.tstamp().get_utc())/gu::datetime::Sec);
          deliver_causal(cm.user_type(), cm.seqno(), cm.datagram());
          causal_queue_.pop_front();
      }
***************
*** 2347,2370 ****
  
  void gcomm::evs::Proto::validate_reg_msg(const UserMessage& msg)
  {
!     if (msg.get_source_view_id() != current_view.get_id())
      {
          // Note: This implementation should guarantee same view delivery,
          // this is sanity check for that.
          gu_throw_fatal << "reg validate: not current view";
      }
  
!     if (collect_stats == true)
      {
!         if (msg.get_order() == O_SAFE)
          {
!             Date now(Date::now());
!             hs_safe.insert(double(now.get_utc() - msg.get_tstamp().get_utc())/gu::datetime::Sec);
          }
!         else if (msg.get_order() == O_AGREED)
          {
!             Date now(Date::now());
!             hs_agreed.insert(double(now.get_utc() - msg.get_tstamp().get_utc())/gu::datetime::Sec);
          }
      }
  }
--- 2376,2399 ----
  
  void gcomm::evs::Proto::validate_reg_msg(const UserMessage& msg)
  {
!     if (msg.source_view_id() != current_view_.id())
      {
          // Note: This implementation should guarantee same view delivery,
          // this is sanity check for that.
          gu_throw_fatal << "reg validate: not current view";
      }
  
!     if (collect_stats_ == true)
      {
!         if (msg.order() == O_SAFE)
          {
!             gu::datetime::Date now(gu::datetime::Date::now());
!             hs_safe_.insert(double(now.get_utc() - msg.tstamp().get_utc())/gu::datetime::Sec);
          }
!         else if (msg.order() == O_AGREED)
          {
!             gu::datetime::Date now(gu::datetime::Date::now());
!             hs_agreed_.insert(double(now.get_utc() - msg.tstamp().get_utc())/gu::datetime::Sec);
          }
      }
  }
***************
*** 2372,2520 ****
  
  void gcomm::evs::Proto::deliver_finish(const InputMapMsg& msg)
  {
!     if ((msg.get_msg().get_flags() & Message::F_AGGREGATE) == 0)
      {
!         ++delivered_msgs[msg.get_msg().get_order()];
!         if (msg.get_msg().get_order() != O_DROP)
          {
!             gu_trace(validate_reg_msg(msg.get_msg()));
!             profile_enter(delivery_prof);
!             ProtoUpMeta um(msg.get_msg().get_source(),
!                            msg.get_msg().get_source_view_id(),
                             0,
!                            msg.get_msg().get_user_type(),
!                            msg.get_msg().get_order(),
!                            msg.get_msg().get_seq());
              try
              {
!                 send_up(msg.get_rb(), um);
              }
              catch (...)
              {
!                 log_info << msg.get_msg() << " " << msg.get_rb().get_len();
                  throw;
              }
!             profile_leave(delivery_prof);
          }
      }
      else
      {
          size_t offset(0);
!         while (offset < msg.get_rb().get_len())
          {
!             ++delivered_msgs[msg.get_msg().get_order()];
              AggregateMessage am;
!             gu_trace(am.unserialize(&msg.get_rb().get_payload()[0],
!                                     msg.get_rb().get_payload().size(),
                                      offset));
              Datagram dg(
!                 SharedBuffer(
!                     new Buffer(
!                         &msg.get_rb().get_payload()[0]
                          + offset
                          + am.serial_size(),
!                         &msg.get_rb().get_payload()[0]
                          + offset
                          + am.serial_size()
!                         + am.get_len())));
!             ProtoUpMeta um(msg.get_msg().get_source(),
!                            msg.get_msg().get_source_view_id(),
                             0,
!                            am.get_user_type(),
!                            msg.get_msg().get_order(),
!                            msg.get_msg().get_seq());
              gu_trace(send_up(dg, um));
!             offset += am.serial_size() + am.get_len();
          }
!         gcomm_assert(offset == msg.get_rb().get_len());
      }
  }
  
  void gcomm::evs::Proto::deliver()
  {
!     if (delivering == true)
      {
          gu_throw_fatal << "Recursive enter to delivery";
      }
  
!     delivering = true;
  
!     if (get_state() != S_OPERATIONAL &&
!         get_state() != S_GATHER      &&
!         get_state() != S_INSTALL     &&
!         get_state() != S_LEAVING)
      {
!         gu_throw_fatal << "invalid state: " << to_string(get_state());
      }
  
      evs_log_debug(D_DELIVERY)
!         << " aru_seq="   << input_map->get_aru_seq()
!         << " safe_seq=" << input_map->get_safe_seq();
  
      InputMapMsgIndex::iterator i, i_next;
!     for (i = input_map->begin(); i != input_map->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::get_value(i));
          bool deliver = false;
!         switch (msg.get_msg().get_order())
          {
          case O_SAFE:
!             if (input_map->is_safe(i) == true)
              {
                  deliver = true;
              }
              break;
          case O_AGREED:
!             if (input_map->is_agreed(i) == true)
              {
                  deliver = true;
              }
              break;
          case O_FIFO:
          case O_DROP:
!             if (input_map->is_fifo(i) == true)
              {
                  deliver = true;
              }
              break;
          default:
              gu_throw_fatal << "invalid safety prefix "
!                               << msg.get_msg().get_order();
          }
  
          if (deliver == true)
          {
              deliver_finish(msg);
!             gu_trace(input_map->erase(i));
          }
!         else if (input_map->has_deliverables() == false)
          {
              break;
          }
      }
!     delivering = false;
  
  }
  
  
  void gcomm::evs::Proto::deliver_trans()
  {
!     if (delivering == true)
      {
          gu_throw_fatal << "Recursive enter to delivery";
      }
  
!     delivering = true;
  
!     if (get_state() != S_INSTALL &&
!         get_state() != S_LEAVING)
          gu_throw_fatal << "invalid state";
  
      evs_log_debug(D_DELIVERY)
!         << " aru_seq="  << input_map->get_aru_seq()
!         << " safe_seq=" << input_map->get_safe_seq();
  
      // In transitional configuration we must deliver all messages that
      // are fifo. This is because:
--- 2401,2549 ----
  
  void gcomm::evs::Proto::deliver_finish(const InputMapMsg& msg)
  {
!     if ((msg.msg().flags() & Message::F_AGGREGATE) == 0)
      {
!         ++delivered_msgs_[msg.msg().order()];
!         if (msg.msg().order() != O_DROP)
          {
!             gu_trace(validate_reg_msg(msg.msg()));
!             profile_enter(delivery_prof_);
!             ProtoUpMeta um(msg.msg().source(),
!                            msg.msg().source_view_id(),
                             0,
!                            msg.msg().user_type(),
!                            msg.msg().order(),
!                            msg.msg().seq());
              try
              {
!                 send_up(msg.rb(), um);
              }
              catch (...)
              {
!                 log_info << msg.msg() << " " << msg.rb().len();
                  throw;
              }
!             profile_leave(delivery_prof_);
          }
      }
      else
      {
          size_t offset(0);
!         while (offset < msg.rb().len())
          {
!             ++delivered_msgs_[msg.msg().order()];
              AggregateMessage am;
!             gu_trace(am.unserialize(&msg.rb().payload()[0],
!                                     msg.rb().payload().size(),
                                      offset));
              Datagram dg(
!                 gu::SharedBuffer(
!                     new gu::Buffer(
!                         &msg.rb().payload()[0]
                          + offset
                          + am.serial_size(),
!                         &msg.rb().payload()[0]
                          + offset
                          + am.serial_size()
!                         + am.len())));
!             ProtoUpMeta um(msg.msg().source(),
!                            msg.msg().source_view_id(),
                             0,
!                            am.user_type(),
!                            msg.msg().order(),
!                            msg.msg().seq());
              gu_trace(send_up(dg, um));
!             offset += am.serial_size() + am.len();
          }
!         gcomm_assert(offset == msg.rb().len());
      }
  }
  
  void gcomm::evs::Proto::deliver()
  {
!     if (delivering_ == true)
      {
          gu_throw_fatal << "Recursive enter to delivery";
      }
  
!     delivering_ = true;
  
!     if (state() != S_OPERATIONAL &&
!         state() != S_GATHER      &&
!         state() != S_INSTALL     &&
!         state() != S_LEAVING)
      {
!         gu_throw_fatal << "invalid state: " << to_string(state());
      }
  
      evs_log_debug(D_DELIVERY)
!         << " aru_seq="   << input_map_->aru_seq()
!         << " safe_seq=" << input_map_->safe_seq();
  
      InputMapMsgIndex::iterator i, i_next;
!     for (i = input_map_->begin(); i != input_map_->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::value(i));
          bool deliver = false;
!         switch (msg.msg().order())
          {
          case O_SAFE:
!             if (input_map_->is_safe(i) == true)
              {
                  deliver = true;
              }
              break;
          case O_AGREED:
!             if (input_map_->is_agreed(i) == true)
              {
                  deliver = true;
              }
              break;
          case O_FIFO:
          case O_DROP:
!             if (input_map_->is_fifo(i) == true)
              {
                  deliver = true;
              }
              break;
          default:
              gu_throw_fatal << "invalid safety prefix "
!                               << msg.msg().order();
          }
  
          if (deliver == true)
          {
              deliver_finish(msg);
!             gu_trace(input_map_->erase(i));
          }
!         else if (input_map_->has_deliverables() == false)
          {
              break;
          }
      }
!     delivering_ = false;
  
  }
  
  
  void gcomm::evs::Proto::deliver_trans()
  {
!     if (delivering_ == true)
      {
          gu_throw_fatal << "Recursive enter to delivery";
      }
  
!     delivering_ = true;
  
!     if (state() != S_INSTALL &&
!         state() != S_LEAVING)
          gu_throw_fatal << "invalid state";
  
      evs_log_debug(D_DELIVERY)
!         << " aru_seq="  << input_map_->aru_seq()
!         << " safe_seq=" << input_map_->safe_seq();
  
      // In transitional configuration we must deliver all messages that
      // are fifo. This is because:
***************
*** 2528,2546 ****
      //   in transitional configuration
  
      InputMap::iterator i, i_next;
!     for (i = input_map->begin(); i != input_map->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::get_value(i));
          bool deliver = false;
!         switch (msg.get_msg().get_order())
          {
          case O_SAFE:
          case O_AGREED:
          case O_FIFO:
          case O_DROP:
!             if (input_map->is_fifo(i) == true)
              {
                  deliver = true;
              }
--- 2557,2575 ----
      //   in transitional configuration
  
      InputMap::iterator i, i_next;
!     for (i = input_map_->begin(); i != input_map_->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::value(i));
          bool deliver = false;
!         switch (msg.msg().order())
          {
          case O_SAFE:
          case O_AGREED:
          case O_FIFO:
          case O_DROP:
!             if (input_map_->is_fifo(i) == true)
              {
                  deliver = true;
              }
***************
*** 2551,2580 ****
  
          if (deliver == true)
          {
!             if (install_message != 0)
              {
                  const MessageNode& mn(
!                     MessageNodeList::get_value(
!                         install_message->get_node_list().find_checked(
!                             msg.get_msg().get_source())));
!                 if (msg.get_msg().get_seq() <= mn.get_im_range().get_hs())
                  {
                      deliver_finish(msg);
                  }
                  else
                  {
!                     gcomm_assert(mn.get_operational() == false);
                      log_info << "filtering out trans message higher than "
                               << "install message hs "
!                              << mn.get_im_range().get_hs()
!                              << ": " << msg.get_msg();
                  }
              }
              else
              {
                  deliver_finish(msg);
              }
!             gu_trace(input_map->erase(i));
          }
      }
  
--- 2580,2609 ----
  
          if (deliver == true)
          {
!             if (install_message_ != 0)
              {
                  const MessageNode& mn(
!                     MessageNodeList::value(
!                         install_message_->node_list().find_checked(
!                             msg.msg().source())));
!                 if (msg.msg().seq() <= mn.im_range().hs())
                  {
                      deliver_finish(msg);
                  }
                  else
                  {
!                     gcomm_assert(mn.operational() == false);
                      log_info << "filtering out trans message higher than "
                               << "install message hs "
!                              << mn.im_range().hs()
!                              << ": " << msg.msg();
                  }
              }
              else
              {
                  deliver_finish(msg);
              }
!             gu_trace(input_map_->erase(i));
          }
      }
  
***************
*** 2582,2608 ****
      // There must not be any messages left that
      // - Are originated from outside of trans conf and are FIFO
      // - Are originated from trans conf
!     for (i = input_map->begin(); i != input_map->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::get_value(i));
          NodeMap::iterator ii;
!         gu_trace(ii = known.find_checked(msg.get_msg().get_source()));
  
!         if (NodeMap::get_value(ii).get_installed() == true)
          {
              gu_throw_fatal << "Protocol error in transitional delivery "
                             << "(self delivery constraint)";
          }
!         else if (input_map->is_fifo(i) == true)
          {
              gu_throw_fatal << "Protocol error in transitional delivery "
                             << "(fifo from partitioned component)";
          }
!         gu_trace(input_map->erase(i));
      }
!     delivering = false;
  }
  
  
--- 2611,2637 ----
      // There must not be any messages left that
      // - Are originated from outside of trans conf and are FIFO
      // - Are originated from trans conf
!     for (i = input_map_->begin(); i != input_map_->end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         const InputMapMsg& msg(InputMapMsgIndex::value(i));
          NodeMap::iterator ii;
!         gu_trace(ii = known_.find_checked(msg.msg().source()));
  
!         if (NodeMap::value(ii).installed() == true)
          {
              gu_throw_fatal << "Protocol error in transitional delivery "
                             << "(self delivery constraint)";
          }
!         else if (input_map_->is_fifo(i) == true)
          {
              gu_throw_fatal << "Protocol error in transitional delivery "
                             << "(fifo from partitioned component)";
          }
!         gu_trace(input_map_->erase(i));
      }
!     delivering_ = false;
  }
  
  
***************
*** 2615,2624 ****
  gcomm::evs::seqno_t gcomm::evs::Proto::update_im_safe_seq(const size_t uuid,
                                                            const seqno_t seq)
  {
!     const seqno_t im_safe_seq(input_map->get_safe_seq(uuid));
      if (im_safe_seq  < seq)
      {
!         input_map->set_safe_seq(uuid, seq);
      }
      return im_safe_seq;
  }
--- 2644,2653 ----
  gcomm::evs::seqno_t gcomm::evs::Proto::update_im_safe_seq(const size_t uuid,
                                                            const seqno_t seq)
  {
!     const seqno_t im_safe_seq(input_map_->safe_seq(uuid));
      if (im_safe_seq  < seq)
      {
!         input_map_->set_safe_seq(uuid, seq);
      }
      return im_safe_seq;
  }
***************
*** 2629,2643 ****
                                      const Datagram& rb)
  
  {
!     assert(ii != known.end());
!     assert(get_state() != S_CLOSED && get_state() != S_JOINING);
!     Node& inst(NodeMap::get_value(ii));
  
      evs_log_debug(D_USER_MSGS) << "received " << msg;
  
!     if (msg.get_source_view_id() != current_view.get_id())
      {
!         if (get_state() == S_LEAVING)
          {
              // Silent drop
              return;
--- 2658,2672 ----
                                      const Datagram& rb)
  
  {
!     assert(ii != known_.end());
!     assert(state() != S_CLOSED && state() != S_JOINING);
!     Node& inst(NodeMap::value(ii));
  
      evs_log_debug(D_USER_MSGS) << "received " << msg;
  
!     if (msg.source_view_id() != current_view_.id())
      {
!         if (state() == S_LEAVING)
          {
              // Silent drop
              return;
***************
*** 2651,2694 ****
              return;
          }
  
!         if (inst.get_operational() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from unoperational source "
!                 << msg.get_source();
              return;
          }
!         else if (inst.get_installed() == false)
          {
!             if (install_message != 0 &&
!                 msg.get_source_view_id() == install_message->get_install_view_id())
              {
!                 assert(state == S_INSTALL);
                  evs_log_debug(D_STATE) << " recovery user message "
                                         << msg;
  
                  // Other instances installed view before this one, so it is
                  // safe to shift to S_OPERATIONAL if consensus has been reached
                  for (MessageNodeList::const_iterator
!                          mi = install_message->get_node_list().begin();
!                      mi != install_message->get_node_list().end(); ++mi)
                  {
!                     if (MessageNodeList::get_value(mi).get_operational() == true)
                      {
                          NodeMap::iterator jj;
!                         gu_trace(jj = known.find_checked(
!                                      MessageNodeList::get_key(mi)));
!                         NodeMap::get_value(jj).set_installed(true);
                      }
                  }
!                 inst.set_tstamp(Date::now());
!                 if (consensus.is_consensus() == true)
                  {
!                     if (get_state() == S_INSTALL)
                      {
!                         profile_enter(shift_to_prof);
                          gu_trace(shift_to(S_OPERATIONAL));
!                         profile_leave(shift_to_prof);
                      }
                      else
                      {
--- 2680,2723 ----
              return;
          }
  
!         if (inst.operational() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from unoperational source "
!                 << msg.source();
              return;
          }
!         else if (inst.installed() == false)
          {
!             if (install_message_ != 0 &&
!                 msg.source_view_id() == install_message_->install_view_id())
              {
!                 assert(state() == S_INSTALL);
                  evs_log_debug(D_STATE) << " recovery user message "
                                         << msg;
  
                  // Other instances installed view before this one, so it is
                  // safe to shift to S_OPERATIONAL if consensus has been reached
                  for (MessageNodeList::const_iterator
!                          mi = install_message_->node_list().begin();
!                      mi != install_message_->node_list().end(); ++mi)
                  {
!                     if (MessageNodeList::value(mi).operational() == true)
                      {
                          NodeMap::iterator jj;
!                         gu_trace(jj = known_.find_checked(
!                                      MessageNodeList::key(mi)));
!                         NodeMap::value(jj).set_installed(true);
                      }
                  }
!                 inst.set_tstamp(gu::datetime::Date::now());
!                 if (consensus_.is_consensus() == true)
                  {
!                     if (state() == S_INSTALL)
                      {
!                         profile_enter(shift_to_prof_);
                          gu_trace(shift_to(S_OPERATIONAL));
!                         profile_leave(shift_to_prof_);
                      }
                      else
                      {
***************
*** 2700,2706 ****
                  }
                  else
                  {
!                     profile_enter(shift_to_prof);
                      evs_log_info(I_STATE)
                          << " no consensus after "
                          << "handling user message from new view";
--- 2729,2735 ----
                  }
                  else
                  {
!                     profile_enter(shift_to_prof_);
                      evs_log_info(I_STATE)
                          << " no consensus after "
                          << "handling user message from new view";
***************
*** 2708,2714 ****
                      // install gaps. Other nodes should time out eventually
                      // if consensus can't be reached.
                      // gu_trace(shift_to(S_GATHER));
!                     profile_leave(shift_to_prof);
                      return;
                  }
              }
--- 2737,2743 ----
                      // install gaps. Other nodes should time out eventually
                      // if consensus can't be reached.
                      // gu_trace(shift_to(S_GATHER));
!                     profile_leave(shift_to_prof_);
                      return;
                  }
              }
***************
*** 2724,2750 ****
          }
      }
  
!     gcomm_assert(msg.get_source_view_id() == current_view.get_id());
  
      Range range;
      Range prev_range;
      seqno_t prev_aru;
      seqno_t prev_safe;
  
!     profile_enter(input_map_prof);
  
!     prev_aru = input_map->get_aru_seq();
!     prev_range = input_map->get_range(inst.get_index());
  
      // Insert only if msg seq is greater or equal than current lowest unseen
!     if (msg.get_seq() >= prev_range.get_lu())
      {
!         Datagram im_dgram(rb, rb.get_offset());
          im_dgram.normalize();
!         gu_trace(range = input_map->insert(inst.get_index(), msg, im_dgram));
!         if (range.get_lu() > prev_range.get_lu())
          {
!             inst.set_tstamp(Date::now());
          }
      }
      else
--- 2753,2779 ----
          }
      }
  
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
      Range range;
      Range prev_range;
      seqno_t prev_aru;
      seqno_t prev_safe;
  
!     profile_enter(input_map_prof_);
  
!     prev_aru = input_map_->aru_seq();
!     prev_range = input_map_->range(inst.index());
  
      // Insert only if msg seq is greater or equal than current lowest unseen
!     if (msg.seq() >= prev_range.lu())
      {
!         Datagram im_dgram(rb, rb.offset());
          im_dgram.normalize();
!         gu_trace(range = input_map_->insert(inst.index(), msg, im_dgram));
!         if (range.lu() > prev_range.lu())
          {
!             inst.set_tstamp(gu::datetime::Date::now());
          }
      }
      else
***************
*** 2753,2840 ****
      }
  
      // Update im safe seq for self
!     update_im_safe_seq(NodeMap::get_value(self_i).get_index(),
!                        input_map->get_aru_seq());
  
      // Update safe seq for message source
!     prev_safe = update_im_safe_seq(inst.get_index(), msg.get_aru_seq());
  
!     profile_leave(input_map_prof);
  
      // Check for missing messages
!     if (range.get_hs()                         >  range.get_lu() &&
!         (msg.get_flags() & Message::F_RETRANS) == 0                 )
      {
          evs_log_debug(D_RETRANS) << " requesting retrans from "
!                                  << msg.get_source() << " "
                                   << range
                                   << " due to input map gap, aru "
!                                  << input_map->get_aru_seq();
!         profile_enter(send_gap_prof);
!         gu_trace(send_gap(msg.get_source(), current_view.get_id(), range));
!         profile_leave(send_gap_prof);
      }
  
      // Seqno range completion and acknowledgement
!     const seqno_t max_hs(input_map->get_max_hs());
!     if (output.empty()                          == true            &&
!         (get_state() == S_OPERATIONAL || get_state() == S_GATHER)  &&
!         (msg.get_flags() & Message::F_MSG_MORE) == 0               &&
!         (last_sent                              <  max_hs))
      {
          // Message not originated from this instance, output queue is empty
          // and last_sent seqno should be advanced
          gu_trace(complete_user(max_hs));
      }
!     else if (output.empty()           == true  &&
!              input_map->get_aru_seq() != prev_aru)
      {
          // Output queue empty and aru changed, send gap to inform others
          evs_log_debug(D_GAP_MSGS) << "sending empty gap";
!         profile_enter(send_gap_prof);
!         gu_trace(send_gap(UUID::nil(), current_view.get_id(), Range()));
!         profile_leave(send_gap_prof);
      }
  
      // Send messages
!     if (get_state() == S_OPERATIONAL)
      {
!         profile_enter(send_user_prof);
!         while (output.empty() == false)
          {
              int err;
!             gu_trace(err = send_user(send_window));
              if (err != 0)
              {
                  break;
              }
          }
!         profile_leave(send_user_prof);
      }
  
      // Deliver messages
!     profile_enter(delivery_prof);
!     if (input_map->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
      gu_trace(deliver_local());
!     profile_leave(delivery_prof);
  
      // If in recovery state, send join each time input map aru seq reaches
      // last sent and either input map aru or safe seq has changed.
!     if (get_state()                  == S_GATHER &&
!         consensus.highest_reachable_safe_seq() == input_map->get_aru_seq() &&
!         (prev_aru                    != input_map->get_aru_seq() ||
!          prev_safe                   != input_map->get_safe_seq()) &&
!         (msg.get_flags() & Message::F_RETRANS) == 0)
      {
!         gcomm_assert(output.empty() == true);
!         if (consensus.is_consensus() == false)
          {
!             profile_enter(send_join_prof);
              gu_trace(send_join());
!             profile_leave(send_join_prof);
          }
      }
  }
--- 2782,2869 ----
      }
  
      // Update im safe seq for self
!     update_im_safe_seq(NodeMap::value(self_i_).index(),
!                        input_map_->aru_seq());
  
      // Update safe seq for message source
!     prev_safe = update_im_safe_seq(inst.index(), msg.aru_seq());
  
!     profile_leave(input_map_prof_);
  
      // Check for missing messages
!     if (range.hs()                         >  range.lu() &&
!         (msg.flags() & Message::F_RETRANS) == 0                 )
      {
          evs_log_debug(D_RETRANS) << " requesting retrans from "
!                                  << msg.source() << " "
                                   << range
                                   << " due to input map gap, aru "
!                                  << input_map_->aru_seq();
!         profile_enter(send_gap_prof_);
!         gu_trace(send_gap(msg.source(), current_view_.id(), range));
!         profile_leave(send_gap_prof_);
      }
  
      // Seqno range completion and acknowledgement
!     const seqno_t max_hs(input_map_->max_hs());
!     if (output_.empty()                          == true            &&
!         (state() == S_OPERATIONAL || state() == S_GATHER)  &&
!         (msg.flags() & Message::F_MSG_MORE) == 0               &&
!         (last_sent_                              <  max_hs))
      {
          // Message not originated from this instance, output queue is empty
          // and last_sent seqno should be advanced
          gu_trace(complete_user(max_hs));
      }
!     else if (output_.empty()           == true  &&
!              input_map_->aru_seq() != prev_aru)
      {
          // Output queue empty and aru changed, send gap to inform others
          evs_log_debug(D_GAP_MSGS) << "sending empty gap";
!         profile_enter(send_gap_prof_);
!         gu_trace(send_gap(UUID::nil(), current_view_.id(), Range()));
!         profile_leave(send_gap_prof_);
      }
  
      // Send messages
!     if (state() == S_OPERATIONAL)
      {
!         profile_enter(send_user_prof_);
!         while (output_.empty() == false)
          {
              int err;
!             gu_trace(err = send_user(send_window_));
              if (err != 0)
              {
                  break;
              }
          }
!         profile_leave(send_user_prof_);
      }
  
      // Deliver messages
!     profile_enter(delivery_prof_);
!     if (input_map_->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
      gu_trace(deliver_local());
!     profile_leave(delivery_prof_);
  
      // If in recovery state, send join each time input map aru seq reaches
      // last sent and either input map aru or safe seq has changed.
!     if (state()                  == S_GATHER &&
!         consensus_.highest_reachable_safe_seq() == input_map_->aru_seq() &&
!         (prev_aru                    != input_map_->aru_seq() ||
!          prev_safe                   != input_map_->safe_seq()) &&
!         (msg.flags() & Message::F_RETRANS) == 0)
      {
!         gcomm_assert(output_.empty() == true);
!         if (consensus_.is_consensus() == false)
          {
!             profile_enter(send_join_prof_);
              gu_trace(send_join());
!             profile_leave(send_join_prof_);
          }
      }
  }
***************
*** 2844,2850 ****
                                          NodeMap::iterator ii,
                                          const Datagram& rb)
  {
!     gcomm_assert(ii != known.end());
      // evs_log_debug(D_DELEGATE_MSGS) << "delegate message " << msg;
      log_debug << "delegate";
      Message umsg;
--- 2873,2879 ----
                                          NodeMap::iterator ii,
                                          const Datagram& rb)
  {
!     gcomm_assert(ii != known_.end());
      // evs_log_debug(D_DELEGATE_MSGS) << "delegate message " << msg;
      log_debug << "delegate";
      Message umsg;
***************
*** 2856,2888 ****
  
  void gcomm::evs::Proto::handle_gap(const GapMessage& msg, NodeMap::iterator ii)
  {
!     assert(ii != known.end());
!     assert(get_state() != S_CLOSED && get_state() != S_JOINING);
  
!     Node& inst(NodeMap::get_value(ii));
      evs_log_debug(D_GAP_MSGS) << "gap message " << msg;
  
  
!     if ((msg.get_flags() & Message::F_COMMIT) != 0)
      {
!         log_debug << self_string() << " commit gap from " << msg.get_source();
!         if (get_state()                           == S_GATHER &&
!             install_message                       != 0 &&
!             install_message->get_fifo_seq()       == msg.get_seq())
          {
              inst.set_committed(true);
!             inst.set_tstamp(Date::now());
              if (is_all_committed() == true)
              {
                  shift_to(S_INSTALL);
                  gu_trace(send_gap(UUID::nil(),
!                                   install_message->get_install_view_id(),
                                    Range()));;
              }
          }
!         else if (get_state() == S_GATHER &&
!                  install_message != 0 &&
!                  install_message->get_fifo_seq() < msg.get_seq())
          {
              // new install message has been generated
              shift_to(S_GATHER, true);
--- 2885,2917 ----
  
  void gcomm::evs::Proto::handle_gap(const GapMessage& msg, NodeMap::iterator ii)
  {
!     assert(ii != known_.end());
!     assert(state() != S_CLOSED && state() != S_JOINING);
  
!     Node& inst(NodeMap::value(ii));
      evs_log_debug(D_GAP_MSGS) << "gap message " << msg;
  
  
!     if ((msg.flags() & Message::F_COMMIT) != 0)
      {
!         log_debug << self_string() << " commit gap from " << msg.source();
!         if (state()                           == S_GATHER &&
!             install_message_                       != 0 &&
!             install_message_->fifo_seq()       == msg.seq())
          {
              inst.set_committed(true);
!             inst.set_tstamp(gu::datetime::Date::now());
              if (is_all_committed() == true)
              {
                  shift_to(S_INSTALL);
                  gu_trace(send_gap(UUID::nil(),
!                                   install_message_->install_view_id(),
                                    Range()));;
              }
          }
!         else if (state() == S_GATHER &&
!                  install_message_ != 0 &&
!                  install_message_->fifo_seq() < msg.seq())
          {
              // new install message has been generated
              shift_to(S_GATHER, true);
***************
*** 2893,2916 ****
          }
          return;
      }
!     else if (get_state()                           == S_INSTALL  &&
!              install_message                       != 0          &&
!              install_message->get_install_view_id() == msg.get_source_view_id())
      {
          evs_log_debug(D_STATE) << "install gap " << msg;
          inst.set_installed(true);
!         inst.set_tstamp(Date::now());
          if (is_all_installed() == true)
          {
!             profile_enter(shift_to_prof);
              gu_trace(shift_to(S_OPERATIONAL));
!             profile_leave(shift_to_prof);
          }
          return;
      }
!     else if (msg.get_source_view_id() != current_view.get_id())
      {
!         if (get_state() == S_LEAVING)
          {
              // Silently drop
              return;
--- 2922,2945 ----
          }
          return;
      }
!     else if (state()                           == S_INSTALL  &&
!              install_message_                       != 0          &&
!              install_message_->install_view_id() == msg.source_view_id())
      {
          evs_log_debug(D_STATE) << "install gap " << msg;
          inst.set_installed(true);
!         inst.set_tstamp(gu::datetime::Date::now());
          if (is_all_installed() == true)
          {
!             profile_enter(shift_to_prof_);
              gu_trace(shift_to(S_OPERATIONAL));
!             profile_leave(shift_to_prof_);
          }
          return;
      }
!     else if (msg.source_view_id() != current_view_.id())
      {
!         if (state() == S_LEAVING)
          {
              // Silently drop
              return;
***************
*** 2922,2938 ****
              return;
          }
  
!         if (inst.get_operational() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from unoperational source "
!                 << msg.get_source();
          }
!         else if (inst.get_installed() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from uninstalled source "
!                 << msg.get_source();
          }
          else
          {
--- 2951,2967 ----
              return;
          }
  
!         if (inst.operational() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from unoperational source "
!                 << msg.source();
          }
!         else if (inst.installed() == false)
          {
              evs_log_debug(D_STATE)
                  << "dropping message from uninstalled source "
!                 << msg.source();
          }
          else
          {
***************
*** 2941,3025 ****
          return;
      }
  
!     gcomm_assert(msg.get_source_view_id() == current_view.get_id());
  
      //
      seqno_t prev_safe;
  
!     profile_enter(input_map_prof);
!     prev_safe = update_im_safe_seq(inst.get_index(), msg.get_aru_seq());
  
      // Deliver messages and update tstamp only if safe_seq changed
      // for the source.
!     if (prev_safe != input_map->get_safe_seq(inst.get_index()))
      {
!         inst.set_tstamp(Date::now());
      }
!     profile_leave(input_map_prof);
  
      //
!     if (msg.get_range_uuid() == get_uuid())
      {
!         if (msg.get_range().get_hs() > last_sent &&
!             (get_state() == S_OPERATIONAL || get_state() == S_GATHER))
          {
              // This could be leaving node requesting messages up to
              // its last sent.
!             gu_trace(complete_user(msg.get_range().get_hs()));
          }
          const seqno_t upper_bound(
!             std::min(msg.get_range().get_hs(), last_sent));
!         if (msg.get_range().get_lu() <= upper_bound)
          {
!             gu_trace(resend(msg.get_source(),
!                             Range(msg.get_range().get_lu(), upper_bound)));
          }
      }
  
      //
!     if (get_state() == S_OPERATIONAL)
      {
!         if (output.empty() == false)
          {
!             profile_enter(send_user_prof);
!             while (output.empty() == false)
              {
                  int err;
!                 gu_trace(err = send_user(send_window));
                  if (err != 0)
                      break;
              }
!             profile_leave(send_user_prof);
          }
          else
          {
!             const seqno_t max_hs(input_map->get_max_hs());
!             if (last_sent <  max_hs)
              {
                  gu_trace(complete_user(max_hs));
              }
          }
      }
  
!     profile_enter(delivery_prof);
!     if (input_map->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
      gu_trace(deliver_local());
!     profile_leave(delivery_prof);
  
      //
!     if (get_state()                            == S_GATHER                  &&
!         consensus.highest_reachable_safe_seq() == input_map->get_aru_seq()  &&
!         prev_safe                              != input_map->get_safe_seq()   )
      {
!         gcomm_assert(output.empty() == true);
!         if (consensus.is_consensus() == false)
          {
!             profile_enter(send_join_prof);
              gu_trace(send_join());
!             profile_leave(send_join_prof);
          }
      }
  }
--- 2970,3054 ----
          return;
      }
  
!     gcomm_assert(msg.source_view_id() == current_view_.id());
  
      //
      seqno_t prev_safe;
  
!     profile_enter(input_map_prof_);
!     prev_safe = update_im_safe_seq(inst.index(), msg.aru_seq());
  
      // Deliver messages and update tstamp only if safe_seq changed
      // for the source.
!     if (prev_safe != input_map_->safe_seq(inst.index()))
      {
!         inst.set_tstamp(gu::datetime::Date::now());
      }
!     profile_leave(input_map_prof_);
  
      //
!     if (msg.range_uuid() == uuid())
      {
!         if (msg.range().hs() > last_sent_ &&
!             (state() == S_OPERATIONAL || state() == S_GATHER))
          {
              // This could be leaving node requesting messages up to
              // its last sent.
!             gu_trace(complete_user(msg.range().hs()));
          }
          const seqno_t upper_bound(
!             std::min(msg.range().hs(), last_sent_));
!         if (msg.range().lu() <= upper_bound)
          {
!             gu_trace(resend(msg.source(),
!                             Range(msg.range().lu(), upper_bound)));
          }
      }
  
      //
!     if (state() == S_OPERATIONAL)
      {
!         if (output_.empty() == false)
          {
!             profile_enter(send_user_prof_);
!             while (output_.empty() == false)
              {
                  int err;
!                 gu_trace(err = send_user(send_window_));
                  if (err != 0)
                      break;
              }
!             profile_leave(send_user_prof_);
          }
          else
          {
!             const seqno_t max_hs(input_map_->max_hs());
!             if (last_sent_ <  max_hs)
              {
                  gu_trace(complete_user(max_hs));
              }
          }
      }
  
!     profile_enter(delivery_prof_);
!     if (input_map_->has_deliverables() == true)
      {
          gu_trace(deliver());
      }
      gu_trace(deliver_local());
!     profile_leave(delivery_prof_);
  
      //
!     if (state()                            == S_GATHER                  &&
!         consensus_.highest_reachable_safe_seq() == input_map_->aru_seq()  &&
!         prev_safe                              != input_map_->safe_seq()   )
      {
!         gcomm_assert(output_.empty() == true);
!         if (consensus_.is_consensus() == false)
          {
!             profile_enter(send_join_prof_);
              gu_trace(send_join());
!             profile_leave(send_join_prof_);
          }
      }
  }
***************
*** 3032,3046 ****
      for (MessageNodeList::const_iterator i = node_list.begin();
           i != node_list.end(); ++i)
      {
!         const UUID& uuid(MessageNodeList::get_key(i));
!         const Node& local_node(NodeMap::get_value(known.find_checked(uuid)));
!         const MessageNode& node(MessageNodeList::get_value(i));
!         gcomm_assert(node.get_view_id() == current_view.get_id());
!         const seqno_t safe_seq(node.get_safe_seq());
          seqno_t prev_safe_seq;
!         gu_trace(prev_safe_seq = update_im_safe_seq(local_node.get_index(), safe_seq));
          if (prev_safe_seq                 != safe_seq &&
!             input_map->get_safe_seq(local_node.get_index()) == safe_seq)
          {
              updated = true;
          }
--- 3061,3075 ----
      for (MessageNodeList::const_iterator i = node_list.begin();
           i != node_list.end(); ++i)
      {
!         const UUID& node_uuid(MessageNodeList::key(i));
!         const Node& local_node(NodeMap::value(known_.find_checked(node_uuid)));
!         const MessageNode& node(MessageNodeList::value(i));
!         gcomm_assert(node.view_id() == current_view_.id());
!         const seqno_t safe_seq(node.safe_seq());
          seqno_t prev_safe_seq;
!         gu_trace(prev_safe_seq = update_im_safe_seq(local_node.index(), safe_seq));
          if (prev_safe_seq                 != safe_seq &&
!             input_map_->safe_seq(local_node.index()) == safe_seq)
          {
              updated = true;
          }
***************
*** 3055,3110 ****
      for (MessageNodeList::const_iterator i = node_list.begin();
           i != node_list.end(); ++i)
      {
!         const UUID& uuid(MessageNodeList::get_key(i));
!         const MessageNode& mn(MessageNodeList::get_value(i));
!         const Node& n(NodeMap::get_value(known.find_checked(uuid)));
!         const Range r(input_map->get_range(n.get_index()));
  
!         if (uuid == get_uuid() &&
!             mn.get_im_range().get_lu() != r.get_lu())
          {
              // Source member is missing messages from us
!             gcomm_assert(mn.get_im_range().get_hs() <= last_sent);
              gu_trace(resend(nl_uuid,
!                             Range(mn.get_im_range().get_lu(), last_sent)));
          }
!         else if ((mn.get_operational() == false ||
!                   mn.get_leaving() == true) &&
!                  uuid != get_uuid() &&
!                  (mn.get_im_range().get_lu() < r.get_lu() ||
!                   mn.get_im_range().get_hs() < r.get_hs()))
!         {
!             gu_trace(recover(nl_uuid, uuid,
!                              Range(mn.get_im_range().get_lu(),
!                                    r.get_hs())));
          }
      }
  }
  
  void gcomm::evs::Proto::retrans_leaves(const MessageNodeList& node_list)
  {
!     for (NodeMap::const_iterator li = known.begin(); li != known.end(); ++li)
      {
!         const Node& local_node(NodeMap::get_value(li));
!         if (local_node.get_leave_message() != 0 &&
              local_node.is_inactive()       == false)
          {
              MessageNodeList::const_iterator msg_li(
!                 node_list.find(NodeMap::get_key(li)));
  
              if (msg_li == node_list.end() ||
!                 MessageNodeList::get_value(msg_li).get_leaving() == false)
              {
!                 const LeaveMessage& lm(*NodeMap::get_value(li).get_leave_message());
!                 LeaveMessage send_lm(lm.get_version(),
!                                      lm.get_source(),
!                                      lm.get_source_view_id(),
!                                      lm.get_seq(),
!                                      lm.get_aru_seq(),
!                                      lm.get_fifo_seq(),
                                       Message::F_RETRANS | Message::F_SOURCE);
  
!                 Buffer buf;
                  serialize(send_lm, buf);
                  Datagram dg(buf);
                  gu_trace(send_delegate(dg));
--- 3084,3139 ----
      for (MessageNodeList::const_iterator i = node_list.begin();
           i != node_list.end(); ++i)
      {
!         const UUID& node_uuid(MessageNodeList::key(i));
!         const MessageNode& mn(MessageNodeList::value(i));
!         const Node& n(NodeMap::value(known_.find_checked(node_uuid)));
!         const Range r(input_map_->range(n.index()));
  
!         if (node_uuid == uuid() &&
!             mn.im_range().lu() != r.lu())
          {
              // Source member is missing messages from us
!             gcomm_assert(mn.im_range().hs() <= last_sent_);
              gu_trace(resend(nl_uuid,
!                             Range(mn.im_range().lu(), last_sent_)));
          }
!         else if ((mn.operational() == false ||
!                   mn.leaving() == true) &&
!                  node_uuid != uuid() &&
!                  (mn.im_range().lu() < r.lu() ||
!                   mn.im_range().hs() < r.hs()))
!         {
!             gu_trace(recover(nl_uuid, node_uuid,
!                              Range(mn.im_range().lu(),
!                                    r.hs())));
          }
      }
  }
  
  void gcomm::evs::Proto::retrans_leaves(const MessageNodeList& node_list)
  {
!     for (NodeMap::const_iterator li = known_.begin(); li != known_.end(); ++li)
      {
!         const Node& local_node(NodeMap::value(li));
!         if (local_node.leave_message() != 0 &&
              local_node.is_inactive()       == false)
          {
              MessageNodeList::const_iterator msg_li(
!                 node_list.find(NodeMap::key(li)));
  
              if (msg_li == node_list.end() ||
!                 MessageNodeList::value(msg_li).leaving() == false)
              {
!                 const LeaveMessage& lm(*NodeMap::value(li).leave_message());
!                 LeaveMessage send_lm(lm.version(),
!                                      lm.source(),
!                                      lm.source_view_id(),
!                                      lm.seq(),
!                                      lm.aru_seq(),
!                                      lm.fifo_seq(),
                                       Message::F_RETRANS | Message::F_SOURCE);
  
!                 gu::Buffer buf;
                  serialize(send_lm, buf);
                  Datagram dg(buf);
                  gu_trace(send_delegate(dg));
***************
*** 3117,3179 ****
  class SelectSuspectsOp
  {
  public:
!     SelectSuspectsOp(MessageNodeList& nl) : nl_(nl) { }
  
!     void operator()(const MessageNodeList::value_type& vt) const
      {
!         if (MessageNodeList::get_value(vt).get_suspected() == true)
          {
              nl_.insert_unique(vt);
          }
      }
  private:
!     MessageNodeList& nl_;
  };
  
  void gcomm::evs::Proto::check_suspects(const UUID& source,
                                         const MessageNodeList& nl)
  {
!     assert(source != get_uuid());
      MessageNodeList suspected;
      for_each(nl.begin(), nl.end(), SelectSuspectsOp(suspected));
  
      for (MessageNodeList::const_iterator i(suspected.begin());
           i != suspected.end(); ++i)
      {
!         const UUID& uuid(MessageNodeList::get_key(i));
!         const MessageNode& node(MessageNodeList::get_value(i));
!         if (node.get_suspected() == true)
          {
!             if (uuid != get_uuid())
              {
                  size_t s_cnt(0);
                  // Iterate over join messages to see if majority agrees
                  // with the suspicion
!                 for (NodeMap::const_iterator j(known.begin());
!                      j != known.end(); ++j)
                  {
!                     const JoinMessage* jm(NodeMap::get_value(j).get_join_message());
!                     if (jm != 0 && jm->get_source() != uuid)
                      {
!                         MessageNodeList::const_iterator mni(jm->get_node_list().find(uuid));
!                         if (mni != jm->get_node_list().end())
                          {
!                             const MessageNode& mn(MessageNodeList::get_value(mni));
!                             if (mn.get_suspected() == true)
                              {
                                  ++s_cnt;
                              }
                          }
                      }
                  }
!                 const Node& kn(NodeMap::get_value(known.find_checked(uuid)));
!                 if (kn.get_operational() == true &&
!                     s_cnt > current_view.get_members().size()/2)
                  {
                      evs_log_info(I_STATE)
                          << " declaring suspected "
!                         << uuid << " as inactive";
!                     set_inactive(uuid);
                  }
              }
          }
--- 3146,3208 ----
  class SelectSuspectsOp
  {
  public:
!     SelectSuspectsOp(gcomm::evs::MessageNodeList& nl) : nl_(nl) { }
  
!     void operator()(const gcomm::evs::MessageNodeList::value_type& vt) const
      {
!         if (gcomm::evs::MessageNodeList::value(vt).suspected() == true)
          {
              nl_.insert_unique(vt);
          }
      }
  private:
!     gcomm::evs::MessageNodeList& nl_;
  };
  
  void gcomm::evs::Proto::check_suspects(const UUID& source,
                                         const MessageNodeList& nl)
  {
!     assert(source != uuid());
      MessageNodeList suspected;
      for_each(nl.begin(), nl.end(), SelectSuspectsOp(suspected));
  
      for (MessageNodeList::const_iterator i(suspected.begin());
           i != suspected.end(); ++i)
      {
!         const UUID& node_uuid(MessageNodeList::key(i));
!         const MessageNode& node(MessageNodeList::value(i));
!         if (node.suspected() == true)
          {
!             if (node_uuid != uuid())
              {
                  size_t s_cnt(0);
                  // Iterate over join messages to see if majority agrees
                  // with the suspicion
!                 for (NodeMap::const_iterator j(known_.begin());
!                      j != known_.end(); ++j)
                  {
!                     const JoinMessage* jm(NodeMap::value(j).join_message());
!                     if (jm != 0 && jm->source() != node_uuid)
                      {
!                         MessageNodeList::const_iterator mni(jm->node_list().find(node_uuid));
!                         if (mni != jm->node_list().end())
                          {
!                             const MessageNode& mn(MessageNodeList::value(mni));
!                             if (mn.suspected() == true)
                              {
                                  ++s_cnt;
                              }
                          }
                      }
                  }
!                 const Node& kn(NodeMap::value(known_.find_checked(node_uuid)));
!                 if (kn.operational() == true &&
!                     s_cnt > current_view_.members().size()/2)
                  {
                      evs_log_info(I_STATE)
                          << " declaring suspected "
!                         << node_uuid << " as inactive";
!                     set_inactive(node_uuid);
                  }
              }
          }
***************
*** 3188,3231 ****
  void gcomm::evs::Proto::cross_check_inactives(const UUID& source,
                                                const MessageNodeList& nl)
  {
!     assert(source != get_uuid());
  
!     const Date now(Date::now());
!     const Period wait_c_to((install_timeout*2)/3); // Wait for consensus
  
      TimerList::const_iterator ti(
!         find_if(timers.begin(), timers.end(), TimerSelectOp(T_INSTALL)));
!     assert(ti != timers.end());
!     if (now + wait_c_to < TimerList::get_key(ti))
      {
          // No check yet
          return;
      }
  
!     NodeMap::const_iterator source_i(known.find_checked(source));
!     const Node& local_source_node(NodeMap::get_value(source_i));
!     const Period ito((install_timeout*1)/3);       // Tighter inactive timeout
  
      MessageNodeList inactive;
      for_each(nl.begin(), nl.end(), SelectNodesOp(inactive, ViewId(), false, false));
      for (MessageNodeList::const_iterator i = inactive.begin();
           i != inactive.end(); ++i)
      {
!         const UUID& uuid(MessageNodeList::get_key(i));
!         const MessageNode& node(MessageNodeList::get_value(i));
!         gcomm_assert(node.get_operational() == false);
!         NodeMap::iterator local_i(known.find(uuid));
! 
!         if (local_i != known.end() && uuid != get_uuid())
!         {
!             Node& local_node(NodeMap::get_value(local_i));
!             if (local_node.get_operational()         == true &&
!                 local_source_node.get_tstamp() + ito >= now  &&
!                 local_node.get_tstamp() + ito        >= now  &&
!                 uuid > source)
              {
!                 evs_log_info(I_STATE) << " arbitrating, select " << uuid;
!                 set_inactive(uuid);
              }
          }
      }
--- 3217,3260 ----
  void gcomm::evs::Proto::cross_check_inactives(const UUID& source,
                                                const MessageNodeList& nl)
  {
!     assert(source != uuid());
  
!     const gu::datetime::Date now(gu::datetime::Date::now());
!     const gu::datetime::Period wait_c_to((install_timeout_*2)/3); // Wait for consensus
  
      TimerList::const_iterator ti(
!         find_if(timers_.begin(), timers_.end(), TimerSelectOp(T_INSTALL)));
!     assert(ti != timers_.end());
!     if (now + wait_c_to < TimerList::key(ti))
      {
          // No check yet
          return;
      }
  
!     NodeMap::const_iterator source_i(known_.find_checked(source));
!     const Node& local_source_node(NodeMap::value(source_i));
!     const gu::datetime::Period ito((install_timeout_*1)/3);       // Tighter inactive timeout
  
      MessageNodeList inactive;
      for_each(nl.begin(), nl.end(), SelectNodesOp(inactive, ViewId(), false, false));
      for (MessageNodeList::const_iterator i = inactive.begin();
           i != inactive.end(); ++i)
      {
!         const UUID& node_uuid(MessageNodeList::key(i));
!         const MessageNode& node(MessageNodeList::value(i));
!         gcomm_assert(node.operational() == false);
!         NodeMap::iterator local_i(known_.find(node_uuid));
! 
!         if (local_i != known_.end() && node_uuid != uuid())
!         {
!             Node& local_node(NodeMap::value(local_i));
!             if (local_node.operational()         == true &&
!                 local_source_node.tstamp() + ito >= now  &&
!                 local_node.tstamp() + ito        >= now  &&
!                 node_uuid > source)
              {
!                 evs_log_info(I_STATE) << " arbitrating, select " << node_uuid;
!                 set_inactive(node_uuid);
              }
          }
      }
***************
*** 3237,3293 ****
  // should be declared inactive.
  void gcomm::evs::Proto::check_unseen()
  {
!     for (NodeMap::iterator i(known.begin()); i != known.end(); ++i)
      {
  
!         const UUID& uuid(NodeMap::get_key(i));
!         Node& node(NodeMap::get_value(i));
  
!         if (uuid                         != get_uuid() &&
!             current_view.is_member(uuid) == false      &&
!             node.get_join_message()      == 0          &&
!             node.get_operational()       == true        )
          {
!             evs_log_info(I_STATE) << "checking operational unseen " << uuid;
              size_t cnt(0), inact_cnt(0);
!             for (NodeMap::iterator j(known.begin()); j != known.end(); ++j)
              {
!                 const JoinMessage* jm(NodeMap::get_value(j).get_join_message());
!                 if (jm == 0 || NodeMap::get_key(j) == get_uuid())
                  {
                      continue;
                  }
                  MessageNodeList::const_iterator mn_i;
!                 for (mn_i = jm->get_node_list().begin();
!                      mn_i != jm->get_node_list().end(); ++mn_i)
                  {
                      NodeMap::const_iterator known_i(
!                         known.find(MessageNodeList::get_key(mn_i)));
!                     if (known_i == known.end() ||
!                         (MessageNodeList::get_value(mn_i).get_operational() == true &&
!                          NodeMap::get_value(known_i).get_join_message() == 0))
                      {
                          evs_log_info(I_STATE)
                              << "all joins not locally present for "
!                             << NodeMap::get_key(j)
                              << " join message node list";
                          return;
                      }
                  }
  
!                 if ((mn_i = jm->get_node_list().find(uuid))
!                     != jm->get_node_list().end())
                  {
!                     const MessageNode& mn(MessageNodeList::get_value(mn_i));
                      evs_log_info(I_STATE)
!                         << "found " << uuid << " from " <<  NodeMap::get_key(j)
                          << " join message: "
!                         << mn.get_view_id() << " "
!                         << mn.get_operational();
!                     if (mn.get_view_id() != ViewId(V_REG))
                      {
                          ++cnt;
!                         if (mn.get_operational() == false) ++inact_cnt;
                      }
                  }
              }
--- 3266,3323 ----
  // should be declared inactive.
  void gcomm::evs::Proto::check_unseen()
  {
!     for (NodeMap::iterator i(known_.begin()); i != known_.end(); ++i)
      {
  
!         const UUID& node_uuid(NodeMap::key(i));
!         Node& node(NodeMap::value(i));
  
!         if (node_uuid                          != uuid() &&
!             current_view_.is_member(node_uuid) == false  &&
!             node.join_message()                == 0      &&
!             node.operational()                 == true)
          {
!             evs_log_info(I_STATE) << "checking operational unseen "
!                                   << node_uuid;
              size_t cnt(0), inact_cnt(0);
!             for (NodeMap::iterator j(known_.begin()); j != known_.end(); ++j)
              {
!                 const JoinMessage* jm(NodeMap::value(j).join_message());
!                 if (jm == 0 || NodeMap::key(j) == uuid())
                  {
                      continue;
                  }
                  MessageNodeList::const_iterator mn_i;
!                 for (mn_i = jm->node_list().begin();
!                      mn_i != jm->node_list().end(); ++mn_i)
                  {
                      NodeMap::const_iterator known_i(
!                         known_.find(MessageNodeList::key(mn_i)));
!                     if (known_i == known_.end() ||
!                         (MessageNodeList::value(mn_i).operational() == true &&
!                          NodeMap::value(known_i).join_message() == 0))
                      {
                          evs_log_info(I_STATE)
                              << "all joins not locally present for "
!                             << NodeMap::key(j)
                              << " join message node list";
                          return;
                      }
                  }
  
!                 if ((mn_i = jm->node_list().find(node_uuid))
!                     != jm->node_list().end())
                  {
!                     const MessageNode& mn(MessageNodeList::value(mn_i));
                      evs_log_info(I_STATE)
!                         << "found " << node_uuid << " from " <<  NodeMap::key(j)
                          << " join message: "
!                         << mn.view_id() << " "
!                         << mn.operational();
!                     if (mn.view_id() != ViewId(V_REG))
                      {
                          ++cnt;
!                         if (mn.operational() == false) ++inact_cnt;
                      }
                  }
              }
***************
*** 3299,3305 ****
                      << ", inact_cnt="
                      << inact_cnt
                      << ")";
!                 set_inactive(uuid);
              }
          }
      }
--- 3329,3335 ----
                      << ", inact_cnt="
                      << inact_cnt
                      << ")";
!                 set_inactive(node_uuid);
              }
          }
      }
***************
*** 3312,3334 ****
  {
      size_t join_counts(0);
      std::map<UUID, size_t > nil_counts;
!     for (NodeMap::const_iterator i(known.begin()); i != known.end(); ++i)
      {
!         const JoinMessage* jm(NodeMap::get_value(i).get_join_message());
          if (jm == 0)
          {
              continue;
          }
          ++join_counts;
!         for (MessageNodeList::const_iterator j(jm->get_node_list().begin());
!              j != jm->get_node_list().end(); ++j)
          {
!             const MessageNode& mn(MessageNodeList::get_value(j));
!             if (mn.get_view_id() == ViewId(V_REG))
              {
!                 if (mn.get_suspected() == true)
                  {
!                     const UUID& uuid(MessageNodeList::get_key(j));
                      ++nil_counts[uuid];
                  }
              }
--- 3342,3364 ----
  {
      size_t join_counts(0);
      std::map<UUID, size_t > nil_counts;
!     for (NodeMap::const_iterator i(known_.begin()); i != known_.end(); ++i)
      {
!         const JoinMessage* jm(NodeMap::value(i).join_message());
          if (jm == 0)
          {
              continue;
          }
          ++join_counts;
!         for (MessageNodeList::const_iterator j(jm->node_list().begin());
!              j != jm->node_list().end(); ++j)
          {
!             const MessageNode& mn(MessageNodeList::value(j));
!             if (mn.view_id() == ViewId(V_REG))
              {
!                 if (mn.suspected() == true)
                  {
!                     const UUID& uuid(MessageNodeList::key(j));
                      ++nil_counts[uuid];
                  }
              }
***************
*** 3350,3395 ****
  
  void gcomm::evs::Proto::handle_join(const JoinMessage& msg, NodeMap::iterator ii)
  {
!     assert(ii != known.end());
!     assert(get_state() != S_CLOSED);
  
!     Node& inst(NodeMap::get_value(ii));
  
      evs_log_debug(D_JOIN_MSGS) << " " << msg;
  
!     if (get_state() == S_LEAVING)
      {
!         if (msg.get_source_view_id() == current_view.get_id())
          {
!             inst.set_tstamp(Date::now());
              MessageNodeList same_view;
!             for_each(msg.get_node_list().begin(), msg.get_node_list().end(),
!                      SelectNodesOp(same_view, current_view.get_id(),
                                     true, true));
!             profile_enter(input_map_prof);
              if (update_im_safe_seqs(same_view) == true)
              {
!                 profile_enter(send_leave_prof);
                  gu_trace(send_leave(false));
!                 profile_leave(send_leave_prof);
              }
!             for (NodeMap::const_iterator i = known.begin(); i != known.end();
                   ++i)
              {
!                 const UUID& uuid(NodeMap::get_key(i));
!                 const Node& node(NodeMap::get_value(i));
!                 if (current_view.is_member(uuid) == true)
                  {
!                     const Range r(input_map->get_range(node.get_index()));
!                     if (r.get_lu() <= last_sent)
                      {
!                         send_gap(uuid, current_view.get_id(),
!                                  Range(r.get_lu(), last_sent));
                      }
                  }
              }
!             profile_leave(input_map_prof);
!             gu_trace(retrans_user(msg.get_source(), same_view));
          }
          return;
      }
--- 3380,3425 ----
  
  void gcomm::evs::Proto::handle_join(const JoinMessage& msg, NodeMap::iterator ii)
  {
!     assert(ii != known_.end());
!     assert(state() != S_CLOSED);
  
!     Node& inst(NodeMap::value(ii));
  
      evs_log_debug(D_JOIN_MSGS) << " " << msg;
  
!     if (state() == S_LEAVING)
      {
!         if (msg.source_view_id() == current_view_.id())
          {
!             inst.set_tstamp(gu::datetime::Date::now());
              MessageNodeList same_view;
!             for_each(msg.node_list().begin(), msg.node_list().end(),
!                      SelectNodesOp(same_view, current_view_.id(),
                                     true, true));
!             profile_enter(input_map_prof_);
              if (update_im_safe_seqs(same_view) == true)
              {
!                 profile_enter(send_leave_prof_);
                  gu_trace(send_leave(false));
!                 profile_leave(send_leave_prof_);
              }
!             for (NodeMap::const_iterator i = known_.begin(); i != known_.end();
                   ++i)
              {
!                 const UUID& uuid(NodeMap::key(i));
!                 const Node& node(NodeMap::value(i));
!                 if (current_view_.is_member(uuid) == true)
                  {
!                     const Range r(input_map_->range(node.index()));
!                     if (r.lu() <= last_sent_)
                      {
!                         send_gap(uuid, current_view_.id(),
!                                  Range(r.lu(), last_sent_));
                      }
                  }
              }
!             profile_leave(input_map_prof_);
!             gu_trace(retrans_user(msg.source(), same_view));
          }
          return;
      }
***************
*** 3397,3421 ****
      {
          return;
      }
!     else if (install_message != 0)
      {
          // Note: don't send join from this branch yet, join is
          // sent at the end of this method
!         if (install_message->get_source() == msg.get_source())
          {
              evs_log_info(I_STATE)
                  << "shift to gather due to representative "
!                 << msg.get_source() << " join";
              gu_trace(shift_to(S_GATHER, false));
          }
!         else if (consensus.is_consistent(*install_message) == true)
          {
              return;
              // Commented out: It seems to be better strategy to
              // just wait source of inconsistent join to time out
              // instead of shifting to gather. #443
  
!             // if (consensus.is_consistent(msg) == true)
              // {
              //   return;
              // }
--- 3427,3451 ----
      {
          return;
      }
!     else if (install_message_ != 0)
      {
          // Note: don't send join from this branch yet, join is
          // sent at the end of this method
!         if (install_message_->source() == msg.source())
          {
              evs_log_info(I_STATE)
                  << "shift to gather due to representative "
!                 << msg.source() << " join";
              gu_trace(shift_to(S_GATHER, false));
          }
!         else if (consensus_.is_consistent(*install_message_) == true)
          {
              return;
              // Commented out: It seems to be better strategy to
              // just wait source of inconsistent join to time out
              // instead of shifting to gather. #443
  
!             // if (consensus_.is_consistent(msg) == true)
              // {
              //   return;
              // }
***************
*** 3433,3483 ****
              evs_log_info(I_STATE)
                  << "shift to GATHER, install message is "
                  << "inconsistent when handling join from "
!                 << msg.get_source() << " " << msg.get_source_view_id();
              evs_log_info(I_STATE) << "state: " << *this;
              gu_trace(shift_to(S_GATHER, false));
          }
      }
!     else if (get_state() != S_GATHER)
      {
          evs_log_info(I_STATE)
              << " shift to GATHER while handling join message from "
!             << msg.get_source() << " " << msg.get_source_view_id();
          gu_trace(shift_to(S_GATHER, false));
      }
  
!     gcomm_assert(output.empty() == true);
  
      // @todo Figure out how to avoid setting tstamp from any join message
!     if (inst.get_join_message() != 0)
!         inst.set_tstamp(Date::now());
      inst.set_join_message(&msg);
  
      // Add unseen nodes to known list. No need to adjust node state here,
      // it is done later on in check_suspects()/cross_check_inactives().
!     for (MessageNodeList::const_iterator i(msg.get_node_list().begin());
!          i != msg.get_node_list().end(); ++i)
      {
!         NodeMap::iterator ni(known.find(MessageNodeList::get_key(i)));
!         if (ni == known.end())
          {
!             known.insert_unique(
!                 make_pair(MessageNodeList::get_key(i),
!                           Node(inactive_timeout, suspect_timeout)));
          }
      }
  
      // Select nodes that are coming from the same view as seen by
      // message source
      MessageNodeList same_view;
!     for_each(msg.get_node_list().begin(), msg.get_node_list().end(),
!              SelectNodesOp(same_view, current_view.get_id(), true, true));
      // Find out self from node list
!     MessageNodeList::const_iterator nlself_i(same_view.find(get_uuid()));
  
      // Other node coming from the same view
!     if (msg.get_source()         != get_uuid() &&
!         msg.get_source_view_id() == current_view.get_id())
      {
          gcomm_assert(nlself_i != same_view.end());
          // Update input map state
--- 3463,3513 ----
              evs_log_info(I_STATE)
                  << "shift to GATHER, install message is "
                  << "inconsistent when handling join from "
!                 << msg.source() << " " << msg.source_view_id();
              evs_log_info(I_STATE) << "state: " << *this;
              gu_trace(shift_to(S_GATHER, false));
          }
      }
!     else if (state() != S_GATHER)
      {
          evs_log_info(I_STATE)
              << " shift to GATHER while handling join message from "
!             << msg.source() << " " << msg.source_view_id();
          gu_trace(shift_to(S_GATHER, false));
      }
  
!     gcomm_assert(output_.empty() == true);
  
      // @todo Figure out how to avoid setting tstamp from any join message
!     if (inst.join_message() != 0)
!         inst.set_tstamp(gu::datetime::Date::now());
      inst.set_join_message(&msg);
  
      // Add unseen nodes to known list. No need to adjust node state here,
      // it is done later on in check_suspects()/cross_check_inactives().
!     for (MessageNodeList::const_iterator i(msg.node_list().begin());
!          i != msg.node_list().end(); ++i)
      {
!         NodeMap::iterator ni(known_.find(MessageNodeList::key(i)));
!         if (ni == known_.end())
          {
!             known_.insert_unique(
!                 std::make_pair(MessageNodeList::key(i),
!                                Node(inactive_timeout_, suspect_timeout_)));
          }
      }
  
      // Select nodes that are coming from the same view as seen by
      // message source
      MessageNodeList same_view;
!     for_each(msg.node_list().begin(), msg.node_list().end(),
!              SelectNodesOp(same_view, current_view_.id(), true, true));
      // Find out self from node list
!     MessageNodeList::const_iterator nlself_i(same_view.find(uuid()));
  
      // Other node coming from the same view
!     if (msg.source()         != uuid() &&
!         msg.source_view_id() == current_view_.id())
      {
          gcomm_assert(nlself_i != same_view.end());
          // Update input map state
***************
*** 3486,3548 ****
          // Find out max hs and complete up to that if needed
          MessageNodeList::const_iterator max_hs_i(
              max_element(same_view.begin(), same_view.end(), RangeHsCmp()));
!         const seqno_t max_hs(MessageNodeList::get_value(max_hs_i).get_im_range().get_hs());
!         if (last_sent < max_hs)
          {
              gu_trace(complete_user(max_hs));
          }
      }
  
      //
!     gu_trace(retrans_user(msg.get_source(), same_view));
      // Retrans leave messages that others are missing
      gu_trace(retrans_leaves(same_view));
  
      // Check if this node is set inactive by the other,
      // if yes, the other must be marked as inactive too
!     if (msg.get_source() != get_uuid() && nlself_i != same_view.end())
      {
!         if (MessageNodeList::get_value(nlself_i).get_operational() == false)
          {
  
              evs_log_info(I_STATE)
!                 << " declaring source " << msg.get_source()
                  << " as inactive (mutual exclusion)";
!             set_inactive(msg.get_source());
          }
      }
  
      // Make cross check to resolve conflict if two nodes
      // declare each other inactive. There is no need to make
      // this for own messages.
!     if (msg.get_source() != get_uuid())
      {
!         gu_trace(check_suspects(msg.get_source(), same_view));
!         gu_trace(cross_check_inactives(msg.get_source(), same_view));
          gu_trace(check_unseen());
          gu_trace(check_nil_view_id());
      }
  
      // If current join message differs from current state, send new join
!     const JoinMessage* curr_join(NodeMap::get_value(self_i).get_join_message());
      MessageNodeList new_nl;
      populate_node_list(&new_nl);
  
      if (curr_join == 0 ||
!         (curr_join->get_aru_seq()   != input_map->get_aru_seq()  ||
!          curr_join->get_seq()       != input_map->get_safe_seq() ||
!          curr_join->get_node_list() != new_nl))
      {
          gu_trace(create_join());
!         if (consensus.is_consensus() == false)
          {
              send_join(false);
          }
      }
  
!     if (consensus.is_consensus() == true)
      {
!         if (is_representative(get_uuid()) == true)
          {
              gu_trace(send_install());
          }
--- 3516,3578 ----
          // Find out max hs and complete up to that if needed
          MessageNodeList::const_iterator max_hs_i(
              max_element(same_view.begin(), same_view.end(), RangeHsCmp()));
!         const seqno_t max_hs(MessageNodeList::value(max_hs_i).im_range().hs());
!         if (last_sent_ < max_hs)
          {
              gu_trace(complete_user(max_hs));
          }
      }
  
      //
!     gu_trace(retrans_user(msg.source(), same_view));
      // Retrans leave messages that others are missing
      gu_trace(retrans_leaves(same_view));
  
      // Check if this node is set inactive by the other,
      // if yes, the other must be marked as inactive too
!     if (msg.source() != uuid() && nlself_i != same_view.end())
      {
!         if (MessageNodeList::value(nlself_i).operational() == false)
          {
  
              evs_log_info(I_STATE)
!                 << " declaring source " << msg.source()
                  << " as inactive (mutual exclusion)";
!             set_inactive(msg.source());
          }
      }
  
      // Make cross check to resolve conflict if two nodes
      // declare each other inactive. There is no need to make
      // this for own messages.
!     if (msg.source() != uuid())
      {
!         gu_trace(check_suspects(msg.source(), same_view));
!         gu_trace(cross_check_inactives(msg.source(), same_view));
          gu_trace(check_unseen());
          gu_trace(check_nil_view_id());
      }
  
      // If current join message differs from current state, send new join
!     const JoinMessage* curr_join(NodeMap::value(self_i_).join_message());
      MessageNodeList new_nl;
      populate_node_list(&new_nl);
  
      if (curr_join == 0 ||
!         (curr_join->aru_seq()   != input_map_->aru_seq()  ||
!          curr_join->seq()       != input_map_->safe_seq() ||
!          curr_join->node_list() != new_nl))
      {
          gu_trace(create_join());
!         if (consensus_.is_consensus() == false)
          {
              send_join(false);
          }
      }
  
!     if (consensus_.is_consensus() == true)
      {
!         if (is_representative(uuid()) == true)
          {
              gu_trace(send_install());
          }
***************
*** 3553,3611 ****
  void gcomm::evs::Proto::handle_leave(const LeaveMessage& msg,
                                       NodeMap::iterator ii)
  {
!     assert(ii != known.end());
!     assert(get_state() != S_CLOSED && get_state() != S_JOINING);
  
!     Node& node(NodeMap::get_value(ii));
      evs_log_debug(D_LEAVE_MSGS) << "leave message " << msg;
  
!     if (msg.get_source() != get_uuid() && node.is_inactive() == true)
      {
          evs_log_debug(D_LEAVE_MSGS) << "dropping leave from already inactive";
          return;
      }
      node.set_leave_message(&msg);
!     if (msg.get_source() == get_uuid())
      {
          // The last one to live, instant close. Otherwise continue
          // serving until it becomes apparent that others have
          // leave message.
!         if (current_view.get_members().size() == 1)
          {
!             profile_enter(shift_to_prof);
              gu_trace(shift_to(S_CLOSED));
!             profile_leave(shift_to_prof);
          }
      }
      else
      {
!         if (msg.get_source_view_id()       != current_view.get_id() ||
              is_msg_from_previous_view(msg) == true)
          {
              // Silent drop
              return;
          }
          node.set_operational(false);
!         const seqno_t prev_safe_seq(update_im_safe_seq(node.get_index(), msg.get_aru_seq()));
!         if (prev_safe_seq != input_map->get_safe_seq(node.get_index()))
          {
!             node.set_tstamp(Date::now());
          }
!         if (get_state() == S_OPERATIONAL)
          {
!             profile_enter(shift_to_prof);
              evs_log_info(I_STATE)
                  << " shift to GATHER when handling leave from "
!                 << msg.get_source() << " " << msg.get_source_view_id();
              gu_trace(shift_to(S_GATHER, true));
!             profile_leave(shift_to_prof);
          }
!         else if (get_state() == S_GATHER &&
!                  prev_safe_seq != input_map->get_safe_seq(node.get_index()))
          {
!             profile_enter(send_join_prof);
              gu_trace(send_join());
!             profile_leave(send_join_prof);
          }
      }
  }
--- 3583,3641 ----
  void gcomm::evs::Proto::handle_leave(const LeaveMessage& msg,
                                       NodeMap::iterator ii)
  {
!     assert(ii != known_.end());
!     assert(state() != S_CLOSED && state() != S_JOINING);
  
!     Node& node(NodeMap::value(ii));
      evs_log_debug(D_LEAVE_MSGS) << "leave message " << msg;
  
!     if (msg.source() != uuid() && node.is_inactive() == true)
      {
          evs_log_debug(D_LEAVE_MSGS) << "dropping leave from already inactive";
          return;
      }
      node.set_leave_message(&msg);
!     if (msg.source() == uuid())
      {
          // The last one to live, instant close. Otherwise continue
          // serving until it becomes apparent that others have
          // leave message.
!         if (current_view_.members().size() == 1)
          {
!             profile_enter(shift_to_prof_);
              gu_trace(shift_to(S_CLOSED));
!             profile_leave(shift_to_prof_);
          }
      }
      else
      {
!         if (msg.source_view_id()       != current_view_.id() ||
              is_msg_from_previous_view(msg) == true)
          {
              // Silent drop
              return;
          }
          node.set_operational(false);
!         const seqno_t prev_safe_seq(update_im_safe_seq(node.index(), msg.aru_seq()));
!         if (prev_safe_seq != input_map_->safe_seq(node.index()))
          {
!             node.set_tstamp(gu::datetime::Date::now());
          }
!         if (state() == S_OPERATIONAL)
          {
!             profile_enter(shift_to_prof_);
              evs_log_info(I_STATE)
                  << " shift to GATHER when handling leave from "
!                 << msg.source() << " " << msg.source_view_id();
              gu_trace(shift_to(S_GATHER, true));
!             profile_leave(shift_to_prof_);
          }
!         else if (state() == S_GATHER &&
!                  prev_safe_seq != input_map_->safe_seq(node.index()))
          {
!             profile_enter(send_join_prof_);
              gu_trace(send_join());
!             profile_leave(send_join_prof_);
          }
      }
  }
***************
*** 3615,3653 ****
                                         NodeMap::iterator ii)
  {
  
!     assert(ii != known.end());
!     assert(get_state() != S_CLOSED && get_state() != S_JOINING);
  
!     Node& inst(NodeMap::get_value(ii));
  
      evs_log_debug(D_INSTALL_MSGS) << "install msg " << msg;
  
!     if (get_state() == S_LEAVING)
      {
!         MessageNodeList::const_iterator mn_i = msg.get_node_list().find(get_uuid());
!         if (mn_i != msg.get_node_list().end())
          {
!             const MessageNode& mn(MessageNodeList::get_value(mn_i));
!             if (mn.get_operational() == false || mn.get_leaving() == true)
              {
!                 profile_enter(shift_to_prof);
                  gu_trace(shift_to(S_CLOSED));
!                 profile_leave(shift_to_prof);
              }
          }
          return;
      }
!     else if (get_state()           == S_OPERATIONAL &&
!              current_view.get_id() == msg.get_source_view_id())
      {
          evs_log_debug(D_INSTALL_MSGS)
              << "dropping install message in already installed view";
          return;
      }
!     else if (inst.get_operational() == false)
      {
          evs_log_debug(D_INSTALL_MSGS)
!             << "previously unoperatioal message source " << msg.get_source()
              << " discarding message";
          return;
      }
--- 3645,3683 ----
                                         NodeMap::iterator ii)
  {
  
!     assert(ii != known_.end());
!     assert(state() != S_CLOSED && state() != S_JOINING);
  
!     Node& inst(NodeMap::value(ii));
  
      evs_log_debug(D_INSTALL_MSGS) << "install msg " << msg;
  
!     if (state() == S_LEAVING)
      {
!         MessageNodeList::const_iterator mn_i = msg.node_list().find(uuid());
!         if (mn_i != msg.node_list().end())
          {
!             const MessageNode& mn(MessageNodeList::value(mn_i));
!             if (mn.operational() == false || mn.leaving() == true)
              {
!                 profile_enter(shift_to_prof_);
                  gu_trace(shift_to(S_CLOSED));
!                 profile_leave(shift_to_prof_);
              }
          }
          return;
      }
!     else if (state()           == S_OPERATIONAL &&
!              current_view_.id() == msg.source_view_id())
      {
          evs_log_debug(D_INSTALL_MSGS)
              << "dropping install message in already installed view";
          return;
      }
!     else if (inst.operational() == false)
      {
          evs_log_debug(D_INSTALL_MSGS)
!             << "previously unoperatioal message source " << msg.source()
              << " discarding message";
          return;
      }
***************
*** 3657,3729 ****
              << " dropping install message from previous view";
          return;
      }
!     else if (install_message != 0)
      {
          log_warn << self_string()
                   << " shift to GATHER due to duplicate install";
          gu_trace(shift_to(S_GATHER));
          return;
      }
!     else if (inst.get_installed() == true)
      {
          log_warn << self_string()
                   << " shift to GATHER due to inconsistent state";
!         profile_enter(shift_to_prof);
          gu_trace(shift_to(S_GATHER));
!         profile_leave(shift_to_prof);
          return;
      }
!     else if (is_representative(msg.get_source()) == false)
      {
          log_warn << self_string()
!                  << " source " << msg.get_source()
                   << " is not supposed to be representative";
          // Isolate node from my group
!         // set_inactive(msg.get_source());
!         profile_enter(shift_to_prof);
          gu_trace(shift_to(S_GATHER));
!         profile_leave(shift_to_prof);
          return;
      }
  
!     assert(install_message == 0);
  
      bool ic;
!     if ((ic = consensus.is_consistent(msg)) == false)
      {
!         gcomm_assert(msg.get_source() != get_uuid());
          // Construct join from install message so that the most recent
          // information from representative is updated to local state.
          const MessageNode& mn(
!             MessageNodeList::get_value(
!                 msg.get_node_list().find_checked(msg.get_source())));
!         JoinMessage jm(msg.get_version(),
!                        msg.get_source(),
!                        mn.get_view_id(),
!                        msg.get_seq(),
!                        msg.get_aru_seq(),
!                        msg.get_fifo_seq(),
!                        msg.get_node_list());
          handle_join(jm, ii);
!         ic = consensus.is_consistent(msg);
      }
  
      if (ic == true)
      {
!         inst.set_tstamp(Date::now());
!         install_message = new InstallMessage(msg);
!         profile_enter(send_gap_prof);
!         gu_trace(send_gap(UUID::nil(), install_message->get_install_view_id(),
                            Range(), true));
!         profile_leave(send_gap_prof);
      }
      else
      {
          evs_log_debug(D_INSTALL_MSGS)
              << "install message " << msg
              << " not consistent with state " << *this;
!         profile_enter(shift_to_prof);
          gu_trace(shift_to(S_GATHER, true));
!         profile_leave(shift_to_prof);
      }
  }
--- 3687,3759 ----
              << " dropping install message from previous view";
          return;
      }
!     else if (install_message_ != 0)
      {
          log_warn << self_string()
                   << " shift to GATHER due to duplicate install";
          gu_trace(shift_to(S_GATHER));
          return;
      }
!     else if (inst.installed() == true)
      {
          log_warn << self_string()
                   << " shift to GATHER due to inconsistent state";
!         profile_enter(shift_to_prof_);
          gu_trace(shift_to(S_GATHER));
!         profile_leave(shift_to_prof_);
          return;
      }
!     else if (is_representative(msg.source()) == false)
      {
          log_warn << self_string()
!                  << " source " << msg.source()
                   << " is not supposed to be representative";
          // Isolate node from my group
!         // set_inactive(msg.source());
!         profile_enter(shift_to_prof_);
          gu_trace(shift_to(S_GATHER));
!         profile_leave(shift_to_prof_);
          return;
      }
  
!     assert(install_message_ == 0);
  
      bool ic;
!     if ((ic = consensus_.is_consistent(msg)) == false)
      {
!         gcomm_assert(msg.source() != uuid());
          // Construct join from install message so that the most recent
          // information from representative is updated to local state.
          const MessageNode& mn(
!             MessageNodeList::value(
!                 msg.node_list().find_checked(msg.source())));
!         JoinMessage jm(msg.version(),
!                        msg.source(),
!                        mn.view_id(),
!                        msg.seq(),
!                        msg.aru_seq(),
!                        msg.fifo_seq(),
!                        msg.node_list());
          handle_join(jm, ii);
!         ic = consensus_.is_consistent(msg);
      }
  
      if (ic == true)
      {
!         inst.set_tstamp(gu::datetime::Date::now());
!         install_message_ = new InstallMessage(msg);
!         profile_enter(send_gap_prof_);
!         gu_trace(send_gap(UUID::nil(), install_message_->install_view_id(),
                            Range(), true));
!         profile_leave(send_gap_prof_);
      }
      else
      {
          evs_log_debug(D_INSTALL_MSGS)
              << "install message " << msg
              << " not consistent with state " << *this;
!         profile_enter(shift_to_prof_);
          gu_trace(shift_to(S_GATHER, true));
!         profile_leave(shift_to_prof_);
      }
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_proto.hpp 2.x/gcomm/src/evs_proto.hpp
*** galera-23.2.2-src/gcomm/src/evs_proto.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_proto.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 90,132 ****
      /*!
       * Default constructor.
       */
!     Proto(gu::Config& conf,
!           const UUID& my_uuid_,
            const gu::URI& uri = gu::URI("evs://"),
!           const size_t mtu_ = std::numeric_limits<size_t>::max());
      ~Proto();
  
!     const UUID& get_uuid() const { return my_uuid; }
  
      std::string self_string() const
      {
          std::ostringstream os;
!         os << "evs::proto(" << get_uuid() << ", " << to_string(get_state())
!            << ", " << current_view.get_id() << ")";
          return os.str();
      }
  
!     State get_state() const { return state; }
  
!     size_t get_known_size() const { return known.size(); }
  
!     bool is_output_empty() const { return output.empty(); }
  
!     std::string get_stats() const;
      void reset_stats();
  
      bool is_flow_control(const seqno_t, const seqno_t win) const;
!     int send_user(gu::Datagram&,
                    uint8_t,
                    Order,
                    seqno_t,
                    seqno_t,
                    size_t n_aggregated = 1);
!     size_t get_mtu() const { return mtu; }
      size_t aggregate_len() const;
      int send_user(const seqno_t);
      void complete_user(const seqno_t);
!     int send_delegate(gu::Datagram&);
      void send_gap(const UUID&, const ViewId&, const Range, bool commit = false);
      const JoinMessage& create_join();
      void send_join(bool tval = true);
--- 90,132 ----
      /*!
       * Default constructor.
       */
!     Proto(gu::Config&    conf,
!           const UUID&    my_uuid,
            const gu::URI& uri = gu::URI("evs://"),
!           const size_t   mtu = std::numeric_limits<size_t>::max());
      ~Proto();
  
!     const UUID& uuid() const { return my_uuid_; }
  
      std::string self_string() const
      {
          std::ostringstream os;
!         os << "evs::proto(" << uuid() << ", " << to_string(state())
!            << ", " << current_view_.id() << ")";
          return os.str();
      }
  
!     State state() const { return state_; }
  
!     size_t known_size() const { return known_.size(); }
  
!     bool is_output_empty() const { return output_.empty(); }
  
!     std::string stats() const;
      void reset_stats();
  
      bool is_flow_control(const seqno_t, const seqno_t win) const;
!     int send_user(Datagram&,
                    uint8_t,
                    Order,
                    seqno_t,
                    seqno_t,
                    size_t n_aggregated = 1);
!     size_t mtu() const { return mtu_; }
      size_t aggregate_len() const;
      int send_user(const seqno_t);
      void complete_user(const seqno_t);
!     int send_delegate(Datagram&);
      void send_gap(const UUID&, const ViewId&, const Range, bool commit = false);
      const JoinMessage& create_join();
      void send_join(bool tval = true);
***************
*** 154,160 ****
      void deliver_finish(const InputMapMsg&);
      void deliver();
      void deliver_local(bool trans = false);
!     void deliver_causal(uint8_t user_type, seqno_t seqno, const gu::Datagram&);
      void validate_trans_msg(const UserMessage&);
      void deliver_trans();
      void deliver_reg_view();
--- 153,159 ----
      void deliver_finish(const InputMapMsg&);
      void deliver();
      void deliver_local(bool trans = false);
!     void deliver_causal(uint8_t user_type, seqno_t seqno, const Datagram&);
      void validate_trans_msg(const UserMessage&);
      void deliver_trans();
      void deliver_reg_view();
***************
*** 197,206 ****
      void handle_foreign(const Message&);
      void handle_user(const UserMessage&,
                       NodeMap::iterator,
!                      const gu::Datagram&);
      void handle_delegate(const DelegateMessage&,
                           NodeMap::iterator,
!                          const gu::Datagram&);
      void handle_gap(const GapMessage&, NodeMap::iterator);
      void handle_join(const JoinMessage&, NodeMap::iterator);
      void handle_leave(const LeaveMessage&, NodeMap::iterator);
--- 196,205 ----
      void handle_foreign(const Message&);
      void handle_user(const UserMessage&,
                       NodeMap::iterator,
!                      const Datagram&);
      void handle_delegate(const DelegateMessage&,
                           NodeMap::iterator,
!                          const Datagram&);
      void handle_gap(const GapMessage&, NodeMap::iterator);
      void handle_join(const JoinMessage&, NodeMap::iterator);
      void handle_leave(const LeaveMessage&, NodeMap::iterator);
***************
*** 208,220 ****
      void populate_node_list(MessageNodeList*) const;
  public:
      static size_t unserialize_message(const UUID&,
!                                       const gu::Datagram&,
                                        Message*);
      void handle_msg(const Message& msg,
!                     const gu::Datagram& dg = gu::Datagram());
      // Protolay
!     void handle_up(const void*, const gu::Datagram&, const ProtoUpMeta&);
!     int handle_down(gu::Datagram& wb, const ProtoDownMeta& dm);
      void handle_stable_view(const View& view)
      {
          set_stable_view(view);
--- 207,219 ----
      void populate_node_list(MessageNodeList*) const;
  public:
      static size_t unserialize_message(const UUID&,
!                                       const Datagram&,
                                        Message*);
      void handle_msg(const Message& msg,
!                     const Datagram& dg = Datagram());
      // Protolay
!     void handle_up(const void*, const Datagram&, const ProtoUpMeta&);
!     int handle_down(Datagram& wb, const ProtoDownMeta& dm);
      void handle_stable_view(const View& view)
      {
          set_stable_view(view);
***************
*** 255,268 ****
      class TimerList :
          public  MultiMap<gu::datetime::Date, Timer> { };
  private:
!     TimerList timers;
  public:
      // These need currently to be public for unit tests
      void handle_inactivity_timer();
      void handle_retrans_timer();
      void handle_install_timer();
      void handle_stats_timer();
!     gu::datetime::Date get_next_expiration(const Timer) const;
      void reset_timers();
      gu::datetime::Date handle_timers();
  
--- 254,267 ----
      class TimerList :
          public  MultiMap<gu::datetime::Date, Timer> { };
  private:
!     TimerList timers_;
  public:
      // These need currently to be public for unit tests
      void handle_inactivity_timer();
      void handle_retrans_timer();
      void handle_install_timer();
      void handle_stats_timer();
!     gu::datetime::Date next_expiration(const Timer) const;
      void reset_timers();
      gu::datetime::Date handle_timers();
  
***************
*** 298,364 ****
      };
  private:
  
!     int version;
      static const int max_version_ = GCOMM_EVS_MAX_VERSION;
!     int debug_mask;
!     int info_mask;
!     gu::datetime::Date last_stats_report;
!     bool collect_stats;
!     Histogram hs_agreed;
!     Histogram hs_safe;
!     Histogram hs_local_causal;
!     long long int send_queue_s;
!     long long int n_send_queue_s;
!     std::vector<long long int> sent_msgs;
!     long long int retrans_msgs;
!     long long int recovered_msgs;
!     std::vector<long long int> recvd_msgs;
!     std::vector<long long int> delivered_msgs;
!     prof::Profile send_user_prof;
!     prof::Profile send_gap_prof;
!     prof::Profile send_join_prof;
!     prof::Profile send_install_prof;
!     prof::Profile send_leave_prof;
!     prof::Profile consistent_prof;
!     prof::Profile consensus_prof;
!     prof::Profile shift_to_prof;
!     prof::Profile input_map_prof;
!     prof::Profile delivery_prof;
!     bool delivering;
!     UUID my_uuid;
      //
      // Known instances
!     NodeMap known;
!     NodeMap::iterator self_i;
      //
!     gu::datetime::Period view_forget_timeout;
!     gu::datetime::Period inactive_timeout;
!     gu::datetime::Period suspect_timeout;
!     gu::datetime::Period inactive_check_period;
!     gu::datetime::Period retrans_period;
!     gu::datetime::Period install_timeout;
!     gu::datetime::Period join_retrans_period;
!     gu::datetime::Period stats_report_period;
!     gu::datetime::Period causal_keepalive_period;
  
!     gu::datetime::Date last_inactive_check;
!     gu::datetime::Date last_causal_keepalive;
  
      // Current view id
      // ViewId current_view;
!     View current_view;
!     View previous_view;
!     std::list<std::pair<ViewId, gu::datetime::Date> > previous_views;
  
      // Map containing received messages and aru/safe seqnos
!     InputMap* input_map;
      // Helper container for local causal messages
      class CausalMessage
      {
      public:
          CausalMessage(uint8_t             user_type,
                        seqno_t             seqno,
!                       const gu::Datagram& datagram)
              :
              user_type_(user_type),
              seqno_    (seqno    ),
--- 297,363 ----
      };
  private:
  
!     int version_;
      static const int max_version_ = GCOMM_EVS_MAX_VERSION;
!     int debug_mask_;
!     int info_mask_;
!     gu::datetime::Date last_stats_report_;
!     bool collect_stats_;
!     Histogram hs_agreed_;
!     Histogram hs_safe_;
!     Histogram hs_local_causal_;
!     long long int send_queue_s_;
!     long long int n_send_queue_s_;
!     std::vector<long long int> sent_msgs_;
!     long long int retrans_msgs_;
!     long long int recovered_msgs_;
!     std::vector<long long int> recvd_msgs_;
!     std::vector<long long int> delivered_msgs_;
!     prof::Profile send_user_prof_;
!     prof::Profile send_gap_prof_;
!     prof::Profile send_join_prof_;
!     prof::Profile send_install_prof_;
!     prof::Profile send_leave_prof_;
!     prof::Profile consistent_prof_;
!     prof::Profile consensus_prof_;
!     prof::Profile shift_to_prof_;
!     prof::Profile input_map_prof_;
!     prof::Profile delivery_prof_;
!     bool delivering_;
!     UUID my_uuid_;
      //
      // Known instances
!     NodeMap known_;
!     NodeMap::iterator self_i_;
      //
!     gu::datetime::Period view_forget_timeout_;
!     gu::datetime::Period inactive_timeout_;
!     gu::datetime::Period suspect_timeout_;
!     gu::datetime::Period inactive_check_period_;
!     gu::datetime::Period retrans_period_;
!     gu::datetime::Period install_timeout_;
!     gu::datetime::Period join_retrans_period_;
!     gu::datetime::Period stats_report_period_;
!     gu::datetime::Period causal_keepalive_period_;
  
!     gu::datetime::Date last_inactive_check_;
!     gu::datetime::Date last_causal_keepalive_;
  
      // Current view id
      // ViewId current_view;
!     View current_view_;
!     View previous_view_;
!     std::list<std::pair<ViewId, gu::datetime::Date> > previous_views_;
  
      // Map containing received messages and aru/safe seqnos
!     InputMap* input_map_;
      // Helper container for local causal messages
      class CausalMessage
      {
      public:
          CausalMessage(uint8_t             user_type,
                        seqno_t             seqno,
!                       const Datagram& datagram)
              :
              user_type_(user_type),
              seqno_    (seqno    ),
***************
*** 367,410 ****
          { }
          uint8_t             user_type() const { return user_type_; }
          seqno_t             seqno()     const { return seqno_    ; }
!         const gu::Datagram& datagram()  const { return datagram_ ; }
          const gu::datetime::Date& tstamp()    const { return tstamp_   ; }
      private:
!         uint8_t      user_type_;
!         seqno_t      seqno_;
!         gu::Datagram datagram_;
!         gu::datetime::Date     tstamp_;
      };
      // Queue containing local causal messages
      std::deque<CausalMessage> causal_queue_;
      // Consensus module
!     Consensus consensus;
      // Last received install message
!     InstallMessage* install_message;
      // Install attempt counter
!     uint32_t attempt_seq;
      // Install timeout counting
!     int max_install_timeouts;
!     int install_timeout_count;
      // Sequence number to maintain membership message FIFO order
!     int64_t fifo_seq;
      // Last sent seq
!     seqno_t last_sent;
      // Protocol send window size
!     seqno_t send_window;
      // User send window size
!     seqno_t user_send_window;
      // Output message queue
!     std::deque<std::pair<gu::Datagram, ProtoDownMeta> > output;
      std::vector<gu::byte_t> send_buf_;
!     uint32_t max_output_size;
!     size_t mtu;
!     bool use_aggregate;
!     bool self_loopback;
!     State state;
!     int shift_to_rfcnt;
! 
  
      Proto(const Proto&);
      void operator=(const Proto&);
  };
--- 366,409 ----
          { }
          uint8_t             user_type() const { return user_type_; }
          seqno_t             seqno()     const { return seqno_    ; }
!         const Datagram& datagram()  const { return datagram_ ; }
          const gu::datetime::Date& tstamp()    const { return tstamp_   ; }
      private:
!         uint8_t            user_type_;
!         seqno_t            seqno_;
!         Datagram       datagram_;
!         gu::datetime::Date tstamp_;
      };
      // Queue containing local causal messages
      std::deque<CausalMessage> causal_queue_;
      // Consensus module
!     Consensus consensus_;
      // Last received install message
!     InstallMessage* install_message_;
      // Install attempt counter
!     uint32_t attempt_seq_;
      // Install timeout counting
!     int max_install_timeouts_;
!     int install_timeout_count_;
      // Sequence number to maintain membership message FIFO order
!     int64_t fifo_seq_;
      // Last sent seq
!     seqno_t last_sent_;
      // Protocol send window size
!     seqno_t send_window_;
      // User send window size
!     seqno_t user_send_window_;
      // Output message queue
!     std::deque<std::pair<Datagram, ProtoDownMeta> > output_;
      std::vector<gu::byte_t> send_buf_;
!     uint32_t max_output_size_;
!     size_t mtu_;
!     bool use_aggregate_;
!     bool self_loopback_;
!     State state_;
!     int shift_to_rfcnt_;
  
+     // non-copyable
      Proto(const Proto&);
      void operator=(const Proto&);
  };
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/evs_seqno.hpp 2.x/gcomm/src/evs_seqno.hpp
*** galera-23.2.2-src/gcomm/src/evs_seqno.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/evs_seqno.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 18,24 ****
      namespace evs
      {
          typedef int64_t seqno_t;
!         
          class Range;
          std::ostream& operator<<(std::ostream&, const Range&);
      }
--- 18,24 ----
      namespace evs
      {
          typedef int64_t seqno_t;
! 
          class Range;
          std::ostream& operator<<(std::ostream&, const Range&);
      }
***************
*** 35,60 ****
          lu_(lu),
          hs_(hs)
      {}
!     seqno_t get_lu() const { return lu_; }
!     seqno_t get_hs() const { return hs_; }
!     
      void set_lu(const seqno_t s) { lu_ = s; }
      void set_hs(const seqno_t s) { hs_ = s; }
!     
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
      {
          gu_trace(offset = gu::serialize8(lu_, buf, buflen, offset));
          gu_trace(offset = gu::serialize8(hs_, buf, buflen, offset));
          return offset;
      }
!     
      size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
      {
          gu_trace(offset = gu::unserialize8(buf, buflen, offset, lu_));
          gu_trace(offset = gu::unserialize8(buf, buflen, offset, hs_));
          return offset;
      }
!     
      static size_t serial_size()
      {
          return 2 * sizeof(seqno_t);
--- 35,60 ----
          lu_(lu),
          hs_(hs)
      {}
!     seqno_t lu() const { return lu_; }
!     seqno_t hs() const { return hs_; }
! 
      void set_lu(const seqno_t s) { lu_ = s; }
      void set_hs(const seqno_t s) { hs_ = s; }
! 
      size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) const
      {
          gu_trace(offset = gu::serialize8(lu_, buf, buflen, offset));
          gu_trace(offset = gu::serialize8(hs_, buf, buflen, offset));
          return offset;
      }
! 
      size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
      {
          gu_trace(offset = gu::unserialize8(buf, buflen, offset, lu_));
          gu_trace(offset = gu::unserialize8(buf, buflen, offset, hs_));
          return offset;
      }
! 
      static size_t serial_size()
      {
          return 2 * sizeof(seqno_t);
***************
*** 72,78 ****
  
  inline std::ostream& gcomm::evs::operator<<(std::ostream& os, const gcomm::evs::Range& r)
  {
!     return (os << "[" << r.get_lu() << "," << r.get_hs() << "]");
  }
  
  #endif // EVS_SEQNO_HPP
--- 72,78 ----
  
  inline std::ostream& gcomm::evs::operator<<(std::ostream& os, const gcomm::evs::Range& r)
  {
!     return (os << "[" << r.lu() << "," << r.hs() << "]");
  }
  
  #endif // EVS_SEQNO_HPP
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/conf.hpp 2.x/gcomm/src/gcomm/conf.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/conf.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/conf.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 401,406 ****
--- 401,411 ----
           */
          static std::string const PcWaitPrimTimeout;
  
+         /*!
+          * @brief Node weight in prim comp voting
+          */
+         static std::string const PcWeight;
+ 
      };
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/datagram.hpp 2.x/gcomm/src/gcomm/datagram.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/datagram.hpp	1970-01-01 08:00:00.000000000 +0800
--- 2.x/gcomm/src/gcomm/datagram.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,296 ----
+ /*
+  * Copyright (C) 2010-2012 Codership Oy <info@codership.com>
+  */
+ 
+ #ifndef GCOMM_DATAGRAM_HPP
+ #define GCOMM_DATAGRAM_HPP
+ 
+ #include "gu_buffer.hpp"
+ #include "gu_serialize.hpp"
+ #include "gu_utils.hpp"
+ #include <boost/crc.hpp>
+ 
+ #include <limits>
+ 
+ #include <cstring>
+ #include <stdint.h>
+ 
+ namespace gcomm
+ {
+ 
+     //!
+     // @class NetHeader
+     //
+     // @brief Header for datagrams sent over network
+     //
+     // Header structure is the following (MSB first)
+     //
+     // | version(4) | reserved(3) | F_CRC(1) | len(24) |
+     // |                   CRC(32)                     |
+     //
+     class NetHeader
+     {
+     public:
+ 
+         NetHeader()
+             :
+             len_(),
+             crc32_()
+         { }
+ 
+         NetHeader(uint32_t len, int version)
+             :
+             len_(len),
+             crc32_(0)
+         {
+             if (len > len_mask_)
+                 gu_throw_error(EINVAL) << "msg too long " << len_;
+             len_ |= (static_cast<uint32_t>(version) << version_shift_);
+         }
+ 
+         uint32_t len() const { return (len_ & len_mask_); }
+ 
+         void set_crc32(uint32_t crc32)
+         {
+             crc32_ = crc32;
+             len_ |= F_CRC32;
+         }
+ 
+         bool has_crc32() const { return (len_ & F_CRC32); }
+         uint32_t crc32() const { return crc32_; }
+         int version() const { return ((len_ & version_mask_) >> version_shift_); }
+         friend size_t serialize(const NetHeader& hdr, gu::byte_t* buf, size_t buflen,
+                                 size_t offset);
+         friend size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset,
+                                   NetHeader& hdr);
+         friend size_t serial_size(const NetHeader& hdr);
+         static const size_t serial_size_ = 8;
+ 
+     private:
+         static const uint32_t len_mask_      = 0x00ffffff;
+         static const uint32_t flags_mask_    = 0x0f000000;
+         static const uint32_t flags_shift_   = 24;
+         static const uint32_t version_mask_  = 0xf0000000;
+         static const uint32_t version_shift_ = 28;
+         enum
+         {
+             F_CRC32 = 1 << 24
+         };
+         uint32_t len_;
+         uint32_t crc32_;
+     };
+ 
+     inline size_t serialize(const NetHeader& hdr, gu::byte_t* buf,
+                             size_t buflen, size_t offset)
+     {
+         offset = gu::serialize4(hdr.len_, buf, buflen, offset);
+         offset = gu::serialize4(hdr.crc32_, buf, buflen, offset);
+         return offset;
+     }
+ 
+     inline size_t unserialize(const gu::byte_t* buf, size_t buflen,
+                               size_t offset, NetHeader& hdr)
+     {
+         offset = gu::unserialize4(buf, buflen, offset, hdr.len_);
+         offset = gu::unserialize4(buf, buflen, offset, hdr.crc32_);
+         switch (hdr.version())
+         {
+         case 0:
+             if ((hdr.len_ & NetHeader::flags_mask_) & ~NetHeader::F_CRC32)
+             {
+                 gu_throw_error(EPROTO)
+                     << "invalid flags "
+                     << ((hdr.len_ & NetHeader::flags_mask_) >>
+                         NetHeader::flags_shift_);
+             }
+             break;
+         default:
+             gu_throw_error(EPROTO) << "invalid protocol version "
+                                    << hdr.version();
+             throw; // keep compiler happy
+         }
+ 
+         return offset;
+     }
+ 
+     inline size_t serial_size(const NetHeader& hdr)
+     {
+         return NetHeader::serial_size_;
+     }
+ 
+     /*!
+      * @brief  Datagram container
+      *
+      * Datagram class provides consistent interface for managing
+      * datagrams/byte buffers.
+      */
+     class Datagram
+     {
+     public:
+         Datagram()
+             :
+             header_       (),
+             header_offset_(header_size_),
+             payload_      (new gu::Buffer()),
+             offset_       (0)
+         { }
+         /*!
+          * @brief Construct new datagram from byte buffer
+          *
+          * @param[in] buf Const pointer to data buffer
+          * @param[in] buflen Length of data buffer
+          *
+          * @throws std::bad_alloc
+          */
+ 
+         Datagram(const gu::Buffer& buf, size_t offset = 0)
+             :
+             header_       (),
+             header_offset_(header_size_),
+             payload_      (new gu::Buffer(buf)),
+             offset_       (offset)
+         {
+             assert(offset_ <= payload_->size());
+         }
+ 
+         Datagram(const gu::SharedBuffer& buf, size_t offset = 0)
+             :
+             header_       (),
+             header_offset_(header_size_),
+             payload_      (buf),
+             offset_       (offset)
+         {
+             assert(offset_ <= payload_->size());
+         }
+ 
+         /*!
+          * @brief Copy constructor.
+          *
+          * @note Only for normalized datagrams.
+          *
+          * @param[in] dgram Datagram to make copy from
+          * @param[in] off
+          * @throws std::bad_alloc
+          */
+         Datagram(const Datagram& dgram,
+                  size_t off = std::numeric_limits<size_t>::max()) :
+             // header_(dgram.header_),
+             header_offset_(dgram.header_offset_),
+             payload_(dgram.payload_),
+             offset_(off == std::numeric_limits<size_t>::max() ? dgram.offset_ : off)
+         {
+             assert(offset_ <= dgram.len());
+             memcpy(header_ + header_offset_,
+                    dgram.header_ + dgram.header_offset(),
+                    dgram.header_len());
+         }
+ 
+         /*!
+          * @brief Destruct datagram
+          */
+         ~Datagram() { }
+ 
+         void normalize()
+         {
+             const gu::SharedBuffer old_payload(payload_);
+             payload_ = gu::SharedBuffer(new gu::Buffer);
+             payload_->reserve(header_len() + old_payload->size() - offset_);
+ 
+             if (header_len() > offset_)
+             {
+                 payload_->insert(payload_->end(),
+                                  header_ + header_offset_ + offset_,
+                                  header_ + header_size_);
+                 offset_ = 0;
+             }
+             else
+             {
+                 offset_ -= header_len();
+             }
+             header_offset_ = header_size_;
+             payload_->insert(payload_->end(), old_payload->begin() + offset_,
+                              old_payload->end());
+             offset_ = 0;
+         }
+ 
+         gu::byte_t* header() { return header_; }
+         const gu::byte_t* header() const { return header_; }
+         size_t header_size() const { return header_size_; }
+         size_t header_len() const { return (header_size_ - header_offset_); }
+         size_t header_offset() const { return header_offset_; }
+         void set_header_offset(const size_t off)
+         {
+             // assert(off <= header_size_);
+             if (off > header_size_) gu_throw_fatal << "out of hdrspace";
+             header_offset_ = off;
+         }
+ 
+         const gu::Buffer& payload() const
+         {
+             assert(payload_ != 0);
+             return *payload_;
+         }
+         gu::Buffer& payload()
+         {
+             assert(payload_ != 0);
+             return *payload_;
+         }
+         size_t len() const { return (header_size_ - header_offset_ + payload_->size()); }
+         size_t offset() const { return offset_; }
+ 
+     private:
+         friend uint16_t crc16(const Datagram&, size_t);
+         friend uint32_t crc32(const Datagram&, size_t);
+ 
+         static const size_t header_size_ = 128;
+         gu::byte_t          header_[header_size_];
+         size_t              header_offset_;
+         gu::SharedBuffer    payload_;
+         size_t              offset_;
+     };
+ 
+     inline uint16_t crc16(const Datagram& dg, size_t offset = 0)
+     {
+         boost::crc_16_type crc;
+         assert(offset < dg.len());
+         gu::byte_t lenb[4];
+         gu::serialize4(static_cast<int32_t>(dg.len() - offset), lenb, sizeof(lenb), 0);
+         crc.process_block(lenb, lenb + sizeof(lenb));
+         if (offset < dg.header_len())
+         {
+             crc.process_block(dg.header_ + dg.header_offset_ + offset,
+                               dg.header_ + dg.header_size_);
+             offset = 0;
+         }
+         else
+         {
+             offset -= dg.header_len();
+         }
+         crc.process_block(&(*dg.payload_)[0] + offset,
+                           &(*dg.payload_)[0] + dg.payload_->size());
+         return crc.checksum();
+     }
+ 
+     inline uint32_t crc32(const Datagram& dg, size_t offset = 0)
+     {
+         boost::crc_32_type crc;
+         gu::byte_t lenb[4];
+         gu::serialize4(static_cast<int32_t>(dg.len() - offset), lenb, sizeof(lenb), 0);
+         crc.process_block(lenb, lenb + sizeof(lenb));
+         if (offset < dg.header_len())
+         {
+             crc.process_block(dg.header_ + dg.header_offset_ + offset,
+                               dg.header_ + dg.header_size_);
+             offset = 0;
+         }
+         else
+         {
+             offset -= dg.header_len();
+         }
+         crc.process_block(&(*dg.payload_)[0] + offset,
+                           &(*dg.payload_)[0] + dg.payload_->size());
+         return crc.checksum();
+     }
+ }
+ 
+ #endif // GCOMM_DATAGRAM_HPP
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/map.hpp 2.x/gcomm/src/gcomm/map.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/map.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/map.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 41,104 ****
  
      protected:
  
!         MapType map;
      public:
  
!         MapBase() : map() {}
  
          virtual ~MapBase() {}
  
!         iterator begin()          { return map.begin(); }
  
!         iterator end()            { return map.end();   }
  
!         iterator find(const K& k) { return map.find(k); }
  
          iterator find_checked(const K& k)
          {
!             iterator ret = map.find(k);
!             if (ret == map.end())
              {
                  gu_throw_fatal << "element " << k << " not found";
              }
              return ret;
          }
  
!         iterator lower_bound(const K& k) { return map.lower_bound(k); }
  
!         const_iterator begin()          const { return map.begin(); }
  
!         const_iterator end()            const { return map.end();   }
  
!         const_reverse_iterator rbegin()         const { return map.rbegin(); }
  
!         const_reverse_iterator rend()           const { return map.rend(); }
  
!         const_iterator find(const K& k) const { return map.find(k); }
  
          const_iterator find_checked(const K& k) const
          {
!             const_iterator ret = map.find(k);
!             if (ret == map.end())
              {
                  gu_throw_fatal << "element " << k << " not found";
              }
              return ret;
          }
  
!         mapped_type& operator[](const key_type& k) { return map[k]; }
  
!         void erase(iterator i) { map.erase(i); }
  
!         void erase(iterator i, iterator j) { map.erase(i, j); }
  
!         void erase(const K& k) { map.erase(k); }
  
!         void clear()           { map.clear(); }
  
!         size_t size() const    { return map.size(); }
  
!         bool empty() const     { return map.empty(); }
  
          size_t serialize(gu::byte_t* const buf,
                           size_t  const buflen,
--- 41,104 ----
  
      protected:
  
!         MapType map_;
      public:
  
!         MapBase() : map_() {}
  
          virtual ~MapBase() {}
  
!         iterator begin()          { return map_.begin(); }
  
!         iterator end()            { return map_.end();   }
  
!         iterator find(const K& k) { return map_.find(k); }
  
          iterator find_checked(const K& k)
          {
!             iterator ret = map_.find(k);
!             if (ret == map_.end())
              {
                  gu_throw_fatal << "element " << k << " not found";
              }
              return ret;
          }
  
!         iterator lower_bound(const K& k) { return map_.lower_bound(k); }
  
!         const_iterator begin()          const { return map_.begin(); }
  
!         const_iterator end()            const { return map_.end();   }
  
!         const_reverse_iterator rbegin()         const { return map_.rbegin(); }
  
!         const_reverse_iterator rend()           const { return map_.rend(); }
  
!         const_iterator find(const K& k) const { return map_.find(k); }
  
          const_iterator find_checked(const K& k) const
          {
!             const_iterator ret = map_.find(k);
!             if (ret == map_.end())
              {
                  gu_throw_fatal << "element " << k << " not found";
              }
              return ret;
          }
  
!         mapped_type& operator[](const key_type& k) { return map_[k]; }
  
!         void erase(iterator i) { map_.erase(i); }
  
!         void erase(iterator i, iterator j) { map_.erase(i, j); }
  
!         void erase(const K& k) { map_.erase(k); }
  
!         void clear()           { map_.clear(); }
  
!         size_t size() const    { return map_.size(); }
  
!         bool empty() const     { return map_.empty(); }
  
          size_t serialize(gu::byte_t* const buf,
                           size_t  const buflen,
***************
*** 107,116 ****
          {
              gu_trace(offset = gu::serialize4(
                           static_cast<uint32_t>(size()), buf, buflen, offset));
!             for (const_iterator i = map.begin(); i != map.end(); ++i)
              {
!                 gu_trace(offset = get_key(i).serialize(buf, buflen, offset));
!                 gu_trace(offset = get_value(i).serialize(buf, buflen, offset));
              }
              return offset;
          }
--- 107,116 ----
          {
              gu_trace(offset = gu::serialize4(
                           static_cast<uint32_t>(size()), buf, buflen, offset));
!             for (const_iterator i = map_.begin(); i != map_.end(); ++i)
              {
!                 gu_trace(offset = key(i).serialize(buf, buflen, offset));
!                 gu_trace(offset = value(i).serialize(buf, buflen, offset));
              }
              return offset;
          }
***************
*** 122,128 ****
          {
              uint32_t len;
              // Clear map in case this object is reused
!             map.clear();
  
              gu_trace(offset = gu::unserialize4(buf, buflen, offset, len));;
  
--- 122,128 ----
          {
              uint32_t len;
              // Clear map in case this object is reused
!             map_.clear();
  
              gu_trace(offset = gu::unserialize4(buf, buflen, offset, len));;
  
***************
*** 132,138 ****
                  V v;
                  gu_trace(offset = k.unserialize(buf, buflen, offset));
                  gu_trace(offset = v.unserialize(buf, buflen, offset));
!                 if (map.insert(std::make_pair(k, v)).second == false)
                  {
                      gu_throw_fatal << "Failed to unserialize map";
                  }
--- 132,138 ----
                  V v;
                  gu_trace(offset = k.unserialize(buf, buflen, offset));
                  gu_trace(offset = v.unserialize(buf, buflen, offset));
!                 if (map_.insert(std::make_pair(k, v)).second == false)
                  {
                      gu_throw_fatal << "Failed to unserialize map";
                  }
***************
*** 147,191 ****
  
          bool operator==(const MapBase& other) const
          {
!             return (map == other.map);
          }
  
          bool operator!=(const MapBase& other) const
          {
!             return !(map == other.map);
          }
  
!         static const K& get_key(const_iterator i)
          {
              return i->first;
          }
  
!         static const K& get_key(iterator i)
          {
              return i->first;
          }
  
!         static const V& get_value(const_iterator i)
          {
              return i->second;
          }
  
!         static V& get_value(iterator i)
          {
              return i->second;
          }
  
!         static const K& get_key(const value_type& vt)
          {
              return vt.first;
          }
  
!         static V& get_value(value_type& vt)
          {
              return vt.second;
          }
  
!         static const V& get_value(const value_type& vt)
          {
              return vt.second;
          }
--- 147,191 ----
  
          bool operator==(const MapBase& other) const
          {
!             return (map_ == other.map_);
          }
  
          bool operator!=(const MapBase& other) const
          {
!             return !(map_ == other.map_);
          }
  
!         static const K& key(const_iterator i)
          {
              return i->first;
          }
  
!         static const K& key(iterator i)
          {
              return i->first;
          }
  
!         static const V& value(const_iterator i)
          {
              return i->second;
          }
  
!         static V& value(iterator i)
          {
              return i->second;
          }
  
!         static const K& key(const value_type& vt)
          {
              return vt.first;
          }
  
!         static V& value(value_type& vt)
          {
              return vt.second;
          }
  
!         static const V& value(const value_type& vt)
          {
              return vt.second;
          }
***************
*** 215,231 ****
          typedef typename MapBase<K, V, C>::iterator iterator;
          std::pair<iterator, bool> insert(const std::pair<K, V>& p)
          {
!             return MapBase<K, V, C>::map.insert(p);
          }
  
          iterator insert_unique(const typename MapBase<K, V, C>::value_type& p)
          {
!             std::pair<iterator, bool> ret = MapBase<K, V, C>::map.insert(p);
              if (false == ret.second)
              {
                  gu_throw_fatal << "duplicate entry "
!                                << "key=" << get_key(p) << " "
!                                << "value=" << get_value(p) << " "
                                 << "map=" << *this;
              }
              return ret.first;
--- 215,231 ----
          typedef typename MapBase<K, V, C>::iterator iterator;
          std::pair<iterator, bool> insert(const std::pair<K, V>& p)
          {
!             return MapBase<K, V, C>::map_.insert(p);
          }
  
          iterator insert_unique(const typename MapBase<K, V, C>::value_type& p)
          {
!             std::pair<iterator, bool> ret = MapBase<K, V, C>::map_.insert(p);
              if (false == ret.second)
              {
                  gu_throw_fatal << "duplicate entry "
!                                << "key=" << MapBase<K, V, C>::key(p) << " "
!                                << "value=" << MapBase<K, V, C>::value(p) << " "
                                 << "map=" << *this;
              }
              return ret.first;
***************
*** 247,282 ****
  
          iterator insert(const std::pair<K, V>& p)
          {
!             return MapBase<K, V, C>::map.insert(p);
          }
  
          iterator insert(iterator position, const value_type& vt)
          {
!             return MapBase<K, V, C>::map.insert(position, vt);
          }
  
          std::pair<const_iterator, const_iterator> equal_range(const K& k) const
          {
!             return MapBase<K, V, C>::map.equal_range(k);
          }
      };
- 
-     template <typename K, typename V>
-     const K& get_key(const typename Map<K, V>::const_iterator i)
-     {
-         return i->first;
-     }
- 
-     template <typename K, typename V>
-     const K& get_key(const typename Map<K, V>::value_type& vt)
-     {
-         return vt.first;
-     }
- 
-     template <typename K, typename V>
-     const V& get_value(const typename Map<K, V>::value_type& vt)
-     {
-         return vt.second;
-     }
  }
  #endif /* GCOMM_MAP_HPP */
--- 247,264 ----
  
          iterator insert(const std::pair<K, V>& p)
          {
!             return MapBase<K, V, C>::map_.insert(p);
          }
  
          iterator insert(iterator position, const value_type& vt)
          {
!             return MapBase<K, V, C>::map_.insert(position, vt);
          }
  
          std::pair<const_iterator, const_iterator> equal_range(const K& k) const
          {
!             return MapBase<K, V, C>::map_.equal_range(k);
          }
      };
  }
  #endif /* GCOMM_MAP_HPP */
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/protolay.hpp 2.x/gcomm/src/gcomm/protolay.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/protolay.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/protolay.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 18,27 ****
  #include "gcomm/view.hpp"
  #include "gcomm/exception.hpp"
  #include "gcomm/order.hpp"
  
  #include "gu_logger.hpp"
  #include "gu_datetime.hpp"
- #include "gu_datagram.hpp"
  #include "gu_config.hpp"
  
  #include <cerrno>
--- 18,27 ----
  #include "gcomm/view.hpp"
  #include "gcomm/exception.hpp"
  #include "gcomm/order.hpp"
+ #include "gcomm/datagram.hpp"
  
  #include "gu_logger.hpp"
  #include "gu_datetime.hpp"
  #include "gu_config.hpp"
  
  #include <cerrno>
***************
*** 77,164 ****
  class gcomm::ProtoUpMeta
  {
  public:
!     ProtoUpMeta(const int err_no_) :
!         source(),
!         source_view_id(),
!         user_type(),
!         order(),
!         to_seq(),
!         err_no(err_no_),
!         view(0)
      { }
  
!     ProtoUpMeta(const UUID    source_         = UUID::nil(),
!                 const ViewId  source_view_id_ = ViewId(),
!                 const View*   view_           = 0,
!                 const uint8_t user_type_      = 0xff,
!                 const Order   order_          = O_DROP,
!                 const int64_t to_seq_         = -1,
!                 const int err_no_ = 0) :
!         source         (source_      ),
!         source_view_id (source_view_id_ ),
!         user_type      (user_type_   ),
!         order          (order_),
!         to_seq         (to_seq_      ),
!         err_no         (err_no_),
!         view           (view_ != 0 ? new View(*view_) : 0)
      { }
  
      ProtoUpMeta(const ProtoUpMeta& um) :
!         source         (um.source      ),
!         source_view_id (um.source_view_id ),
!         user_type      (um.user_type   ),
!         order          (um.order       ),
!         to_seq         (um.to_seq      ),
!         err_no         (um.err_no),
!         view           (um.view ? new View(*um.view) : 0)
      { }
  
!     ~ProtoUpMeta() { delete view; }
  
!     const UUID&   get_source()         const { return source; }
  
!     const ViewId& get_source_view_id() const { return source_view_id; }
  
!     uint8_t       get_user_type()      const { return user_type; }
  
!     Order         get_order()          const { return order; }
  
!     int64_t       get_to_seq()         const { return to_seq; }
  
!     int           get_errno()          const { return err_no; }
  
!     bool          has_view()           const { return view != 0; }
  
!     const View&   get_view()           const { return *view; }
  
  private:
      ProtoUpMeta& operator=(const ProtoUpMeta&);
  
!     UUID    const source;
!     ViewId  const source_view_id;
!     uint8_t const user_type;
!     Order   const order;
!     int64_t const to_seq;
!     int     const err_no;
!     View*   const view;
  };
  
  inline std::ostream& gcomm::operator<<(std::ostream& os, const ProtoUpMeta& um)
  {
      os << "proto_up_meta: { ";
!     if (not (um.get_source() == UUID::nil()))
      {
!         os << "source=" << um.get_source() << ",";
      }
!     if (um.get_source_view_id().get_type() != V_NONE)
      {
!         os << "source_view_id=" << um.get_source_view_id() << ",";
      }
!     os << "user_type=" << static_cast<int>(um.get_user_type()) << ",";
!     os << "to_seq=" << um.get_to_seq() << ",";
      if (um.has_view() == true)
      {
!         os << "view=" << um.get_view();
      }
      os << "}";
      return os;
--- 77,164 ----
  class gcomm::ProtoUpMeta
  {
  public:
!     ProtoUpMeta(const int err_no) :
!         source_(),
!         source_view_id_(),
!         user_type_(),
!         order_(),
!         to_seq_(),
!         err_no_(err_no),
!         view_(0)
      { }
  
!     ProtoUpMeta(const UUID    source         = UUID::nil(),
!                 const ViewId  source_view_id = ViewId(),
!                 const View*   view           = 0,
!                 const uint8_t user_type      = 0xff,
!                 const Order   order          = O_DROP,
!                 const int64_t to_seq         = -1,
!                 const int err_no = 0) :
!         source_         (source         ),
!         source_view_id_ (source_view_id ),
!         user_type_      (user_type      ),
!         order_          (order          ),
!         to_seq_         (to_seq         ),
!         err_no_         (err_no         ),
!         view_           (view != 0 ? new View(*view) : 0)
      { }
  
      ProtoUpMeta(const ProtoUpMeta& um) :
!         source_         (um.source_         ),
!         source_view_id_ (um.source_view_id_ ),
!         user_type_      (um.user_type_      ),
!         order_          (um.order_          ),
!         to_seq_         (um.to_seq_         ),
!         err_no_         (um.err_no_         ),
!         view_           (um.view_ ? new View(*um.view_) : 0)
      { }
  
!     ~ProtoUpMeta() { delete view_; }
  
!     const UUID&   source()         const { return source_; }
  
!     const ViewId& source_view_id() const { return source_view_id_; }
  
!     uint8_t       user_type()      const { return user_type_; }
  
!     Order         order()          const { return order_; }
  
!     int64_t       to_seq()         const { return to_seq_; }
  
!     int           err_no()          const { return err_no_; }
  
!     bool          has_view()           const { return view_ != 0; }
  
!     const View&   view()           const { return *view_; }
  
  private:
      ProtoUpMeta& operator=(const ProtoUpMeta&);
  
!     UUID    const source_;
!     ViewId  const source_view_id_;
!     uint8_t const user_type_;
!     Order   const order_;
!     int64_t const to_seq_;
!     int     const err_no_;
!     View*   const view_;
  };
  
  inline std::ostream& gcomm::operator<<(std::ostream& os, const ProtoUpMeta& um)
  {
      os << "proto_up_meta: { ";
!     if (not (um.source() == UUID::nil()))
      {
!         os << "source=" << um.source() << ",";
      }
!     if (um.source_view_id().type() != V_NONE)
      {
!         os << "source_view_id=" << um.source_view_id() << ",";
      }
!     os << "user_type=" << static_cast<int>(um.user_type()) << ",";
!     os << "to_seq=" << um.to_seq() << ",";
      if (um.has_view() == true)
      {
!         os << "view=" << um.view();
      }
      os << "}";
      return os;
***************
*** 168,188 ****
  class gcomm::ProtoDownMeta
  {
  public:
!     ProtoDownMeta(const uint8_t user_type_ = 0xff,
!                   const Order   order_     = O_SAFE,
!                   const UUID&   uuid_      = UUID::nil()) :
!         user_type (user_type_),
!         order     (order_),
!         source    (uuid_)
      { }
  
!     uint8_t     get_user_type() const { return user_type; }
!     Order       get_order()     const { return order;     }
!     const UUID& get_source()    const { return source;    }
  private:
!     const uint8_t user_type;
!     const Order   order;
!     const UUID    source;
  };
  
  class gcomm::Protolay
--- 168,188 ----
  class gcomm::ProtoDownMeta
  {
  public:
!     ProtoDownMeta(const uint8_t user_type = 0xff,
!                   const Order   order     = O_SAFE,
!                   const UUID&   uuid      = UUID::nil()) :
!         user_type_ (user_type),
!         order_     (order),
!         source_    (uuid)
      { }
  
!     uint8_t     user_type() const { return user_type_; }
!     Order       order()     const { return order_;     }
!     const UUID& source()    const { return source_;    }
  private:
!     const uint8_t user_type_;
!     const Order   order_;
!     const UUID    source_;
  };
  
  class gcomm::Protolay
***************
*** 212,219 ****
      virtual void close(const UUID& uuid) { }
  
      /* apparently handles data from upper layer. what is return value? */
!     virtual int  handle_down (gu::Datagram&, const ProtoDownMeta&) = 0;
!     virtual void handle_up   (const void*, const gu::Datagram&, const ProtoUpMeta&) = 0;
  
      void set_up_context(Protolay *up)
      {
--- 212,219 ----
      virtual void close(const UUID& uuid) { }
  
      /* apparently handles data from upper layer. what is return value? */
!     virtual int  handle_down (Datagram&, const ProtoDownMeta&) = 0;
!     virtual void handle_up   (const void*, const Datagram&, const ProtoUpMeta&) = 0;
  
      void set_up_context(Protolay *up)
      {
***************
*** 263,269 ****
      }
  
      /* apparently passed data buffer to the upper layer */
!     void send_up(const gu::Datagram& dg, const ProtoUpMeta& up_meta)
      {
  	if (up_context_.empty() == true)
          {
--- 263,269 ----
      }
  
      /* apparently passed data buffer to the upper layer */
!     void send_up(const Datagram& dg, const ProtoUpMeta& up_meta)
      {
  	if (up_context_.empty() == true)
          {
***************
*** 279,285 ****
      }
  
      /* apparently passes data buffer to lower layer, what is return value? */
!     int send_down(gu::Datagram& dg, const ProtoDownMeta& down_meta)
      {
  	if (down_context_.empty() == true)
          {
--- 279,285 ----
      }
  
      /* apparently passes data buffer to lower layer, what is return value? */
!     int send_down(Datagram& dg, const ProtoDownMeta& down_meta)
      {
  	if (down_context_.empty() == true)
          {
***************
*** 291,301 ****
          for (CtxList::iterator i = down_context_.begin();
               i != down_context_.end(); ++i)
          {
!             const size_t hdr_offset(dg.get_header_offset());
              int err = (*i)->handle_down(dg, down_meta);
              // Verify that lower layer rolls back any modifications to
              // header
!             if (hdr_offset != dg.get_header_offset())
              {
                  gu_throw_fatal;
              }
--- 291,301 ----
          for (CtxList::iterator i = down_context_.begin();
               i != down_context_.end(); ++i)
          {
!             const size_t hdr_offset(dg.header_offset());
              int err = (*i)->handle_down(dg, down_meta);
              // Verify that lower layer rolls back any modifications to
              // header
!             if (hdr_offset != dg.header_offset())
              {
                  gu_throw_fatal;
              }
***************
*** 328,334 ****
          return false;
      }
  
!     const Protolay* get_id() const { return this; }
  
  };
  
--- 328,334 ----
          return false;
      }
  
!     const Protolay* id() const { return this; }
  
  };
  
***************
*** 337,343 ****
  public:
      Toplay(gu::Config& conf) : Protolay(conf) { }
  private:
!     int handle_down(gu::Datagram& dg, const ProtoDownMeta& dm)
      {
  	gu_throw_fatal << "Toplay handle_down() called";
  	throw;
--- 337,343 ----
  public:
      Toplay(gu::Config& conf) : Protolay(conf) { }
  private:
!     int handle_down(Datagram& dg, const ProtoDownMeta& dm)
      {
  	gu_throw_fatal << "Toplay handle_down() called";
  	throw;
***************
*** 349,355 ****
  public:
      Bottomlay(gu::Config& conf) : Protolay(conf) { }
  private:
!     void handle_up(const void* id, const gu::Datagram&, const ProtoUpMeta& um)
      {
  	gu_throw_fatal << "Bottomlay handle_up() called";
      }
--- 349,355 ----
  public:
      Bottomlay(gu::Config& conf) : Protolay(conf) { }
  private:
!     void handle_up(const void* id, const Datagram&, const ProtoUpMeta& um)
      {
  	gu_throw_fatal << "Bottomlay handle_up() called";
      }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/protonet.hpp 2.x/gcomm/src/gcomm/protonet.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/protonet.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/protonet.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 118,126 ****
      //
      static Protonet* create(gu::Config& conf);
  
!     const std::string& get_type() const { return type_; }
  
!     virtual size_t get_mtu() const = 0;
  
  protected:
  
--- 118,126 ----
      //
      static Protonet* create(gu::Config& conf);
  
!     const std::string& type() const { return type_; }
  
!     virtual size_t mtu() const = 0;
  
  protected:
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/protostack.hpp 2.x/gcomm/src/gcomm/protostack.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/protostack.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/protostack.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 8,14 ****
  #include "gcomm/protolay.hpp"
  
  #include "gu_lock.hpp"
- #include "gu_datagram.hpp"
  
  #include <deque>
  
--- 8,13 ----
***************
*** 29,35 ****
      void push_proto(Protolay* p);
      void pop_proto(Protolay* p);
      gu::datetime::Date handle_timers();
!     void dispatch(const void* id, const gu::Datagram& dg,
                    const ProtoUpMeta& um);
      bool set_param(const std::string&, const std::string&);
      void enter() { mutex_.lock(); }
--- 28,34 ----
      void push_proto(Protolay* p);
      void pop_proto(Protolay* p);
      gu::datetime::Date handle_timers();
!     void dispatch(const void* id, const Datagram& dg,
                    const ProtoUpMeta& um);
      bool set_param(const std::string&, const std::string&);
      void enter() { mutex_.lock(); }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/transport.hpp 2.x/gcomm/src/gcomm/transport.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/transport.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/transport.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 34,58 ****
  class gcomm::Transport : public Protolay
  {
  public:
-     typedef enum {
-         S_CLOSED,
-         S_CONNECTING,
-         S_CONNECTED,
-         S_CLOSING,
-         S_LISTENING,
-         S_FAILED
-     } State;
- 
      virtual ~Transport();
  
!     virtual size_t      get_mtu()          const = 0;
!     virtual bool        supports_uuid()    const;
!     virtual const UUID& get_uuid()         const;
!     virtual std::string get_local_addr()   const;
!     virtual std::string get_remote_addr()  const;
  
!     virtual State        get_state() const;
!     int                  get_errno() const;
  
      virtual void connect() = 0;
      virtual void connect(const gu::URI& uri)
--- 34,47 ----
  class gcomm::Transport : public Protolay
  {
  public:
      virtual ~Transport();
  
!     virtual size_t      mtu()           const = 0;
!     virtual const UUID& uuid()          const = 0;
!     virtual std::string local_addr()    const;
!     virtual std::string remote_addr()   const;
  
!     int                 err_no()        const;
  
      virtual void connect() = 0;
      virtual void connect(const gu::URI& uri)
***************
*** 67,73 ****
      }
  
      virtual void        listen();
!     virtual std::string get_listen_addr() const
      {
          gu_throw_fatal << "not supported";
          throw;
--- 56,62 ----
      }
  
      virtual void        listen();
!     virtual std::string listen_addr() const
      {
          gu_throw_fatal << "not supported";
          throw;
***************
*** 84,105 ****
                                  << uri_.get_scheme();
      }
  
!     virtual int  handle_down(gu::Datagram&, const ProtoDownMeta&) = 0;
!     virtual void handle_up  (const void*, const gu::Datagram&, const ProtoUpMeta&) = 0;
      virtual void handle_stable_view(const View& view) { }
!     Protostack& get_pstack() { return pstack_; }
!     Protonet&   get_pnet()   { return pnet_; }
  
      static Transport* create(Protonet&, const std::string&);
      static Transport* create(Protonet&, const gu::URI&);
  protected:
      Transport (Protonet&, const gu::URI&);
-     void              set_state(State);
      Protostack        pstack_;
      Protonet&         pnet_;
      gu::URI           uri_;
- 
-     State             state_;
      int               error_no_;
  
  private:
--- 73,91 ----
                                  << uri_.get_scheme();
      }
  
!     virtual int  handle_down(Datagram&, const ProtoDownMeta&) = 0;
!     virtual void handle_up  (const void*, const Datagram&, const ProtoUpMeta&) = 0;
      virtual void handle_stable_view(const View& view) { }
!     Protostack& pstack() { return pstack_; }
!     Protonet&   pnet()   { return pnet_; }
  
      static Transport* create(Protonet&, const std::string&);
      static Transport* create(Protonet&, const gu::URI&);
  protected:
      Transport (Protonet&, const gu::URI&);
      Protostack        pstack_;
      Protonet&         pnet_;
      gu::URI           uri_;
      int               error_no_;
  
  private:
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/types.hpp 2.x/gcomm/src/gcomm/types.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/types.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/types.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 17,89 ****
  
  
  namespace gcomm
! {    
!     template <size_t SZ> 
      class String
      {
      public:
!         String(const std::string& str_ = "") : str(str_) 
!         { 
!             if (str.size() > str_size)
              {
                  gu_throw_error(EMSGSIZE);
              }
!             
          }
!         
          virtual ~String() { }
!         
!         size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset) 
              const throw(gu::Exception)
          {
!             if (buflen < offset + str_size)
              {
!                 gu_throw_error (EMSGSIZE) << str_size
                                            << " > " << (buflen-offset);
              }
!             std::string ser_str(str);
!             ser_str.resize(str_size, '\0');
!             (void)std::copy(ser_str.data(), ser_str.data() + ser_str.size(), 
                              buf + offset);
!             return offset + str_size;
          }
!         
          size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
              throw(gu::Exception)
          {
!             if (buflen < offset + str_size)
              {
!                 gu_throw_error (EMSGSIZE) << str_size
                                            << " > " << (buflen-offset);
              }
!             str.assign(reinterpret_cast<const char*>(buf) + offset, str_size);
!             const size_t tc(str.find_first_of('\0'));
              if (tc != std::string::npos)
              {
!                 str.resize(tc);
              }
!             return offset + str_size;
          }
!         
          static size_t serial_size()
          {
!             return str_size;
          }
  
!         const std::string& to_string() const { return str; }
  
          bool operator==(const String<SZ>& cmp) const
!         { return (str == cmp.str); }
!         
      private:
!         static const size_t str_size = SZ ;
!         std::string str; /* Human readable name if any */
      };
  
      template <size_t SZ>
      inline std::ostream& operator<<(std::ostream& os, const String<SZ>& str)
      { return (os << str.to_string()); }
!     
  } // namespace gcomm
  
  #endif /* _GCOMM_TYPES_HPP_ */
--- 17,89 ----
  
  
  namespace gcomm
! {
!     template <size_t SZ>
      class String
      {
      public:
!         String(const std::string& str = "") : str_(str)
!         {
!             if (str_.size() > str_size_)
              {
                  gu_throw_error(EMSGSIZE);
              }
! 
          }
! 
          virtual ~String() { }
! 
!         size_t serialize(gu::byte_t* buf, size_t buflen, size_t offset)
              const throw(gu::Exception)
          {
!             if (buflen < offset + str_size_)
              {
!                 gu_throw_error (EMSGSIZE) << str_size_
                                            << " > " << (buflen-offset);
              }
!             std::string ser_str(str_);
!             ser_str.resize(str_size_, '\0');
!             (void)std::copy(ser_str.data(), ser_str.data() + ser_str.size(),
                              buf + offset);
!             return offset + str_size_;
          }
! 
          size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
              throw(gu::Exception)
          {
!             if (buflen < offset + str_size_)
              {
!                 gu_throw_error (EMSGSIZE) << str_size_
                                            << " > " << (buflen-offset);
              }
!             str_.assign(reinterpret_cast<const char*>(buf) + offset, str_size_);
!             const size_t tc(str_.find_first_of('\0'));
              if (tc != std::string::npos)
              {
!                 str_.resize(tc);
              }
!             return offset + str_size_;
          }
! 
          static size_t serial_size()
          {
!             return str_size_;
          }
  
!         const std::string& to_string() const { return str_; }
  
          bool operator==(const String<SZ>& cmp) const
!         { return (str_ == cmp.str_); }
! 
      private:
!         static const size_t str_size_ = SZ ;
!         std::string str_; /* Human readable name if any */
      };
  
      template <size_t SZ>
      inline std::ostream& operator<<(std::ostream& os, const String<SZ>& str)
      { return (os << str.to_string()); }
! 
  } // namespace gcomm
  
  #endif /* _GCOMM_TYPES_HPP_ */
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/util.hpp 2.x/gcomm/src/gcomm/util.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/util.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/util.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 5,11 ****
  #ifndef _GCOMM_UTIL_HPP_
  #define _GCOMM_UTIL_HPP_
  
! #include "gu_datagram.hpp"
  #include "gu_logger.hpp"
  #include "gu_throw.hpp"
  
--- 5,12 ----
  #ifndef _GCOMM_UTIL_HPP_
  #define _GCOMM_UTIL_HPP_
  
! #include "gcomm/datagram.hpp"
! 
  #include "gu_logger.hpp"
  #include "gu_throw.hpp"
  
***************
*** 54,107 ****
  
  
      template <class M>
!     void push_header(const M& msg, gu::Datagram& dg)
      {
! #if 0
!         dg.get_header().resize(dg.get_header().size() + msg.serial_size());
!         memmove(&dg.get_header()[0] + msg.serial_size(),
!                 &dg.get_header()[0],
!                 dg.get_header().size() - msg.serial_size());
!         msg.serialize(&dg.get_header()[0],
!                       dg.get_header().size(), 0);
! #else
!         if (dg.get_header_offset() < msg.serial_size())
          {
              gu_throw_fatal;
          }
!         msg.serialize(dg.get_header(),
!                       dg.get_header_size(),
!                       dg.get_header_offset() - msg.serial_size());
!         dg.set_header_offset(dg.get_header_offset() - msg.serial_size());
! #endif
      }
  
  
      template <class M>
!     void pop_header(const M& msg, gu::Datagram& dg)
      {
! #if 0
!         memmove(&dg.get_header()[0],
!                 &dg.get_header()[0] + msg.serial_size(),
!                 dg.get_header().size() - msg.serial_size());
!         dg.get_header().resize(dg.get_header().size() - msg.serial_size());
! #else
!         assert(dg.get_header_size() >= dg.get_header_offset() + msg.serial_size());
!         dg.set_header_offset(dg.get_header_offset() + msg.serial_size());
! #endif
      }
  
  
!     inline const gu::byte_t* get_begin(const gu::Datagram& dg)
      {
!         return (dg.get_offset() < dg.get_header_len() ?
!                 dg.get_header() + dg.get_header_offset() + dg.get_offset() :
!                 &dg.get_payload()[0] + (dg.get_offset() - dg.get_header_len()));
      }
!     inline size_t get_available(const gu::Datagram& dg)
      {
!         return (dg.get_offset() < dg.get_header_len() ?
!                 dg.get_header_len() - dg.get_offset() :
!                 dg.get_payload().size() - (dg.get_offset() - dg.get_header_len()));
      }
  
  
--- 55,92 ----
  
  
      template <class M>
!     void push_header(const M& msg, Datagram& dg)
      {
!         if (dg.header_offset() < msg.serial_size())
          {
              gu_throw_fatal;
          }
!         msg.serialize(dg.header(),
!                       dg.header_size(),
!                       dg.header_offset() - msg.serial_size());
!         dg.set_header_offset(dg.header_offset() - msg.serial_size());
      }
  
  
      template <class M>
!     void pop_header(const M& msg, Datagram& dg)
      {
!         assert(dg.header_size() >= dg.header_offset() + msg.serial_size());
!         dg.set_header_offset(dg.header_offset() + msg.serial_size());
      }
  
  
!     inline const gu::byte_t* begin(const Datagram& dg)
      {
!         return (dg.offset() < dg.header_len() ?
!                 dg.header() + dg.header_offset() + dg.offset() :
!                 &dg.payload()[0] + (dg.offset() - dg.header_len()));
      }
!     inline size_t available(const Datagram& dg)
      {
!         return (dg.offset() < dg.header_len() ?
!                 dg.header_len() - dg.offset() :
!                 dg.payload().size() - (dg.offset() - dg.header_len()));
      }
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/uuid.hpp 2.x/gcomm/src/gcomm/uuid.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/uuid.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/uuid.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 27,51 ****
  {
  public:
  
!     UUID() : uuid(GU_UUID_NIL) {}
  
!     UUID(const void* node, const size_t node_len) :
!         uuid()
      {
!         gu_uuid_generate(&uuid, node, node_len);
      }
  
!     UUID(const int32_t idx) :
!         uuid()
      {
          assert(idx > 0);
!         uuid = GU_UUID_NIL;
!         memcpy(&uuid, &idx, sizeof(idx));
      }
  
      static const UUID& nil()
      {
!         return uuid_nil;
      }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
--- 27,49 ----
  {
  public:
  
!     UUID() : uuid_(GU_UUID_NIL) {}
  
!     UUID(const void* node, const size_t node_len) : uuid_()
      {
!         gu_uuid_generate(&uuid_, node, node_len);
      }
  
!     UUID(const int32_t idx) : uuid_()
      {
          assert(idx > 0);
!         uuid_ = GU_UUID_NIL;
!         memcpy(&uuid_, &idx, sizeof(idx));
      }
  
      static const UUID& nil()
      {
!         return uuid_nil_;
      }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
***************
*** 55,61 ****
              gu_throw_error (EMSGSIZE) << sizeof(gu_uuid_t) << " > "
                                             << (buflen - offset);
  
!         memcpy(&uuid, buf + offset, sizeof(gu_uuid_t));
  
          return offset + sizeof(gu_uuid_t);
      }
--- 53,59 ----
              gu_throw_error (EMSGSIZE) << sizeof(gu_uuid_t) << " > "
                                             << (buflen - offset);
  
!         memcpy(&uuid_, buf + offset, sizeof(gu_uuid_t));
  
          return offset + sizeof(gu_uuid_t);
      }
***************
*** 67,73 ****
              gu_throw_error (EMSGSIZE) << sizeof(gu_uuid_t) << " > "
                                             << (buflen - offset);
  
!         memcpy(buf + offset, &uuid, sizeof(gu_uuid_t));
  
          return offset + sizeof(gu_uuid_t);
      }
--- 65,71 ----
              gu_throw_error (EMSGSIZE) << sizeof(gu_uuid_t) << " > "
                                             << (buflen - offset);
  
!         memcpy(buf + offset, &uuid_, sizeof(gu_uuid_t));
  
          return offset + sizeof(gu_uuid_t);
      }
***************
*** 77,128 ****
          return sizeof(gu_uuid_t);
      }
  
!     const gu_uuid_t* get_uuid_ptr() const
      {
!         return &uuid;
      }
  
      bool operator<(const UUID& cmp) const
      {
!         return (gu_uuid_compare(&uuid, &cmp.uuid) < 0);
      }
  
      bool operator==(const UUID& cmp) const
      {
!         return (gu_uuid_compare(&uuid, &cmp.uuid) == 0);
      }
  
      bool older(const UUID& cmp) const
      {
!         return (gu_uuid_older(&uuid, &cmp.uuid) > 0);
      }
  
      std::ostream& to_stream(std::ostream& os) const
      {
          static const char buf[37] = { 0, };
!         const uint32_t* i = reinterpret_cast<const uint32_t*>(uuid.data);
  
          if (i[0] != 0 &&
!             memcmp(i + 1, buf, sizeof(uuid) - sizeof(*i)) == 0)
          {
              // if all of UUID is contained in the first 4 bytes
              os << i[0]; // should this be converted to certain endianness?
          }
          else
          {
!             const uint16_t* s = reinterpret_cast<const uint16_t*>(uuid.data);
  
!             using namespace std;
  
!             ios_base::fmtflags saved = os.flags();
! 
!             os << hex
!                << setfill('0') << setw(8) << gu_be32(i[0]) << '-'
!                << setfill('0') << setw(4) << gu_be16(s[2]) << '-'
!                << setfill('0') << setw(4) << gu_be16(s[3]) << '-'
!                << setfill('0') << setw(4) << gu_be16(s[4]) << '-'
!                << setfill('0') << setw(4) << gu_be16(s[5])
!                << setfill('0') << setw(8) << gu_be32(i[3]);
  
              os.flags(saved);
          }
--- 75,124 ----
          return sizeof(gu_uuid_t);
      }
  
!     const gu_uuid_t* uuid_ptr() const
      {
!         return &uuid_;
      }
  
      bool operator<(const UUID& cmp) const
      {
!         return (gu_uuid_compare(&uuid_, &cmp.uuid_) < 0);
      }
  
      bool operator==(const UUID& cmp) const
      {
!         return (gu_uuid_compare(&uuid_, &cmp.uuid_) == 0);
      }
  
      bool older(const UUID& cmp) const
      {
!         return (gu_uuid_older(&uuid_, &cmp.uuid_) > 0);
      }
  
      std::ostream& to_stream(std::ostream& os) const
      {
          static const char buf[37] = { 0, };
!         const uint32_t* i = reinterpret_cast<const uint32_t*>(uuid_.data);
  
          if (i[0] != 0 &&
!             memcmp(i + 1, buf, sizeof(uuid_) - sizeof(*i)) == 0)
          {
              // if all of UUID is contained in the first 4 bytes
              os << i[0]; // should this be converted to certain endianness?
          }
          else
          {
!             const uint16_t* s = reinterpret_cast<const uint16_t*>(uuid_.data);
  
!             std::ios_base::fmtflags saved = os.flags();
  
!             os << std::hex
!                << std::setfill('0') << std::setw(8) << gu_be32(i[0]) << '-'
!                << std::setfill('0') << std::setw(4) << gu_be16(s[2]) << '-'
!                << std::setfill('0') << std::setw(4) << gu_be16(s[3]) << '-'
!                << std::setfill('0') << std::setw(4) << gu_be16(s[4]) << '-'
!                << std::setfill('0') << std::setw(4) << gu_be16(s[5])
!                << std::setfill('0') << std::setw(8) << gu_be32(i[3]);
  
              os.flags(saved);
          }
***************
*** 140,148 ****
  
  private:
  
!     gu_uuid_t         uuid;
!     static const UUID uuid_nil;
!     UUID(gu_uuid_t uuid_) : uuid(uuid_) {}
  };
  
  
--- 136,144 ----
  
  private:
  
!     gu_uuid_t         uuid_;
!     static const UUID uuid_nil_;
!     UUID(gu_uuid_t uuid) : uuid_(uuid) {}
  };
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gcomm/view.hpp 2.x/gcomm/src/gcomm/view.hpp
*** galera-23.2.2-src/gcomm/src/gcomm/view.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gcomm/view.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 31,58 ****
      public:
  
  
!         ViewId(const ViewType type_    = V_NONE,
!                const UUID&    uuid_   = UUID::nil(),
!                const uint32_t seq_ = 0) :
!             type(type_),
!             uuid(uuid_),
!             seq(seq_)
          { }
  
!         ViewId(const ViewType type_,
                 const ViewId& vi) :
!             type(type_),
!             uuid(vi.get_uuid()),
!             seq(vi.get_seq())
          { }
  
          virtual ~ViewId() { }
  
!         ViewType    get_type() const { return type; }
  
!         const UUID& get_uuid() const { return uuid; }
  
!         uint32_t    get_seq()  const { return seq; }
  
          size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
              throw (gu::Exception);
--- 31,58 ----
      public:
  
  
!         ViewId(const ViewType type    = V_NONE,
!                const UUID&    uuid    = UUID::nil(),
!                const uint32_t seq     = 0) :
!             type_(type),
!             uuid_(uuid),
!             seq_ (seq)
          { }
  
!         ViewId(const ViewType type,
                 const ViewId& vi) :
!             type_(type),
!             uuid_(vi.uuid()),
!             seq_ (vi.seq())
          { }
  
          virtual ~ViewId() { }
  
!         ViewType    type() const { return type_; }
  
!         const UUID& uuid() const { return uuid_; }
  
!         uint32_t    seq()  const { return seq_; }
  
          size_t unserialize(const gu::byte_t* buf, size_t buflen, size_t offset)
              throw (gu::Exception);
***************
*** 62,68 ****
  
          static size_t serial_size()
          {
!             return UUID::serial_size() + sizeof(reinterpret_cast<ViewId*>(0)->seq);
          }
  
          bool operator<(const ViewId& cmp) const
--- 62,68 ----
  
          static size_t serial_size()
          {
!             return UUID::serial_size() + sizeof(reinterpret_cast<ViewId*>(0)->seq_);
          }
  
          bool operator<(const ViewId& cmp) const
***************
*** 71,85 ****
              // 1) view seq less than
              // 2) uuid newer than
              // 3) type less than
!             return (seq < cmp.seq ||
!                     (seq == cmp.seq &&
!                      (cmp.uuid.older(uuid) ||
!                       (uuid == cmp.uuid && type < cmp.type) ) ) );
          }
  
          bool operator==(const ViewId& cmp) const
          {
!             return (seq == cmp.seq && type == cmp.type && uuid == cmp.uuid);
          }
  
          bool operator!=(const ViewId& cmp) const
--- 71,87 ----
              // 1) view seq less than
              // 2) uuid newer than
              // 3) type less than
!             return (seq_ < cmp.seq_ ||
!                     (seq_ == cmp.seq_ &&
!                      (cmp.uuid_.older(uuid_) ||
!                       (uuid_ == cmp.uuid_ && type_ < cmp.type_) ) ) );
          }
  
          bool operator==(const ViewId& cmp) const
          {
!             return (seq_  == cmp.seq_  &&
!                     type_ == cmp.type_ &&
!                     uuid_ == cmp.uuid_);
          }
  
          bool operator!=(const ViewId& cmp) const
***************
*** 88,96 ****
          }
  
      private:
!         ViewType type;
!         UUID uuid; // uniquely identifies the sequence of group views (?)
!         uint32_t    seq;  // position in the sequence                        (?)
      };
  
      std::ostream& operator<<(std::ostream&, const ViewId&);
--- 90,98 ----
          }
  
      private:
!         ViewType type_;
!         UUID     uuid_; // uniquely identifies the sequence of group views (?)
!         uint32_t seq_;  // position in the sequence                        (?)
      };
  
      std::ostream& operator<<(std::ostream&, const ViewId&);
***************
*** 115,135 ****
      public:
  
          View() :
!             bootstrap   (false),
!             view_id     (V_NONE),
!             members     (),
!             joined      (),
!             left        (),
!             partitioned ()
          { }
  
!         View(const ViewId& view_id_, bool bootstrap_ = false) :
!             bootstrap   (bootstrap_),
!             view_id     (view_id_),
!             members     (),
!             joined      (),
!             left        (),
!             partitioned ()
          { }
  
          ~View() {}
--- 117,137 ----
      public:
  
          View() :
!             bootstrap_   (false),
!             view_id_     (V_NONE),
!             members_     (),
!             joined_      (),
!             left_        (),
!             partitioned_ ()
          { }
  
!         View(const ViewId& view_id, bool bootstrap = false) :
!             bootstrap_   (bootstrap),
!             view_id_     (view_id),
!             members_     (),
!             joined_      (),
!             left_        (),
!             partitioned_ ()
          { }
  
          ~View() {}
***************
*** 143,174 ****
          void add_left        (const UUID& pid, const std::string& name);
          void add_partitioned (const UUID& pid, const std::string& name);
  
!         const NodeList& get_members     () const;
!         const NodeList& get_joined      () const;
!         const NodeList& get_left        () const;
!         const NodeList& get_partitioned () const;
  
!         NodeList& get_members() { return members; }
  
          bool is_member(const UUID& uuid) const
!         { return members.find(uuid) != members.end(); }
  
          bool is_joining(const UUID& uuid) const
!         { return joined.find(uuid) != joined.end(); }
  
          bool is_leaving(const UUID& uuid) const
!         { return left.find(uuid) != left.end(); }
  
          bool is_partitioning(const UUID& uuid) const
!         { return partitioned.find(uuid) != partitioned.end(); }
  
  
!         ViewType      get_type           () const;
!         const ViewId& get_id             () const;
!         const UUID&   get_representative () const;
  
          bool is_empty() const;
!         bool is_bootstrap() const { return bootstrap; }
  
          size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
              throw (gu::Exception);
--- 145,176 ----
          void add_left        (const UUID& pid, const std::string& name);
          void add_partitioned (const UUID& pid, const std::string& name);
  
!         const NodeList& members     () const;
!         const NodeList& joined      () const;
!         const NodeList& left        () const;
!         const NodeList& partitioned () const;
  
!         NodeList& members() { return members_; }
  
          bool is_member(const UUID& uuid) const
!         { return members_.find(uuid) != members_.end(); }
  
          bool is_joining(const UUID& uuid) const
!         { return joined_.find(uuid) != joined_.end(); }
  
          bool is_leaving(const UUID& uuid) const
!         { return left_.find(uuid) != left_.end(); }
  
          bool is_partitioning(const UUID& uuid) const
!         { return partitioned_.find(uuid) != partitioned_.end(); }
  
  
!         ViewType      type           () const;
!         const ViewId& id             () const;
!         const UUID&   representative () const;
  
          bool is_empty() const;
!         bool is_bootstrap() const { return bootstrap_; }
  
          size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
              throw (gu::Exception);
***************
*** 180,191 ****
  
  
      private:
!         bool     bootstrap;   // Flag indicating if view was bootstrapped
!         ViewId   view_id;     // View identifier
!         NodeList members;     // List of members in view
!         NodeList joined;      // List of newly joined members in view
!         NodeList left;        // Fracefully left members from previous view
!         NodeList partitioned; // Partitioned members from previous view
      };
  
      bool operator==(const gcomm::View&, const gcomm::View&);
--- 182,193 ----
  
  
      private:
!         bool     bootstrap_;   // Flag indicating if view was bootstrapped
!         ViewId   view_id_;     // View identifier
!         NodeList members_;     // List of members in view
!         NodeList joined_;      // List of newly joined members in view
!         NodeList left_;        // Fracefully left members from previous view
!         NodeList partitioned_; // Partitioned members from previous view
      };
  
      bool operator==(const gcomm::View&, const gcomm::View&);
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast.cpp 2.x/gcomm/src/gmcast.cpp
*** galera-23.2.2-src/gcomm/src/gmcast.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 13,93 ****
  #include "gu_convert.hpp"
  #include "gu_resolver.hpp"
  
- using namespace std;
  using namespace std::rel_ops;
- using namespace gcomm;
- using namespace gcomm::gmcast;
- using namespace gu;
- using namespace gu::net;
- using namespace gu::datetime;
  
! const long gcomm::GMCast::max_retry_cnt(std::numeric_limits<int>::max());
  
! static void set_tcp_defaults (URI* uri)
  {
      // what happens if there is already this parameter?
!     uri->set_option(Conf::TcpNonBlocking, gu::to_string(1));
  }
  
  
! static bool check_tcp_uri(const URI& uri)
  {
!     return (uri.get_scheme() == TCP_SCHEME ||
!             uri.get_scheme() == SSL_SCHEME);
  }
  
  static std::string get_scheme(bool use_ssl)
  {
      if (use_ssl == true)
      {
!         return SSL_SCHEME;
      }
!     return TCP_SCHEME;
  }
  
  
! GMCast::GMCast(Protonet& net, const gu::URI& uri)
      :
      Transport     (net, uri),
!     version(check_range(Conf::GMCastVersion,
!                         param<int>(conf_, uri, Conf::GMCastVersion, "0"),
!                         0, max_version_ + 1)),
!     my_uuid       (0, 0),
!     use_ssl       (param<bool>(conf_, uri, Conf::SocketUseSsl, "false")),
      // @todo: technically group name should be in path component
!     group_name    (param<std::string>(conf_, uri, Conf::GMCastGroup, "")),
!     listen_addr   (
          param<std::string>(
              conf_, uri, Conf::GMCastListenAddr,
!             get_scheme(use_ssl) + "://0.0.0.0")), // how to make it IPv6 safe?
!     initial_addrs (),
!     mcast_addr    (param<std::string>(conf_, uri, Conf::GMCastMCastAddr, "")),
!     bind_ip       (""),
!     mcast_ttl     (check_range(
                         Conf::GMCastMCastTTL,
                         param<int>(conf_, uri, Conf::GMCastMCastTTL, "1"),
                         1, 256)),
!     listener      (0),
!     mcast         (),
!     pending_addrs (),
!     remote_addrs  (),
!     addr_blacklist(),
!     relaying      (false),
!     isolate       (false),
!     proto_map     (new ProtoMap()),
!     mcast_tree    (),
!     time_wait     (param<Period>(conf_, uri, Conf::GMCastTimeWait, "PT5S")),
!     check_period  ("PT0.5S"),
!     peer_timeout  (param<Period>(conf_, uri, Conf::GMCastPeerTimeout, "PT3S")),
!     max_initial_reconnect_attempts(
          param<int>(conf_, uri,
                     Conf::GMCastMaxInitialReconnectAttempts,
!                    gu::to_string(max_retry_cnt))),
!     next_check    (Date::now())
  {
!     log_info << "GMCast version " << version;
  
!     if (group_name == "")
      {
          gu_throw_error (EINVAL) << "Group not defined in URL: "
                                  << uri_.to_string();
--- 13,93 ----
  #include "gu_convert.hpp"
  #include "gu_resolver.hpp"
  
  using namespace std::rel_ops;
  
! using gcomm::gmcast::Proto;
! using gcomm::gmcast::ProtoMap;
! using gcomm::gmcast::Link;
! using gcomm::gmcast::LinkMap;
! using gcomm::gmcast::Message;
  
! const long gcomm::GMCast::max_retry_cnt_(std::numeric_limits<int>::max());
! 
! static void set_tcp_defaults (gu::URI* uri)
  {
      // what happens if there is already this parameter?
!     uri->set_option(gcomm::Conf::TcpNonBlocking, gu::to_string(1));
  }
  
  
! static bool check_tcp_uri(const gu::URI& uri)
  {
!     return (uri.get_scheme() == gcomm::TCP_SCHEME ||
!             uri.get_scheme() == gcomm::SSL_SCHEME);
  }
  
  static std::string get_scheme(bool use_ssl)
  {
      if (use_ssl == true)
      {
!         return gcomm::SSL_SCHEME;
      }
!     return gcomm::TCP_SCHEME;
  }
  
  
! gcomm::GMCast::GMCast(Protonet& net, const gu::URI& uri)
      :
      Transport     (net, uri),
!     version_(check_range(Conf::GMCastVersion,
!                          param<int>(conf_, uri, Conf::GMCastVersion, "0"),
!                          0, max_version_ + 1)),
!     my_uuid_      (0, 0),
!     use_ssl_      (param<bool>(conf_, uri, Conf::SocketUseSsl, "false")),
      // @todo: technically group name should be in path component
!     group_name_   (param<std::string>(conf_, uri, Conf::GMCastGroup, "")),
!     listen_addr_  (
          param<std::string>(
              conf_, uri, Conf::GMCastListenAddr,
!             get_scheme(use_ssl_) + "://0.0.0.0")), // how to make it IPv6 safe?
!     initial_addrs_(),
!     mcast_addr_   (param<std::string>(conf_, uri, Conf::GMCastMCastAddr, "")),
!     bind_ip_      (""),
!     mcast_ttl_    (check_range(
                         Conf::GMCastMCastTTL,
                         param<int>(conf_, uri, Conf::GMCastMCastTTL, "1"),
                         1, 256)),
!     listener_     (0),
!     mcast_        (),
!     pending_addrs_(),
!     remote_addrs_ (),
!     addr_blacklist_(),
!     relaying_     (false),
!     isolate_      (false),
!     proto_map_    (new ProtoMap()),
!     mcast_tree_   (),
!     time_wait_    (param<gu::datetime::Period>(conf_, uri, Conf::GMCastTimeWait, "PT5S")),
!     check_period_ ("PT0.5S"),
!     peer_timeout_ (param<gu::datetime::Period>(conf_, uri, Conf::GMCastPeerTimeout, "PT3S")),
!     max_initial_reconnect_attempts_(
          param<int>(conf_, uri,
                     Conf::GMCastMaxInitialReconnectAttempts,
!                    gu::to_string(max_retry_cnt_))),
!     next_check_   (gu::datetime::Date::now())
  {
!     log_info << "GMCast version " << version_;
  
!     if (group_name_ == "")
      {
          gu_throw_error (EINVAL) << "Group not defined in URL: "
                                  << uri_.to_string();
***************
*** 97,132 ****
  
      try
      {
!         listen_addr = uri_.get_option (Conf::GMCastListenAddr);
      }
      catch (gu::NotFound&) {}
  
      try
      {
!         gu::URI uri(listen_addr); /* check validity of the address */
      }
!     catch (Exception&)
      {
          /* most probably no scheme, try to append one and see if it succeeds */
!         listen_addr = uri_string(get_scheme(use_ssl), listen_addr);
!         gu_trace(gu::URI uri(listen_addr));
      }
  
!     URI listen_uri(listen_addr);
  
      if (check_tcp_uri(listen_uri) == false)
      {
!         gu_throw_error (EINVAL) << "listen addr '" << listen_addr
                                  << "' does not specify supported protocol";
      }
  
!     if (resolve(listen_uri).get_addr().is_anyaddr() == false)
      {
          // bind outgoing connections to the same address as listening.
!         gu_trace(bind_ip = listen_uri.get_host());
      }
  
!     string port(Defaults::GMCastTcpPort);
  
      try
      {
--- 97,132 ----
  
      try
      {
!         listen_addr_ = uri_.get_option (Conf::GMCastListenAddr);
      }
      catch (gu::NotFound&) {}
  
      try
      {
!         gu::URI uri(listen_addr_); /* check validity of the address */
      }
!     catch (gu::Exception&)
      {
          /* most probably no scheme, try to append one and see if it succeeds */
!         listen_addr_ = uri_string(get_scheme(use_ssl_), listen_addr_);
!         gu_trace(gu::URI uri(listen_addr_));
      }
  
!     gu::URI listen_uri(listen_addr_);
  
      if (check_tcp_uri(listen_uri) == false)
      {
!         gu_throw_error (EINVAL) << "listen addr '" << listen_addr_
                                  << "' does not specify supported protocol";
      }
  
!     if (gu::net::resolve(listen_uri).get_addr().is_anyaddr() == false)
      {
          // bind outgoing connections to the same address as listening.
!         gu_trace(bind_ip_ = listen_uri.get_host());
      }
  
!     std::string port(Defaults::GMCastTcpPort);
  
      try
      {
***************
*** 146,203 ****
              try { port = uri_.get_port(); } catch (gu::NotSet&) {}
          }
  
!         listen_addr += ":" + port;
      }
  
      // if (!conf_.has(BASE_PORT_KEY)) {
          conf_.set(BASE_PORT_KEY, port);
      // }
  
!     listen_addr = resolve(listen_addr).to_string();
      // resolving sets scheme to tcp, have to rewrite for ssl
!     if (use_ssl == true)
      {
!         listen_addr.replace(0, 3, SSL_SCHEME);
      }
  
!     if (initial_addrs.find(listen_addr) != initial_addrs.end())
      {
          gu_throw_error(EINVAL) << "connect address points to listen address '"
!                                << listen_addr
                                 << "', check that cluster address '"
                                 << uri.get_host() << ":" << port
                                 << "' is correct";
      }
  
!     if (mcast_addr != "")
      {
          try
          {
              port = uri_.get_option(Conf::GMCastMCastPort);
          }
!         catch (NotFound&) {}
  
!         mcast_addr = resolve(uri_string(UDP_SCHEME, mcast_addr, port)).to_string();
      }
  
!     log_info << self_string() << " listening at " << listen_addr;
!     log_info << self_string() << " multicast: " << mcast_addr
!              << ", ttl: " << mcast_ttl;
  
!     conf_.set(Conf::GMCastListenAddr, listen_addr);
!     conf_.set(Conf::GMCastMCastAddr, mcast_addr);
!     conf_.set(Conf::GMCastVersion, gu::to_string(version));
!     conf_.set(Conf::GMCastTimeWait, gu::to_string(time_wait));
!     conf_.set(Conf::GMCastMCastTTL, gu::to_string(mcast_ttl));
!     conf_.set(Conf::GMCastPeerTimeout, gu::to_string(peer_timeout));
  
  }
  
! GMCast::~GMCast()
  {
!     if (listener != 0) close();
  
!     delete proto_map;
  }
  
  void gcomm::GMCast::set_initial_addr(const gu::URI& uri)
--- 146,204 ----
              try { port = uri_.get_port(); } catch (gu::NotSet&) {}
          }
  
!         listen_addr_ += ":" + port;
      }
  
      // if (!conf_.has(BASE_PORT_KEY)) {
          conf_.set(BASE_PORT_KEY, port);
      // }
  
!         listen_addr_ = gu::net::resolve(listen_addr_).to_string();
      // resolving sets scheme to tcp, have to rewrite for ssl
!     if (use_ssl_ == true)
      {
!         listen_addr_.replace(0, 3, gcomm::SSL_SCHEME);
      }
  
!     if (initial_addrs_.find(listen_addr_) != initial_addrs_.end())
      {
          gu_throw_error(EINVAL) << "connect address points to listen address '"
!                                << listen_addr_
                                 << "', check that cluster address '"
                                 << uri.get_host() << ":" << port
                                 << "' is correct";
      }
  
!     if (mcast_addr_ != "")
      {
          try
          {
              port = uri_.get_option(Conf::GMCastMCastPort);
          }
!         catch (gu::NotFound&) {}
  
!         mcast_addr_ = gu::net::resolve(
!             uri_string(gcomm::UDP_SCHEME, mcast_addr_, port)).to_string();
      }
  
!     log_info << self_string() << " listening at " << listen_addr_;
!     log_info << self_string() << " multicast: " << mcast_addr_
!              << ", ttl: " << mcast_ttl_;
  
!     conf_.set(Conf::GMCastListenAddr, listen_addr_);
!     conf_.set(Conf::GMCastMCastAddr, mcast_addr_);
!     conf_.set(Conf::GMCastVersion, gu::to_string(version_));
!     conf_.set(Conf::GMCastTimeWait, gu::to_string(time_wait_));
!     conf_.set(Conf::GMCastMCastTTL, gu::to_string(mcast_ttl_));
!     conf_.set(Conf::GMCastPeerTimeout, gu::to_string(peer_timeout_));
  
  }
  
! gcomm::GMCast::~GMCast()
  {
!     if (listener_ != 0) close();
  
!     delete proto_map_;
  }
  
  void gcomm::GMCast::set_initial_addr(const gu::URI& uri)
***************
*** 220,226 ****
  
          if (host_is_any(host)) continue;
  
!         string port;
          try
          {
              port = i->port();
--- 221,227 ----
  
          if (host_is_any(host)) continue;
  
!         std::string port;
          try
          {
              port = i->port();
***************
*** 236,249 ****
                  port = Defaults::GMCastTcpPort;
              }
          }
!         std::string initial_addr = resolve(
!             uri_string(get_scheme(use_ssl), host, port)
              ).to_string();
  
          // resolving sets scheme to tcp, have to rewrite for ssl
!         if (use_ssl == true)
          {
!             initial_addr.replace(0, 3, SSL_SCHEME);
          }
  
          if (check_tcp_uri(initial_addr) == false)
--- 237,250 ----
                  port = Defaults::GMCastTcpPort;
              }
          }
!         std::string initial_addr = gu::net::resolve(
!             uri_string(get_scheme(use_ssl_), host, port)
              ).to_string();
  
          // resolving sets scheme to tcp, have to rewrite for ssl
!         if (use_ssl_ == true)
          {
!             initial_addr.replace(0, 3, gcomm::SSL_SCHEME);
          }
  
          if (check_tcp_uri(initial_addr) == false)
***************
*** 253,298 ****
          }
  
          log_debug << self_string() << " initial addr: " << initial_addr;
!         initial_addrs.insert(initial_addr);
  
      }
  
  }
  
  
! void GMCast::connect()
  {
      pstack_.push_proto(this);
!     log_debug << "gmcast " << get_uuid() << " connect";
  
!     URI listen_uri(listen_addr);
  
      set_tcp_defaults (&listen_uri);
  
!     listener = get_pnet().acceptor(listen_uri);
!     gu_trace (listener->listen(listen_uri));
  
!     if (!mcast_addr.empty())
      {
!         URI mcast_uri(
!             mcast_addr + '?'
!             + gcomm::Socket::OptIfAddr + '=' + URI(listen_addr).get_host()+'&'
              + gcomm::Socket::OptNonBlocking + "=1&"
!             + gcomm::Socket::OptMcastTTL    + '=' + to_string(mcast_ttl)
              );
  
!         mcast = get_pnet().socket(mcast_uri);
!         gu_trace(mcast->connect(mcast_uri));
      }
  
!     if (!initial_addrs.empty())
      {
!         for (std::set<std::string>::const_iterator i(initial_addrs.begin());
!              i != initial_addrs.end(); ++i)
          {
!             insert_address(*i, UUID(), pending_addrs);
!             AddrList::iterator ai(pending_addrs.find(*i));
!             AddrList::get_value(ai).set_max_retries(max_retry_cnt);
              gu_trace (gmcast_connect(*i));
          }
      }
--- 254,300 ----
          }
  
          log_debug << self_string() << " initial addr: " << initial_addr;
!         initial_addrs_.insert(initial_addr);
  
      }
  
  }
  
  
! void gcomm::GMCast::connect()
  {
      pstack_.push_proto(this);
!     log_debug << "gmcast " << uuid() << " connect";
  
!     gu::URI listen_uri(listen_addr_);
  
      set_tcp_defaults (&listen_uri);
  
!     listener_ = pnet().acceptor(listen_uri);
!     gu_trace (listener_->listen(listen_uri));
  
!     if (!mcast_addr_.empty())
      {
!         gu::URI mcast_uri(
!             mcast_addr_ + '?'
!             + gcomm::Socket::OptIfAddr + '='
!             + gu::URI(listen_addr_).get_host()+'&'
              + gcomm::Socket::OptNonBlocking + "=1&"
!             + gcomm::Socket::OptMcastTTL    + '=' + gu::to_string(mcast_ttl_)
              );
  
!         mcast_ = pnet().socket(mcast_uri);
!         gu_trace(mcast_->connect(mcast_uri));
      }
  
!     if (!initial_addrs_.empty())
      {
!         for (std::set<std::string>::const_iterator i(initial_addrs_.begin());
!              i != initial_addrs_.end(); ++i)
          {
!             insert_address(*i, UUID(), pending_addrs_);
!             AddrList::iterator ai(pending_addrs_.find(*i));
!             AddrList::value(ai).set_max_retries(max_retry_cnt_);
              gu_trace (gmcast_connect(*i));
          }
      }
***************
*** 307,374 ****
  
  
  
! void GMCast::close(bool force)
  {
!     log_debug << "gmcast " << get_uuid() << " close";
      pstack_.pop_proto(this);
!     if (mcast != 0)
      {
!         mcast->close();
          // delete mcast;
          // mcast = 0;
      }
  
!     gcomm_assert(listener != 0);
!     listener->close();
!     delete listener;
!     listener = 0;
  
!     mcast_tree.clear();
!     for (ProtoMap::iterator i = proto_map->begin(); i != proto_map->end(); ++i)
      {
!         delete ProtoMap::get_value(i);
      }
  
!     proto_map->clear();
!     pending_addrs.clear();
!     remote_addrs.clear();
  }
  
  
! void GMCast::gmcast_accept()
  {
      SocketPtr tp;
  
      try
      {
!         tp = listener->accept();
      }
!     catch (Exception& e)
      {
          log_warn << e.what();
          return;
      }
  
!     if (isolate == true)
      {
          log_debug << "dropping accepted socket due to isolation";
          tp->close();
          return;
      }
  
!     Proto* peer = new Proto (version, tp,
!                              listener->listen_addr() /* listen_addr */,
!                              "", mcast_addr,
!                              get_uuid(), group_name);
!     pair<ProtoMap::iterator, bool> ret =
!         proto_map->insert(make_pair(tp->get_id(), peer));
  
      if (ret.second == false)
      {
          delete peer;
          gu_throw_fatal << "Failed to add peer to map";
      }
!     if (tp->get_state() == Socket::S_CONNECTED)
      {
          peer->send_handshake();
      }
--- 309,378 ----
  
  
  
! void gcomm::GMCast::close(bool force)
  {
!     log_debug << "gmcast " << uuid() << " close";
      pstack_.pop_proto(this);
!     if (mcast_ != 0)
      {
!         mcast_->close();
          // delete mcast;
          // mcast = 0;
      }
  
!     gcomm_assert(listener_ != 0);
!     listener_->close();
!     delete listener_;
!     listener_ = 0;
  
!     mcast_tree_.clear();
!     for (ProtoMap::iterator
!              i = proto_map_->begin(); i != proto_map_->end(); ++i)
      {
!         delete ProtoMap::value(i);
      }
  
!     proto_map_->clear();
!     pending_addrs_.clear();
!     remote_addrs_.clear();
  }
  
  
! void gcomm::GMCast::gmcast_accept()
  {
      SocketPtr tp;
  
      try
      {
!         tp = listener_->accept();
      }
!     catch (gu::Exception& e)
      {
          log_warn << e.what();
          return;
      }
  
!     if (isolate_ == true)
      {
          log_debug << "dropping accepted socket due to isolation";
          tp->close();
          return;
      }
  
!     Proto* peer = new Proto (
!         version_, tp,
!         listener_->listen_addr() /* listen_addr */,
!         "", mcast_addr_,
!         uuid(), group_name_);
!     std::pair<ProtoMap::iterator, bool> ret =
!         proto_map_->insert(std::make_pair(tp->id(), peer));
  
      if (ret.second == false)
      {
          delete peer;
          gu_throw_fatal << "Failed to add peer to map";
      }
!     if (tp->state() == Socket::S_CONNECTED)
      {
          peer->send_handshake();
      }
***************
*** 380,421 ****
  }
  
  
! void GMCast::gmcast_connect(const string& remote_addr)
  {
!     if (remote_addr == listen_addr) return;
  
!     URI connect_uri(remote_addr);
  
      set_tcp_defaults (&connect_uri);
  
!     if (!bind_ip.empty())
      {
!         connect_uri.set_option(gcomm::Socket::OptIfAddr, bind_ip);
      }
  
!     SocketPtr tp = get_pnet().socket(connect_uri);
  
      try
      {
          tp->connect(connect_uri);
      }
!     catch (Exception& e)
      {
          log_debug << "Connect failed: " << e.what();
          // delete tp;
          return;
      }
  
!     Proto* peer = new Proto (version,
!                              tp,
!                              listener->listen_addr()/* listen_addr*/ ,
!                              remote_addr,
!                              mcast_addr,
!                              get_uuid(),
!                              group_name);
  
!     pair<ProtoMap::iterator, bool> ret =
!         proto_map->insert(make_pair(tp->get_id(), peer));
  
      if (ret.second == false)
      {
--- 384,426 ----
  }
  
  
! void gcomm::GMCast::gmcast_connect(const std::string& remote_addr)
  {
!     if (remote_addr == listen_addr_) return;
  
!     gu::URI connect_uri(remote_addr);
  
      set_tcp_defaults (&connect_uri);
  
!     if (!bind_ip_.empty())
      {
!         connect_uri.set_option(gcomm::Socket::OptIfAddr, bind_ip_);
      }
  
!     SocketPtr tp = pnet().socket(connect_uri);
  
      try
      {
          tp->connect(connect_uri);
      }
!     catch (gu::Exception& e)
      {
          log_debug << "Connect failed: " << e.what();
          // delete tp;
          return;
      }
  
!     Proto* peer = new Proto (
!         version_,
!         tp,
!         listener_->listen_addr()/* listen_addr*/ ,
!         remote_addr,
!         mcast_addr_,
!         uuid(),
!         group_name_);
  
!     std::pair<ProtoMap::iterator, bool> ret =
!         proto_map_->insert(std::make_pair(tp->id(), peer));
  
      if (ret.second == false)
      {
***************
*** 427,474 ****
  }
  
  
! void GMCast::gmcast_forget(const UUID& uuid)
  {
      /* Close all proto entries corresponding to uuid */
  
      ProtoMap::iterator pi, pi_next;
!     for (pi = proto_map->begin(); pi != proto_map->end(); pi = pi_next)
      {
          pi_next = pi, ++pi_next;
!         Proto* rp = ProtoMap::get_value(pi);
!         if (rp->get_remote_uuid() == uuid)
          {
              delete rp;
!             proto_map->erase(pi);
          }
      }
  
      /* Set all corresponding entries in address list to have retry cnt
       * greater than max retries and next reconnect time after some period */
      AddrList::iterator ai;
!     for (ai = remote_addrs.begin(); ai != remote_addrs.end(); ++ai)
      {
!         AddrEntry& ae(AddrList::get_value(ai));
!         if (ae.get_uuid() == uuid)
          {
              log_info << "forgetting " << uuid
!                      << " (" << AddrList::get_key(ai) << ")";
  
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map->begin(); pi != proto_map->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::get_value(pi);
!                 if (rp->get_remote_addr() == AddrList::get_key(ai))
                  {
!                     log_info << "deleting entry " << AddrList::get_key(ai);
                      delete rp;
!                     proto_map->erase(pi);
                  }
              }
              ae.set_max_retries(0);
              ae.set_retry_cnt(1);
!             ae.set_next_reconnect(Date::now() + time_wait);
          }
      }
  
--- 432,479 ----
  }
  
  
! void gcomm::GMCast::gmcast_forget(const UUID& uuid)
  {
      /* Close all proto entries corresponding to uuid */
  
      ProtoMap::iterator pi, pi_next;
!     for (pi = proto_map_->begin(); pi != proto_map_->end(); pi = pi_next)
      {
          pi_next = pi, ++pi_next;
!         Proto* rp = ProtoMap::value(pi);
!         if (rp->remote_uuid() == uuid)
          {
              delete rp;
!             proto_map_->erase(pi);
          }
      }
  
      /* Set all corresponding entries in address list to have retry cnt
       * greater than max retries and next reconnect time after some period */
      AddrList::iterator ai;
!     for (ai = remote_addrs_.begin(); ai != remote_addrs_.end(); ++ai)
      {
!         AddrEntry& ae(AddrList::value(ai));
!         if (ae.uuid() == uuid)
          {
              log_info << "forgetting " << uuid
!                      << " (" << AddrList::key(ai) << ")";
  
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map_->begin(); pi != proto_map_->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::value(pi);
!                 if (rp->remote_addr() == AddrList::key(ai))
                  {
!                     log_info << "deleting entry " << AddrList::key(ai);
                      delete rp;
!                     proto_map_->erase(pi);
                  }
              }
              ae.set_max_retries(0);
              ae.set_retry_cnt(1);
!             ae.set_next_reconnect(gu::datetime::Date::now() + time_wait_);
          }
      }
  
***************
*** 476,487 ****
      update_addresses();
  }
  
! void GMCast::handle_connected(Proto* rp)
  {
!     const SocketPtr tp(rp->get_socket());
!     assert(tp->get_state() == Socket::S_CONNECTED);
      log_debug << "transport " << tp << " connected";
!     if (rp->get_state() == Proto::S_INIT)
      {
          log_debug << "sending hanshake";
          // accepted socket was waiting for underlying transport
--- 481,492 ----
      update_addresses();
  }
  
! void gcomm::GMCast::handle_connected(Proto* rp)
  {
!     const SocketPtr tp(rp->socket());
!     assert(tp->state() == Socket::S_CONNECTED);
      log_debug << "transport " << tp << " connected";
!     if (rp->state() == Proto::S_INIT)
      {
          log_debug << "sending hanshake";
          // accepted socket was waiting for underlying transport
***************
*** 490,609 ****
      }
  }
  
! void GMCast::handle_established(Proto* est)
  {
      log_debug << self_string() << " connection established to "
!               << est->get_remote_uuid() << " "
!               << est->get_remote_addr();
  
!     if (est->get_remote_uuid() == get_uuid())
      {
          std::set<std::string>::iterator
!             ia_i(initial_addrs.find(est->get_remote_addr()));
!         if (ia_i != initial_addrs.end())
          {
!             initial_addrs.erase(ia_i);
          }
!         AddrList::iterator i(pending_addrs.find(est->get_remote_addr()));
!         if (i != pending_addrs.end())
          {
              log_warn << self_string()
!                      << " address '" << est->get_remote_addr()
                       << "' points to own listening address, blacklisting";
!             pending_addrs.erase(i);
!             addr_blacklist.insert(make_pair(est->get_remote_addr(),
!                                             AddrEntry(Date::now(),
!                                                       Date::now(),
!                                                       est->get_remote_uuid())));
          }
!         proto_map->erase(
!             proto_map->find_checked(est->get_socket()->get_id()));
          delete est;
          update_addresses();
          return;
      }
  
!     // If address is found from pending_addrs, move it to remote_addrs list
      // and set retry cnt to -1
!     const string& remote_addr(est->get_remote_addr());
!     AddrList::iterator i(pending_addrs.find(remote_addr));
  
!     if (i != pending_addrs.end())
      {
          log_debug << "Erasing " << remote_addr << " from panding list";
!         pending_addrs.erase(i);
      }
  
!     if ((i = remote_addrs.find(remote_addr)) == remote_addrs.end())
      {
          log_debug << "Inserting " << remote_addr << " to remote list";
  
!         insert_address (remote_addr, est->get_remote_uuid(), remote_addrs);
!         i = remote_addrs.find(remote_addr);
      }
!     else if (AddrList::get_value(i).get_uuid() != est->get_remote_uuid())
      {
!         log_info << "remote endpoint " << est->get_remote_addr()
!                  << " changed identity " << AddrList::get_value(i).get_uuid()
!                  << " -> " << est->get_remote_uuid();
!         remote_addrs.erase(i);
!         i = remote_addrs.insert_unique(
!             make_pair(est->get_remote_addr(),
!                       AddrEntry(Date::now(),
!                                 Date::max(),
!                                 est->get_remote_uuid())));
      }
  
!     if (AddrList::get_value(i).get_retry_cnt() >
!         AddrList::get_value(i).get_max_retries())
      {
          log_warn << "discarding established (time wait) "
!                  << est->get_remote_uuid()
!                  << " (" << est->get_remote_addr() << ") ";
!         proto_map->erase(proto_map->find(est->get_socket()->get_id()));
          delete est;
          update_addresses();
          return;
      }
  
!     // send_up(Datagram(), p->get_remote_uuid());
  
      // init retry cnt to -1 to avoid unnecessary logging at first attempt
      // max retries will be readjusted in handle stable view
!     AddrList::get_value(i).set_retry_cnt(-1);
!     AddrList::get_value(i).set_max_retries(max_initial_reconnect_attempts);
  
      // Cleanup all previously established entries with same
      // remote uuid. It is assumed that the most recent connection
      // is usually the healthiest one.
      ProtoMap::iterator j, j_next;
!     for (j = proto_map->begin(); j != proto_map->end(); j = j_next)
      {
          j_next = j, ++j_next;
  
!         Proto* p(ProtoMap::get_value(j));
  
!         if (p->get_remote_uuid() == est->get_remote_uuid())
          {
!             if (p->get_handshake_uuid() < est->get_handshake_uuid())
              {
                  log_info << self_string()
                            << " cleaning up duplicate "
!                           << p->get_socket()
                            << " after established "
!                           << est->get_socket();
!                 proto_map->erase(j);
                  delete p;
              }
!             else if (p->get_handshake_uuid() > est->get_handshake_uuid())
              {
                  log_info << self_string()
                           << " cleaning up established "
!                          << est->get_socket()
                           << " which is duplicate of "
!                          << p->get_socket();
!                 proto_map->erase(
!                     proto_map->find_checked(est->get_socket()->get_id()));
                  delete est;
                  break;
              }
--- 495,614 ----
      }
  }
  
! void gcomm::GMCast::handle_established(Proto* est)
  {
      log_debug << self_string() << " connection established to "
!               << est->remote_uuid() << " "
!               << est->remote_addr();
  
!     if (est->remote_uuid() == uuid())
      {
          std::set<std::string>::iterator
!             ia_i(initial_addrs_.find(est->remote_addr()));
!         if (ia_i != initial_addrs_.end())
          {
!             initial_addrs_.erase(ia_i);
          }
!         AddrList::iterator i(pending_addrs_.find(est->remote_addr()));
!         if (i != pending_addrs_.end())
          {
              log_warn << self_string()
!                      << " address '" << est->remote_addr()
                       << "' points to own listening address, blacklisting";
!             pending_addrs_.erase(i);
!             addr_blacklist_.insert(make_pair(est->remote_addr(),
!                                              AddrEntry(gu::datetime::Date::now(),
!                                                        gu::datetime::Date::now(),
!                                                        est->remote_uuid())));
          }
!         proto_map_->erase(
!             proto_map_->find_checked(est->socket()->id()));
          delete est;
          update_addresses();
          return;
      }
  
!     // If address is found from pending_addrs_, move it to remote_addrs list
      // and set retry cnt to -1
!     const std::string& remote_addr(est->remote_addr());
!     AddrList::iterator i(pending_addrs_.find(remote_addr));
  
!     if (i != pending_addrs_.end())
      {
          log_debug << "Erasing " << remote_addr << " from panding list";
!         pending_addrs_.erase(i);
      }
  
!     if ((i = remote_addrs_.find(remote_addr)) == remote_addrs_.end())
      {
          log_debug << "Inserting " << remote_addr << " to remote list";
  
!         insert_address (remote_addr, est->remote_uuid(), remote_addrs_);
!         i = remote_addrs_.find(remote_addr);
      }
!     else if (AddrList::value(i).uuid() != est->remote_uuid())
      {
!         log_info << "remote endpoint " << est->remote_addr()
!                  << " changed identity " << AddrList::value(i).uuid()
!                  << " -> " << est->remote_uuid();
!         remote_addrs_.erase(i);
!         i = remote_addrs_.insert_unique(
!             make_pair(est->remote_addr(),
!                       AddrEntry(gu::datetime::Date::now(),
!                                 gu::datetime::Date::max(),
!                                 est->remote_uuid())));
      }
  
!     if (AddrList::value(i).retry_cnt() >
!         AddrList::value(i).max_retries())
      {
          log_warn << "discarding established (time wait) "
!                  << est->remote_uuid()
!                  << " (" << est->remote_addr() << ") ";
!         proto_map_->erase(proto_map_->find(est->socket()->id()));
          delete est;
          update_addresses();
          return;
      }
  
!     // send_up(Datagram(), p->remote_uuid());
  
      // init retry cnt to -1 to avoid unnecessary logging at first attempt
      // max retries will be readjusted in handle stable view
!     AddrList::value(i).set_retry_cnt(-1);
!     AddrList::value(i).set_max_retries(max_initial_reconnect_attempts_);
  
      // Cleanup all previously established entries with same
      // remote uuid. It is assumed that the most recent connection
      // is usually the healthiest one.
      ProtoMap::iterator j, j_next;
!     for (j = proto_map_->begin(); j != proto_map_->end(); j = j_next)
      {
          j_next = j, ++j_next;
  
!         Proto* p(ProtoMap::value(j));
  
!         if (p->remote_uuid() == est->remote_uuid())
          {
!             if (p->handshake_uuid() < est->handshake_uuid())
              {
                  log_info << self_string()
                            << " cleaning up duplicate "
!                           << p->socket()
                            << " after established "
!                           << est->socket();
!                 proto_map_->erase(j);
                  delete p;
              }
!             else if (p->handshake_uuid() > est->handshake_uuid())
              {
                  log_info << self_string()
                           << " cleaning up established "
!                          << est->socket()
                           << " which is duplicate of "
!                          << p->socket();
!                 proto_map_->erase(
!                     proto_map_->find_checked(est->socket()->id()));
                  delete est;
                  break;
              }
***************
*** 617,635 ****
      update_addresses();
  }
  
! void GMCast::handle_failed(Proto* failed)
  {
      log_debug << "handle failed: " << *failed;
!     const string& remote_addr = failed->get_remote_addr();
  
      bool found_ok(false);
!     for (ProtoMap::const_iterator i = proto_map->begin();
!          i != proto_map->end(); ++i)
      {
!         Proto* p(ProtoMap::get_value(i));
          if (p                    != failed      &&
!             p->get_state()       <= Proto::S_OK &&
!             p->get_remote_addr() == failed->get_remote_addr())
          {
              log_debug << "found live " << *p;
              found_ok = true;
--- 622,640 ----
      update_addresses();
  }
  
! void gcomm::GMCast::handle_failed(Proto* failed)
  {
      log_debug << "handle failed: " << *failed;
!     const std::string& remote_addr = failed->remote_addr();
  
      bool found_ok(false);
!     for (ProtoMap::const_iterator i = proto_map_->begin();
!          i != proto_map_->end(); ++i)
      {
!         Proto* p(ProtoMap::value(i));
          if (p                    != failed      &&
!             p->state()       <= Proto::S_OK &&
!             p->remote_addr() == failed->remote_addr())
          {
              log_debug << "found live " << *p;
              found_ok = true;
***************
*** 641,653 ****
      {
          AddrList::iterator i;
  
!         if ((i = pending_addrs.find(remote_addr)) != pending_addrs.end() ||
!             (i = remote_addrs.find(remote_addr))  != remote_addrs.end())
          {
!             AddrEntry& ae(AddrList::get_value(i));
!             ae.set_retry_cnt(ae.get_retry_cnt() + 1);
  
!             Date rtime = Date::now() + Period("PT1S");
              log_debug << self_string()
                        << " setting next reconnect time to "
                        << rtime << " for " << remote_addr;
--- 646,658 ----
      {
          AddrList::iterator i;
  
!         if ((i = pending_addrs_.find(remote_addr)) != pending_addrs_.end() ||
!             (i = remote_addrs_.find(remote_addr))  != remote_addrs_.end())
          {
!             AddrEntry& ae(AddrList::value(i));
!             ae.set_retry_cnt(ae.retry_cnt() + 1);
  
!             gu::datetime::Date rtime = gu::datetime::Date::now() + gu::datetime::Period("PT1S");
              log_debug << self_string()
                        << " setting next reconnect time to "
                        << rtime << " for " << remote_addr;
***************
*** 655,675 ****
          }
      }
  
!     proto_map->erase(failed->get_socket()->get_id());
      delete failed;
      update_addresses();
  }
  
  
! bool GMCast::is_connected(const string& addr, const UUID& uuid) const
  {
!     for (ProtoMap::const_iterator i = proto_map->begin();
!          i != proto_map->end(); ++i)
      {
!         Proto* conn = ProtoMap::get_value(i);
  
!         if (addr == conn->get_remote_addr() ||
!             uuid == conn->get_remote_uuid())
          {
              return true;
          }
--- 660,680 ----
          }
      }
  
!     proto_map_->erase(failed->socket()->id());
      delete failed;
      update_addresses();
  }
  
  
! bool gcomm::GMCast::is_connected(const std::string& addr, const UUID& uuid) const
  {
!     for (ProtoMap::const_iterator i = proto_map_->begin();
!          i != proto_map_->end(); ++i)
      {
!         Proto* conn = ProtoMap::value(i);
  
!         if (addr == conn->remote_addr() ||
!             uuid == conn->remote_uuid())
          {
              return true;
          }
***************
*** 679,696 ****
  }
  
  
! void GMCast::insert_address (const string& addr,
                               const UUID&   uuid,
                               AddrList&     alist)
  {
!     if (addr == listen_addr)
      {
          gu_throw_fatal << "Trying to add self addr " << addr << " to addr list";
      }
  
      if (alist.insert(make_pair(addr,
!                                AddrEntry(Date::now(),
!                                          Date::now(), uuid))).second == false)
      {
          log_warn << "Duplicate entry: " << addr;
      }
--- 684,701 ----
  }
  
  
! void gcomm::GMCast::insert_address (const std::string& addr,
                               const UUID&   uuid,
                               AddrList&     alist)
  {
!     if (addr == listen_addr_)
      {
          gu_throw_fatal << "Trying to add self addr " << addr << " to addr list";
      }
  
      if (alist.insert(make_pair(addr,
!                                AddrEntry(gu::datetime::Date::now(),
!                                          gu::datetime::Date::now(), uuid))).second == false)
      {
          log_warn << "Duplicate entry: " << addr;
      }
***************
*** 702,786 ****
  }
  
  
! void GMCast::update_addresses()
  {
      LinkMap link_map;
!     set<UUID> uuids;
      /* Add all established connections into uuid_map and update
       * list of remote addresses */
  
      ProtoMap::iterator i, i_next;
!     for (i = proto_map->begin(); i != proto_map->end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         Proto* rp = ProtoMap::get_value(i);
  
!         if (rp->get_state() == Proto::S_OK)
          {
!             if (rp->get_remote_addr() == "" ||
!                 rp->get_remote_uuid() == UUID::nil())
              {
!                 gu_throw_fatal << "Protocol error: local: (" << my_uuid
!                                << ", '" << listen_addr
!                                << "'), remote: (" << rp->get_remote_uuid()
!                                << ", '" << rp->get_remote_addr() << "')";
              }
  
!             if (remote_addrs.find(rp->get_remote_addr()) == remote_addrs.end())
              {
                  log_warn << "Connection exists but no addr on addr list for "
!                          << rp->get_remote_addr();
!                 insert_address(rp->get_remote_addr(), rp->get_remote_uuid(),
!                                remote_addrs);
              }
  
!             if (uuids.insert(rp->get_remote_uuid()).second == false)
              {
                  // Duplicate entry, drop this one
                  // @todo Deeper inspection about the connection states
                  log_debug << self_string() << " dropping duplicate entry";
!                 proto_map->erase(i);
                  delete rp;
              }
              else
              {
!                 link_map.insert(Link(rp->get_remote_uuid(),
!                                      rp->get_remote_addr(),
!                                      rp->get_mcast_addr()));
              }
          }
      }
  
      /* Send topology change message containing only established
       * connections */
!     for (ProtoMap::iterator i = proto_map->begin(); i != proto_map->end(); ++i)
      {
!         Proto* gp = ProtoMap::get_value(i);
  
          // @todo: a lot of stuff here is done for each connection, including
          //        message creation and serialization. Need a mcast_msg() call
          //        and move this loop in there.
!         if (gp->get_state() == Proto::S_OK)
              gp->send_topology_change(link_map);
      }
  
      /* Add entries reported by all other nodes to address list to
       * get complete view of existing uuids/addresses */
!     for (ProtoMap::iterator i = proto_map->begin(); i != proto_map->end(); ++i)
      {
!         Proto* rp = ProtoMap::get_value(i);
  
!         if (rp->get_state() == Proto::S_OK)
          {
!             for (LinkMap::const_iterator j = rp->get_link_map().begin();
!                  j != rp->get_link_map().end(); ++j)
              {
!                 const UUID& link_uuid(LinkMap::get_key(j));
!                 const string& link_addr(LinkMap::get_value(j).get_addr());
                  gcomm_assert(link_uuid != UUID::nil() && link_addr != "");
  
!                 if (addr_blacklist.find(link_addr) != addr_blacklist.end())
                  {
                      log_info << self_string()
                               << " address '" << link_addr
--- 707,791 ----
  }
  
  
! void gcomm::GMCast::update_addresses()
  {
      LinkMap link_map;
!     std::set<UUID> uuids;
      /* Add all established connections into uuid_map and update
       * list of remote addresses */
  
      ProtoMap::iterator i, i_next;
!     for (i = proto_map_->begin(); i != proto_map_->end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         Proto* rp = ProtoMap::value(i);
  
!         if (rp->state() == Proto::S_OK)
          {
!             if (rp->remote_addr() == "" ||
!                 rp->remote_uuid() == UUID::nil())
              {
!                 gu_throw_fatal << "Protocol error: local: (" << my_uuid_
!                                << ", '" << listen_addr_
!                                << "'), remote: (" << rp->remote_uuid()
!                                << ", '" << rp->remote_addr() << "')";
              }
  
!             if (remote_addrs_.find(rp->remote_addr()) == remote_addrs_.end())
              {
                  log_warn << "Connection exists but no addr on addr list for "
!                          << rp->remote_addr();
!                 insert_address(rp->remote_addr(), rp->remote_uuid(),
!                                remote_addrs_);
              }
  
!             if (uuids.insert(rp->remote_uuid()).second == false)
              {
                  // Duplicate entry, drop this one
                  // @todo Deeper inspection about the connection states
                  log_debug << self_string() << " dropping duplicate entry";
!                 proto_map_->erase(i);
                  delete rp;
              }
              else
              {
!                 link_map.insert(Link(rp->remote_uuid(),
!                                      rp->remote_addr(),
!                                      rp->mcast_addr()));
              }
          }
      }
  
      /* Send topology change message containing only established
       * connections */
!     for (ProtoMap::iterator i = proto_map_->begin(); i != proto_map_->end(); ++i)
      {
!         Proto* gp = ProtoMap::value(i);
  
          // @todo: a lot of stuff here is done for each connection, including
          //        message creation and serialization. Need a mcast_msg() call
          //        and move this loop in there.
!         if (gp->state() == Proto::S_OK)
              gp->send_topology_change(link_map);
      }
  
      /* Add entries reported by all other nodes to address list to
       * get complete view of existing uuids/addresses */
!     for (ProtoMap::iterator i = proto_map_->begin(); i != proto_map_->end(); ++i)
      {
!         Proto* rp = ProtoMap::value(i);
  
!         if (rp->state() == Proto::S_OK)
          {
!             for (LinkMap::const_iterator j = rp->link_map().begin();
!                  j != rp->link_map().end(); ++j)
              {
!                 const UUID& link_uuid(LinkMap::key(j));
!                 const std::string& link_addr(LinkMap::value(j).addr());
                  gcomm_assert(link_uuid != UUID::nil() && link_addr != "");
  
!                 if (addr_blacklist_.find(link_addr) != addr_blacklist_.end())
                  {
                      log_info << self_string()
                               << " address '" << link_addr
***************
*** 789,822 ****
                      continue;
                  }
  
!                 if (link_uuid                     != get_uuid()         &&
!                     remote_addrs.find(link_addr)  == remote_addrs.end() &&
!                     pending_addrs.find(link_addr) == pending_addrs.end())
                  {
                      log_debug << self_string()
                                << " conn refers to but no addr in addr list for "
                                << link_addr;
!                     insert_address(link_addr, link_uuid, remote_addrs);
  
!                     AddrList::iterator pi(remote_addrs.find(link_addr));
  
!                     assert(pi != remote_addrs.end());
  
!                     AddrEntry& ae(AddrList::get_value(pi));
  
                      // init retry cnt to -1 to avoid unnecessary logging
                      // at first attempt
                      // max retries will be readjusted in handle stable view
                      ae.set_retry_cnt(-1);
!                     ae.set_max_retries(max_initial_reconnect_attempts);
  
                      // Add some randomness for first reconnect to avoid
                      // simultaneous connects
!                     Date rtime(Date::now());
  
!                     rtime = rtime + ::rand() % (100*MSec);
                      ae.set_next_reconnect(rtime);
!                     next_check = min(next_check, rtime);
                  }
              }
          }
--- 794,827 ----
                      continue;
                  }
  
!                 if (link_uuid                     != uuid()         &&
!                     remote_addrs_.find(link_addr)  == remote_addrs_.end() &&
!                     pending_addrs_.find(link_addr) == pending_addrs_.end())
                  {
                      log_debug << self_string()
                                << " conn refers to but no addr in addr list for "
                                << link_addr;
!                     insert_address(link_addr, link_uuid, remote_addrs_);
  
!                     AddrList::iterator pi(remote_addrs_.find(link_addr));
  
!                     assert(pi != remote_addrs_.end());
  
!                     AddrEntry& ae(AddrList::value(pi));
  
                      // init retry cnt to -1 to avoid unnecessary logging
                      // at first attempt
                      // max retries will be readjusted in handle stable view
                      ae.set_retry_cnt(-1);
!                     ae.set_max_retries(max_initial_reconnect_attempts_);
  
                      // Add some randomness for first reconnect to avoid
                      // simultaneous connects
!                     gu::datetime::Date rtime(gu::datetime::Date::now());
  
!                     rtime = rtime + ::rand() % (100*gu::datetime::MSec);
                      ae.set_next_reconnect(rtime);
!                     next_check_ = std::min(next_check_, rtime);
                  }
              }
          }
***************
*** 824,860 ****
  
      // Build multicast tree
      log_debug << self_string() << " --- mcast tree begin ---";
!     mcast_tree.clear();
  
!     if (mcast != 0)
      {
!         log_debug << mcast_addr;
!         mcast_tree.push_back(mcast.get());
      }
  
!     for (ProtoMap::const_iterator i(proto_map->begin()); i != proto_map->end();
           ++i)
      {
!         const Proto& p(*ProtoMap::get_value(i));
  
!         log_debug << "Proto: " << p.get_state() << " " << p.get_remote_addr()
!                   << " " << p.get_mcast_addr();
  
!         if (p.get_state() == Proto::S_OK &&
!             (p.get_mcast_addr() == "" ||
!              p.get_mcast_addr() != mcast_addr))
          {
!             log_debug << p.get_remote_addr();
!             mcast_tree.push_back(p.get_socket().get());
          }
      }
      log_debug << self_string() << " --- mcast tree end ---";
  }
  
  
! void GMCast::reconnect()
  {
!     if (isolate == true)
      {
          log_debug << "skipping reconnect due to isolation";
          return;
--- 829,865 ----
  
      // Build multicast tree
      log_debug << self_string() << " --- mcast tree begin ---";
!     mcast_tree_.clear();
  
!     if (mcast_ != 0)
      {
!         log_debug << mcast_addr_;
!         mcast_tree_.push_back(mcast_.get());
      }
  
!     for (ProtoMap::const_iterator i(proto_map_->begin()); i != proto_map_->end();
           ++i)
      {
!         const Proto& p(*ProtoMap::value(i));
  
!         log_debug << "Proto: " << p.state() << " " << p.remote_addr()
!                   << " " << p.mcast_addr();
  
!         if (p.state() == Proto::S_OK &&
!             (p.mcast_addr() == "" ||
!              p.mcast_addr() != mcast_addr_))
          {
!             log_debug << p.remote_addr();
!             mcast_tree_.push_back(p.socket().get());
          }
      }
      log_debug << self_string() << " --- mcast tree end ---";
  }
  
  
! void gcomm::GMCast::reconnect()
  {
!     if (isolate_ == true)
      {
          log_debug << "skipping reconnect due to isolation";
          return;
***************
*** 862,887 ****
  
      /* Loop over known remote addresses and connect if proto entry
       * does not exist */
!     Date now = Date::now();
      AddrList::iterator i, i_next;
  
!     for (i = pending_addrs.begin(); i != pending_addrs.end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         const string& pending_addr(AddrList::get_key(i));
!         const AddrEntry& ae(AddrList::get_value(i));
  
          if (is_connected (pending_addr, UUID::nil()) == false &&
!             ae.get_next_reconnect()                  <= now)
          {
!             if (ae.get_retry_cnt() > ae.get_max_retries())
              {
                  log_info << "cleaning up pending addr " << pending_addr;
!                 pending_addrs.erase(i);
                  continue; // no reference to pending_addr after this
              }
!             else if (ae.get_next_reconnect() <= now)
              {
                  log_debug << "connecting to pending " << pending_addr;
                  gmcast_connect (pending_addr);
--- 867,892 ----
  
      /* Loop over known remote addresses and connect if proto entry
       * does not exist */
!     gu::datetime::Date now = gu::datetime::Date::now();
      AddrList::iterator i, i_next;
  
!     for (i = pending_addrs_.begin(); i != pending_addrs_.end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         const std::string& pending_addr(AddrList::key(i));
!         const AddrEntry& ae(AddrList::value(i));
  
          if (is_connected (pending_addr, UUID::nil()) == false &&
!             ae.next_reconnect()                  <= now)
          {
!             if (ae.retry_cnt() > ae.max_retries())
              {
                  log_info << "cleaning up pending addr " << pending_addr;
!                 pending_addrs_.erase(i);
                  continue; // no reference to pending_addr after this
              }
!             else if (ae.next_reconnect() <= now)
              {
                  log_debug << "connecting to pending " << pending_addr;
                  gmcast_connect (pending_addr);
***************
*** 890,922 ****
      }
  
  
!     for (i = remote_addrs.begin(); i != remote_addrs.end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         const string& remote_addr(AddrList::get_key(i));
!         const AddrEntry& ae(AddrList::get_value(i));
!         const UUID& remote_uuid(ae.get_uuid());
  
!         gcomm_assert(remote_uuid != get_uuid());
  
          if (is_connected(remote_addr, remote_uuid) == false &&
!             ae.get_next_reconnect()                <= now)
          {
!             if (ae.get_retry_cnt() > ae.get_max_retries())
              {
                  log_info << " cleaning up " << remote_uuid << " ("
                           << remote_addr << ")";
!                 remote_addrs.erase(i);
                  continue;//no reference to remote_addr or remote_uuid after this
              }
!             else if (ae.get_next_reconnect() <= now)
              {
!                 if (ae.get_retry_cnt() % 30 == 0)
                  {
                      log_info << self_string() << " reconnecting to "
                               << remote_uuid << " (" << remote_addr
!                              << "), attempt " << ae.get_retry_cnt();
                  }
  
                  gmcast_connect(remote_addr);
--- 895,927 ----
      }
  
  
!     for (i = remote_addrs_.begin(); i != remote_addrs_.end(); i = i_next)
      {
          i_next = i, ++i_next;
  
!         const std::string& remote_addr(AddrList::key(i));
!         const AddrEntry& ae(AddrList::value(i));
!         const UUID& remote_uuid(ae.uuid());
  
!         gcomm_assert(remote_uuid != uuid());
  
          if (is_connected(remote_addr, remote_uuid) == false &&
!             ae.next_reconnect()                <= now)
          {
!             if (ae.retry_cnt() > ae.max_retries())
              {
                  log_info << " cleaning up " << remote_uuid << " ("
                           << remote_addr << ")";
!                 remote_addrs_.erase(i);
                  continue;//no reference to remote_addr or remote_uuid after this
              }
!             else if (ae.next_reconnect() <= now)
              {
!                 if (ae.retry_cnt() % 30 == 0)
                  {
                      log_info << self_string() << " reconnecting to "
                               << remote_uuid << " (" << remote_addr
!                              << "), attempt " << ae.retry_cnt();
                  }
  
                  gmcast_connect(remote_addr);
***************
*** 936,962 ****
  
      // iterate over proto map and mark all timed out entries as failed
      gu::datetime::Date now(gu::datetime::Date::now());
!     for (ProtoMap::iterator i(proto_map->begin()); i != proto_map->end(); )
      {
          ProtoMap::iterator i_next(i);
          ++i_next;
!         Proto* p(ProtoMap::get_value(i));
!         if (p->get_state() > Proto::S_INIT &&
!             p->get_state() < Proto::S_FAILED &&
!             p->get_tstamp() + peer_timeout < now)
          {
              log_debug << self_string()
                        << " connection to peer "
!                       << p->get_remote_uuid() << " with addr "
!                       << p->get_remote_addr()
                        << " timed out";
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
!         else if (p->get_state() == Proto::S_OK)
          {
              // log_info << "live proto " << *p;
!             live_uuids.insert(p->get_remote_uuid());
          }
          i = i_next;
      }
--- 941,967 ----
  
      // iterate over proto map and mark all timed out entries as failed
      gu::datetime::Date now(gu::datetime::Date::now());
!     for (ProtoMap::iterator i(proto_map_->begin()); i != proto_map_->end(); )
      {
          ProtoMap::iterator i_next(i);
          ++i_next;
!         Proto* p(ProtoMap::value(i));
!         if (p->state() > Proto::S_INIT &&
!             p->state() < Proto::S_FAILED &&
!             p->tstamp() + peer_timeout_ < now)
          {
              log_debug << self_string()
                        << " connection to peer "
!                       << p->remote_uuid() << " with addr "
!                       << p->remote_addr()
                        << " timed out";
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
!         else if (p->state() == Proto::S_OK)
          {
              // log_info << "live proto " << *p;
!             live_uuids.insert(p->remote_uuid());
          }
          i = i_next;
      }
***************
*** 967,1014 ****
      // proto entry associated to each addr entry
  
      std::string nonlive_peers;
!     for (AddrList::const_iterator i(remote_addrs.begin());
!          i != remote_addrs.end(); ++i)
      {
!         const AddrEntry& ae(AddrList::get_value(i));
!         if (ae.get_retry_cnt()             <= ae.get_max_retries() &&
!             live_uuids.find(ae.get_uuid()) == live_uuids.end())
          {
              // log_info << self_string()
!             // << " missing live proto entry for " << ae.get_uuid();
!             nonlive_peers += AddrList::get_key(i) + " ";
              should_relay = true;
          }
      }
  
!     if (relaying == false && should_relay == true)
      {
          log_info << self_string()
                   << " turning message relay requesting on, nonlive peers: "
                   << nonlive_peers;
!         relaying = true;
      }
!     else if (relaying == true && should_relay == false)
      {
          log_info << self_string() << " turning message relay requesting off";
!         relaying = false;
      }
  
  }
  
  
! Date gcomm::GMCast::handle_timers()
  {
!     const Date now(Date::now());
  
!     if (now >= next_check)
      {
          check_liveness();
          reconnect();
!         next_check = now + check_period;
      }
  
!     return next_check;
  }
  
  
--- 972,1019 ----
      // proto entry associated to each addr entry
  
      std::string nonlive_peers;
!     for (AddrList::const_iterator i(remote_addrs_.begin());
!          i != remote_addrs_.end(); ++i)
      {
!         const AddrEntry& ae(AddrList::value(i));
!         if (ae.retry_cnt()             <= ae.max_retries() &&
!             live_uuids.find(ae.uuid()) == live_uuids.end())
          {
              // log_info << self_string()
!             // << " missing live proto entry for " << ae.uuid();
!             nonlive_peers += AddrList::key(i) + " ";
              should_relay = true;
          }
      }
  
!     if (relaying_ == false && should_relay == true)
      {
          log_info << self_string()
                   << " turning message relay requesting on, nonlive peers: "
                   << nonlive_peers;
!         relaying_ = true;
      }
!     else if (relaying_ == true && should_relay == false)
      {
          log_info << self_string() << " turning message relay requesting off";
!         relaying_ = false;
      }
  
  }
  
  
! gu::datetime::Date gcomm::GMCast::handle_timers()
  {
!     const gu::datetime::Date now(gu::datetime::Date::now());
  
!     if (now >= next_check_)
      {
          check_liveness();
          reconnect();
!         next_check_ = now + check_period_;
      }
  
!     return next_check_;
  }
  
  
***************
*** 1016,1030 ****
                            const void* exclude_id)
  {
      Message relay_msg(msg);
!     relay_msg.set_flags(relay_msg.get_flags() & ~Message::F_RELAY);
      Datagram relay_dg(dg);
      relay_dg.normalize();
      gu_trace(push_header(relay_msg, relay_dg));
!     for (list<Socket*>::iterator i(mcast_tree.begin());
!          i != mcast_tree.end(); ++i)
      {
          int err;
!         if ((*i)->get_id() != exclude_id &&
              (err = (*i)->send(relay_dg)) != 0)
          {
              log_debug << "transport: " << ::strerror(err);
--- 1021,1035 ----
                            const void* exclude_id)
  {
      Message relay_msg(msg);
!     relay_msg.set_flags(relay_msg.flags() & ~Message::F_RELAY);
      Datagram relay_dg(dg);
      relay_dg.normalize();
      gu_trace(push_header(relay_msg, relay_dg));
!     for (std::list<Socket*>::iterator i(mcast_tree_.begin());
!          i != mcast_tree_.end(); ++i)
      {
          int err;
!         if ((*i)->id() != exclude_id &&
              (err = (*i)->send(relay_dg)) != 0)
          {
              log_debug << "transport: " << ::strerror(err);
***************
*** 1032,1093 ****
      }
  }
  
! void GMCast::handle_up(const void*        id,
                         const Datagram&    dg,
                         const ProtoUpMeta& um)
  {
      ProtoMap::iterator i;
  
!     if (listener == 0) { return; }
  
!     if (id == listener->get_id())
      {
          gmcast_accept();
      }
!     else if (mcast.get() != 0 && id == mcast->get_id())
      {
          Message msg;
  
          try
          {
!             if (dg.get_offset() < dg.get_header_len())
              {
!                 gu_trace(msg.unserialize(dg.get_header(), dg.get_header_size(),
!                                          dg.get_header_offset() +
!                                          dg.get_offset()));
              }
              else
              {
!                 gu_trace(msg.unserialize(&dg.get_payload()[0],
!                                          dg.get_len(),
!                                          dg.get_offset()));
              }
          }
!         catch (Exception& e)
          {
              GU_TRACE(e);
              log_warn << e.what();
              return;
          }
  
!         if (msg.get_type() >= Message::T_USER_BASE)
          {
!             gu_trace(send_up(Datagram(dg, dg.get_offset() + msg.serial_size()),
!                              ProtoUpMeta(msg.get_source_uuid())));
          }
          else
          {
!             log_warn << "non-user message " << msg.get_type()
                       << " from multicast socket";
          }
      }
!     else if ((i = proto_map->find(id)) != proto_map->end())
      {
!         Proto* p(ProtoMap::get_value(i));
  
!         if (dg.get_len() > 0)
          {
!             const Proto::State prev_state(p->get_state());
  
              if (prev_state == Proto::S_FAILED)
              {
--- 1037,1098 ----
      }
  }
  
! void gcomm::GMCast::handle_up(const void*        id,
                         const Datagram&    dg,
                         const ProtoUpMeta& um)
  {
      ProtoMap::iterator i;
  
!     if (listener_ == 0) { return; }
  
!     if (id == listener_->id())
      {
          gmcast_accept();
      }
!     else if (mcast_.get() != 0 && id == mcast_->id())
      {
          Message msg;
  
          try
          {
!             if (dg.offset() < dg.header_len())
              {
!                 gu_trace(msg.unserialize(dg.header(), dg.header_size(),
!                                          dg.header_offset() +
!                                          dg.offset()));
              }
              else
              {
!                 gu_trace(msg.unserialize(&dg.payload()[0],
!                                          dg.len(),
!                                          dg.offset()));
              }
          }
!         catch (gu::Exception& e)
          {
              GU_TRACE(e);
              log_warn << e.what();
              return;
          }
  
!         if (msg.type() >= Message::T_USER_BASE)
          {
!             gu_trace(send_up(Datagram(dg, dg.offset() + msg.serial_size()),
!                              ProtoUpMeta(msg.source_uuid())));
          }
          else
          {
!             log_warn << "non-user message " << msg.type()
                       << " from multicast socket";
          }
      }
!     else if ((i = proto_map_->find(id)) != proto_map_->end())
      {
!         Proto* p(ProtoMap::value(i));
  
!         if (dg.len() > 0)
          {
!             const Proto::State prev_state(p->state());
  
              if (prev_state == Proto::S_FAILED)
              {
***************
*** 1100,1109 ****
  
              try
              {
!                 msg.unserialize(&dg.get_payload()[0], dg.get_len(),
!                                 dg.get_offset());
              }
!             catch (Exception& e)
              {
                  GU_TRACE(e);
                  log_warn << e.what();
--- 1105,1114 ----
  
              try
              {
!                 msg.unserialize(&dg.payload()[0], dg.len(),
!                                 dg.offset());
              }
!             catch (gu::Exception& e)
              {
                  GU_TRACE(e);
                  log_warn << e.what();
***************
*** 1112,1127 ****
                  return;
              }
  
!             if (msg.get_type() >= Message::T_USER_BASE)
              {
!                 if (msg.get_flags() & Message::F_RELAY)
                  {
                      relay(msg,
!                           Datagram(dg, dg.get_offset() + msg.serial_size()),
                            id);
                  }
!                 send_up(Datagram(dg, dg.get_offset() + msg.serial_size()),
!                         ProtoUpMeta(msg.get_source_uuid()));
                  p->set_tstamp(gu::datetime::Date::now());
              }
              else
--- 1117,1132 ----
                  return;
              }
  
!             if (msg.type() >= Message::T_USER_BASE)
              {
!                 if (msg.flags() & Message::F_RELAY)
                  {
                      relay(msg,
!                           Datagram(dg, dg.offset() + msg.serial_size()),
                            id);
                  }
!                 send_up(Datagram(dg, dg.offset() + msg.serial_size()),
!                         ProtoUpMeta(msg.source_uuid()));
                  p->set_tstamp(gu::datetime::Date::now());
              }
              else
***************
*** 1131,1137 ****
                      gu_trace(p->handle_message(msg));
                      p->set_tstamp(gu::datetime::Date::now());
                  }
!                 catch (Exception& e)
                  {
                      log_warn << "handling gmcast protocol message failed: "
                               << e.what();
--- 1136,1142 ----
                      gu_trace(p->handle_message(msg));
                      p->set_tstamp(gu::datetime::Date::now());
                  }
!                 catch (gu::Exception& e)
                  {
                      log_warn << "handling gmcast protocol message failed: "
                               << e.what();
***************
*** 1139,1150 ****
                      return;
                  }
  
!                 if (p->get_state() == Proto::S_FAILED)
                  {
                      handle_failed(p);
                      return;
                  }
!                 else if (p->get_changed() == true)
                  {
                      update_addresses();
                      check_liveness();
--- 1144,1155 ----
                      return;
                  }
  
!                 if (p->state() == Proto::S_FAILED)
                  {
                      handle_failed(p);
                      return;
                  }
!                 else if (p->changed() == true)
                  {
                      update_addresses();
                      check_liveness();
***************
*** 1152,1178 ****
                  }
              }
  
!             if (prev_state != Proto::S_OK && p->get_state() == Proto::S_OK)
              {
                  handle_established(p);
              }
          }
!         else if (p->get_socket()->get_state() == Socket::S_CONNECTED &&
!                  (p->get_state() == Proto::S_HANDSHAKE_WAIT ||
!                   p->get_state() == Proto::S_INIT))
          {
              handle_connected(p);
          }
!         else if (p->get_socket()->get_state() == Socket::S_CONNECTED)
          {
!             log_warn << "connection " << p->get_socket()->get_id()
                       << " closed by peer";
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
          else
          {
!             log_debug << "socket in state " << p->get_socket()->get_state();
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
--- 1157,1183 ----
                  }
              }
  
!             if (prev_state != Proto::S_OK && p->state() == Proto::S_OK)
              {
                  handle_established(p);
              }
          }
!         else if (p->socket()->state() == Socket::S_CONNECTED &&
!                  (p->state() == Proto::S_HANDSHAKE_WAIT ||
!                   p->state() == Proto::S_INIT))
          {
              handle_connected(p);
          }
!         else if (p->socket()->state() == Socket::S_CONNECTED)
          {
!             log_warn << "connection " << p->socket()->id()
                       << " closed by peer";
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
          else
          {
!             log_debug << "socket in state " << p->socket()->state();
              p->set_state(Proto::S_FAILED);
              handle_failed(p);
          }
***************
*** 1183,1208 ****
      }
  }
  
! int GMCast::handle_down(Datagram& dg, const ProtoDownMeta& dm)
  {
!     Message msg(version, Message::T_USER_BASE, get_uuid(), 1);
  
      gu_trace(push_header(msg, dg));
  
!     size_t relay_idx(mcast_tree.size());
!     if (relaying == true && relay_idx > 0)
      {
          relay_idx = rand() % relay_idx;
      }
  
      size_t idx(0);
!     for (list<Socket*>::iterator i(mcast_tree.begin());
!          i != mcast_tree.end(); ++i, ++idx)
      {
          if (relay_idx == idx)
          {
              gu_trace(pop_header(msg, dg));
!             msg.set_flags(msg.get_flags() | Message::F_RELAY);
              gu_trace(push_header(msg, dg));
          }
          int err;
--- 1188,1213 ----
      }
  }
  
! int gcomm::GMCast::handle_down(Datagram& dg, const ProtoDownMeta& dm)
  {
!     Message msg(version_, Message::T_USER_BASE, uuid(), 1);
  
      gu_trace(push_header(msg, dg));
  
!     size_t relay_idx(mcast_tree_.size());
!     if (relaying_ == true && relay_idx > 0)
      {
          relay_idx = rand() % relay_idx;
      }
  
      size_t idx(0);
!     for (std::list<Socket*>::iterator i(mcast_tree_.begin());
!          i != mcast_tree_.end(); ++i, ++idx)
      {
          if (relay_idx == idx)
          {
              gu_trace(pop_header(msg, dg));
!             msg.set_flags(msg.flags() | Message::F_RELAY);
              gu_trace(push_header(msg, dg));
          }
          int err;
***************
*** 1213,1219 ****
          if (relay_idx == idx)
          {
              gu_trace(pop_header(msg, dg));
!             msg.set_flags(msg.get_flags() & ~Message::F_RELAY);
              gu_trace(push_header(msg, dg));
          }
      }
--- 1218,1224 ----
          if (relay_idx == idx)
          {
              gu_trace(pop_header(msg, dg));
!             msg.set_flags(msg.flags() & ~Message::F_RELAY);
              gu_trace(push_header(msg, dg));
          }
      }
***************
*** 1226,1243 ****
  void gcomm::GMCast::handle_stable_view(const View& view)
  {
      log_debug << "GMCast::handle_stable_view: " << view;
!     if (view.get_type() == V_PRIM)
      {
          // discard addr list entries not in view
          std::set<UUID> gmcast_lst;
!         for (AddrList::const_iterator i(remote_addrs.begin());
!              i != remote_addrs.end(); ++i)
          {
!             gmcast_lst.insert(i->second.get_uuid());
          }
          std::set<UUID> view_lst;
!         for (NodeList::const_iterator i(view.get_members().begin());
!              i != view.get_members().end(); ++i)
          {
              view_lst.insert(i->first);
          }
--- 1231,1248 ----
  void gcomm::GMCast::handle_stable_view(const View& view)
  {
      log_debug << "GMCast::handle_stable_view: " << view;
!     if (view.type() == V_PRIM)
      {
          // discard addr list entries not in view
          std::set<UUID> gmcast_lst;
!         for (AddrList::const_iterator i(remote_addrs_.begin());
!              i != remote_addrs_.end(); ++i)
          {
!             gmcast_lst.insert(i->second.uuid());
          }
          std::set<UUID> view_lst;
!         for (NodeList::const_iterator i(view.members().begin());
!              i != view.members().end(); ++i)
          {
              view_lst.insert(i->first);
          }
***************
*** 1258,1324 ****
               i != view_lst.end(); ++i)
          {
              AddrList::iterator ai;
!             if ((ai = find_if(remote_addrs.begin(), remote_addrs.end(),
!                               AddrListUUIDCmp(*i))) != remote_addrs.end())
              {
                  ai->second.set_retry_cnt(-1);
!                 ai->second.set_max_retries(max_retry_cnt);
              }
          }
  
          // iterate over pending address list and discard entries without UUID
!         for (AddrList::iterator i(pending_addrs.begin());
!              i != pending_addrs.end(); )
          {
              AddrList::iterator i_next(i);
              ++i_next;
!             const AddrEntry& ae(AddrList::get_value(i));
!             if (ae.get_uuid() == UUID())
              {
!                 const std::string addr(AddrList::get_key(i));
                  log_info << "discarding pending addr without UUID: "
                           << addr;
!                 for (ProtoMap::iterator pi(proto_map->begin());
!                      pi != proto_map->end();)
                  {
                      ProtoMap::iterator pi_next(pi);
                      ++pi_next;
!                     Proto* p(ProtoMap::get_value(pi));
!                     if (p->get_remote_addr() == addr)
                      {
                          log_info << "discarding pending addr proto entry " << p;
                          delete p;
!                         proto_map->erase(pi);
                      }
                      pi = pi_next;
                  }
!                 pending_addrs.erase(i);
              }
              i = i_next;
          }
      }
!     else if (view.get_type() == V_REG)
      {
!         for (NodeList::const_iterator i(view.get_members().begin());
!              i != view.get_members().end(); ++i)
          {
              AddrList::iterator ai;
!             if ((ai = find_if(remote_addrs.begin(), remote_addrs.end(),
!                               AddrListUUIDCmp(NodeList::get_key(i))))
!                 != remote_addrs.end())
              {
!                 log_info << "declaring " << NodeList::get_key(i) << " stable";
                  ai->second.set_retry_cnt(-1);
!                 ai->second.set_max_retries(max_retry_cnt);
              }
          }
      }
      check_liveness();
  
!     for (ProtoMap::const_iterator i(proto_map->begin()); i != proto_map->end();
           ++i)
      {
!         log_debug << "proto: " << *ProtoMap::get_value(i);
      }
  }
  
--- 1263,1329 ----
               i != view_lst.end(); ++i)
          {
              AddrList::iterator ai;
!             if ((ai = find_if(remote_addrs_.begin(), remote_addrs_.end(),
!                               AddrListUUIDCmp(*i))) != remote_addrs_.end())
              {
                  ai->second.set_retry_cnt(-1);
!                 ai->second.set_max_retries(max_retry_cnt_);
              }
          }
  
          // iterate over pending address list and discard entries without UUID
!         for (AddrList::iterator i(pending_addrs_.begin());
!              i != pending_addrs_.end(); )
          {
              AddrList::iterator i_next(i);
              ++i_next;
!             const AddrEntry& ae(AddrList::value(i));
!             if (ae.uuid() == UUID())
              {
!                 const std::string addr(AddrList::key(i));
                  log_info << "discarding pending addr without UUID: "
                           << addr;
!                 for (ProtoMap::iterator pi(proto_map_->begin());
!                      pi != proto_map_->end();)
                  {
                      ProtoMap::iterator pi_next(pi);
                      ++pi_next;
!                     Proto* p(ProtoMap::value(pi));
!                     if (p->remote_addr() == addr)
                      {
                          log_info << "discarding pending addr proto entry " << p;
                          delete p;
!                         proto_map_->erase(pi);
                      }
                      pi = pi_next;
                  }
!                 pending_addrs_.erase(i);
              }
              i = i_next;
          }
      }
!     else if (view.type() == V_REG)
      {
!         for (NodeList::const_iterator i(view.members().begin());
!              i != view.members().end(); ++i)
          {
              AddrList::iterator ai;
!             if ((ai = find_if(remote_addrs_.begin(), remote_addrs_.end(),
!                               AddrListUUIDCmp(NodeList::key(i))))
!                 != remote_addrs_.end())
              {
!                 log_info << "declaring " << NodeList::key(i) << " stable";
                  ai->second.set_retry_cnt(-1);
!                 ai->second.set_max_retries(max_retry_cnt_);
              }
          }
      }
      check_liveness();
  
!     for (ProtoMap::const_iterator i(proto_map_->begin()); i != proto_map_->end();
           ++i)
      {
!         log_debug << "proto: " << *ProtoMap::value(i);
      }
  }
  
***************
*** 1327,1364 ****
      if (val.compare(0, 4, "add:") == 0)
      {
          gu::URI uri(val.substr(4));
!         std::string addr(resolve(uri_string(get_scheme(use_ssl),
!                                             uri.get_host(),
!                                             uri.get_port())).to_string());
          log_info << "inserting address '" << addr << "'";
!         insert_address(addr, UUID(), remote_addrs);
!         AddrList::iterator ai(remote_addrs.find(addr));
!         AddrList::get_value(ai).set_max_retries(
!             max_initial_reconnect_attempts);
!         AddrList::get_value(ai).set_retry_cnt(-1);
      }
      else if (val.compare(0, 4, "del:") == 0)
      {
          std::string addr(val.substr(4));
!         AddrList::iterator ai(remote_addrs.find(addr));
!         if (ai != remote_addrs.end())
          {
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map->begin(); pi != proto_map->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::get_value(pi);
!                 if (rp->get_remote_addr() == AddrList::get_key(ai))
                  {
!                     log_info << "deleting entry " << AddrList::get_key(ai);
                      delete rp;
!                     proto_map->erase(pi);
                  }
              }
!             AddrEntry& ae(AddrList::get_value(ai));
              ae.set_max_retries(0);
              ae.set_retry_cnt(1);
!             ae.set_next_reconnect(Date::now() + time_wait);
              update_addresses();
          }
          else
--- 1332,1369 ----
      if (val.compare(0, 4, "add:") == 0)
      {
          gu::URI uri(val.substr(4));
!         std::string addr(gu::net::resolve(uri_string(get_scheme(use_ssl_),
!                                                      uri.get_host(),
!                                                      uri.get_port())).to_string());
          log_info << "inserting address '" << addr << "'";
!         insert_address(addr, UUID(), remote_addrs_);
!         AddrList::iterator ai(remote_addrs_.find(addr));
!         AddrList::value(ai).set_max_retries(
!             max_initial_reconnect_attempts_);
!         AddrList::value(ai).set_retry_cnt(-1);
      }
      else if (val.compare(0, 4, "del:") == 0)
      {
          std::string addr(val.substr(4));
!         AddrList::iterator ai(remote_addrs_.find(addr));
!         if (ai != remote_addrs_.end())
          {
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map_->begin(); pi != proto_map_->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::value(pi);
!                 if (rp->remote_addr() == AddrList::key(ai))
                  {
!                     log_info << "deleting entry " << AddrList::key(ai);
                      delete rp;
!                     proto_map_->erase(pi);
                  }
              }
!             AddrEntry& ae(AddrList::value(ai));
              ae.set_max_retries(0);
              ae.set_retry_cnt(1);
!             ae.set_next_reconnect(gu::datetime::Date::now() + time_wait_);
              update_addresses();
          }
          else
***************
*** 1378,1384 ****
  {
      if (key == Conf::GMCastMaxInitialReconnectAttempts)
      {
!         max_initial_reconnect_attempts = gu::from_string<int>(val);
          return true;
      }
      else if (key == Conf::GMCastPeerAddr)
--- 1383,1389 ----
  {
      if (key == Conf::GMCastMaxInitialReconnectAttempts)
      {
!         max_initial_reconnect_attempts_ = gu::from_string<int>(val);
          return true;
      }
      else if (key == Conf::GMCastPeerAddr)
***************
*** 1399,1419 ****
      }
      else if (key == Conf::GMCastIsolate)
      {
!         isolate = gu::from_string<bool>(val);
          log_info << "turning isolation "
!                  << (isolate == true ? "on" : "off");
!         if (isolate == true)
          {
              // delete all entries in proto map
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map->begin(); pi != proto_map->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::get_value(pi);
                  delete rp;
!                 proto_map->erase(pi);
              }
!             mcast_tree.clear();
          }
          return true;
      }
--- 1404,1424 ----
      }
      else if (key == Conf::GMCastIsolate)
      {
!         isolate_ = gu::from_string<bool>(val);
          log_info << "turning isolation "
!                  << (isolate_ == true ? "on" : "off");
!         if (isolate_ == true)
          {
              // delete all entries in proto map
              ProtoMap::iterator pi, pi_next;
!             for (pi = proto_map_->begin(); pi != proto_map_->end(); pi = pi_next)
              {
                  pi_next = pi, ++pi_next;
!                 Proto* rp = ProtoMap::value(pi);
                  delete rp;
!                 proto_map_->erase(pi);
              }
!             mcast_tree_.clear();
          }
          return true;
      }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast.hpp 2.x/gcomm/src/gmcast.hpp
*** galera-23.2.2-src/gcomm/src/gmcast.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 6,13 ****
   * Generic multicast transport. Uses tcp connections if real multicast
   * is not available.
   */
! #ifndef TRANSPORT_GMCAST_HPP
! #define TRANSPORT_GMCAST_HPP
  
  #include "gcomm/uuid.hpp"
  #include "gcomm/exception.hpp"
--- 6,13 ----
   * Generic multicast transport. Uses tcp connections if real multicast
   * is not available.
   */
! #ifndef GCOMM_GMCAST_HPP
! #define GCOMM_GMCAST_HPP
  
  #include "gcomm/uuid.hpp"
  #include "gcomm/exception.hpp"
***************
*** 38,50 ****
          ~GMCast();
  
          // Protolay interface
!         void handle_up(const void*, const gu::Datagram&, const ProtoUpMeta&);
!         int  handle_down(gu::Datagram&, const ProtoDownMeta&);
          void handle_stable_view(const View& view);
          bool set_param(const std::string& key, const std::string& val);
          // Transport interface
!         bool supports_uuid()   const { return true; }
!         const UUID& get_uuid() const { return my_uuid; }
          void connect();
          void connect(const gu::URI&);
          void close(bool force = false);
--- 38,49 ----
          ~GMCast();
  
          // Protolay interface
!         void handle_up(const void*, const Datagram&, const ProtoUpMeta&);
!         int  handle_down(Datagram&, const ProtoDownMeta&);
          void handle_stable_view(const View& view);
          bool set_param(const std::string& key, const std::string& val);
          // Transport interface
!         const UUID& uuid() const { return my_uuid_; }
          void connect();
          void connect(const gu::URI&);
          void close(bool force = false);
***************
*** 55,67 ****
              gu_throw_fatal << "gmcast transport listen not implemented";
          }
  
!         std::string get_listen_addr() const
          {
!             if (listener == 0)
              {
                  gu_throw_error(ENOTCONN) << "not connected";
              }
!             return listener->listen_addr();
          }
  
          Transport* accept()
--- 54,66 ----
              gu_throw_fatal << "gmcast transport listen not implemented";
          }
  
!         std::string listen_addr() const
          {
!             if (listener_ == 0)
              {
                  gu_throw_error(ENOTCONN) << "not connected";
              }
!             return listener_->listen_addr();
          }
  
          Transport* accept()
***************
*** 69,77 ****
              gu_throw_fatal << "gmcast transport accept not implemented"; throw;
          }
  
!         size_t get_mtu() const
          {
!             return pnet_.get_mtu() - (4 + UUID::serial_size());
          }
  
      private:
--- 68,76 ----
              gu_throw_fatal << "gmcast transport accept not implemented"; throw;
          }
  
!         size_t mtu() const
          {
!             return pnet_.mtu() - (4 + UUID::serial_size());
          }
  
      private:
***************
*** 79,128 ****
          GMCast (const GMCast&);
          GMCast& operator=(const GMCast&);
  
!         static const long max_retry_cnt;
  
          class AddrEntry
          {
          public:
  
!             AddrEntry(const gu::datetime::Date& last_seen_,
!                       const gu::datetime::Date& next_reconnect_,
!                       const UUID& uuid_) :
!                 uuid           (uuid_),
!                 last_seen      (last_seen_),
!                 next_reconnect (next_reconnect_),
!                 retry_cnt      (0),
!                 max_retries    (0)
              { }
  
!             const UUID& get_uuid() const { return uuid; }
  
!             void set_last_seen(const gu::datetime::Date& d) { last_seen = d; }
  
!             const gu::datetime::Date& get_last_seen() const
!             { return last_seen; }
  
              void set_next_reconnect(const gu::datetime::Date& d)
!             { next_reconnect = d; }
  
!             const gu::datetime::Date& get_next_reconnect() const
!             { return next_reconnect; }
  
!             void set_retry_cnt(const int r) { retry_cnt = r; }
  
!             int get_retry_cnt() const { return retry_cnt; }
  
!             void set_max_retries(int mr) { max_retries = mr; }
!             int get_max_retries() const { return max_retries; }
  
          private:
              friend std::ostream& operator<<(std::ostream&, const AddrEntry&);
              void operator=(const AddrEntry&);
!             UUID uuid;
!             gu::datetime::Date last_seen;
!             gu::datetime::Date next_reconnect;
!             int  retry_cnt;
!             int  max_retries;
          };
  
  
--- 78,128 ----
          GMCast (const GMCast&);
          GMCast& operator=(const GMCast&);
  
!         static const long max_retry_cnt_;
  
          class AddrEntry
          {
          public:
  
!             AddrEntry(const gu::datetime::Date& last_seen,
!                       const gu::datetime::Date& next_reconnect,
!                       const UUID&               uuid)
!                 :
!                 uuid_           (uuid),
!                 last_seen_      (last_seen),
!                 next_reconnect_ (next_reconnect),
!                 retry_cnt_      (0),
!                 max_retries_    (0)
              { }
  
!             const UUID& uuid() const { return uuid_; }
  
!             void set_last_seen(const gu::datetime::Date& d) { last_seen_ = d; }
  
!             const gu::datetime::Date& last_seen() const
!             { return last_seen_; }
  
              void set_next_reconnect(const gu::datetime::Date& d)
!             { next_reconnect_ = d; }
  
!             const gu::datetime::Date& next_reconnect() const
!             { return next_reconnect_; }
  
!             void set_retry_cnt(const int r) { retry_cnt_ = r; }
  
!             int retry_cnt() const { return retry_cnt_; }
  
!             void set_max_retries(int mr) { max_retries_ = mr; }
!             int max_retries() const { return max_retries_; }
  
          private:
              friend std::ostream& operator<<(std::ostream&, const AddrEntry&);
              void operator=(const AddrEntry&);
!             UUID uuid_;
!             gu::datetime::Date last_seen_;
!             gu::datetime::Date next_reconnect_;
!             int  retry_cnt_;
!             int  max_retries_;
          };
  
  
***************
*** 134,171 ****
              AddrListUUIDCmp(const UUID& uuid) : uuid_(uuid) { }
              bool operator()(const AddrList::value_type& cmp) const
              {
!                 return (cmp.second.get_uuid() == uuid_);
              }
          private:
              UUID uuid_;
          };
  
!         int               version;
!         static const int max_version_ = GCOMM_GMCAST_MAX_VERSION;
!         UUID              my_uuid;
!         bool              use_ssl;
!         std::string       group_name;
!         std::string       listen_addr;
!         std::set<std::string>       initial_addrs;
!         std::string       mcast_addr;
!         std::string       bind_ip;
!         int               mcast_ttl;
!         Acceptor*         listener;
!         SocketPtr         mcast;
!         AddrList          pending_addrs;
!         AddrList          remote_addrs;
!         AddrList          addr_blacklist;
!         bool              relaying;
!         bool              isolate;
! 
!         gmcast::ProtoMap*  proto_map;
!         std::list<Socket*> mcast_tree;
! 
!         gu::datetime::Period time_wait;
!         gu::datetime::Period check_period;
!         gu::datetime::Period peer_timeout;
!         int                  max_initial_reconnect_attempts;
!         gu::datetime::Date next_check;
          gu::datetime::Date handle_timers();
  
          // Accept new connection
--- 134,171 ----
              AddrListUUIDCmp(const UUID& uuid) : uuid_(uuid) { }
              bool operator()(const AddrList::value_type& cmp) const
              {
!                 return (cmp.second.uuid() == uuid_);
              }
          private:
              UUID uuid_;
          };
  
!         int               version_;
!         static const int  max_version_ = GCOMM_GMCAST_MAX_VERSION;
!         UUID              my_uuid_;
!         bool              use_ssl_;
!         std::string       group_name_;
!         std::string       listen_addr_;
!         std::set<std::string> initial_addrs_;
!         std::string       mcast_addr_;
!         std::string       bind_ip_;
!         int               mcast_ttl_;
!         Acceptor*         listener_;
!         SocketPtr         mcast_;
!         AddrList          pending_addrs_;
!         AddrList          remote_addrs_;
!         AddrList          addr_blacklist_;
!         bool              relaying_;
!         bool              isolate_;
! 
!         gmcast::ProtoMap*  proto_map_;
!         std::list<Socket*> mcast_tree_;
! 
!         gu::datetime::Period time_wait_;
!         gu::datetime::Period check_period_;
!         gu::datetime::Period peer_timeout_;
!         int                  max_initial_reconnect_attempts_;
!         gu::datetime::Date next_check_;
          gu::datetime::Date handle_timers();
  
          // Accept new connection
***************
*** 191,197 ****
          void update_addresses();
          //
          void check_liveness();
!         void relay(const gmcast::Message& msg, const gu::Datagram& dg,
                     const void* exclude_id);
          // Reconnecting
          void reconnect();
--- 191,197 ----
          void update_addresses();
          //
          void check_liveness();
!         void relay(const gmcast::Message& msg, const Datagram& dg,
                     const void* exclude_id);
          // Reconnecting
          void reconnect();
***************
*** 202,208 ****
          std::string self_string() const
          {
              std::ostringstream os;
!             os << '(' << my_uuid << ", '" << listen_addr << "')";
              return os.str();
          }
  
--- 202,208 ----
          std::string self_string() const
          {
              std::ostringstream os;
!             os << '(' << my_uuid_ << ", '" << listen_addr_ << "')";
              return os.str();
          }
  
***************
*** 211,222 ****
  
      inline std::ostream& operator<<(std::ostream& os, const GMCast::AddrEntry& ae)
      {
!         return (os << ae.uuid
!                 << " last_seen=" << ae.last_seen
!                 << " next_reconnect=" << ae.next_reconnect
!                 << " retry_cnt=" << ae.retry_cnt);
      }
  
  }
  
! #endif // TRANSPORT_GMCAST_HPP
--- 211,222 ----
  
      inline std::ostream& operator<<(std::ostream& os, const GMCast::AddrEntry& ae)
      {
!         return (os << ae.uuid_
!                 << " last_seen=" << ae.last_seen_
!                 << " next_reconnect=" << ae.next_reconnect_
!                 << " retry_cnt=" << ae.retry_cnt_);
      }
  
  }
  
! #endif // GCOMM_GMCAST_HPP
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast_link.hpp 2.x/gcomm/src/gmcast_link.hpp
*** galera-23.2.2-src/gcomm/src/gmcast_link.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast_link.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 31,50 ****
          addr_      (addr),
          mcast_addr_(mcast_addr)
      { }
!     
      bool operator==(const Link& cmp) const
      { return (uuid_ == cmp.uuid_ && addr_ == cmp.addr_); }
!     
      bool operator<(const Link& cmp) const
!     { 
          return (uuid_ < cmp.uuid_ ||
                  (uuid_ == cmp.uuid_ && addr_ < cmp.addr_));
!         
      }
!     
!     const gcomm::UUID& get_uuid() const { return uuid_; }
!     const std::string& get_addr() const { return addr_; }
!     const std::string& get_mcast_addr() const { return mcast_addr_; }
  private:
      UUID uuid_;
      std::string addr_;
--- 31,50 ----
          addr_      (addr),
          mcast_addr_(mcast_addr)
      { }
! 
      bool operator==(const Link& cmp) const
      { return (uuid_ == cmp.uuid_ && addr_ == cmp.addr_); }
! 
      bool operator<(const Link& cmp) const
!     {
          return (uuid_ < cmp.uuid_ ||
                  (uuid_ == cmp.uuid_ && addr_ < cmp.addr_));
! 
      }
! 
!     const gcomm::UUID& uuid() const { return uuid_; }
!     const std::string& addr() const { return addr_; }
!     const std::string& mcast_addr() const { return mcast_addr_; }
  private:
      UUID uuid_;
      std::string addr_;
***************
*** 57,84 ****
  {
      typedef std::set<Link> MType;
  public:
!     LinkMap() : link_map() { }
      typedef MType::iterator iterator;
      typedef MType::const_iterator const_iterator;
      typedef MType::value_type value_type;
!     
!     std::pair<iterator, bool> insert(const Link& i) 
!     { return link_map.insert(i); }
!     
!     iterator begin() { return link_map.begin(); }
!     const_iterator begin() const { return link_map.begin(); }
!     iterator end() { return link_map.end(); }
!     const_iterator end() const { return link_map.end(); }
!     const_iterator find(const value_type& vt) const { return link_map.find(vt); } 
!     size_t size() const { return link_map.size(); }
!     static const UUID& get_key(const_iterator i) { return i->get_uuid(); }
!     static const Link& get_value(const_iterator i) { return *i; }
!     static const UUID& get_key(const value_type& vt) { return vt.get_uuid(); }
!     static const Link& get_value(const value_type& vt) { return vt; }
!     bool operator==(const LinkMap& cmp) const 
!     { return (link_map == cmp.link_map); }
  private:
!     MType link_map;
  };
  
  inline std::ostream& gcomm::gmcast::operator<<(std::ostream& os, const LinkMap& lm)
--- 57,84 ----
  {
      typedef std::set<Link> MType;
  public:
!     LinkMap() : link_map_() { }
      typedef MType::iterator iterator;
      typedef MType::const_iterator const_iterator;
      typedef MType::value_type value_type;
! 
!     std::pair<iterator, bool> insert(const Link& i)
!     { return link_map_.insert(i); }
! 
!     iterator begin() { return link_map_.begin(); }
!     const_iterator begin() const { return link_map_.begin(); }
!     iterator end() { return link_map_.end(); }
!     const_iterator end() const { return link_map_.end(); }
!     const_iterator find(const value_type& vt) const { return link_map_.find(vt); }
!     size_t size() const { return link_map_.size(); }
!     static const UUID& key(const_iterator i) { return i->uuid(); }
!     static const Link& value(const_iterator i) { return *i; }
!     static const UUID& key(const value_type& vt) { return vt.uuid(); }
!     static const Link& value(const value_type& vt) { return vt; }
!     bool operator==(const LinkMap& cmp) const
!     { return (link_map_ == cmp.link_map_); }
  private:
!     MType link_map_;
  };
  
  inline std::ostream& gcomm::gmcast::operator<<(std::ostream& os, const LinkMap& lm)
***************
*** 86,93 ****
      for (LinkMap::const_iterator i = lm.begin(); i != lm.end();
           ++i)
      {
!         os << "\n(" << LinkMap::get_key(i) << ","
!            << LinkMap::get_value(i).get_addr() << ")";
      }
      return (os << "\n");
  }
--- 86,93 ----
      for (LinkMap::const_iterator i = lm.begin(); i != lm.end();
           ++i)
      {
!         os << "\n(" << LinkMap::key(i) << ","
!            << LinkMap::value(i).addr() << ")";
      }
      return (os << "\n");
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast_message.hpp 2.x/gcomm/src/gmcast_message.hpp
*** galera-23.2.2-src/gcomm/src/gmcast_message.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast_message.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 2,7 ****
--- 2,10 ----
   * Copyright (C) 2009-2012 Codership Oy <info@codership.com>
   */
  
+ #ifndef GCOMM_GMCAST_MESSAGE_HPP
+ #define GCOMM_GMCAST_MESSAGE_HPP
+ 
  #include "gcomm/types.hpp"
  #include "gcomm/uuid.hpp"
  #include "gmcast_node.hpp"
***************
*** 46,64 ****
  
  private:
  
!     gu::byte_t        version;
!     Type              type;
!     gu::byte_t        flags;
!     gu::byte_t        segment_id;
!     gcomm::UUID       handshake_uuid;
!     gcomm::UUID       source_uuid;
!     gcomm::String<64> node_address;
!     gcomm::String<32> group_name;
  
  
      Message& operator=(const Message&);
  
!     NodeList node_list;
  public:
  
      static const char* type_to_string (Type t)
--- 49,67 ----
  
  private:
  
!     gu::byte_t        version_;
!     Type              type_;
!     gu::byte_t        flags_;
!     gu::byte_t        segment_id_;
!     gcomm::UUID       handshake_uuid_;
!     gcomm::UUID       source_uuid_;
!     gcomm::String<64> node_address_;
!     gcomm::String<32> group_name_;
  
  
      Message& operator=(const Message&);
  
!     NodeList node_list_;
  public:
  
      static const char* type_to_string (Type t)
***************
*** 82,198 ****
      }
  
      Message(const Message& msg) :
!         version        (msg.version),
!         type           (msg.type),
!         flags          (msg.flags),
!         segment_id     (msg.segment_id),
!         handshake_uuid (msg.handshake_uuid),
!         source_uuid    (msg.source_uuid),
!         node_address   (msg.node_address),
!         group_name     (msg.group_name),
!         node_list      (msg.node_list)
      { }
  
      /* Default ctor */
      Message ()
          :
!         version        (0),
!         type           (T_INVALID),
!         flags          (0),
!         segment_id     (0),
!         handshake_uuid (),
!         source_uuid    (),
!         node_address   (),
!         group_name     (),
!         node_list      ()
      {}
  
      /* Ctor for handshake, handshake ok and handshake fail */
      Message (int v,
!              const Type  type_,
!              const UUID& handshake_uuid_,
!              const UUID& source_uuid_)
          :
!         version        (v),
!         type           (type_),
!         flags          (F_HANDSHAKE_UUID),
!         segment_id     (0),
!         handshake_uuid (handshake_uuid_),
!         source_uuid    (source_uuid_),
!         node_address   (),
!         group_name     (),
!         node_list      ()
!     {
!         if (type != T_HANDSHAKE && type != T_HANDSHAKE_OK &&
!             type != T_HANDSHAKE_FAIL)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type)
                                << " in handshake constructor";
      }
  
      /* Ctor for user message */
      Message (int v,
!              const Type    type_,
!              const UUID&   source_uuid_,
!              const int     ttl_)
          :
!         version        (v),
!         type           (type_),
!         flags          (0),
!         segment_id     (0),
!         handshake_uuid (),
!         source_uuid    (source_uuid_),
!         node_address   (),
!         group_name     (),
!         node_list      ()
      {
!         if (type < T_USER_BASE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type)
                                << " in user message constructor";
      }
  
      /* Ctor for handshake response */
      Message (int v,
!              const Type         type_,
!              const gcomm::UUID& handshake_uuid_,
!              const gcomm::UUID& source_uuid_,
!              const std::string& node_address_,
!              const std::string& group_name_)
          :
!         version        (v),
!         type           (type_),
!         flags          (F_GROUP_NAME | F_NODE_ADDRESS | F_HANDSHAKE_UUID),
!         segment_id     (0),
!         handshake_uuid (handshake_uuid_),
!         source_uuid    (source_uuid_),
!         node_address   (node_address_),
!         group_name     (group_name_),
!         node_list      ()
  
      {
!         if (type != T_HANDSHAKE_RESPONSE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type)
!                               << " in handshake response constructor";
      }
  
      /* Ctor for topology change */
      Message (int v,
!              const Type         type_,
!              const gcomm::UUID& source_uuid_,
!              const std::string& group_name_,
               const NodeList&    nodes)
          :
!         version        (v),
!         type           (type_),
!         flags          (F_GROUP_NAME | F_NODE_LIST),
!         segment_id     (0),
!         handshake_uuid (),
!         source_uuid    (source_uuid_),
!         node_address   (),
!         group_name     (group_name_),
!         node_list      (nodes)
      {
!         if (type != T_TOPOLOGY_CHANGE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type)
                                << " in topology change constructor";
      }
  
--- 85,201 ----
      }
  
      Message(const Message& msg) :
!         version_        (msg.version_),
!         type_           (msg.type_),
!         flags_          (msg.flags_),
!         segment_id_     (msg.segment_id_),
!         handshake_uuid_ (msg.handshake_uuid_),
!         source_uuid_    (msg.source_uuid_),
!         node_address_   (msg.node_address_),
!         group_name_     (msg.group_name_),
!         node_list_      (msg.node_list_)
      { }
  
      /* Default ctor */
      Message ()
          :
!         version_        (0),
!         type_           (T_INVALID),
!         flags_          (0),
!         segment_id_     (0),
!         handshake_uuid_ (),
!         source_uuid_    (),
!         node_address_   (),
!         group_name_     (),
!         node_list_      ()
      {}
  
      /* Ctor for handshake, handshake ok and handshake fail */
      Message (int v,
!              const Type  type,
!              const UUID& handshake_uuid,
!              const UUID& source_uuid)
          :
!         version_        (v),
!         type_           (type),
!         flags_          (F_HANDSHAKE_UUID),
!         segment_id_     (0),
!         handshake_uuid_ (handshake_uuid),
!         source_uuid_    (source_uuid),
!         node_address_   (),
!         group_name_     (),
!         node_list_      ()
!     {
!         if (type_ != T_HANDSHAKE && type_ != T_HANDSHAKE_OK &&
!             type_ != T_HANDSHAKE_FAIL)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type_)
                                << " in handshake constructor";
      }
  
      /* Ctor for user message */
      Message (int v,
!              const Type    type,
!              const UUID&   source_uuid,
!              const int     ttl)
          :
!         version_        (v),
!         type_           (type),
!         flags_          (0),
!         segment_id_     (0),
!         handshake_uuid_ (),
!         source_uuid_    (source_uuid),
!         node_address_   (),
!         group_name_     (),
!         node_list_      ()
      {
!         if (type_ < T_USER_BASE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type_)
                                << " in user message constructor";
      }
  
      /* Ctor for handshake response */
      Message (int v,
!              const Type         type,
!              const gcomm::UUID& handshake_uuid,
!              const gcomm::UUID& source_uuid,
!              const std::string& node_address,
!              const std::string& group_name)
          :
!         version_        (v),
!         type_           (type),
!         flags_          (F_GROUP_NAME | F_NODE_ADDRESS | F_HANDSHAKE_UUID),
!         segment_id_     (0),
!         handshake_uuid_ (handshake_uuid),
!         source_uuid_    (source_uuid),
!         node_address_   (node_address),
!         group_name_     (group_name),
!         node_list_      ()
  
      {
!         if (type_ != T_HANDSHAKE_RESPONSE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type_)
!                            << " in handshake response constructor";
      }
  
      /* Ctor for topology change */
      Message (int v,
!              const Type         type,
!              const gcomm::UUID& source_uuid,
!              const std::string& group_name,
               const NodeList&    nodes)
          :
!         version_        (v),
!         type_           (type),
!         flags_          (F_GROUP_NAME | F_NODE_LIST),
!         segment_id_     (0),
!         handshake_uuid_ (),
!         source_uuid_    (source_uuid),
!         node_address_   (),
!         group_name_     (group_name),
!         node_list_      (nodes)
      {
!         if (type_ != T_TOPOLOGY_CHANGE)
!             gu_throw_fatal << "Invalid message type " << type_to_string(type_)
                                << " in topology change constructor";
      }
  
***************
*** 205,234 ****
      {
          size_t off;
  
!         gu_trace (off = gu::serialize1(version, buf, buflen, offset));
!         gu_trace (off = gu::serialize1(static_cast<gu::byte_t>(type),buf,buflen,off));
!         gu_trace (off = gu::serialize1(flags, buf, buflen, off));
!         gu_trace (off = gu::serialize1(segment_id, buf, buflen, off));
!         gu_trace (off = source_uuid.serialize(buf, buflen, off));
  
!         if (flags & F_HANDSHAKE_UUID)
          {
!             gu_trace(off = handshake_uuid.serialize(buf, buflen, off));
          }
  
!         if (flags & F_NODE_ADDRESS)
          {
!             gu_trace (off = node_address.serialize(buf, buflen, off));
          }
  
!         if (flags & F_GROUP_NAME)
          {
!             gu_trace (off = group_name.serialize(buf, buflen, off));
          }
  
!         if (flags & F_NODE_LIST)
          {
!             gu_trace(off = node_list.serialize(buf, buflen, off));
          }
          return off;
      }
--- 208,237 ----
      {
          size_t off;
  
!         gu_trace (off = gu::serialize1(version_, buf, buflen, offset));
!         gu_trace (off = gu::serialize1(static_cast<gu::byte_t>(type_),buf,buflen,off));
!         gu_trace (off = gu::serialize1(flags_, buf, buflen, off));
!         gu_trace (off = gu::serialize1(segment_id_, buf, buflen, off));
!         gu_trace (off = source_uuid_.serialize(buf, buflen, off));
  
!         if (flags_ & F_HANDSHAKE_UUID)
          {
!             gu_trace(off = handshake_uuid_.serialize(buf, buflen, off));
          }
  
!         if (flags_ & F_NODE_ADDRESS)
          {
!             gu_trace (off = node_address_.serialize(buf, buflen, off));
          }
  
!         if (flags_ & F_GROUP_NAME)
          {
!             gu_trace (off = group_name_.serialize(buf, buflen, off));
          }
  
!         if (flags_ & F_NODE_LIST)
          {
!             gu_trace(off = node_list_.serialize(buf, buflen, off));
          }
          return off;
      }
***************
*** 240,247 ****
          gu::byte_t t;
  
          gu_trace (off = gu::unserialize1(buf, buflen, offset, t));
!         type = static_cast<Type>(t);
!         switch (type)
          {
          case T_HANDSHAKE:
          case T_HANDSHAKE_RESPONSE:
--- 243,250 ----
          gu::byte_t t;
  
          gu_trace (off = gu::unserialize1(buf, buflen, offset, t));
!         type_ = static_cast<Type>(t);
!         switch (type_)
          {
          case T_HANDSHAKE:
          case T_HANDSHAKE_RESPONSE:
***************
*** 252,282 ****
              break;
          default:
              gu_throw_error(EINVAL) << "invalid message type "
!                                    << static_cast<int>(type);
              throw;
          }
!         gu_trace (off = gu::unserialize1(buf, buflen, off, flags));
!         gu_trace (off = gu::unserialize1(buf, buflen, off, segment_id));
!         gu_trace (off = source_uuid.unserialize(buf, buflen, off));
  
!         if (flags & F_HANDSHAKE_UUID)
          {
!             gu_trace(off = handshake_uuid.unserialize(buf, buflen, off));
          }
  
!         if (flags & F_NODE_ADDRESS)
          {
!             gu_trace (off = node_address.unserialize(buf, buflen, off));
          }
  
!         if (flags & F_GROUP_NAME)
          {
!             gu_trace (off = group_name.unserialize(buf, buflen, off));
          }
  
!         if (flags & F_NODE_LIST)
          {
!             gu_trace(off = node_list.unserialize(buf, buflen, off));
          }
  
          return off;
--- 255,285 ----
              break;
          default:
              gu_throw_error(EINVAL) << "invalid message type "
!                                    << static_cast<int>(type_);
              throw;
          }
!         gu_trace (off = gu::unserialize1(buf, buflen, off, flags_));
!         gu_trace (off = gu::unserialize1(buf, buflen, off, segment_id_));
!         gu_trace (off = source_uuid_.unserialize(buf, buflen, off));
  
!         if (flags_ & F_HANDSHAKE_UUID)
          {
!             gu_trace(off = handshake_uuid_.unserialize(buf, buflen, off));
          }
  
!         if (flags_ & F_NODE_ADDRESS)
          {
!             gu_trace (off = node_address_.unserialize(buf, buflen, off));
          }
  
!         if (flags_ & F_GROUP_NAME)
          {
!             gu_trace (off = group_name_.unserialize(buf, buflen, off));
          }
  
!         if (flags_ & F_NODE_LIST)
          {
!             gu_trace(off = node_list_.unserialize(buf, buflen, off));
          }
  
          return off;
***************
*** 287,299 ****
      {
          size_t off;
  
!         gu_trace (off = gu::unserialize1(buf, buflen, offset, version));
  
!         switch (version) {
          case 0:
              gu_trace (return read_v0(buf, buflen, off));
          default:
!             gu_throw_error(EPROTONOSUPPORT) << "Unsupported/unrecognized gmcast protocol version: " << version;
              throw;
          }
      }
--- 290,302 ----
      {
          size_t off;
  
!         gu_trace (off = gu::unserialize1(buf, buflen, offset, version_));
  
!         switch (version_) {
          case 0:
              gu_trace (return read_v0(buf, buflen, off));
          default:
!             gu_throw_error(EPROTONOSUPPORT) << "Unsupported/unrecognized gmcast protocol version: " << version_;
              throw;
          }
      }
***************
*** 301,330 ****
      size_t serial_size() const
      {
          return 4 /* Common header: version, type, flags, segment_id */
!             + source_uuid.serial_size()
!             + (flags & F_HANDSHAKE_UUID ? handshake_uuid.serial_size() : 0)
              /* GMCast address if set */
!             + (flags & F_NODE_ADDRESS ? node_address.serial_size() : 0)
              /* Group name if set */
!             + (flags & F_GROUP_NAME ? group_name.serial_size() : 0)
              /* Node list if set */
!             + (flags & F_NODE_LIST ? node_list.serial_size() : 0);
      }
  
!     int get_version() const { return version; }
  
!     Type    get_type()    const { return type;    }
  
!     void set_flags(uint8_t f) { flags = f; }
!     uint8_t get_flags()   const { return flags;   }
  
!     const UUID& get_handshake_uuid() const { return handshake_uuid; }
  
!     const UUID&     get_source_uuid()  const { return source_uuid;  }
  
!     const std::string&   get_node_address() const { return node_address.to_string(); }
  
!     const std::string&   get_group_name()   const { return group_name.to_string();   }
  
!     const NodeList& get_node_list()    const { return node_list;    }
  };
--- 304,335 ----
      size_t serial_size() const
      {
          return 4 /* Common header: version, type, flags, segment_id */
!             + source_uuid_.serial_size()
!             + (flags_ & F_HANDSHAKE_UUID ? handshake_uuid_.serial_size() : 0)
              /* GMCast address if set */
!             + (flags_ & F_NODE_ADDRESS ? node_address_.serial_size() : 0)
              /* Group name if set */
!             + (flags_ & F_GROUP_NAME ? group_name_.serial_size() : 0)
              /* Node list if set */
!             + (flags_ & F_NODE_LIST ? node_list_.serial_size() : 0);
      }
  
!     int version() const { return version_; }
  
!     Type    type()    const { return type_;    }
  
!     void set_flags(uint8_t f) { flags_ = f; }
!     uint8_t flags()   const { return flags_;   }
  
!     const UUID& handshake_uuid() const { return handshake_uuid_; }
  
!     const UUID&     source_uuid()  const { return source_uuid_;  }
  
!     const std::string&   node_address() const { return node_address_.to_string(); }
  
!     const std::string&   group_name()   const { return group_name_.to_string();   }
  
!     const NodeList& node_list()    const { return node_list_;    }
  };
+ 
+ #endif // GCOMM_GMCAST_MESSAGE_HPP
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast_node.hpp 2.x/gcomm/src/gmcast_node.hpp
*** galera-23.2.2-src/gcomm/src/gmcast_node.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast_node.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 24,36 ****
  {
  
  public:
!     
      Node(const std::string& addr   = "") : addr_(addr), mcast_addr_("") { }
!     
!     const std::string& get_addr() const { return addr_.to_string(); }
!     const std::string& get_mcast_addr() const { return mcast_addr_.to_string(); } 
!     
!     size_t unserialize(const gu::byte_t* buf, 
                         const size_t buflen, const size_t offset)
      {
          size_t  off;
--- 24,36 ----
  {
  
  public:
! 
      Node(const std::string& addr   = "") : addr_(addr), mcast_addr_("") { }
! 
!     const std::string& addr() const { return addr_.to_string(); }
!     const std::string& mcast_addr() const { return mcast_addr_.to_string(); }
! 
!     size_t unserialize(const gu::byte_t* buf,
                         const size_t buflen, const size_t offset)
      {
          size_t  off;
***************
*** 40,47 ****
          gu_trace (off = mcast_addr_.unserialize(buf, buflen, off));
          return off;
      }
!     
!     size_t serialize(gu::byte_t* buf, const size_t buflen, 
                       const size_t offset) const
      {
          size_t  off;
--- 40,47 ----
          gu_trace (off = mcast_addr_.unserialize(buf, buflen, off));
          return off;
      }
! 
!     size_t serialize(gu::byte_t* buf, const size_t buflen,
                       const size_t offset) const
      {
          size_t  off;
***************
*** 51,59 ****
          gu_trace (off = mcast_addr_.serialize(buf, buflen, off));
          return off;
      }
!     
      static size_t serial_size() { return (4 + 2 * ADDR_SIZE); }
!     
  private:
      static const size_t ADDR_SIZE = 64;
      gcomm::String<ADDR_SIZE> addr_;
--- 51,59 ----
          gu_trace (off = mcast_addr_.serialize(buf, buflen, off));
          return off;
      }
! 
      static size_t serial_size() { return (4 + 2 * ADDR_SIZE); }
! 
  private:
      static const size_t ADDR_SIZE = 64;
      gcomm::String<ADDR_SIZE> addr_;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast_proto.cpp 2.x/gcomm/src/gmcast_proto.cpp
*** galera-23.2.2-src/gcomm/src/gmcast_proto.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast_proto.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 6,19 ****
  
  #include "gu_uri.hpp"
  
! using namespace std;
! using namespace std::rel_ops;
! using namespace gu;
! using namespace gcomm;
  
  void gcomm::gmcast::Proto:: set_state(State new_state)
  {
!     log_debug << "State change: " << to_string(state) << " -> "
                << to_string(new_state);
  
      static const bool allowed[][7] =
--- 6,16 ----
  
  #include "gu_uri.hpp"
  
! using std::rel_ops::operator!=;
  
  void gcomm::gmcast::Proto:: set_state(State new_state)
  {
!     log_debug << "State change: " << to_string(state_) << " -> "
                << to_string(new_state);
  
      static const bool allowed[][7] =
***************
*** 34,46 ****
              { false,  false,  false,  false,  false,  false, false } // CLOSED
          };
  
!     if (!allowed[state][new_state])
      {
!         gu_throw_fatal << "Invalid state change: " << to_string(state)
                            << " -> " << to_string(new_state);
      }
  
!     state = new_state;
  }
  
  void gcomm::gmcast::Proto::send_msg(const Message& msg)
--- 31,43 ----
              { false,  false,  false,  false,  false,  false, false } // CLOSED
          };
  
!     if (!allowed[state_][new_state])
      {
!         gu_throw_fatal << "Invalid state change: " << to_string(state_)
                            << " -> " << to_string(new_state);
      }
  
!     state_ = new_state;
  }
  
  void gcomm::gmcast::Proto::send_msg(const Message& msg)
***************
*** 48,54 ****
      gu::Buffer buf;
      gu_trace(serialize(msg, buf));
      Datagram dg(buf);
!     int ret = tp->send(dg);
  
      // @todo: This can happen during congestion, figure out how to
      // avoid terminating connection with topology change messages.
--- 45,51 ----
      gu::Buffer buf;
      gu_trace(serialize(msg, buf));
      Datagram dg(buf);
!     int ret = tp_->send(dg);
  
      // @todo: This can happen during congestion, figure out how to
      // avoid terminating connection with topology change messages.
***************
*** 61,68 ****
  
  void gcomm::gmcast::Proto::send_handshake()
  {
!     handshake_uuid = UUID(0, 0);
!     Message hs (version, Message::T_HANDSHAKE, handshake_uuid, local_uuid);
  
      send_msg(hs);
  
--- 58,65 ----
  
  void gcomm::gmcast::Proto::send_handshake()
  {
!     handshake_uuid_ = UUID(0, 0);
!     Message hs (version_, Message::T_HANDSHAKE, handshake_uuid_, local_uuid_);
  
      send_msg(hs);
  
***************
*** 71,101 ****
  
  void gcomm::gmcast::Proto::wait_handshake()
  {
!     if (get_state() != S_INIT)
!         gu_throw_fatal << "Invalid state: " << to_string(get_state());
  
      set_state(S_HANDSHAKE_WAIT);
  }
  
  void gcomm::gmcast::Proto::handle_handshake(const Message& hs)
  {
!     if (get_state() != S_HANDSHAKE_WAIT)
!         gu_throw_fatal << "Invalid state: " << to_string(get_state());
  
!     if (hs.get_version() != version)
      {
!         log_warn << "incompatible protocol version: " << hs.get_version();
          set_state(S_FAILED);
          return;
      }
!     handshake_uuid = hs.get_handshake_uuid();
!     remote_uuid = hs.get_source_uuid();
  
!     Message hsr (version, Message::T_HANDSHAKE_RESPONSE,
!                  handshake_uuid,
!                  local_uuid,
!                  local_addr,
!                  group_name);
      send_msg(hsr);
  
      set_state(S_HANDSHAKE_RESPONSE_SENT);
--- 68,98 ----
  
  void gcomm::gmcast::Proto::wait_handshake()
  {
!     if (state() != S_INIT)
!         gu_throw_fatal << "Invalid state: " << to_string(state());
  
      set_state(S_HANDSHAKE_WAIT);
  }
  
  void gcomm::gmcast::Proto::handle_handshake(const Message& hs)
  {
!     if (state() != S_HANDSHAKE_WAIT)
!         gu_throw_fatal << "Invalid state: " << to_string(state());
  
!     if (hs.version() != version_)
      {
!         log_warn << "incompatible protocol version: " << hs.version();
          set_state(S_FAILED);
          return;
      }
!     handshake_uuid_ = hs.handshake_uuid();
!     remote_uuid_ = hs.source_uuid();
  
!     Message hsr (version_, Message::T_HANDSHAKE_RESPONSE,
!                  handshake_uuid_,
!                  local_uuid_,
!                  local_addr_,
!                  group_name_);
      send_msg(hsr);
  
      set_state(S_HANDSHAKE_RESPONSE_SENT);
***************
*** 103,142 ****
  
  void gcomm::gmcast::Proto::handle_handshake_response(const Message& hs)
  {
!     if (get_state() != S_HANDSHAKE_SENT)
!         gu_throw_fatal << "Invalid state: " << to_string(get_state());
  
!         const std::string& grp = hs.get_group_name();
  
          try
          {
!             if (grp != group_name)
              {
!                 log_info << "handshake failed, my group: '" << group_name
                           << "', peer group: '" << grp << "'";
!                 Message failed(version, Message::T_HANDSHAKE_FAIL,
!                                handshake_uuid, local_uuid);
                  send_msg(failed);
                  set_state(S_FAILED);
                  return;
              }
!             remote_uuid = hs.get_source_uuid();
!             gu::URI remote_uri(tp->get_remote_addr());
!             remote_addr = uri_string(remote_uri.get_scheme(),
!                                      remote_uri.get_host(),
!                                      URI(hs.get_node_address()).get_port());
! 
!             propagate_remote = true;
!             Message ok(version, Message::T_HANDSHAKE_OK, handshake_uuid, local_uuid);
              send_msg(ok);
              set_state(S_OK);
          }
!         catch (exception& e)
          {
              log_warn << "Parsing peer address '"
!                      << hs.get_node_address() << "' failed: " << e.what();
  
!             Message nok (version, Message::T_HANDSHAKE_FAIL, handshake_uuid, local_uuid);
  
              send_msg (nok);
              set_state(S_FAILED);
--- 100,141 ----
  
  void gcomm::gmcast::Proto::handle_handshake_response(const Message& hs)
  {
!     if (state() != S_HANDSHAKE_SENT)
!         gu_throw_fatal << "Invalid state: " << to_string(state());
  
!         const std::string& grp = hs.group_name();
  
          try
          {
!             if (grp != group_name_)
              {
!                 log_info << "handshake failed, my group: '" << group_name_
                           << "', peer group: '" << grp << "'";
!                 Message failed(version_, Message::T_HANDSHAKE_FAIL,
!                                handshake_uuid_, local_uuid_);
                  send_msg(failed);
                  set_state(S_FAILED);
                  return;
              }
!             remote_uuid_ = hs.source_uuid();
!             gu::URI remote_uri(tp_->remote_addr());
!             remote_addr_ = uri_string(remote_uri.get_scheme(),
!                                       remote_uri.get_host(),
!                                       gu::URI(hs.node_address()).get_port());
! 
!             propagate_remote_ = true;
!             Message ok(version_, Message::T_HANDSHAKE_OK, handshake_uuid_,
!                        local_uuid_);
              send_msg(ok);
              set_state(S_OK);
          }
!         catch (std::exception& e)
          {
              log_warn << "Parsing peer address '"
!                      << hs.node_address() << "' failed: " << e.what();
  
!             Message nok (version_, Message::T_HANDSHAKE_FAIL, handshake_uuid_,
!                          local_uuid_);
  
              send_msg (nok);
              set_state(S_FAILED);
***************
*** 145,151 ****
  
  void gcomm::gmcast::Proto::handle_ok(const Message& hs)
  {
!     propagate_remote = true;
      set_state(S_OK);
  }
  
--- 144,150 ----
  
  void gcomm::gmcast::Proto::handle_ok(const Message& hs)
  {
!     propagate_remote_ = true;
      set_state(S_OK);
  }
  
***************
*** 157,183 ****
  
  void gcomm::gmcast::Proto::handle_topology_change(const Message& msg)
  {
!     const Message::NodeList& nl(msg.get_node_list());
  
      LinkMap new_map;
      for (Message::NodeList::const_iterator i = nl.begin(); i != nl.end(); ++i)
      {
!         new_map.insert(Link(Message::NodeList::get_key(i),
!                             Message::NodeList::get_value(i).get_addr(),
!                             Message::NodeList::get_value(i).get_mcast_addr()));
!         if (Message::NodeList::get_key(i) == get_remote_uuid()     &&
!             mcast_addr == "" &&
!             Message::NodeList::get_value(i).get_mcast_addr() != "")
          {
!             mcast_addr = Message::NodeList::get_value(i).get_mcast_addr();
          }
      }
  
!     if (link_map != new_map)
      {
!         changed = true;
      }
!     link_map = new_map;
  }
  
  
--- 156,182 ----
  
  void gcomm::gmcast::Proto::handle_topology_change(const Message& msg)
  {
!     const Message::NodeList& nl(msg.node_list());
  
      LinkMap new_map;
      for (Message::NodeList::const_iterator i = nl.begin(); i != nl.end(); ++i)
      {
!         new_map.insert(Link(Message::NodeList::key(i),
!                             Message::NodeList::value(i).addr(),
!                             Message::NodeList::value(i).mcast_addr()));
!         if (Message::NodeList::key(i) == remote_uuid()     &&
!             mcast_addr_ == "" &&
!             Message::NodeList::value(i).mcast_addr() != "")
          {
!             mcast_addr_ = Message::NodeList::value(i).mcast_addr();
          }
      }
  
!     if (link_map_ != new_map)
      {
!         changed_ = true;
      }
!     link_map_ = new_map;
  }
  
  
***************
*** 186,201 ****
      Message::NodeList nl;
      for (LinkMap::const_iterator i = um.begin(); i != um.end(); ++i)
      {
!         if (LinkMap::get_key(i) == UUID::nil() ||
!             LinkMap::get_value(i).get_addr() == "")
              gu_throw_fatal << "nil uuid or empty address";
  
!         nl.insert_unique(make_pair(LinkMap::get_key(i),
!                                    Node(LinkMap::get_value(i).get_addr())));
      }
  
!     Message msg(version, Message::T_TOPOLOGY_CHANGE, local_uuid,
!                 group_name, nl);
  
      send_msg(msg);
  }
--- 185,201 ----
      Message::NodeList nl;
      for (LinkMap::const_iterator i = um.begin(); i != um.end(); ++i)
      {
!         if (LinkMap::key(i) == UUID::nil() ||
!             LinkMap::value(i).addr() == "")
              gu_throw_fatal << "nil uuid or empty address";
  
!         nl.insert_unique(
!             std::make_pair(LinkMap::key(i),
!                            Node(LinkMap::value(i).addr())));
      }
  
!     Message msg(version_, Message::T_TOPOLOGY_CHANGE, local_uuid_,
!                 group_name_, nl);
  
      send_msg(msg);
  }
***************
*** 204,210 ****
  void gcomm::gmcast::Proto::handle_message(const Message& msg)
  {
  
!     switch (msg.get_type())
      {
      case Message::T_HANDSHAKE:
          handle_handshake(msg);
--- 204,210 ----
  void gcomm::gmcast::Proto::handle_message(const Message& msg)
  {
  
!     switch (msg.type())
      {
      case Message::T_HANDSHAKE:
          handle_handshake(msg);
***************
*** 222,228 ****
          handle_topology_change(msg);
          break;
      default:
!         gu_throw_fatal << "invalid message type: " << msg.get_type();
          throw;
      }
  }
--- 222,228 ----
          handle_topology_change(msg);
          break;
      default:
!         gu_throw_fatal << "invalid message type: " << msg.type();
          throw;
      }
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/gmcast_proto.hpp 2.x/gcomm/src/gmcast_proto.hpp
*** galera-23.2.2-src/gcomm/src/gmcast_proto.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/gmcast_proto.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 40,48 ****
  public:
  
      void set_state(State new_state);
!     State get_state() const
      {
!         return state;
      }
  
      static std::string to_string (State s)
--- 40,48 ----
  public:
  
      void set_state(State new_state);
!     State state() const
      {
!         return state_;
      }
  
      static std::string to_string (State s)
***************
*** 63,92 ****
  
  
      Proto (int v,
!            SocketPtr          tp_,
!            const std::string& local_addr_,
!            const std::string& remote_addr_,
!            const std::string& mcast_addr_,
!            const gcomm::UUID& local_uuid_,
!            const std::string& group_name_)
          :
!         version(v),
!         handshake_uuid   (),
!         local_uuid       (local_uuid_),
!         remote_uuid      (),
!         local_addr       (local_addr_),
!         remote_addr      (remote_addr_),
!         mcast_addr       (mcast_addr_),
!         group_name       (group_name_),
!         changed          (false),
!         state            (S_INIT),
!         propagate_remote (false),
!         tp               (tp_),
!         link_map         (),
!         tstamp           (gu::datetime::Date::now())
      { }
  
!     ~Proto() { tp->close(); }
  
      void send_msg(const Message& msg);
      void send_handshake();
--- 63,92 ----
  
  
      Proto (int v,
!            SocketPtr          tp,
!            const std::string& local_addr,
!            const std::string& remote_addr,
!            const std::string& mcast_addr,
!            const gcomm::UUID& local_uuid,
!            const std::string& group_name)
          :
!         version_(v),
!         handshake_uuid_   (),
!         local_uuid_       (local_uuid),
!         remote_uuid_      (),
!         local_addr_       (local_addr),
!         remote_addr_      (remote_addr),
!         mcast_addr_       (mcast_addr),
!         group_name_       (group_name),
!         changed_          (false),
!         state_            (S_INIT),
!         propagate_remote_ (false),
!         tp_               (tp),
!         link_map_         (),
!         tstamp_           (gu::datetime::Date::now())
      { }
  
!     ~Proto() { tp_->close(); }
  
      void send_msg(const Message& msg);
      void send_handshake();
***************
*** 99,159 ****
      void send_topology_change(LinkMap& um);
      void handle_message(const Message& msg);
  
!     const gcomm::UUID& get_handshake_uuid() const { return handshake_uuid; }
!     const gcomm::UUID& get_local_uuid() const { return local_uuid; }
!     const gcomm::UUID& get_remote_uuid() const { return remote_uuid; }
  
!     SocketPtr get_socket() const { return tp; }
  
!     const std::string& get_remote_addr() const { return remote_addr; }
!     const std::string& get_mcast_addr() const { return mcast_addr; }
!     const LinkMap& get_link_map() const { return link_map; }
  
!     bool get_changed()
      {
!         bool ret = changed;
!         changed = false;
          return ret;
      }
!     int get_version() const { return version; }
!     void set_tstamp(gu::datetime::Date ts) { tstamp = ts; }
!     gu::datetime::Date get_tstamp() const { return tstamp; }
  private:
      friend std::ostream& operator<<(std::ostream&, const Proto&);
      Proto(const Proto&);
      void operator=(const Proto&);
  
!     int version;
!     gcomm::UUID       handshake_uuid;
!     gcomm::UUID       local_uuid;  // @todo: do we need it here?
!     gcomm::UUID       remote_uuid;
!     std::string       local_addr;
!     std::string       remote_addr;
!     std::string       mcast_addr;
!     std::string       group_name;
!     bool              changed;
!     State             state;
!     bool              propagate_remote;
!     SocketPtr         tp;
!     LinkMap           link_map;
!     gu::datetime::Date tstamp;
  };
  
  
  inline std::ostream& gcomm::gmcast::operator<<(std::ostream& os, const Proto& p)
  {
!     os << "v="  << p.version << ","
!        << "lu=" << p.local_uuid << ","
!        << "ru=" << p.remote_uuid << ","
!        << "la=" << p.local_addr << ","
!        << "ra=" << p.remote_addr << ","
!        << "mc=" << p.mcast_addr << ","
!        << "gn=" << p.group_name << ","
!        << "ch=" << p.changed << ","
!        << "st=" << gcomm::gmcast::Proto::to_string(p.state) << ","
!        << "pr=" << p.propagate_remote << ","
!        << "tp=" << p.tp << ","
!        << "ts=" << p.tstamp;
      return os;
  }
  
--- 99,159 ----
      void send_topology_change(LinkMap& um);
      void handle_message(const Message& msg);
  
!     const gcomm::UUID& handshake_uuid() const { return handshake_uuid_; }
!     const gcomm::UUID& local_uuid() const { return local_uuid_; }
!     const gcomm::UUID& remote_uuid() const { return remote_uuid_; }
  
!     SocketPtr socket() const { return tp_; }
  
!     const std::string& remote_addr() const { return remote_addr_; }
!     const std::string& mcast_addr() const { return mcast_addr_; }
!     const LinkMap& link_map() const { return link_map_; }
  
!     bool changed()
      {
!         bool ret = changed_;
!         changed_ = false;
          return ret;
      }
!     int version() const { return version_; }
!     void set_tstamp(gu::datetime::Date ts) { tstamp_ = ts; }
!     gu::datetime::Date tstamp() const { return tstamp_; }
  private:
      friend std::ostream& operator<<(std::ostream&, const Proto&);
      Proto(const Proto&);
      void operator=(const Proto&);
  
!     int version_;
!     gcomm::UUID       handshake_uuid_;
!     gcomm::UUID       local_uuid_;  // @todo: do we need it here?
!     gcomm::UUID       remote_uuid_;
!     std::string       local_addr_;
!     std::string       remote_addr_;
!     std::string       mcast_addr_;
!     std::string       group_name_;
!     bool              changed_;
!     State             state_;
!     bool              propagate_remote_;
!     SocketPtr         tp_;
!     LinkMap           link_map_;
!     gu::datetime::Date tstamp_;
  };
  
  
  inline std::ostream& gcomm::gmcast::operator<<(std::ostream& os, const Proto& p)
  {
!     os << "v="  << p.version_ << ","
!        << "lu=" << p.local_uuid_ << ","
!        << "ru=" << p.remote_uuid_ << ","
!        << "la=" << p.local_addr_ << ","
!        << "ra=" << p.remote_addr_ << ","
!        << "mc=" << p.mcast_addr_ << ","
!        << "gn=" << p.group_name_ << ","
!        << "ch=" << p.changed_ << ","
!        << "st=" << gcomm::gmcast::Proto::to_string(p.state_) << ","
!        << "pr=" << p.propagate_remote_ << ","
!        << "tp=" << p.tp_ << ","
!        << "ts=" << p.tstamp_;
      return os;
  }
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/histogram.cpp 2.x/gcomm/src/histogram.cpp
*** galera-23.2.2-src/gcomm/src/histogram.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/histogram.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 14,32 ****
  #include <limits>
  #include <vector>
  
! using namespace std;
! 
! gcomm::Histogram::Histogram(const string& vals)
      :
!     cnt()
  {
!     vector<string> varr = gu::strsplit(vals, ',');
  
!     for (vector<string>::const_iterator i = varr.begin(); i != varr.end(); ++i)
      {
          double val;
  
!         istringstream is(*i);
          is >> val;
  
          if (is.fail())
--- 14,31 ----
  #include <limits>
  #include <vector>
  
! gcomm::Histogram::Histogram(const std::string& vals)
      :
!     cnt_()
  {
!     std::vector<std::string> varr = gu::strsplit(vals, ',');
  
!     for (std::vector<std::string>::const_iterator
!              i = varr.begin(); i != varr.end(); ++i)
      {
          double val;
  
!         std::istringstream is(*i);
          is >> val;
  
          if (is.fail())
***************
*** 34,46 ****
              gu_throw_fatal << "Parse error";
          }
  
!         if (cnt.insert(make_pair(val, 0)).second == false)
          {
              gu_throw_fatal << "Failed to insert value: " << val;
          }
      }
  
!     if (cnt.insert(make_pair(numeric_limits<double>::max(), 0)).second == false)
      {
          gu_throw_fatal << "Failed to insert numeric_limits<double>::max()";
      }
--- 33,47 ----
              gu_throw_fatal << "Parse error";
          }
  
!         if (cnt_.insert(std::make_pair(val, 0)).second == false)
          {
              gu_throw_fatal << "Failed to insert value: " << val;
          }
      }
  
!     if (cnt_.insert(
!             std::make_pair(
!                 std::numeric_limits<double>::max(), 0)).second == false)
      {
          gu_throw_fatal << "Failed to insert numeric_limits<double>::max()";
      }
***************
*** 54,62 ****
          return;
      }
  
!     map<const double, long long>::iterator i = cnt.lower_bound(val);
  
!     if (i == cnt.end())
      {
          gu_throw_fatal;
      }
--- 55,63 ----
          return;
      }
  
!     std::map<double, long long>::iterator i = cnt_.lower_bound(val);
  
!     if (i == cnt_.end())
      {
          gu_throw_fatal;
      }
***************
*** 66,96 ****
  
  void gcomm::Histogram::clear()
  {
!     for (map<const double, long long>::iterator i = cnt.begin();
!          i != cnt.end(); ++i)
      {
          i->second = 0;
      }
  }
  
! ostream& gcomm::operator<<(ostream& os, const Histogram& hs)
  {
!     map<const double, long long>::const_iterator i, i_next;
  
      long long norm = 0;
!     for (i = hs.cnt.begin(); i != hs.cnt.end(); ++i)
      {
          norm += i->second;
      }
  
!     for (i = hs.cnt.begin(); i != hs.cnt.end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         if (i_next == hs.cnt.end())
              break;
          os << i->first << " -> " << i_next->first << ": "
!            << 100.*double(i_next->second + (i == hs.cnt.begin() ? i->second : 0))/double(norm) << " ";
      }
      os << "total: " << norm;
  
--- 67,97 ----
  
  void gcomm::Histogram::clear()
  {
!     for (std::map<double, long long>::iterator i = cnt_.begin();
!          i != cnt_.end(); ++i)
      {
          i->second = 0;
      }
  }
  
! std::ostream& gcomm::operator<<(std::ostream& os, const Histogram& hs)
  {
!     std::map<double, long long>::const_iterator i, i_next;
  
      long long norm = 0;
!     for (i = hs.cnt_.begin(); i != hs.cnt_.end(); ++i)
      {
          norm += i->second;
      }
  
!     for (i = hs.cnt_.begin(); i != hs.cnt_.end(); i = i_next)
      {
          i_next = i;
          ++i_next;
!         if (i_next == hs.cnt_.end())
              break;
          os << i->first << " -> " << i_next->first << ": "
!            << 100.*double(i_next->second + (i == hs.cnt_.begin() ? i->second : 0))/double(norm) << " ";
      }
      os << "total: " << norm;
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/histogram.hpp 2.x/gcomm/src/histogram.hpp
*** galera-23.2.2-src/gcomm/src/histogram.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/histogram.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 19,25 ****
          void clear();
          friend std::ostream& operator<<(std::ostream&, const Histogram&);
      private:
!         std::map<const double, long long> cnt;
      };
  
      std::ostream& operator<<(std::ostream&, const Histogram&);
--- 19,25 ----
          void clear();
          friend std::ostream& operator<<(std::ostream&, const Histogram&);
      private:
!         std::map<double, long long> cnt_;
      };
  
      std::ostream& operator<<(std::ostream&, const Histogram&);
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/pc.cpp 2.x/gcomm/src/pc.cpp
*** galera-23.2.2-src/gcomm/src/pc.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/pc.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 15,37 ****
  
  #include "gu_datetime.hpp"
  
- using namespace std;
- using namespace gcomm;
  
! using namespace gu;
! using namespace gu::datetime;
! 
! 
! void PC::handle_up(const void* cid, const Datagram& rb,
                     const ProtoUpMeta& um)
  {
      send_up(rb, um);
  }
  
  
! int PC::handle_down(Datagram& wb, const ProtoDownMeta& dm)
  {
!     if (wb.get_len() == 0)
      {
          gu_throw_error(EMSGSIZE);
      }
--- 15,31 ----
  
  #include "gu_datetime.hpp"
  
  
! void gcomm::PC::handle_up(const void* cid, const Datagram& rb,
                     const ProtoUpMeta& um)
  {
      send_up(rb, um);
  }
  
  
! int gcomm::PC::handle_down(Datagram& wb, const ProtoDownMeta& dm)
  {
!     if (wb.len() == 0)
      {
          gu_throw_error(EMSGSIZE);
      }
***************
*** 39,85 ****
  }
  
  
! size_t PC::get_mtu() const
  {
      // TODO:
!     if (gmcast == 0) gu_throw_fatal << "not open";
  
      evs::UserMessage evsm;
      pc::UserMessage  pcm(0, 0);
  
!     if (gmcast->get_mtu() < 2*evsm.serial_size() + pcm.serial_size())
      {
          gu_throw_fatal << "transport max msg size too small: "
!                           << gmcast->get_mtu();
      }
  
!     return gmcast->get_mtu() - 2*evsm.serial_size() - pcm.serial_size();
  }
  
! 
! bool PC::supports_uuid() const
! {
!     if (gmcast->supports_uuid() == false)
!     {
!         // alex: what is the meaning of this ?
!         gu_throw_fatal << "transport does not support UUID";
!     }
!     return true;
! }
! 
! 
! const UUID& PC::get_uuid() const
  {
!     return gmcast->get_uuid();
  }
  
! std::string gcomm::PC::get_listen_addr() const
  {
!     return gmcast->get_listen_addr();
  }
  
  
! void PC::connect()
  {
      bool start_prim(false);
  
--- 33,67 ----
  }
  
  
! size_t gcomm::PC::mtu() const
  {
      // TODO:
!     if (gmcast_ == 0) gu_throw_fatal << "not open";
  
      evs::UserMessage evsm;
      pc::UserMessage  pcm(0, 0);
  
!     if (gmcast_->mtu() < 2*evsm.serial_size() + pcm.serial_size())
      {
          gu_throw_fatal << "transport max msg size too small: "
!                           << gmcast_->mtu();
      }
  
!     return gmcast_->mtu() - 2*evsm.serial_size() - pcm.serial_size();
  }
  
! const gcomm::UUID& gcomm::PC::uuid() const
  {
!     return gmcast_->uuid();
  }
  
! std::string gcomm::PC::listen_addr() const
  {
!     return gmcast_->listen_addr();
  }
  
  
! void gcomm::PC::connect()
  {
      bool start_prim(false);
  
***************
*** 94,164 ****
      const bool wait_prim(
          gu::from_string<bool>(
              uri_.get_option(Conf::PcWaitPrim, Defaults::PcWaitPrim)));
!     const Period wait_prim_timeout(
!         gu::from_string<Period>(
              uri_.get_option(Conf::PcWaitPrimTimeout,
                              Defaults::PcWaitPrimTimeout)));
!     pstack_.push_proto(gmcast);
!     pstack_.push_proto(evs);
!     pstack_.push_proto(pc);
      pstack_.push_proto(this);
!     get_pnet().insert(&pstack_);
  
!     gmcast->connect();
  
!     closed = false;
  
!     evs->shift_to(evs::Proto::S_JOINING);
!     pc->connect(start_prim);
  
      // Due to #658 there is limited announce period after which
      // node is allowed to proceed to non-prim if other nodes
      // are not detected.
!     Date try_until(Date::now() + announce_timeout);
!     while (start_prim == false && evs->get_known_size() <= 1)
      {
          // Send join messages without handling them
!         evs->send_join(false);
!         get_pnet().event_loop(Sec/2);
  
!         if (try_until < Date::now())
          {
              break;
          }
      }
  
!     log_debug << "PC/EVS Proto initial state: " << *evs;
!     if (evs->get_state() != evs::Proto::S_OPERATIONAL)
      {
          log_debug << "PC/EVS Proto sending join request";
!         evs->send_join();
      }
!     gcomm_assert(evs->get_state() == evs::Proto::S_GATHER ||
!                  evs->get_state() == evs::Proto::S_INSTALL ||
!                  evs->get_state() == evs::Proto::S_OPERATIONAL);
  
      // - Due to #658 we loop here only if node is told to start in prim.
      // - Fix for #680, bypass waiting prim only if explicitly required
!     try_until = Date::now() + wait_prim_timeout;
      while ((wait_prim == true || start_prim == true) &&
!            pc->get_state() != pc::Proto::S_PRIM)
      {
!         get_pnet().event_loop(Sec/2);
!         if (try_until < Date::now())
          {
!             pc->close();
!             evs->close();
!             gmcast->close();
!             get_pnet().erase(&pstack_);
              pstack_.pop_proto(this);
!             pstack_.pop_proto(pc);
!             pstack_.pop_proto(evs);
!             pstack_.pop_proto(gmcast);
              gu_throw_error(ETIMEDOUT) << "failed to reach primary view";
          }
      }
  
!     pc->set_mtu(get_mtu());
  }
  
  void gcomm::PC::connect(const gu::URI& uri)
--- 76,146 ----
      const bool wait_prim(
          gu::from_string<bool>(
              uri_.get_option(Conf::PcWaitPrim, Defaults::PcWaitPrim)));
!     const gu::datetime::Period wait_prim_timeout(
!         gu::from_string<gu::datetime::Period>(
              uri_.get_option(Conf::PcWaitPrimTimeout,
                              Defaults::PcWaitPrimTimeout)));
!     pstack_.push_proto(gmcast_);
!     pstack_.push_proto(evs_);
!     pstack_.push_proto(pc_);
      pstack_.push_proto(this);
!     pnet().insert(&pstack_);
  
!     gmcast_->connect();
  
!     closed_ = false;
  
!     evs_->shift_to(evs::Proto::S_JOINING);
!     pc_->connect(start_prim);
  
      // Due to #658 there is limited announce period after which
      // node is allowed to proceed to non-prim if other nodes
      // are not detected.
!     gu::datetime::Date try_until(gu::datetime::Date::now() + announce_timeout_);
!     while (start_prim == false && evs_->known_size() <= 1)
      {
          // Send join messages without handling them
!         evs_->send_join(false);
!         pnet().event_loop(gu::datetime::Sec/2);
  
!         if (try_until < gu::datetime::Date::now())
          {
              break;
          }
      }
  
!     log_debug << "PC/EVS Proto initial state: " << *evs_;
!     if (evs_->state() != evs::Proto::S_OPERATIONAL)
      {
          log_debug << "PC/EVS Proto sending join request";
!         evs_->send_join();
      }
!     gcomm_assert(evs_->state() == evs::Proto::S_GATHER ||
!                  evs_->state() == evs::Proto::S_INSTALL ||
!                  evs_->state() == evs::Proto::S_OPERATIONAL);
  
      // - Due to #658 we loop here only if node is told to start in prim.
      // - Fix for #680, bypass waiting prim only if explicitly required
!     try_until = gu::datetime::Date::now() + wait_prim_timeout;
      while ((wait_prim == true || start_prim == true) &&
!            pc_->state() != pc::Proto::S_PRIM)
      {
!         pnet().event_loop(gu::datetime::Sec/2);
!         if (try_until < gu::datetime::Date::now())
          {
!             pc_->close();
!             evs_->close();
!             gmcast_->close();
!             pnet().erase(&pstack_);
              pstack_.pop_proto(this);
!             pstack_.pop_proto(pc_);
!             pstack_.pop_proto(evs_);
!             pstack_.pop_proto(gmcast_);
              gu_throw_error(ETIMEDOUT) << "failed to reach primary view";
          }
      }
  
!     pc_->set_mtu(mtu());
  }
  
  void gcomm::PC::connect(const gu::URI& uri)
***************
*** 168,252 ****
  }
  
  
! void PC::close(bool force)
  {
  
      if (force == false)
      {
          log_debug << "PC/EVS Proto leaving";
! 	pc->close();
! 	evs->close();
  
! 	Date wait_until(Date::now() + linger);
  
  	do
  	{
!             get_pnet().event_loop(Sec/2);
  	}
! 	while (evs->get_state() != evs::Proto::S_CLOSED &&
! 	       Date::now()      <  wait_until);
  
! 	if (evs->get_state() != evs::Proto::S_CLOSED)
  	{
!             evs->shift_to(evs::Proto::S_CLOSED);
  	}
  
! 	if (pc->get_state() != pc::Proto::S_CLOSED)
  	{
              log_warn << "PCProto didn't reach closed state";
  	}
  
! 	gmcast->close();
      }
      else
      {
  	log_info << "Forced PC close";
      }
!     get_pnet().erase(&pstack_);
      pstack_.pop_proto(this);
!     pstack_.pop_proto(pc);
!     pstack_.pop_proto(evs);
!     pstack_.pop_proto(gmcast);
  
!     closed = true;
  }
  
  
! PC::PC(Protonet& net, const gu::URI& uri) :
      Transport (net, uri),
!     gmcast    (0),
!     evs       (0),
!     pc        (0),
!     closed    (true),
!     linger    (param<Period>(conf_, uri, Conf::PcLinger, "PT2S")),
!     announce_timeout(param<Period>(conf_, uri, Conf::PcAnnounceTimeout,
!                                    Defaults::PcAnnounceTimeout))
  {
      if (uri_.get_scheme() != Conf::PcScheme)
      {
          log_fatal << "invalid uri: " << uri_.to_string();
      }
  
!     gmcast = new GMCast(get_pnet(), uri_);
  
!     const UUID& uuid(gmcast->get_uuid());
  
      if (uuid == UUID::nil())
      {
          gu_throw_fatal << "invalid UUID: " << uuid;
      }
      evs::UserMessage evsum;
!     evs = new evs::Proto(get_pnet().conf(),
!                          uuid, uri_, gmcast->get_mtu() - 2*evsum.serial_size());
!     pc  = new pc::Proto (get_pnet().conf(), uuid, uri_);
  
!     conf_.set(Conf::PcLinger, gu::to_string(linger));
  }
  
  
! PC::~PC()
  {
!     if (!closed)
      {
          try
          {
--- 150,236 ----
  }
  
  
! void gcomm::PC::close(bool force)
  {
  
      if (force == false)
      {
          log_debug << "PC/EVS Proto leaving";
! 	pc_->close();
! 	evs_->close();
  
!         gu::datetime::Date wait_until(gu::datetime::Date::now() + linger_);
  
  	do
  	{
!             pnet().event_loop(gu::datetime::Sec/2);
  	}
! 	while (evs_->state()         != evs::Proto::S_CLOSED &&
! 	       gu::datetime::Date::now() <  wait_until);
  
! 	if (evs_->state() != evs::Proto::S_CLOSED)
  	{
!             evs_->shift_to(evs::Proto::S_CLOSED);
  	}
  
! 	if (pc_->state() != pc::Proto::S_CLOSED)
  	{
              log_warn << "PCProto didn't reach closed state";
  	}
  
! 	gmcast_->close();
      }
      else
      {
  	log_info << "Forced PC close";
      }
!     pnet().erase(&pstack_);
      pstack_.pop_proto(this);
!     pstack_.pop_proto(pc_);
!     pstack_.pop_proto(evs_);
!     pstack_.pop_proto(gmcast_);
  
!     closed_ = true;
  }
  
  
! gcomm::PC::PC(Protonet& net, const gu::URI& uri) :
      Transport (net, uri),
!     gmcast_    (0),
!     evs_       (0),
!     pc_        (0),
!     closed_    (true),
!     linger_    (param<gu::datetime::Period>(
!                     conf_, uri, Conf::PcLinger, "PT2S")),
!     announce_timeout_(param<gu::datetime::Period>(
!                           conf_, uri, Conf::PcAnnounceTimeout,
!                           Defaults::PcAnnounceTimeout))
  {
      if (uri_.get_scheme() != Conf::PcScheme)
      {
          log_fatal << "invalid uri: " << uri_.to_string();
      }
  
!     gmcast_ = new GMCast(pnet(), uri_);
  
!     const UUID& uuid(gmcast_->uuid());
  
      if (uuid == UUID::nil())
      {
          gu_throw_fatal << "invalid UUID: " << uuid;
      }
      evs::UserMessage evsum;
!     evs_ = new evs::Proto(pnet().conf(),
!                           uuid, uri_, gmcast_->mtu() - 2*evsum.serial_size());
!     pc_  = new pc::Proto (pnet().conf(), uuid, uri_);
  
!     conf_.set(Conf::PcLinger, gu::to_string(linger_));
  }
  
  
! gcomm::PC::~PC()
  {
!     if (!closed_)
      {
          try
          {
***************
*** 257,263 ****
          sleep(1); // half-hearted attempt to avoid race with client threads
      }
  
!     delete gmcast;
!     delete evs;
!     delete pc;
  }
--- 241,247 ----
          sleep(1); // half-hearted attempt to avoid race with client threads
      }
  
!     delete gmcast_;
!     delete evs_;
!     delete pc_;
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/pc.hpp 2.x/gcomm/src/pc.hpp
*** galera-23.2.2-src/gcomm/src/pc.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/pc.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 26,52 ****
  
          void connect();
          void connect(const gu::URI&);
!         std::string get_listen_addr() const;
  
          void close(bool force = false);
  
!         void handle_up(const void*, const gu::Datagram&, const ProtoUpMeta&);
!         int  handle_down(gu::Datagram&, const ProtoDownMeta&);
  
!         bool supports_uuid() const;
!         const UUID& get_uuid() const;
  
!         size_t get_mtu() const;
  
      private:
  
!         GMCast*     gmcast;             // GMCast transport
!         evs::Proto* evs;                // EVS protocol layer
!         pc::Proto*  pc;                 // PC protocol layer
!         bool        closed;             // flag for destructor
                                          // Period to wait graceful leave
!         gu::datetime::Period linger;
!         gu::datetime::Period announce_timeout;
  
          PC(const PC&);
          void operator=(const PC&);
--- 26,51 ----
  
          void connect();
          void connect(const gu::URI&);
!         std::string listen_addr() const;
  
          void close(bool force = false);
  
!         void handle_up(const void*, const Datagram&, const ProtoUpMeta&);
!         int  handle_down(Datagram&, const ProtoDownMeta&);
  
!         const UUID& uuid() const;
  
!         size_t mtu() const;
  
      private:
  
!         GMCast*     gmcast_;             // GMCast transport
!         evs::Proto* evs_;                // EVS protocol layer
!         pc::Proto*  pc_;                 // PC protocol layer
!         bool        closed_;             // flag for destructor
                                          // Period to wait graceful leave
!         gu::datetime::Period linger_;
!         gu::datetime::Period announce_timeout_;
  
          PC(const PC&);
          void operator=(const PC&);
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/pc_message.hpp 2.x/gcomm/src/pc_message.hpp
*** galera-23.2.2-src/gcomm/src/pc_message.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/pc_message.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 34,61 ****
  class gcomm::pc::Node
  {
  public:
!     enum Flags { F_PRIM = 0x1 };
  
      Node(const bool     prim      = false,
           const uint32_t last_seq  = std::numeric_limits<uint32_t>::max(),
           const ViewId&  last_prim = ViewId(V_NON_PRIM),
!          const int64_t  to_seq    = -1)
          :
          prim_      (prim     ),
          last_seq_  (last_seq ),
          last_prim_ (last_prim),
!         to_seq_    (to_seq   )
      { }
  
      void set_prim      (const bool val)          { prim_      = val      ; }
      void set_last_seq  (const uint32_t seq)      { last_seq_  = seq      ; }
      void set_last_prim (const ViewId& last_prim) { last_prim_ = last_prim; }
      void set_to_seq    (const uint64_t seq)      { to_seq_    = seq      ; }
  
!     bool          get_prim()      const { return prim_     ; }
!     uint32_t      get_last_seq()  const { return last_seq_ ; }
!     const ViewId& get_last_prim() const { return last_prim_; }
!     int64_t       get_to_seq()    const { return to_seq_   ; }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
          throw (gu::Exception)
--- 34,69 ----
  class gcomm::pc::Node
  {
  public:
!     enum Flags
!     {
!         F_PRIM   = 0x1,
!         F_WEIGHT = 0x2
!     };
  
      Node(const bool     prim      = false,
           const uint32_t last_seq  = std::numeric_limits<uint32_t>::max(),
           const ViewId&  last_prim = ViewId(V_NON_PRIM),
!          const int64_t  to_seq    = -1,
!          const int      weight    = -1)
          :
          prim_      (prim     ),
          last_seq_  (last_seq ),
          last_prim_ (last_prim),
!         to_seq_    (to_seq   ),
!         weight_    (weight)
      { }
  
      void set_prim      (const bool val)          { prim_      = val      ; }
      void set_last_seq  (const uint32_t seq)      { last_seq_  = seq      ; }
      void set_last_prim (const ViewId& last_prim) { last_prim_ = last_prim; }
      void set_to_seq    (const uint64_t seq)      { to_seq_    = seq      ; }
+     void set_weight    (const int weight)        { weight_    = weight   ; }
  
!     bool          prim()      const { return prim_     ; }
!     uint32_t      last_seq()  const { return last_seq_ ; }
!     const ViewId& last_prim() const { return last_prim_; }
!     int64_t       to_seq()    const { return to_seq_   ; }
!     int           weight()    const { return weight_   ; }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
          throw (gu::Exception)
***************
*** 66,72 ****
          gu_trace (off = gu::unserialize4(buf, buflen, off, flags));
  
          prim_ = flags & F_PRIM;
! 
          gu_trace (off = gu::unserialize4(buf, buflen, off, last_seq_));
          gu_trace (off = last_prim_.unserialize(buf, buflen, off));
          gu_trace (off = gu::unserialize8(buf, buflen, off, to_seq_));
--- 74,87 ----
          gu_trace (off = gu::unserialize4(buf, buflen, off, flags));
  
          prim_ = flags & F_PRIM;
!         if (flags & F_WEIGHT)
!         {
!             weight_ = flags >> 24;
!         }
!         else
!         {
!             weight_ = -1;
!         }
          gu_trace (off = gu::unserialize4(buf, buflen, off, last_seq_));
          gu_trace (off = last_prim_.unserialize(buf, buflen, off));
          gu_trace (off = gu::unserialize8(buf, buflen, off, to_seq_));
***************
*** 81,87 ****
          uint32_t flags = 0;
  
          flags |= prim_ ? F_PRIM : 0;
! 
          gu_trace (off = gu::serialize4(flags, buf, buflen, off));
          gu_trace (off = gu::serialize4(last_seq_, buf, buflen, off));
          gu_trace (off = last_prim_.serialize(buf, buflen, off));
--- 96,106 ----
          uint32_t flags = 0;
  
          flags |= prim_ ? F_PRIM : 0;
!         if (weight_ >= 0)
!         {
!             flags |= F_WEIGHT;
!             flags |= weight_ << 24;
!         }
          gu_trace (off = gu::serialize4(flags, buf, buflen, off));
          gu_trace (off = gu::serialize4(last_seq_, buf, buflen, off));
          gu_trace (off = last_prim_.serialize(buf, buflen, off));
***************
*** 103,122 ****
  
      bool operator==(const Node& cmp) const
      {
!         return get_prim()   == cmp.get_prim()      &&
!             get_last_seq()  == cmp.get_last_seq()  &&
!             get_last_prim() == cmp.get_last_prim() &&
!             get_to_seq()    == cmp.get_to_seq();
      }
  
      std::string to_string() const
      {
          std::ostringstream ret;
  
!         ret << "prim="        << prim_
              << ",last_seq="  << last_seq_
              << ",last_prim=" << last_prim_
!             << ",to_seq="    << to_seq_;
  
          return ret.str();
      }
--- 122,143 ----
  
      bool operator==(const Node& cmp) const
      {
!         return (prim()   == cmp.prim()         &&
!                 last_seq()  == cmp.last_seq()  &&
!                 last_prim() == cmp.last_prim() &&
!                 to_seq()    == cmp.to_seq()    &&
!                 weight()    == cmp.weight() );
      }
  
      std::string to_string() const
      {
          std::ostringstream ret;
  
!         ret << "prim="       << prim_
              << ",last_seq="  << last_seq_
              << ",last_prim=" << last_prim_
!             << ",to_seq="    << to_seq_
!             << ",weight="    << weight_;
  
          return ret.str();
      }
***************
*** 127,132 ****
--- 148,154 ----
      uint32_t last_seq_;  // Last seen message seq from the node
      ViewId   last_prim_; // Last known prim comp view id for the node
      int64_t  to_seq_;    // Last known TO seq for the node
+     int      weight_;    // Node weight
  };
  
  
***************
*** 144,150 ****
  public:
  
      enum Type {T_NONE, T_STATE, T_INSTALL, T_USER, T_MAX};
!     enum { F_CRC16 = 0x1, F_BOOTSTRAP = 0x2 };
  
      static const char* to_string(Type t)
      {
--- 166,176 ----
  public:
  
      enum Type {T_NONE, T_STATE, T_INSTALL, T_USER, T_MAX};
!     enum
!     {
!         F_CRC16 = 0x1,
!         F_BOOTSTRAP = 0x2
!     };
  
      static const char* to_string(Type t)
      {
***************
*** 183,191 ****
      virtual ~Message() { }
  
  
!     int      get_version()  const { return version_; }
!     Type     get_type()     const { return type_; }
!     uint32_t get_seq()      const { return seq_; }
  
      void flags(int flags) { flags_ = flags; }
      int flags() const { return flags_; }
--- 209,217 ----
      virtual ~Message() { }
  
  
!     int      version()  const { return version_; }
!     Type     type()     const { return type_; }
!     uint32_t seq()      const { return seq_; }
  
      void flags(int flags) { flags_ = flags; }
      int flags() const { return flags_; }
***************
*** 203,213 ****
      }
      uint16_t checksum() const { return crc16_; }
  
!     const NodeMap& get_node_map() const { return node_map_; }
!     NodeMap&       get_node_map()       { return node_map_; }
  
!     const Node&    get_node(const UUID& uuid) const
!     { return NodeMap::get_value(node_map_.find_checked(uuid)); }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
          throw (gu::Exception)
--- 229,239 ----
      }
      uint16_t checksum() const { return crc16_; }
  
!     const NodeMap& node_map() const { return node_map_; }
!     NodeMap&       node_map()       { return node_map_; }
  
!     const Node&    node(const UUID& uuid) const
!     { return NodeMap::value(node_map_.find_checked(uuid)); }
  
      size_t unserialize(const gu::byte_t* buf, const size_t buflen, const size_t offset)
          throw (gu::Exception)
***************
*** 285,291 ****
  
          ret << "pcmsg{ type=" << to_string(type_) << ", seq=" << seq_;
          ret << ", flags=" << std::setw(2) << std::hex << flags_;
!         ret << ", node_map {" << get_node_map() << "}";
          ret << '}';
  
          return ret.str();
--- 311,317 ----
  
          ret << "pcmsg{ type=" << to_string(type_) << ", seq=" << seq_;
          ret << ", flags=" << std::setw(2) << std::hex << flags_;
!         ret << ", node_map {" << node_map() << "}";
          ret << '}';
  
          return ret.str();
***************
*** 332,342 ****
  
  inline bool gcomm::pc::operator==(const Message& a, const Message& b)
  {
!     return (a.get_version()  == b.get_version() &&
              a.checksum()     == b.checksum()    &&
!             a.get_type()     == b.get_type()    &&
!             a.get_seq()      == b.get_seq()     &&
!             a.get_node_map() == b.get_node_map());
  }
  
  
--- 358,368 ----
  
  inline bool gcomm::pc::operator==(const Message& a, const Message& b)
  {
!     return (a.version()  == b.version() &&
              a.checksum()     == b.checksum()    &&
!             a.type()     == b.type()    &&
!             a.seq()      == b.seq()     &&
!             a.node_map() == b.node_map());
  }
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/pc_proto.cpp 2.x/gcomm/src/pc_proto.cpp
*** galera-23.2.2-src/gcomm/src/pc_proto.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/pc_proto.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 11,23 ****
  #include "gu_macros.h"
  #include <set>
  
! using namespace std;
! using namespace std::rel_ops;
! 
! using namespace gu;
! 
! using namespace gcomm;
! 
  //
  // Helpers
  //
--- 11,18 ----
  #include "gu_macros.h"
  #include <set>
  
! using std::rel_ops::operator!=;
! using std::rel_ops::operator>;
  //
  // Helpers
  //
***************
*** 28,43 ****
      SelectPrimOp(gcomm::pc::Proto::SMMap& states) : states_(states) { }
      void operator()(const gcomm::pc::Proto::SMMap::value_type& vt) const
      {
!         const gcomm::UUID& uuid(gcomm::pc::Proto::SMMap::get_key(vt));
!         const gcomm::pc::Message& msg(gcomm::pc::Proto::SMMap::get_value(vt));
!         const gcomm::pc::NodeMap& nm(msg.get_node_map());
          gcomm::pc::NodeMap::const_iterator nm_i(nm.find(uuid));
          if (nm_i == nm.end())
          {
              gu_throw_error(EPROTO) << "protocol error, self not found from "
                                     << uuid << " state msg node list";
          }
!         if (gcomm::pc::NodeMap::get_value(nm_i).get_prim() == true)
          {
              states_.insert(vt);
          }
--- 23,38 ----
      SelectPrimOp(gcomm::pc::Proto::SMMap& states) : states_(states) { }
      void operator()(const gcomm::pc::Proto::SMMap::value_type& vt) const
      {
!         const gcomm::UUID& uuid(gcomm::pc::Proto::SMMap::key(vt));
!         const gcomm::pc::Message& msg(gcomm::pc::Proto::SMMap::value(vt));
!         const gcomm::pc::NodeMap& nm(msg.node_map());
          gcomm::pc::NodeMap::const_iterator nm_i(nm.find(uuid));
          if (nm_i == nm.end())
          {
              gu_throw_error(EPROTO) << "protocol error, self not found from "
                                     << uuid << " state msg node list";
          }
!         if (gcomm::pc::NodeMap::value(nm_i).prim() == true)
          {
              states_.insert(vt);
          }
***************
*** 53,68 ****
                      const gcomm::pc::Proto::SMMap::value_type& b) const
      {
          const gcomm::pc::Node& astate(
!             gcomm::pc::NodeMap::get_value(
!                 gcomm::pc::Proto::SMMap::get_value(a).get_node_map()
!                 .find_checked(gcomm::pc::Proto::SMMap::get_key(a))));
  
          const gcomm::pc::Node& bstate(
!             gcomm::pc::NodeMap::get_value(
!                 gcomm::pc::Proto::SMMap::get_value(b).get_node_map()
!                 .find_checked(gcomm::pc::Proto::SMMap::get_key(b))));
  
!         return (astate.get_to_seq() < bstate.get_to_seq());
      }
  };
  
--- 48,63 ----
                      const gcomm::pc::Proto::SMMap::value_type& b) const
      {
          const gcomm::pc::Node& astate(
!             gcomm::pc::NodeMap::value(
!                 gcomm::pc::Proto::SMMap::value(a).node_map()
!                 .find_checked(gcomm::pc::Proto::SMMap::key(a))));
  
          const gcomm::pc::Node& bstate(
!             gcomm::pc::NodeMap::value(
!                 gcomm::pc::Proto::SMMap::value(b).node_map()
!                 .find_checked(gcomm::pc::Proto::SMMap::key(b))));
  
!         return (astate.to_seq() < bstate.to_seq());
      }
  };
  
***************
*** 74,97 ****
      gcomm::pc::Proto::SMMap::const_iterator max_i(
          max_element(states.begin(), states.end(), ToSeqCmpOp()));
      const gcomm::pc::Node& state(
!         gcomm::pc::Proto::SMMap::get_value(max_i).get_node(
!             gcomm::pc::Proto::SMMap::get_key(max_i)));
!     return state.get_to_seq();
  }
  
! static void checksum(pc::Message& msg, gu::Datagram& dg)
  {
!     uint16_t crc16(gu::crc16(dg, 4));
      msg.checksum(crc16, true);
!     pop_header(msg, dg);
!     push_header(msg, dg);
  }
  
! static void test_checksum(pc::Message& msg, const gu::Datagram& dg,
                            size_t offset)
  {
      uint16_t msg_crc16(msg.checksum());
!     uint16_t crc16(gu::crc16(dg, offset + 4));
      if (crc16 != msg_crc16)
      {
          gu_throw_fatal << "Message checksum failed";
--- 69,92 ----
      gcomm::pc::Proto::SMMap::const_iterator max_i(
          max_element(states.begin(), states.end(), ToSeqCmpOp()));
      const gcomm::pc::Node& state(
!         gcomm::pc::Proto::SMMap::value(max_i).node(
!             gcomm::pc::Proto::SMMap::key(max_i)));
!     return state.to_seq();
  }
  
! static void checksum(gcomm::pc::Message& msg, gcomm::Datagram& dg)
  {
!     uint16_t crc16(gcomm::crc16(dg, 4));
      msg.checksum(crc16, true);
!     gcomm::pop_header(msg, dg);
!     gcomm::push_header(msg, dg);
  }
  
! static void test_checksum(gcomm::pc::Message& msg, const gcomm::Datagram& dg,
                            size_t offset)
  {
      uint16_t msg_crc16(msg.checksum());
!     uint16_t crc16(gcomm::crc16(dg, offset + 4));
      if (crc16 != msg_crc16)
      {
          gu_throw_fatal << "Message checksum failed";
***************
*** 129,151 ****
  
      StateMessage pcs(version_);
  
!     NodeMap& im(pcs.get_node_map());
  
      for (NodeMap::iterator i = instances_.begin(); i != instances_.end(); ++i)
      {
          // Assume all nodes in the current view have reached current to_seq
!         Node& local_state(NodeMap::get_value(i));
!         if (current_view_.is_member(NodeMap::get_key(i)) == true)
          {
!             local_state.set_to_seq(get_to_seq());
          }
!         im.insert_unique(make_pair(NodeMap::get_key(i), local_state));
      }
  
!     log_debug << self_id() << " local to seq " << get_to_seq();
      log_debug << self_id() << " sending state: " << pcs;
  
!     Buffer buf;
      serialize(pcs, buf);
      Datagram dg(buf);
  
--- 124,146 ----
  
      StateMessage pcs(version_);
  
!     NodeMap& im(pcs.node_map());
  
      for (NodeMap::iterator i = instances_.begin(); i != instances_.end(); ++i)
      {
          // Assume all nodes in the current view have reached current to_seq
!         Node& local_state(NodeMap::value(i));
!         if (current_view_.is_member(NodeMap::key(i)) == true)
          {
!             local_state.set_to_seq(to_seq());
          }
!         im.insert_unique(std::make_pair(NodeMap::key(i), local_state));
      }
  
!     log_debug << self_id() << " local to seq " << to_seq();
      log_debug << self_id() << " sending state: " << pcs;
  
!     gu::Buffer buf;
      serialize(pcs, buf);
      Datagram dg(buf);
  
***************
*** 161,179 ****
  
      InstallMessage pci(version_);
  
!     NodeMap& im(pci.get_node_map());
  
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         if (current_view_.get_members().find(SMMap::get_key(i)) !=
!             current_view_.get_members().end())
          {
              gu_trace(
                  im.insert_unique(
!                     make_pair(
!                         SMMap::get_key(i),
!                         SMMap::get_value(i).get_node((SMMap::get_key(i))))));
          }
      }
  
--- 156,174 ----
  
      InstallMessage pci(version_);
  
!     NodeMap& im(pci.node_map());
  
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         if (current_view_.members().find(SMMap::key(i)) !=
!             current_view_.members().end())
          {
              gu_trace(
                  im.insert_unique(
!                     std::make_pair(
!                         SMMap::key(i),
!                         SMMap::value(i).node((SMMap::key(i))))));
          }
      }
  
***************
*** 187,193 ****
          log_debug << self_id() << " sending install: " << pci;
      }
  
!     Buffer buf;
      serialize(pci, buf);
      Datagram dg(buf);
      int ret = send_down(dg, ProtoDownMeta());
--- 182,188 ----
          log_debug << self_id() << " sending install: " << pci;
      }
  
!     gu::Buffer buf;
      serialize(pci, buf);
      Datagram dg(buf);
      int ret = send_down(dg, ProtoDownMeta());
***************
*** 201,218 ****
  
  void gcomm::pc::Proto::deliver_view(bool bootstrap)
  {
!     View v(pc_view_.get_id(), bootstrap);
  
!     v.add_members(current_view_.get_members().begin(),
!                   current_view_.get_members().end());
  
      for (NodeMap::const_iterator i = instances_.begin();
           i != instances_.end(); ++i)
      {
!         if (current_view_.get_members().find(NodeMap::get_key(i)) ==
!             current_view_.get_members().end())
          {
!             v.add_partitioned(NodeMap::get_key(i), "");
          }
      }
  
--- 196,213 ----
  
  void gcomm::pc::Proto::deliver_view(bool bootstrap)
  {
!     View v(pc_view_.id(), bootstrap);
  
!     v.add_members(current_view_.members().begin(),
!                   current_view_.members().end());
  
      for (NodeMap::const_iterator i = instances_.begin();
           i != instances_.end(); ++i)
      {
!         if (current_view_.members().find(NodeMap::key(i)) ==
!             current_view_.members().end())
          {
!             v.add_partitioned(NodeMap::key(i), "");
          }
      }
  
***************
*** 225,238 ****
  
  void gcomm::pc::Proto::mark_non_prim()
  {
!     pc_view_ = ViewId(V_NON_PRIM, current_view_.get_id());
      for (NodeMap::iterator i = instances_.begin(); i != instances_.end();
           ++i)
      {
!         const UUID& uuid(NodeMap::get_key(i));
!         Node& inst(NodeMap::get_value(i));
!         if (current_view_.get_members().find(uuid) !=
!             current_view_.get_members().end())
          {
              inst.set_prim(false);
              pc_view_.add_member(uuid, "");
--- 220,233 ----
  
  void gcomm::pc::Proto::mark_non_prim()
  {
!     pc_view_ = ViewId(V_NON_PRIM, current_view_.id());
      for (NodeMap::iterator i = instances_.begin(); i != instances_.end();
           ++i)
      {
!         const UUID& uuid(NodeMap::key(i));
!         Node& inst(NodeMap::value(i));
!         if (current_view_.members().find(uuid) !=
!             current_view_.members().end())
          {
              inst.set_prim(false);
              pc_view_.add_member(uuid, "");
***************
*** 264,273 ****
  
  
  
!     if (allowed[get_state()][s] == false)
      {
          gu_throw_fatal << "Forbidden state transtion: "
!                        << to_string(get_state()) << " -> " << to_string(s);
      }
  
      switch (s)
--- 259,268 ----
  
  
  
!     if (allowed[state()][s] == false)
      {
          gu_throw_fatal << "Forbidden state transtion: "
!                        << to_string(state()) << " -> " << to_string(s);
      }
  
      switch (s)
***************
*** 281,299 ****
          break;
      case S_PRIM:
      {
!         pc_view_ = ViewId(V_PRIM, current_view_.get_id());
          for (NodeMap::iterator i = instances_.begin(); i != instances_.end();
               ++i)
          {
!             const UUID& uuid(NodeMap::get_key(i));
!             Node& inst(NodeMap::get_value(i));
!             if (current_view_.get_members().find(uuid) !=
!                 current_view_.get_members().end())
              {
                  inst.set_prim(true);
!                 inst.set_last_prim(ViewId(V_PRIM, current_view_.get_id()));
                  inst.set_last_seq(0);
!                 inst.set_to_seq(get_to_seq());
                  pc_view_.add_member(uuid, "");
              }
              else
--- 276,294 ----
          break;
      case S_PRIM:
      {
!         pc_view_ = ViewId(V_PRIM, current_view_.id());
          for (NodeMap::iterator i = instances_.begin(); i != instances_.end();
               ++i)
          {
!             const UUID& uuid(NodeMap::key(i));
!             Node& inst(NodeMap::value(i));
!             if (current_view_.members().find(uuid) !=
!                 current_view_.members().end())
              {
                  inst.set_prim(true);
!                 inst.set_last_prim(ViewId(V_PRIM, current_view_.id()));
                  inst.set_last_seq(0);
!                 inst.set_to_seq(to_seq());
                  pc_view_.add_member(uuid, "");
              }
              else
***************
*** 314,324 ****
          ;
      }
  
!     log_debug << self_id() << " shift_to: " << to_string(get_state())
                << " -> " <<  to_string(s)
!               << " prim " << get_prim()
!               << " last prim " << get_last_prim()
!               << " to_seq " << get_to_seq();
  
      state_ = s;
  }
--- 309,319 ----
          ;
      }
  
!     log_debug << self_id() << " shift_to: " << to_string(state())
                << " -> " <<  to_string(s)
!               << " prim " << prim()
!               << " last prim " << last_prim()
!               << " to_seq " << to_seq();
  
      state_ = s;
  }
***************
*** 326,381 ****
  
  void gcomm::pc::Proto::handle_first_trans(const View& view)
  {
!     gcomm_assert(get_state() == S_NON_PRIM);
!     gcomm_assert(view.get_type() == V_TRANS);
  
      if (start_prim_ == true)
      {
!         if (view.get_members().size() > 1 || view.is_empty())
          {
              gu_throw_fatal << "Corrupted view";
          }
  
!         if (NodeList::get_key(view.get_members().begin()) != get_uuid())
          {
              gu_throw_fatal << "Bad first UUID: "
!                            << NodeList::get_key(view.get_members().begin())
!                            << ", expected: " << get_uuid();
          }
  
!         set_last_prim(ViewId(V_PRIM, view.get_id()));
          set_prim(true);
      }
      current_view_ = view;
      shift_to(S_TRANS);
  }
  
  
  bool gcomm::pc::Proto::have_quorum(const View& view) const
  {
!     return (view.get_members().size()*2 + view.get_left().size() >
!             pc_view_.get_members().size());
  }
  
  
  bool gcomm::pc::Proto::have_split_brain(const View& view) const
  {
!     return (view.get_members().size()*2 + view.get_left().size() ==
!             pc_view_.get_members().size());
  }
  
  
  void gcomm::pc::Proto::handle_trans(const View& view)
  {
!     gcomm_assert(view.get_id().get_type() == V_TRANS);
!     gcomm_assert(view.get_id().get_uuid() == current_view_.get_id().get_uuid() &&
!                  view.get_id().get_seq()  == current_view_.get_id().get_seq());
  
      log_debug << self_id() << " \n\n current view " << current_view_
                << "\n\n next view " << view
                << "\n\n pc view " << pc_view_;
  
!     if (!have_quorum(view))
      {
          if (closing_ == false && ignore_sb_ == true && have_split_brain(view))
          {
--- 321,449 ----
  
  void gcomm::pc::Proto::handle_first_trans(const View& view)
  {
!     gcomm_assert(state() == S_NON_PRIM);
!     gcomm_assert(view.type() == V_TRANS);
  
      if (start_prim_ == true)
      {
!         if (view.members().size() > 1 || view.is_empty())
          {
              gu_throw_fatal << "Corrupted view";
          }
  
!         if (NodeList::key(view.members().begin()) != uuid())
          {
              gu_throw_fatal << "Bad first UUID: "
!                            << NodeList::key(view.members().begin())
!                            << ", expected: " << uuid();
          }
  
!         set_last_prim(ViewId(V_PRIM, view.id()));
          set_prim(true);
      }
      current_view_ = view;
      shift_to(S_TRANS);
  }
  
+ // Compute weighted sum of members in node list. If member cannot be found
+ // from node_map its weight is assumed to be zero.
+ static size_t weighted_sum(const gcomm::NodeList& node_list,
+                            const gcomm::pc::NodeMap& node_map)
+ {
+     size_t sum(0);
+     for (gcomm::NodeList::const_iterator i(node_list.begin());
+          i != node_list.end(); ++i)
+     {
+         int weight(0);
+         gcomm::pc::NodeMap::const_iterator node_i(
+             node_map.find(gcomm::NodeList::key(i)));
+         if (node_i != node_map.end())
+         {
+             const gcomm::pc::Node& node(gcomm::pc::NodeMap::value(node_i));
+             gcomm_assert(node.weight() >= 0 &&
+                          node.weight() <= 0xff);
+             weight = node.weight();
+         }
+         else
+         {
+             weight = 0;
+         }
+         sum += weight;
+     }
+     return sum;
+ }
+ 
+ // Check if all members in node_list have weight associated. This is needed
+ // to fall back to backwards compatibility mode during upgrade (all weights are
+ // assumed to be one). See have_quorum() and have_split_brain() below.
+ static bool have_weights(const gcomm::NodeList& node_list,
+                          const gcomm::pc::NodeMap& node_map)
+ {
+     for (gcomm::NodeList::const_iterator i(node_list.begin());
+          i != node_list.end(); ++i)
+     {
+         gcomm::pc::NodeMap::const_iterator node_i(
+             node_map.find(gcomm::NodeList::key(i)));
+         if (node_i != node_map.end())
+         {
+             const gcomm::pc::Node& node(gcomm::pc::NodeMap::value(node_i));
+             if (node.weight() == -1)
+             {
+                 return false;
+             }
+         }
+     }
+     return true;
+ }
+ 
  
  bool gcomm::pc::Proto::have_quorum(const View& view) const
  {
!     if (have_weights(view.members(), instances_) &&
!         have_weights(view.left(), instances_)    &&
!         have_weights(pc_view_.members(), instances_))
!     {
!         return (weighted_sum(view.members(), instances_) * 2
!                 + weighted_sum(view.left(), instances_) >
!                 weighted_sum(pc_view_.members(), instances_));
!     }
!     else
!     {
!         return (view.members().size()*2 + view.left().size() >
!                 pc_view_.members().size());
!     }
  }
  
  
  bool gcomm::pc::Proto::have_split_brain(const View& view) const
  {
!     if (have_weights(view.members(), instances_)  &&
!         have_weights(view.left(), instances_)     &&
!         have_weights(pc_view_.members(), instances_))
!     {
!         return (weighted_sum(view.members(), instances_) * 2
!                 + weighted_sum(view.left(), instances_) ==
!                 weighted_sum(pc_view_.members(), instances_));
!     }
!     else
!     {
!         return (view.members().size()*2 + view.left().size() ==
!                 pc_view_.members().size());
!     }
  }
  
  
  void gcomm::pc::Proto::handle_trans(const View& view)
  {
!     gcomm_assert(view.id().type() == V_TRANS);
!     gcomm_assert(view.id().uuid() == current_view_.id().uuid() &&
!                  view.id().seq()  == current_view_.id().seq());
  
      log_debug << self_id() << " \n\n current view " << current_view_
                << "\n\n next view " << view
                << "\n\n pc view " << pc_view_;
  
!     if (have_quorum(view) == false)
      {
          if (closing_ == false && ignore_sb_ == true && have_split_brain(view))
          {
***************
*** 412,427 ****
  
  void gcomm::pc::Proto::handle_reg(const View& view)
  {
!     gcomm_assert(view.get_type() == V_REG);
!     gcomm_assert(get_state() == S_TRANS);
  
      if (view.is_empty() == false &&
!         view.get_id().get_seq() <= current_view_.get_id().get_seq())
      {
          gu_throw_fatal << "Non-increasing view ids: current view "
!                        << current_view_.get_id()
                         << " new view "
!                        << view.get_id();
      }
  
      current_view_ = view;
--- 480,495 ----
  
  void gcomm::pc::Proto::handle_reg(const View& view)
  {
!     gcomm_assert(view.type() == V_REG);
!     gcomm_assert(state() == S_TRANS);
  
      if (view.is_empty() == false &&
!         view.id().seq() <= current_view_.id().seq())
      {
          gu_throw_fatal << "Non-increasing view ids: current view "
!                        << current_view_.id()
                         << " new view "
!                        << view.id();
      }
  
      current_view_ = view;
***************
*** 445,458 ****
  {
  
      // We accept only EVS TRANS and REG views
!     if (view.get_type() != V_TRANS && view.get_type() != V_REG)
      {
          gu_throw_fatal << "Invalid view type";
      }
  
      // Make sure that self exists in view
      if (view.is_empty()            == false &&
!         view.is_member(get_uuid()) == false)
      {
          gu_throw_fatal << "Self not found from non empty view: "
                         << view;
--- 513,526 ----
  {
  
      // We accept only EVS TRANS and REG views
!     if (view.type() != V_TRANS && view.type() != V_REG)
      {
          gu_throw_fatal << "Invalid view type";
      }
  
      // Make sure that self exists in view
      if (view.is_empty()            == false &&
!         view.is_member(uuid()) == false)
      {
          gu_throw_fatal << "Self not found from non empty view: "
                         << view;
***************
*** 460,468 ****
  
      log_debug << self_id() << " " << view;
  
!     if (view.get_type() == V_TRANS)
      {
!         if (current_view_.get_type() == V_NONE)
          {
              handle_first_trans(view);
          }
--- 528,536 ----
  
      log_debug << self_id() << " " << view;
  
!     if (view.type() == V_TRANS)
      {
!         if (current_view_.type() == V_NONE)
          {
              handle_first_trans(view);
          }
***************
*** 492,542 ****
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const UUID& msg_source_uuid(SMMap::get_key(i));
!         const Node& msg_source_state(SMMap::get_value(i).get_node(msg_source_uuid));
  
!         const NodeMap& msg_state_map(SMMap::get_value(i).get_node_map());
          for (NodeMap::const_iterator si = msg_state_map.begin();
               si != msg_state_map.end(); ++si)
          {
!             const UUID& uuid(NodeMap::get_key(si));
!             const Node& msg_state(NodeMap::get_value(si));
!             const Node& local_state(NodeMap::get_value(instances_.find_checked(uuid)));
!             if (get_prim()                  == true &&
!                 msg_source_state.get_prim() == true &&
!                 msg_state.get_prim()        == true)
              {
                  if (current_view_.is_member(uuid) == true)
                  {
                      // Msg source claims to come from prim view and this node
                      // is in prim. All message prim view states must be equal
                      // to local ones.
!                     gcomm_assert(msg_state == local_state)
!                         << self_id()
!                         << " node " << uuid
!                         << " prim state message and local states not consistent:"
!                         << " msg node "   << msg_state
!                         << " local state " << local_state;
!                     gcomm_assert(msg_state.get_to_seq() == max_to_seq)
                          << self_id()
                          << " node " << uuid
                          << " to seq not consistent with local state:"
                          << " max to seq " << max_to_seq
!                         << " msg state to seq " << msg_state.get_to_seq();
                  }
              }
!             else if (get_prim() == true)
              {
                  log_debug << self_id()
                            << " node " << uuid
!                           << " from " << msg_state.get_last_prim()
!                           << " joining " << get_last_prim();
              }
!             else if (msg_state.get_prim() == true)
              {
                  // @todo: Cross check with other state messages coming from prim
                  log_debug << self_id()
!                           << " joining to " << msg_state.get_last_prim();
              }
          }
      }
--- 560,627 ----
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const UUID& msg_source_uuid(SMMap::key(i));
!         const Node& msg_source_state(SMMap::value(i).node(msg_source_uuid));
  
!         const NodeMap& msg_state_map(SMMap::value(i).node_map());
          for (NodeMap::const_iterator si = msg_state_map.begin();
               si != msg_state_map.end(); ++si)
          {
!             const UUID& uuid(NodeMap::key(si));
!             const Node& msg_state(NodeMap::value(si));
!             const Node& local_state(NodeMap::value(instances_.find_checked(uuid)));
!             if (prim()                  == true &&
!                 msg_source_state.prim() == true &&
!                 msg_state.prim()        == true)
              {
                  if (current_view_.is_member(uuid) == true)
                  {
                      // Msg source claims to come from prim view and this node
                      // is in prim. All message prim view states must be equal
                      // to local ones.
!                     if (msg_state.weight() == -1)
!                     {
!                         // backwards compatibility, ignore weight in state check
!                         gcomm_assert(
!                             msg_state.prim() == local_state.prim()     &&
!                             msg_state.last_seq() == local_state.last_seq()  &&
!                             msg_state.last_prim() == local_state.last_prim() &&
!                             msg_state.to_seq()    == local_state.to_seq())
!                             << self_id()
!                             << " node " << uuid
!                             << " prim state message and local states not consistent:"
!                             << " msg node "   << msg_state
!                             << " local state " << local_state;
!                     }
!                     else
!                     {
!                         gcomm_assert(msg_state == local_state)
!                             << self_id()
!                             << " node " << uuid
!                             << " prim state message and local states not consistent:"
!                             << " msg node "   << msg_state
!                             << " local state " << local_state;
!                     }
!                     gcomm_assert(msg_state.to_seq() == max_to_seq)
                          << self_id()
                          << " node " << uuid
                          << " to seq not consistent with local state:"
                          << " max to seq " << max_to_seq
!                         << " msg state to seq " << msg_state.to_seq();
                  }
              }
!             else if (prim() == true)
              {
                  log_debug << self_id()
                            << " node " << uuid
!                           << " from " << msg_state.last_prim()
!                           << " joining " << last_prim();
              }
!             else if (msg_state.prim() == true)
              {
                  // @todo: Cross check with other state messages coming from prim
                  log_debug << self_id()
!                           << " joining to " << msg_state.last_prim();
              }
          }
      }
***************
*** 556,571 ****
           ++i)
      {
          NodeMap::const_iterator ii(
!             SMMap::get_value(i).get_node_map().find_checked(SMMap::get_key(i)));
  
  
!         const Node& inst      = NodeMap::get_value(ii);
!         const int64_t to_seq    = inst.get_to_seq();
!         const ViewId  last_prim = inst.get_last_prim();
  
          if (to_seq                 != -1         &&
              to_seq                 != max_to_seq &&
!             last_prim.get_type()   != V_NON_PRIM)
          {
              log_debug << self_id() << " RTR is needed: " << to_seq
                        << " / " << last_prim;
--- 641,656 ----
           ++i)
      {
          NodeMap::const_iterator ii(
!             SMMap::value(i).node_map().find_checked(SMMap::key(i)));
  
  
!         const Node& inst      = NodeMap::value(ii);
!         const int64_t to_seq    = inst.to_seq();
!         const ViewId  last_prim = inst.last_prim();
  
          if (to_seq                 != -1         &&
              to_seq                 != max_to_seq &&
!             last_prim.type()   != V_NON_PRIM)
          {
              log_debug << self_id() << " RTR is needed: " << to_seq
                        << " / " << last_prim;
***************
*** 579,592 ****
  
  void gcomm::pc::Proto::cleanup_instances()
  {
!     gcomm_assert(get_state() == S_PRIM);
!     gcomm_assert(current_view_.get_type() == V_REG);
  
      NodeMap::iterator i, i_next;
      for (i = instances_.begin(); i != instances_.end(); i = i_next)
      {
          i_next = i, ++i_next;
!         const UUID& uuid(NodeMap::get_key(i));
          if (current_view_.is_member(uuid) == false)
          {
              log_debug << self_id()
--- 664,677 ----
  
  void gcomm::pc::Proto::cleanup_instances()
  {
!     gcomm_assert(state() == S_PRIM);
!     gcomm_assert(current_view_.type() == V_REG);
  
      NodeMap::iterator i, i_next;
      for (i = instances_.begin(); i != instances_.end(); i = i_next)
      {
          i_next = i, ++i_next;
!         const UUID& uuid(NodeMap::key(i));
          if (current_view_.is_member(uuid) == false)
          {
              log_debug << self_id()
***************
*** 607,619 ****
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const Node& state(SMMap::get_value(i).get_node(SMMap::get_key(i)));
  
!         if (state.get_prim() == true)
          {
              prim      = true;
!             last_prim = state.get_last_prim();
!             to_seq    = state.get_to_seq();
              break;
          }
      }
--- 692,704 ----
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const Node& state(SMMap::value(i).node(SMMap::key(i)));
  
!         if (state.prim() == true)
          {
              prim      = true;
!             last_prim = state.last_prim();
!             to_seq    = state.to_seq();
              break;
          }
      }
***************
*** 623,640 ****
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const Node& state(SMMap::get_value(i).get_node(SMMap::get_key(i)));
  
!         if (state.get_prim() == true)
          {
!             if (state.get_last_prim() != last_prim)
              {
                  gu_throw_fatal
                      << self_id()
                      << " last prims not consistent";
              }
  
!             if (state.get_to_seq() != to_seq)
              {
                  gu_throw_fatal
                      << self_id()
--- 708,725 ----
      for (SMMap::const_iterator i = state_msgs_.begin(); i != state_msgs_.end();
           ++i)
      {
!         const Node& state(SMMap::value(i).node(SMMap::key(i)));
  
!         if (state.prim() == true)
          {
!             if (state.last_prim() != last_prim)
              {
                  gu_throw_fatal
                      << self_id()
                      << " last prims not consistent";
              }
  
!             if (state.to_seq() != to_seq)
              {
                  gu_throw_fatal
                      << self_id()
***************
*** 643,650 ****
          }
          else
          {
!             log_debug << "Non-prim " << SMMap::get_key(i) <<" from "
!                       << state.get_last_prim() << " joining prim";
          }
      }
  
--- 728,735 ----
          }
          else
          {
!             log_debug << "Non-prim " << SMMap::key(i) <<" from "
!                       << state.last_prim() << " joining prim";
          }
      }
  
***************
*** 662,681 ****
               ++i)
          {
              for (NodeMap::const_iterator
!                      j = SMMap::get_value(i).get_node_map().begin();
!                  j != SMMap::get_value(i).get_node_map().end(); ++j)
              {
!                 const UUID& uuid(NodeMap::get_key(j));
!                 const Node& inst(NodeMap::get_value(j));
  
!                 if (inst.get_last_prim() != ViewId(V_NON_PRIM) &&
!                     find<MultiMap<ViewId, UUID>::iterator,
!                     pair<const ViewId, UUID> >(last_prim_uuids.begin(),
!                                                last_prim_uuids.end(),
!                                                make_pair(inst.get_last_prim(), uuid)) ==
                      last_prim_uuids.end())
                  {
!                     last_prim_uuids.insert(make_pair(inst.get_last_prim(), uuid));
                  }
              }
          }
--- 747,767 ----
               ++i)
          {
              for (NodeMap::const_iterator
!                      j = SMMap::value(i).node_map().begin();
!                  j != SMMap::value(i).node_map().end(); ++j)
              {
!                 const UUID& uuid(NodeMap::key(j));
!                 const Node& inst(NodeMap::value(j));
  
!                 if (inst.last_prim() != ViewId(V_NON_PRIM) &&
!                     std::find<MultiMap<ViewId, UUID>::iterator,
!                               std::pair<const ViewId, UUID> >(
!                                   last_prim_uuids.begin(),
!                                   last_prim_uuids.end(),
!                                   std::make_pair(inst.last_prim(), uuid)) ==
                      last_prim_uuids.end())
                  {
!                     last_prim_uuids.insert(std::make_pair(inst.last_prim(), uuid));
                  }
              }
          }
***************
*** 687,712 ****
          }
  
          const ViewId greatest_view_id(last_prim_uuids.rbegin()->first);
!         set<UUID> greatest_view;
!         pair<MultiMap<ViewId, UUID>::const_iterator,
!             MultiMap<ViewId, UUID>::const_iterator> gvi =
              last_prim_uuids.equal_range(greatest_view_id);
          for (MultiMap<ViewId, UUID>::const_iterator i = gvi.first;
               i != gvi.second; ++i)
          {
!             pair<set<UUID>::iterator, bool> iret = greatest_view.insert(
!                 MultiMap<ViewId, UUID>::get_value(i));
              gcomm_assert(iret.second == true);
          }
          log_debug << self_id()
                    << " greatest view id " << greatest_view_id;
!         set<UUID> present;
!         for (NodeList::const_iterator i = current_view_.get_members().begin();
!              i != current_view_.get_members().end(); ++i)
          {
!             present.insert(NodeList::get_key(i));
          }
!         set<UUID> intersection;
          set_intersection(greatest_view.begin(), greatest_view.end(),
                           present.begin(), present.end(),
                           inserter(intersection, intersection.begin()));
--- 773,799 ----
          }
  
          const ViewId greatest_view_id(last_prim_uuids.rbegin()->first);
!         std::set<UUID> greatest_view;
!         std::pair<MultiMap<ViewId, UUID>::const_iterator,
!                   MultiMap<ViewId, UUID>::const_iterator> gvi =
              last_prim_uuids.equal_range(greatest_view_id);
          for (MultiMap<ViewId, UUID>::const_iterator i = gvi.first;
               i != gvi.second; ++i)
          {
!             std::pair<std::set<UUID>::iterator, bool>
!                 iret = greatest_view.insert(
!                     MultiMap<ViewId, UUID>::value(i));
              gcomm_assert(iret.second == true);
          }
          log_debug << self_id()
                    << " greatest view id " << greatest_view_id;
!         std::set<UUID> present;
!         for (NodeList::const_iterator i = current_view_.members().begin();
!              i != current_view_.members().end(); ++i)
          {
!             present.insert(NodeList::key(i));
          }
!         std::set<UUID> intersection;
          set_intersection(greatest_view.begin(), greatest_view.end(),
                           present.begin(), present.end(),
                           inserter(intersection, intersection.begin()));
***************
*** 725,751 ****
  
  void gcomm::pc::Proto::handle_state(const Message& msg, const UUID& source)
  {
!     gcomm_assert(msg.get_type() == Message::T_STATE);
!     gcomm_assert(get_state() == S_STATES_EXCH);
!     gcomm_assert(state_msgs_.size() < current_view_.get_members().size());
  
      log_debug << self_id() << " handle state from " << source << " " << msg;
  
      // Early check for possibly conflicting primary components. The one
      // with greater view id may continue (as it probably has been around
      // for longer timer). However, this should be configurable policy.
!     if (get_prim() == true)
      {
!         const Node& si(NodeMap::get_value(msg.get_node_map().find(source)));
!         if (si.get_prim() == true && si.get_last_prim() != get_last_prim())
          {
              log_warn << self_id() << " conflicting prims: my prim: "
!                      << get_last_prim()
                       << " other prim: "
!                      << si.get_last_prim();
  
!             if ((npvo_ == true  && get_last_prim() < si.get_last_prim()) ||
!                 (npvo_ == false && get_last_prim() > si.get_last_prim()))
              {
                  log_warn << self_id() << " discarding other prim view: "
                           << (npvo_ == true ? "newer" : "older" )
--- 812,838 ----
  
  void gcomm::pc::Proto::handle_state(const Message& msg, const UUID& source)
  {
!     gcomm_assert(msg.type() == Message::T_STATE);
!     gcomm_assert(state() == S_STATES_EXCH);
!     gcomm_assert(state_msgs_.size() < current_view_.members().size());
  
      log_debug << self_id() << " handle state from " << source << " " << msg;
  
      // Early check for possibly conflicting primary components. The one
      // with greater view id may continue (as it probably has been around
      // for longer timer). However, this should be configurable policy.
!     if (prim() == true)
      {
!         const Node& si(NodeMap::value(msg.node_map().find(source)));
!         if (si.prim() == true && si.last_prim() != last_prim())
          {
              log_warn << self_id() << " conflicting prims: my prim: "
!                      << last_prim()
                       << " other prim: "
!                      << si.last_prim();
  
!             if ((npvo_ == true  && last_prim() < si.last_prim()) ||
!                 (npvo_ == false && last_prim() > si.last_prim()))
              {
                  log_warn << self_id() << " discarding other prim view: "
                           << (npvo_ == true ? "newer" : "older" )
***************
*** 762,784 ****
          }
      }
  
!     state_msgs_.insert_unique(make_pair(source, msg));
  
!     if (state_msgs_.size() == current_view_.get_members().size())
      {
          // Insert states from previously unseen nodes into local state map
          for (SMMap::const_iterator i = state_msgs_.begin();
               i != state_msgs_.end(); ++i)
          {
!             const NodeMap& sm_im(SMMap::get_value(i).get_node_map());
              for (NodeMap::const_iterator j = sm_im.begin(); j != sm_im.end();
                   ++j)
              {
!                 const UUID& sm_uuid(NodeMap::get_key(j));
!                 if (instances_.find(sm_uuid) == instances_.end())
                  {
!                     const Node& sm_state(NodeMap::get_value(j));
!                     instances_.insert_unique(make_pair(sm_uuid, sm_state));
                  }
              }
          }
--- 849,881 ----
          }
      }
  
!     state_msgs_.insert_unique(std::make_pair(source, msg));
  
!     if (state_msgs_.size() == current_view_.members().size())
      {
          // Insert states from previously unseen nodes into local state map
          for (SMMap::const_iterator i = state_msgs_.begin();
               i != state_msgs_.end(); ++i)
          {
!             const NodeMap& sm_im(SMMap::value(i).node_map());
              for (NodeMap::const_iterator j = sm_im.begin(); j != sm_im.end();
                   ++j)
              {
!                 const UUID& sm_uuid(NodeMap::key(j));
!                 const Node& sm_node(NodeMap::value(j));
!                 NodeMap::iterator local_node_i(instances_.find(sm_uuid));
!                 Node& local_node(NodeMap::value(local_node_i));
!                 if (local_node_i == instances_.end())
                  {
!                     const Node& sm_state(NodeMap::value(j));
!                     instances_.insert_unique(std::make_pair(sm_uuid, sm_state));
!                 }
!                 else if (local_node.weight() == -1 && sm_node.weight() != -1)
!                 {
!                     // backwards compatibility: override weight for instances
!                     // which have been reported by old nodes but have weights
!                     // associated anyway
!                     local_node.set_weight(sm_node.weight());
                  }
              }
          }
***************
*** 793,800 ****
              (void)requires_rtr();
              shift_to(S_INSTALL);
  
!             if (current_view_.get_members().find(get_uuid()) ==
!                 current_view_.get_members().begin())
              {
                  send_install(false);
              }
--- 890,897 ----
              (void)requires_rtr();
              shift_to(S_INSTALL);
  
!             if (current_view_.members().find(uuid()) ==
!                 current_view_.members().begin())
              {
                  send_install(false);
              }
***************
*** 811,818 ****
  
  void gcomm::pc::Proto::handle_install(const Message& msg, const UUID& source)
  {
!     gcomm_assert(msg.get_type() == Message::T_INSTALL);
!     gcomm_assert(get_state() == S_INSTALL || get_state() == S_NON_PRIM);
  
      if ((msg.flags() & Message::F_BOOTSTRAP) == 0)
      {
--- 908,915 ----
  
  void gcomm::pc::Proto::handle_install(const Message& msg, const UUID& source)
  {
!     gcomm_assert(msg.type() == Message::T_INSTALL);
!     gcomm_assert(state() == S_INSTALL || state() == S_NON_PRIM);
  
      if ((msg.flags() & Message::F_BOOTSTRAP) == 0)
      {
***************
*** 823,869 ****
      {
          log_debug << self_id()
                    << " handle bootstrap install from " << source << " " << msg;
!         if (get_state() == S_INSTALL)
          {
              log_info << "ignoring bootstrap install in "
!                      << to_string(get_state()) << " state";
              return;
          }
      }
      // Validate own state
  
!     NodeMap::const_iterator mi(msg.get_node_map().find_checked(get_uuid()));
  
!     const Node& m_state(NodeMap::get_value(mi));
  
!     if (m_state != NodeMap::get_value(self_i_))
      {
!         gu_throw_fatal << self_id()
!                        << "Install message self state does not match, "
!                        << "message state: " << m_state
!                        << ", local state: "
!                        << NodeMap::get_value(self_i_);
      }
  
      // Set TO seqno according to install message
      int64_t to_seq(-1);
      bool prim_found(false);
!     for (mi = msg.get_node_map().begin(); mi != msg.get_node_map().end(); ++mi)
      {
!         const Node& m_state = NodeMap::get_value(mi);
          // check that all TO seqs coming from prim are same
!         if (m_state.get_prim() == true && to_seq != -1)
          {
!             if (m_state.get_to_seq() != to_seq)
              {
                  gu_throw_fatal << "Install message TO seqnos inconsistent";
              }
          }
  
!         if (m_state.get_prim() == true)
          {
              prim_found = true;
!             to_seq = std::max(to_seq, m_state.get_to_seq());
          }
      }
  
--- 920,985 ----
      {
          log_debug << self_id()
                    << " handle bootstrap install from " << source << " " << msg;
!         if (state() == S_INSTALL)
          {
              log_info << "ignoring bootstrap install in "
!                      << to_string(state()) << " state";
              return;
          }
      }
      // Validate own state
  
!     NodeMap::const_iterator mi(msg.node_map().find_checked(uuid()));
  
!     const Node& m_state(NodeMap::value(mi));
  
!     if (m_state.weight() == -1)
      {
!         // backwards compatibility, ignore weight in state check
!         const Node& self_state(NodeMap::value(self_i_));
!         if ((m_state.prim()      == self_state.prim()     &&
!              m_state.last_seq()  == self_state.last_seq()  &&
!              m_state.last_prim() == self_state.last_prim() &&
!              m_state.to_seq()    == self_state.to_seq()) == false)
!         {
!             gu_throw_fatal << self_id()
!                            << "Install message self state does not match, "
!                            << "message state: " << m_state
!                            << ", local state: "
!                            << NodeMap::value(self_i_);
!         }
!     }
!     else
!     {
!         if (m_state != NodeMap::value(self_i_))
!         {
!             gu_throw_fatal << self_id()
!                            << "Install message self state does not match, "
!                            << "message state: " << m_state
!                            << ", local state: "
!                            << NodeMap::value(self_i_);
!         }
      }
  
      // Set TO seqno according to install message
      int64_t to_seq(-1);
      bool prim_found(false);
!     for (mi = msg.node_map().begin(); mi != msg.node_map().end(); ++mi)
      {
!         const Node& m_state = NodeMap::value(mi);
          // check that all TO seqs coming from prim are same
!         if (m_state.prim() == true && to_seq != -1)
          {
!             if (m_state.to_seq() != to_seq)
              {
                  gu_throw_fatal << "Install message TO seqnos inconsistent";
              }
          }
  
!         if (m_state.prim() == true)
          {
              prim_found = true;
!             to_seq = std::max(to_seq, m_state.to_seq());
          }
      }
  
***************
*** 871,881 ****
      {
          // #277
          // prim comp was restored from non-prims, find out max known TO seq
!         for (mi = msg.get_node_map().begin(); mi != msg.get_node_map().end();
               ++mi)
          {
!             const Node& m_state = NodeMap::get_value(mi);
!             to_seq = std::max(to_seq, m_state.get_to_seq());
          }
          log_debug << "assigning TO seq to "
                    << to_seq << " after restoring prim";
--- 987,997 ----
      {
          // #277
          // prim comp was restored from non-prims, find out max known TO seq
!         for (mi = msg.node_map().begin(); mi != msg.node_map().end();
               ++mi)
          {
!             const Node& m_state = NodeMap::value(mi);
!             to_seq = std::max(to_seq, m_state.to_seq());
          }
          log_debug << "assigning TO seq to "
                    << to_seq << " after restoring prim";
***************
*** 895,943 ****
  void gcomm::pc::Proto::handle_user(const Message& msg, const Datagram& dg,
                                     const ProtoUpMeta& um)
  {
!     int64_t to_seq(-1);
  
!     if (get_prim() == true)
      {
!         if (um.get_order() == O_SAFE)
          {
!             set_to_seq(get_to_seq() + 1);
!             to_seq = get_to_seq();
          }
      }
!     else if (current_view_.get_members().find(um.get_source()) ==
!              current_view_.get_members().end())
      {
!         gcomm_assert(current_view_.get_type() == V_TRANS);
          // log_debug << self_id()
          //        << " dropping message from out of view source in non-prim";
          return;
      }
  
  
!     if (um.get_order() == O_SAFE)
      {
!         Node& state(NodeMap::get_value(instances_.find_checked(um.get_source())));
!         if (state.get_last_seq() + 1 != msg.get_seq())
          {
              gu_throw_fatal << "gap in message sequence: source="
!                            << um.get_source()
                             << " expected_seq="
!                            << state.get_last_seq() + 1
                             << " seq="
!                            << msg.get_seq();
          }
!         state.set_last_seq(msg.get_seq());
      }
  
!     Datagram up_dg(dg, dg.get_offset() + msg.serial_size());
      gu_trace(send_up(up_dg,
!                      ProtoUpMeta(um.get_source(),
!                                  pc_view_.get_id(),
                                   0,
!                                  um.get_user_type(),
!                                  um.get_order(),
!                                  to_seq)));
  }
  
  
--- 1011,1059 ----
  void gcomm::pc::Proto::handle_user(const Message& msg, const Datagram& dg,
                                     const ProtoUpMeta& um)
  {
!     int64_t curr_to_seq(-1);
  
!     if (prim() == true)
      {
!         if (um.order() == O_SAFE)
          {
!             set_to_seq(to_seq() + 1);
!             curr_to_seq = to_seq();
          }
      }
!     else if (current_view_.members().find(um.source()) ==
!              current_view_.members().end())
      {
!         gcomm_assert(current_view_.type() == V_TRANS);
          // log_debug << self_id()
          //        << " dropping message from out of view source in non-prim";
          return;
      }
  
  
!     if (um.order() == O_SAFE)
      {
!         Node& state(NodeMap::value(instances_.find_checked(um.source())));
!         if (state.last_seq() + 1 != msg.seq())
          {
              gu_throw_fatal << "gap in message sequence: source="
!                            << um.source()
                             << " expected_seq="
!                            << state.last_seq() + 1
                             << " seq="
!                            << msg.seq();
          }
!         state.set_last_seq(msg.seq());
      }
  
!     Datagram up_dg(dg, dg.offset() + msg.serial_size());
      gu_trace(send_up(up_dg,
!                      ProtoUpMeta(um.source(),
!                                  pc_view_.id(),
                                   0,
!                                  um.user_type(),
!                                  um.order(),
!                                  curr_to_seq)));
  }
  
  
***************
*** 968,995 ****
          {  FAIL,   ACCEPT,  ACCEPT,   ACCEPT  }   // NON-PRIM
      };
  
!     Message::Type msg_type(msg.get_type());
!     Verdict       verdict (verdicts[get_state()][msg.get_type()]);
  
      if (verdict == FAIL)
      {
          gu_throw_fatal << "Invalid input, message " << msg.to_string()
!                        << " in state " << to_string(get_state());
      }
      else if (verdict == DROP)
      {
          log_warn << "Dropping input, message " << msg.to_string()
!                  << " in state " << to_string(get_state());
          return;
      }
  
      switch (msg_type)
      {
      case Message::T_STATE:
!         gu_trace(handle_state(msg, um.get_source()));
          break;
      case Message::T_INSTALL:
!         gu_trace(handle_install(msg, um.get_source()));
          break;
      case Message::T_USER:
          gu_trace(handle_user(msg, rb, um));
--- 1084,1111 ----
          {  FAIL,   ACCEPT,  ACCEPT,   ACCEPT  }   // NON-PRIM
      };
  
!     Message::Type msg_type(msg.type());
!     Verdict       verdict (verdicts[state()][msg.type()]);
  
      if (verdict == FAIL)
      {
          gu_throw_fatal << "Invalid input, message " << msg.to_string()
!                        << " in state " << to_string(state());
      }
      else if (verdict == DROP)
      {
          log_warn << "Dropping input, message " << msg.to_string()
!                  << " in state " << to_string(state());
          return;
      }
  
      switch (msg_type)
      {
      case Message::T_STATE:
!         gu_trace(handle_state(msg, um.source()));
          break;
      case Message::T_INSTALL:
!         gu_trace(handle_install(msg, um.source()));
          break;
      case Message::T_USER:
          gu_trace(handle_user(msg, rb, um));
***************
*** 1006,1035 ****
  {
      if (um.has_view() == true)
      {
!         handle_view(um.get_view());
      }
      else
      {
          Message msg;
!         const byte_t* b(get_begin(rb));
!         const size_t available(get_available(rb));
          try
          {
              (void)msg.unserialize(b, available, 0);
          }
!         catch (Exception& e)
          {
              switch (e.get_errno())
              {
              case EPROTONOSUPPORT:
!                 if (get_prim() == false)
                  {
                      gu_throw_fatal << e.what() << " terminating";
                  }
                  else
                  {
                      log_warn << "unknown/unsupported protocol version: "
!                              << msg.get_version()
                               << " dropping message";
                      return;
                  }
--- 1122,1151 ----
  {
      if (um.has_view() == true)
      {
!         handle_view(um.view());
      }
      else
      {
          Message msg;
!         const gu::byte_t* b(gcomm::begin(rb));
!         const size_t available(gcomm::available(rb));
          try
          {
              (void)msg.unserialize(b, available, 0);
          }
!         catch (gu::Exception& e)
          {
              switch (e.get_errno())
              {
              case EPROTONOSUPPORT:
!                 if (prim() == false)
                  {
                      gu_throw_fatal << e.what() << " terminating";
                  }
                  else
                  {
                      log_warn << "unknown/unsupported protocol version: "
!                              << msg.version()
                               << " dropping message";
                      return;
                  }
***************
*** 1044,1050 ****
  
          if (checksum_ == true && msg.flags() & Message::F_CRC16)
          {
!             test_checksum(msg, rb, rb.get_offset());
          }
  
          try
--- 1160,1166 ----
  
          if (checksum_ == true && msg.flags() & Message::F_CRC16)
          {
!             test_checksum(msg, rb, rb.offset());
          }
  
          try
***************
*** 1063,1078 ****
  
  int gcomm::pc::Proto::handle_down(Datagram& dg, const ProtoDownMeta& dm)
  {
!     if (gu_unlikely(get_state() != S_PRIM))
      {
          return EAGAIN;
      }
!     if (gu_unlikely(dg.get_len() > mtu()))
      {
          return EMSGSIZE;
      }
  
!     uint32_t    seq(dm.get_order() == O_SAFE ? last_sent_seq_ + 1 : last_sent_seq_);
      UserMessage um(version_, seq);
  
      push_header(um, dg);
--- 1179,1194 ----
  
  int gcomm::pc::Proto::handle_down(Datagram& dg, const ProtoDownMeta& dm)
  {
!     if (gu_unlikely(state() != S_PRIM))
      {
          return EAGAIN;
      }
!     if (gu_unlikely(dg.len() > mtu()))
      {
          return EMSGSIZE;
      }
  
!     uint32_t    seq(dm.order() == O_SAFE ? last_sent_seq_ + 1 : last_sent_seq_);
      UserMessage um(version_, seq);
  
      push_header(um, dg);
***************
*** 1115,1124 ****
      }
      else if (key == gcomm::Conf::PcBootstrap)
      {
!         if (get_state() != S_NON_PRIM)
          {
              log_info << "ignoring '" << key << "' in state "
!                      << to_string(get_state());
          }
          else
          {
--- 1231,1240 ----
      }
      else if (key == gcomm::Conf::PcBootstrap)
      {
!         if (state() != S_NON_PRIM)
          {
              log_info << "ignoring '" << key << "' in state "
!                      << to_string(state());
          }
          else
          {
***************
*** 1131,1137 ****
               key == Conf::PcLinger ||
               key == Conf::PcNpvo ||
               key == Conf::PcWaitPrim ||
!              key == Conf::PcWaitPrimTimeout)
      {
          gu_throw_error(EPERM) << "can't change value for '"
                                << key << "' during runtime";
--- 1247,1254 ----
               key == Conf::PcLinger ||
               key == Conf::PcNpvo ||
               key == Conf::PcWaitPrim ||
!              key == Conf::PcWaitPrimTimeout ||
!              key == Conf::PcWeight)
      {
          gu_throw_error(EPERM) << "can't change value for '"
                                << key << "' during runtime";
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/pc_proto.hpp 2.x/gcomm/src/pc_proto.hpp
*** galera-23.2.2-src/gcomm/src/pc_proto.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/pc_proto.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 84,138 ****
          current_view_  (V_NONE),
          pc_view_       (V_NON_PRIM),
          views_         (),
!         mtu_           (std::numeric_limits<int32_t>::max())
      {
          log_info << "PC version " << version_;
          conf.set(Conf::PcVersion,      gu::to_string(version_));
          conf.set(Conf::PcNpvo,         gu::to_string(npvo_));
          conf.set(Conf::PcIgnoreSb,     gu::to_string(ignore_sb_));
          conf.set(Conf::PcIgnoreQuorum, gu::to_string(ignore_quorum_));
          conf.set(Conf::PcChecksum,     gu::to_string(checksum_));
      }
  
      ~Proto() { }
  
!     const UUID& get_uuid() const { return my_uuid_; }
  
!     bool get_prim() const { return NodeMap::get_value(self_i_).get_prim(); }
  
!     void set_prim(const bool val) { NodeMap::get_value(self_i_).set_prim(val); }
  
      void mark_non_prim();
  
  
!     const ViewId& get_last_prim() const
!     { return NodeMap::get_value(self_i_).get_last_prim(); }
  
      void set_last_prim(const ViewId& vid)
      {
!         gcomm_assert(vid.get_type() == V_PRIM);
!         NodeMap::get_value(self_i_).set_last_prim(vid);
      }
  
!     uint32_t get_last_seq() const
!     { return NodeMap::get_value(self_i_).get_last_seq(); }
  
      void set_last_seq(const uint32_t seq)
!     { NodeMap::get_value(self_i_).set_last_seq(seq); }
  
!     int64_t get_to_seq() const
!     { return NodeMap::get_value(self_i_).get_to_seq(); }
  
      void set_to_seq(const int64_t seq)
!     { NodeMap::get_value(self_i_).set_to_seq(seq); }
  
      class SMMap : public Map<const UUID, Message> { };
  
!     const View& get_current_view() const { return current_view_; }
  
      const UUID& self_id() const { return my_uuid_; }
  
!     State       get_state()   const { return state_; }
  
      void shift_to    (State);
      void send_state  ();
--- 84,148 ----
          current_view_  (V_NONE),
          pc_view_       (V_NON_PRIM),
          views_         (),
!         mtu_           (std::numeric_limits<int32_t>::max()),
!         weight_        (check_range(Conf::PcWeight,
!                                     param<int>(conf, uri, Conf::PcWeight, "1"),
!                                     0, 0xff))
      {
          log_info << "PC version " << version_;
+         set_weight(weight_);
+ 
          conf.set(Conf::PcVersion,      gu::to_string(version_));
          conf.set(Conf::PcNpvo,         gu::to_string(npvo_));
          conf.set(Conf::PcIgnoreSb,     gu::to_string(ignore_sb_));
          conf.set(Conf::PcIgnoreQuorum, gu::to_string(ignore_quorum_));
          conf.set(Conf::PcChecksum,     gu::to_string(checksum_));
+         conf.set(Conf::PcWeight,       gu::to_string(weight_));
      }
  
      ~Proto() { }
  
!     const UUID& uuid() const { return my_uuid_; }
  
!     bool prim() const { return NodeMap::value(self_i_).prim(); }
  
!     void set_prim(const bool val) { NodeMap::value(self_i_).set_prim(val); }
  
      void mark_non_prim();
  
  
!     const ViewId& last_prim() const
!     { return NodeMap::value(self_i_).last_prim(); }
  
      void set_last_prim(const ViewId& vid)
      {
!         gcomm_assert(vid.type() == V_PRIM);
!         NodeMap::value(self_i_).set_last_prim(vid);
      }
  
!     uint32_t last_seq() const
!     { return NodeMap::value(self_i_).last_seq(); }
  
      void set_last_seq(const uint32_t seq)
!     { NodeMap::value(self_i_).set_last_seq(seq); }
  
!     int64_t to_seq() const
!     { return NodeMap::value(self_i_).to_seq(); }
  
      void set_to_seq(const int64_t seq)
!     { NodeMap::value(self_i_).set_to_seq(seq); }
! 
!     void set_weight(int weight)
!     { NodeMap::value(self_i_).set_weight(weight); }
! 
  
      class SMMap : public Map<const UUID, Message> { };
  
!     const View& current_view() const { return current_view_; }
  
      const UUID& self_id() const { return my_uuid_; }
  
!     State       state()   const { return state_; }
  
      void shift_to    (State);
      void send_state  ();
***************
*** 142,152 ****
      void handle_trans       (const View&);
      void handle_reg         (const View&);
  
!     void handle_msg  (const Message&, const gu::Datagram&,
                        const ProtoUpMeta&);
!     void handle_up   (const void*, const gu::Datagram&,
                        const ProtoUpMeta&);
!     int  handle_down (gu::Datagram&, const ProtoDownMeta&);
  
      void connect(bool first)
      {
--- 152,162 ----
      void handle_trans       (const View&);
      void handle_reg         (const View&);
  
!     void handle_msg  (const Message&, const Datagram&,
                        const ProtoUpMeta&);
!     void handle_up   (const void*, const Datagram&,
                        const ProtoUpMeta&);
!     int  handle_down (Datagram&, const ProtoDownMeta&);
  
      void connect(bool first)
      {
***************
*** 176,182 ****
      void cleanup_instances();
      void handle_state(const Message&, const UUID&);
      void handle_install(const Message&, const UUID&);
!     void handle_user(const Message&, const gu::Datagram&,
                       const ProtoUpMeta&);
      void deliver_view(bool bootstrap = false);
  
--- 186,192 ----
      void cleanup_instances();
      void handle_state(const Message&, const UUID&);
      void handle_install(const Message&, const UUID&);
!     void handle_user(const Message&, const Datagram&,
                       const ProtoUpMeta&);
      void deliver_view(bool bootstrap = false);
  
***************
*** 199,204 ****
--- 209,215 ----
      View              pc_view_;       // PC view
      std::list<View>   views_;         // List of seen views
      size_t            mtu_;           // Maximum transmission unit
+     int               weight_;        // Node weight in voting
  };
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/profile.hpp 2.x/gcomm/src/profile.hpp
*** galera-23.2.2-src/gcomm/src/profile.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/profile.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 5,15 ****
  /*!
   * @file profile.hpp
   *
!  * @brief Lightweight profiling utility. 
   *
   * Profiling utility suitable for getting runtime code profile information
   * with minimal overhead. Macros profile_enter() and profile_leave()
!  * can be inserted around the code and will be expanded to profiling 
   * code if GCOMM_PROFILE is defined.
   *
   * Example usage:
--- 5,15 ----
  /*!
   * @file profile.hpp
   *
!  * @brief Lightweight profiling utility.
   *
   * Profiling utility suitable for getting runtime code profile information
   * with minimal overhead. Macros profile_enter() and profile_leave()
!  * can be inserted around the code and will be expanded to profiling
   * code if GCOMM_PROFILE is defined.
   *
   * Example usage:
***************
*** 54,60 ****
  
  namespace prof
  {
!     
      // Forward declarations
      class Key;
      class Point;
--- 54,60 ----
  
  namespace prof
  {
! 
      // Forward declarations
      class Key;
      class Point;
***************
*** 71,96 ****
  class prof::Key
  {
  public:
!     Key(const char* const file_, 
!         const char* const func_, 
!         const int line_) :
!         file(file_),
!         func(func_),
!         line(line_)
      { }
  
      bool operator==(const Key& cmp) const
      {
!         return (line == cmp.line && 
!                 func == cmp.func &&
!                 file == cmp.file);
      }
!     
      bool operator<(const Key& cmp) const
      {
!         return (line < cmp.line ||
!                 (line == cmp.line && (func < cmp.func ||
!                                       (func == cmp.func && file < cmp.file))));
      }
      std::string to_string() const
      {
--- 71,97 ----
  class prof::Key
  {
  public:
!     Key(const char* const file,
!         const char* const func,
!         const int line)
!         :
!         file_(file),
!         func_(func),
!         line_(line)
      { }
  
      bool operator==(const Key& cmp) const
      {
!         return (line_ == cmp.line_ &&
!                 func_ == cmp.func_ &&
!                 file_ == cmp.file_);
      }
! 
      bool operator<(const Key& cmp) const
      {
!         return (line_ < cmp.line_ ||
!                 (line_ == cmp.line_ && (func_ < cmp.func_ ||
!                                         (func_ == cmp.func_ && file_ < cmp.file_))));
      }
      std::string to_string() const
      {
***************
*** 102,132 ****
      friend class Point;
      friend class Profile;
      friend std::ostream& operator<<(std::ostream& os, const Key&);
!     const char* const file;
!     const char* const func;
!     const int         line;
  };
  
  inline std::ostream& prof::operator<<(std::ostream& os, const prof::Key& key)
  {
!     return os << key.file << ":" << key.func << ":" << key.line;
! } 
  
  
  class prof::Point
  {
  public:
!     Point(const Profile& prof_, 
!           const char* file_, 
!           const char* func_, 
!           const int line_);
      ~Point();
  private:
      friend class Profile;
!     const Profile& prof;
!     const Key key;
!     mutable long long int enter_time_calendar;
!     mutable long long int enter_time_thread_cputime;
  };
  
  /*!
--- 103,133 ----
      friend class Point;
      friend class Profile;
      friend std::ostream& operator<<(std::ostream& os, const Key&);
!     const char* const file_;
!     const char* const func_;
!     const int         line_;
  };
  
  inline std::ostream& prof::operator<<(std::ostream& os, const prof::Key& key)
  {
!     return os << key.file_ << ":" << key.func_ << ":" << key.line_;
! }
  
  
  class prof::Point
  {
  public:
!     Point(const Profile& prof,
!           const char* file,
!           const char* func,
!           const int line);
      ~Point();
  private:
      friend class Profile;
!     const Profile& prof_;
!     const Key key_;
!     mutable long long int enter_time_calendar_;
!     mutable long long int enter_time_thread_cputime_;
  };
  
  /*!
***************
*** 136,159 ****
  {
      struct PointStats
      {
!         PointStats(long long int count_               = 0,
!                    long long int time_calendar_       = 0,
!                    long long int time_thread_cputime_ = 0) : 
!             count               (count_              ), 
!             time_calendar       (time_calendar_      ), 
!             time_thread_cputime (time_thread_cputime_) 
          { }
  
          PointStats operator+(const PointStats& add) const
          {
!             return PointStats(count               + add.count,
!                               time_calendar       + add.time_calendar,
!                               time_thread_cputime + add.time_thread_cputime);
          }
!         
!         long long int count;
!         long long int time_calendar;
!         long long int time_thread_cputime;
      };
  public:
      /*!
--- 137,160 ----
  {
      struct PointStats
      {
!         PointStats(long long int count                = 0,
!                    long long int time_calendar        = 0,
!                    long long int time_thread_cputime  = 0) :
!             count_              (count              ),
!             time_calendar_      (time_calendar      ),
!             time_thread_cputime_(time_thread_cputime)
          { }
  
          PointStats operator+(const PointStats& add) const
          {
!             return PointStats(count_               + add.count_,
!                               time_calendar_       + add.time_calendar_,
!                               time_thread_cputime_ + add.time_thread_cputime_);
          }
! 
!         long long int count_;
!         long long int time_calendar_;
!         long long int time_thread_cputime_;
      };
  public:
      /*!
***************
*** 161,214 ****
       *
       * @param name_ Name identifying the profile in ostream output.
       */
!     Profile(const std::string& name_ = "profile") : 
!         name(name_),
!         start_time_calendar(gu_time_calendar()),
!         start_time_thread_cputime(gu_time_thread_cputime()),
!         points()
      { }
!     
      void enter(const Point& point) const
!     { 
!         points[point.key].count++; 
!         point.enter_time_calendar = gu_time_calendar();
!         point.enter_time_thread_cputime = gu_time_thread_cputime();
      }
!     
      void leave(const Point& point) const
!     { 
          long long int t_cal(gu_time_calendar());
          long long int t_thdcpu(gu_time_thread_cputime());
!         points[point.key].time_calendar += (t_cal - point.enter_time_calendar);
!         points[point.key].time_thread_cputime += (t_thdcpu - point.enter_time_thread_cputime);
      }
!     
!     void clear() { points.clear(); }
!     
      friend std::ostream& operator<<(std::ostream&, const Profile&);
!     
      typedef std::map<Key, PointStats> Map;
!     std::string const name;
!     long long int const start_time_calendar;
!     long long int const start_time_thread_cputime;
!     mutable Map points;
  };
  
! inline prof::Point::Point(const Profile& prof_, 
!                           const char* file_, 
!                           const char* func_, 
!                           const int line_) :
!     prof(prof_),
!     key(file_, func_, line_),
!     enter_time_calendar(),
!     enter_time_thread_cputime()
! { 
!     prof.enter(*this); 
  }
  
! inline prof::Point::~Point() 
! { 
!     prof.leave(*this); 
  }
  
  
--- 162,217 ----
       *
       * @param name_ Name identifying the profile in ostream output.
       */
!     Profile(const std::string& name = "profile") :
!         name_(name),
!         start_time_calendar_(gu_time_calendar()),
!         start_time_thread_cputime_(gu_time_thread_cputime()),
!         points_()
      { }
! 
      void enter(const Point& point) const
!     {
!         points_[point.key_].count_++;
!         point.enter_time_calendar_ = gu_time_calendar();
!         point.enter_time_thread_cputime_ = gu_time_thread_cputime();
      }
! 
      void leave(const Point& point) const
!     {
          long long int t_cal(gu_time_calendar());
          long long int t_thdcpu(gu_time_thread_cputime());
!         points_[point.key_].time_calendar_ +=
!             (t_cal - point.enter_time_calendar_);
!         points_[point.key_].time_thread_cputime_ +=
!             (t_thdcpu - point.enter_time_thread_cputime_);
      }
! 
!     void clear() { points_.clear(); }
! 
      friend std::ostream& operator<<(std::ostream&, const Profile&);
! 
      typedef std::map<Key, PointStats> Map;
!     std::string const name_;
!     long long int const start_time_calendar_;
!     long long int const start_time_thread_cputime_;
!     mutable Map points_;
  };
  
! inline prof::Point::Point(const Profile& prof,
!                           const char*    file,
!                           const char*    func,
!                           const int      line) :
!     prof_(prof),
!     key_(file, func, line),
!     enter_time_calendar_(),
!     enter_time_thread_cputime_()
! {
!     prof_.enter(*this);
  }
  
! inline prof::Point::~Point()
! {
!     prof_.leave(*this);
  }
  
  
***************
*** 222,229 ****
  
      char prev_fill(os.fill());
      os.fill(' ');
!     os << "\nprofile name: " << prof.name;
!     
  
      os << std::left << std::fixed << std::setprecision(3);
      os << "\n\n";
--- 224,231 ----
  
      char prev_fill(os.fill());
      os.fill(' ');
!     os << "\nprofile name: " << prof.name_;
! 
  
      os << std::left << std::fixed << std::setprecision(3);
      os << "\n\n";
***************
*** 231,265 ****
      os << std::setw(10) << "count";
      os << std::setw(10) << "calendar";
      os << std::setw(10) << "cpu";
!     os << "\n" 
!        << std::setfill('-') << std::setw(70) << "" 
         << std::setfill(' ') << "\n";
!     for (Profile::Map::const_iterator i = prof.points.begin(); 
!          i != prof.points.end(); ++i)
      {
          os << std::setw(40) << std::left << i->first.to_string();
          os << std::right;
!         os << std::setw(10) << i->second.count;
!         os << std::setw(10) << double(i->second.time_calendar)*1.e-9;
!         os << std::setw(10) << double(i->second.time_thread_cputime)*1.e-9;
          os << std::left;
          os << "\n";
          cumul = cumul + i->second;
      }
!     
!     os << "\ntot count         : " << cumul.count;
!     os << "\ntot calendar time : " << double(cumul.time_calendar)*1.e-9;
!     os << "\ntot thread cputime: " << double(cumul.time_thread_cputime)*1.e-9;
!     os << "\ntot ct since ctor : " 
!        << double(gu::datetime::Date::now().get_utc() - prof.start_time_calendar)*1.e-9;
!     
      os.fill(prev_fill);
      return os;
  }
  
  
  /*
!  * Convenience macros for defining profile entry and leave points. 
   * If GCOMM_PROFILE is undefined, these macros expand to no-op.
   */
  #ifdef GCOMM_PROFILE
--- 233,268 ----
      os << std::setw(10) << "count";
      os << std::setw(10) << "calendar";
      os << std::setw(10) << "cpu";
!     os << "\n"
!        << std::setfill('-') << std::setw(70) << ""
         << std::setfill(' ') << "\n";
!     for (Profile::Map::const_iterator i = prof.points_.begin();
!          i != prof.points_.end(); ++i)
      {
          os << std::setw(40) << std::left << i->first.to_string();
          os << std::right;
!         os << std::setw(10) << i->second.count_;
!         os << std::setw(10) << double(i->second.time_calendar_)*1.e-9;
!         os << std::setw(10) << double(i->second.time_thread_cputime_)*1.e-9;
          os << std::left;
          os << "\n";
          cumul = cumul + i->second;
      }
! 
!     os << "\ntot count         : " << cumul.count_;
!     os << "\ntot calendar time : " << double(cumul.time_calendar_)*1.e-9;
!     os << "\ntot thread cputime: " << double(cumul.time_thread_cputime_)*1.e-9;
!     os << "\ntot ct since ctor : "
!        << double(gu::datetime::Date::now().get_utc()
!                  - prof.start_time_calendar_)*1.e-9;
! 
      os.fill(prev_fill);
      return os;
  }
  
  
  /*
!  * Convenience macros for defining profile entry and leave points.
   * If GCOMM_PROFILE is undefined, these macros expand to no-op.
   */
  #ifdef GCOMM_PROFILE
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/protonet.cpp 2.x/gcomm/src/protonet.cpp
*** galera-23.2.2-src/gcomm/src/protonet.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/protonet.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 11,21 ****
  #include "gcomm/util.hpp"
  #include "gcomm/conf.hpp"
  
- using namespace std;
- using namespace gu;
- using namespace gu::datetime;
- using namespace gcomm;
- 
  void gcomm::Protonet::insert(Protostack* pstack)
  {
      log_debug << "insert pstack " << pstack;
--- 11,16 ----
***************
*** 37,52 ****
      protos_.erase(i);
  }
  
! Date gcomm::Protonet::handle_timers()
  {
      Critical<Protonet> crit(*this);
!     Date next_time(Date::max());
      {
!         for (deque<Protostack*>::iterator i = protos_.begin();
               i != protos_.end();
               ++i)
          {
!             next_time = min(next_time, (*i)->handle_timers());
          }
      }
      return next_time;
--- 32,47 ----
      protos_.erase(i);
  }
  
! gu::datetime::Date gcomm::Protonet::handle_timers()
  {
      Critical<Protonet> crit(*this);
!     gu::datetime::Date next_time(gu::datetime::Date::max());
      {
!         for (std::deque<Protostack*>::iterator i = protos_.begin();
               i != protos_.end();
               ++i)
          {
!             next_time = std::min(next_time, (*i)->handle_timers());
          }
      }
      return next_time;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/protostack.cpp 2.x/gcomm/src/protostack.cpp
*** galera-23.2.2-src/gcomm/src/protostack.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/protostack.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 6,18 ****
  #include "socket.hpp"
  #include "gcomm/util.hpp"
  
- using namespace std;
- using namespace std::rel_ops;
- using namespace gu;
- using namespace gu::datetime;
- using namespace gcomm;
- 
- 
  void gcomm::Protostack::push_proto(Protolay* p)
  {
      Critical<Protostack> crit(*this);
--- 6,11 ----
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/socket.hpp 2.x/gcomm/src/socket.hpp
*** galera-23.2.2-src/gcomm/src/socket.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/socket.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 12,19 ****
  #ifndef GCOMM_SOCKET_HPP
  #define GCOMM_SOCKET_HPP
  
  #include "gu_uri.hpp"
! #include "gu_datagram.hpp"
  
  namespace gcomm
  {
--- 12,21 ----
  #ifndef GCOMM_SOCKET_HPP
  #define GCOMM_SOCKET_HPP
  
+ #include "gcomm/datagram.hpp"
+ 
  #include "gu_uri.hpp"
! 
  
  namespace gcomm
  {
***************
*** 54,67 ****
      virtual void connect(const gu::URI& uri) = 0;
      virtual void close() = 0;
  
!     virtual int send(const gu::Datagram& dg) = 0;
      virtual void async_receive() = 0;
  
!     virtual size_t get_mtu() const = 0;
!     virtual std::string get_local_addr() const = 0;
!     virtual std::string get_remote_addr() const = 0;
!     virtual State get_state() const = 0;
!     virtual SocketId get_id() const = 0;
  protected:
      const gu::URI uri_;
  };
--- 56,69 ----
      virtual void connect(const gu::URI& uri) = 0;
      virtual void close() = 0;
  
!     virtual int send(const Datagram& dg) = 0;
      virtual void async_receive() = 0;
  
!     virtual size_t mtu() const = 0;
!     virtual std::string local_addr() const = 0;
!     virtual std::string remote_addr() const = 0;
!     virtual State state() const = 0;
!     virtual SocketId id() const = 0;
  protected:
      const gu::URI uri_;
  };
***************
*** 87,95 ****
      virtual void listen(const gu::URI& uri) = 0;
      virtual std::string listen_addr() const = 0;
      virtual void close() = 0;
!     virtual State get_state() const = 0;
      virtual SocketPtr accept() = 0;
!     virtual SocketId get_id() const = 0;
  protected:
      const gu::URI uri_;
  };
--- 89,97 ----
      virtual void listen(const gu::URI& uri) = 0;
      virtual std::string listen_addr() const = 0;
      virtual void close() = 0;
!     virtual State state() const = 0;
      virtual SocketPtr accept() = 0;
!     virtual SocketId id() const = 0;
  protected:
      const gu::URI uri_;
  };
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/transport.cpp 2.x/gcomm/src/transport.cpp
*** galera-23.2.2-src/gcomm/src/transport.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/transport.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 8,54 ****
  #include "pc.hpp"
  #include "gcomm/conf.hpp"
  
- 
- // Private methods
- 
- void gcomm::Transport::set_state(const State state)
- {
-     state_ = state;
- }
- 
  // Public methods
  
! bool gcomm::Transport::supports_uuid() const
! {
!     return false;
! }
! 
! const gcomm::UUID& gcomm::Transport::get_uuid() const
  {
      gu_throw_fatal << "UUID not supported by " + uri_.get_scheme();
      throw;
  }
  
! std::string gcomm::Transport::get_local_addr() const
  {
      gu_throw_fatal << "get local url not supported";
      throw;
  }
  
! std::string gcomm::Transport::get_remote_addr() const
  {
      gu_throw_fatal << "get remote url not supported";
      throw;
  }
  
  
! 
! gcomm::Transport::State gcomm::Transport::get_state() const
! {
!     return state_;
! }
! 
! int gcomm::Transport::get_errno() const
  {
      return error_no_;
  }
--- 8,35 ----
  #include "pc.hpp"
  #include "gcomm/conf.hpp"
  
  // Public methods
  
! const gcomm::UUID& gcomm::Transport::uuid() const
  {
      gu_throw_fatal << "UUID not supported by " + uri_.get_scheme();
      throw;
  }
  
! std::string gcomm::Transport::local_addr() const
  {
      gu_throw_fatal << "get local url not supported";
      throw;
  }
  
! std::string gcomm::Transport::remote_addr() const
  {
      gu_throw_fatal << "get remote url not supported";
      throw;
  }
  
  
! int gcomm::Transport::err_no() const
  {
      return error_no_;
  }
***************
*** 73,79 ****
      pstack_(),
      pnet_(pnet),
      uri_(uri),
-     state_(S_CLOSED),
      error_no_(0)
  { }
  
--- 54,59 ----
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/uuid.cpp 2.x/gcomm/src/uuid.cpp
*** galera-23.2.2-src/gcomm/src/uuid.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/uuid.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 5,11 ****
  #include "gcomm/uuid.hpp"
  
  
! const gcomm::UUID gcomm::UUID::uuid_nil = gcomm::UUID(GU_UUID_NIL);
  
  
  
--- 5,11 ----
  #include "gcomm/uuid.hpp"
  
  
! const gcomm::UUID gcomm::UUID::uuid_nil_ = gcomm::UUID(GU_UUID_NIL);
  
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/src/view.cpp 2.x/gcomm/src/view.cpp
*** galera-23.2.2-src/gcomm/src/view.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/src/view.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 10,196 ****
  
  #include <sstream>
  
! using namespace std;
! using namespace gcomm;
! 
! using namespace gu;
! 
! size_t gcomm::ViewId::unserialize(const byte_t* buf, 
!                                   const size_t buflen, 
                                    const size_t offset)
      throw (gu::Exception)
  {
      size_t off;
!     
!     gu_trace (off = uuid.unserialize(buf, buflen, offset));
      uint32_t w;
      gu_trace (off = gu::unserialize4(buf, buflen, off, w));
!     seq = w & 0x3fffffff;
!     type = static_cast<ViewType>(w >> 30);
      return off;
  }
  
! size_t gcomm::ViewId::serialize(byte_t* buf, 
!                                 const size_t buflen, 
                                  const size_t offset)
      const throw (gu::Exception)
  {
      size_t off;
!  
!     gcomm_assert(type != V_NONE);
!     gu_trace (off = uuid.serialize(buf, buflen, offset));
!     uint32_t w((seq & 0x3fffffff) | (type << 30));
      gu_trace (off = gu::serialize4(w, buf, buflen, off));
!     
      return off;
  }
  
  
! static string to_string(const ViewType type)
  {
      switch (type)
      {
!     case V_TRANS:    return "TRANS";
!     case V_REG:      return "REG";
!     case V_NON_PRIM: return "NON_PRIM";
!     case V_PRIM:     return "PRIM";
      default:
          return "UNKNOWN";
          // gcomm_throw_fatal << "Invalid type value"; throw;
      }
  }
  
! ostream& gcomm::operator<<(ostream& os, const gcomm::ViewId& vi)
  {
!     return (os << "view_id(" 
!             << ::to_string(vi.get_type()) << "," 
!             << vi.get_uuid() << "," 
!             << vi.get_seq()) << ")";
  }
  
  
! void gcomm::View::add_member(const UUID& pid, const string& name)
  {
!     gu_trace((void)members.insert_unique(make_pair(pid, Node())));
  }
!     
  void gcomm::View::add_members(NodeList::const_iterator begin,
                                NodeList::const_iterator end)
  {
      for (NodeList::const_iterator i = begin; i != end; ++i)
      {
!         gu_trace((void)members.insert_unique(
!                      make_pair(NodeList::get_key(i), 
!                                NodeList::get_value(i))));
      }
  }
  
! void gcomm::View::add_joined(const UUID& pid, const string& name)
  {
!     gu_trace((void)joined.insert_unique(make_pair(pid, Node())));
  
  }
  
! void gcomm::View::add_left(const UUID& pid, const string& name)
  {
!     gu_trace((void)left.insert_unique(make_pair(pid, Node())));
  }
  
! void gcomm::View::add_partitioned(const UUID& pid, const string& name)
  {
!     gu_trace((void)partitioned.insert_unique(make_pair(pid, Node())));
  }
  
! const NodeList& gcomm::View::get_members() const
  {
!     return members;
  }
  
! const NodeList& gcomm::View::get_joined() const
  {
!     return joined;
  }
  
! const NodeList& gcomm::View::get_left() const
  {
!     return left;
  }
  
! const NodeList& gcomm::View::get_partitioned() const
  {
!     return partitioned;
  }
!     
! ViewType gcomm::View::get_type() const
  {
!     return view_id.get_type();
  }
  
! const gcomm::ViewId& View::get_id() const
  {
!     return view_id;
  }
  
! const UUID& gcomm::View::get_representative() const
  {
!     if (members.empty())
      {
          return UUID::nil();
      }
      else
      {
!         return NodeList::get_key(members.begin());
      }
  }
  
  bool gcomm::View::is_empty() const
  {
!     return view_id.get_uuid() == UUID::nil() && members.size() == 0;
  }
  
  bool gcomm::operator==(const gcomm::View& a, const gcomm::View& b)
  {
!     return a.get_id()   == b.get_id() && 
!         a.get_members() == b.get_members() &&
!         a.get_joined()  == b.get_joined() &&
!         a.get_left()    == b.get_left() &&
!         a.get_partitioned() == b.get_partitioned();
  }
  
  
  
! size_t gcomm::View::unserialize(const byte_t* buf, const size_t buflen, 
                                  size_t offset)
      throw (gu::Exception)
  {
!     gu_trace (offset = view_id.unserialize    (buf, buflen, offset));
!     gu_trace (offset = members.unserialize    (buf, buflen, offset));
!     gu_trace (offset = joined.unserialize     (buf, buflen, offset));
!     gu_trace (offset = left.unserialize       (buf, buflen, offset));
!     gu_trace (offset = partitioned.unserialize(buf, buflen, offset));
  
      return offset;
  }
  
! size_t gcomm::View::serialize(byte_t* buf, const size_t buflen, 
                                size_t offset) const
      throw (gu::Exception)
  {
!     gu_trace (offset = view_id.serialize    (buf, buflen, offset));
!     gu_trace (offset = members.serialize    (buf, buflen, offset));
!     gu_trace (offset = joined.serialize     (buf, buflen, offset));
!     gu_trace (offset = left.serialize       (buf, buflen, offset));
!     gu_trace (offset = partitioned.serialize(buf, buflen, offset));
      return offset;
  }
  
  size_t gcomm::View::serial_size() const
  {
!     return view_id.serial_size() 
!         + members.serial_size() 
!         + joined.serial_size() 
!         + left.serial_size() 
!         + partitioned.serial_size();
  }
  
  
--- 10,191 ----
  
  #include <sstream>
  
! size_t gcomm::ViewId::unserialize(const gu::byte_t* buf,
!                                   const size_t buflen,
                                    const size_t offset)
      throw (gu::Exception)
  {
      size_t off;
! 
!     gu_trace (off = uuid_.unserialize(buf, buflen, offset));
      uint32_t w;
      gu_trace (off = gu::unserialize4(buf, buflen, off, w));
!     seq_ = w & 0x3fffffff;
!     type_ = static_cast<ViewType>(w >> 30);
      return off;
  }
  
! size_t gcomm::ViewId::serialize(gu::byte_t* buf,
!                                 const size_t buflen,
                                  const size_t offset)
      const throw (gu::Exception)
  {
      size_t off;
! 
!     gcomm_assert(type_ != V_NONE);
!     gu_trace (off = uuid_.serialize(buf, buflen, offset));
!     uint32_t w((seq_ & 0x3fffffff) | (type_ << 30));
      gu_trace (off = gu::serialize4(w, buf, buflen, off));
! 
      return off;
  }
  
  
! static std::string to_string(const gcomm::ViewType type)
  {
      switch (type)
      {
!     case gcomm::V_TRANS:    return "TRANS";
!     case gcomm::V_REG:      return "REG";
!     case gcomm::V_NON_PRIM: return "NON_PRIM";
!     case gcomm::V_PRIM:     return "PRIM";
      default:
          return "UNKNOWN";
          // gcomm_throw_fatal << "Invalid type value"; throw;
      }
  }
  
! std::ostream& gcomm::operator<<(std::ostream& os, const gcomm::ViewId& vi)
  {
!     return (os << "view_id("
!             << ::to_string(vi.type()) << ","
!             << vi.uuid() << ","
!             << vi.seq()) << ")";
  }
  
  
! void gcomm::View::add_member(const UUID& pid, const std::string& name)
  {
!     gu_trace((void)members_.insert_unique(std::make_pair(pid, Node())));
  }
! 
  void gcomm::View::add_members(NodeList::const_iterator begin,
                                NodeList::const_iterator end)
  {
      for (NodeList::const_iterator i = begin; i != end; ++i)
      {
!         gu_trace((void)members_.insert_unique(
!                      std::make_pair(NodeList::key(i),
!                                     NodeList::value(i))));
      }
  }
  
! void gcomm::View::add_joined(const UUID& pid, const std::string& name)
  {
!     gu_trace((void)joined_.insert_unique(std::make_pair(pid, Node())));
  
  }
  
! void gcomm::View::add_left(const UUID& pid, const std::string& name)
  {
!     gu_trace((void)left_.insert_unique(std::make_pair(pid, Node())));
  }
  
! void gcomm::View::add_partitioned(const UUID& pid, const std::string& name)
  {
!     gu_trace((void)partitioned_.insert_unique(std::make_pair(pid, Node())));
  }
  
! const gcomm::NodeList& gcomm::View::members() const
  {
!     return members_;
  }
  
! const gcomm::NodeList& gcomm::View::joined() const
  {
!     return joined_;
  }
  
! const gcomm::NodeList& gcomm::View::left() const
  {
!     return left_;
  }
  
! const gcomm::NodeList& gcomm::View::partitioned() const
  {
!     return partitioned_;
  }
! 
! gcomm::ViewType gcomm::View::type() const
  {
!     return view_id_.type();
  }
  
! const gcomm::ViewId& gcomm::View::id() const
  {
!     return view_id_;
  }
  
! const gcomm::UUID& gcomm::View::representative() const
  {
!     if (members_.empty())
      {
          return UUID::nil();
      }
      else
      {
!         return NodeList::key(members_.begin());
      }
  }
  
  bool gcomm::View::is_empty() const
  {
!     return (view_id_.uuid() == UUID::nil() && members_.size() == 0);
  }
  
  bool gcomm::operator==(const gcomm::View& a, const gcomm::View& b)
  {
!     return (a.id()          == b.id()      &&
!             a.members()     == b.members() &&
!             a.joined()      == b.joined()  &&
!             a.left()        == b.left()    &&
!             a.partitioned() == b.partitioned());
  }
  
  
  
! size_t gcomm::View::unserialize(const gu::byte_t* buf, const size_t buflen,
                                  size_t offset)
      throw (gu::Exception)
  {
!     gu_trace (offset = view_id_.unserialize    (buf, buflen, offset));
!     gu_trace (offset = members_.unserialize    (buf, buflen, offset));
!     gu_trace (offset = joined_.unserialize     (buf, buflen, offset));
!     gu_trace (offset = left_.unserialize       (buf, buflen, offset));
!     gu_trace (offset = partitioned_.unserialize(buf, buflen, offset));
  
      return offset;
  }
  
! size_t gcomm::View::serialize(gu::byte_t* buf, const size_t buflen,
                                size_t offset) const
      throw (gu::Exception)
  {
!     gu_trace (offset = view_id_.serialize    (buf, buflen, offset));
!     gu_trace (offset = members_.serialize    (buf, buflen, offset));
!     gu_trace (offset = joined_.serialize     (buf, buflen, offset));
!     gu_trace (offset = left_.serialize       (buf, buflen, offset));
!     gu_trace (offset = partitioned_.serialize(buf, buflen, offset));
      return offset;
  }
  
  size_t gcomm::View::serial_size() const
  {
!     return (view_id_.serial_size()
!             + members_.serial_size()
!             + joined_.serial_size()
!             + left_.serial_size()
!             + partitioned_.serial_size());
  }
  
  
***************
*** 203,217 ****
      }
      else
      {
!         os << view.get_id();
          os << " memb {\n";
!         os << view.get_members();
          os << "} joined {\n";
!         os << view.get_joined();
          os << "} left {\n";
!         os << view.get_left();
          os << "} partitioned {\n";
!         os << view.get_partitioned();
          os << "}";
      }
      os << ")";
--- 198,212 ----
      }
      else
      {
!         os << view.id();
          os << " memb {\n";
!         os << view.members();
          os << "} joined {\n";
!         os << view.joined();
          os << "} left {\n";
!         os << view.left();
          os << "} partitioned {\n";
!         os << view.partitioned();
          os << "}";
      }
      os << ")";
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_evs2.cpp 2.x/gcomm/test/check_evs2.cpp
*** galera-23.2.2-src/gcomm/test/check_evs2.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_evs2.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 90,97 ****
      jm.set_source(uuid1);
      check_serialization(jm, jm.serial_size(), JoinMessage());
  
!     InstallMessage im(0, uuid1, view_id, ViewId(V_REG, view_id.get_uuid(),
!                                                 view_id.get_seq()), 8, 5, 27, node_list);
      im.set_source(uuid1);
      check_serialization(im, im.serial_size(), InstallMessage());
  
--- 90,97 ----
      jm.set_source(uuid1);
      check_serialization(jm, jm.serial_size(), JoinMessage());
  
!     InstallMessage im(0, uuid1, view_id, ViewId(V_REG, view_id.uuid(),
!                                                 view_id.seq()), 8, 5, 27, node_list);
      im.set_source(uuid1);
      check_serialization(im, im.serial_size(), InstallMessage());
  
***************
*** 134,146 ****
      {
          InputMap::iterator i = im.find(0, s);
          fail_if(i == im.end());
!         fail_unless(InputMapMsgIndex::get_value(i).get_msg().get_source() == uuid1);
!         fail_unless(InputMapMsgIndex::get_value(i).get_msg().get_seq() == s);
  
          i = im.find(1, s);
          fail_if(i == im.end());
!         fail_unless(InputMapMsgIndex::get_value(i).get_msg().get_source() == uuid2);
!         fail_unless(InputMapMsgIndex::get_value(i).get_msg().get_seq() == s);
      }
  
  }
--- 134,146 ----
      {
          InputMap::iterator i = im.find(0, s);
          fail_if(i == im.end());
!         fail_unless(InputMapMsgIndex::value(i).msg().source() == uuid1);
!         fail_unless(InputMapMsgIndex::value(i).msg().seq() == s);
  
          i = im.find(1, s);
          fail_if(i == im.end());
!         fail_unless(InputMapMsgIndex::value(i).msg().source() == uuid2);
!         fail_unless(InputMapMsgIndex::value(i).msg().seq() == s);
      }
  
  }
***************
*** 186,203 ****
      im.reset(1);
  
      im.insert(index1, UserMessage(0, uuid1, view, 0));
!     fail_unless(im.get_aru_seq() == 0);
      im.insert(index1, UserMessage(0, uuid1, view, 1));
!     fail_unless(im.get_aru_seq() == 1);
      im.insert(index1, UserMessage(0, uuid1, view, 2));
!     fail_unless(im.get_aru_seq() == 2);
      im.insert(index1, UserMessage(0, uuid1, view, 3));
!     fail_unless(im.get_aru_seq() == 3);
      im.insert(index1, UserMessage(0, uuid1, view, 5));
!     fail_unless(im.get_aru_seq() == 3);
  
      im.insert(index1, UserMessage(0, uuid1, view, 4));
!     fail_unless(im.get_aru_seq() == 5);
  
      InputMap::iterator i = im.find(index1, 0);
      fail_unless(im.is_fifo(i) == true);
--- 186,203 ----
      im.reset(1);
  
      im.insert(index1, UserMessage(0, uuid1, view, 0));
!     fail_unless(im.aru_seq() == 0);
      im.insert(index1, UserMessage(0, uuid1, view, 1));
!     fail_unless(im.aru_seq() == 1);
      im.insert(index1, UserMessage(0, uuid1, view, 2));
!     fail_unless(im.aru_seq() == 2);
      im.insert(index1, UserMessage(0, uuid1, view, 3));
!     fail_unless(im.aru_seq() == 3);
      im.insert(index1, UserMessage(0, uuid1, view, 5));
!     fail_unless(im.aru_seq() == 3);
  
      im.insert(index1, UserMessage(0, uuid1, view, 4));
!     fail_unless(im.aru_seq() == 5);
  
      InputMap::iterator i = im.find(index1, 0);
      fail_unless(im.is_fifo(i) == true);
***************
*** 211,217 ****
      fail_unless(im.is_safe(i) == true);
  
      im.insert(index1, UserMessage(0, uuid1, view, 7));
!     im.set_safe_seq(index1, im.get_aru_seq());
      i = im.find(index1, 7);
      fail_if(im.is_safe(i) == true);
  
--- 211,217 ----
      fail_unless(im.is_safe(i) == true);
  
      im.insert(index1, UserMessage(0, uuid1, view, 7));
!     im.set_safe_seq(index1, im.aru_seq());
      i = im.find(index1, 7);
      fail_if(im.is_safe(i) == true);
  
***************
*** 278,284 ****
              (void)im.insert(i, um);
              if ((seq + 5) % 10 == 0)
              {
!                 last_safe = um.get_seq() - 3;
                  im.set_safe_seq(i, last_safe);
                  for (InputMap::iterator ii = im.begin();
                       ii != im.end() && im.is_safe(ii) == true;
--- 278,284 ----
              (void)im.insert(i, um);
              if ((seq + 5) % 10 == 0)
              {
!                 last_safe = um.seq() - 3;
                  im.set_safe_seq(i, last_safe);
                  for (InputMap::iterator ii = im.begin();
                       ii != im.end() && im.is_safe(ii) == true;
***************
*** 289,296 ****
              }
              cnt++;
          }
!         gcomm_assert(im.get_aru_seq() == seq);
!         gcomm_assert(im.get_safe_seq() == last_safe);
      }
      Date stop(Date::now());
  
--- 289,296 ----
              }
              cnt++;
          }
!         gcomm_assert(im.aru_seq() == seq);
!         gcomm_assert(im.safe_seq() == last_safe);
      }
      Date stop(Date::now());
  
***************
*** 303,316 ****
  class InputMapInserter
  {
  public:
!     InputMapInserter(InputMap& im_) : im(im_) { }
  
      void operator()(const pair<size_t, UserMessage>& p) const
      {
!         im.insert(p.first, p.second);
      }
  private:
!     InputMap& im;
  };
  
  START_TEST(test_input_map_random_insert)
--- 303,316 ----
  class InputMapInserter
  {
  public:
!     InputMapInserter(InputMap& im) : im_(im) { }
  
      void operator()(const pair<size_t, UserMessage>& p) const
      {
!         im_.insert(p.first, p.second);
      }
  private:
!     InputMap& im_;
  };
  
  START_TEST(test_input_map_random_insert)
***************
*** 348,371 ****
      size_t n = 0;
      for (InputMap::iterator i = im.begin(); i != im.end(); ++i)
      {
!         const InputMapMsg& msg(InputMapMsgIndex::get_value(i));
!         fail_unless(msg.get_msg() == msgs[n].second);
          fail_if(im.is_safe(i) == true);
          ++n;
      }
  
!     fail_unless(im.get_aru_seq() == n_seqnos - 1);
!     fail_unless(im.get_safe_seq() == -1);
  
      for (size_t i = 0; i < n_uuids; ++i)
      {
!         fail_unless(im.get_range(i) ==
                      Range(n_seqnos,
                            n_seqnos - 1));
  
          im.set_safe_seq(i, n_seqnos - 1);
      }
!     fail_unless(im.get_safe_seq() == n_seqnos - 1);
  
  }
  END_TEST
--- 348,371 ----
      size_t n = 0;
      for (InputMap::iterator i = im.begin(); i != im.end(); ++i)
      {
!         const InputMapMsg& msg(InputMapMsgIndex::value(i));
!         fail_unless(msg.msg() == msgs[n].second);
          fail_if(im.is_safe(i) == true);
          ++n;
      }
  
!     fail_unless(im.aru_seq() == n_seqnos - 1);
!     fail_unless(im.safe_seq() == -1);
  
      for (size_t i = 0; i < n_uuids; ++i)
      {
!         fail_unless(im.range(i) ==
                      Range(n_seqnos,
                            n_seqnos - 1));
  
          im.set_safe_seq(i, n_seqnos - 1);
      }
!     fail_unless(im.safe_seq() == n_seqnos - 1);
  
  }
  END_TEST
***************
*** 375,384 ****
  
  static Datagram* get_msg(DummyTransport* tp, Message* msg, bool release = true)
  {
!     Datagram* rb = tp->get_out();
      if (rb != 0)
      {
!         gu_trace(Proto::unserialize_message(tp->get_uuid(), *rb, msg));
          if (release == true)
          {
              delete rb;
--- 375,384 ----
  
  static Datagram* get_msg(DummyTransport* tp, Message* msg, bool release = true)
  {
!     Datagram* rb = tp->out();
      if (rb != 0)
      {
!         gu_trace(Proto::unserialize_message(tp->uuid(), *rb, msg));
          if (release == true)
          {
              delete rb;
***************
*** 399,440 ****
  
      Datagram* rb = get_msg(t, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.get_type() == Message::T_JOIN);
  
      // Install message is emitted at the end of JOIN handling
      // 'cause this is the only instance and is always consistent
      // with itself
      rb = get_msg(t, &im);
      fail_unless(rb != 0);
!     fail_unless(im.get_type() == Message::T_INSTALL);
  
      // Handling INSTALL message emits three gap messages,
      // one for receiving install message (commit gap), one for
      // shift to install and one for shift to operational
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.get_type() == Message::T_GAP);
!     fail_unless((gm.get_flags() & Message::F_COMMIT) != 0);
  
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.get_type() == Message::T_GAP);
!     fail_unless((gm.get_flags() & Message::F_COMMIT) == 0);
  
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.get_type() == Message::T_GAP);
!     fail_unless((gm.get_flags() & Message::F_COMMIT) == 0);
  
      // State must have evolved JOIN -> S_GATHER -> S_INSTALL -> S_OPERATIONAL
!     fail_unless(p->get_state() == Proto::S_OPERATIONAL);
  
      // Handle join message again, must stay in S_OPERATIONAL, must not
      // emit anything
      p->handle_msg(jm);
      rb = get_msg(t, &gm);
      fail_unless(rb == 0);
!     fail_unless(p->get_state() == Proto::S_OPERATIONAL);
  
  }
  
--- 399,440 ----
  
      Datagram* rb = get_msg(t, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.type() == Message::T_JOIN);
  
      // Install message is emitted at the end of JOIN handling
      // 'cause this is the only instance and is always consistent
      // with itself
      rb = get_msg(t, &im);
      fail_unless(rb != 0);
!     fail_unless(im.type() == Message::T_INSTALL);
  
      // Handling INSTALL message emits three gap messages,
      // one for receiving install message (commit gap), one for
      // shift to install and one for shift to operational
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.type() == Message::T_GAP);
!     fail_unless((gm.flags() & Message::F_COMMIT) != 0);
  
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.type() == Message::T_GAP);
!     fail_unless((gm.flags() & Message::F_COMMIT) == 0);
  
      rb = get_msg(t, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.type() == Message::T_GAP);
!     fail_unless((gm.flags() & Message::F_COMMIT) == 0);
  
      // State must have evolved JOIN -> S_GATHER -> S_INSTALL -> S_OPERATIONAL
!     fail_unless(p->state() == Proto::S_OPERATIONAL);
  
      // Handle join message again, must stay in S_OPERATIONAL, must not
      // emit anything
      p->handle_msg(jm);
      rb = get_msg(t, &gm);
      fail_unless(rb == 0);
!     fail_unless(p->state() == Proto::S_OPERATIONAL);
  
  }
  
***************
*** 478,538 ****
  
      // Initial states check
      p2->shift_to(Proto::S_JOINING);
!     fail_unless(p1->get_state() == Proto::S_OPERATIONAL);
!     fail_unless(p2->get_state() == Proto::S_JOINING);
  
      // Send join message, don't self handle immediately
      // Expected output: one join message
      p2->send_join(false);
!     fail_unless(p2->get_state() == Proto::S_JOINING);
      rb = get_msg(t2, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.get_type() == Message::T_JOIN);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
      // Handle node 2's join on node 1
      // Expected output: shift to S_GATHER and one join message
      p1->handle_msg(jm);
!     fail_unless(p1->get_state() == Proto::S_GATHER);
      rb = get_msg(t1, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.get_type() == Message::T_JOIN);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      // Handle node 1's join on node 2
      // Expected output: shift to S_GATHER and one join message
      p2->handle_msg(jm);
!     fail_unless(p2->get_state() == Proto::S_GATHER);
      rb = get_msg(t2, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.get_type() == Message::T_JOIN);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
      // Handle node 2's join on node 1
      // Expected output: Install and commit gap messages, state stays in S_GATHER
      p1->handle_msg(jm);
!     fail_unless(p1->get_state() == Proto::S_GATHER);
      rb = get_msg(t1, &im);
      fail_unless(rb != 0);
!     fail_unless(im.get_type() == Message::T_INSTALL);
      rb = get_msg(t1, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.get_type() == Message::T_GAP);
!     fail_unless((gm.get_flags() & Message::F_COMMIT) != 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      // Handle install message on node 2
      // Expected output: commit gap message and state stays in S_RECOVERY
      p2->handle_msg(im);
!     fail_unless(p2->get_state() == Proto::S_GATHER);
      rb = get_msg(t2, &gm2);
      fail_unless(rb != 0);
!     fail_unless(gm2.get_type() == Message::T_GAP);
!     fail_unless((gm2.get_flags() & Message::F_COMMIT) != 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
--- 478,538 ----
  
      // Initial states check
      p2->shift_to(Proto::S_JOINING);
!     fail_unless(p1->state() == Proto::S_OPERATIONAL);
!     fail_unless(p2->state() == Proto::S_JOINING);
  
      // Send join message, don't self handle immediately
      // Expected output: one join message
      p2->send_join(false);
!     fail_unless(p2->state() == Proto::S_JOINING);
      rb = get_msg(t2, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.type() == Message::T_JOIN);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
      // Handle node 2's join on node 1
      // Expected output: shift to S_GATHER and one join message
      p1->handle_msg(jm);
!     fail_unless(p1->state() == Proto::S_GATHER);
      rb = get_msg(t1, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.type() == Message::T_JOIN);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      // Handle node 1's join on node 2
      // Expected output: shift to S_GATHER and one join message
      p2->handle_msg(jm);
!     fail_unless(p2->state() == Proto::S_GATHER);
      rb = get_msg(t2, &jm);
      fail_unless(rb != 0);
!     fail_unless(jm.type() == Message::T_JOIN);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
      // Handle node 2's join on node 1
      // Expected output: Install and commit gap messages, state stays in S_GATHER
      p1->handle_msg(jm);
!     fail_unless(p1->state() == Proto::S_GATHER);
      rb = get_msg(t1, &im);
      fail_unless(rb != 0);
!     fail_unless(im.type() == Message::T_INSTALL);
      rb = get_msg(t1, &gm);
      fail_unless(rb != 0);
!     fail_unless(gm.type() == Message::T_GAP);
!     fail_unless((gm.flags() & Message::F_COMMIT) != 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      // Handle install message on node 2
      // Expected output: commit gap message and state stays in S_RECOVERY
      p2->handle_msg(im);
!     fail_unless(p2->state() == Proto::S_GATHER);
      rb = get_msg(t2, &gm2);
      fail_unless(rb != 0);
!     fail_unless(gm2.type() == Message::T_GAP);
!     fail_unless((gm2.flags() & Message::F_COMMIT) != 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
***************
*** 540,561 ****
      // Expected output: Both nodes shift to S_INSTALL,
      // both send gap messages
      p1->handle_msg(gm2);
!     fail_unless(p1->get_state() == Proto::S_INSTALL);
      Message gm12;
      rb = get_msg(t1, &gm12);
      fail_unless(rb != 0);
!     fail_unless(gm12.get_type() == Message::T_GAP);
!     fail_unless((gm12.get_flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      p2->handle_msg(gm);
!     fail_unless(p2->get_state() == Proto::S_INSTALL);
      Message gm22;
      rb = get_msg(t2, &gm22);
      fail_unless(rb != 0);
!     fail_unless(gm22.get_type() == Message::T_GAP);
!     fail_unless((gm22.get_flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
--- 540,561 ----
      // Expected output: Both nodes shift to S_INSTALL,
      // both send gap messages
      p1->handle_msg(gm2);
!     fail_unless(p1->state() == Proto::S_INSTALL);
      Message gm12;
      rb = get_msg(t1, &gm12);
      fail_unless(rb != 0);
!     fail_unless(gm12.type() == Message::T_GAP);
!     fail_unless((gm12.flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      p2->handle_msg(gm);
!     fail_unless(p2->state() == Proto::S_INSTALL);
      Message gm22;
      rb = get_msg(t2, &gm22);
      fail_unless(rb != 0);
!     fail_unless(gm22.type() == Message::T_GAP);
!     fail_unless((gm22.flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
***************
*** 563,582 ****
      // and gap message
  
      p1->handle_msg(gm22);
!     fail_unless(p1->get_state() == Proto::S_OPERATIONAL);
      rb = get_msg(t1, &msg);
      fail_unless(rb != 0);
!     fail_unless(msg.get_type() == Message::T_GAP);
!     fail_unless((msg.get_flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      p2->handle_msg(gm12);
!     fail_unless(p2->get_state() == Proto::S_OPERATIONAL);
      rb = get_msg(t2, &msg);
      fail_unless(rb != 0);
!     fail_unless(msg.get_type() == Message::T_GAP);
!     fail_unless((msg.get_flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
--- 563,582 ----
      // and gap message
  
      p1->handle_msg(gm22);
!     fail_unless(p1->state() == Proto::S_OPERATIONAL);
      rb = get_msg(t1, &msg);
      fail_unless(rb != 0);
!     fail_unless(msg.type() == Message::T_GAP);
!     fail_unless((msg.flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t1, &msg);
      fail_unless(rb == 0);
  
      p2->handle_msg(gm12);
!     fail_unless(p2->state() == Proto::S_OPERATIONAL);
      rb = get_msg(t2, &msg);
      fail_unless(rb != 0);
!     fail_unless(msg.type() == Message::T_GAP);
!     fail_unless((msg.flags() & Message::F_COMMIT) == 0);
      rb = get_msg(t2, &msg);
      fail_unless(rb == 0);
  
***************
*** 662,668 ****
  {
      for (size_t i = i_begin; i <= i_end; ++i)
      {
!         nvec[i]->set_cvi(ViewId(V_REG, nvec[i_begin]->get_uuid(),
                                  static_cast<uint32_t>(seq)));
      }
  }
--- 662,668 ----
  {
      for (size_t i = i_begin; i <= i_end; ++i)
      {
!         nvec[i]->set_cvi(ViewId(V_REG, nvec[i_begin]->uuid(),
                                  static_cast<uint32_t>(seq)));
      }
  }
***************
*** 674,680 ****
      ViewSeq() { }
      bool operator()(const C& a, const C& b) const
      {
!         return (a->get_trace().get_current_view_trace().get_view().get_id().get_seq() < b->get_trace().get_current_view_trace().get_view().get_id().get_seq());
      }
  };
  
--- 674,680 ----
      ViewSeq() { }
      bool operator()(const C& a, const C& b) const
      {
!         return (a->trace().current_view_trace().view().id().seq() < b->trace().current_view_trace().view().id().seq());
      }
  };
  
***************
*** 684,690 ****
      if (i == dnv.size()) return static_cast<uint32_t>(-1);
      return (*std::max_element(dnv.begin() + i,
                                dnv.begin() + j,
!                               ViewSeq<const DummyNode*>()))->get_trace().get_current_view_trace().get_view().get_id().get_seq();
  }
  
  
--- 684,690 ----
      if (i == dnv.size()) return static_cast<uint32_t>(-1);
      return (*std::max_element(dnv.begin() + i,
                                dnv.begin() + j,
!                               ViewSeq<const DummyNode*>()))->trace().current_view_trace().view().id().seq();
  }
  
  
***************
*** 1231,1237 ****
          {
              if (j != i)
              {
!                 dn[j]->close(dn[i]->get_uuid());
              }
          }
          set_cvi(dn, 0, n_nodes - 1, view_seq + 1);
--- 1231,1237 ----
          {
              if (j != i)
              {
!                 dn[j]->close(dn[i]->uuid());
              }
          }
          set_cvi(dn, 0, n_nodes - 1, view_seq + 1);
***************
*** 1271,1286 ****
      }
      uint32_t view_seq = n_nodes + 1;
  
!     dn[0]->close(dn[1]->get_uuid());
!     dn[1]->close(dn[0]->get_uuid());
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq));
!     dn[2]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq));
!     dn[1]->set_cvi(ViewId(V_REG, dn[1]->get_uuid(), view_seq));
      gu_trace(prop.propagate_until_cvi(true));
  
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq + 1));
!     dn[1]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq + 1));
!     dn[2]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq + 1));
      gu_trace(prop.propagate_until_cvi(true));
  
      gu_trace(check_trace(dn));
--- 1271,1286 ----
      }
      uint32_t view_seq = n_nodes + 1;
  
!     dn[0]->close(dn[1]->uuid());
!     dn[1]->close(dn[0]->uuid());
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq));
!     dn[2]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq));
!     dn[1]->set_cvi(ViewId(V_REG, dn[1]->uuid(), view_seq));
      gu_trace(prop.propagate_until_cvi(true));
  
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq + 1));
!     dn[1]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq + 1));
!     dn[2]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq + 1));
      gu_trace(prop.propagate_until_cvi(true));
  
      gu_trace(check_trace(dn));
***************
*** 1315,1329 ****
      }
      uint32_t view_seq = n_nodes + 1;
  
!     dn[0]->close(dn[1]->get_uuid());
!     dn[1]->close(dn[0]->get_uuid());
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq));
!     dn[1]->set_cvi(ViewId(V_REG, dn[1]->get_uuid(), view_seq));
  
      gu_trace(prop.propagate_until_cvi(true));
  
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq + 1));
!     dn[1]->set_cvi(ViewId(V_REG, dn[0]->get_uuid(), view_seq + 1));
      gu_trace(prop.propagate_until_cvi(true));
  
      gu_trace(check_trace(dn));
--- 1315,1329 ----
      }
      uint32_t view_seq = n_nodes + 1;
  
!     dn[0]->close(dn[1]->uuid());
!     dn[1]->close(dn[0]->uuid());
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq));
!     dn[1]->set_cvi(ViewId(V_REG, dn[1]->uuid(), view_seq));
  
      gu_trace(prop.propagate_until_cvi(true));
  
!     dn[0]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq + 1));
!     dn[1]->set_cvi(ViewId(V_REG, dn[0]->uuid(), view_seq + 1));
      gu_trace(prop.propagate_until_cvi(true));
  
      gu_trace(check_trace(dn));
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_gcomm.cpp 2.x/gcomm/test/check_gcomm.cpp
*** galera-23.2.2-src/gcomm/test/check_gcomm.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_gcomm.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 14,19 ****
--- 14,20 ----
  #include <cstdlib>
  #include <check.h>
  #include <string.h>
+ #include <unistd.h>
  
  // <using namespace gcomm;
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_gmcast.cpp 2.x/gcomm/test/check_gmcast.cpp
*** galera-23.2.2-src/gcomm/test/check_gmcast.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_gmcast.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 45,53 ****
  
      class User : public Toplay
      {
!         Transport* tp;
!         size_t recvd;
!         Protostack pstack;
          User(const User&);
          void operator=(User&);
      public:
--- 45,53 ----
  
      class User : public Toplay
      {
!         Transport* tp_;
!         size_t recvd_;
!         Protostack pstack_;
          User(const User&);
          void operator=(User&);
      public:
***************
*** 56,64 ****
               const std::string& listen_addr,
               const std::string& remote_addr) :
              Toplay(pnet.conf()),
!             tp(0),
!             recvd(0),
!             pstack()
          {
              string uri("gmcast://");
              uri += remote_addr; // != 0 ? remote_addr : "";
--- 56,64 ----
               const std::string& listen_addr,
               const std::string& remote_addr) :
              Toplay(pnet.conf()),
!             tp_(0),
!             recvd_(0),
!             pstack_()
          {
              string uri("gmcast://");
              uri += remote_addr; // != 0 ? remote_addr : "";
***************
*** 74,107 ****
              uri += "&gmcast.listen_addr=tcp://";
              uri += listen_addr;
  
!             tp = Transport::create(pnet, uri);
          }
  
          ~User()
          {
!             delete tp;
          }
  
          void start(const std::string& peer = "")
          {
              if (peer == "")
              {
!                 tp->connect();
              }
              else
              {
!                 tp->connect(peer);
              }
!             pstack.push_proto(tp);
!             pstack.push_proto(this);
          }
  
  
          void stop()
          {
!             pstack.pop_proto(this);
!             pstack.pop_proto(tp);
!             tp->close();
          }
  
          void handle_timer()
--- 74,107 ----
              uri += "&gmcast.listen_addr=tcp://";
              uri += listen_addr;
  
!             tp_ = Transport::create(pnet, uri);
          }
  
          ~User()
          {
!             delete tp_;
          }
  
          void start(const std::string& peer = "")
          {
              if (peer == "")
              {
!                 tp_->connect();
              }
              else
              {
!                 tp_->connect(peer);
              }
!             pstack_.push_proto(tp_);
!             pstack_.push_proto(this);
          }
  
  
          void stop()
          {
!             pstack_.pop_proto(this);
!             pstack_.pop_proto(tp_);
!             tp_->close();
          }
  
          void handle_timer()
***************
*** 117,151 ****
          void handle_up(const void* cid, const Datagram& rb,
                         const ProtoUpMeta& um)
          {
!             if (rb.get_len() < rb.get_offset() + 16)
              {
                  gu_throw_fatal << "offset error";
              }
              char buf[16];
              memset(buf, 'a', sizeof(buf));
!             if (memcmp(buf, &rb.get_payload()[0] + rb.get_offset(), 16) != 0)
              {
                  gu_throw_fatal << "content mismatch";
              }
!             recvd++;
          }
  
!         size_t get_recvd() const
          {
!             return recvd;
          }
  
          void set_recvd(size_t val)
          {
!             recvd = val;
          }
  
  
!         Protostack& get_pstack() { return pstack; }
  
!         std::string get_listen_addr() const
          {
!             return tp->get_listen_addr();
          }
  
      };
--- 117,151 ----
          void handle_up(const void* cid, const Datagram& rb,
                         const ProtoUpMeta& um)
          {
!             if (rb.len() < rb.offset() + 16)
              {
                  gu_throw_fatal << "offset error";
              }
              char buf[16];
              memset(buf, 'a', sizeof(buf));
!             if (memcmp(buf, &rb.payload()[0] + rb.offset(), 16) != 0)
              {
                  gu_throw_fatal << "content mismatch";
              }
!             recvd_++;
          }
  
!         size_t recvd() const
          {
!             return recvd_;
          }
  
          void set_recvd(size_t val)
          {
!             recvd_ = val;
          }
  
  
!         Protostack& pstack() { return pstack_; }
  
!         std::string listen_addr() const
          {
!             return tp_->listen_addr();
          }
  
      };
***************
*** 155,161 ****
      auto_ptr<Protonet> pnet(Protonet::create(conf));
  
      User u1(*pnet, "127.0.0.1:0", "");
!     pnet->insert(&u1.get_pstack());
  
      log_info << "u1 start";
      u1.start();
--- 155,161 ----
      auto_ptr<Protonet> pnet(Protonet::create(conf));
  
      User u1(*pnet, "127.0.0.1:0", "");
!     pnet->insert(&u1.pstack());
  
      log_info << "u1 start";
      u1.start();
***************
*** 163,178 ****
  
      pnet->event_loop(Sec/10);
  
!     fail_unless(u1.get_recvd() == 0);
  
      log_info << "u2 start";
      User u2(*pnet, "127.0.0.1:0",
!             u1.get_listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u2.get_pstack());
  
      u2.start();
  
!     while (u1.get_recvd() <= 50 || u2.get_recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
--- 163,178 ----
  
      pnet->event_loop(Sec/10);
  
!     fail_unless(u1.recvd() == 0);
  
      log_info << "u2 start";
      User u2(*pnet, "127.0.0.1:0",
!             u1.listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u2.pstack());
  
      u2.start();
  
!     while (u1.recvd() <= 50 || u2.recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
***************
*** 181,191 ****
  
      log_info << "u3 start";
      User u3(*pnet, "127.0.0.1:0",
!             u2.get_listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u3.get_pstack());
      u3.start();
  
!     while (u3.get_recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
--- 181,191 ----
  
      log_info << "u3 start";
      User u3(*pnet, "127.0.0.1:0",
!             u2.listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u3.pstack());
      u3.start();
  
!     while (u3.recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
***************
*** 194,204 ****
  
      log_info << "u4 start";
      User u4(*pnet, "127.0.0.1:0",
!             u2.get_listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u4.get_pstack());
      u4.start();
  
!     while (u4.get_recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
--- 194,204 ----
  
      log_info << "u4 start";
      User u4(*pnet, "127.0.0.1:0",
!             u2.listen_addr().erase(0, strlen("tcp://")));
!     pnet->insert(&u4.pstack());
      u4.start();
  
!     while (u4.recvd() <= 50)
      {
          u1.handle_timer();
          u2.handle_timer();
***************
*** 207,219 ****
  
      log_info << "u1 stop";
      u1.stop();
!     pnet->erase(&u1.get_pstack());
  
      pnet->event_loop(3*Sec);
  
      log_info << "u1 start";
!     pnet->insert(&u1.get_pstack());
!     u1.start(u2.get_listen_addr());
  
      u1.set_recvd(0);
      u2.set_recvd(0);
--- 207,219 ----
  
      log_info << "u1 stop";
      u1.stop();
!     pnet->erase(&u1.pstack());
  
      pnet->event_loop(3*Sec);
  
      log_info << "u1 start";
!     pnet->insert(&u1.pstack());
!     u1.start(u2.listen_addr());
  
      u1.set_recvd(0);
      u2.set_recvd(0);
***************
*** 227,241 ****
          pnet->event_loop(Sec/10);
      }
  
!     fail_unless(u1.get_recvd() != 0);
!     fail_unless(u2.get_recvd() != 0);
!     fail_unless(u3.get_recvd() != 0);
!     fail_unless(u4.get_recvd() != 0);
! 
!     pnet->erase(&u4.get_pstack());
!     pnet->erase(&u3.get_pstack());
!     pnet->erase(&u2.get_pstack());
!     pnet->erase(&u1.get_pstack());
  
      u1.stop();
      u2.stop();
--- 227,241 ----
          pnet->event_loop(Sec/10);
      }
  
!     fail_unless(u1.recvd() != 0);
!     fail_unless(u2.recvd() != 0);
!     fail_unless(u3.recvd() != 0);
!     fail_unless(u4.recvd() != 0);
! 
!     pnet->erase(&u4.pstack());
!     pnet->erase(&u3.pstack());
!     pnet->erase(&u2.pstack());
!     pnet->erase(&u1.pstack());
  
      u1.stop();
      u2.stop();
***************
*** 257,272 ****
      Transport* tp1 = Transport::create(*pnet, "gmcast://?gmcast.group=test");
      Transport* tp2 = Transport::create(*pnet, "gmcast://127.0.0.1:4567?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:10002");
  
!     pnet->insert(&tp1->get_pstack());
!     pnet->insert(&tp2->get_pstack());
  
      tp1->connect();
      tp2->connect();
  
      pnet->event_loop(Sec);
  
!     pnet->erase(&tp2->get_pstack());
!     pnet->erase(&tp1->get_pstack());
  
      tp1->close();
      tp2->close();
--- 257,272 ----
      Transport* tp1 = Transport::create(*pnet, "gmcast://?gmcast.group=test");
      Transport* tp2 = Transport::create(*pnet, "gmcast://127.0.0.1:4567?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:10002");
  
!     pnet->insert(&tp1->pstack());
!     pnet->insert(&tp2->pstack());
  
      tp1->connect();
      tp2->connect();
  
      pnet->event_loop(Sec);
  
!     pnet->erase(&tp2->pstack());
!     pnet->erase(&tp1->pstack());
  
      tp1->close();
      tp2->close();
***************
*** 288,317 ****
      gu::Config conf;
      auto_ptr<Protonet> pnet(Protonet::create(conf));
      Transport* tp1 = Transport::create(*pnet, "gmcast://?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
!     pnet->insert(&tp1->get_pstack());
      tp1->connect();
  
      Transport* tp2 = Transport::create(*pnet,
                                         std::string("gmcast://")
!                                        + tp1->get_listen_addr().erase(
                                             0, strlen("tcp://"))
                                         + "?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
      Transport* tp3 = Transport::create(*pnet,
                                         std::string("gmcast://")
!                                        + tp1->get_listen_addr().erase(
                                             0, strlen("tcp://"))
                                         + "?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
  
  
!     pnet->insert(&tp2->get_pstack());
!     pnet->insert(&tp3->get_pstack());
  
      tp2->connect();
      tp3->connect();
  
      pnet->event_loop(Sec);
  
!     UUID uuid1 = tp1->get_uuid();
  
      tp1->close();
      tp2->close(uuid1);
--- 288,317 ----
      gu::Config conf;
      auto_ptr<Protonet> pnet(Protonet::create(conf));
      Transport* tp1 = Transport::create(*pnet, "gmcast://?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
!     pnet->insert(&tp1->pstack());
      tp1->connect();
  
      Transport* tp2 = Transport::create(*pnet,
                                         std::string("gmcast://")
!                                        + tp1->listen_addr().erase(
                                             0, strlen("tcp://"))
                                         + "?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
      Transport* tp3 = Transport::create(*pnet,
                                         std::string("gmcast://")
!                                        + tp1->listen_addr().erase(
                                             0, strlen("tcp://"))
                                         + "?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0");
  
  
!     pnet->insert(&tp2->pstack());
!     pnet->insert(&tp3->pstack());
  
      tp2->connect();
      tp3->connect();
  
      pnet->event_loop(Sec);
  
!     UUID uuid1 = tp1->uuid();
  
      tp1->close();
      tp2->close(uuid1);
***************
*** 323,331 ****
      log_info << "####";
      pnet->event_loop(Sec);
  
!     pnet->erase(&tp3->get_pstack());
!     pnet->erase(&tp2->get_pstack());
!     pnet->erase(&tp1->get_pstack());
  
      tp1->close();
      tp2->close();
--- 323,331 ----
      log_info << "####";
      pnet->event_loop(Sec);
  
!     pnet->erase(&tp3->pstack());
!     pnet->erase(&tp2->pstack());
!     pnet->erase(&tp1->pstack());
  
      tp1->close();
      tp2->close();
***************
*** 353,359 ****
                                *pnet,
                                "gmcast://127.0.0.1:4567?"
                                "gmcast.group=test"));
!     pnet->insert(&tp1->get_pstack());
      tp1->connect();
      try
      {
--- 353,359 ----
                                *pnet,
                                "gmcast://127.0.0.1:4567?"
                                "gmcast.group=test"));
!     pnet->insert(&tp1->pstack());
      tp1->connect();
      try
      {
***************
*** 365,371 ****
                      "unexpected errno: %d, cause %s",
                      e.get_errno(), e.what());
      }
!     pnet->erase(&tp1->get_pstack());
      tp1->close();
      delete tp1;
      pnet->event_loop(0);
--- 365,371 ----
                      "unexpected errno: %d, cause %s",
                      e.get_errno(), e.what());
      }
!     pnet->erase(&tp1->pstack());
      tp1->close();
      delete tp1;
      pnet->event_loop(0);
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_pc.cpp 2.x/gcomm/test/check_pc.cpp
*** galera-23.2.2-src/gcomm/test/check_pc.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_pc.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 30,50 ****
  START_TEST(test_pc_messages)
  {
      StateMessage pcs(0);
!     pc::NodeMap& sim(pcs.get_node_map());
  
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 6,
!                                      ViewId(V_PRIM,
!                                             UUID(0, 0), 9),
!                                      42)));
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 88, ViewId(V_PRIM,
!                                                        UUID(0, 0), 3),
!                                      472)));
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 78, ViewId(V_PRIM,
!                                                       UUID(0, 0), 87),
!                                      52)));
  
      size_t expt_size = 4 // hdr
          + 4              // seq
--- 30,50 ----
  START_TEST(test_pc_messages)
  {
      StateMessage pcs(0);
!     pc::NodeMap& sim(pcs.node_map());
  
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 6,
!                                        ViewId(V_PRIM,
!                                               UUID(0, 0), 9),
!                                        42, -1)));
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 88, ViewId(V_PRIM,
!                                                          UUID(0, 0), 3),
!                                        472, 0)));
      sim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 78, ViewId(V_PRIM,
!                                                         UUID(0, 0), 87),
!                                        52, 1)));
  
      size_t expt_size = 4 // hdr
          + 4              // seq
***************
*** 52,71 ****
      check_serialization(pcs, expt_size, StateMessage(-1));
  
      InstallMessage pci(0);
!     pc::NodeMap& iim = pci.get_node_map();
  
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 6, ViewId(V_PRIM,
!                                                        UUID(0, 0), 9), 42)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 88, ViewId(V_NON_PRIM,
!                                                          UUID(0, 0), 3), 472)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 78, ViewId(V_PRIM,
!                                                         UUID(0, 0), 87), 52)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 457, ViewId(V_NON_PRIM,
!                                                           UUID(0, 0), 37), 56)));
  
      expt_size = 4 // hdr
          + 4              // seq
--- 52,71 ----
      check_serialization(pcs, expt_size, StateMessage(-1));
  
      InstallMessage pci(0);
!     pc::NodeMap& iim = pci.node_map();
  
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 6, ViewId(V_PRIM,
!                                                        UUID(0, 0), 9), 42, -1)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 88, ViewId(V_NON_PRIM,
!                                                          UUID(0, 0), 3), 472, 0)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(true, 78, ViewId(V_PRIM,
!                                                         UUID(0, 0), 87), 52, 1)));
      iim.insert(std::make_pair(UUID(0,0),
                                pc::Node(false, 457, ViewId(V_NON_PRIM,
!                                                           UUID(0, 0), 37), 56, 0xff)));
  
      expt_size = 4 // hdr
          + 4              // seq
***************
*** 83,117 ****
  
  class PCUser : public Toplay
  {
-     list<View> views;
-     PCUser(const PCUser&);
-     void operator=(const PCUser&);
  public:
!     UUID uuid;
!     DummyTransport* tp;
!     Proto* pc;
!     PCUser(gu::Config& conf, const UUID& uuid_,
!            DummyTransport *tp_, Proto* pc_) :
          Toplay(conf),
!         views(),
!         uuid(uuid_),
!         tp(tp_),
!         pc(pc_)
!     {
!         gcomm::connect(tp, pc);
!         gcomm::connect(pc, this);
      }
  
      void handle_up(const void* cid, const Datagram& rb,
                     const ProtoUpMeta& um)
      {
          if (um.has_view() == true)
          {
!             const View& view(um.get_view());
              log_info << view;
!             fail_unless(view.get_type() == V_PRIM ||
!                         view.get_type() == V_NON_PRIM);
!             views.push_back(View(view));
          }
      }
  
--- 83,115 ----
  
  class PCUser : public Toplay
  {
  public:
!     PCUser(gu::Config& conf, const UUID& uuid,
!            DummyTransport *tp, Proto* pc) :
          Toplay(conf),
!         views_(),
!         uuid_(uuid),
!         tp_(tp),
!         pc_(pc)
!     {
!         gcomm::connect(tp_, pc_);
!         gcomm::connect(pc_, this);
      }
  
+     const UUID& uuid() const { return uuid_; }
+     DummyTransport* tp() { return tp_; }
+     Proto* pc() { return pc_; }
+ 
      void handle_up(const void* cid, const Datagram& rb,
                     const ProtoUpMeta& um)
      {
          if (um.has_view() == true)
          {
!             const View& view(um.view());
              log_info << view;
!             fail_unless(view.type() == V_PRIM ||
!                         view.type() == V_NON_PRIM);
!             views_.push_back(View(view));
          }
      }
  
***************
*** 122,128 ****
--- 120,134 ----
          Datagram dg(buf);
          fail_unless(send_down(dg, ProtoDownMeta()) == 0);
      }
+ private:
  
+     PCUser(const PCUser&);
+     void operator=(const PCUser&);
+ 
+     list<View> views_;
+     UUID uuid_;
+     DummyTransport* tp_;
+     Proto* pc_;
  };
  
  void get_msg(Datagram* rb, Message* msg, bool release = true)
***************
*** 135,142 ****
      else
      {
          // assert(rb->get_header().size() == 0 && rb->get_offset() == 0);
!         const byte_t* begin(get_begin(*rb));
!         const size_t available(get_available(*rb));
          fail_unless(msg->unserialize(begin,
                                       available, 0) != 0);
          log_info << "get_msg: " << msg->to_string();
--- 141,148 ----
      else
      {
          // assert(rb->get_header().size() == 0 && rb->get_offset() == 0);
!         const byte_t* begin(gcomm::begin(*rb));
!         const size_t available(gcomm::available(*rb));
          fail_unless(msg->unserialize(begin,
                                       available, 0) != 0);
          log_info << "get_msg: " << msg->to_string();
***************
*** 149,197 ****
  void single_boot(PCUser* pu1)
  {
  
!     ProtoUpMeta sum1(pu1->uuid);
  
!     View vt0(ViewId(V_TRANS, pu1->uuid, 0));
!     vt0.add_member(pu1->uuid, "n1");
      ProtoUpMeta um1(UUID::nil(), ViewId(), &vt0);
!     pu1->pc->connect(true);
!     // pu1->pc->shift_to(Proto::S_JOINING);
!     pu1->pc->handle_up(0, Datagram(), um1);
!     fail_unless(pu1->pc->get_state() == Proto::S_TRANS);
  
!     View vr1(ViewId(V_REG, pu1->uuid, 1));
!     vr1.add_member(pu1->uuid, "n1");
      ProtoUpMeta um2(UUID::nil(), ViewId(), &vr1);
!     pu1->pc->handle_up(0, Datagram(), um2);
!     fail_unless(pu1->pc->get_state() == Proto::S_STATES_EXCH);
  
!     Datagram* rb = pu1->tp->get_out();
      fail_unless(rb != 0);
      Message sm1;
      get_msg(rb, &sm1);
!     fail_unless(sm1.get_type() == Message::T_STATE);
!     fail_unless(sm1.get_node_map().size() == 1);
      {
!         const pc::Node& pi1 = pc::NodeMap::get_value(sm1.get_node_map().begin());
!         fail_unless(pi1.get_prim() == true);
!         fail_unless(pi1.get_last_prim() == ViewId(V_PRIM, pu1->uuid, 0));
      }
!     pu1->pc->handle_msg(sm1, Datagram(), sum1);
!     fail_unless(pu1->pc->get_state() == Proto::S_INSTALL);
  
!     rb = pu1->tp->get_out();
      fail_unless(rb != 0);
      Message im1;
      get_msg(rb, &im1);
!     fail_unless(im1.get_type() == Message::T_INSTALL);
!     fail_unless(im1.get_node_map().size() == 1);
      {
!         const pc::Node& pi1 = pc::NodeMap::get_value(im1.get_node_map().begin());
!         fail_unless(pi1.get_prim() == true);
!         fail_unless(pi1.get_last_prim() == ViewId(V_PRIM, pu1->uuid, 0));
      }
!     pu1->pc->handle_msg(im1, Datagram(), sum1);
!     fail_unless(pu1->pc->get_state() == Proto::S_PRIM);
  }
  
  START_TEST(test_pc_view_changes_single)
--- 155,203 ----
  void single_boot(PCUser* pu1)
  {
  
!     ProtoUpMeta sum1(pu1->uuid());
  
!     View vt0(ViewId(V_TRANS, pu1->uuid(), 0));
!     vt0.add_member(pu1->uuid(), "n1");
      ProtoUpMeta um1(UUID::nil(), ViewId(), &vt0);
!     pu1->pc()->connect(true);
!     // pu1->pc()->shift_to(Proto::S_JOINING);
!     pu1->pc()->handle_up(0, Datagram(), um1);
!     fail_unless(pu1->pc()->state() == Proto::S_TRANS);
  
!     View vr1(ViewId(V_REG, pu1->uuid(), 1));
!     vr1.add_member(pu1->uuid(), "n1");
      ProtoUpMeta um2(UUID::nil(), ViewId(), &vr1);
!     pu1->pc()->handle_up(0, Datagram(), um2);
!     fail_unless(pu1->pc()->state() == Proto::S_STATES_EXCH);
  
!     Datagram* rb = pu1->tp()->out();
      fail_unless(rb != 0);
      Message sm1;
      get_msg(rb, &sm1);
!     fail_unless(sm1.type() == Message::T_STATE);
!     fail_unless(sm1.node_map().size() == 1);
      {
!         const pc::Node& pi1 = pc::NodeMap::value(sm1.node_map().begin());
!         fail_unless(pi1.prim() == true);
!         fail_unless(pi1.last_prim() == ViewId(V_PRIM, pu1->uuid(), 0));
      }
!     pu1->pc()->handle_msg(sm1, Datagram(), sum1);
!     fail_unless(pu1->pc()->state() == Proto::S_INSTALL);
  
!     rb = pu1->tp()->out();
      fail_unless(rb != 0);
      Message im1;
      get_msg(rb, &im1);
!     fail_unless(im1.type() == Message::T_INSTALL);
!     fail_unless(im1.node_map().size() == 1);
      {
!         const pc::Node& pi1 = pc::NodeMap::value(im1.node_map().begin());
!         fail_unless(pi1.prim() == true);
!         fail_unless(pi1.last_prim() == ViewId(V_PRIM, pu1->uuid(), 0));
      }
!     pu1->pc()->handle_msg(im1, Datagram(), sum1);
!     fail_unless(pu1->pc()->state() == Proto::S_PRIM);
  }
  
  START_TEST(test_pc_view_changes_single)
***************
*** 210,298 ****
  
  static void double_boot(PCUser* pu1, PCUser* pu2)
  {
!     ProtoUpMeta pum1(pu1->uuid);
!     ProtoUpMeta pum2(pu2->uuid);
  
!     View t11(ViewId(V_TRANS, pu1->pc->get_current_view().get_id()));
!     t11.add_member(pu1->uuid, "n1");
!     pu1->pc->handle_view(t11);
!     fail_unless(pu1->pc->get_state() == Proto::S_TRANS);
! 
!     View t12(ViewId(V_TRANS, pu2->uuid, 0));
!     t12.add_member(pu2->uuid, "n2");
!     // pu2->pc->shift_to(Proto::S_JOINING);
!     pu2->pc->connect(false);
!     pu2->pc->handle_view(t12);
!     fail_unless(pu2->pc->get_state() == Proto::S_TRANS);
  
      View r1(ViewId(V_REG,
!                    pu1->uuid,
!                    pu1->pc->get_current_view().get_id().get_seq() + 1));
!     r1.add_member(pu1->uuid, "n1");
!     r1.add_member(pu2->uuid, "n2");
!     pu1->pc->handle_view(r1);
!     fail_unless(pu1->pc->get_state() == Proto::S_STATES_EXCH);
  
!     pu2->pc->handle_view(r1);
!     fail_unless(pu2->pc->get_state() == Proto::S_STATES_EXCH);
  
!     Datagram* rb = pu1->tp->get_out();
      fail_unless(rb != 0);
      Message sm1;
      get_msg(rb, &sm1);
!     fail_unless(sm1.get_type() == Message::T_STATE);
  
!     rb = pu2->tp->get_out();
      fail_unless(rb != 0);
      Message sm2;
      get_msg(rb, &sm2);
!     fail_unless(sm2.get_type() == Message::T_STATE);
  
!     rb = pu1->tp->get_out();
      fail_unless(rb == 0);
!     rb = pu2->tp->get_out();
      fail_unless(rb == 0);
  
!     pu1->pc->handle_msg(sm1, Datagram(), pum1);
!     rb = pu1->tp->get_out();
      fail_unless(rb == 0);
!     fail_unless(pu1->pc->get_state() == Proto::S_STATES_EXCH);
!     pu1->pc->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu1->pc->get_state() == Proto::S_INSTALL);
  
!     pu2->pc->handle_msg(sm1, Datagram(), pum1);
!     rb = pu2->tp->get_out();
      fail_unless(rb == 0);
!     fail_unless(pu2->pc->get_state() == Proto::S_STATES_EXCH);
!     pu2->pc->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu2->pc->get_state() == Proto::S_INSTALL);
  
      Message im1;
      UUID imsrc;
!     if (pu1->uuid < pu2->uuid)
      {
!         rb = pu1->tp->get_out();
!         imsrc = pu1->uuid;
      }
      else
      {
!         rb = pu2->tp->get_out();
!         imsrc = pu2->uuid;
      }
  
      fail_unless(rb != 0);
      get_msg(rb, &im1);
!     fail_unless(im1.get_type() == Message::T_INSTALL);
  
!     fail_unless(pu1->tp->get_out() == 0);
!     fail_unless(pu2->tp->get_out() == 0);
  
      ProtoUpMeta ipum(imsrc);
!     pu1->pc->handle_msg(im1, Datagram(), ipum);
!     fail_unless(pu1->pc->get_state() == Proto::S_PRIM);
  
!     pu2->pc->handle_msg(im1, Datagram(), ipum);
!     fail_unless(pu2->pc->get_state() == Proto::S_PRIM);
  }
  
  START_TEST(test_pc_view_changes_double)
--- 216,304 ----
  
  static void double_boot(PCUser* pu1, PCUser* pu2)
  {
!     ProtoUpMeta pum1(pu1->uuid());
!     ProtoUpMeta pum2(pu2->uuid());
  
!     View t11(ViewId(V_TRANS, pu1->pc()->current_view().id()));
!     t11.add_member(pu1->uuid(), "n1");
!     pu1->pc()->handle_view(t11);
!     fail_unless(pu1->pc()->state() == Proto::S_TRANS);
! 
!     View t12(ViewId(V_TRANS, pu2->uuid(), 0));
!     t12.add_member(pu2->uuid(), "n2");
!     // pu2->pc()->shift_to(Proto::S_JOINING);
!     pu2->pc()->connect(false);
!     pu2->pc()->handle_view(t12);
!     fail_unless(pu2->pc()->state() == Proto::S_TRANS);
  
      View r1(ViewId(V_REG,
!                    pu1->uuid(),
!                    pu1->pc()->current_view().id().seq() + 1));
!     r1.add_member(pu1->uuid(), "n1");
!     r1.add_member(pu2->uuid(), "n2");
!     pu1->pc()->handle_view(r1);
!     fail_unless(pu1->pc()->state() == Proto::S_STATES_EXCH);
  
!     pu2->pc()->handle_view(r1);
!     fail_unless(pu2->pc()->state() == Proto::S_STATES_EXCH);
  
!     Datagram* rb = pu1->tp()->out();
      fail_unless(rb != 0);
      Message sm1;
      get_msg(rb, &sm1);
!     fail_unless(sm1.type() == Message::T_STATE);
  
!     rb = pu2->tp()->out();
      fail_unless(rb != 0);
      Message sm2;
      get_msg(rb, &sm2);
!     fail_unless(sm2.type() == Message::T_STATE);
  
!     rb = pu1->tp()->out();
      fail_unless(rb == 0);
!     rb = pu2->tp()->out();
      fail_unless(rb == 0);
  
!     pu1->pc()->handle_msg(sm1, Datagram(), pum1);
!     rb = pu1->tp()->out();
      fail_unless(rb == 0);
!     fail_unless(pu1->pc()->state() == Proto::S_STATES_EXCH);
!     pu1->pc()->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu1->pc()->state() == Proto::S_INSTALL);
  
!     pu2->pc()->handle_msg(sm1, Datagram(), pum1);
!     rb = pu2->tp()->out();
      fail_unless(rb == 0);
!     fail_unless(pu2->pc()->state() == Proto::S_STATES_EXCH);
!     pu2->pc()->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu2->pc()->state() == Proto::S_INSTALL);
  
      Message im1;
      UUID imsrc;
!     if (pu1->uuid() < pu2->uuid())
      {
!         rb = pu1->tp()->out();
!         imsrc = pu1->uuid();
      }
      else
      {
!         rb = pu2->tp()->out();
!         imsrc = pu2->uuid();
      }
  
      fail_unless(rb != 0);
      get_msg(rb, &im1);
!     fail_unless(im1.type() == Message::T_INSTALL);
  
!     fail_unless(pu1->tp()->out() == 0);
!     fail_unless(pu2->tp()->out() == 0);
  
      ProtoUpMeta ipum(imsrc);
!     pu1->pc()->handle_msg(im1, Datagram(), ipum);
!     fail_unless(pu1->pc()->state() == Proto::S_PRIM);
  
!     pu2->pc()->handle_msg(im1, Datagram(), ipum);
!     fail_unless(pu2->pc()->state() == Proto::S_PRIM);
  }
  
  START_TEST(test_pc_view_changes_double)
***************
*** 316,364 ****
  
      Datagram* rb;
  
!     View tnp(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tnp.add_member(uuid1, "n1");
!     pu1.pc->handle_view(tnp);
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
      View reg(ViewId(V_REG, uuid1,
!                     pu1.pc->get_current_view().get_id().get_seq() + 1));
      reg.add_member(uuid1, "n1");
!     pu1.pc->handle_view(reg);
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     rb = pu1.tp->get_out();
      fail_unless(rb != 0);
!     pu1.pc->handle_up(0, *rb, ProtoUpMeta(uuid1));
!     fail_unless(pu1.pc->get_state() == Proto::S_NON_PRIM);
      delete rb;
  
!     View tpv2(ViewId(V_TRANS, pu2.pc->get_current_view().get_id()));
      tpv2.add_member(uuid2, "n2");
      tpv2.add_left(uuid1, "n1");
!     pu2.pc->handle_view(tpv2);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.tp->get_out() == 0);
  
      View rp2(ViewId(V_REG, uuid2,
!                                  pu1.pc->get_current_view().get_id().get_seq() + 1));
      rp2.add_member(uuid2, "n2");
      rp2.add_left(uuid1, "n1");
!     pu2.pc->handle_view(rp2);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
!     rb = pu2.tp->get_out();
      fail_unless(rb != 0);
      Message sm2;
      get_msg(rb, &sm2);
!     fail_unless(sm2.get_type() == Message::T_STATE);
!     fail_unless(pu2.tp->get_out() == 0);
!     pu2.pc->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu2.pc->get_state() == Proto::S_INSTALL);
!     rb = pu2.tp->get_out();
      fail_unless(rb != 0);
      Message im2;
      get_msg(rb, &im2);
!     fail_unless(im2.get_type() == Message::T_INSTALL);
!     pu2.pc->handle_msg(im2, Datagram(), pum2);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 322,370 ----
  
      Datagram* rb;
  
!     View tnp(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tnp.add_member(uuid1, "n1");
!     pu1.pc()->handle_view(tnp);
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
      View reg(ViewId(V_REG, uuid1,
!                     pu1.pc()->current_view().id().seq() + 1));
      reg.add_member(uuid1, "n1");
!     pu1.pc()->handle_view(reg);
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     rb = pu1.tp()->out();
      fail_unless(rb != 0);
!     pu1.pc()->handle_up(0, *rb, ProtoUpMeta(uuid1));
!     fail_unless(pu1.pc()->state() == Proto::S_NON_PRIM);
      delete rb;
  
!     View tpv2(ViewId(V_TRANS, pu2.pc()->current_view().id()));
      tpv2.add_member(uuid2, "n2");
      tpv2.add_left(uuid1, "n1");
!     pu2.pc()->handle_view(tpv2);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.tp()->out() == 0);
  
      View rp2(ViewId(V_REG, uuid2,
!                                  pu1.pc()->current_view().id().seq() + 1));
      rp2.add_member(uuid2, "n2");
      rp2.add_left(uuid1, "n1");
!     pu2.pc()->handle_view(rp2);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
!     rb = pu2.tp()->out();
      fail_unless(rb != 0);
      Message sm2;
      get_msg(rb, &sm2);
!     fail_unless(sm2.type() == Message::T_STATE);
!     fail_unless(pu2.tp()->out() == 0);
!     pu2.pc()->handle_msg(sm2, Datagram(), pum2);
!     fail_unless(pu2.pc()->state() == Proto::S_INSTALL);
!     rb = pu2.tp()->out();
      fail_unless(rb != 0);
      Message im2;
      get_msg(rb, &im2);
!     fail_unless(im2.type() == Message::T_INSTALL);
!     pu2.pc()->handle_msg(im2, Datagram(), pum2);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 409,527 ****
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
      // PRIM -> TRANS -> STATES_EXCH -> RTR -> TRANS -> STATES_EXCH -> RTR -> PRIM
!     View tr1(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr1.add_member(uuid1, "n1");
      tr1.add_member(uuid2, "n2");
!     pu1.pc->handle_view(tr1);
!     pu2.pc->handle_view(tr1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp->get_out() == 0);
!     fail_unless(pu2.tp->get_out() == 0);
  
      View reg2(ViewId(V_REG, uuid1,
!                      pu1.pc->get_current_view().get_id().get_seq() + 1));
      reg2.add_member(uuid1, "n1");
      reg2.add_member(uuid2, "n2");
!     pu1.pc->handle_view(reg2);
!     pu2.pc->handle_view(reg2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
      Message msg;
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
!     pu2.pc->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum2);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc->get_state() == Proto::S_INSTALL);
  
!     View tr2(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr2.add_member(uuid1, "n1");
      tr2.add_member(uuid2, "n2");
  
!     pu1.pc->handle_view(tr2);
!     pu2.pc->handle_view(tr2);
  
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
      Message im;
  
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum1);
!         pu2.pc->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum2);
!         pu2.pc->handle_msg(im, Datagram(), pum2);
      }
  
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc->get_current_view().get_id().get_seq() + 1));
  
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc->handle_view(reg3);
!     pu2.pc->handle_view(reg3);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
!     pu2.pc->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum2);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc->get_state() == Proto::S_INSTALL);
  
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum1);
!         pu2.pc->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum2);
!         pu2.pc->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 415,533 ----
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
      // PRIM -> TRANS -> STATES_EXCH -> RTR -> TRANS -> STATES_EXCH -> RTR -> PRIM
!     View tr1(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr1.add_member(uuid1, "n1");
      tr1.add_member(uuid2, "n2");
!     pu1.pc()->handle_view(tr1);
!     pu2.pc()->handle_view(tr1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp()->out() == 0);
!     fail_unless(pu2.tp()->out() == 0);
  
      View reg2(ViewId(V_REG, uuid1,
!                      pu1.pc()->current_view().id().seq() + 1));
      reg2.add_member(uuid1, "n1");
      reg2.add_member(uuid2, "n2");
!     pu1.pc()->handle_view(reg2);
!     pu2.pc()->handle_view(reg2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
      Message msg;
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum2);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc()->state() == Proto::S_INSTALL);
  
!     View tr2(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr2.add_member(uuid1, "n1");
      tr2.add_member(uuid2, "n2");
  
!     pu1.pc()->handle_view(tr2);
!     pu2.pc()->handle_view(tr2);
  
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
      Message im;
  
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum1);
!         pu2.pc()->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum2);
!         pu2.pc()->handle_msg(im, Datagram(), pum2);
      }
  
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc()->current_view().id().seq() + 1));
  
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc()->handle_view(reg3);
!     pu2.pc()->handle_view(reg3);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum2);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc()->state() == Proto::S_INSTALL);
  
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum1);
!         pu2.pc()->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum2);
!         pu2.pc()->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 547,649 ****
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
      // PRIM -> TRANS -> STATES_EXCH -> TRANS -> STATES_EXCH -> RTR -> PRIM
!     View tr1(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr1.add_member(uuid1, "n1");
      tr1.add_member(uuid2, "n2");
!     pu1.pc->handle_view(tr1);
!     pu2.pc->handle_view(tr1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp->get_out() == 0);
!     fail_unless(pu2.tp->get_out() == 0);
  
      View reg2(ViewId(V_REG, uuid1,
!                      pu1.pc->get_current_view().get_id().get_seq() + 1));
      reg2.add_member(uuid1, "n1");
      reg2.add_member(uuid2, "n2");
!     pu1.pc->handle_view(reg2);
!     pu2.pc->handle_view(reg2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
  
  
!     View tr2(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr2.add_member(uuid1, "n1");
      tr2.add_member(uuid2, "n2");
  
!     pu1.pc->handle_view(tr2);
!     pu2.pc->handle_view(tr2);
  
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
      Message msg;
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
!     pu2.pc->handle_msg(msg, Datagram(), pum1);
! 
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
! 
!     get_msg(pu2.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum2);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc->get_current_view().get_id().get_seq() + 1));
  
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc->handle_view(reg3);
!     pu2.pc->handle_view(reg3);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
!     pu2.pc->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum2);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc->get_state() == Proto::S_INSTALL);
  
      Message im;
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum1);
!         pu2.pc->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum2);
!         pu2.pc->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 553,655 ----
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
      // PRIM -> TRANS -> STATES_EXCH -> TRANS -> STATES_EXCH -> RTR -> PRIM
!     View tr1(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr1.add_member(uuid1, "n1");
      tr1.add_member(uuid2, "n2");
!     pu1.pc()->handle_view(tr1);
!     pu2.pc()->handle_view(tr1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp()->out() == 0);
!     fail_unless(pu2.tp()->out() == 0);
  
      View reg2(ViewId(V_REG, uuid1,
!                      pu1.pc()->current_view().id().seq() + 1));
      reg2.add_member(uuid1, "n1");
      reg2.add_member(uuid2, "n2");
!     pu1.pc()->handle_view(reg2);
!     pu2.pc()->handle_view(reg2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
  
  
!     View tr2(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr2.add_member(uuid1, "n1");
      tr2.add_member(uuid2, "n2");
  
!     pu1.pc()->handle_view(tr2);
!     pu2.pc()->handle_view(tr2);
  
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
      Message msg;
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg, Datagram(), pum1);
! 
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
! 
!     get_msg(pu2.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum2);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc()->current_view().id().seq() + 1));
  
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc()->handle_view(reg3);
!     pu2.pc()->handle_view(reg3);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum2);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc()->state() == Proto::S_INSTALL);
  
      Message im;
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum1);
!         pu2.pc()->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum2);
!         pu2.pc()->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 669,773 ****
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
      // PRIM -> NON_PRIM -> STATES_EXCH -> RTR -> NON_PRIM -> STATES_EXCH -> ...
      //      -> NON_PRIM -> STATES_EXCH -> RTR -> NON_PRIM
!     View tr11(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr11.add_member(uuid1, "n1");
!     pu1.pc->handle_view(tr11);
  
!     View tr12(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr12.add_member(uuid2, "n2");
!     pu2.pc->handle_view(tr12);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp->get_out() == 0);
!     fail_unless(pu2.tp->get_out() == 0);
  
      View reg21(ViewId(V_REG, uuid1,
!                       pu1.pc->get_current_view().get_id().get_seq() + 1));
      reg21.add_member(uuid1, "n1");
!     pu1.pc->handle_view(reg21);
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
  
      View reg22(ViewId(V_REG, uuid2,
!                       pu2.pc->get_current_view().get_id().get_seq() + 1));
      reg22.add_member(uuid2, "n2");
!     pu2.pc->handle_view(reg22);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
  
      Message msg;
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
  
!     get_msg(pu2.tp->get_out(), &msg);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_NON_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_NON_PRIM);
  
  
  
!     View tr21(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr21.add_member(uuid1, "n1");
!     pu1.pc->handle_view(tr21);
  
!     View tr22(ViewId(V_TRANS, pu2.pc->get_current_view().get_id()));
      tr22.add_member(uuid2, "n2");
!     pu2.pc->handle_view(tr22);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_TRANS);
!     fail_unless(pu2.pc->get_state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp->get_out() == 0);
!     fail_unless(pu2.tp->get_out() == 0);
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc->get_current_view().get_id().get_seq() + 1));
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc->handle_view(reg3);
!     pu2.pc->handle_view(reg3);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum1);
!     pu2.pc->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc->get_state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp->get_out(), &msg);
!     pu1.pc->handle_msg(msg, Datagram(), pum2);
!     pu2.pc->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc->get_state() == Proto::S_INSTALL);
  
      Message im;
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum1);
!         pu2.pc->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp->get_out(), &im);
!         pu1.pc->handle_msg(im, Datagram(), pum2);
!         pu2.pc->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 675,779 ----
      // n2: JOINING -> STATES_EXCH -> RTR -> PRIM
      double_boot(&pu1, &pu2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
      // PRIM -> NON_PRIM -> STATES_EXCH -> RTR -> NON_PRIM -> STATES_EXCH -> ...
      //      -> NON_PRIM -> STATES_EXCH -> RTR -> NON_PRIM
!     View tr11(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr11.add_member(uuid1, "n1");
!     pu1.pc()->handle_view(tr11);
  
!     View tr12(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr12.add_member(uuid2, "n2");
!     pu2.pc()->handle_view(tr12);
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp()->out() == 0);
!     fail_unless(pu2.tp()->out() == 0);
  
      View reg21(ViewId(V_REG, uuid1,
!                       pu1.pc()->current_view().id().seq() + 1));
      reg21.add_member(uuid1, "n1");
!     pu1.pc()->handle_view(reg21);
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
  
      View reg22(ViewId(V_REG, uuid2,
!                       pu2.pc()->current_view().id().seq() + 1));
      reg22.add_member(uuid2, "n2");
!     pu2.pc()->handle_view(reg22);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
  
      Message msg;
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
  
!     get_msg(pu2.tp()->out(), &msg);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_NON_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_NON_PRIM);
  
  
  
!     View tr21(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr21.add_member(uuid1, "n1");
!     pu1.pc()->handle_view(tr21);
  
!     View tr22(ViewId(V_TRANS, pu2.pc()->current_view().id()));
      tr22.add_member(uuid2, "n2");
!     pu2.pc()->handle_view(tr22);
  
!     fail_unless(pu1.pc()->state() == Proto::S_TRANS);
!     fail_unless(pu2.pc()->state() == Proto::S_TRANS);
  
!     fail_unless(pu1.tp()->out() == 0);
!     fail_unless(pu2.tp()->out() == 0);
  
      View reg3(ViewId(V_REG, uuid1,
!                      pu1.pc()->current_view().id().seq() + 1));
      reg3.add_member(uuid1, "n1");
      reg3.add_member(uuid2, "n2");
  
!     pu1.pc()->handle_view(reg3);
!     pu2.pc()->handle_view(reg3);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu1.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg, Datagram(), pum1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
!     fail_unless(pu2.pc()->state() == Proto::S_STATES_EXCH);
  
!     get_msg(pu2.tp()->out(), &msg);
!     pu1.pc()->handle_msg(msg, Datagram(), pum2);
!     pu2.pc()->handle_msg(msg, Datagram(), pum2);
  
!     fail_unless(pu1.pc()->state() == Proto::S_INSTALL);
!     fail_unless(pu2.pc()->state() == Proto::S_INSTALL);
  
      Message im;
      if (uuid1 < uuid2)
      {
!         get_msg(pu1.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum1);
!         pu2.pc()->handle_msg(im, Datagram(), pum1);
      }
      else
      {
!         get_msg(pu2.tp()->out(), &im);
!         pu1.pc()->handle_msg(im, Datagram(), pum2);
!         pu2.pc()->handle_msg(im, Datagram(), pum2);
      }
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 790,823 ****
      PCUser pu2(conf, uuid2, &tp2, &pc2);
      single_boot(&pu2);
  
!     View tr1(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr1.add_member(uuid1);
!     pu1.pc->handle_view(tr1);
!     View tr2(ViewId(V_TRANS, pu2.pc->get_current_view().get_id()));
      tr2.add_member(uuid2);
!     pu2.pc->handle_view(tr2);
  
!     View reg(ViewId(V_REG, uuid1, tr1.get_id().get_seq() + 1));
      reg.add_member(uuid1);
      reg.add_member(uuid2);
!     pu1.pc->handle_view(reg);
!     pu2.pc->handle_view(reg);
  
      Message msg1, msg2;
  
      /* First node must discard msg2 and stay in states exch waiting for
       * trans view */
!     get_msg(pu1.tp->get_out(), &msg1);
!     get_msg(pu2.tp->get_out(), &msg2);
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
  
!     pu1.pc->handle_msg(msg1, Datagram(), pum1);
!     pu1.pc->handle_msg(msg2, Datagram(), pum2);
  
      /* Second node must abort */
      try
      {
!         pu2.pc->handle_msg(msg1, Datagram(), pum1);
          fail("not aborted");
      }
      catch (Exception& e)
--- 796,829 ----
      PCUser pu2(conf, uuid2, &tp2, &pc2);
      single_boot(&pu2);
  
!     View tr1(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr1.add_member(uuid1);
!     pu1.pc()->handle_view(tr1);
!     View tr2(ViewId(V_TRANS, pu2.pc()->current_view().id()));
      tr2.add_member(uuid2);
!     pu2.pc()->handle_view(tr2);
  
!     View reg(ViewId(V_REG, uuid1, tr1.id().seq() + 1));
      reg.add_member(uuid1);
      reg.add_member(uuid2);
!     pu1.pc()->handle_view(reg);
!     pu2.pc()->handle_view(reg);
  
      Message msg1, msg2;
  
      /* First node must discard msg2 and stay in states exch waiting for
       * trans view */
!     get_msg(pu1.tp()->out(), &msg1);
!     get_msg(pu2.tp()->out(), &msg2);
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
  
!     pu1.pc()->handle_msg(msg1, Datagram(), pum1);
!     pu1.pc()->handle_msg(msg2, Datagram(), pum2);
  
      /* Second node must abort */
      try
      {
!         pu2.pc()->handle_msg(msg1, Datagram(), pum1);
          fail("not aborted");
      }
      catch (Exception& e)
***************
*** 825,846 ****
          log_info << e.what();
      }
  
!     fail_unless(pu1.tp->get_out() == 0);
  
!     View tr3(ViewId(V_TRANS, reg.get_id()));
      tr3.add_member(uuid1);
!     pu1.pc->handle_view(tr3);
!     View reg3(ViewId(V_REG, uuid1, tr3.get_id().get_seq() + 1));
      reg3.add_member(uuid1);
!     pu1.pc->handle_view(reg3);
  
!     get_msg(pu1.tp->get_out(), &msg1);
!     pu1.pc->handle_msg(msg1, Datagram(), pum1);
  
!     get_msg(pu1.tp->get_out(), &msg1);
!     pu1.pc->handle_msg(msg1, Datagram(), pum1);
  
!     fail_unless(pu1.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 831,852 ----
          log_info << e.what();
      }
  
!     fail_unless(pu1.tp()->out() == 0);
  
!     View tr3(ViewId(V_TRANS, reg.id()));
      tr3.add_member(uuid1);
!     pu1.pc()->handle_view(tr3);
!     View reg3(ViewId(V_REG, uuid1, tr3.id().seq() + 1));
      reg3.add_member(uuid1);
!     pu1.pc()->handle_view(reg3);
  
!     get_msg(pu1.tp()->out(), &msg1);
!     pu1.pc()->handle_msg(msg1, Datagram(), pum1);
  
!     get_msg(pu1.tp()->out(), &msg1);
!     pu1.pc()->handle_msg(msg1, Datagram(), pum1);
  
!     fail_unless(pu1.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 863,896 ****
      PCUser pu2(conf, uuid2, &tp2, &pc2);
      single_boot(&pu2);
  
!     View tr1(ViewId(V_TRANS, pu1.pc->get_current_view().get_id()));
      tr1.add_member(uuid1);
!     pu1.pc->handle_view(tr1);
!     View tr2(ViewId(V_TRANS, pu2.pc->get_current_view().get_id()));
      tr2.add_member(uuid2);
!     pu2.pc->handle_view(tr2);
  
!     View reg(ViewId(V_REG, uuid1, tr1.get_id().get_seq() + 1));
      reg.add_member(uuid1);
      reg.add_member(uuid2);
!     pu1.pc->handle_view(reg);
!     pu2.pc->handle_view(reg);
  
      Message msg1, msg2;
  
      /* First node must discard msg2 and stay in states exch waiting for
       * trans view */
!     get_msg(pu1.tp->get_out(), &msg1);
!     get_msg(pu2.tp->get_out(), &msg2);
!     fail_unless(pu1.pc->get_state() == Proto::S_STATES_EXCH);
  
!     pu1.pc->handle_msg(msg1, Datagram(), pum1);
!     pu2.pc->handle_msg(msg1, Datagram(), pum1);
  
      /* First node must abort */
      try
      {
!         pu1.pc->handle_msg(msg2, Datagram(), pum2);
          fail("not aborted");
      }
      catch (Exception& e)
--- 869,902 ----
      PCUser pu2(conf, uuid2, &tp2, &pc2);
      single_boot(&pu2);
  
!     View tr1(ViewId(V_TRANS, pu1.pc()->current_view().id()));
      tr1.add_member(uuid1);
!     pu1.pc()->handle_view(tr1);
!     View tr2(ViewId(V_TRANS, pu2.pc()->current_view().id()));
      tr2.add_member(uuid2);
!     pu2.pc()->handle_view(tr2);
  
!     View reg(ViewId(V_REG, uuid1, tr1.id().seq() + 1));
      reg.add_member(uuid1);
      reg.add_member(uuid2);
!     pu1.pc()->handle_view(reg);
!     pu2.pc()->handle_view(reg);
  
      Message msg1, msg2;
  
      /* First node must discard msg2 and stay in states exch waiting for
       * trans view */
!     get_msg(pu1.tp()->out(), &msg1);
!     get_msg(pu2.tp()->out(), &msg2);
!     fail_unless(pu1.pc()->state() == Proto::S_STATES_EXCH);
  
!     pu1.pc()->handle_msg(msg1, Datagram(), pum1);
!     pu2.pc()->handle_msg(msg1, Datagram(), pum1);
  
      /* First node must abort */
      try
      {
!         pu1.pc()->handle_msg(msg2, Datagram(), pum2);
          fail("not aborted");
      }
      catch (Exception& e)
***************
*** 898,919 ****
          log_info << e.what();
      }
  
!     fail_unless(pu2.tp->get_out() == 0);
  
!     View tr3(ViewId(V_TRANS, reg.get_id()));
      tr3.add_member(uuid2);
!     pu2.pc->handle_view(tr3);
!     View reg3(ViewId(V_REG, uuid2, tr3.get_id().get_seq() + 1));
      reg3.add_member(uuid2);
!     pu2.pc->handle_view(reg3);
  
!     get_msg(pu2.tp->get_out(), &msg2);
!     pu2.pc->handle_msg(msg2, Datagram(), pum2);
  
!     get_msg(pu2.tp->get_out(), &msg2);
!     pu2.pc->handle_msg(msg2, Datagram(), pum2);
  
!     fail_unless(pu2.pc->get_state() == Proto::S_PRIM);
  
  }
  END_TEST
--- 904,925 ----
          log_info << e.what();
      }
  
!     fail_unless(pu2.tp()->out() == 0);
  
!     View tr3(ViewId(V_TRANS, reg.id()));
      tr3.add_member(uuid2);
!     pu2.pc()->handle_view(tr3);
!     View reg3(ViewId(V_REG, uuid2, tr3.id().seq() + 1));
      reg3.add_member(uuid2);
!     pu2.pc()->handle_view(reg3);
  
!     get_msg(pu2.tp()->out(), &msg2);
!     pu2.pc()->handle_msg(msg2, Datagram(), pum2);
  
!     get_msg(pu2.tp()->out(), &msg2);
!     pu2.pc()->handle_msg(msg2, Datagram(), pum2);
  
!     fail_unless(pu2.pc()->state() == Proto::S_PRIM);
  
  }
  END_TEST
***************
*** 942,949 ****
      {
          nvec[i]->set_cvi(ViewId(type,
                                  type == V_NON_PRIM ?
!                                 nvec[0]->get_uuid() :
!                                 nvec[i_begin]->get_uuid(),
                                  static_cast<uint32_t>(type == V_NON_PRIM ? seq - 1 : seq)));
      }
  }
--- 948,955 ----
      {
          nvec[i]->set_cvi(ViewId(type,
                                  type == V_NON_PRIM ?
!                                 nvec[0]->uuid() :
!                                 nvec[i_begin]->uuid(),
                                  static_cast<uint32_t>(type == V_NON_PRIM ? seq - 1 : seq)));
      }
  }
***************
*** 952,958 ****
  
  static DummyNode* create_dummy_node(size_t idx,
                                      const string& inactive_timeout = "PT1H",
!                                     const string& retrans_period = "PT1H")
  {
      const string conf = "evs://?" + Conf::EvsViewForgetTimeout + "=PT1H&"
          + Conf::EvsInactiveCheckPeriod + "=" + to_string(Period(inactive_timeout)/3) + "&"
--- 958,965 ----
  
  static DummyNode* create_dummy_node(size_t idx,
                                      const string& inactive_timeout = "PT1H",
!                                     const string& retrans_period = "PT1H",
!                                     int weight = 1)
  {
      const string conf = "evs://?" + Conf::EvsViewForgetTimeout + "=PT1H&"
          + Conf::EvsInactiveCheckPeriod + "=" + to_string(Period(inactive_timeout)/3) + "&"
***************
*** 957,973 ****
      const string conf = "evs://?" + Conf::EvsViewForgetTimeout + "=PT1H&"
          + Conf::EvsInactiveCheckPeriod + "=" + to_string(Period(inactive_timeout)/3) + "&"
          + Conf::EvsInactiveTimeout + "=" + inactive_timeout + "&"
- 
          + Conf::EvsKeepalivePeriod + "=" + retrans_period + "&"
          + Conf::EvsJoinRetransPeriod + "=" + retrans_period + "&"
!         + Conf::EvsInstallTimeout + "=" + inactive_timeout;;
      list<Protolay*> protos;
      try
      {
          UUID uuid(static_cast<int32_t>(idx));
          protos.push_back(new DummyTransport(uuid, false));
          protos.push_back(new evs::Proto(gu_conf, uuid, conf));
!         protos.push_back(new Proto(gu_conf, uuid));
          return new DummyNode(gu_conf, idx, protos);
      }
      catch (...)
--- 964,980 ----
      const string conf = "evs://?" + Conf::EvsViewForgetTimeout + "=PT1H&"
          + Conf::EvsInactiveCheckPeriod + "=" + to_string(Period(inactive_timeout)/3) + "&"
          + Conf::EvsInactiveTimeout + "=" + inactive_timeout + "&"
          + Conf::EvsKeepalivePeriod + "=" + retrans_period + "&"
          + Conf::EvsJoinRetransPeriod + "=" + retrans_period + "&"
!         + Conf::EvsInstallTimeout + "=" + inactive_timeout + "&"
!         + Conf::PcWeight + "=" + gu::to_string(weight);
      list<Protolay*> protos;
      try
      {
          UUID uuid(static_cast<int32_t>(idx));
          protos.push_back(new DummyTransport(uuid, false));
          protos.push_back(new evs::Proto(gu_conf, uuid, conf));
!         protos.push_back(new Proto(gu_conf, uuid, conf));
          return new DummyNode(gu_conf, idx, protos);
      }
      catch (...)
***************
*** 1166,1210 ****
  
  class PCUser2 : public Toplay
  {
!     Transport* tp;
!     bool sending;
!     uint8_t my_type;
!     bool send;
!     Period send_period;
!     Date next_send;
      PCUser2(const PCUser2&);
      void operator=(const PCUser2);
  public:
!     PCUser2(Protonet& net, const string& uri, const bool send_ = true) :
          Toplay(net.conf()),
!         tp(Transport::create(net, uri)),
!         sending(false),
!         my_type(static_cast<uint8_t>(1 + ::rand()%4)),
!         send(send_),
!         send_period("PT0.05S"),
!         next_send(Date::max())
      { }
  
      ~PCUser2()
      {
!         delete tp;
      }
  
      void start()
      {
!         gcomm::connect(tp, this);
!         tp->connect();
!         gcomm::disconnect(tp, this);
!         tp->get_pstack().push_proto(this);
      }
  
      void stop()
      {
!         sending = false;
!         tp->get_pstack().pop_proto(this);
!         gcomm::connect(tp, this);
!         tp->close();
!         gcomm::disconnect(tp, this);
      }
  
      void handle_up(const void* cid, const Datagram& rb, const ProtoUpMeta& um)
--- 1173,1217 ----
  
  class PCUser2 : public Toplay
  {
!     Transport* tp_;
!     bool sending_;
!     uint8_t my_type_;
!     bool send_;
!     Period send_period_;
!     Date next_send_;
      PCUser2(const PCUser2&);
      void operator=(const PCUser2);
  public:
!     PCUser2(Protonet& net, const string& uri, const bool send = true) :
          Toplay(net.conf()),
!         tp_(Transport::create(net, uri)),
!         sending_(false),
!         my_type_(static_cast<uint8_t>(1 + ::rand()%4)),
!         send_(send),
!         send_period_("PT0.05S"),
!         next_send_(Date::max())
      { }
  
      ~PCUser2()
      {
!         delete tp_;
      }
  
      void start()
      {
!         gcomm::connect(tp_, this);
!         tp_->connect();
!         gcomm::disconnect(tp_, this);
!         tp_->pstack().push_proto(this);
      }
  
      void stop()
      {
!         sending_ = false;
!         tp_->pstack().pop_proto(this);
!         gcomm::connect(tp_, this);
!         tp_->close();
!         gcomm::disconnect(tp_, this);
      }
  
      void handle_up(const void* cid, const Datagram& rb, const ProtoUpMeta& um)
***************
*** 1212,1261 ****
  
          if (um.has_view())
          {
!             const View& view(um.get_view());
              log_info << view;
!             if (view.get_type() == V_PRIM && send == true)
              {
!                 sending = true;
!                 next_send = Date::now() + send_period;
              }
          }
          else
          {
              // log_debug << "received message: " << um.get_to_seq();
!             fail_unless(rb.get_len() - rb.get_offset() == 16);
!             if (um.get_source() == tp->get_uuid())
              {
!                 fail_unless(um.get_user_type() == my_type);
              }
          }
      }
  
!     Protostack& get_pstack() { return tp->get_pstack(); }
  
      Date handle_timers()
      {
          Date now(Date::now());
!         if (now >= next_send)
          {
              byte_t buf[16];
              memset(buf, 0xa, sizeof(buf));
              Datagram dg(Buffer(buf, buf + sizeof(buf)));
              // dg.get_header().resize(128);
              // dg.set_header_offset(128);
!             int ret = send_down(dg, ProtoDownMeta(my_type, rand() % 10 == 0 ? O_SAFE : O_LOCAL_CAUSAL));
              if (ret != 0)
              {
                  // log_debug << "send down " << ret;
              }
!             next_send = next_send + send_period;
          }
!         return next_send;
      }
  
!     std::string get_listen_addr() const
      {
!         return tp->get_listen_addr();
      }
  
  };
--- 1219,1268 ----
  
          if (um.has_view())
          {
!             const View& view(um.view());
              log_info << view;
!             if (view.type() == V_PRIM && send_ == true)
              {
!                 sending_ = true;
!                 next_send_ = Date::now() + send_period_;
              }
          }
          else
          {
              // log_debug << "received message: " << um.get_to_seq();
!             fail_unless(rb.len() - rb.offset() == 16);
!             if (um.source() == tp_->uuid())
              {
!                 fail_unless(um.user_type() == my_type_);
              }
          }
      }
  
!     Protostack& pstack() { return tp_->pstack(); }
  
      Date handle_timers()
      {
          Date now(Date::now());
!         if (now >= next_send_)
          {
              byte_t buf[16];
              memset(buf, 0xa, sizeof(buf));
              Datagram dg(Buffer(buf, buf + sizeof(buf)));
              // dg.get_header().resize(128);
              // dg.set_header_offset(128);
!             int ret = send_down(dg, ProtoDownMeta(my_type_, rand() % 10 == 0 ? O_SAFE : O_LOCAL_CAUSAL));
              if (ret != 0)
              {
                  // log_debug << "send down " << ret;
              }
!             next_send_ = next_send_ + send_period_;
          }
!         return next_send_;
      }
  
!     std::string listen_addr() const
      {
!         return tp_->listen_addr();
      }
  
  };
***************
*** 1280,1286 ****
  
      PCUser2 pu2(*net,
                  std::string("pc://")
!                 + pu1.get_listen_addr().erase(0, strlen("tcp://"))
                  + "?evs.info_log_mask=0xff&"
                  "gmcast.group=pc&"
                  "gmcast.time_wait=PT0.5S&"
--- 1287,1293 ----
  
      PCUser2 pu2(*net,
                  std::string("pc://")
!                 + pu1.listen_addr().erase(0, strlen("tcp://"))
                  + "?evs.info_log_mask=0xff&"
                  "gmcast.group=pc&"
                  "gmcast.time_wait=PT0.5S&"
***************
*** 1288,1294 ****
                  "node.name=n2");
      PCUser2 pu3(*net,
                  std::string("pc://")
!                 + pu1.get_listen_addr().erase(0, strlen("tcp://"))
                  + "?evs.info_log_mask=0xff&"
                  "gmcast.group=pc&"
                  "gmcast.time_wait=PT0.5S&"
--- 1295,1301 ----
                  "node.name=n2");
      PCUser2 pu3(*net,
                  std::string("pc://")
!                 + pu1.listen_addr().erase(0, strlen("tcp://"))
                  + "?evs.info_log_mask=0xff&"
                  "gmcast.group=pc&"
                  "gmcast.time_wait=PT0.5S&"
***************
*** 1338,1353 ****
  
      p.handle_view(r5);
  
!     Datagram* dg = tp.get_out();
      fail_unless(dg != 0);
      Message sm4;
      get_msg(dg, &sm4);
!     fail_unless(sm4.get_type() == Message::T_STATE);
  
      // Handle first sm from uuid3
  
      StateMessage sm3(0);
!     pc::NodeMap& im3(sm3.get_node_map());
      im3.insert_unique(make_pair(uuid1,
                                  pc::Node(true, 254, ViewId(V_PRIM, uuid1, 3), 20)));
      im3.insert_unique(make_pair(uuid2,
--- 1345,1360 ----
  
      p.handle_view(r5);
  
!     Datagram* dg = tp.out();
      fail_unless(dg != 0);
      Message sm4;
      get_msg(dg, &sm4);
!     fail_unless(sm4.type() == Message::T_STATE);
  
      // Handle first sm from uuid3
  
      StateMessage sm3(0);
!     pc::NodeMap& im3(sm3.node_map());
      im3.insert_unique(make_pair(uuid1,
                                  pc::Node(true, 254, ViewId(V_PRIM, uuid1, 3), 20)));
      im3.insert_unique(make_pair(uuid2,
***************
*** 1374,1383 ****
              gcomm::connect(&tp_, &p_);
              gcomm::connect(&p_, this);
          }
!         const UUID& uuid() const { return p_.get_uuid(); }
          gcomm::pc::Proto& p() { return p_; }
          DummyTransport& tp() { return tp_; }
!         void handle_up(const void* id, const gu::Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
              // void
--- 1381,1390 ----
              gcomm::connect(&tp_, &p_);
              gcomm::connect(&p_, this);
          }
!         const UUID& uuid() const { return p_.uuid(); }
          gcomm::pc::Proto& p() { return p_; }
          DummyTransport& tp() { return tp_; }
!         void handle_up(const void* id, const Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
              // void
***************
*** 1394,1483 ****
      // boot to first prim
      {
          gcomm::View tr(ViewId(V_TRANS, n1.uuid(), 0));
!         tr.get_members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().connect(true);
          n1.p().handle_view(tr);
!         Datagram* dg(n1.tp().get_out());
!         fail_unless(dg == 0 && n1.p().get_state() == gcomm::pc::Proto::S_TRANS);
          gcomm::View reg(ViewId(V_REG, n1.uuid(), 1));
!         reg.get_members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().handle_view(reg);
!         dg = n1.tp().get_out();
          fail_unless(dg != 0 &&
!                     n1.p().get_state() == gcomm::pc::Proto::S_STATES_EXCH);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
!         dg = n1.tp().get_out();
          fail_unless(dg != 0 &&
!                     n1.p().get_state() == gcomm::pc::Proto::S_INSTALL);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
!         dg = n1.tp().get_out();
!         fail_unless(dg == 0 && n1.p().get_state() == gcomm::pc::Proto::S_PRIM);
      }
  
      // add remaining nodes
      {
          gcomm::View tr(ViewId(V_TRANS, n1.uuid(), 1));
!         tr.get_members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().handle_view(tr);
      }
      {
          gcomm::View tr(ViewId(V_TRANS, n2.uuid(), 0));
!         tr.get_members().insert_unique(std::make_pair(n2.uuid(), ""));
          n2.p().connect(false);
          n2.p().handle_view(tr);
      }
      {
          gcomm::View tr(ViewId(V_TRANS, n3.uuid(), 0));
!         tr.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().connect(false);
          n3.p().handle_view(tr);
      }
  
      {
          gcomm::View reg(ViewId(V_REG, n1.uuid(), 2));
!         reg.get_members().insert_unique(std::make_pair(n1.uuid(), ""));
!         reg.get_members().insert_unique(std::make_pair(n2.uuid(), ""));
!         reg.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
          n1.p().handle_view(reg);
          n2.p().handle_view(reg);
          n3.p().handle_view(reg);
  
!         gu::Datagram* dg(n1.tp().get_out());
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
  
!         dg = n2.tp().get_out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          delete dg;
  
!         dg = n3.tp().get_out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          delete dg;
  
!         dg = n1.tp().get_out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
  
!         fail_unless(n1.tp().get_out() == 0 &&
!                     n1.p().get_state() == gcomm::pc::Proto::S_PRIM);
!         fail_unless(n2.tp().get_out() == 0 &&
!                     n2.p().get_state() == gcomm::pc::Proto::S_PRIM);
!         fail_unless(n3.tp().get_out() == 0 &&
!                     n3.p().get_state() == gcomm::pc::Proto::S_PRIM);
      }
  
      mark_point();
--- 1401,1490 ----
      // boot to first prim
      {
          gcomm::View tr(ViewId(V_TRANS, n1.uuid(), 0));
!         tr.members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().connect(true);
          n1.p().handle_view(tr);
!         Datagram* dg(n1.tp().out());
!         fail_unless(dg == 0 && n1.p().state() == gcomm::pc::Proto::S_TRANS);
          gcomm::View reg(ViewId(V_REG, n1.uuid(), 1));
!         reg.members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().handle_view(reg);
!         dg = n1.tp().out();
          fail_unless(dg != 0 &&
!                     n1.p().state() == gcomm::pc::Proto::S_STATES_EXCH);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
!         dg = n1.tp().out();
          fail_unless(dg != 0 &&
!                     n1.p().state() == gcomm::pc::Proto::S_INSTALL);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
!         dg = n1.tp().out();
!         fail_unless(dg == 0 && n1.p().state() == gcomm::pc::Proto::S_PRIM);
      }
  
      // add remaining nodes
      {
          gcomm::View tr(ViewId(V_TRANS, n1.uuid(), 1));
!         tr.members().insert_unique(std::make_pair(n1.uuid(), ""));
          n1.p().handle_view(tr);
      }
      {
          gcomm::View tr(ViewId(V_TRANS, n2.uuid(), 0));
!         tr.members().insert_unique(std::make_pair(n2.uuid(), ""));
          n2.p().connect(false);
          n2.p().handle_view(tr);
      }
      {
          gcomm::View tr(ViewId(V_TRANS, n3.uuid(), 0));
!         tr.members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().connect(false);
          n3.p().handle_view(tr);
      }
  
      {
          gcomm::View reg(ViewId(V_REG, n1.uuid(), 2));
!         reg.members().insert_unique(std::make_pair(n1.uuid(), ""));
!         reg.members().insert_unique(std::make_pair(n2.uuid(), ""));
!         reg.members().insert_unique(std::make_pair(n3.uuid(), ""));
          n1.p().handle_view(reg);
          n2.p().handle_view(reg);
          n3.p().handle_view(reg);
  
!         Datagram* dg(n1.tp().out());
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
  
!         dg = n2.tp().out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          delete dg;
  
!         dg = n3.tp().out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          delete dg;
  
!         dg = n1.tp().out();
          fail_unless(dg != 0);
          n1.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n1.uuid()));
          delete dg;
  
!         fail_unless(n1.tp().out() == 0 &&
!                     n1.p().state() == gcomm::pc::Proto::S_PRIM);
!         fail_unless(n2.tp().out() == 0 &&
!                     n2.p().state() == gcomm::pc::Proto::S_PRIM);
!         fail_unless(n3.tp().out() == 0 &&
!                     n3.p().state() == gcomm::pc::Proto::S_PRIM);
      }
  
      mark_point();
***************
*** 1485,1509 ****
      // the following reg view
      {
          gcomm::View tr(gcomm::ViewId(V_TRANS, n1.uuid(), 2));
!         tr.get_members().insert_unique(std::make_pair(n2.uuid(), ""));
!         tr.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
  
          n2.p().handle_view(tr);
          n3.p().handle_view(tr);
  
          gcomm::View reg(gcomm::ViewId(V_REG, n2.uuid(), 3));
!         reg.get_members().insert_unique(std::make_pair(n2.uuid(), ""));
!         reg.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
          n2.p().handle_view(reg);
          n3.p().handle_view(reg);
  
  
!         gu::Datagram* dg(n2.tp().get_out());
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          delete dg;
  
!         dg = n3.tp().get_out();
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          delete dg;
--- 1492,1516 ----
      // the following reg view
      {
          gcomm::View tr(gcomm::ViewId(V_TRANS, n1.uuid(), 2));
!         tr.members().insert_unique(std::make_pair(n2.uuid(), ""));
!         tr.members().insert_unique(std::make_pair(n3.uuid(), ""));
  
          n2.p().handle_view(tr);
          n3.p().handle_view(tr);
  
          gcomm::View reg(gcomm::ViewId(V_REG, n2.uuid(), 3));
!         reg.members().insert_unique(std::make_pair(n2.uuid(), ""));
!         reg.members().insert_unique(std::make_pair(n3.uuid(), ""));
          n2.p().handle_view(reg);
          n3.p().handle_view(reg);
  
  
!         Datagram* dg(n2.tp().out());
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n2.uuid()));
          delete dg;
  
!         dg = n3.tp().out();
          n2.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          n3.p().handle_up(0, *dg, gcomm::ProtoUpMeta(n3.uuid()));
          delete dg;
***************
*** 1513,1536 ****
      // drop n2 from view and make sure that n3 ends in non-prim
      {
          gcomm::View tr(gcomm::ViewId(V_TRANS, n2.uuid(), 3));
!         tr.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().handle_view(tr);
!         fail_unless(n3.tp().get_out() == 0 &&
!                     n3.p().get_state() == gcomm::pc::Proto::S_TRANS);
  
          gcomm::View reg(gcomm::ViewId(V_REG, n3.uuid(), 4));
!         reg.get_members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().handle_view(reg);
  
!         fail_unless(n3.p().get_state() == gcomm::pc::Proto::S_STATES_EXCH);
  
!         gu::Datagram* dg(n3.tp().get_out());
          fail_unless(dg != 0);
          n3.p().handle_up(0, *dg, ProtoUpMeta(n3.uuid()));
!         dg = n3.tp().get_out();
          fail_unless(dg == 0 &&
!                     n3.p().get_state() == gcomm::pc::Proto::S_NON_PRIM,
!                     "%p %d", dg, n3.p().get_state());
      }
  
  }
--- 1520,1543 ----
      // drop n2 from view and make sure that n3 ends in non-prim
      {
          gcomm::View tr(gcomm::ViewId(V_TRANS, n2.uuid(), 3));
!         tr.members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().handle_view(tr);
!         fail_unless(n3.tp().out() == 0 &&
!                     n3.p().state() == gcomm::pc::Proto::S_TRANS);
  
          gcomm::View reg(gcomm::ViewId(V_REG, n3.uuid(), 4));
!         reg.members().insert_unique(std::make_pair(n3.uuid(), ""));
          n3.p().handle_view(reg);
  
!         fail_unless(n3.p().state() == gcomm::pc::Proto::S_STATES_EXCH);
  
!         Datagram* dg(n3.tp().out());
          fail_unless(dg != 0);
          n3.p().handle_up(0, *dg, ProtoUpMeta(n3.uuid()));
!         dg = n3.tp().out();
          fail_unless(dg == 0 &&
!                     n3.p().state() == gcomm::pc::Proto::S_NON_PRIM,
!                     "%p %d", dg, n3.p().state());
      }
  
  }
***************
*** 1548,1559 ****
      PCUser pu1(conf, uuid1, &tp1, &pc1);
      single_boot(&pu1);
  
!     assert(pc1.get_state() == Proto::S_PRIM);
      pu1.send();
      pu1.send();
!     Datagram* dg1(tp1.get_out());
      fail_unless(dg1 != 0);
!     Datagram* dg2(tp1.get_out());
      fail_unless(dg2 != 0);
  
      try
--- 1555,1566 ----
      PCUser pu1(conf, uuid1, &tp1, &pc1);
      single_boot(&pu1);
  
!     assert(pc1.state() == Proto::S_PRIM);
      pu1.send();
      pu1.send();
!     Datagram* dg1(tp1.out());
      fail_unless(dg1 != 0);
!     Datagram* dg2(tp1.out());
      fail_unless(dg2 != 0);
  
      try
***************
*** 1581,1599 ****
      PCUser pu1(conf, uuid1, &tp1, &pc1);
      single_boot(&pu1);
  
!     assert(pc1.get_state() == Proto::S_PRIM);
      pu1.send();
!     Datagram* dg(tp1.get_out());
      fail_unless(dg != 0);
      dg->normalize();
      pc1.handle_up(0, *dg, ProtoUpMeta(uuid1));
      delete dg;
  
      pu1.send();
!     dg = tp1.get_out();
      fail_unless(dg != 0);
      dg->normalize();
!     *(&dg->get_payload()[0] + dg->get_payload().size() - 1) ^= 0x10;
      try
      {
          pc1.handle_up(0, *dg, ProtoUpMeta(uuid1));
--- 1588,1606 ----
      PCUser pu1(conf, uuid1, &tp1, &pc1);
      single_boot(&pu1);
  
!     assert(pc1.state() == Proto::S_PRIM);
      pu1.send();
!     Datagram* dg(tp1.out());
      fail_unless(dg != 0);
      dg->normalize();
      pc1.handle_up(0, *dg, ProtoUpMeta(uuid1));
      delete dg;
  
      pu1.send();
!     dg = tp1.out();
      fail_unless(dg != 0);
      dg->normalize();
!     *(&dg->payload()[0] + dg->payload().size() - 1) ^= 0x10;
      try
      {
          pc1.handle_up(0, *dg, ProtoUpMeta(uuid1));
***************
*** 1672,1678 ****
      {
      public:
          D(gu::Config& conf) : gcomm::Toplay(conf) { }
!         void handle_up(const void* id, const gu::Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
  
--- 1679,1685 ----
      {
      public:
          D(gu::Config& conf) : gcomm::Toplay(conf) { }
!         void handle_up(const void* id, const Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
  
***************
*** 1688,1704 ****
                                   "pc://?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0"));
      gcomm::connect(tp.get(), &d);
      gu::Buffer buf(10);
!     gu::Datagram dg(buf);
      int err;
      err = tp->send_down(dg, gcomm::ProtoDownMeta());
      fail_unless(err == ENOTCONN, "%d", err);
      tp->connect();
!     buf.resize(tp->get_mtu());
!     gu::Datagram dg2(buf);
      err = tp->send_down(dg2, gcomm::ProtoDownMeta());
      fail_unless(err == 0, "%d", err);
      buf.resize(buf.size() + 1);
!     gu::Datagram dg3(buf);
      err = tp->send_down(dg3, gcomm::ProtoDownMeta());
      fail_unless(err == EMSGSIZE, "%d", err);
      pnet->event_loop(gu::datetime::Sec);
--- 1695,1711 ----
                                   "pc://?gmcast.group=test&gmcast.listen_addr=tcp://127.0.0.1:0"));
      gcomm::connect(tp.get(), &d);
      gu::Buffer buf(10);
!     Datagram dg(buf);
      int err;
      err = tp->send_down(dg, gcomm::ProtoDownMeta());
      fail_unless(err == ENOTCONN, "%d", err);
      tp->connect();
!     buf.resize(tp->mtu());
!     Datagram dg2(buf);
      err = tp->send_down(dg2, gcomm::ProtoDownMeta());
      fail_unless(err == 0, "%d", err);
      buf.resize(buf.size() + 1);
!     Datagram dg3(buf);
      err = tp->send_down(dg3, gcomm::ProtoDownMeta());
      fail_unless(err == EMSGSIZE, "%d", err);
      pnet->event_loop(gu::datetime::Sec);
***************
*** 1721,1727 ****
      {
      public:
          D(gu::Config& conf) : gcomm::Toplay(conf) { }
!         void handle_up(const void* id, const gu::Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
  
--- 1728,1734 ----
      {
      public:
          D(gu::Config& conf) : gcomm::Toplay(conf) { }
!         void handle_up(const void* id, const Datagram& dg,
                         const gcomm::ProtoUpMeta& um)
          {
  
***************
*** 1846,1851 ****
--- 1853,1889 ----
  }
  END_TEST
  
+ START_TEST(test_weighted_quorum)
+ {
+     log_info << "START (test_weighted_quorum)";
+     size_t n_nodes(3);
+     vector<DummyNode*> dn;
+     PropagationMatrix prop;
+     const string inactive_timeout("PT0.7S");
+     const string retrans_period("PT0.1S");
+     uint32_t view_seq = 0;
+ 
+     for (size_t i = 0; i < n_nodes; ++i)
+     {
+         dn.push_back(create_dummy_node(i + 1, inactive_timeout,
+                                        retrans_period, i));
+         gu_trace(join_node(&prop, dn[i], i == 0));
+         set_cvi(dn, 0, i, ++view_seq, V_PRIM);
+         gu_trace(prop.propagate_until_cvi(false));
+     }
+ 
+     // split node 3 (weight 2) out, node 3 should remain in prim while
+     // nodes 1 and 2 (weights 0 + 1 = 1) should end up in non-prim
+     prop.split(1, 3);
+     prop.split(2, 3);
+     ++view_seq;
+     set_cvi(dn, 0, 1, view_seq, V_NON_PRIM);
+     set_cvi(dn, 2, 2, view_seq, V_PRIM);
+     gu_trace(prop.propagate_until_cvi(true));
+ }
+ END_TEST
+ 
+ 
  
  Suite* pc_suite()
  {
***************
*** 1944,1948 ****
--- 1982,1991 ----
      tcase_add_test(tc, test_trac_622_638);
      suite_add_tcase(s, tc);
  
+     tc = tcase_create("test_weighted_quorum");
+     tcase_add_test(tc, test_weighted_quorum);
+     suite_add_tcase(s, tc);
+ 
+ 
      return s;
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_templ.hpp 2.x/gcomm/test/check_templ.hpp
*** galera-23.2.2-src/gcomm/test/check_templ.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_templ.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 15,28 ****
  namespace gcomm
  {
  
!     
      template<class T>
!     void check_serialization(const T& c, const size_t expected_size, 
                               const T& default_c)
      {
!         
!         fail_unless(c.serial_size() == expected_size, 
!                     "size = %lu expected = %lu", 
                      c.serial_size(), expected_size);
          gu::byte_t* buf = new gu::byte_t[expected_size + 7];
          size_t ret;
--- 15,28 ----
  namespace gcomm
  {
  
! 
      template<class T>
!     void check_serialization(const T& c, const size_t expected_size,
                               const T& default_c)
      {
! 
!         fail_unless(c.serial_size() == expected_size,
!                     "size = %lu expected = %lu",
                      c.serial_size(), expected_size);
          gu::byte_t* buf = new gu::byte_t[expected_size + 7];
          size_t ret;
***************
*** 37,43 ****
              // OK
          }
          fail_unless(c.serialize(buf, expected_size, 0) == expected_size);
!     
          T c2(default_c);
  
          try
--- 37,43 ----
              // OK
          }
          fail_unless(c.serialize(buf, expected_size, 0) == expected_size);
! 
          T c2(default_c);
  
          try
***************
*** 56,67 ****
              log_warn << "\n\t" << c << " !=\n\t" << c2;
          }
          fail_unless(c == c2);
!     
          // Check that read/write return offset properly
!     
          fail_unless(c.serialize(buf, expected_size + 7, 5) == expected_size + 5);
          fail_unless(c2.unserialize(buf, expected_size + 7, 5) == expected_size + 5);
!     
          fail_unless(c == c2);
  
          delete[] buf;
--- 56,67 ----
              log_warn << "\n\t" << c << " !=\n\t" << c2;
          }
          fail_unless(c == c2);
! 
          // Check that read/write return offset properly
! 
          fail_unless(c.serialize(buf, expected_size + 7, 5) == expected_size + 5);
          fail_unless(c2.unserialize(buf, expected_size + 7, 5) == expected_size + 5);
! 
          fail_unless(c == c2);
  
          delete[] buf;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_trace.cpp 2.x/gcomm/test/check_trace.cpp
*** galera-23.2.2-src/gcomm/test/check_trace.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_trace.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 18,30 ****
  
  ostream& gcomm::operator<<(ostream& os, const TraceMsg& msg)
  {
!     return (os << "(" << msg.get_source() << "," << msg.get_source_view_id() << "," << msg.get_seq() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const ViewTrace& vtr)
  {
!     os << vtr.get_view() << ": ";
!     copy(vtr.get_msgs().begin(), vtr.get_msgs().end(),
           ostream_iterator<const TraceMsg>(os, " "));
      return os;
  }
--- 18,30 ----
  
  ostream& gcomm::operator<<(ostream& os, const TraceMsg& msg)
  {
!     return (os << "(" << msg.source() << "," << msg.source_view_id() << "," << msg.seq() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const ViewTrace& vtr)
  {
!     os << vtr.view() << ": ";
!     copy(vtr.msgs().begin(), vtr.msgs().end(),
           ostream_iterator<const TraceMsg>(os, " "));
      return os;
  }
***************
*** 32,44 ****
  ostream& gcomm::operator<<(ostream& os, const Trace& tr)
  {
      os << "trace: \n";
!     os << tr.get_view_traces();
      return os;
  }
  
  ostream& gcomm::operator<<(ostream& os, const Channel& ch)
  {
!     return (os << "(" << ch.get_latency() << "," << ch.get_loss() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const Channel* chp)
--- 32,44 ----
  ostream& gcomm::operator<<(ostream& os, const Trace& tr)
  {
      os << "trace: \n";
!     os << tr.view_traces();
      return os;
  }
  
  ostream& gcomm::operator<<(ostream& os, const Channel& ch)
  {
!     return (os << "(" << ch.latency() << "," << ch.loss() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const Channel* chp)
***************
*** 48,60 ****
  
  ostream& gcomm::operator<<(ostream& os, const MatrixElem& me)
  {
!     return (os << "(" << me.get_ii() << "," << me.get_jj() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const PropagationMatrix& prop)
  {
      os << "(";
!     copy(prop.prop.begin(), prop.prop.end(),
           ostream_iterator<const ChannelMap::value_type>(os, ","));
      os << ")";
      return os;
--- 48,60 ----
  
  ostream& gcomm::operator<<(ostream& os, const MatrixElem& me)
  {
!     return (os << "(" << me.ii() << "," << me.jj() << ")");
  }
  
  ostream& gcomm::operator<<(ostream& os, const PropagationMatrix& prop)
  {
      os << "(";
!     copy(prop.prop_.begin(), prop.prop_.end(),
           ostream_iterator<const ChannelMap::value_type>(os, ","));
      os << ")";
      return os;
***************
*** 65,94 ****
  class LinkOp
  {
  public:
!     LinkOp(DummyNode& node_, ChannelMap& prop_) :
!         node(node_), prop(prop_) { }
  
      void operator()(NodeMap::value_type& l)
      {
!         if (NodeMap::get_key(l) != node.get_index())
          {
              ChannelMap::iterator ii;
!             gu_trace(ii = prop.insert_unique(
!                          make_pair(MatrixElem(node.get_index(),
!                                               NodeMap::get_key(l)),
                                     new Channel(check_trace_conf))));
!             gcomm::connect(ChannelMap::get_value(ii), node.get_protos().front());
!             gu_trace(ii = prop.insert_unique(
!                          make_pair(MatrixElem(NodeMap::get_key(l),
!                                               node.get_index()),
                                     new Channel(check_trace_conf))));
!             gcomm::connect(ChannelMap::get_value(ii),
!                            NodeMap::get_value(l)->get_protos().front());
          }
      }
  private:
!     DummyNode& node;
!     ChannelMap& prop;
  };
  
  
--- 65,94 ----
  class LinkOp
  {
  public:
!     LinkOp(DummyNode& node, ChannelMap& prop) :
!         node_(node), prop_(prop) { }
  
      void operator()(NodeMap::value_type& l)
      {
!         if (NodeMap::key(l) != node_.index())
          {
              ChannelMap::iterator ii;
!             gu_trace(ii = prop_.insert_unique(
!                          make_pair(MatrixElem(node_.index(),
!                                               NodeMap::key(l)),
                                     new Channel(check_trace_conf))));
!             gcomm::connect(ChannelMap::value(ii), node_.protos().front());
!             gu_trace(ii = prop_.insert_unique(
!                          make_pair(MatrixElem(NodeMap::key(l),
!                                               node_.index()),
                                     new Channel(check_trace_conf))));
!             gcomm::connect(ChannelMap::value(ii),
!                            NodeMap::value(l)->protos().front());
          }
      }
  private:
!     DummyNode& node_;
!     ChannelMap& prop_;
  };
  
  
***************
*** 96,117 ****
  class PropagateOp
  {
  public:
!     PropagateOp(NodeMap& tp_) : tp(tp_) { }
  
      void operator()(ChannelMap::value_type& vt)
      {
          ChannelMsg cmsg(vt.second->get());
!         if (cmsg.get_rb().get_len() != 0)
          {
!             NodeMap::iterator i(tp.find(vt.first.get_jj()));
!             gcomm_assert(i != tp.end());
!             gu_trace(NodeMap::get_value(i)->get_protos().front()->handle_up(
!                          &tp, cmsg.get_rb(),
!                          ProtoUpMeta(cmsg.get_source())));
          }
      }
  private:
!     NodeMap& tp;
  };
  
  
--- 96,117 ----
  class PropagateOp
  {
  public:
!     PropagateOp(NodeMap& tp) : tp_(tp) { }
  
      void operator()(ChannelMap::value_type& vt)
      {
          ChannelMsg cmsg(vt.second->get());
!         if (cmsg.rb().len() != 0)
          {
!             NodeMap::iterator i(tp_.find(vt.first.jj()));
!             gcomm_assert(i != tp_.end());
!             gu_trace(NodeMap::value(i)->protos().front()->handle_up(
!                          &tp_, cmsg.rb(),
!                          ProtoUpMeta(cmsg.source())));
          }
      }
  private:
!     NodeMap& tp_;
  };
  
  
***************
*** 121,127 ****
      ExpireTimersOp() { }
      void operator()(NodeMap::value_type& vt)
      {
!         NodeMap::get_value(vt)->handle_timers();
      }
  };
  
--- 121,127 ----
      ExpireTimersOp() { }
      void operator()(NodeMap::value_type& vt)
      {
!         NodeMap::value(vt)->handle_timers();
      }
  };
  
***************
*** 132,159 ****
      //  {
      //   dg.normalize();
      // }
!     queue.push_back(make_pair(latency, ChannelMsg(dg, source)));
  }
  
  ChannelMsg gcomm::Channel::get()
  {
!     while (queue.empty() == false)
      {
!         pair<size_t, ChannelMsg>& p(queue.front());
          if (p.first == 0)
          {
              // todo: packet loss goes here
!             if (get_loss() < 1.)
              {
                  double rnd(double(rand())/double(RAND_MAX));
!                 if (get_loss() < rnd)
                  {
!                     queue.pop_front();
                      return ChannelMsg(Datagram(), UUID::nil());
                  }
              }
              ChannelMsg ret(p.second);
!             queue.pop_front();
              return ret;
          }
          else
--- 132,159 ----
      //  {
      //   dg.normalize();
      // }
!     queue_.push_back(make_pair(latency_, ChannelMsg(dg, source)));
  }
  
  ChannelMsg gcomm::Channel::get()
  {
!     while (queue_.empty() == false)
      {
!         pair<size_t, ChannelMsg>& p(queue_.front());
          if (p.first == 0)
          {
              // todo: packet loss goes here
!             if (loss() < 1.)
              {
                  double rnd(double(rand())/double(RAND_MAX));
!                 if (loss() < rnd)
                  {
!                     queue_.pop_front();
                      return ChannelMsg(Datagram(), UUID::nil());
                  }
              }
              ChannelMsg ret(p.second);
!             queue_.pop_front();
              return ret;
          }
          else
***************
*** 167,179 ****
  
  gcomm::PropagationMatrix::~PropagationMatrix()
  {
!     for_each(prop.begin(), prop.end(), ChannelMap::DeleteObject());
  }
  
  void gcomm::PropagationMatrix::insert_tp(DummyNode* t)
  {
!     gu_trace(tp.insert_unique(make_pair(t->get_index(), t)));
!     for_each(tp.begin(), tp.end(), LinkOp(*t, prop));
  }
  
  
--- 167,179 ----
  
  gcomm::PropagationMatrix::~PropagationMatrix()
  {
!     for_each(prop_.begin(), prop_.end(), ChannelMap::DeleteObject());
  }
  
  void gcomm::PropagationMatrix::insert_tp(DummyNode* t)
  {
!     gu_trace(tp_.insert_unique(make_pair(t->index(), t)));
!     for_each(tp_.begin(), tp_.end(), LinkOp(*t, prop_));
  }
  
  
***************
*** 181,188 ****
                                             const size_t lat)
  {
      ChannelMap::iterator i;
!     gu_trace(i = prop.find_checked(MatrixElem(ii, jj)));
!     ChannelMap::get_value(i)->set_latency(lat);
  }
  
  
--- 181,188 ----
                                             const size_t lat)
  {
      ChannelMap::iterator i;
!     gu_trace(i = prop_.find_checked(MatrixElem(ii, jj)));
!     ChannelMap::value(i)->set_latency(lat);
  }
  
  
***************
*** 190,197 ****
                                          const double loss)
  {
      ChannelMap::iterator i;
!     gu_trace(i = prop.find_checked(MatrixElem(ii, jj)));
!     ChannelMap::get_value(i)->set_loss(loss);
  }
  
  
--- 190,197 ----
                                          const double loss)
  {
      ChannelMap::iterator i;
!     gu_trace(i = prop_.find_checked(MatrixElem(ii, jj)));
!     ChannelMap::value(i)->set_loss(loss);
  }
  
  
***************
*** 211,217 ****
  
  void gcomm::PropagationMatrix::expire_timers()
  {
!     for_each(tp.begin(), tp.end(), ExpireTimersOp());
  }
  
  
--- 211,217 ----
  
  void gcomm::PropagationMatrix::expire_timers()
  {
!     for_each(tp_.begin(), tp_.end(), ExpireTimersOp());
  }
  
  
***************
*** 219,225 ****
  {
      while (n-- > 0)
      {
!         for_each(prop.begin(), prop.end(), PropagateOp(tp));
      }
  }
  
--- 219,225 ----
  {
      while (n-- > 0)
      {
!         for_each(prop_.begin(), prop_.end(), PropagateOp(tp_));
      }
  }
  
***************
*** 228,234 ****
  {
      do
      {
!         for_each(prop.begin(), prop.end(), PropagateOp(tp));
      }
      while (count_channel_msgs() > 0);
  }
--- 228,234 ----
  {
      do
      {
!         for_each(prop_.begin(), prop_.end(), PropagateOp(tp_));
      }
      while (count_channel_msgs() > 0);
  }
***************
*** 253,262 ****
  size_t gcomm::PropagationMatrix::count_channel_msgs() const
  {
      size_t ret = 0;
!     for (ChannelMap::const_iterator i = prop.begin();
!          i != prop.end(); ++i)
      {
!         ret += ChannelMap::get_value(i)->get_n_msgs();
      }
      return ret;
  }
--- 253,262 ----
  size_t gcomm::PropagationMatrix::count_channel_msgs() const
  {
      size_t ret = 0;
!     for (ChannelMap::const_iterator i = prop_.begin();
!          i != prop_.end(); ++i)
      {
!         ret += ChannelMap::value(i)->n_msgs();
      }
      return ret;
  }
***************
*** 264,271 ****
  
  bool gcomm::PropagationMatrix::all_in_cvi() const
  {
!     for (map<size_t, DummyNode*>::const_iterator i = tp.begin();
!          i != tp.end(); ++i)
      {
          if (i->second->in_cvi() == false)
          {
--- 264,271 ----
  
  bool gcomm::PropagationMatrix::all_in_cvi() const
  {
!     for (map<size_t, DummyNode*>::const_iterator i = tp_.begin();
!          i != tp_.end(); ++i)
      {
          if (i->second->in_cvi() == false)
          {
***************
*** 280,307 ****
  static void check_traces(const Trace& t1, const Trace& t2)
  {
      for (Trace::ViewTraceMap::const_iterator
!              i = t1.get_view_traces().begin(); i != t1.get_view_traces().end();
           ++i)
      {
          Trace::ViewTraceMap::const_iterator i_next(i);
          ++i_next;
!         if (i_next != t1.get_view_traces().end())
          {
              const Trace::ViewTraceMap::const_iterator
!                 j(t2.get_view_traces().find(Trace::ViewTraceMap::get_key(i)));
              Trace::ViewTraceMap::const_iterator j_next(j);
              ++j_next;
              // Note: Comparision is meaningful if also next view is the
              //       same.
              // @todo Proper checks for PRIM and NON_PRIM
!             if (j             != t2.get_view_traces().end() &&
!                 j_next        != t2.get_view_traces().end() &&
                  i_next->first == j_next->first              &&
!                 i_next->second.get_view().get_members() ==
!                 j_next->second.get_view().get_members())
              {
!                 if (i->first.get_type() != V_NON_PRIM &&
!                     i->first.get_type() != V_PRIM)
                  {
                      gcomm_assert(*i == *j)
                          << "traces differ: \n\n" << *i << "\n\n" << *j << "\n\n"
--- 280,307 ----
  static void check_traces(const Trace& t1, const Trace& t2)
  {
      for (Trace::ViewTraceMap::const_iterator
!              i = t1.view_traces().begin(); i != t1.view_traces().end();
           ++i)
      {
          Trace::ViewTraceMap::const_iterator i_next(i);
          ++i_next;
!         if (i_next != t1.view_traces().end())
          {
              const Trace::ViewTraceMap::const_iterator
!                 j(t2.view_traces().find(Trace::ViewTraceMap::key(i)));
              Trace::ViewTraceMap::const_iterator j_next(j);
              ++j_next;
              // Note: Comparision is meaningful if also next view is the
              //       same.
              // @todo Proper checks for PRIM and NON_PRIM
!             if (j             != t2.view_traces().end() &&
!                 j_next        != t2.view_traces().end() &&
                  i_next->first == j_next->first              &&
!                 i_next->second.view().members() ==
!                 j_next->second.view().members())
              {
!                 if (i->first.type() != V_NON_PRIM &&
!                     i->first.type() != V_PRIM)
                  {
                      gcomm_assert(*i == *j)
                          << "traces differ: \n\n" << *i << "\n\n" << *j << "\n\n"
***************
*** 319,340 ****
  class CheckTraceOp
  {
  public:
!     CheckTraceOp(const vector<DummyNode*>& nvec_) : nvec(nvec_) { }
  
      void operator()(const DummyNode* n) const
      {
!         for (vector<DummyNode*>::const_iterator i = nvec.begin();
!              i != nvec.end();
               ++i)
          {
!             if ((*i)->get_index() != n->get_index())
              {
!                 gu_trace(check_traces((*i)->get_trace(), n->get_trace()));
              }
          }
      }
  private:
!     const vector<DummyNode*>& nvec;
  };
  
  
--- 319,340 ----
  class CheckTraceOp
  {
  public:
!     CheckTraceOp(const vector<DummyNode*>& nvec) : nvec_(nvec) { }
  
      void operator()(const DummyNode* n) const
      {
!         for (vector<DummyNode*>::const_iterator i = nvec_.begin();
!              i != nvec_.end();
               ++i)
          {
!             if ((*i)->index() != n->index())
              {
!                 gu_trace(check_traces((*i)->trace(), n->trace()));
              }
          }
      }
  private:
!     const vector<DummyNode*>& nvec_;
  };
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_trace.hpp 2.x/gcomm/test/check_trace.hpp
*** galera-23.2.2-src/gcomm/test/check_trace.hpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_trace.hpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 8,17 ****
   * Classes for tracing views and messages
   */
  
- #include "gu_datagram.hpp"
  #include "gu_uri.hpp"
  #include "gu_datetime.hpp"
  
  #include "gcomm/uuid.hpp"
  #include "gcomm/protolay.hpp"
  #include "gcomm/protostack.hpp"
--- 8,17 ----
   * Classes for tracing views and messages
   */
  
  #include "gu_uri.hpp"
  #include "gu_datetime.hpp"
  
+ #include "gcomm/datagram.hpp"
  #include "gcomm/uuid.hpp"
  #include "gcomm/protolay.hpp"
  #include "gcomm/protostack.hpp"
***************
*** 31,62 ****
      class TraceMsg
      {
      public:
!         TraceMsg(const UUID& source_           = UUID::nil(),
!                  const ViewId& source_view_id_ = ViewId(),
!                  const int64_t seq_            = -1) :
!             source(source_),
!             source_view_id(source_view_id_),
!             seq(seq_)
          { }
  
!         const UUID& get_source() const { return source; }
  
!         const ViewId& get_source_view_id() const { return source_view_id; }
  
!         int64_t get_seq() const { return seq; }
  
          bool operator==(const TraceMsg& cmp) const
          {
!             return (source         == cmp.source         &&
!                     source_view_id == cmp.source_view_id &&
!                     seq            == cmp.seq              );
  
          }
  
      private:
!         UUID    source;
!         ViewId  source_view_id;
!         int64_t seq;
      };
  
      std::ostream& operator<<(std::ostream& os, const TraceMsg& msg);
--- 31,62 ----
      class TraceMsg
      {
      public:
!         TraceMsg(const UUID& source           = UUID::nil(),
!                  const ViewId& source_view_id = ViewId(),
!                  const int64_t seq            = -1) :
!             source_(source),
!             source_view_id_(source_view_id),
!             seq_(seq)
          { }
  
!         const UUID& source() const { return source_; }
  
!         const ViewId& source_view_id() const { return source_view_id_; }
  
!         int64_t seq() const { return seq_; }
  
          bool operator==(const TraceMsg& cmp) const
          {
!             return (source_         == cmp.source_         &&
!                     source_view_id_ == cmp.source_view_id_ &&
!                     seq_            == cmp.seq_              );
  
          }
  
      private:
!         UUID    source_;
!         ViewId  source_view_id_;
!         int64_t seq_;
      };
  
      std::ostream& operator<<(std::ostream& os, const TraceMsg& msg);
***************
*** 64,131 ****
      class ViewTrace
      {
      public:
!         ViewTrace(const View& view_) : view(view_), msgs() { }
  
          void insert_msg(const TraceMsg& msg)
              throw (gu::Exception)
          {
!             switch (view.get_type())
              {
              case V_REG:
!                 gcomm_assert(view.get_id() == msg.get_source_view_id());
!                 gcomm_assert(contains(msg.get_source()) == true)
!                     << "msg source " << msg.get_source() << " not int view "
!                     << view;
                  break;
              case V_TRANS:
!                 gcomm_assert(view.get_id().get_uuid() ==
!                              msg.get_source_view_id().get_uuid() &&
!                              view.get_id().get_seq() ==
!                              msg.get_source_view_id().get_seq());
                  break;
              case V_NON_PRIM:
                  break;
              case V_PRIM:
!                 gcomm_assert(view.get_id() == msg.get_source_view_id())
!                     << " view id " << view.get_id()
!                     <<  " source view " << msg.get_source_view_id();
!                 gcomm_assert(contains(msg.get_source()) == true);
                  break;
              case V_NONE:
                  gu_throw_fatal;
                  break;
              }
  
!             if (view.get_type() != V_NON_PRIM)
              {
!                 msgs.push_back(msg);
              }
          }
  
!         const View& get_view() const { return view; }
  
!         const std::deque<TraceMsg>& get_msgs() const { return msgs; }
  
          bool operator==(const ViewTrace& cmp) const
          {
              // Note: Cannot compare joining members since seen differently
              // on different merging subsets
!             return (view.get_members()     == cmp.view.get_members()     &&
!                     view.get_left()        == cmp.view.get_left()        &&
!                     view.get_partitioned() == cmp.view.get_partitioned() &&
!                     msgs                   == cmp.msgs                     );
          }
      private:
  
          bool contains(const UUID& uuid) const
          {
!             return (view.get_members().find(uuid) != view.get_members().end() ||
!                     view.get_left().find(uuid)    != view.get_left().end() ||
!                     view.get_partitioned().find(uuid) != view.get_partitioned().end());
          }
  
!         View       view;
!         std::deque<TraceMsg> msgs;
      };
  
      std::ostream& operator<<(std::ostream& os, const ViewTrace& vtr);
--- 64,131 ----
      class ViewTrace
      {
      public:
!         ViewTrace(const View& view) : view_(view), msgs_() { }
  
          void insert_msg(const TraceMsg& msg)
              throw (gu::Exception)
          {
!             switch (view_.type())
              {
              case V_REG:
!                 gcomm_assert(view_.id() == msg.source_view_id());
!                 gcomm_assert(contains(msg.source()) == true)
!                     << "msg source " << msg.source() << " not int view "
!                     << view_;
                  break;
              case V_TRANS:
!                 gcomm_assert(view_.id().uuid() ==
!                              msg.source_view_id().uuid() &&
!                              view_.id().seq() ==
!                              msg.source_view_id().seq());
                  break;
              case V_NON_PRIM:
                  break;
              case V_PRIM:
!                 gcomm_assert(view_.id() == msg.source_view_id())
!                     << " view id " << view_.id()
!                     <<  " source view " << msg.source_view_id();
!                 gcomm_assert(contains(msg.source()) == true);
                  break;
              case V_NONE:
                  gu_throw_fatal;
                  break;
              }
  
!             if (view_.type() != V_NON_PRIM)
              {
!                 msgs_.push_back(msg);
              }
          }
  
!         const View& view() const { return view_; }
  
!         const std::deque<TraceMsg>& msgs() const { return msgs_; }
  
          bool operator==(const ViewTrace& cmp) const
          {
              // Note: Cannot compare joining members since seen differently
              // on different merging subsets
!             return (view_.members()     == cmp.view_.members()     &&
!                     view_.left()        == cmp.view_.left()        &&
!                     view_.partitioned() == cmp.view_.partitioned() &&
!                     msgs_              == cmp.msgs_                     );
          }
      private:
  
          bool contains(const UUID& uuid) const
          {
!             return (view_.members().find(uuid) != view_.members().end() ||
!                     view_.left().find(uuid)    != view_.left().end() ||
!                     view_.partitioned().find(uuid) != view_.partitioned().end());
          }
  
!         View       view_;
!         std::deque<TraceMsg> msgs_;
      };
  
      std::ostream& operator<<(std::ostream& os, const ViewTrace& vtr);
***************
*** 136,166 ****
      public:
          class ViewTraceMap : public Map<ViewId, ViewTrace> { };
  
!         Trace() : views(), current_view(views.end()) { }
  
          void insert_view(const View& view)
          {
!             gu_trace(current_view = views.insert_unique(
!                          std::make_pair(view.get_id(), ViewTrace(view))));
  
              log_debug << view;
          }
          void insert_msg(const TraceMsg& msg)
          {
!             gcomm_assert(current_view != views.end()) << "no view set before msg delivery";
!             gu_trace(ViewTraceMap::get_value(current_view).insert_msg(msg));
          }
!         const ViewTraceMap& get_view_traces() const { return views; }
  
!         const ViewTrace& get_current_view_trace() const
          {
!             gcomm_assert(current_view != views.end());
!             return ViewTraceMap::get_value(current_view);
          }
  
      private:
!         ViewTraceMap views;
!         ViewTraceMap::iterator current_view;
      };
  
  
--- 136,166 ----
      public:
          class ViewTraceMap : public Map<ViewId, ViewTrace> { };
  
!         Trace() : views_(), current_view_(views_.end()) { }
  
          void insert_view(const View& view)
          {
!             gu_trace(current_view_ = views_.insert_unique(
!                          std::make_pair(view.id(), ViewTrace(view))));
  
              log_debug << view;
          }
          void insert_msg(const TraceMsg& msg)
          {
!             gcomm_assert(current_view_ != views_.end()) << "no view set before msg delivery";
!             gu_trace(ViewTraceMap::value(current_view_).insert_msg(msg));
          }
!         const ViewTraceMap& view_traces() const { return views_; }
  
!         const ViewTrace& current_view_trace() const
          {
!             gcomm_assert(current_view_ != views_.end());
!             return ViewTraceMap::value(current_view_);
          }
  
      private:
!         ViewTraceMap views_;
!         ViewTraceMap::iterator current_view_;
      };
  
  
***************
*** 168,197 ****
  
      class DummyTransport : public Transport
      {
!         UUID uuid;
!         std::deque<gu::Datagram*> out;
!         bool queue;
      public:
!         DummyTransport(const UUID& uuid_ = UUID::nil(), bool queue_ = true,
                         const gu::URI& uri = gu::URI("dummy:")) :
              Transport(*std::auto_ptr<Protonet>(Protonet::create(check_trace_conf)),
                        uri),
!             uuid(uuid_),
!             out(),
!             queue(queue_)
          {}
  
          ~DummyTransport()
          {
!             out.clear();
          }
  
!         bool supports_uuid() const { return true; }
  
!         const UUID& get_uuid() const { return uuid; }
! 
! 
!         size_t get_mtu() const { return (1U << 31); }
  
          void connect(bool first) { }
  
--- 168,194 ----
  
      class DummyTransport : public Transport
      {
!         UUID uuid_;
!         std::deque<Datagram*> out_;
!         bool queue_;
      public:
!         DummyTransport(const UUID& uuid = UUID::nil(), bool queue = true,
                         const gu::URI& uri = gu::URI("dummy:")) :
              Transport(*std::auto_ptr<Protonet>(Protonet::create(check_trace_conf)),
                        uri),
!             uuid_(uuid),
!             out_(),
!             queue_(queue)
          {}
  
          ~DummyTransport()
          {
!             out_.clear();
          }
  
!         const UUID& uuid() const { return uuid_; }
  
!         size_t mtu() const { return (1U << 31); }
  
          void connect(bool first) { }
  
***************
*** 211,244 ****
              return 0;
          }
  
!         void handle_up(const void* cid, const gu::Datagram& rb,
                         const ProtoUpMeta& um)
          {
              send_up(rb, um);
          }
  
!         int handle_down(gu::Datagram& wb, const ProtoDownMeta& dm)
          {
!             if (queue == true)
              {
!                 // assert(wb.get_header().size() == 0);
!                 out.push_back(new gu::Datagram(wb));
                  return 0;
              }
              else
              {
!                 gu_trace(return send_down(wb, ProtoDownMeta(0xff, O_UNRELIABLE, uuid)));
              }
          }
  
!         gu::Datagram* get_out()
          {
!             if (out.empty())
              {
                  return 0;
              }
!             gu::Datagram* rb = out.front();
!             out.pop_front();
              return rb;
          }
      };
--- 208,241 ----
              return 0;
          }
  
!         void handle_up(const void* cid, const Datagram& rb,
                         const ProtoUpMeta& um)
          {
              send_up(rb, um);
          }
  
!         int handle_down(Datagram& wb, const ProtoDownMeta& dm)
          {
!             if (queue_ == true)
              {
!                 // assert(wb.header().size() == 0);
!                 out_.push_back(new Datagram(wb));
                  return 0;
              }
              else
              {
!                 gu_trace(return send_down(wb, ProtoDownMeta(0xff, O_UNRELIABLE, uuid_)));
              }
          }
  
!         Datagram* out()
          {
!             if (out_.empty())
              {
                  return 0;
              }
!             Datagram* rb = out_.front();
!             out_.pop_front();
              return rb;
          }
      };
***************
*** 248,267 ****
      {
      public:
          DummyNode(gu::Config& conf,
!                   const size_t index_,
!                   const std::list<Protolay*>& protos_) :
              Toplay (conf),
!             index  (index_),
!             uuid   (UUID(static_cast<int32_t>(index))),
!             protos (protos_),
!             cvi    (),
!             tr     (),
!             curr_seq(0)
          {
!             gcomm_assert(protos.empty() == false);
              std::list<Protolay*>::iterator i, i_next;
!             i = i_next = protos.begin();
!             for (++i_next; i_next != protos.end(); ++i, ++i_next)
              {
                  gu_trace(gcomm::connect(*i, *i_next));
              }
--- 245,264 ----
      {
      public:
          DummyNode(gu::Config& conf,
!                   const size_t index,
!                   const std::list<Protolay*>& protos) :
              Toplay (conf),
!             index_  (index),
!             uuid_   (UUID(static_cast<int32_t>(index))),
!             protos_ (protos),
!             cvi_    (),
!             tr_     (),
!             curr_seq_(0)
          {
!             gcomm_assert(protos_.empty() == false);
              std::list<Protolay*>::iterator i, i_next;
!             i = i_next = protos_.begin();
!             for (++i_next; i_next != protos_.end(); ++i, ++i_next)
              {
                  gu_trace(gcomm::connect(*i, *i_next));
              }
***************
*** 271,303 ****
          ~DummyNode()
          {
              std::list<Protolay*>::iterator i, i_next;
!             i = i_next = protos.begin();
!             for (++i_next; i_next != protos.end(); ++i, ++i_next)
              {
                  gu_trace(gcomm::disconnect(*i, *i_next));
              }
              gu_trace(gcomm::disconnect(*i, this));
!             std::for_each(protos.begin(), protos.end(), gu::DeleteObject());
          }
  
  
!         const UUID& get_uuid() const { return uuid; }
  
!         std::list<Protolay*>& get_protos() { return protos; }
  
!         size_t get_index() const { return index; }
  
          void connect(bool first)
          {
!             gu_trace(std::for_each(protos.rbegin(), protos.rend(),
                                     std::bind2nd(
                                         std::mem_fun(&Protolay::connect), first)));
          }
  
          void close()
          {
!             for (std::list<Protolay*>::iterator i = protos.begin();
!                  i != protos.end(); ++i)
              {
                  (*i)->close();
              }
--- 268,300 ----
          ~DummyNode()
          {
              std::list<Protolay*>::iterator i, i_next;
!             i = i_next = protos_.begin();
!             for (++i_next; i_next != protos_.end(); ++i, ++i_next)
              {
                  gu_trace(gcomm::disconnect(*i, *i_next));
              }
              gu_trace(gcomm::disconnect(*i, this));
!             std::for_each(protos_.begin(), protos_.end(), gu::DeleteObject());
          }
  
  
!         const UUID& uuid() const { return uuid_; }
  
!         std::list<Protolay*>& protos() { return protos_; }
  
!         size_t index() const { return index_; }
  
          void connect(bool first)
          {
!             gu_trace(std::for_each(protos_.rbegin(), protos_.rend(),
                                     std::bind2nd(
                                         std::mem_fun(&Protolay::connect), first)));
          }
  
          void close()
          {
!             for (std::list<Protolay*>::iterator i = protos_.begin();
!                  i != protos_.end(); ++i)
              {
                  (*i)->close();
              }
***************
*** 308,315 ****
  
          void close(const UUID& uuid)
          {
!             for (std::list<Protolay*>::iterator i = protos.begin();
!                  i != protos.end(); ++i)
              {
                  (*i)->close(uuid);
              }
--- 305,312 ----
  
          void close(const UUID& uuid)
          {
!             for (std::list<Protolay*>::iterator i = protos_.begin();
!                  i != protos_.end(); ++i)
              {
                  (*i)->close(uuid);
              }
***************
*** 319,329 ****
  
          void send()
          {
!             const int64_t seq(curr_seq);
              gu::byte_t buf[sizeof(seq)];
              size_t sz;
              gu_trace(sz = gu::serialize8(seq, buf, sizeof(buf), 0));
!             gu::Datagram dg(gu::Buffer(buf, buf + sz));
              int err = send_down(dg, ProtoDownMeta(0));
              if (err != 0)
              {
--- 316,326 ----
  
          void send()
          {
!             const int64_t seq(curr_seq_);
              gu::byte_t buf[sizeof(seq)];
              size_t sz;
              gu_trace(sz = gu::serialize8(seq, buf, sizeof(buf), 0));
!             Datagram dg(gu::Buffer(buf, buf + sz));
              int err = send_down(dg, ProtoDownMeta(0));
              if (err != 0)
              {
***************
*** 331,357 ****
              }
              else
              {
!                 ++curr_seq;
              }
          }
  
!         const Trace& get_trace() const { return tr; }
  
          void set_cvi(const ViewId& vi)
          {
!             log_debug << get_uuid() << " setting cvi to " << vi;
!             cvi = vi;
          }
  
          bool in_cvi() const
          {
              for (Trace::ViewTraceMap::const_reverse_iterator i(
!                      tr.get_view_traces().rbegin());
!                  i != tr.get_view_traces().rend(); ++i)
              {
!                 if (i->first.get_uuid() == cvi.get_uuid() &&
!                     i->first.get_type() == cvi.get_type() &&
!                     i->first.get_seq()  >= cvi.get_seq())
                  {
                      return true;
                  }
--- 328,354 ----
              }
              else
              {
!                 ++curr_seq_;
              }
          }
  
!         const Trace& trace() const { return tr_; }
  
          void set_cvi(const ViewId& vi)
          {
!             log_debug << uuid() << " setting cvi to " << vi;
!             cvi_ = vi;
          }
  
          bool in_cvi() const
          {
              for (Trace::ViewTraceMap::const_reverse_iterator i(
!                      tr_.view_traces().rbegin());
!                  i != tr_.view_traces().rend(); ++i)
              {
!                 if (i->first.uuid() == cvi_.uuid() &&
!                     i->first.type() == cvi_.type() &&
!                     i->first.seq()  >= cvi_.seq())
                  {
                      return true;
                  }
***************
*** 359,379 ****
              return false;
          }
  
!         void handle_up(const void* cid, const gu::Datagram& rb,
                         const ProtoUpMeta& um)
          {
!             if (rb.get_len() != 0)
              {
!                 gcomm_assert((um.get_source() == UUID::nil()) == false);
!                 // assert(rb.get_header().size() == 0);
!                 const gu::byte_t* begin(get_begin(rb));
!                 const size_t available(get_available(rb));
  
  
!                 // log_debug << um.get_source() << " " << get_uuid()
                  //         << " " << available ;
!                 // log_debug << rb.get_len() << " " << rb.get_offset() << " "
!                 //         << rb.get_header_len();
                  if (available != 8)
                  {
                      log_info << "check_trace fail";
--- 356,376 ----
              return false;
          }
  
!         void handle_up(const void* cid, const Datagram& rb,
                         const ProtoUpMeta& um)
          {
!             if (rb.len() != 0)
              {
!                 gcomm_assert((um.source() == UUID::nil()) == false);
!                 // assert(rb.header().size() == 0);
!                 const gu::byte_t* begin(gcomm::begin(rb));
!                 const size_t available(gcomm::available(rb));
  
  
!                 // log_debug << um.source() << " " << uuid()
                  //         << " " << available ;
!                 // log_debug << rb.len() << " " << rb.offset() << " "
!                 //         << rb.header_len();
                  if (available != 8)
                  {
                      log_info << "check_trace fail";
***************
*** 384,414 ****
                                            available,
                                            0,
                                            seq));
!                 tr.insert_msg(TraceMsg(um.get_source(), um.get_source_view_id(),
!                                        seq));
              }
              else
              {
                  gcomm_assert(um.has_view() == true);
!                 tr.insert_view(um.get_view());
              }
          }
  
  
          gu::datetime::Date handle_timers()
          {
!             std::for_each(protos.begin(), protos.end(),
                            std::mem_fun(&Protolay::handle_timers));
              return gu::datetime::Date::max();
          }
  
      private:
!         size_t index;
!         UUID uuid;
!         std::list<Protolay*> protos;
!         ViewId cvi;
!         Trace tr;
!         int64_t curr_seq;
      };
  
  
--- 381,411 ----
                                            available,
                                            0,
                                            seq));
!                 tr_.insert_msg(TraceMsg(um.source(), um.source_view_id(),
!                                         seq));
              }
              else
              {
                  gcomm_assert(um.has_view() == true);
!                 tr_.insert_view(um.view());
              }
          }
  
  
          gu::datetime::Date handle_timers()
          {
!             std::for_each(protos_.begin(), protos_.end(),
                            std::mem_fun(&Protolay::handle_timers));
              return gu::datetime::Date::max();
          }
  
      private:
!         size_t index_;
!         UUID uuid_;
!         std::list<Protolay*> protos_;
!         ViewId cvi_;
!         Trace tr_;
!         int64_t curr_seq_;
      };
  
  
***************
*** 416,431 ****
      class ChannelMsg
      {
      public:
!         ChannelMsg(const gu::Datagram& rb_, const UUID& source_) :
!             rb(rb_),
!             source(source_)
          {
          }
!         const gu::Datagram& get_rb() const { return rb; }
!         const UUID& get_source() const { return source; }
      private:
!         gu::Datagram rb;
!         UUID source;
      };
  
  
--- 413,428 ----
      class ChannelMsg
      {
      public:
!         ChannelMsg(const Datagram& rb, const UUID& source) :
!             rb_(rb),
!             source_(source)
          {
          }
!         const Datagram& rb() const { return rb_; }
!         const UUID& source() const { return source_; }
      private:
!         Datagram rb_;
!         UUID source_;
      };
  
  
***************
*** 433,480 ****
      {
      public:
          Channel(gu::Config& conf,
!                 const size_t ttl_ = 1,
!                 const size_t latency_ = 1,
!                 const double loss_ = 1.) :
              Bottomlay(conf),
!             ttl(ttl_),
!             latency(latency_),
!             loss(loss_),
!             queue()
          { }
  
  
  
          ~Channel() { }
  
!         int handle_down(gu::Datagram& wb, const ProtoDownMeta& dm)
          {
!             gcomm_assert((dm.get_source() == UUID::nil()) == false);
!             gu_trace(put(wb, dm.get_source()));
              return 0;
          }
  
!         void put(const gu::Datagram& rb, const UUID& source);
          ChannelMsg get();
!         void set_ttl(const size_t t) { ttl = t; }
!         size_t get_ttl() const { return ttl; }
          void set_latency(const size_t l)
          {
              gcomm_assert(l > 0);
!             latency = l;
          }
!         size_t get_latency() const { return latency; }
!         void set_loss(const double l) { loss = l; }
!         double get_loss() const { return loss; }
!         size_t get_n_msgs() const
          {
!             return queue.size();
          }
      private:
!         size_t ttl;
!         size_t latency;
!         double loss;
!         std::deque<std::pair<size_t, ChannelMsg> > queue;
      };
  
  
--- 430,477 ----
      {
      public:
          Channel(gu::Config& conf,
!                 const size_t ttl = 1,
!                 const size_t latency = 1,
!                 const double loss = 1.) :
              Bottomlay(conf),
!             ttl_(ttl),
!             latency_(latency),
!             loss_(loss),
!             queue_()
          { }
  
  
  
          ~Channel() { }
  
!         int handle_down(Datagram& wb, const ProtoDownMeta& dm)
          {
!             gcomm_assert((dm.source() == UUID::nil()) == false);
!             gu_trace(put(wb, dm.source()));
              return 0;
          }
  
!         void put(const Datagram& rb, const UUID& source);
          ChannelMsg get();
!         void set_ttl(const size_t t) { ttl_ = t; }
!         size_t ttl() const { return ttl_; }
          void set_latency(const size_t l)
          {
              gcomm_assert(l > 0);
!             latency_ = l;
          }
!         size_t latency() const { return latency_; }
!         void set_loss(const double l) { loss_ = l; }
!         double loss() const { return loss_; }
!         size_t n_msgs() const
          {
!             return queue_.size();
          }
      private:
!         size_t ttl_;
!         size_t latency_;
!         double loss_;
!         std::deque<std::pair<size_t, ChannelMsg> > queue_;
      };
  
  
***************
*** 487,502 ****
      class MatrixElem
      {
      public:
!         MatrixElem(const size_t ii_, const size_t jj_) : ii(ii_), jj(jj_) { }
!         size_t get_ii() const { return ii; }
!         size_t get_jj() const { return jj; }
          bool operator<(const MatrixElem& cmp) const
          {
!             return (ii < cmp.ii || (ii == cmp.ii && jj < cmp.jj));
          }
      private:
!         size_t ii;
!         size_t jj;
      };
  
      std::ostream& operator<<(std::ostream& os, const MatrixElem& me);
--- 484,499 ----
      class MatrixElem
      {
      public:
!         MatrixElem(const size_t ii, const size_t jj) : ii_(ii), jj_(jj) { }
!         size_t ii() const { return ii_; }
!         size_t jj() const { return jj_; }
          bool operator<(const MatrixElem& cmp) const
          {
!             return (ii_ < cmp.ii_ || (ii_ == cmp.ii_ && jj_ < cmp.jj_));
          }
      private:
!         size_t ii_;
!         size_t jj_;
      };
  
      std::ostream& operator<<(std::ostream& os, const MatrixElem& me);
***************
*** 508,514 ****
          {
              void operator()(ChannelMap::value_type& vt)
              {
!                 delete ChannelMap::get_value(vt);
              }
          };
      };
--- 505,511 ----
          {
              void operator()(ChannelMap::value_type& vt)
              {
!                 delete ChannelMap::value(vt);
              }
          };
      };
***************
*** 518,524 ****
          {
              void operator()(NodeMap::value_type& vt)
              {
!                 delete NodeMap::get_value(vt);
              }
          };
  
--- 515,521 ----
          {
              void operator()(NodeMap::value_type& vt)
              {
!                 delete NodeMap::value(vt);
              }
          };
  
***************
*** 527,533 ****
      class PropagationMatrix
      {
      public:
!         PropagationMatrix() : tp(), prop() { }
          ~PropagationMatrix();
  
          void insert_tp(DummyNode* t);
--- 524,530 ----
      class PropagationMatrix
      {
      public:
!         PropagationMatrix() : tp_(), prop_() { }
          ~PropagationMatrix();
  
          void insert_tp(DummyNode* t);
***************
*** 546,553 ****
          size_t count_channel_msgs() const;
          bool all_in_cvi() const;
  
!         NodeMap    tp;
!         ChannelMap prop;
      };
  
  
--- 543,550 ----
          size_t count_channel_msgs() const;
          bool all_in_cvi() const;
  
!         NodeMap    tp_;
!         ChannelMap prop_;
      };
  
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_types.cpp 2.x/gcomm/test/check_types.cpp
*** galera-23.2.2-src/gcomm/test/check_types.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_types.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 76,89 ****
  
  
      ViewId vid;
!     fail_unless(vid.get_uuid() == UUID());
!     fail_unless(vid.get_seq() == 0);
  
      UUID uuid(0, 0);
  
      vid = ViewId(V_REG, uuid, 7);
!     fail_unless(vid.get_uuid() == uuid);
!     fail_unless(vid.get_seq() == 7);
  
      check_serialization(vid, UUID::serial_size() + sizeof(uint32_t), ViewId());
  
--- 76,89 ----
  
  
      ViewId vid;
!     fail_unless(vid.uuid() == UUID());
!     fail_unless(vid.seq() == 0);
  
      UUID uuid(0, 0);
  
      vid = ViewId(V_REG, uuid, 7);
!     fail_unless(vid.uuid() == uuid);
!     fail_unless(vid.seq() == 7);
  
      check_serialization(vid, UUID::serial_size() + sizeof(uint32_t), ViewId());
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/check_util.cpp 2.x/gcomm/test/check_util.cpp
*** galera-23.2.2-src/gcomm/test/check_util.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/check_util.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 5,10 ****
--- 5,11 ----
  #include "gcomm/util.hpp"
  #include "histogram.hpp"
  #include "gcomm/protonet.hpp"
+ #include "gcomm/datagram.hpp"
  
  #ifdef HAVE_ASIO_HPP
  #include "asio_protonet.hpp"
***************
*** 52,57 ****
--- 53,155 ----
  }
  END_TEST
  
+ START_TEST(test_datagram)
+ {
+ 
+     // Header check
+     gcomm::NetHeader hdr(42, 0);
+     fail_unless(hdr.len() == 42);
+     fail_unless(hdr.has_crc32() == false);
+     fail_unless(hdr.version() == 0);
+ 
+     hdr.set_crc32(1234);
+     fail_unless(hdr.has_crc32() == true);
+     fail_unless(hdr.len() == 42);
+ 
+     gcomm::NetHeader hdr1(42, 1);
+     fail_unless(hdr1.len() == 42);
+     fail_unless(hdr1.has_crc32() == false);
+     fail_unless(hdr1.version() == 1);
+ 
+     gu::byte_t hdrbuf[NetHeader::serial_size_];
+     fail_unless(serialize(hdr1, hdrbuf, sizeof(hdrbuf), 0) ==
+                 NetHeader::serial_size_);
+     try
+     {
+         unserialize(hdrbuf, sizeof(hdrbuf), 0, hdr);
+         fail("");
+     }
+     catch (Exception& e)
+     {
+         // ok
+     }
+ 
+ 
+     gu::byte_t b[128];
+     for (gu::byte_t i = 0; i < sizeof(b); ++i)
+     {
+         b[i] = i;
+     }
+     gu::Buffer buf(b, b + sizeof(b));
+ 
+     gcomm::Datagram dg(buf);
+     fail_unless(dg.len() == sizeof(b));
+ 
+     // Normal copy construction
+     gcomm::Datagram dgcopy(buf);
+     fail_unless(dgcopy.len() == sizeof(b));
+     fail_unless(memcmp(dgcopy.header() + dgcopy.header_offset(),
+                        dg.header() + dg.header_offset(),
+                        dg.header_len()) == 0);
+     fail_unless(dgcopy.payload() == dg.payload());
+ 
+     // Copy construction from offset of 16
+     gcomm::Datagram dg16(dg, 16);
+     log_info << dg16.len();
+     fail_unless(dg16.len() - dg16.offset() == sizeof(b) - 16);
+     for (gu::byte_t i = 0; i < sizeof(b) - 16; ++i)
+     {
+         fail_unless(dg16.payload()[i + dg16.offset()] == i + 16);
+     }
+ 
+ #if 0
+     // Normalize datagram, all data is moved into payload, data from
+     // beginning to offset is discarded. Normalization must not change
+     // dg
+     dg16.normalize();
+ 
+     fail_unless(dg16.len() == sizeof(b) - 16);
+     for (byte_t i = 0; i < sizeof(b) - 16; ++i)
+     {
+         fail_unless(dg16.payload()[i] == i + 16);
+     }
+ 
+     fail_unless(dg.len() == sizeof(b));
+     for (byte_t i = 0; i < sizeof(b); ++i)
+     {
+         fail_unless(dg.payload()[i] == i);
+     }
+ 
+     Datagram dgoff(buf, 16);
+     dgoff.header().resize(8);
+     dgoff.set_header_offset(4);
+     fail_unless(dgoff.len() == buf.size() + 4);
+     fail_unless(dgoff.header_offset() == 4);
+     fail_unless(dgoff.header().size() == 8);
+     for (byte_t i = 0; i < 4; ++i)
+     {
+         *(&dgoff.header()[0] + i) = i;
+     }
+ 
+     dgoff.normalize();
+ 
+     fail_unless(dgoff.len() == sizeof(b) - 16 + 4);
+     fail_unless(dgoff.header_offset() == 0);
+     fail_unless(dgoff.header().size() == 0);
+ #endif // 0
+ }
+ END_TEST
+ 
  
  #if defined(HAVE_ASIO_HPP)
  START_TEST(test_asio)
***************
*** 69,77 ****
      pn.event_loop(datetime::Sec);
  
      SocketPtr sr = acc->accept();
!     fail_unless(sr->get_state() == Socket::S_CONNECTED);
  
!     vector<byte_t> buf(cl->get_mtu());
      for (size_t i = 0; i < buf.size(); ++i)
      {
          buf[i] = static_cast<byte_t>(i & 0xff);
--- 167,175 ----
      pn.event_loop(datetime::Sec);
  
      SocketPtr sr = acc->accept();
!     fail_unless(sr->state() == Socket::S_CONNECTED);
  
!     vector<byte_t> buf(cl->mtu());
      for (size_t i = 0; i < buf.size(); ++i)
      {
          buf[i] = static_cast<byte_t>(i & 0xff);
***************
*** 108,113 ****
--- 206,215 ----
      tcase_add_test(tc, test_histogram);
      suite_add_tcase(s, tc);
  
+     tc = tcase_create("test_datagram");
+     tcase_add_test(tc, test_datagram);
+     suite_add_tcase(s, tc);
+ 
  #ifdef HAVE_ASIO_HPP
      tc = tcase_create("test_asio");
      tcase_add_test(tc, test_asio);
diff -crB --unidirectional-new-file galera-23.2.2-src/gcomm/test/ssl_test.cpp 2.x/gcomm/test/ssl_test.cpp
*** galera-23.2.2-src/gcomm/test/ssl_test.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcomm/test/ssl_test.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 41,60 ****
          return std::string(msg_.begin(), msg_.end());
      }
  
!     void handle_up(const void* id, const gu::Datagram& dg,
                     const gcomm::ProtoUpMeta& um)
      {
!         if (um.get_errno() != 0)
          {
!             log_error << "socket failed: " << um.get_errno();
              socket_->close();
              throw std::exception();
          }
          else
          {
!             assert(id == socket_->get_id());
!             msg_.insert(msg_.begin(), gcomm::get_begin(dg),
!                         gcomm::get_begin(dg) + gcomm::get_available(dg));
          }
      }
  private:
--- 41,60 ----
          return std::string(msg_.begin(), msg_.end());
      }
  
!     void handle_up(const void* id, const gcomm::Datagram& dg,
                     const gcomm::ProtoUpMeta& um)
      {
!         if (um.err_no() != 0)
          {
!             log_error << "socket failed: " << um.err_no();
              socket_->close();
              throw std::exception();
          }
          else
          {
!             assert(id == socket_->id());
!             msg_.insert(msg_.begin(), gcomm::begin(dg),
!                         gcomm::begin(dg) + gcomm::available(dg));
          }
      }
  private:
***************
*** 96,109 ****
          listener_->listen(uri_);
      }
  
!     void handle_up(const void* id, const gu::Datagram& dg,
                     const gcomm::ProtoUpMeta& um)
      {
!         if (id == listener_->get_id())
          {
              gcomm::SocketPtr socket(listener_->accept());
              if (smap_.insert(
!                     std::make_pair(socket->get_id(), socket)).second == false)
              {
                  throw std::logic_error("duplicate socket entry");
              }
--- 96,109 ----
          listener_->listen(uri_);
      }
  
!     void handle_up(const void* id, const gcomm::Datagram& dg,
                     const gcomm::ProtoUpMeta& um)
      {
!         if (id == listener_->id())
          {
              gcomm::SocketPtr socket(listener_->accept());
              if (smap_.insert(
!                     std::make_pair(socket->id(), socket)).second == false)
              {
                  throw std::logic_error("duplicate socket entry");
              }
***************
*** 117,131 ****
          }
  
          gcomm::SocketPtr socket(si->second);
!         if (socket->get_state() == gcomm::Socket::S_CONNECTED)
          {
!             gu::Datagram msg;
!             msg.get_payload().resize(msg_.size());
!             std::copy(msg_.begin(), msg_.end(), msg.get_payload().begin());
              socket->send(msg);
          }
!         else if (socket->get_state() == gcomm::Socket::S_CLOSED ||
!                  socket->get_state() == gcomm::Socket::S_FAILED)
          {
              std::cerr << "socket " << id << " failed" << std::endl;
              socket->close();
--- 117,131 ----
          }
  
          gcomm::SocketPtr socket(si->second);
!         if (socket->state() == gcomm::Socket::S_CONNECTED)
          {
!             gcomm::Datagram msg;
!             msg.payload().resize(msg_.size());
!             std::copy(msg_.begin(), msg_.end(), msg.payload().begin());
              socket->send(msg);
          }
!         else if (socket->state() == gcomm::Socket::S_CLOSED ||
!                  socket->state() == gcomm::Socket::S_FAILED)
          {
              std::cerr << "socket " << id << " failed" << std::endl;
              socket->close();
***************
*** 133,139 ****
          }
          else
          {
!             std::cerr << "socket state: " << socket->get_state() << std::endl;
          }
      }
  
--- 133,139 ----
          }
          else
          {
!             std::cerr << "socket state: " << socket->state() << std::endl;
          }
      }
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcs/src/gcs_gcomm.cpp 2.x/gcs/src/gcs_gcomm.cpp
*** galera-23.2.2-src/gcs/src/gcs_gcomm.cpp	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcs/src/gcs_gcomm.cpp	2013-03-08 19:49:02.370351000 +0800
***************
*** 25,30 ****
--- 25,31 ----
  
  
  #include <galerautils.hpp>
+ #include "gu_backtrace.hpp"
  #include "gcomm/transport.hpp"
  #include "gcomm/util.hpp"
  
***************
*** 48,69 ****
  class RecvBufData
  {
  public:
!     RecvBufData(const size_t source_idx_,
!                 const Datagram& dgram_,
!                 const ProtoUpMeta& um_) :
!         source_idx(source_idx_),
!         dgram(dgram_),
!         um(um_)
      { }
  
!     size_t get_source_idx() const { return source_idx; }
!     const Datagram& get_dgram() const { return dgram; }
!     const ProtoUpMeta& get_um() const { return um; }
  
  private:
!     size_t source_idx;
!     Datagram dgram;
!     ProtoUpMeta um;
  };
  
  
--- 49,70 ----
  class RecvBufData
  {
  public:
!     RecvBufData(const size_t source_idx,
!                 const Datagram& dgram,
!                 const ProtoUpMeta& um) :
!         source_idx_(source_idx),
!         dgram_     (dgram),
!         um_        (um)
      { }
  
!     size_t get_source_idx() const { return source_idx_; }
!     const Datagram& get_dgram() const { return dgram_; }
!     const ProtoUpMeta& get_um() const { return um_; }
  
  private:
!     size_t source_idx_;
!     Datagram dgram_;
!     ProtoUpMeta um_;
  };
  
  
***************
*** 82,124 ****
  
  public:
  
!     RecvBuf() : mutex(), cond(), queue(), waiting(false) { }
  
      void push_back(const RecvBufData& p)
      {
!         Lock lock(mutex);
  
!         queue.push_back(p);
  
!         if (waiting == true) { cond.signal(); }
      }
  
      const RecvBufData& front(const Date& timeout) throw (Exception)
      {
!         Lock lock(mutex);
  
!         while (queue.empty())
          {
!             Waiting w(waiting);
              if (gu_likely (timeout == GU_TIME_ETERNITY))
              {
!                 lock.wait(cond);
              }
              else
              {
!                 lock.wait(cond, timeout);
              }
          }
!         assert (false == waiting);
  
!         return queue.front();
      }
  
      void pop_front()
      {
!         Lock lock(mutex);
!         assert(queue.empty() == false);
!         queue.pop_front();
      }
  
  private:
--- 83,125 ----
  
  public:
  
!     RecvBuf() : mutex_(), cond_(), queue_(), waiting_(false) { }
  
      void push_back(const RecvBufData& p)
      {
!         Lock lock(mutex_);
  
!         queue_.push_back(p);
  
!         if (waiting_ == true) { cond_.signal(); }
      }
  
      const RecvBufData& front(const Date& timeout) throw (Exception)
      {
!         Lock lock(mutex_);
  
!         while (queue_.empty())
          {
!             Waiting w(waiting_);
              if (gu_likely (timeout == GU_TIME_ETERNITY))
              {
!                 lock.wait(cond_);
              }
              else
              {
!                 lock.wait(cond_, timeout);
              }
          }
!         assert (false == waiting_);
  
!         return queue_.front();
      }
  
      void pop_front()
      {
!         Lock lock(mutex_);
!         assert(queue_.empty() == false);
!         queue_.pop_front();
      }
  
  private:
***************
*** 130,165 ****
          void unlock() {}
      };
  
!     Mutex mutex;
!     Cond cond;
      deque<RecvBufData,
            boost::fast_pool_allocator<
                RecvBufData,
!               boost::default_user_allocator_new_delete, DummyMutex> > queue;
!     bool waiting;
  };
  
  
  class MsgData : public MessageData
  {
  public:
!     MsgData(const byte_t* data_,
!             const size_t data_size_,
!             const gcs_msg_type_t msg_type_) :
!         data(data_),
!         data_size(data_size_),
!         msg_type(msg_type_)
      { }
!     const byte_t* get_data() const { return data; }
!     size_t get_data_size() const { return data_size; }
!     gcs_msg_type_t get_msg_type() const { return msg_type; }
  
  public:
      MsgData(const MsgData&);
      void operator=(const MsgData&);
!     const byte_t* data;
!     size_t  data_size;
!     gcs_msg_type_t msg_type;
  };
  
  
--- 131,166 ----
          void unlock() {}
      };
  
!     Mutex mutex_;
!     Cond cond_;
      deque<RecvBufData,
            boost::fast_pool_allocator<
                RecvBufData,
!               boost::default_user_allocator_new_delete, DummyMutex> > queue_;
!     bool waiting_;
  };
  
  
  class MsgData : public MessageData
  {
  public:
!     MsgData(const byte_t* data,
!             const size_t data_size,
!             const gcs_msg_type_t msg_type) :
!         data_     (data),
!         data_size_(data_size),
!         msg_type_ (msg_type)
      { }
!     const byte_t* get_data() const { return data_; }
!     size_t get_data_size() const { return data_size_; }
!     gcs_msg_type_t get_msg_type() const { return msg_type_; }
  
  public:
      MsgData(const MsgData&);
      void operator=(const MsgData&);
!     const byte_t*  data_;
!     size_t         data_size_;
!     gcs_msg_type_t msg_type_;
  };
  
  
***************
*** 169,203 ****
  
      GCommConn(const URI& u, gu::Config& cnf) :
          Toplay(cnf),
!         conf(cnf),
!         uuid(),
!         thd(),
!         uri(u),
!         use_prod_cons(from_string<bool>(
!                           uri.get_option("gcomm.use_prod_cons", "false"))),
!         net(Protonet::create(conf)),
!         tp(0),
!         mutex(),
!         refcnt(0),
!         terminated(false),
!         error(0),
!         recv_buf(),
!         current_view(),
!         prof("gcs_gcomm")
      {
!         if (use_prod_cons == false)
!         {
!             log_debug << "gcomm: disabling prod/cons";
!         }
!         log_info << "backend: " << net->get_type();
      }
  
      ~GCommConn()
      {
!         delete net;
      }
  
!     const UUID& get_uuid() const { return uuid; }
  
      static void* run_fn(void* arg)
      {
--- 170,198 ----
  
      GCommConn(const URI& u, gu::Config& cnf) :
          Toplay(cnf),
!         conf_(cnf),
!         uuid_(),
!         thd_(),
!         uri_(u),
!         net_(Protonet::create(conf_)),
!         tp_(0),
!         mutex_(),
!         refcnt_(0),
!         terminated_(false),
!         error_(0),
!         recv_buf_(),
!         current_view_(),
!         prof_("gcs_gcomm")
      {
!         log_info << "backend: " << net_->type();
      }
  
      ~GCommConn()
      {
!         delete net_;
      }
  
!     const UUID& get_uuid() const { return uuid_; }
  
      static void* run_fn(void* arg)
      {
***************
*** 207,224 ****
  
      void connect(const string& channel)
      {
!         if (tp != 0)
          {
              gu_throw_fatal << "backend connection already open";
          }
  
!         uri.set_option("gmcast.group", channel);
!         tp = Transport::create(*net, uri);
!         gcomm::connect(tp, this);
  
          string peer;
          URI::AuthorityList::const_iterator i, i_next;
!         for (i = uri.get_authority_list().begin(); i != uri.get_authority_list().end(); ++i)
          {
              i_next = i;
              ++i_next;
--- 202,220 ----
  
      void connect(const string& channel)
      {
!         if (tp_ != 0)
          {
              gu_throw_fatal << "backend connection already open";
          }
  
!         uri_.set_option("gmcast.group", channel);
!         tp_ = Transport::create(*net_, uri_);
!         gcomm::connect(tp_, this);
  
          string peer;
          URI::AuthorityList::const_iterator i, i_next;
!         for (i = uri_.get_authority_list().begin();
!              i != uri_.get_authority_list().end(); ++i)
          {
              i_next = i;
              ++i_next;
***************
*** 227,245 ****
              try { host = i->host(); } catch (NotSet&) { }
              try { port = i->port(); } catch (NotSet&) { }
              peer += host != "" ? host + ":" + port : "";
!             if (i_next != uri.get_authority_list().end())
              {
                  peer += ",";
              }
          }
          log_info << "gcomm: connecting to group '" << channel
                   << "', peer '" << peer << "'";
!         tp->connect();
!         uuid = tp->get_uuid();
  
          int err;
  
!         if ((err = pthread_create(&thd, 0, &run_fn, this)) != 0)
          {
              gu_throw_error(err);
          }
--- 223,241 ----
              try { host = i->host(); } catch (NotSet&) { }
              try { port = i->port(); } catch (NotSet&) { }
              peer += host != "" ? host + ":" + port : "";
!             if (i_next != uri_.get_authority_list().end())
              {
                  peer += ",";
              }
          }
          log_info << "gcomm: connecting to group '" << channel
                   << "', peer '" << peer << "'";
!         tp_->connect();
!         uuid_ = tp_->uuid();
  
          int err;
  
!         if ((err = pthread_create(&thd_, 0, &run_fn, this)) != 0)
          {
              gu_throw_error(err);
          }
***************
*** 248,254 ****
  
      void close()
      {
!         if (tp == 0)
          {
              log_warn << "gcomm: backend already closed";
              return;
--- 244,250 ----
  
      void close()
      {
!         if (tp_ == 0)
          {
              log_warn << "gcomm: backend already closed";
              return;
***************
*** 256,267 ****
          log_info << "gcomm: terminating thread";
          terminate();
          log_info << "gcomm: joining thread";
!         pthread_join(thd, 0);
          log_info << "gcomm: closing backend";
!         tp->close(error != 0);
!         gcomm::disconnect(tp, this);
!         delete tp;
!         tp = 0;
  
          const Message* msg;
  
--- 252,263 ----
          log_info << "gcomm: terminating thread";
          terminate();
          log_info << "gcomm: joining thread";
!         pthread_join(thd_, 0);
          log_info << "gcomm: closing backend";
!         tp_->close(error_ != 0);
!         gcomm::disconnect(tp_, this);
!         delete tp_;
!         tp_ = 0;
  
          const Message* msg;
  
***************
*** 270,287 ****
              return_ack(Message(&msg->get_producer(), 0, -ECONNABORTED));
          }
          log_info << "gcomm: closed";
!         log_debug << prof;
      }
  
      void run();
  
!     void notify() { net->interrupt(); }
  
      void terminate()
      {
!         Lock lock(mutex);
!         terminated = true;
!         net->interrupt();
      }
  
      void handle_up     (const void*        id,
--- 266,283 ----
              return_ack(Message(&msg->get_producer(), 0, -ECONNABORTED));
          }
          log_info << "gcomm: closed";
!         log_debug << prof_;
      }
  
      void run();
  
!     void notify() { net_->interrupt(); }
  
      void terminate()
      {
!         Lock lock(mutex_);
!         terminated_ = true;
!         net_->interrupt();
      }
  
      void handle_up     (const void*        id,
***************
*** 290,318 ****
  
      void queue_and_wait(const Message& msg, Message* ack);
  
!     RecvBuf&    get_recv_buf()            { return recv_buf; }
      size_t      get_mtu()           const
      {
!         if (tp == 0)
          {
              gu_throw_fatal << "GCommConn::get_mtu(): "
                             << "backend connection not open";
          }
!         return tp->get_mtu();
      }
!     bool        get_use_prod_cons() const { return use_prod_cons; }
!     Protonet&   get_pnet()                { return *net; }
!     gu::Config& get_conf()                { return conf; }
!     int         get_error() const         { return error; }
      class Ref
      {
      public:
  
!         Ref(gcs_backend_t* ptr, bool unset = false) : conn(0)
          {
              if (ptr->conn != 0)
              {
!                 conn = reinterpret_cast<GCommConn*>(ptr->conn)->ref(unset);
  
                  if (unset == true)
                  {
--- 286,313 ----
  
      void queue_and_wait(const Message& msg, Message* ack);
  
!     RecvBuf&    get_recv_buf()            { return recv_buf_; }
      size_t      get_mtu()           const
      {
!         if (tp_ == 0)
          {
              gu_throw_fatal << "GCommConn::get_mtu(): "
                             << "backend connection not open";
          }
!         return tp_->mtu();
      }
!     Protonet&   get_pnet()                { return *net_; }
!     gu::Config& get_conf()                { return conf_; }
!     int         get_error() const         { return error_; }
      class Ref
      {
      public:
  
!         Ref(gcs_backend_t* ptr, bool unset = false) : conn_(0)
          {
              if (ptr->conn != 0)
              {
!                 conn_ = reinterpret_cast<GCommConn*>(ptr->conn)->ref(unset);
  
                  if (unset == true)
                  {
***************
*** 323,342 ****
  
          ~Ref()
          {
!             if (conn != 0)
              {
!                 conn->unref();
              }
          }
  
!         GCommConn* get() { return conn; }
  
      private:
  
          Ref(const Ref&);
          void operator=(const Ref&);
  
!         GCommConn* conn;
      };
  
  private:
--- 318,337 ----
  
          ~Ref()
          {
!             if (conn_ != 0)
              {
!                 conn_->unref();
              }
          }
  
!         GCommConn* get() { return conn_; }
  
      private:
  
          Ref(const Ref&);
          void operator=(const Ref&);
  
!         GCommConn* conn_;
      };
  
  private:
***************
*** 351,385 ****
  
      void unref() { }
  
!     gu::Config& conf;
!     UUID uuid;
!     pthread_t thd;
!     URI uri;
!     bool use_prod_cons;
!     Protonet* net;
!     Transport* tp;
!     Mutex mutex;
!     size_t refcnt;
!     bool terminated;
!     int error;
!     RecvBuf recv_buf;
!     View current_view;
!     Profile prof;
  };
  
  
! void GCommConn::handle_up(const void* id, const Datagram& dg, const ProtoUpMeta& um)
  {
!     if (um.get_errno() != 0)
      {
!         error = um.get_errno();
!         recv_buf.push_back(RecvBufData(numeric_limits<size_t>::max(), dg, um));
      }
      else if (um.has_view() == true)
      {
!         current_view = um.get_view();
!         recv_buf.push_back(RecvBufData(numeric_limits<size_t>::max(), dg, um));
!         if (current_view.is_empty())
          {
              log_debug << "handle_up: self leave";
          }
--- 346,380 ----
  
      void unref() { }
  
!     gu::Config& conf_;
!     UUID        uuid_;
!     pthread_t   thd_;
!     URI         uri_;
!     Protonet*   net_;
!     Transport*  tp_;
!     Mutex       mutex_;
!     size_t      refcnt_;
!     bool        terminated_;
!     int         error_;
!     RecvBuf     recv_buf_;
!     View        current_view_;
!     Profile     prof_;
  };
  
  
! void
! GCommConn::handle_up(const void* id, const Datagram& dg, const ProtoUpMeta& um)
  {
!     if (um.err_no() != 0)
      {
!         error_ = um.err_no();
!         recv_buf_.push_back(RecvBufData(numeric_limits<size_t>::max(), dg, um));
      }
      else if (um.has_view() == true)
      {
!         current_view_ = um.view();
!         recv_buf_.push_back(RecvBufData(numeric_limits<size_t>::max(), dg, um));
!         if (current_view_.is_empty())
          {
              log_debug << "handle_up: self leave";
          }
***************
*** 387,405 ****
      else
      {
          size_t idx(0);
!         for (NodeList::const_iterator i = current_view.get_members().begin();
!              i != current_view.get_members().end(); ++i)
          {
!             if (NodeList::get_key(i) == um.get_source())
              {
!                 profile_enter(prof);
!                 recv_buf.push_back(RecvBufData(idx, dg, um));
!                 profile_leave(prof);
                  break;
              }
              ++idx;
          }
!         assert(idx < current_view.get_members().size());
      }
  }
  
--- 382,400 ----
      else
      {
          size_t idx(0);
!         for (NodeList::const_iterator i = current_view_.members().begin();
!              i != current_view_.members().end(); ++i)
          {
!             if (NodeList::key(i) == um.source())
              {
!                 profile_enter(prof_);
!                 recv_buf_.push_back(RecvBufData(idx, dg, um));
!                 profile_leave(prof_);
                  break;
              }
              ++idx;
          }
!         assert(idx < current_view_.members().size());
      }
  }
  
***************
*** 407,422 ****
  void GCommConn::queue_and_wait(const Message& msg, Message* ack)
  {
      {
!         Lock lock(mutex);
!         if (terminated == true)
          {
              *ack = Message(&msg.get_producer(), 0, -ECONNABORTED);
              return;
          }
      }
!     profile_enter(prof);
      Consumer::queue_and_wait(msg, ack);
!     profile_leave(prof);
  }
  
  
--- 402,417 ----
  void GCommConn::queue_and_wait(const Message& msg, Message* ack)
  {
      {
!         Lock lock(mutex_);
!         if (terminated_ == true)
          {
              *ack = Message(&msg.get_producer(), 0, -ECONNABORTED);
              return;
          }
      }
!     profile_enter(prof_);
      Consumer::queue_and_wait(msg, ack);
!     profile_leave(prof_);
  }
  
  
***************
*** 425,473 ****
      while (true)
      {
          {
!             Lock lock(mutex);
  
!             if (terminated == true)
              {
-                 if (get_use_prod_cons() == true)
-                 {
-                     const Message* msg;
- 
-                     while ((msg = get_next_msg()) != 0)
-                     {
-                         return_ack(Message(&msg->get_producer(), 0,
-                                            -ECONNABORTED));
-                     }
-                 }
                  break;
              }
          }
  
-         if (get_use_prod_cons() == true)
-         {
-             const Message* msg;
- 
-             if ((msg = get_next_msg()) != 0)
-             {
-                 const MsgData* md(static_cast<const MsgData*>(msg->get_data()));
-                 Buffer buf(md->get_data(), md->get_data() + md->get_data_size());
-                 Datagram dg(buf);
-                 int err = send_down(dg, ProtoDownMeta(md->get_msg_type(),
-                                                       md->get_msg_type() == GCS_MSG_CAUSAL ? O_LOCAL_CAUSAL : O_SAFE));
- 
-                 return_ack(Message(&msg->get_producer(), 0, err != 0 ?
-                                    -err : static_cast<int>(dg.get_len())));
-             }
-         }
- 
          try
          {
!             net->event_loop(Sec);
          }
          catch (gu::Exception& e)
          {
              log_error << "exception from gcomm, backend must be restarted:"
                        << e.what();
              gcomm::Critical<Protonet> crit(get_pnet());
              handle_up(0, Datagram(),
                        ProtoUpMeta(UUID::nil(),
--- 420,445 ----
      while (true)
      {
          {
!             Lock lock(mutex_);
  
!             if (terminated_ == true)
              {
                  break;
              }
          }
  
          try
          {
!             net_->event_loop(Sec);
          }
          catch (gu::Exception& e)
          {
              log_error << "exception from gcomm, backend must be restarted:"
                        << e.what();
+             // Commented out due to Backtrace() not producing proper
+             // backtraces.
+             // log_info << "attempting to get backtrace:";
+             // Backtrace().print(std::cerr);
              gcomm::Critical<Protonet> crit(get_pnet());
              handle_up(0, Datagram(),
                        ProtoUpMeta(UUID::nil(),
***************
*** 479,488 ****
--- 451,467 ----
                                    e.get_errno()));
              break;
          }
+ #if 0
+         // Disabled catching unknown exceptions due to Backtrace() not
+         // producing proper backtraces. We let the application crash
+         // and deal with diagnostics.
          catch (...)
          {
              log_error
                  << "unknow exception from gcomm, backend must be restarted";
+             log_info << "attempting to get backtrace:";
+             Backtrace().print(std::cerr);
+ 
              gcomm::Critical<Protonet> crit(get_pnet());
              handle_up(0, Datagram(),
                        ProtoUpMeta(UUID::nil(),
***************
*** 494,499 ****
--- 473,479 ----
                                    gu::Exception::E_UNSPEC));
              break;
          }
+ #endif
      }
  }
  
***************
*** 527,557 ****
  
      GCommConn& conn(*ref.get());
  
!     if (conn.get_use_prod_cons() == true)
!     {
!         Producer prod(conn);
!         Message ack;
!         MsgData msg_data(reinterpret_cast<const byte_t*>(buf), len, msg_type);
!         conn.queue_and_wait(Message(&prod, &msg_data), &ack);
!         return ack.get_val();
!     }
!     else
!     {
!         Datagram dg(
!             SharedBuffer(
!                 new Buffer(reinterpret_cast<const byte_t*>(buf),
!                            reinterpret_cast<const byte_t*>(buf) + len)));
!         gcomm::Critical<Protonet> crit(conn.get_pnet());
!         if (gu_unlikely(conn.get_error() != 0))
!         {
!             return -ECONNABORTED;
!         }
!         int err = conn.send_down(
!             dg,
!             ProtoDownMeta(msg_type, msg_type == GCS_MSG_CAUSAL ?
!                           O_LOCAL_CAUSAL : O_SAFE));
!         return (err == 0 ? len : -err);
!     }
  }
  
  
--- 507,526 ----
  
      GCommConn& conn(*ref.get());
  
!     Datagram dg(
!         SharedBuffer(
!             new Buffer(reinterpret_cast<const byte_t*>(buf),
!                        reinterpret_cast<const byte_t*>(buf) + len)));
!     gcomm::Critical<Protonet> crit(conn.get_pnet());
!     if (gu_unlikely(conn.get_error() != 0))
!     {
!         return -ECONNABORTED;
!     }
!     int err = conn.send_down(
!         dg,
!         ProtoDownMeta(msg_type, msg_type == GCS_MSG_CAUSAL ?
!                       O_LOCAL_CAUSAL : O_SAFE));
!     return (err == 0 ? len : -err);
  }
  
  
***************
*** 560,569 ****
  {
      size_t n(0);
  
!     for (NodeList::const_iterator i = view.get_members().begin();
!          i != view.get_members().end(); ++i)
      {
!         const UUID& uuid(NodeList::get_key(i));
  
          log_debug << "member: " << n << " uuid: " << uuid;
  
--- 529,538 ----
  {
      size_t n(0);
  
!     for (NodeList::const_iterator i = view.members().begin();
!          i != view.members().end(); ++i)
      {
!         const UUID& uuid(NodeList::key(i));
  
          log_debug << "member: " << n << " uuid: " << uuid;
  
***************
*** 604,622 ****
          const Datagram&    dg(d.get_dgram());
          const ProtoUpMeta& um(d.get_um());
  
!         if (gu_likely(dg.get_len() != 0))
          {
!             assert(dg.get_len() > dg.get_offset());
  
!             const byte_t* b(get_begin(dg));
!             const ssize_t pload_len(get_available(dg));
  
              msg->size = pload_len;
  
              if (gu_likely(pload_len <= msg->buf_len))
              {
                  memcpy(msg->buf, b, pload_len);
!                 msg->type = static_cast<gcs_msg_type_t>(um.get_user_type());
                  recv_buf.pop_front();
              }
              else
--- 573,591 ----
          const Datagram&    dg(d.get_dgram());
          const ProtoUpMeta& um(d.get_um());
  
!         if (gu_likely(dg.len() != 0))
          {
!             assert(dg.len() > dg.offset());
  
!             const byte_t* b(gcomm::begin(dg));
!             const ssize_t pload_len(gcomm::available(dg));
  
              msg->size = pload_len;
  
              if (gu_likely(pload_len <= msg->buf_len))
              {
                  memcpy(msg->buf, b, pload_len);
!                 msg->type = static_cast<gcs_msg_type_t>(um.user_type());
                  recv_buf.pop_front();
              }
              else
***************
*** 624,630 ****
                  msg->type = GCS_MSG_ERROR;
              }
          }
!         else if (um.get_errno() != 0)
          {
              gcs_comp_msg_t* cm(gcs_comp_msg_leave());
              const ssize_t cm_size(gcs_comp_msg_size(cm));
--- 593,599 ----
                  msg->type = GCS_MSG_ERROR;
              }
          }
!         else if (um.err_no() != 0)
          {
              gcs_comp_msg_t* cm(gcs_comp_msg_leave());
              const ssize_t cm_size(gcs_comp_msg_size(cm));
***************
*** 645,658 ****
          {
              assert(um.has_view() == true);
  
!             const View& view(um.get_view());
  
!             assert(view.get_type() == V_PRIM || view.get_type() == V_NON_PRIM);
  
!             gcs_comp_msg_t* cm(gcs_comp_msg_new(view.get_type() == V_PRIM,
                                                  view.is_bootstrap(),
                                                  view.is_empty() ? -1 : 0,
!                                                 view.get_members().size()));
  
              const ssize_t cm_size(gcs_comp_msg_size(cm));
  
--- 614,627 ----
          {
              assert(um.has_view() == true);
  
!             const View& view(um.view());
  
!             assert(view.type() == V_PRIM || view.type() == V_NON_PRIM);
  
!             gcs_comp_msg_t* cm(gcs_comp_msg_new(view.type() == V_PRIM,
                                                  view.is_bootstrap(),
                                                  view.is_empty() ? -1 : 0,
!                                                 view.members().size()));
  
              const ssize_t cm_size(gcs_comp_msg_size(cm));
  
diff -crB --unidirectional-new-file galera-23.2.2-src/gcs/src/gcs_group.c 2.x/gcs/src/gcs_group.c
*** galera-23.2.2-src/gcs/src/gcs_group.c	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcs/src/gcs_group.c	2013-03-08 19:49:02.370351000 +0800
***************
*** 1,7 ****
  /*
   * Copyright (C) 2008 Codership Oy <info@codership.com>
   *
!  * $Id: gcs_group.c 2832 2012-06-25 20:06:26Z alex $
   */
  
  #include "gcs_group.h"
--- 1,7 ----
  /*
   * Copyright (C) 2008 Codership Oy <info@codership.com>
   *
!  * $Id: gcs_group.c 2928 2013-01-14 19:25:09Z alex $
   */
  
  #include "gcs_group.h"
***************
*** 198,203 ****
--- 198,205 ----
              last_applied = seqno;
              last_node    = n;
          }
+         // extra diagnostic, ignore
+         //else if (!count) { gu_warn("not counting %d", n); }
      }
  
      if (gu_likely (last_node >= 0)) {
***************
*** 228,234 ****
  }
  
  static const char group_empty_id[GCS_COMP_MEMB_ID_MAX_LEN + 1] = { 0, };
!  
  static void
  group_check_donor (gcs_group_t* group)
  {
--- 230,236 ----
  }
  
  static const char group_empty_id[GCS_COMP_MEMB_ID_MAX_LEN + 1] = { 0, };
! 
  static void
  group_check_donor (gcs_group_t* group)
  {
***************
*** 289,295 ****
              group->last_applied_proto_ver = 0;
          }
          else {
!             group->last_applied_proto_ver = 1;            
          }
      }
      else {
--- 291,297 ----
              group->last_applied_proto_ver = 0;
          }
          else {
!             group->last_applied_proto_ver = 1;
          }
      }
      else {
***************
*** 618,624 ****
  
          group_redo_last_applied (group);
  
!         if (old_val < group->last_applied) return group->last_applied;
      }
  
      return 0;
--- 620,631 ----
  
          group_redo_last_applied (group);
  
!         if (old_val < group->last_applied) {
!             gu_debug ("New COMMIT CUT %lld after %lld from %d",
!                       (long long)group->last_applied,
!                       (long long)seqno, msg->sender_idx);
!             return group->last_applied;
!         }
      }
  
      return 0;
diff -crB --unidirectional-new-file galera-23.2.2-src/gcs/src/unit_tests/gcs_core_test.c 2.x/gcs/src/unit_tests/gcs_core_test.c
*** galera-23.2.2-src/gcs/src/unit_tests/gcs_core_test.c	2012-10-26 19:48:39.000000000 +0800
--- 2.x/gcs/src/unit_tests/gcs_core_test.c	2013-03-08 19:49:02.370351000 +0800
***************
*** 1,7 ****
  /*
   * Copyright (C) 2008 Codership Oy <info@codership.com>
   *
!  * $Id: gcs_core_test.c 2835 2012-06-27 21:49:51Z alex $
   */
  
  /*
--- 1,7 ----
  /*
   * Copyright (C) 2008 Codership Oy <info@codership.com>
   *
!  * $Id: gcs_core_test.c 2919 2012-12-26 23:20:00Z alex $
   */
  
  /*
***************
*** 476,482 ****
  {
  #undef ACT
  #define ACT act2
!     long     tout = 100; // 100 ms timeout
      size_t   act_size = sizeof(ACT);
      action_t act_s    = { ACT, NULL, act_size, GCS_ACT_TORDERED, -1, -1 };
      action_t act_r    = { NULL, NULL, -1, -1, -1, -1 };
--- 476,482 ----
  {
  #undef ACT
  #define ACT act2
!     long     tout = 1000; // 100 ms timeout
      size_t   act_size = sizeof(ACT);
      action_t act_s    = { ACT, NULL, act_size, GCS_ACT_TORDERED, -1, -1 };
      action_t act_r    = { NULL, NULL, -1, -1, -1, -1 };
***************
*** 625,631 ****
      fail_if (CORE_SEND_STEP (Core, tout, 1)); // 1st frag
      fail_if (DUMMY_INJECT_COMPONENT (Backend, non_prim));
      fail_if (CORE_SEND_STEP (Core, tout, 1)); // 2nd frag
!     usleep (500000);
      fail_if (gcs_dummy_set_component(Backend, non_prim));
      fail_if (CORE_SEND_STEP (Core, 4*tout, 1)); // 3rd frag
      fail_if (CORE_RECV_ACT (&act_r, NULL, UNKNOWN_SIZE, GCS_ACT_CONF));
--- 625,631 ----
      fail_if (CORE_SEND_STEP (Core, tout, 1)); // 1st frag
      fail_if (DUMMY_INJECT_COMPONENT (Backend, non_prim));
      fail_if (CORE_SEND_STEP (Core, tout, 1)); // 2nd frag
!     usleep (1000000);
      fail_if (gcs_dummy_set_component(Backend, non_prim));
      fail_if (CORE_SEND_STEP (Core, 4*tout, 1)); // 3rd frag
      fail_if (CORE_RECV_ACT (&act_r, NULL, UNKNOWN_SIZE, GCS_ACT_CONF));
***************
*** 659,663 ****
--- 659,664 ----
    tcase_add_test  (tcase, gcs_core_test_api);
    tcase_add_test  (tcase, gcs_core_test_own);
  //  tcase_add_test  (tcase, gcs_core_test_foreign);
+   tcase_set_timeout(tcase, 60);
    return suite;
  }
diff -crB --unidirectional-new-file galera-23.2.2-src/SConstruct 2.x/SConstruct
*** galera-23.2.2-src/SConstruct	2012-10-26 19:48:39.000000000 +0800
--- 2.x/SConstruct	2013-03-08 19:49:02.370351000 +0800
***************
*** 30,41 ****
  Default target: all
  
  Commandline Options:
!     debug=n        debug build with optimization level n
!     arch=str       target architecture [i686|x86_64]
!     build_dir=dir  build directory, default: '.'
!     boost=[0|1]    disable or enable boost libraries
!     revno=XXXX     source code revision number
!     bpostatic=path a path to static libboost_program_options.a
  ''')
  # bpostatic option added on Percona request
  
--- 30,42 ----
  Default target: all
  
  Commandline Options:
!     debug=n          debug build with optimization level n
!     arch=str         target architecture [i686|x86_64]
!     build_dir=dir    build directory, default: '.'
!     boost=[0|1]      disable or enable boost libraries
!     boost_pool=[0|1] use or not use boost pool allocator
!     revno=XXXX       source code revision number
!     bpostatic=path   a path to static libboost_program_options.a
  ''')
  # bpostatic option added on Percona request
  
***************
*** 95,104 ****
      print 'Unsupported target architecture: ' + arch
      Exit(1)
  
! boost = int(ARGUMENTS.get('boost', 1))
! ssl   = int(ARGUMENTS.get('ssl', 1))
  
! GALERA_VER = ARGUMENTS.get('version', '2.2')
  GALERA_REV = ARGUMENTS.get('revno', 'XXXX')
  # export to any module that might have use of those
  Export('GALERA_VER', 'GALERA_REV')
--- 96,106 ----
      print 'Unsupported target architecture: ' + arch
      Exit(1)
  
! boost      = int(ARGUMENTS.get('boost', 1))
! boost_pool = int(ARGUMENTS.get('boost_pool', 1))
! ssl        = int(ARGUMENTS.get('ssl', 1))
  
! GALERA_VER = ARGUMENTS.get('version', '2.3')
  GALERA_REV = ARGUMENTS.get('revno', 'XXXX')
  # export to any module that might have use of those
  Export('GALERA_VER', 'GALERA_REV')
***************
*** 254,264 ****
      conf.env.Append(CPPFLAGS = ' -DBOOST_DATE_TIME_POSIX_TIME_STD_CONFIG=1')
      # Required boost headers/libraries
      #
!     if conf.CheckCXXHeader('boost/pool/pool_alloc.hpp'):
!         print 'Using boost pool alloc'
!         conf.env.Append(CPPFLAGS = ' -DGALERA_USE_BOOST_POOL_ALLOC=1')
!     else:
!         print 'Error: boost/pool/pool_alloc.hpp not found or not usable'
  else:
      print 'Not using boost'
  
--- 256,268 ----
      conf.env.Append(CPPFLAGS = ' -DBOOST_DATE_TIME_POSIX_TIME_STD_CONFIG=1')
      # Required boost headers/libraries
      #
!     if boost_pool == 1:
!         if conf.CheckCXXHeader('boost/pool/pool_alloc.hpp'):
!             print 'Using boost pool alloc'
!             conf.env.Append(CPPFLAGS = ' -DGALERA_USE_BOOST_POOL_ALLOC=1')
!         else:
!             print 'Error: boost/pool/pool_alloc.hpp not found or not usable'
!             Exit(1)
  else:
      print 'Not using boost'
  
diff -crB --unidirectional-new-file galera-23.2.2-src/scripts/build.sh 2.x/scripts/build.sh
*** galera-23.2.2-src/scripts/build.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/scripts/build.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 1,6 ****
  #!/bin/bash -eu
  
! # $Id: build.sh 2745 2012-03-17 00:00:23Z alex $
  
  get_cores()
  {
--- 1,6 ----
  #!/bin/bash -eu
  
! # $Id: build.sh 2915 2012-12-26 02:06:55Z alex $
  
  get_cores()
  {
***************
*** 37,42 ****
--- 37,43 ----
      --source        build source packages
      --sb            skip actual build, use the existing binaries
      --scons         build using Scons build system (yes)
+     --so            Sconscript option
      -j|--jobs       how many parallel jobs to use for Scons (1)
      "\nSet DISABLE_GCOMM/DISABLE_VSBES to 'yes' to disable respective modules"
  EOF
***************
*** 52,57 ****
--- 53,59 ----
  DEBUG=${DEBUG:-"no"}
  DEBUG_LEVEL=${DEBUG_LEVEL:-"1"}
  SCONS=${SCONS:-"yes"}
+ SCONS_OPTS=${SCONS_OPTS:-""}
  JOBS=${JOBS:-"$(get_cores)"}
  SCRATCH=${SCRATCH:-"no"}
  OPT="yes"
***************
*** 144,149 ****
--- 146,155 ----
  	--scons)
  	    SCONS="yes"
  	    ;;
+ 	--so)
+ 	    SCONS_OPTS="$SCONS_OPTS $2"
+ 	    shift
+ 	    ;;
  	-j|--jobs)
  	    JOBS=$2
  	    shift
***************
*** 312,323 ****
  
      if [ "$SCRATCH" == "yes" ]
      then
!         scons -Q -c --conf=force $scons_args
      fi
  
      if [ "$SKIP_BUILD" != "yes" ]
      then
!         scons $scons_args -j $JOBS
      fi
  
  elif test "$SKIP_BUILD" == "no"; then # Build using autotools
--- 318,329 ----
  
      if [ "$SCRATCH" == "yes" ]
      then
!         scons -Q -c --conf=force $scons_args $SCONS_OPTS
      fi
  
      if [ "$SKIP_BUILD" != "yes" ]
      then
!         scons $scons_args -j $JOBS $SCONS_OPTS
      fi
  
  elif test "$SKIP_BUILD" == "no"; then # Build using autotools
diff -crB --unidirectional-new-file galera-23.2.2-src/scripts/mysql/debian/mysqld_safe-5.5 2.x/scripts/mysql/debian/mysqld_safe-5.5
*** galera-23.2.2-src/scripts/mysql/debian/mysqld_safe-5.5	2012-10-26 19:48:39.000000000 +0800
--- 2.x/scripts/mysql/debian/mysqld_safe-5.5	2013-03-08 19:49:02.370351000 +0800
***************
*** 121,127 ****
  }
  
  eval_log_error () {
!   cmd="$1"
    case $logging in
      file) cmd="$cmd >> "`shell_quote_string "$err_log"`" 2>&1" ;;
      syslog)
--- 121,127 ----
  }
  
  eval_log_error () {
!   local cmd="$1"
    case $logging in
      file) cmd="$cmd >> "`shell_quote_string "$err_log"`" 2>&1" ;;
      syslog)
***************
*** 180,189 ****
  # Run mysqld with --wsrep-recover and parse recovered position from log.
  # Position will be stored in wsrep_start_position_opt global.
  wsrep_recovery() {
!   cmd="$@"
    wr_logfile=$(mktemp)
!   log_notice "WSREP: Running position recovery"
!   $cmd --log_error=$wr_logfile --wsrep-recover
    rp=$(grep "WSREP: Recovered position:" $wr_logfile)
    if [ -z "$rp" ]; then
      skipped=$(grep WSREP $wr_logfile | grep "skipping position recovery")
--- 180,191 ----
  # Run mysqld with --wsrep-recover and parse recovered position from log.
  # Position will be stored in wsrep_start_position_opt global.
  wsrep_recovery() {
!   local mysqld_cmd="$@"
    wr_logfile=$(mktemp)
!   [ `id -u` = "0" ] && chown $user $wr_logfile
!   chmod 600 $wr_logfile
!   log_notice "WSREP: Running position recovery with --log_error=$wr_logfile"
!   $mysqld_cmd --log_error=$wr_logfile --wsrep-recover
    rp=$(grep "WSREP: Recovered position:" $wr_logfile)
    if [ -z "$rp" ]; then
      skipped=$(grep WSREP $wr_logfile | grep "skipping position recovery")
***************
*** 888,893 ****
--- 890,897 ----
        I=`expr $I + 1`
      done
    fi
+   log_notice "WSREP: sleeping 15 seconds before restart"
+   sleep 15
    log_notice "mysqld restarted"
  done
  
diff -crB --unidirectional-new-file galera-23.2.2-src/scripts/mysql/mysql-galera 2.x/scripts/mysql/mysql-galera
*** galera-23.2.2-src/scripts/mysql/mysql-galera	2012-10-26 19:48:39.000000000 +0800
--- 2.x/scripts/mysql/mysql-galera	2013-03-08 19:49:02.370351000 +0800
***************
*** 87,92 ****
--- 87,95 ----
  #DEBUG_OPTS=" --debug "
  #DEBUG_OPTS=" --debug=d,galera,wsdb:t:i:o,$MYSQL_DATA_DIR/mysqld.trc"
  
+ SKIP_RECOVERY=0
+ START_POSITION=""
+ 
  err_log="$MYSQL_DATA_DIR/$(hostname).err"
  mysql_log="$MYSQL_DATA_DIR/$(hostname).log"
  
***************
*** 114,119 ****
--- 117,124 ----
      --ws_level        : RBR (default) or SQL
      -P|--port         : port for MySQL client connections
      -S|--socket       : location of mysqld socket
+     --skip-recovery   : skip recovery phase
+     --start-position  : start position passed to server
  
  Commands:
  check                 : check cosistency of database given with --db option
***************
*** 189,194 ****
--- 194,229 ----
      fi
  }
  
+ wsrep_start_position_opt=""
+ 
+ # Run mysqld with --wsrep-recover and parse recovered position from log.
+ # Position will be stored in wsrep_start_position_opt global.
+ wsrep_recovery() {
+   cmd="$@"
+   wr_logfile=$(mktemp)
+   echo "WSREP: Running position recovery"
+   set +e
+   $cmd --log_error=$wr_logfile --wsrep-recover
+   rp=$(grep "WSREP: Recovered position:" $wr_logfile)
+   if [ -z "$rp" ]; then
+     skipped=$(grep WSREP $wr_logfile | grep "skipping position recovery")
+     if [ -z "$skipped" ]; then
+       echo "WSREP: Failed to recover position: " \
+           `cat $wr_logfile`;
+     else
+       echo "WSREP: Position recovery skipped"
+     fi
+   else
+     start_pos=$(echo $rp | sed 's/.*WSREP\:\ Recovered\ position://' \
+         | sed 's/^[ \t]*//')
+     wsrep_start_position_opt="--wsrep_start_position=$start_pos"
+     echo "WSREP: Recovered position $start_pos"
+   fi
+   set -e
+   rm $wr_logfile
+ }
+ 
+ 
  galera_start()
  {
      local failed
***************
*** 247,252 ****
--- 282,316 ----
      fi
  
      echo -n "Starting mysqld instance with data dir $MYSQL_DATA_DIR and listening at port $MYSQL_PORT and socket $MYSQL_SOCKET..."
+     ulimit -n 4096 # This is normally allowed for non-privileged users
+ 
+     if test $SKIP_RECOVERY = 0
+     then
+         wsrep_recovery $MYSQLD \
+             $DEFAULTS_OPTION \
+             --user="$MYSQLD_USER" \
+             --basedir="$MYSQL_BASE_DIR" \
+             --datadir="$MYSQL_DATA_DIR" \
+             --plugin-dir=lib/mysql/plugin \
+             --pid-file="$MYSQL_PID" \
+             --port=$MYSQL_PORT \
+             --socket=$MYSQL_SOCKET \
+             --skip-external-locking \
+             --log_error=$err_log \
+             $MYSQLD_OPTS \
+             $INNODB_OPTS \
+             $WSREP_OPTS \
+             $DEBUG_OPTS \
+             $LOGGING_OPTS \
+             $RBR_OPTS \
+             $PLUGIN_OPTS
+     else
+         echo "skipping recovery"
+         if test -n "$START_POSITION"
+         then
+             wsrep_start_position_opt="--wsrep-start-position=$START_POSITION"
+         fi
+     fi
  
      if test -z $GDB
      then
***************
*** 268,273 ****
--- 332,338 ----
              $LOGGING_OPTS \
              $RBR_OPTS \
              $PLUGIN_OPTS \
+             $wsrep_start_position_opt \
              1>/dev/null 2>>$err_log &
      else
          $GDB --args $MYSQLD \
***************
*** 286,292 ****
              $DEBUG_OPTS \
              $LOGGING_OPTS \
              $RBR_OPTS \
!             $PLUGIN_OPTS
      fi
      my_pid=$!
  
--- 351,358 ----
              $DEBUG_OPTS \
              $LOGGING_OPTS \
              $RBR_OPTS \
!             $PLUGIN_OPTS \
!             $wsrep_start_position_opt
      fi
      my_pid=$!
  
***************
*** 509,514 ****
--- 575,587 ----
              MYSQL_SOCKET="$2"
              shift
              ;;
+     --skip-recovery)
+             SKIP_RECOVERY=1
+             ;;
+     --start-position)
+             START_POSITION="$2"
+             shift
+             ;;
  'dump')
              COMMAND="dump"
              ;;
***************
*** 533,538 ****
--- 606,612 ----
              ;;
      *)
          # must be command
+             echo "error parsing: $@"
              usage
              exit 1
              ;;
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/conf/cluster.conf.tmpl 2.x/tests/conf/cluster.conf.tmpl
*** galera-23.2.2-src/tests/conf/cluster.conf.tmpl	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/conf/cluster.conf.tmpl	2013-03-08 19:49:02.370351000 +0800
***************
*** 2,12 ****
  # Cluster resources configuration.
  #
  
- # List of available nodes, preferably IP addresses.
- # If hostnames are used, /etc/hosts file should be up to date
- # on each network node.
- export CLUSTER_NODES=${CLUSTER_NODES:-"gw vs1 vs2"}
- 
  # DBMS that will be used for tests
  export DBMS=${DBMS:-"MYSQL"}
  
--- 2,7 ----
***************
*** 21,31 ****
  # DBMS schema to use for tests
  export DBMS_TEST_SCHEMA=${DBMS_TEST_SCHEMA:-"test"}
  
- # is this needed?
- ## Base directory where MySQL is installed in. May also be 
- ## symbolic link pointing to real directory
- #export MYSQL_BASE=${MYSQL_BASE:-"~/galera/mysql"}
- 
  # Host for clients to connect to
  export DBMS_HOST=${DBMS_HOST:-"127.0.0.1"}
  
--- 16,21 ----
***************
*** 60,69 ****
--- 50,64 ----
  #
  # export GCOMM_EXTRA_PARAMS=${GCOMM_EXTRA_PARAMS:-"gmcast.mcast_addr=239.192.0.11"}
  
+ # default replication port
  export GCS_PORT=4567
  
+ # common part of my.cnf
  export COMMON_MY_CNF=$BASE_CONF/common_my.cnf
  
+ # libglb.so location if not standard (/usr/lib|/usr/local/lib)
+ #GLB_LIB=
+ 
  . $BASE_CONF/nodes.conf
  
  # end
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/conf/main.conf 2.x/tests/conf/main.conf
*** galera-23.2.2-src/tests/conf/main.conf	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/conf/main.conf	2013-03-08 19:49:02.370351000 +0800
***************
*** 6,8 ****
--- 6,49 ----
  declare -r BASE_CONF="$TEST_BASE/conf"
  
  . ${CLUSTER_CONF:-"$BASE_CONF/cluster.conf"}
+ 
+ # The code below tries to find available libglb.so and if found, export
+ # necessary variables for client side load balancing
+ GLB_LIB=${GLB_LIB:-""}
+ if [ ! -r "$GLB_LIB" ]
+ then
+     if [ -r /usr/local/lib/libglb.so ]
+     then
+         GLB_LIB="/usr/local/lib/libglb.so"
+     elif [ -r /usr/lib/libglb.so ]
+     then
+         GLB_LIB="/usr/lib/libglb.so"
+     fi
+ fi
+ 
+ if [ -r "$GLB_LIB" ]
+ then
+     LD_PRELOAD=${LD_PRELOAD:-""}
+     if [ -n "$LD_PRELOAD" ]
+     then
+         export LD_PRELOAD="$GLB_LIB:$LD_PRELOAD"
+     else
+         export LD_PRELOAD="$GLB_LIB"
+     fi
+ 
+     export GLB_BIND=$DBMS_HOST:$DBMS_PORT
+ 
+     GLB_TARGETS=""
+     for node in $NODE_LIST
+     do
+         target=${NODE_INCOMING_HOST[$node]}:${NODE_INCOMING_PORT[$node]}
+         if [ $node -ne $NODE_MAX ]
+         then
+             GLB_TARGETS="$GLB_TARGETS$target,"
+         else
+             GLB_TARGETS="$GLB_TARGETS$target"
+         fi
+     done
+     export GLB_TARGETS
+ fi
+ 
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/regressions/lp1073220/run.sh 2.x/tests/regressions/lp1073220/run.sh
*** galera-23.2.2-src/tests/regressions/lp1073220/run.sh	1970-01-01 08:00:00.000000000 +0800
--- 2.x/tests/regressions/lp1073220/run.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,58 ----
+ #!/bin/bash -e
+ #
+ # lp:861212
+ # https://bugs.launchpad.net/codership-mysql/+bug/861212
+ #
+ # TEST SETUP
+ #
+ # This test starts two nodes and runs mixed DML/DDL load described in
+ #
+ #   https://bugs.launchpad.net/codership-mysql/+bug/861212/comments/2
+ #
+ # for some time.
+ #
+ # PARAMETERS
+ #
+ # Number of test rounds
+ ROUNDS=${ROUNDS:-"200"}
+ # Duration of single iteration
+ DURATION=${DURATION:-"3"}
+ #
+ #
+ 
+ 
+ declare -r DIST_BASE=$(cd $(dirname $0)/../..; pwd -P)
+ TEST_BASE=${TEST_BASE:-"$DIST_BASE"}
+ 
+ . $TEST_BASE/conf/main.conf
+ declare -r SCRIPTS="$DIST_BASE/scripts"
+ . $SCRIPTS/jobs.sh
+ . $SCRIPTS/action.sh
+ . $SCRIPTS/kill.sh
+ . $SCRIPTS/misc.sh
+ 
+ echo "##################################################################"
+ echo "##             regression test for lp:861212"
+ echo "##################################################################"
+ 
+ echo "restarting cluster to clean state"
+ restart
+ 
+ 
+ echo "starting load for $DURATION" seconds
+ SQLGEN=${SQLGEN:-"$DIST_BASE/bin/sqlgen"}
+ 
+ round=0
+ while test $round -lt $ROUNDS
+ do
+     $SQLGEN --user $DBMS_TEST_USER --pswd $DBMS_TEST_PSWD --host $DBMS_HOST \
+         --port $DBMS_PORT --users $DBMS_CLIENTS --duration $DURATION \
+     --stat-interval 30 --rows 1000 --ac-frac 10 --rollbacks 0.1 --alters 1
+ 
+     echo "checking consistency"
+     check || (sleep 5 && check)
+     round=$(($round + 1))
+ done
+ 
+ echo "stopping cluster"
+ stop
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/regressions/lp1089490/run.sh 2.x/tests/regressions/lp1089490/run.sh
*** galera-23.2.2-src/tests/regressions/lp1089490/run.sh	1970-01-01 08:00:00.000000000 +0800
--- 2.x/tests/regressions/lp1089490/run.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,163 ----
+ #!/bin/bash 
+ ##
+ #
+ # lp:1089490
+ # https://bugs.launchpad.net/codership-mysql/+bug/1089490
+ #
+ # BUG BACKGRPOUND:
+ #
+ # Foreign keys can cause slave crash if following conditions are met:
+ # 1. foreign key constraint has been defined with CASCADE ON DELETE option
+ # 2. foreign key constraint has mixed NULL options in referencing columns
+ #  (i.e. client column defined with NOT NULL option and parent column 
+ #   with NULL option)
+ # 3. slave is configured with multiple slave threads (wsrep_slave_threads > 1)
+ # 4. work load has conflicting DELETE operations for parent and child table
+ #
+ # TEST SETUP:
+ #   - Two nodes are used in master slave mode. 
+ #   - Slave is configured with 4 applier threads
+ #   - parent and child tables are created and populated
+ #   - test load runs two separate connections, where other session deletes
+ #     rows from parent table and other sessions delete rows from child table, 
+ #     one by one
+ # Due to the cascade on delete, option, the delete from parent table will issue
+ # delete for the child table, and this cascaded delete may conflict with the 
+ # direct delete on child table
+ #
+ # SUCCESS CRITERIA
+ #
+ # If bug is present, slave will crash for not being able to delete a row from
+ # child table
+ #
+ declare -r DIST_BASE=$(cd $(dirname $0)/../..; pwd -P)
+ TEST_BASE=${TEST_BASE:-"$DIST_BASE"}
+ 
+ . $TEST_BASE/conf/main.conf
+ declare -r SCRIPTS="$DIST_BASE/scripts"
+ . $SCRIPTS/jobs.sh
+ . $SCRIPTS/action.sh
+ . $SCRIPTS/kill.sh
+ . $SCRIPTS/misc.sh
+ 
+ echo "##################################################################"
+ echo "##             regression test for lp:1089490"
+ echo "##################################################################"
+ echo "stopping cluster"
+ ../../scripts/command.sh stop
+ echo
+ echo "starting node0, node1..."
+ ../../scripts/command.sh start "-d  --slave_threads 4"
+ 
+ MYSQL="mysql --batch --silent --user=$DBMS_TEST_USER --password=$DBMS_TEST_PSWD --host=$DBMS_HOST test "
+ 
+ declare -r port_0=${NODE_INCOMING_PORT[0]}
+ declare -r port_1=${NODE_INCOMING_PORT[1]}
+ 
+ inserter()
+ {
+     local port=$1
+     for i in {1..1000}; do
+ 	$MYSQL --port=$port -e "
+           INSERT INTO test.lp1089490_parent(pk, j) VALUES($i, $i); 
+           INSERT INTO test.lp1089490_child(i,fk) VALUES ($i, $i); 
+         " 2>&1
+     done
+ }
+ 
+ delete_parent()
+ {
+     local port=$1
+     for i in {1..1000}; do
+ 	$MYSQL --port=$port -e "
+           DELETE FROM test.lp1089490_parent WHERE pk=$i; 
+         " 2>&1
+     done
+ }
+ 
+ delete_child()
+ {
+     local port=$1
+     for i in {1..1000}; do
+ 	$MYSQL --port=$port -e "
+           DELETE FROM  test.lp1089490_child WHERE i=$i; 
+         " 2>&1
+     done
+ }
+ 
+ createdb()
+ { 
+     $MYSQL --port=$port_0 -e "reset master;"
+     $MYSQL --port=$port_1 -e "reset master;"
+ 
+     $MYSQL --port=$port_0 -e "
+         DROP TABLE IF EXISTS test.lp1089490_child;"
+ 
+     $MYSQL --port=$port_0 -e '
+         DROP TABLE IF EXISTS test.lp1089490_parent;'
+ 
+     $MYSQL --port=$port_0 -e '
+         CREATE TABLE test.lp1089490_parent
+         (
+            pk INT PRIMARY KEY AUTO_INCREMENT,
+            j int
+         )'
+ 
+     $MYSQL --port=$port_0 -e "
+         CREATE TABLE test.lp1089490_child
+         (
+             i INT PRIMARY KEY AUTO_INCREMENT, 
+             fk int, 
+             CONSTRAINT  FOREIGN KEY (fk) REFERENCES test.lp1089490_parent(pk) 
+             ON DELETE CASCADE
+         )"
+ }
+ 
+ #########################################################
+ #
+ # Test begins here
+ #
+ #########################################################
+ 
+ threads=$($MYSQL --port=$port_1 -e "SHOW VARIABLES LIKE 'wsrep_slave_threads'")
+ 
+ echo "applier check: $threads"
+ [ "$threads" = "wsrep_slave_threads	4" ] || { echo "NOT ENOUGH SLAVES"; exit 1; }
+ 
+ echo "Creating database..."
+ createdb
+ 
+ for i in {1..20}; do
+     echo
+     echo "### round $i ###"
+ 
+     echo "populating database..."
+     inserter $port_0
+ 
+     echo "starting delete for parent table"
+     delete_parent $port_0 &
+     declare parent_pid=$!
+ 
+     echo "starting delete for child table"
+     delete_child $port_0 &
+     declare child_pid=$!
+ 
+     echo "waiting load to end ($parent_pid $child_pid)"
+     wait
+ done
+ 
+ $MYSQL --port=$port_0 -e 'SHOW PROCESSLIST'
+ echo
+ $MYSQL --port=$port_1 -e 'SHOW PROCESSLIST'
+ [ "$?" != "0" ] && echo "failed!" && exit 1
+ 
+ $SCRIPTS/command.sh check
+ 
+ echo
+ echo "Done!"
+ echo
+ 
+ ../../scripts/command.sh stop
+ 
+ exit 0
+ 
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/regressions/run-all.sh 2.x/tests/regressions/run-all.sh
*** galera-23.2.2-src/tests/regressions/run-all.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/regressions/run-all.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 1,6 ****
  #!/bin/bash
  
! tests="lp1003929
         lp1013978
         lp1026181
         lp1055961
--- 1,8 ----
  #!/bin/bash
  
! tests="lp1089490
!        lp1073220
!        lp1003929
         lp1013978
         lp1026181
         lp1055961
***************
*** 35,38 ****
          echo "test $ii failed"
          exit 1
      fi
! done
\ No newline at end of file
--- 37,40 ----
          echo "test $ii failed"
          exit 1
      fi
! done
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/scripts/action.sh 2.x/tests/scripts/action.sh
*** galera-23.2.2-src/tests/scripts/action.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/scripts/action.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 3,23 ****
  cluster_status()
  {
      local node=$1
-     local status_str=""
      case "$DBMS" in
          "MYSQL")
!             echo -n $(mysql -u$DBMS_ROOT_USER -p$DBMS_ROOT_PSWD \
                  -h${NODE_INCOMING_HOST[$node]} -P${NODE_INCOMING_PORT[$node]} \
                  --skip-column-names -ss \
!                 -e "SET wsrep_on=0; SHOW STATUS WHERE Variable_name LIKE 'wsrep_cluster_status'
!                     OR Variable_name LIKE 'wsrep_cluster_size'" 2>/dev/null) \
!                         | awk '{ print $4 ":" $2; }'
              ;;
          "PGSQL"|*)
              return -1
      esac
  }
  
  #
  # Routines to start|stop|check cluster nodes
  #
--- 3,55 ----
  cluster_status()
  {
      local node=$1
      case "$DBMS" in
          "MYSQL")
!             local res=$(mysql -u$DBMS_ROOT_USER -p$DBMS_ROOT_PSWD \
                  -h${NODE_INCOMING_HOST[$node]} -P${NODE_INCOMING_PORT[$node]} \
                  --skip-column-names -ss \
!                 -e "SET wsrep_on=0;
!                     SHOW STATUS WHERE Variable_name LIKE 'wsrep_cluster_status'
!                     OR Variable_name LIKE 'wsrep_cluster_size'" 2>/dev/null)
!             echo -n $res | awk '{ print $4 ":" $2; }'
              ;;
          "PGSQL"|*)
              return -1
      esac
  }
  
+ mysql_query()
+ {
+     local node=$1
+     local query=$2
+     mysql -u$DBMS_ROOT_USER -p$DBMS_ROOT_PSWD \
+           -h${NODE_INCOMING_HOST[$node]} -P${NODE_INCOMING_PORT[$node]} \
+           --skip-column-names -ss -e "$query" 2>/dev/null
+ }
+ 
+ wait_node_state()
+ {
+     local node=$1
+     local state=$2
+ 
+     while true
+     do
+         local res="-1"
+ 
+         case "$DBMS" in
+         "MYSQL")
+             res=$(mysql_query $node "SHOW STATUS LIKE 'wsrep_local_state'" \
+                   | awk '{ print $2 }')
+             ;;
+         "PGSQL"|*)
+             return -1
+         esac
+ 
+         if [ "$res" = "$state" ]; then break; fi
+         sleep 1
+     done
+ }
+ 
  #
  # Routines to start|stop|check cluster nodes
  #
***************
*** 168,174 ****
      local node=$1
      local extra_params
      [ -z "$GCOMM_EXTRA_PARAMS" ] && extra_params="?" || extra_params="?${GCOMM_EXTRA_PARAMS}&"
!     echo "${extra_params}gmcast.listen_addr=tcp://${NODE_GCS_HOST[$node]}:${NODE_GCS_PORT[$node]}"
  }
  
  # return GCS address at which node N should connect to group
--- 200,207 ----
      local node=$1
      local extra_params
      [ -z "$GCOMM_EXTRA_PARAMS" ] && extra_params="?" || extra_params="?${GCOMM_EXTRA_PARAMS}&"
! #    echo "${extra_params}gmcast.listen_addr=tcp://${NODE_GCS_HOST[$node]}:${NODE_GCS_PORT[$node]}"
!     echo "${extra_params}gmcast.listen_addr=tcp://0.0.0.0:${NODE_GCS_PORT[$node]}"
  }
  
  # return GCS address at which node N should connect to group
***************
*** 232,244 ****
          start_node "-g $(gcs_address $node)" "$@" $node &
          cnt=$(($cnt + 1))
      done
      # TODO: Poll until all have reached non-prim
!     for node in $NODE_LIST
      do
          while true
          do
              st=$(cluster_status $node)
!             if test "x$st" == "xnon-Primary:$cnt"
              then
                  break;
              fi
--- 265,278 ----
          start_node "-g $(gcs_address $node)" "$@" $node &
          cnt=$(($cnt + 1))
      done
+ 
      # TODO: Poll until all have reached non-prim
!     for node in 0 # only one node is sufficient
      do
          while true
          do
              st=$(cluster_status $node)
!             if test "x$st" = "xnon-Primary:$cnt"
              then
                  break;
              fi
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/scripts/install.sh 2.x/tests/scripts/install.sh
*** galera-23.2.2-src/tests/scripts/install.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/scripts/install.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 36,42 ****
  
      if [ -n "$common_cnf" ] || [ -n "$cnf_src" ]
      then
!         if [ "${NODE_LOCATION[$node]}" == "local" ]
          then
              ([ -n "$common_cnf" ] && cat "$common_cnf" && \
               [ -n "$cnf_src" ]    && cat "$cnf_src") > "$cnf_dst"
--- 36,42 ----
  
      if [ -n "$common_cnf" ] || [ -n "$cnf_src" ]
      then
!         if [ "${NODE_LOCATION[$node]}" = "local" ]
          then
              ([ -n "$common_cnf" ] && cat "$common_cnf" && \
               [ -n "$cnf_src" ]    && cat "$cnf_src") > "$cnf_dst"
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/scripts/jobs.sh 2.x/tests/scripts/jobs.sh
*** galera-23.2.2-src/tests/scripts/jobs.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/scripts/jobs.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 34,40 ****
      local out="$BASE_OUT/${1}_${NODE_ID[$node]}.out"
      local cmd="$($@)"
  
!     if [ "${NODE_LOCATION[$node]}" == "local" ]
      then
  #        local_job "$cmd" 1>"$out"
          eval "$cmd" 1>"$out"
--- 34,40 ----
      local out="$BASE_OUT/${1}_${NODE_ID[$node]}.out"
      local cmd="$($@)"
  
!     if [ "${NODE_LOCATION[$node]}" = "local" ]
      then
  #        local_job "$cmd" 1>"$out"
          eval "$cmd" 1>"$out"
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/test_overhead/run.sh 2.x/tests/test_overhead/run.sh
*** galera-23.2.2-src/tests/test_overhead/run.sh	1970-01-01 08:00:00.000000000 +0800
--- 2.x/tests/test_overhead/run.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 0 ****
--- 1,92 ----
+ #!/bin/bash -eu
+ 
+ # This test measures master replication overhead by running a number of
+ # autocommit queries with wsrep_on set to 0 and 1.
+ #
+ # NOTES:
+ # - The load was deliberately chosen to produce maximum replication overhead.
+ # - SQL commands are first dumped into a text file in order to minimize client
+ #   overhead when benchmarking.
+ 
+ declare -r DIST_BASE=$(cd $(dirname $0)/..; pwd -P)
+ TEST_BASE=${TEST_BASE:-"$DIST_BASE"}
+ 
+ . $TEST_BASE/conf/main.conf
+ 
+ declare -r SCRIPTS="$DIST_BASE/scripts"
+ . $SCRIPTS/jobs.sh
+ . $SCRIPTS/action.sh
+ 
+ restart
+ 
+ for node in $(seq 1 $NODE_MAX)
+ do
+     stop_node $node
+ done
+ 
+ declare -r SQL="$(dirname $0)/tmp.sql"
+ declare -r TABLE="overhead"
+ declare -r TABLE_DEFINITION="(pk INT PRIMARY KEY, u VARCHAR(64))"
+ declare -r MAX_ROWS=50000
+ 
+ insert_load()
+ {
+     local WSREP_ON=$1
+     echo "USE $DBMS_TEST_SCHEMA; SET GLOBAL wsrep_on=$WSREP_ON; "
+ #    echo "BEGIN; "
+     for i in $(seq 1 $MAX_ROWS)
+     do
+         echo "INSERT INTO $TABLE VALUES ($i, uuid()); "
+     done
+ #    echo "COMMIT;"
+ }
+ 
+ update_load()
+ {
+     local WSREP_ON=$1
+     echo "USE $DBMS_TEST_SCHEMA; SET GLOBAL wsrep_on=$WSREP_ON; "
+ #    echo "BEGIN; "
+     for i in $(seq 1 $MAX_ROWS)
+     do
+         local PK=$(( $RANDOM * $RANDOM % $MAX_ROWS))
+         echo "UPDATE $TABLE SET u = uuid() WHERE pk = $PK; "
+     done
+ #    echo "COMMIT;"
+ }
+ 
+ MYSQL="mysql -u$DBMS_TEST_USER -p$DBMS_TEST_PSWD"
+ MYSQL="$MYSQL -h${NODE_INCOMING_HOST[0]} -P${NODE_INCOMING_PORT[0]} -B"
+ 
+ warm_up()
+ {
+     echo -n "Warming up: "
+     $MYSQL -e "DROP TABLE IF EXISTS $DBMS_TEST_SCHEMA.$TABLE"
+     $MYSQL -e "CREATE TABLE $DBMS_TEST_SCHEMA.$TABLE $TABLE_DEFINITION"
+     insert_load 1 > $SQL # generate sql commands
+     /usr/bin/time -o /dev/stdout -f '%e' $MYSQL < $SQL
+ }
+ 
+ warm_up
+ 
+ declare -a INSERTS
+ declare -a UPDATES
+ 
+ for wsrep in 0 1
+ do
+     $MYSQL -e "DROP TABLE IF EXISTS $DBMS_TEST_SCHEMA.$TABLE"
+     $MYSQL -e "CREATE TABLE $DBMS_TEST_SCHEMA.$TABLE $TABLE_DEFINITION"
+     echo -n "wsrep_on = $wsrep :  "
+     insert_load $wsrep > $SQL # generate sql commands
+     TIMING=$(/usr/bin/time -o /dev/stdout -f '%e' $MYSQL < $SQL)
+     echo -n "${TIMING} / "
+     INSERTS[$wsrep]=$(echo -n ${TIMING} | sed s/\\.//)
+     update_load $wsrep > $SQL # generate sql commands
+     TIMING=$(/usr/bin/time -o /dev/stdout -f '%e' $MYSQL < $SQL)
+     echo "${TIMING}"
+     UPDATES[$wsrep]=$(echo -n ${TIMING} | sed s/\\.//)
+ done
+ 
+ INSERT_OVERHEAD=$(( ${INSERTS[1]} * 100 / ${INSERTS[0]} - 100))
+ UPDATE_OVERHEAD=$(( ${UPDATES[1]} * 100 / ${UPDATES[0]} - 100))
+ echo "Overhead: $INSERT_OVERHEAD% / $UPDATE_OVERHEAD%"
+ 
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/test_seesaw/run.sh 2.x/tests/test_seesaw/run.sh
*** galera-23.2.2-src/tests/test_seesaw/run.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/test_seesaw/run.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 12,17 ****
--- 12,19 ----
  . $SCRIPTS/misc.sh
  
  TRIES=${1:-"-1"} # -1 stands for indefinite loop
+ KILL_RATE=${KILL_RATE:-"3"}
+ SST_RATE=${SST_RATE:-"2"}
  
  #restart # cluster restart should be triggered by user
  
***************
*** 46,52 ****
      local -r node_id=${NODE_ID[$node]}
  
      local pause_var=10
!     local var_kill=$(( $RANDOM % 3 ))
  
      if [ $var_kill -eq 0 ]
      then
--- 48,54 ----
      local -r node_id=${NODE_ID[$node]}
  
      local pause_var=10
!     local var_kill=$(( $RANDOM % $KILL_RATE ))
  
      if [ $var_kill -eq 0 ]
      then
***************
*** 69,80 ****
  
      echo "Restarting node $node_id..."
  
      if test $pause_var -gt 3
      then
!         restart_node "-g $(gcs_address $node)" $node
      else
          stop_node $node || : # just in case the process is still lingering
!         restart_node "-g $(gcs_address $node)" $node
      fi
  }
  
--- 71,89 ----
  
      echo "Restarting node $node_id..."
  
+     local skip_recovery_opt=""
+     if [ $var_kill -eq 0 ] && [ $(($RANDOM % $SST_RATE)) -eq 0 ]
+     then
+         echo "Enforcing SST"
+         skip_recovery_opt="--skip-recovery --start-position '00000000-0000-0000-0000-000000000000:-2'"
+     fi
+ 
      if test $pause_var -gt 3
      then
!         restart_node "-g $(gcs_address $node) $skip_recovery_opt" $node
      else
          stop_node $node || : # just in case the process is still lingering
!         restart_node "-g $(gcs_address $node) $skip_recovery_opt" $node
      fi
  }
  
diff -crB --unidirectional-new-file galera-23.2.2-src/tests/test_stopcont/run.sh 2.x/tests/test_stopcont/run.sh
*** galera-23.2.2-src/tests/test_stopcont/run.sh	2012-10-26 19:48:39.000000000 +0800
--- 2.x/tests/test_stopcont/run.sh	2013-03-08 19:49:02.370351000 +0800
***************
*** 51,56 ****
--- 51,61 ----
  
      echo "Signaling node $node_id with CONT..."
      signal_node CONT $node
+ 
+     sleep 10 # this pause needed to get node to notice that it lost the PC
+              # if it did...
+ 
+     wait_node_state $node 4 # 4 - SYNCED
  }
  
  node=0
***************
*** 67,73 ****
  
      cycle $node
  
-     pause 1 5
      consistency_check $sqlgen_pid
      pause 2
  
--- 72,77 ----
