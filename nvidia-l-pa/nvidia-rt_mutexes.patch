diff -Naur a/nv.c b/nv.c
--- a/nv.c	2012-12-04 23:42:53.000000000 +0100
+++ b/nv.c	2012-12-04 20:57:00.000000000 +0100
@@ -603,10 +603,10 @@
     nv_alloc_t *at
 )
 {
-    down(&nvl->at_lock);
+    mutex_lock(&nvl->at_lock);
     at->next = nvl->alloc_queue;
     nvl->alloc_queue = at;
-    up(&nvl->at_lock);
+    mutex_unlock(&nvl->at_lock);
     return 0;
 }
 
@@ -1427,7 +1427,7 @@
 
     nv = NV_STATE_PTR(nvl);
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
 
     UNLOCK_NV_LINUX_DEVICES();
 
@@ -1630,7 +1630,7 @@
         if (nvl->isr_sp != NULL)
             NV_KMEM_CACHE_FREE_STACK(nvl->isr_sp);
     }
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
 failed2:
     if (rc != 0)
@@ -1683,7 +1683,7 @@
 
     rm_free_unused_clients(sp, nv, NV_GET_FILE_PRIVATE(file));
 
-    down(&nvl->at_lock);
+    mutex_lock(&nvl->at_lock);
     if (nvl->alloc_queue != NULL)
     {
         nv_alloc_t *at = nvl->alloc_queue, *next;
@@ -1695,22 +1695,22 @@
                 (at->file == file))
             {
                 NV_ATOMIC_INC(at->usage_count);
-                up(&nvl->at_lock);
+                mutex_unlock(&nvl->at_lock);
                 if (at->pid == os_get_current_process())
                     NV_PRINT_AT(NV_DBG_MEMINFO, at);
                 nv_free_pages(nv, at->num_pages,
                               NV_ALLOC_MAPPING_CONTIG(at->flags),
                               NV_ALLOC_MAPPING(at->flags),
                               (void *)at);
-                down(&nvl->at_lock);
+                mutex_lock(&nvl->at_lock);
                 next = nvl->alloc_queue; /* start over */
             }
             at = next;
         }
     }
-    up(&nvl->at_lock);
+    mutex_unlock(&nvl->at_lock);
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
     if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
     {
         if (NV_IS_GVI_DEVICE(nv))
@@ -1772,7 +1772,7 @@
         /* leave INIT flag alone so we don't reinit every time */
         nv->flags &= ~NV_FLAG_OPEN;
     }
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     for (i = 0; i < NV_FOPS_STACK_INDEX_COUNT; ++i)
     {
@@ -1847,7 +1847,7 @@
     nv_printf(NV_DBG_INFO, "NVRM: ioctl(0x%x, 0x%x, 0x%x)\n",
         _IOC_NR(cmd), (unsigned int) i_arg, _IOC_SIZE(cmd));
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
     sp = nvfp->fops_sp[NV_FOPS_STACK_INDEX_IOCTL];
 
     NV_CHECK_PCI_CONFIG_SPACE(sp, nv, TRUE, TRUE, NV_MAY_SLEEP());
@@ -2002,7 +2002,7 @@
     }
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
     if (arg_copy != NULL)
     {
         if (status != -EFAULT)
@@ -2119,7 +2119,7 @@
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_open\n");
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
 
     /* save the nv away in file->private_data */
     nvfp->nvptr = nvl;
@@ -2139,7 +2139,7 @@
     }
 
     NV_ATOMIC_INC(nvl->usage_count);
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     return 0;
 }
@@ -2163,7 +2163,7 @@
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_close\n");
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
     if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
     {
         nv->flags &= ~NV_FLAG_OPEN;
@@ -2175,7 +2175,7 @@
                 "NVRM: failed to unregister from the ACPI subsystem!\n");
         }
     }
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     rm_free_unused_clients(sp, nv, NV_GET_FILE_PRIVATE(file));
 
@@ -2333,7 +2333,7 @@
     nv_linux_state_t *nvl = NV_GET_NVL_FROM_NV_STATE(nv);
     NvU32 i, offset, page_idx=0;
 
-    down(&nvl->at_lock);
+    mutex_lock(&nvl->at_lock);
     at = nv_find_alloc(nvl, address, NV_ALLOC_TYPE_PCI);
     if (at != NULL)
     {
@@ -2352,20 +2352,26 @@
 
         if (i == at->num_pages) /* not found */
         {
-            up(&nvl->at_lock);
+            mutex_unlock(&nvl->at_lock);
             return NULL;
         }
     }
     else
     {
-        up(&nvl->at_lock);
+        mutex_unlock(&nvl->at_lock);
         return NULL;
     }
-    up(&nvl->at_lock);
+    if (at->page_table[i]->virt_addr == 0)
+    {
+        mutex_unlock(&nvl->at_lock);
+        return NULL;
+    }
+    mutex_unlock(&nvl->at_lock);
 
     if (((size + offset) <= PAGE_SIZE) && !NV_ALLOC_MAPPING_GUEST(at->flags))
     {
         *priv_data = NULL;
+        mutex_unlock(&nvl->at_lock);   
         return (void *)(at->page_table[i]->virt_addr + offset);
     }
     else
@@ -2533,7 +2539,7 @@
         "NVRM: VM: nv_free_pages: 0x%llx 0x%x\n", at->key, page_count);
 
     /* only lock ldata while removing 'at' from the list */
-    down(&nvl->at_lock);
+    mutex_lock(&nvl->at_lock);
 
     NV_PRINT_AT(NV_DBG_MEMINFO, at);
 
@@ -2548,12 +2554,12 @@
      */
     if (!NV_ATOMIC_DEC_AND_TEST(at->usage_count))
     {
-        up(&nvl->at_lock);
+        mutex_unlock(&nvl->at_lock);
         return RM_OK;
     }
 
     nvl_remove_alloc(nvl, at);
-    up(&nvl->at_lock);
+    mutex_unlock(&nvl->at_lock);
 
     if (!NV_ALLOC_MAPPING_GUEST(at->flags))
     {
@@ -2618,9 +2624,9 @@
     }
 
     nvfp->event_pending = TRUE;
-    wake_up_interruptible(&nvfp->waitqueue);
-
     NV_SPIN_UNLOCK_IRQRESTORE(&nvfp->fp_lock, eflags);
+
+    wake_up_interruptible(&nvfp->waitqueue);
 }
 
 int NV_API_CALL nv_get_event(
@@ -3172,7 +3178,7 @@
     /* Remove proc entry for this GPU */
     nv_procfs_remove_gpu(nvl);
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
     UNLOCK_NV_LINUX_DEVICES();
 
 #if !defined(NV_VMWARE)
diff -Naur a/nv-linux.h b/nv-linux.h
--- a/nv-linux.h	2013-12-04 23:42:53.000000000 +0100
+++ b/nv-linux.h	2013-12-04 20:57:00.000000000 +0100
@@ -139,11 +139,6 @@
 #endif
 
 #include <linux/spinlock.h>
-#if defined(NV_LINUX_SEMAPHORE_H_PRESENT)
-#include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
 #include <linux/completion.h>
 #include <linux/highmem.h>
 
@@ -944,19 +939,7 @@
     return ret;
 }
 
-#if defined(CONFIG_PREEMPT_RT_FULL)
-#define NV_INIT_MUTEX(mutex) sema_init(mutex,1)
-#else
-#if !defined(__SEMAPHORE_INITIALIZER) && defined(__COMPAT_SEMAPHORE_INITIALIZER)
-#define __SEMAPHORE_INITIALIZER __COMPAT_SEMAPHORE_INITIALIZER
-#endif
-#define NV_INIT_MUTEX(mutex)                       \
-    {                                              \
-        struct semaphore __mutex =                 \
-            __SEMAPHORE_INITIALIZER(*(mutex), 1);  \
-        *(mutex) = __mutex;                        \
-    }
-#endif
+#define NV_INIT_MUTEX(mutex) mutex_init(mutex)
 
 #if !defined(NV_VMWARE)
 #if defined(NV_GET_NUM_PHYSPAGES_PRESENT)
@@ -1508,13 +1491,13 @@
     struct timer_list rc_timer;
 
     /* lock for linux-specific data, not used by core rm */
-    struct semaphore ldata_lock;
+    struct mutex ldata_lock;
 
     /* proc directory information */
     struct proc_dir_entry *proc_dir;
 
     /* lock for linux-specific alloc queue */
-    struct semaphore at_lock;
+    struct mutex at_lock;
 
     NvU32 minor_num;
     struct nv_linux_state_s *next;
@@ -1577,7 +1560,7 @@
 {
     nv_stack_t *sp;
     nv_stack_t *fops_sp[NV_FOPS_STACK_INDEX_COUNT];
-    struct semaphore fops_sp_lock[NV_FOPS_STACK_INDEX_COUNT];
+    struct mutex fops_sp_lock[NV_FOPS_STACK_INDEX_COUNT];
     void *nvptr;
     void *proc_data;
     void *data;
diff -Naur a/nv-mmap.c b/nv-mmap.c
--- a/nv-mmap.c	2013-12-04 23:42:53.000000000 +0100
+++ b/nv-mmap.c	2013-03-04 20:57:00.000000000 +0100
@@ -227,7 +227,7 @@
 
     NV_PRINT_VMA(NV_DBG_MEMINFO, vma);
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
     sp = nvfp->fops_sp[NV_FOPS_STACK_INDEX_MMAP];
 
     NV_CHECK_PCI_CONFIG_SPACE(sp, nv, TRUE, TRUE, NV_MAY_SLEEP());
@@ -312,13 +312,13 @@
         unsigned long start = 0;
         unsigned int i, j;
 
-        down(&nvl->at_lock);
+        mutex_lock(&nvl->at_lock);
         at = nv_find_alloc(nvl, NV_VMA_OFFSET(vma), NV_ALLOC_TYPE_PCI);
 
         if (at == NULL)
         {
             static int count = 0;
-            up(&nvl->at_lock);
+            mutex_unlock(&nvl->at_lock);;
             if (count++ < NV_MAX_RECURRING_WARNING_MESSAGES)
             {
                 nv_printf(NV_DBG_ERRORS,
@@ -341,7 +341,7 @@
 
         if (i == at->num_pages)
         {
-            up(&nvl->at_lock);
+            mutex_unlock(&nvl->at_lock);;
             status = -EINVAL;
             goto done;
         }
@@ -350,7 +350,7 @@
         {
             nv_printf(NV_DBG_ERRORS,
                 "NVRM: requested mapping exceeds allocation's boundary!\n");
-            up(&nvl->at_lock);
+            mutex_unlock(&nvl->at_lock);;
             status = -EINVAL;
             goto done;
         }
@@ -359,14 +359,14 @@
                               NV_ALLOC_MAPPING(at->flags),
                               NV_MEMORY_TYPE_SYSTEM))
         {
-            up(&nvl->at_lock);
+            mutex_unlock(&nvl->at_lock);
             status = -ENXIO;
             goto done;
         }
 
         NV_VMA_PRIVATE(vma) = at;
         NV_ATOMIC_INC(at->usage_count);
-        up(&nvl->at_lock);
+        mutex_unlock(&nvl->at_lock);
 
         start = vma->vm_start;
         for (j = i; j < (i + pages); j++)
@@ -396,6 +396,6 @@
     NV_VMA_FILE(vma) = file;
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
     return status;
 }
diff -Naur a/os-interface.c b/os-interface.c
--- a/os-interface.c	2012-03-19 23:42:53.000000000 +0100
+++ b/os-interface.c	2012-03-20 21:06:25.000000000 +0100
@@ -26,7 +26,7 @@
     return RM_OK;
 }
 
-typedef struct semaphore os_mutex_t;
+typedef struct mutex os_mutex_t;
 
 //
 // os_alloc_mutex - Allocate the RM mutex
@@ -87,7 +87,7 @@
     {
         return RM_ERR_INVALID_REQUEST;
     }
-    down(os_mutex);
+    mutex_lock(os_mutex);
 
     return RM_OK;
 }
@@ -118,7 +118,7 @@
 )
 {
     os_mutex_t *os_mutex = (os_mutex_t *)pMutex;
-    up(os_mutex);
+    mutex_unlock(os_mutex);
 }
 
 typedef struct os_semaphore_s
--- a/nv-frontend.c	2013-12-03 23:27:15.289577015 -0500
+++ b/nv-frontend.c	2013-12-03 23:26:58.658576157 -0500
@@ -31,7 +31,7 @@
 static NvU32 nv_num_instances;
 
 // lock required to protect table.
-struct semaphore nv_module_table_lock;
+struct mutex nv_module_table_lock;
 
 // minor number table
 nvidia_module_t *nv_minor_num_table[NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX + 1];
@@ -133,7 +133,7 @@
     int rc = -1;
     NvU32 ctrl_minor_num;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     if (module->instance >= NV_MAX_MODULE_INSTANCES)
     {
         printk("NVRM: NVIDIA module instance %d registration failed.\n",
@@ -150,7 +150,7 @@
     nv_minor_num_table[ctrl_minor_num] = module;
     nv_num_instances++;
 done:
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -162,7 +162,7 @@
     NvU32 ctrl_minor_num;
     nv_linux_state_t *device = module->nv_linux_devices;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
 
     ctrl_minor_num = NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX - module->instance;
     if (nv_minor_num_table[ctrl_minor_num] == NULL)
@@ -182,7 +182,7 @@
         nv_num_instances--;
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -193,7 +193,7 @@
     int rc = -1;
     NvU32 ctrl_minor_num;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     ctrl_minor_num = NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX - module->instance;
     if (nv_minor_num_table[ctrl_minor_num] == NULL)
     {
@@ -205,7 +205,7 @@
     {
         rc = add_device(module, device, NV_FALSE);
     }
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -216,7 +216,7 @@
     int rc = 0;
     NvU32 ctrl_minor_num;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     ctrl_minor_num = NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX - module->instance;
     if (nv_minor_num_table[ctrl_minor_num] == NULL)
     {
@@ -228,7 +228,7 @@
     {
         rc = remove_device(module, device);
     }
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -244,7 +244,7 @@
 
     NvU32 minor_num = NV_FRONTEND_MINOR_NUMBER(inode);
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     module = nv_minor_num_table[minor_num];
 
     if ((module != NULL) && (module->open != NULL))
@@ -253,7 +253,7 @@
         // nvidia-frontend.ko does not get unloaded before the nvidiaN.ko modules.
         if (NV_BUILD_MODULE_INSTANCES != 0 && !try_module_get(module->owner))
         {
-            up(&nv_module_table_lock);
+            mutex_unlock(&nv_module_table_lock);
             return -ENODEV;
         }
         rc = module->open(inode, file);
@@ -262,7 +262,7 @@
                     __FUNCTION__, minor_num, rc);
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
     return rc;
 }
 
@@ -276,7 +276,7 @@
 
     NvU32 minor_num = NV_FRONTEND_MINOR_NUMBER(inode);
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     module = nv_minor_num_table[minor_num];
 
     if ((module != NULL) && (module->close != NULL))
@@ -293,7 +293,7 @@
         }
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
     return rc;
 }
 
--- a/nv-procfs.c	2013-10-30 20:15:05.000000000 -0400
+++ b/nv-procfs.c	2013-12-04 11:56:03.067894803 -0500
@@ -354,7 +354,7 @@
     char *proc_buffer;
     unsigned long bytes_left;
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
 
     bytes_left = (NV_PROC_WRITE_BUFFER_SIZE - nvfp->off - 1);
 
@@ -384,7 +384,7 @@
     *pos = nvfp->off;
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
 
     return ((status < 0) ? status : (int)count);
 }
