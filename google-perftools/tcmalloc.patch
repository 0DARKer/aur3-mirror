--- src/debugallocation.cc.orig	2011-07-06 17:21:12.802398504 +0200
+++ src/debugallocation.cc	2011-07-06 17:21:20.772701874 +0200
@@ -1135,7 +1135,11 @@
   MallocHook::InvokeNewHook(p, size);
   return p;
 }
-void *(*__memalign_hook)(size_t, size_t, const void *) = MemalignOverride;
+
+#if !defined(__MALLOC_HOOK_VOLATILE)
+#define __MALLOC_HOOK_VOLATILE
+#endif
+void *(*__MALLOC_HOOK_VOLATILE __memalign_hook)(size_t, size_t, const void *) = MemalignOverride;
 
 extern "C" void* memalign(size_t align, size_t size) __THROW {
   void *p = do_debug_memalign(align, size);
--- src/tcmalloc.cc.orig	2011-07-06 17:20:59.715233706 +0200
+++ src/tcmalloc.cc	2011-07-06 17:21:06.675498632 +0200
@@ -137,6 +137,13 @@
 # define WIN32_DO_PATCHING 1
 #endif
 
+// GLibc 2.14+ requires the hook functions be declared volatile, based on the value of the
+// define __MALLOC_HOOK_VOLATILE. For compatibility with older/non-GLibc implementations,
+// provide an empty definition.
+#if !defined(__MALLOC_HOOK_VOLATILE)
+#define __MALLOC_HOOK_VOLATILE
+#endif
+
 using STL_NAMESPACE::max;
 using STL_NAMESPACE::numeric_limits;
 using STL_NAMESPACE::vector;
@@ -1669,5 +1676,5 @@
   MallocHook::InvokeNewHook(result, size);
   return result;
 }
-void *(*__memalign_hook)(size_t, size_t, const void *) = MemalignOverride;
+void *(*__MALLOC_HOOK_VOLATILE __memalign_hook)(size_t, size_t, const void *) = MemalignOverride;
 #endif  // #ifndef TCMALLOC_FOR_DEBUGALLOCATION
